filename,contest_id,contract_name,input_token,completion_token,total_token,execution_time,cost,contract_content,contract_size
RealWorld_TA_100_SingleStrategyController_RealWorld_20240812094041.log,100,SingleStrategyController,69783,3708,73491,87.0,0.423075,"// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.7;

import ""./interfaces/IStrategy.sol"";
import ""./interfaces/IStrategyController.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract SingleStrategyController is
    IStrategyController,
    Ownable,
    ReentrancyGuard
{
    using SafeERC20 for IERC20;

    address private _vault;
    IStrategy private _strategy;
    IERC20 private immutable _baseToken;

    modifier onlyVault() {
        require(msg.sender == _vault, ""Caller is not the vault"");
        _;
    }

    constructor(IERC20 _token) {
        require(address(_token) != address(0), ""Zero address"");
        _baseToken = _token;
    }

    // Assumes approval to take `_amount` has already been given by vault
    function deposit(uint256 _amount)
        external
        override
        onlyVault
        nonReentrant
    {
        _baseToken.safeTransferFrom(_vault, address(this), _amount);
        _strategy.deposit(_baseToken.balanceOf(address(this)));
    }

    function withdraw(address _recipient, uint256 _amount)
        external
        override
        onlyVault
        nonReentrant
    {
        _strategy.withdraw(_recipient, _amount);
    }

    function migrate(IStrategy _newStrategy)
        external
        override
        onlyOwner
        nonReentrant
    {
        uint256 _oldStrategyBalance;
        IStrategy _oldStrategy = _strategy;
        _strategy = _newStrategy;
        _baseToken.approve(address(_newStrategy), type(uint256).max);
        if (address(_oldStrategy) != address(0)) {
            _baseToken.approve(address(_oldStrategy), 0);
            _oldStrategyBalance = _oldStrategy.totalValue();
            _oldStrategy.withdraw(address(this), _oldStrategyBalance);
            _newStrategy.deposit(_baseToken.balanceOf(address(this)));
        }
        emit StrategyMigrated(
            address(_oldStrategy),
            address(_newStrategy),
            _oldStrategyBalance
        );
    }

    function setVault(address _newVault) external override onlyOwner {
        _vault = _newVault;
        emit VaultChanged(_newVault);
    }

    function totalValue() external view override returns (uint256) {
        return _baseToken.balanceOf(address(this)) + _strategy.totalValue();
    }

    function getVault() external view override returns (address) {
        return _vault;
    }

    function getStrategy() external view override returns (IStrategy) {
        return _strategy;
    }

    function getBaseToken() external view override returns (IERC20) {
        return _baseToken;
    }
}",611
RealWorld_TA_100_IPrePOMarket_RealWorld_20240812095158.log,100,IPrePOMarket,193979,2728,196707,92.0,1.024455,"// SPDX-License-Identifier: GPL-3.0
pragma solidity =0.8.7;

import ""./ILongShortToken.sol"";
import ""./IStrategyController.sol"";

/**
 * @notice Users can mint/redeem long/short positions on a specific asset in
 * exchange for Collateral tokens.
 * @dev Position settlement prices are bound by a floor and ceiling set
 * during market initialization.
 *
 * The value of a Long and Short token should always equal 1 Collateral.
 */
interface IPrePOMarket {
    /// @dev Emitted via `constructor()`
    /// @param longToken Market Long token address
    /// @param shortToken Market Short token address
    /// @param shortToken Market Short token address
    /// @param floorLongPrice Long token price floor
    /// @param ceilingLongPrice Long token price ceiling
    /// @param floorValuation Market valuation floor
    /// @param ceilingValuation Market valuation ceiling
    /// @param mintingFee Market minting fee
    /// @param redemptionFee Market redemption fee
    /// @param expiryTime Market expiry time
    event MarketCreated(
        address longToken,
        address shortToken,
        uint256 floorLongPrice,
        uint256 ceilingLongPrice,
        uint256 floorValuation,
        uint256 ceilingValuation,
        uint256 mintingFee,
        uint256 redemptionFee,
        uint256 expiryTime
    );

    /// @dev Emitted via `mintLongShortTokens()`.
    /// @param minter The address of the minter
    /// @param amount The amount of Long/Short tokens minted
    event Mint(address indexed minter, uint256 amount);

    /// @dev Emitted via `redeem()`.
    /// @param redeemer The address of the redeemer
    /// @param amount The amount of Long/Short tokens redeemed
    event Redemption(address indexed redeemer, uint256 amount);

    /// @dev Emitted via `setTreasury()`.
    /// @param treasury The new treasury address
    event TreasuryChanged(address treasury);

    /// @dev Emitted via `setFinalLongPrice()`.
    /// @param price The final Long price
    event FinalLongPriceSet(uint256 price);

    /// @dev Emitted via `setMintingFee()`.
    /// @param fee The new minting fee
    event MintingFeeChanged(uint256 fee);

    /// @dev Emitted via `setRedemptionFee()`.
    /// @param fee The new redemption fee
    event RedemptionFeeChanged(uint256 fee);

    /// @dev Emitted via `setPublicMinting()`.
    /// @param allowed The new public minting status
    event PublicMintingChanged(bool allowed);

    /**
     * @notice Mints Long and Short tokens in exchange for `amount`
     * Collateral.
     * @dev Minting is not allowed after the market has ended.
     *
     * `owner()` may mint tokens before PublicMinting is enabled to
     * bootstrap a market with an initial supply.
     * @param amount Amount of Collateral to deposit
     * @return Long/Short tokens minted
     */
    function mintLongShortTokens(uint256 amount) external returns (uint256);

    /**
     * @notice Redeem `longAmount` Long and `shortAmount` Short tokens for
     * Collateral.
     * @dev Before the market ends, redemptions can only be done with equal
     * parts N Long/Short tokens for N Collateral.
     *
     * After the market has ended, users can redeem any amount of
     * Long/Short tokens for Collateral.
     * @param longAmount Amount of Long tokens to redeem
     * @param shortAmount Amount of Short tokens to redeem
     */
    function redeem(uint256 longAmount, uint256 shortAmount) external;

    /**
     * @notice Sets the treasury address minting/redemption fees are sent to.
     * @dev Only callable by `owner()`.
     * @param newTreasury New treasury address
     */
    function setTreasury(address newTreasury) external;

    /**
     * @notice Sets the price a Long token can be redeemed for after the
     * market has ended (in wei units of Collateral).
     * @dev The contract initializes this to > MAX_PRICE and knows the market
     * has ended when it is set to <= MAX_PRICE.
     *
     * Only callable by `owner()`.
     * @param newFinalLongPrice Price to set Long token redemptions
     */
    function setFinalLongPrice(uint256 newFinalLongPrice) external;

    /**
     * @notice Sets the fee for minting Long/Short tokens, must be a 4
     * decimal place percentage value e.g. 4.9999% = 49999.
     * @dev Only callable by `owner()`.
     * @param newMintingFee New minting fee
     */
    function setMintingFee(uint256 newMintingFee) external;

    /**
     * @notice Sets the fee for redeeming Long/Short tokens, must be a 4
     * decimal place percentage value e.g. 4.9999% = 49999.
     * @dev Only callable by `owner()`.
     * @param newRedemptionFee New redemption fee
     */
    function setRedemptionFee(uint256 newRedemptionFee) external;

    /**
     * @notice Sets whether or not everyone is allowed to mint Long/Short
     * tokens.
     * @dev Only callable by `owner()`.
     * @param allowed Whether or not to allow everyone to mint Long/Short
     */
    function setPublicMinting(bool allowed) external;

    /// @return Treasury address where minting/redemption fees are sent
    function getTreasury() external view returns (address);

    /// @return Collateral token used to fund Long/Short positions
    function getCollateral() external view returns (IERC20);

    /**
     * @dev The PrePOMarket is the owner of this token contract.
     * @return Long token for this market
     */
    function getLongToken() external view returns (ILongShortToken);

    /**
     * @dev The PrePOMarket is the owner of this token contract.
     * @return Short token for this market
     */
    function getShortToken() external view returns (ILongShortToken);

    /**
     * @notice Returns the lower bound of what a Long token can be priced at
     * (in wei units of Collateral).
     * @dev Must be less than ceilingLongPrice and MAX_PRICE.
     * @return Minimum Long token price
     */
    function getFloorLongPrice() external view returns (uint256);

    /**
     * @notice Returns the upper bound of what a Long token can be priced at
     * (in wei units of Collateral).
     * @dev Must be less than MAX_PRICE.
     * @return Maximum Long token price
     */
    function getCeilingLongPrice() external view returns (uint256);

    /**
     * @notice Returns the price a Long token can be redeemed for after the
     * market has ended (in wei units of Collateral).
     * @dev The contract initializes this to > MAX_PRICE and knows the market
     * has ended when it is set to <= MAX_PRICE.
     * @return Final Long token price
     */
    function getFinalLongPrice() external view returns (uint256);

    /**
     * @notice Returns valuation of a market when the price of a Long
     * token is at the floor.
     * @return Market valuation floor
     */
    function getFloorValuation() external view returns (uint256);

    /**
     * @notice Returns valuation of a market when the price of a Long
     * token is at the ceiling.
     * @return Market valuation ceiling
     */
    function getCeilingValuation() external view returns (uint256);

    /**
     * @notice Returns the fee for minting Long/Short tokens as a 4 decimal
     * place percentage value e.g. 4.9999% = 49999.
     * @return Minting fee
     */
    function getMintingFee() external view returns (uint256);

    /**
     * @notice Returns the fee for redeeming Long/Short tokens as a 4 decimal
     * place percentage value e.g. 4.9999% = 49999.
     * @return Redemption fee
     */
    function getRedemptionFee() external view returns (uint256);

    /**
     * @notice Returns the timestamp of when the market will expire.
     * @return Market expiry timestamp
     */
    function getExpiryTime() external view returns (uint256);

    /**
     * @notice Returns whether Long/Short token minting is open to everyone.
     * @dev If true, anyone can mint Long/Short tokens, if false, only
     * `owner()` may mint.
     * @return Whether or not public minting is allowed
     */
    function isPublicMintingAllowed() external view returns (bool);

    /**
     * @notice Long prices cannot exceed this value, equivalent to 1 ether
     * unit of Collateral.
     * @return Max Long token price
     */
    function getMaxPrice() external pure returns (uint256);

    /**
     * @notice Returns the denominator for calculating fees from 4 decimal
     * place percentage values e.g. 4.9999% = 49999.
     * @return Denominator for calculating fees
     */
    function getFeeDenominator() external pure returns (uint256);

    /**
     * @notice Fee limit of 5% represented as 4 decimal place percentage
     * value e.g. 4.9999% = 49999.
     * @return Fee limit
     */
    function getFeeLimit() external pure returns (uint256);
}",2095
RealWorld_TA_100_IAccountAccessController_RealWorld_20240812095039.log,100,IAccountAccessController,85606,2248,87854,77.0,0.47299,"// SPDX-License-Identifier: UNLICENSED

pragma solidity =0.8.7;

/**
 * @notice The Access Controller is used for allowing/blocking access to
 * contract functions.
 */
interface IAccountAccessController {
    /**
     * @dev Emitted via `setRoot()`.
     * @param root The new merkle root
     */
    event RootChanged(bytes32 root);

    /**
     * @dev Emitted via `allowAccounts()` and `allowSelf`.
     * @param account The account that was allowed
     */
    event AccountAllowed(address indexed account);

    /**
     * @dev Emitted via `blockAccounts()`.
     * @param account The account that was blocked
     */
    event AccountBlocked(address indexed account);

    /**
     * @dev Emitted via `setRoot()` and `clearAllowedAccounts`,
     * and `setRootAndClearAllowedAccounts`.
     * @param index The index for the new allowlist
     */
    event AllowedAccountsCleared(uint32 index);

    /**
     * @dev Emitted via `clearBlockedAccounts`.
     * @param index The index for the new blocklist
     */
    event BlockedAccountsCleared(uint32 index);

    /**
     * @notice Sets the merkle root used to determine which accounts
     * to allow.
     * @dev Only callable by `owner()`.
     * @param newRoot The new merkle root
     */
    function setRoot(bytes32 newRoot) external;

    /**
     * @notice Clears the allowlist for all accounts.
     * @dev This does not actually modify any existing allowlists, the
     * the function will increment an index pointing to a new mapping
     * that will be referenced.
     *
     * Only callable by `owner()`.
     */
    function clearAllowedAccounts() external;

    /**
     * @notice Sets the merkle root used to determine which accounts
     * to allow and resets the allowlist.
     * @dev Only callable by `owner()`.
     * @param newRoot The new merkle root
     */
    function setRootAndClearAllowedAccounts(bytes32 newRoot) external;

    /**
     * @notice Clears the blocklist for all accounts.
     * @dev This does not actually modify any existing blocklists, the
     * the function will increment an index pointing to a new mapping
     * that will be referenced.
     *
     * Only callable by `owner()`.
     */
    function clearBlockedAccounts() external;

    /**
     * @notice Allows one or more accounts, regardless of existing access.
     * @dev Only callable by `owner()`.
     * @param accounts Accounts to allow
     */
    function allowAccounts(address[] calldata accounts) external;

    /**
     * @notice Blocks one or more accounts, regardless of existing access.
     * @dev Only callable by `owner()`.
     * @param accounts Accounts to block
     */
    function blockAccounts(address[] calldata accounts) external;

    /**
     * @notice Allows the caller if the provided signature is valid.
     * @dev An account cannot call this function if it is already
     * allowed/blocked.
     * @param proof Proof of the caller's inclusion in the merkle root
     */
    function allowSelf(bytes32[] calldata proof) external;

    /**
     * @notice Returns the merkle root used to determine which accounts
     * to allow.
     * @return The current merkle root
     */
    function getRoot() external view returns (bytes32);

    /**
     * @return Whether the account is allowed
     */
    function isAccountAllowed(address account) external view returns (bool);

    /**
     * @return Whether the account is blocked
     */
    function isAccountBlocked(address account) external view returns (bool);
}",791
RealWorld_TA_100_IStrategy_RealWorld_20240812095332.log,100,IStrategy,52936,1903,54839,68.0,0.30274,"// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.7;

import ""../interfaces/IStrategyController.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

/**
 * @notice Strategy that deploys Base Token to earn yield denominated in Base
 * Token.
 * @dev `owner()` can call emergency functions and setters, only controller
 * can call deposit/withdraw.
 */
interface IStrategy {
    /**
     * @notice Deposits `amount` Base Token into the strategy.
     * @dev Assumes the StrategyController has given infinite spend approval
     * to the strategy.
     * @param amount Amount of Base Token to deposit
     */
    function deposit(uint256 amount) external;

    /**
     * @notice Withdraws `amount` Base Token from the strategy to `recipient`.
     * @dev This withdrawal is optimistic, returned amount might be less than
     * the amount specified.
     * @param recipient Address to receive the Base Token
     * @param amount Amount of Base Token to withdraw
     */
    function withdraw(address recipient, uint256 amount) external;

    /**
     * @notice Returns the Base Token balance of this contract and
     * the estimated value of deployed assets.
     * @return Total value of assets within the strategy
     */
    function totalValue() external view returns (uint256);

    /**
     * @notice Returns the Strategy Controller that intermediates interactions
     * between a vault and this strategy.
     * @dev Functions with the `onlyController` modifier can only be called by
     * this Strategy Controller.
     * @return The Strategy Controller address
     */
    function getController() external view returns (IStrategyController);

    /**
     * @notice The ERC20 asset that this strategy utilizes to earn yield and
     * return profits with.
     * @return The Base Token address
     */
    function getBaseToken() external view returns (IERC20);
}",410
RealWorld_TA_100_WithdrawHook_RealWorld_20240812093330.log,100,WithdrawHook,40322,2700,43022,73.0,0.25561,"// SPDX-License-Identifier: UNLICENSED
import ""./interfaces/IHook.sol"";
import ""./interfaces/ICollateralDepositRecord.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

pragma solidity =0.8.7;

contract WithdrawHook is IHook, Ownable {
    address private _vault;
    ICollateralDepositRecord private _depositRecord;

    constructor(address _newDepositRecord) {
        _depositRecord = ICollateralDepositRecord(_newDepositRecord);
    }

    modifier onlyVault() {
        require(msg.sender == _vault, ""Caller is not the vault"");
        _;
    }

    function hook(
        address _sender,
        uint256 _initialAmount,
        uint256 _finalAmount
    ) external override onlyVault {
        _depositRecord.recordWithdrawal(_sender, _finalAmount);
    }

    function setVault(address _newVault) external override onlyOwner {
        _vault = _newVault;
        emit VaultChanged(_newVault);
    }

    function getVault() external view returns (address) {
        return _vault;
    }

    function getDepositRecord()
        external
        view
        returns (ICollateralDepositRecord)
    {
        return _depositRecord;
    }
}",257
RealWorld_TA_100_MockStrategy_RealWorld_20240812094739.log,100,MockStrategy,134126,4327,138453,105.0,0.75717,"// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.7;

import ""../interfaces/ILongShortToken.sol"";
import ""../interfaces/IStrategyController.sol"";
import ""../interfaces/IStrategy.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

contract MockStrategy is IStrategy, Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    IStrategyController private _controller;
    /**
     * This would be an IERC20 in a real strategy, but we are using
     * ILongShortToken due to this being a mock strategy that needs
     * to mint/burn its `_baseToken`
     */
    ILongShortToken private _baseToken;

    /**
     * This would not exist in an actual strategy since strategies are vault
     * agnostic, only exists because we need to know vault shares supply to
     * simulate a `totalValue()`
     */
    IERC20 public vault;
    // Timestamp to denote when virtual yield can begin to accumulate
    uint256 public beginning;
    /**
     * Integer percent APY for mock strategy, editable in case we need to
     * modify later for testnet
     */
    uint256 public apy;
    // Virtual value of a vault share is initialized to 1 `_baseToken`
    uint256 public constant INITIAL_SHARE_VALUE = 1e18;

    event VaultChanged(address vault);

    modifier onlyController() {
        require(
            msg.sender == address(_controller),
            ""Caller is not the controller""
        );
        _;
    }

    constructor(address _newController, address _newBaseToken) {
        _controller = IStrategyController(_newController);
        _baseToken = ILongShortToken(_newBaseToken);
        beginning = block.timestamp;
    }

    /**
     * `_baseToken` must blacklist users besides governance and controller
     * from sending to this contract to prevent unwanted share inflation from
     * users directly sending funds to the strategy
     */
    function deposit(uint256 _amount) external override onlyController {
        uint256 _actualBalance = _baseToken.balanceOf(address(this));
        uint256 _virtualBalance = _getVirtualBalance();
        if (_actualBalance > 0) {
            /**
             * Bring `_baseToken` balance in line with our expected virtual
             * balance, this is so that the difference in `totalValue()`
             * before/after reflects the deposit amount
             */
            if (_virtualBalance > _actualBalance) {
                require(
                    _baseToken.owner() == address(this),
                    ""Strategy must be baseToken owner""
                );
                /**
                 * Mint tokens to bring `_baseToken` balance up to
                 * `_virtualBalance` before deposit
                 */
                _baseToken.mint(
                    address(this),
                    _virtualBalance - _actualBalance
                );
            }
        }
        IERC20(_baseToken).safeTransferFrom(
            address(_controller),
            address(this),
            _amount
        );
    }

    /**
     * We enforce `_baseToken` ownership here and not in the initializer since
     * we would have to deterministically figure out strategy deployment
     * address ahead of time
     */
    function withdraw(address _recipient, uint256 _amount)
        external
        override
        onlyController
    {
        require(
            _baseToken.owner() == address(this),
            ""Strategy must be baseToken owner""
        );
        if (_amount > _baseToken.balanceOf(address(this))) {
            uint256 _shortfall = _amount - _baseToken.balanceOf(address(this));
            _baseToken.mint(address(this), _shortfall);
        }
        IERC20(_baseToken).safeTransfer(_recipient, _amount);
    }

    function setVault(IERC20 _newVault) external onlyOwner {
        vault = _newVault;
        emit VaultChanged(address(vault));
    }

    /**
     * Initializes to current timestamp, changeable by governance if needed
     * later
     */
    function setBeginning(uint256 _beginning) external onlyOwner {
        beginning = _beginning;
    }

    /**
     * Virtual APY yields will be calculated from the starting value of
     * INITIAL_SHARE_VALUE
     */
    function setApy(uint256 _apy) external onlyOwner {
        apy = _apy;
    }

    /**
     * Virtual balance is the amount owed to all shareholders based on the
     * current timestamp and virtual APY. This returns the actual `_baseToken`
     * balance if it is greater than the `_virtualBalance`, which for this
     * mock strategy, will always be when a user deposits funds prior to
     * minting shares.
     *
     * After a user deposits funds via `deposit()`, `totalValue()`
     * should return the `_actualBalance` to allow Collateral to determine how
     * many shares to mint for a user. Once the shares are minted, the
     * `_virtualBalance` will once again surpass the `_actualBalance`.
     */
    function totalValue() external view override returns (uint256) {
        uint256 _actualBalance = _baseToken.balanceOf(address(this));
        uint256 _virtualBalance = _getVirtualBalance();
        if (_actualBalance > _virtualBalance) {
            return _actualBalance;
        } else {
            return _virtualBalance;
        }
    }

    function getController()
        external
        view
        override
        returns (IStrategyController)
    {
        return _controller;
    }

    function getBaseToken() external view override returns (IERC20) {
        return IERC20(_baseToken);
    }

    function _getVirtualBalance() internal view returns (uint256) {
        return
            (vault.totalSupply() * _currentShareValue()) / INITIAL_SHARE_VALUE;
    }

    /**
     * INITIAL_SHARE_VALUE is only being re-used here as a denominator for wei
     * token math.
     */
    function _currentShareValue() internal view returns (uint256) {
        uint256 _returnPerSecond = (INITIAL_SHARE_VALUE * apy) /
            100 /
            31536000;
        uint256 _timeDeployed = block.timestamp - beginning;
        return INITIAL_SHARE_VALUE + (_returnPerSecond * _timeDeployed);
    }
}",1372
RealWorld_TA_100_IStrategyController_RealWorld_20240812100010.log,100,IStrategyController,80239,3491,83730,88.0,0.471015,"// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.7;

import ""./IStrategy.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/**
 * @notice Strategy Controller acts as an intermediary between the Strategy
 * and the PrePO Collateral contract.
 *
 * The Collateral contract should never interact with the Strategy directly
 * and only perform operations via the Strategy Controller.
 */
interface IStrategyController {
    /// @dev Emitted via `setVault()`.
    /// @param vault The new vault address
    event VaultChanged(address vault);

    /// @dev Emitted via `migrate()`.
    /// @param oldStrategy The old strategy address
    /// @param newStrategy The new strategy address
    /// @param amount The amount migrated
    event StrategyMigrated(
        address oldStrategy,
        address newStrategy,
        uint256 amount
    );

    /**
     * @notice Deposits the specified amount of Base Token into the Strategy.
     * @dev Only the vault (Collateral contract) may call this function.
     *
     * Assumes approval to transfer amount from the Collateral contract
     * has been given.
     * @param amount Amount of Base Token to deposit
     */
    function deposit(uint256 amount) external;

    /**
     * @notice Withdraws the requested amount of Base Token from the Strategy
     * to the recipient.
     * @dev Only the vault (Collateral contract) may call this function.
     *
     * This withdrawal is optimistic, returned amount might be less than
     * the amount specified.
     * @param amount Amount of Base Token to withdraw
     * @param recipient Address to receive the Base Token
     */
    function withdraw(address recipient, uint256 amount) external;

    /**
     * @notice Migrates funds from currently configured Strategy to a new
     * Strategy and replaces it.
     * @dev If a Strategy is not already set, it sets the Controller's
     * Strategy to the new value with no funds being exchanged.
     *
     * Gives infinite Base Token approval to the new strategy and sets it
     * to zero for the old one.
     *
     * Only callable by `owner()`.
     * @param newStrategy Address of the new Strategy
     */
    function migrate(IStrategy newStrategy) external;

    /**
     * @notice Sets the vault that is allowed to deposit/withdraw through this
     * StrategyController.
     * @dev Only callable by `owner()`.
     * @param newVault Address of the new vault
     */
    function setVault(address newVault) external;

    /**
     * @notice Returns the Base Token balance of this contract and the
     * `totalValue()` returned by the Strategy.
     * @return The total value of assets within the strategy
     */
    function totalValue() external view returns (uint256);

    /**
     * @notice Returns the vault that is allowed to deposit/withdraw through
     * this Strategy Controller.
     * @return The vault address
     */
    function getVault() external view returns (address);

    /**
     * @notice Returns the ERC20 asset that this Strategy Controller supports
     * handling funds with.
     * @return The Base Token address
     */
    function getBaseToken() external view returns (IERC20);

    /**
     * @return The Strategy that this Strategy Controller manages
     */
    function getStrategy() external view returns (IStrategy);
}",725
RealWorld_TA_100_AccountAccessController_RealWorld_20240812093445.log,100,AccountAccessController,73132,2631,75763,82.0,0.41828,"// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.7;

import ""@openzeppelin/contracts/utils/cryptography/MerkleProof.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./interfaces/IAccountAccessController.sol"";

contract AccountAccessController is Ownable, IAccountAccessController {
    bytes32 private _root;
    uint16 internal _allowedAccountsIndex;
    uint16 internal _blockedAccountsIndex;
    mapping(uint16 => mapping(address => bool)) private _allowedAccounts;
    mapping(uint16 => mapping(address => bool)) private _blockedAccounts;

    constructor() {}

    function setRoot(bytes32 _newRoot) external override onlyOwner {
        _setRoot(_newRoot);
    }

    function clearAllowedAccounts() external override onlyOwner {
        _clearAllowedAccounts();
    }

    function setRootAndClearAllowedAccounts(bytes32 _newRoot)
        external
        override
        onlyOwner
    {
        _setRoot(_newRoot);
        _clearAllowedAccounts();
    }

    function clearBlockedAccounts() external override onlyOwner {
        _blockedAccountsIndex++;
        emit BlockedAccountsCleared(_blockedAccountsIndex);
    }

    function allowAccounts(address[] calldata _accounts)
        external
        override
        onlyOwner
    {
        for (uint256 _i = 0; _i < _accounts.length; _i++) {
            _allowedAccounts[_allowedAccountsIndex][_accounts[_i]] = true;
            emit AccountAllowed(_accounts[_i]);
        }
    }

    function blockAccounts(address[] calldata _accounts)
        external
        override
        onlyOwner
    {
        for (uint256 _i = 0; _i < _accounts.length; _i++) {
            _blockedAccounts[_blockedAccountsIndex][_accounts[_i]] = true;
            emit AccountBlocked(_accounts[_i]);
        }
    }

    function allowSelf(bytes32[] calldata _proof) external override {
        require(
            _allowedAccounts[_allowedAccountsIndex][msg.sender] == false,
            ""Account already registered""
        );
        bytes32 _leaf = keccak256(abi.encodePacked(msg.sender));

        require(MerkleProof.verify(_proof, _root, _leaf), ""Invalid proof"");
        _allowedAccounts[_allowedAccountsIndex][msg.sender] = true;
        emit AccountAllowed(msg.sender);
    }

    function getRoot() external view override returns (bytes32) {
        return _root;
    }

    function isAccountAllowed(address _account)
        external
        view
        override
        returns (bool)
    {
        return _allowedAccounts[_allowedAccountsIndex][_account];
    }

    function isAccountBlocked(address _account)
        external
        view
        override
        returns (bool)
    {
        return _blockedAccounts[_blockedAccountsIndex][_account];
    }

    function _setRoot(bytes32 _newRoot) internal {
        _root = _newRoot;
        emit RootChanged(_root);
    }

    function _clearAllowedAccounts() internal {
        _allowedAccountsIndex++;
        emit AllowedAccountsCleared(_allowedAccountsIndex);
    }
}",653
RealWorld_TA_100_MockAccountAccessController_RealWorld_20240812094518.log,100,MockAccountAccessController,25852,1653,27505,67.0,0.16232,"// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.7;

import ""../AccountAccessController.sol"";

contract MockAccountAccessController is AccountAccessController {
    constructor() {}

    function getAllowedAccountsIndex() external view returns (uint16) {
        return _allowedAccountsIndex;
    }

    function getBlockedAccountsIndex() external view returns (uint16) {
        return _blockedAccountsIndex;
    }
}",88
RealWorld_TA_100_TestCollateral_RealWorld_20240812094926.log,100,TestCollateral,22121,2170,24291,71.0,0.154005,"pragma solidity =0.8.7;

import ""../Collateral.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol"";

contract TestCollateral is Collateral, MulticallUpgradeable {}",48
RealWorld_TA_100_ICollateral_RealWorld_20240812095712.log,100,ICollateral,203321,3072,206393,100.0,1.078045,"// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.7;

import ""./IHook.sol"";
import ""./IStrategyController.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";

/**
 * @notice Used for minting and redeeming prePO Collateral tokens. A
 * Collateral token is a share of a yield-bearing vault, its Base Token value
 * varying based on the current value of the vault's assets.
 */
interface ICollateral is IERC20Upgradeable {
    /**
     * @notice Used to keep track of whether or not a user has initiated a
     * withdrawal in a block prior to calling withdraw().
     * @member amount The requested amount of Collateral to withdraw.
     * @member blockNumber The block in which the request was made.
     */
    struct WithdrawalRequest {
        uint256 amount;
        uint256 blockNumber;
    }

    /// @dev Emitted via `setDepositsAllowed()`.
    /// @param allowed Whether deposits are allowed
    event DepositsAllowedChanged(bool allowed);

    /// @dev Emitted via `setWithdrawalsAllowed()`.
    /// @param allowed Whether withdrawals are allowed
    event WithdrawalsAllowedChanged(bool allowed);

    /// @dev Emitted via `setStrategyController()`.
    /// @param controller The address of the new Strategy Controller
    event StrategyControllerChanged(address controller);

    /// @dev Emitted via `setMintingFee()`.
    /// @param fee The new fee
    event MintingFeeChanged(uint256 fee);

    /// @dev Emitted via `setRedemptionFee()`.
    /// @param fee The new fee
    event RedemptionFeeChanged(uint256 fee);

    /// @dev Emitted via `setDelayedWithdrawal()`.
    /// @param enabled Whether or not delayed withdrawals are enabled
    event DelayedWithdrawalChanged(bool enabled);

    /// @dev Emitted via `setDelayedWithdrawalExpiry()`.
    /// @param expiry The new expiry
    event DelayedWithdrawalExpiryChanged(uint256 expiry);

    /// @dev Emitted via `setDepositHook()`.
    /// @param hook The new deposit hook
    event DepositHookChanged(address hook);

    /// @dev Emitted via `setWithdrawalHook()`.
    /// @param hook The new withdraw hook
    event WithdrawHookChanged(address hook);

    /**
     * @notice Mints Collateral tokens for `amount` Base Token.
     * @dev Assumes approval has been given by the user for the
     * Collateral contract to spend their funds.
     * @param amount The amount of Base Token to deposit
     * @return The amount of Collateral minted
     */
    function deposit(uint256 amount) external returns (uint256);

    /**
     * @notice Creates a request to allow a withdrawal for `amount` Collateral
     * in a later block.
     * @dev The user's balance must be >= the amount requested to
     * initiate a withdrawal. If this function is called when there is already
     * an existing withdrawal request, the existing request is overwritten
     * with the new `amount` and current block number.
     * @param amount The amount of Collateral to withdraw
     */
    function initiateWithdrawal(uint256 amount) external;

    /**
     * @notice Resets the existing withdrawal request on record for the caller.
     * @dev This call will not revert if a user doesn't have an existing
     * request and will simply reset the user's already empty request record.
     */
    function uninitiateWithdrawal() external;

    /**
     * @notice Burns `amount` Collateral tokens in exchange for Base Token.
     * @dev If `delayedWithdrawalExpiry` is non-zero, a withdrawal request
     * must be initiated in a prior block no more than
     * `delayedWithdrawalExpiry` blocks before. The amount specified in the
     * request must match the amount being withdrawn.
     * @param amount The amount of Collateral to burn
     * @return Amount of Base Token withdrawn
     */
    function withdraw(uint256 amount) external returns (uint256);

    /**
     * @notice Sets whether deposits to the Collateral vault are allowed.
     * @dev Only callable by `owner()`.
     * @param allowed Whether deposits are allowed
     */
    function setDepositsAllowed(bool allowed) external;

    /**
     * @notice Sets whether withdrawals from the Collateral vault are allowed.
     * @dev Only callable by `owner()`.
     * @param allowed Whether withdrawals are allowed
     */
    function setWithdrawalsAllowed(bool allowed) external;

    /**
     * @notice Sets the contract that controls which strategy funds are sent
     * to.
     * @dev Only callable by `owner()`.
     * @param newController Address of a contract implementing `IStrategyController`
     */
    function setStrategyController(IStrategyController newController) external;

    /**
     * @notice Sets the number of blocks to pass before expiring a withdrawal
     * request.
     * @dev If this is set to zero, withdrawal requests are ignored.
     *
     * Only callable by `owner()`.
     * @param expiry Blocks before expiring a withdrawal request
     */
    function setDelayedWithdrawalExpiry(uint256 expiry) external;

    /**
     * @notice Sets the fee for minting Collateral, must be a 4 decimal place
     * percentage value e.g. 4.9999% = 49999.
     * @dev Only callable by `owner()`.
     * @param newMintingFee The new fee for minting Collateral
     */
    function setMintingFee(uint256 newMintingFee) external;

    /**
     * @notice Sets the fee for redeeming Collateral, must be a 4 decimal place
     * percentage value e.g. 4.9999% = 49999.
     * @dev Only callable by `owner()`.
     * @param newRedemptionFee The new fee for redeeming Collateral
     */
    function setRedemptionFee(uint256 newRedemptionFee) external;

    /**
     * @notice Sets the contract implementing `IHook` that will be called
     * during the `deposit()` function.
     * @dev Only callable by `owner()`.
     * @param newDepositHook Address of a contract implementing `IHook`
     */
    function setDepositHook(IHook newDepositHook) external;

    /**
     * @notice Sets the contract implementing `IHook` that will be called
     * during the `withdraw()` function.
     * @dev Only callable by `owner()`.
     * @param newWithdrawHook Address of a contract implementing `IHook`
     */
    function setWithdrawHook(IHook newWithdrawHook) external;

    /// @return Whether deposits are allowed
    function getDepositsAllowed() external view returns (bool);

    /// @return Whether withdrawals are allowed
    function getWithdrawalsAllowed() external view returns (bool);

    /// @return Address where fees are sent to
    function getTreasury() external view returns (address);

    /**
     * @return Fee for minting Collateral
     * @dev Fee has four decimals places of percentage value precision
     * e.g. 4.9999% = 49999.
     */
    function getMintingFee() external view returns (uint256);

    /**
     * @return Fee for redeeming Collateral
     * @dev Fee has four decimals places of percentage value precision
     * e.g. 4.9999% = 49999.
     */
    function getRedemptionFee() external view returns (uint256);

    /**
     * @notice This asset will be required for minting Collateral, and
     * returned when redeeming Collateral.
     * @return The ERC20 token backing Collateral shares
     */
    function getBaseToken() external view returns (IERC20Upgradeable);

    /**
     * @notice The Strategy Controller intermediates any interactions between
     * this vault and a yield-earning strategy.
     * @return The current Strategy Controller
     */
    function getStrategyController()
        external
        view
        returns (IStrategyController);

    /**
     * @return Blocks that can pass before a withdrawal request expires
     */
    function getDelayedWithdrawalExpiry() external view returns (uint256);

    /// @return The withdrawal request on record for `account`
    function getWithdrawalRequest(address account)
        external
        view
        returns (WithdrawalRequest memory);

    /**
     * @return The `IHook` that runs during the `deposit()` function
     */
    function getDepositHook() external view returns (IHook);

    /**
     * @return The `IHook` that runs during the `withdraw()` function
     */
    function getWithdrawHook() external view returns (IHook);

    /**
     * @notice Gets the amount of Base Token received for redeeming `shares`
     * Collateral.
     * @param shares Amount of shares that would be redeemed
     * @return Amount of Base Token received
     */
    function getAmountForShares(uint256 shares)
        external
        view
        returns (uint256);

    /// @param amount Amount of Base Token that would be deposited
    /// @return Shares received for depositing `amount` Base Token
    function getSharesForAmount(uint256 amount)
        external
        view
        returns (uint256);

    /**
     * @notice Returns the sum of the contract's latent Base Token balance and
     * the estimated Base Token value of the strategy's assets.
     * @dev This call relies on the `totalValue()` returned by the
     * Strategy Controller. The Collateral vault trusts the Strategy Controller
     * to relay an accurate value of the Strategy's assets.
     * @return Total assets denominated in Base Token
     */
    function totalAssets() external view returns (uint256);

    /**
     * @notice Returns the denominator for calculating fees from 4 decimal
     * place percentage values e.g. 4.9999% = 49999.
     * @return Denominator
     */
    function getFeeDenominator() external pure returns (uint256);

    /**
     * @notice Returns the fee limit of 5% represented as 4 decimal place
     * percentage value e.g. 4.9999% = 49999.
     * @return Fee limit
     */
    function getFeeLimit() external pure returns (uint256);
}",2228
RealWorld_TA_100_IHook_RealWorld_20240812095600.log,100,IHook,46446,2019,48465,70.0,0.27261,"// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.7;

/// @notice Used for adding additional checks and/or data recording when
/// interacting with the Collateral vault.
interface IHook {
    /**
     * @dev Emitted via `setVault()`.
     * @param vault The new vault address
     */
    event VaultChanged(address vault);

    /**
     * @dev This hook should only contain calls to external contracts, where
     * the actual implementation and state of a feature will reside.
     *
     * `initialAmount` for `deposit()` and `withdraw()` is the `amount`
     * parameter passed in by the caller.
     *
     * `finalAmount` for `deposit()` is the Base Token amount provided by
     * the user and any latent contract balance that is included in the
     * deposit.
     *
     * `finalAmount` for `withdraw()` is the Base Token amount returned
     * by the configured Strategy.
     *
     * Only callable by the vault.
     * @param sender The account calling the Collateral vault
     * @param initialAmount The amount passed to the Collateral vault
     * @param finalAmount The amount actually involved in the transaction
     */
    function hook(
        address sender,
        uint256 initialAmount,
        uint256 finalAmount
    ) external;

    /**
     * @notice Sets the vault that will be allowed to call this hook.
     * @dev Only callable by owner().
     * @param newVault The vault address
     */
    function setVault(address newVault) external;
}",331
RealWorld_TA_100_IPrePOMarketFactory_RealWorld_20240812100141.log,100,IPrePOMarketFactory,86674,1804,88478,73.0,0.46945,"// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.7;

import ""./IPrePOMarket.sol"";

/**
 * @notice Deploys a PrePOMarket and two LongShortToken contracts to serve as
 * the token pair.
 */
interface IPrePOMarketFactory {
    /// @dev Emitted via `setCollateralValidity()`.
    /// @param collateral the collateral changed
    /// @param allowed whether the collateral is valid
    event CollateralValidityChanged(address collateral, bool allowed);

    /// @dev Emitted via `createMarket()`.
    /// @param market The market created
    /// @param longShortHash The market unique id
    event MarketAdded(address market, bytes32 longShortHash);

    /**
     * @notice Deploys a PrePOMarket with the given parameters and two
     * LongShortToken contracts to serve as the token pair.
     * @dev Parameters are all passed along to their respective arguments
     * in the PrePOMarket constructor.
     *
     * Token names are generated from `tokenNameSuffix` as the name
     * suffix and `tokenSymbolSuffix` as the symbol suffix.
     *
     * ""LONG ""/""SHORT "" are appended to respective names, ""L_""/""S_"" are
     * appended to respective symbols.
     *
     * e.g. preSTRIPE 100-200 30-September 2021 =>
     * LONG preSTRIPE 100-200 30-September-2021.
     *
     * e.g. preSTRIPE_100-200_30SEP21 => L_preSTRIPE_100-200_30SEP21.
     * @param tokenNameSuffix The name suffix for the token pair
     * @param tokenSymbolSuffix The symbol suffix for the token pair
     * @param collateral The address of the collateral token
     * @param governance The address of the governance contract
     * @param floorLongPrice The floor price for the Long token
     * @param ceilingLongPrice The ceiling price for the Long token
     * @param floorValuation The floor valuation for the Market
     * @param ceilingValuation The ceiling valuation for the Market
     * @param mintingFee The minting fee for Long/Short tokens
     * @param redemptionFee The redemption fee for Long/Short tokens
     * @param expiryTime The expiry time for the Market
     */
    function createMarket(
        string memory tokenNameSuffix,
        string memory tokenSymbolSuffix,
        address collateral,
        address governance,
        uint256 floorLongPrice,
        uint256 ceilingLongPrice,
        uint256 floorValuation,
        uint256 ceilingValuation,
        uint256 mintingFee,
        uint256 redemptionFee,
        uint256 expiryTime
    ) external;

    /**
     * @notice Sets whether a collateral contract is valid for assignment to
     * new PrePOMarkets.
     * @param collateral The address of the collateral contract
     * @param validity Whether the collateral contract should be valid
     */
    function setCollateralValidity(address collateral, bool validity) external;

    /**
     * @notice Returns whether collateral contract is valid for assignment to
     * new PrePOMarkets.
     * @param collateral The address of the collateral contract
     * @return Whether the collateral contract is valid
     */
    function isCollateralValid(address collateral)
        external
        view
        returns (bool);

    /**
     * @dev `longShortHash` is a keccak256 hash of the long token address and
     * short token address of the PrePOMarket.
     * @param longShortHash PrePOMarket unique identifier
     * @return PrePOMarket address corresponding to the market id
     */
    function getMarket(bytes32 longShortHash)
        external
        view
        returns (IPrePOMarket);
}",817
RealWorld_TA_100_PrePOMarket_RealWorld_20240812094328.log,100,PrePOMarket,196129,4261,200390,108.0,1.065865,"// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.7;

import ""./interfaces/ILongShortToken.sol"";
import ""./interfaces/IPrePOMarket.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract PrePOMarket is IPrePOMarket, Ownable, ReentrancyGuard {
    address private _treasury;

    IERC20 private immutable _collateral;
    ILongShortToken private immutable _longToken;
    ILongShortToken private immutable _shortToken;

    uint256 private immutable _floorLongPrice;
    uint256 private immutable _ceilingLongPrice;
    uint256 private _finalLongPrice;

    uint256 private immutable _floorValuation;
    uint256 private immutable _ceilingValuation;

    uint256 private _mintingFee;
    uint256 private _redemptionFee;

    uint256 private immutable _expiryTime;

    bool private _publicMinting;

    uint256 private constant MAX_PRICE = 1e18;
    uint256 private constant FEE_DENOMINATOR = 1000000;
    uint256 private constant FEE_LIMIT = 50000;

    /**
     * Assumes `_newCollateral`, `_newLongToken`, and `_newShortToken` are
     * valid, since they will be handled by the PrePOMarketFactory. The
     * treasury is initialized to governance due to stack limitations.
     *
     * Assumes that ownership of `_longToken` and `_shortToken` has been
     * transferred to this contract via `createMarket()` in
     * `PrePOMarketFactory.sol`.
     */
    constructor(
        address _governance,
        address _newCollateral,
        ILongShortToken _newLongToken,
        ILongShortToken _newShortToken,
        uint256 _newFloorLongPrice,
        uint256 _newCeilingLongPrice,
        uint256 _newFloorValuation,
        uint256 _newCeilingValuation,
        uint256 _newMintingFee,
        uint256 _newRedemptionFee,
        uint256 _newExpiryTime,
        bool _allowed
    ) {
        require(
            _newCeilingLongPrice > _newFloorLongPrice,
            ""Ceiling must exceed floor""
        );
        require(_newExpiryTime > block.timestamp, ""Invalid expiry"");
        require(_newMintingFee <= FEE_LIMIT, ""Exceeds fee limit"");
        require(_newRedemptionFee <= FEE_LIMIT, ""Exceeds fee limit"");
        require(_newCeilingLongPrice <= MAX_PRICE, ""Ceiling cannot exceed 1"");

        transferOwnership(_governance);
        _treasury = _governance;

        _collateral = IERC20(_newCollateral);
        _longToken = _newLongToken;
        _shortToken = _newShortToken;

        _floorLongPrice = _newFloorLongPrice;
        _ceilingLongPrice = _newCeilingLongPrice;
        _finalLongPrice = MAX_PRICE + 1;

        _floorValuation = _newFloorValuation;
        _ceilingValuation = _newCeilingValuation;

        _mintingFee = _newMintingFee;
        _redemptionFee = _newRedemptionFee;

        _expiryTime = _newExpiryTime;

        _publicMinting = _allowed;

        emit MarketCreated(
            address(_newLongToken),
            address(_newShortToken),
            _newFloorLongPrice,
            _newCeilingLongPrice,
            _newFloorValuation,
            _newCeilingValuation,
            _newMintingFee,
            _newRedemptionFee,
            _newExpiryTime
        );
    }

    function mintLongShortTokens(uint256 _amount)
        external
        override
        nonReentrant
        returns (uint256)
    {
        if (msg.sender != owner()) {
            require(_publicMinting, ""Public minting disabled"");
        }
        require(_finalLongPrice > MAX_PRICE, ""Market ended"");
        require(
            _collateral.balanceOf(msg.sender) >= _amount,
            ""Insufficient collateral""
        );
        /**
         * Add 1 to avoid rounding to zero, only process if user is minting
         * an amount large enough to pay a fee
         */
        uint256 _fee = (_amount * _mintingFee) / FEE_DENOMINATOR + 1;
        require(_amount > _fee, ""Minting amount too small"");
        _collateral.transferFrom(msg.sender, _treasury, _fee);
        _amount -= _fee;
        _collateral.transferFrom(msg.sender, address(this), _amount);
        _longToken.mint(msg.sender, _amount);
        _shortToken.mint(msg.sender, _amount);
        emit Mint(msg.sender, _amount);
        return _amount;
    }

    function redeem(uint256 _longAmount, uint256 _shortAmount)
        external
        override
        nonReentrant
    {
        require(
            _longToken.balanceOf(msg.sender) >= _longAmount,
            ""Insufficient long tokens""
        );
        require(
            _shortToken.balanceOf(msg.sender) >= _shortAmount,
            ""Insufficient short tokens""
        );

        uint256 _collateralOwed;
        if (_finalLongPrice <= MAX_PRICE) {
            uint256 _shortPrice = MAX_PRICE - _finalLongPrice;
            _collateralOwed =
                (_finalLongPrice * _longAmount + _shortPrice * _shortAmount) /
                MAX_PRICE;
        } else {
            require(
                _longAmount == _shortAmount,
                ""Long and Short must be equal""
            );
            _collateralOwed = _longAmount;
        }

        _longToken.burnFrom(msg.sender, _longAmount);
        _shortToken.burnFrom(msg.sender, _shortAmount);
        /**
         * Add 1 to avoid rounding to zero, only process if user is redeeming
         * an amount large enough to pay a fee
         */
        uint256 _fee = (_collateralOwed * _redemptionFee) /
            FEE_DENOMINATOR +
            1;
        require(_collateralOwed > _fee, ""Redemption amount too small"");
        _collateral.transfer(_treasury, _fee);
        _collateralOwed -= _fee;
        _collateral.transfer(msg.sender, _collateralOwed);

        emit Redemption(msg.sender, _collateralOwed);
    }

    function setTreasury(address _newTreasury) external override onlyOwner {
        _treasury = _newTreasury;
        emit TreasuryChanged(_newTreasury);
    }

    function setFinalLongPrice(uint256 _newFinalLongPrice)
        external
        override
        onlyOwner
    {
        require(
            _newFinalLongPrice >= _floorLongPrice,
            ""Price cannot be below floor""
        );
        require(
            _newFinalLongPrice <= _ceilingLongPrice,
            ""Price cannot exceed ceiling""
        );
        _finalLongPrice = _newFinalLongPrice;
        emit FinalLongPriceSet(_newFinalLongPrice);
    }

    function setMintingFee(uint256 _newMintingFee)
        external
        override
        onlyOwner
    {
        require(_newMintingFee <= FEE_LIMIT, ""Exceeds fee limit"");
        _mintingFee = _newMintingFee;
        emit MintingFeeChanged(_newMintingFee);
    }

    function setRedemptionFee(uint256 _newRedemptionFee)
        external
        override
        onlyOwner
    {
        require(_newRedemptionFee <= FEE_LIMIT, ""Exceeds fee limit"");
        _redemptionFee = _newRedemptionFee;
        emit RedemptionFeeChanged(_newRedemptionFee);
    }

    function setPublicMinting(bool _allowed) external override onlyOwner {
        _publicMinting = _allowed;
        emit PublicMintingChanged(_allowed);
    }

    function getTreasury() external view override returns (address) {
        return _treasury;
    }

    function getCollateral() external view override returns (IERC20) {
        return _collateral;
    }

    function getLongToken() external view override returns (ILongShortToken) {
        return _longToken;
    }

    function getShortToken() external view override returns (ILongShortToken) {
        return _shortToken;
    }

    function getFloorLongPrice() external view override returns (uint256) {
        return _floorLongPrice;
    }

    function getCeilingLongPrice() external view override returns (uint256) {
        return _ceilingLongPrice;
    }

    function getFinalLongPrice() external view override returns (uint256) {
        return _finalLongPrice;
    }

    function getFloorValuation() external view override returns (uint256) {
        return _floorValuation;
    }

    function getCeilingValuation() external view override returns (uint256) {
        return _ceilingValuation;
    }

    function getMintingFee() external view override returns (uint256) {
        return _mintingFee;
    }

    function getRedemptionFee() external view override returns (uint256) {
        return _redemptionFee;
    }

    function getExpiryTime() external view override returns (uint256) {
        return _expiryTime;
    }

    function isPublicMintingAllowed() external view override returns (bool) {
        return _publicMinting;
    }

    function getMaxPrice() external pure override returns (uint256) {
        return MAX_PRICE;
    }

    function getFeeDenominator() external pure override returns (uint256) {
        return FEE_DENOMINATOR;
    }

    function getFeeLimit() external pure override returns (uint256) {
        return FEE_LIMIT;
    }
}",2131
RealWorld_TA_100_MockERC20_RealWorld_20240812094627.log,100,MockERC20,26883,2115,28998,70.0,0.176715,"// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.7;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MockERC20 is ERC20, Ownable {
    constructor(string memory name_, string memory symbol_)
        ERC20(name_, symbol_)
    {}

    function mint(address _recipient, uint256 _amount) external onlyOwner {
        _mint(_recipient, _amount);
    }
}",105
RealWorld_TA_100_PrePOMarketFactory_RealWorld_20240812093206.log,100,PrePOMarketFactory,89584,2217,91801,82.0,0.49226,"// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.7;

import ""./LongShortToken.sol"";
import ""./PrePOMarket.sol"";
import ""./interfaces/ILongShortToken.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""./interfaces/IPrePOMarketFactory.sol"";

contract PrePOMarketFactory is
    IPrePOMarketFactory,
    OwnableUpgradeable,
    ReentrancyGuardUpgradeable
{
    mapping(address => bool) private _validCollateral;
    mapping(bytes32 => address) private _deployedMarkets;

    function initialize() public initializer {
        OwnableUpgradeable.__Ownable_init();
    }

    function isCollateralValid(address _collateral)
        external
        view
        override
        returns (bool)
    {
        return _validCollateral[_collateral];
    }

    function getMarket(bytes32 _longShortHash)
        external
        view
        override
        returns (IPrePOMarket)
    {
        return IPrePOMarket(_deployedMarkets[_longShortHash]);
    }

    function createMarket(
        string memory _tokenNameSuffix,
        string memory _tokenSymbolSuffix,
        address _governance,
        address _collateral,
        uint256 _floorLongPrice,
        uint256 _ceilingLongPrice,
        uint256 _floorValuation,
        uint256 _ceilingValuation,
        uint256 _mintingFee,
        uint256 _redemptionFee,
        uint256 _expiryTime
    ) external override onlyOwner nonReentrant {
        require(_validCollateral[_collateral], ""Invalid collateral"");

        (
            LongShortToken _longToken,
            LongShortToken _shortToken
        ) = _createPairTokens(_tokenNameSuffix, _tokenSymbolSuffix);
        bytes32 _salt = keccak256(abi.encodePacked(_longToken, _shortToken));

        PrePOMarket _newMarket = new PrePOMarket{salt: _salt}(
            _governance,
            _collateral,
            ILongShortToken(address(_longToken)),
            ILongShortToken(address(_shortToken)),
            _floorLongPrice,
            _ceilingLongPrice,
            _floorValuation,
            _ceilingValuation,
            _mintingFee,
            _redemptionFee,
            _expiryTime,
            false
        );
        _deployedMarkets[_salt] = address(_newMarket);

        _longToken.transferOwnership(address(_newMarket));
        _shortToken.transferOwnership(address(_newMarket));
        emit MarketAdded(address(_newMarket), _salt);
    }

    function setCollateralValidity(address _collateral, bool _validity)
        external
        override
        onlyOwner
    {
        _validCollateral[_collateral] = _validity;
        emit CollateralValidityChanged(_collateral, _validity);
    }

    function _createPairTokens(
        string memory _tokenNameSuffix,
        string memory _tokenSymbolSuffix
    )
        internal
        returns (LongShortToken _newLongToken, LongShortToken _newShortToken)
    {
        string memory _longTokenName = string(
            abi.encodePacked(""LONG"", "" "", _tokenNameSuffix)
        );
        string memory _shortTokenName = string(
            abi.encodePacked(""SHORT"", "" "", _tokenNameSuffix)
        );
        string memory _longTokenSymbol = string(
            abi.encodePacked(""L"", ""_"", _tokenSymbolSuffix)
        );
        string memory _shortTokenSymbol = string(
            abi.encodePacked(""S"", ""_"", _tokenSymbolSuffix)
        );
        _newLongToken = new LongShortToken(_longTokenName, _longTokenSymbol);
        _newShortToken = new LongShortToken(
            _shortTokenName,
            _shortTokenSymbol
        );
        return (_newLongToken, _newShortToken);
    }
}",872
RealWorld_TA_100_CollateralDepositRecord_RealWorld_20240812093917.log,100,CollateralDepositRecord,78383,3152,81535,82.0,0.454955,"// SPDX-License-Identifier: UNLICENSED
import ""./interfaces/ICollateralDepositRecord.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

pragma solidity =0.8.7;

contract CollateralDepositRecord is ICollateralDepositRecord, Ownable {
    uint256 private _globalDepositCap;
    uint256 private _globalDepositAmount;
    uint256 private _accountDepositCap;
    mapping(address => uint256) private _accountToNetDeposit;
    mapping(address => bool) private _allowedHooks;

    modifier onlyAllowedHooks() {
        require(_allowedHooks[msg.sender], ""Caller not allowed"");
        _;
    }

    constructor(uint256 _newGlobalDepositCap, uint256 _newAccountDepositCap) {
        _globalDepositCap = _newGlobalDepositCap;
        _accountDepositCap = _newAccountDepositCap;
    }

    function recordDeposit(address _sender, uint256 _amount)
        external
        override
        onlyAllowedHooks
    {
        require(
            _amount + _globalDepositAmount <= _globalDepositCap,
            ""Global deposit cap exceeded""
        );
        require(
            _amount + _accountToNetDeposit[_sender] <= _accountDepositCap,
            ""Account deposit cap exceeded""
        );
        _globalDepositAmount += _amount;
        _accountToNetDeposit[_sender] += _amount;
    }

    function recordWithdrawal(address _sender, uint256 _amount)
        external
        override
        onlyAllowedHooks
    {
        if (_globalDepositAmount > _amount) {
            _globalDepositAmount -= _amount;
        } else {
            _globalDepositAmount = 0;
        }
        if (_accountToNetDeposit[_sender] > _amount) {
            _accountToNetDeposit[_sender] -= _amount;
        } else {
            _accountToNetDeposit[_sender] = 0;
        }
    }

    function setGlobalDepositCap(uint256 _newGlobalDepositCap)
        external
        override
        onlyOwner
    {
        _globalDepositCap = _newGlobalDepositCap;
        emit GlobalDepositCapChanged(_globalDepositCap);
    }

    function setAccountDepositCap(uint256 _newAccountDepositCap)
        external
        override
        onlyOwner
    {
        _accountDepositCap = _newAccountDepositCap;
        emit AccountDepositCapChanged(_newAccountDepositCap);
    }

    function setAllowedHook(address _hook, bool _allowed)
        external
        override
        onlyOwner
    {
        _allowedHooks[_hook] = _allowed;
        emit AllowedHooksChanged(_hook, _allowed);
    }

    function getGlobalDepositCap() external view override returns (uint256) {
        return _globalDepositCap;
    }

    function getGlobalDepositAmount()
        external
        view
        override
        returns (uint256)
    {
        return _globalDepositAmount;
    }

    function getAccountDepositCap() external view override returns (uint256) {
        return _accountDepositCap;
    }

    function getNetDeposit(address _account)
        external
        view
        override
        returns (uint256)
    {
        return _accountToNetDeposit[_account];
    }

    function isHookAllowed(address _hook)
        external
        view
        override
        returns (bool)
    {
        return _allowedHooks[_hook];
    }
}",705
RealWorld_TA_100_Collateral_RealWorld_20240812093609.log,100,Collateral,218429,5561,223990,120.0,1.203365,"// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.7;

import ""./interfaces/ICollateral.sol"";
import ""./interfaces/IStrategyController.sol"";
import ""./interfaces/IHook.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

contract Collateral is
    ICollateral,
    ERC20Upgradeable,
    OwnableUpgradeable,
    ReentrancyGuardUpgradeable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    bool private _depositsAllowed;
    bool private _withdrawalsAllowed;
    address private _treasury;
    uint256 private _mintingFee;
    uint256 private _redemptionFee;
    IERC20Upgradeable private _baseToken;
    IStrategyController private _strategyController;

    uint256 private _delayedWithdrawalExpiry;
    mapping(address => WithdrawalRequest) private _accountToWithdrawalRequest;

    IHook private _depositHook;
    IHook private _withdrawHook;

    uint256 private constant FEE_DENOMINATOR = 1000000;
    uint256 private constant FEE_LIMIT = 50000;

    function initialize(address _newBaseToken, address _newTreasury)
        public
        initializer
    {
        __Ownable_init_unchained();
        __ReentrancyGuard_init_unchained();
        __ERC20_init_unchained(
            string(""prePO Collateral Token""),
            string(""preCT"")
        );
        _baseToken = IERC20Upgradeable(_newBaseToken);
        _treasury = _newTreasury;
    }

    function deposit(uint256 _amount)
        external
        override
        nonReentrant
        returns (uint256)
    {
        require(_depositsAllowed, ""Deposits not allowed"");
        _baseToken.safeTransferFrom(msg.sender, address(this), _amount);
        // Calculate fees and shares to mint including latent contract funds
        uint256 _amountToDeposit = _baseToken.balanceOf(address(this));
        // Record deposit before fee is taken
        if (address(_depositHook) != address(0)) {
            _depositHook.hook(msg.sender, _amount, _amountToDeposit);
        }
        /**
         * Add 1 to avoid rounding to zero, only process deposit if user is
         * depositing an amount large enough to pay a fee.
         */
        uint256 _fee = (_amountToDeposit * _mintingFee) / FEE_DENOMINATOR + 1;
        require(_amountToDeposit > _fee, ""Deposit amount too small"");
        _baseToken.safeTransfer(_treasury, _fee);
        _amountToDeposit -= _fee;

        uint256 _valueBefore = _strategyController.totalValue();
        _baseToken.approve(address(_strategyController), _amountToDeposit);
        _strategyController.deposit(_amountToDeposit);
        uint256 _valueAfter = _strategyController.totalValue();
        _amountToDeposit = _valueAfter - _valueBefore;

        uint256 _shares = 0;
        if (totalSupply() == 0) {
            _shares = _amountToDeposit;
        } else {
            /**
             * # of shares owed = amount deposited / cost per share, cost per
             * share = total supply / total value.
             */
            _shares = (_amountToDeposit * totalSupply()) / (_valueBefore);
        }
        _mint(msg.sender, _shares);
        return _shares;
    }

    function initiateWithdrawal(uint256 _amount) external override {
        /**
         * Checking the balance before initiation is necessary since a user
         * could initiate an unlimited withdrawal amount ahead of time,
         * negating the protection a delayed withdrawal offers.
         */
        require(balanceOf(msg.sender) >= _amount, ""Insufficient balance"");
        _accountToWithdrawalRequest[msg.sender].amount = _amount;
        _accountToWithdrawalRequest[msg.sender].blockNumber = block.number;
    }

    function uninitiateWithdrawal() external override {
        _accountToWithdrawalRequest[msg.sender].amount = 0;
        _accountToWithdrawalRequest[msg.sender].blockNumber = 0;
    }

    function _processDelayedWithdrawal(address _account, uint256 _amount)
        internal
    {
        /**
         * Verify that the withdrawal being processed matches what was
         * recorded during initiation.
         */
        require(
            _accountToWithdrawalRequest[_account].amount == _amount,
            ""Initiated amount does not match""
        );
        uint256 _recordedBlock = _accountToWithdrawalRequest[_account]
            .blockNumber;
        require(
            _recordedBlock + _delayedWithdrawalExpiry >= block.number,
            ""Must withdraw before expiry""
        );
        require(
            block.number > _recordedBlock,
            ""Must withdraw in a later block""
        );
        // Reset the initiation prior to withdrawal.
        _accountToWithdrawalRequest[_account].amount = 0;
        _accountToWithdrawalRequest[_account].blockNumber = 0;
    }

    function withdraw(uint256 _amount)
        external
        override
        nonReentrant
        returns (uint256)
    {
        require(_withdrawalsAllowed, ""Withdrawals not allowed"");
        if (_delayedWithdrawalExpiry != 0) {
            _processDelayedWithdrawal(msg.sender, _amount);
        }
        uint256 _owed = (_strategyController.totalValue() * _amount) /
            totalSupply();
        _burn(msg.sender, _amount);

        uint256 _balanceBefore = _baseToken.balanceOf(address(this));
        _strategyController.withdraw(address(this), _owed);
        uint256 _balanceAfter = _baseToken.balanceOf(address(this));

        uint256 _amountWithdrawn = _balanceAfter - _balanceBefore;
        // Record withdrawal before fee is taken
        if (address(_withdrawHook) != address(0)) {
            _withdrawHook.hook(msg.sender, _amount, _amountWithdrawn);
        }

        /**
         * Send redemption fee to the protocol treasury. Add 1 to avoid
         * rounding to zero, only process withdrawal if user is
         * withdrawing an amount large enough to pay a fee.
         */
        uint256 _fee = (_amountWithdrawn * _redemptionFee) /
            FEE_DENOMINATOR +
            1;
        require(_amountWithdrawn > _fee, ""Withdrawal amount too small"");
        _baseToken.safeTransfer(_treasury, _fee);
        _amountWithdrawn -= _fee;
        _baseToken.safeTransfer(msg.sender, _amountWithdrawn);
        return _amountWithdrawn;
    }

    function setDepositsAllowed(bool _allowed) external override onlyOwner {
        _depositsAllowed = _allowed;
        emit DepositsAllowedChanged(_allowed);
    }

    function setWithdrawalsAllowed(bool _allowed) external override onlyOwner {
        _withdrawalsAllowed = _allowed;
        emit WithdrawalsAllowedChanged(_allowed);
    }

    function setStrategyController(IStrategyController _newStrategyController)
        external
        override
        onlyOwner
    {
        _strategyController = _newStrategyController;
        emit StrategyControllerChanged(address(_strategyController));
    }

    function setDelayedWithdrawalExpiry(uint256 _newDelayedWithdrawalExpiry)
        external
        override
        onlyOwner
    {
        _delayedWithdrawalExpiry = _newDelayedWithdrawalExpiry;
        emit DelayedWithdrawalExpiryChanged(_delayedWithdrawalExpiry);
    }

    function setMintingFee(uint256 _newMintingFee)
        external
        override
        onlyOwner
    {
        require(_newMintingFee <= FEE_LIMIT, ""Exceeds fee limit"");
        _mintingFee = _newMintingFee;
        emit MintingFeeChanged(_mintingFee);
    }

    function setRedemptionFee(uint256 _newRedemptionFee)
        external
        override
        onlyOwner
    {
        require(_newRedemptionFee <= FEE_LIMIT, ""Exceeds fee limit"");
        _redemptionFee = _newRedemptionFee;
        emit RedemptionFeeChanged(_redemptionFee);
    }

    function setDepositHook(IHook _newDepositHook)
        external
        override
        onlyOwner
    {
        _depositHook = _newDepositHook;
        emit DepositHookChanged(address(_depositHook));
    }

    function setWithdrawHook(IHook _newWithdrawHook)
        external
        override
        onlyOwner
    {
        _withdrawHook = _newWithdrawHook;
        emit WithdrawHookChanged(address(_withdrawHook));
    }

    function getDepositsAllowed() external view override returns (bool) {
        return _depositsAllowed;
    }

    function getWithdrawalsAllowed() external view override returns (bool) {
        return _withdrawalsAllowed;
    }

    function getTreasury() external view override returns (address) {
        return _treasury;
    }

    function getMintingFee() external view override returns (uint256) {
        return _mintingFee;
    }

    function getRedemptionFee() external view override returns (uint256) {
        return _redemptionFee;
    }

    function getBaseToken()
        external
        view
        override
        returns (IERC20Upgradeable)
    {
        return _baseToken;
    }

    function getStrategyController()
        external
        view
        override
        returns (IStrategyController)
    {
        return _strategyController;
    }

    function getDelayedWithdrawalExpiry()
        external
        view
        override
        returns (uint256)
    {
        return _delayedWithdrawalExpiry;
    }

    function getWithdrawalRequest(address _account)
        external
        view
        override
        returns (WithdrawalRequest memory)
    {
        return _accountToWithdrawalRequest[_account];
    }

    function getDepositHook() external view override returns (IHook) {
        return _depositHook;
    }

    function getWithdrawHook() external view override returns (IHook) {
        return _withdrawHook;
    }

    function getAmountForShares(uint256 _shares)
        external
        view
        override
        returns (uint256)
    {
        if (totalSupply() == 0) {
            return _shares;
        }
        return (_shares * totalAssets()) / totalSupply();
    }

    function getSharesForAmount(uint256 _amount)
        external
        view
        override
        returns (uint256)
    {
        uint256 _totalAssets = totalAssets();
        return
            (_totalAssets > 0)
                ? ((_amount * totalSupply()) / _totalAssets)
                : 0;
    }

    function getFeeDenominator() external pure override returns (uint256) {
        return FEE_DENOMINATOR;
    }

    function getFeeLimit() external pure override returns (uint256) {
        return FEE_LIMIT;
    }

    function totalAssets() public view override returns (uint256) {
        return
            _baseToken.balanceOf(address(this)) +
            _strategyController.totalValue();
    }
}",2441
RealWorld_TA_100_ICollateralDepositRecord_RealWorld_20240812095442.log,100,ICollateralDepositRecord,88791,2499,91290,76.0,0.493935,"// SPDX-License-Identifier: UNLICENSED

pragma solidity =0.8.7;

/// @notice Enforces Collateral deposit caps.
interface ICollateralDepositRecord {
    /// @dev Emitted via `setGlobalDepositCap()`.
    /// @param amount New global deposit cap
    event GlobalDepositCapChanged(uint256 amount);

    /// @dev Emitted via `setAccountDepositCap()`.
    /// @param amount New account deposit cap
    event AccountDepositCapChanged(uint256 amount);

    /// @dev Emitted via `setAllowedHook()`.
    /// @param hook Hook with changed permissions
    /// @param allowed Whether the hook is allowed
    event AllowedHooksChanged(address hook, bool allowed);

    /**
     * @dev This function will be called by a Collateral hook before the fee
     * is subtracted from the initial `amount` passed in.
     *
     * Only callable by allowed hooks.
     *
     * Reverts if the incoming deposit brings either total over their
     * respective caps.
     *
     * `finalAmount` is added to both the global and account-specific
     * deposit totals.
     * @param sender The account making the Collateral deposit
     * @param finalAmount The amount actually deposited by the user
     */
    function recordDeposit(address sender, uint256 finalAmount) external;

    /**
     * @notice Called by a Collateral hook before the fee is subtracted from
     * the amount withdrawn from the Strategy.
     * @dev `finalAmount` is subtracted from both the global and
     * account-specific deposit totals.
     *
     * Only callable by allowed hooks.
     * @param sender The account making the Collateral withdrawal
     * @param finalAmount The amount actually withdrawn by the user
     */
    function recordWithdrawal(address sender, uint256 finalAmount) external;

    /**
     * @notice Sets the global cap on assets backing Collateral in circulation.
     * @dev Only callable by owner().
     * @param newGlobalDepositCap The new global deposit cap
     */
    function setGlobalDepositCap(uint256 newGlobalDepositCap) external;

    /**
     * @notice Sets the cap on net Base Token deposits per user.
     * @dev Only callable by owner().
     * @param newAccountDepositCap The new account deposit cap
     */
    function setAccountDepositCap(uint256 newAccountDepositCap) external;

    /**
     * @notice Sets if a contract is allowed to record deposits
     * and withdrawals.
     * @dev Only callable by owner().
     * @param hook The contract address
     * @param allowed Whether or not the contract will be allowed
     */
    function setAllowedHook(address hook, bool allowed) external;

    /**
     * @notice Gets the maximum Base Token amount that is allowed to be
     * deposited (net of withdrawals).
     * @dev Deposits are not allowed if `globalDepositAmount` exceeds
     * the `globalDepositCap`.
     * @return Base Token amount
     */
    function getGlobalDepositCap() external view returns (uint256);

    /// @return Net total of Base Token deposited.
    function getGlobalDepositAmount() external view returns (uint256);

    /**
     * @dev An account will not be allowed to deposit if their net deposits
     * exceed `accountDepositCap`.
     * @return The cap on net Base Token deposits per user
     */
    function getAccountDepositCap() external view returns (uint256);

    /**
     * @param account The account to retrieve net deposits for
     * @return The net total amount of Base Token deposited by a user
     */
    function getNetDeposit(address account) external view returns (uint256);

    /**
     * @notice Returns whether the contract is allowed to record deposits and
     * withdrawals.
     * @param hook The contract to retrieve allowed status for
     * @return Whether the contract is allowed
     */
    function isHookAllowed(address hook) external view returns (bool);
}",835
RealWorld_TA_100_LongShortToken_RealWorld_20240812093811.log,100,LongShortToken,28052,1675,29727,64.0,0.17376,"// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.7;

import ""@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract LongShortToken is ERC20Burnable, Ownable {
    constructor(string memory name_, string memory symbol_)
        ERC20(name_, symbol_)
    {}

    function mint(address _recipient, uint256 _amount) external onlyOwner {
        _mint(_recipient, _amount);
    }
}",125
RealWorld_TA_100_DepositHook_RealWorld_20240812094210.log,100,DepositHook,49174,1913,51087,76.0,0.28413,"// SPDX-License-Identifier: UNLICENSED
import ""./interfaces/IHook.sol"";
import ""./interfaces/IAccountAccessController.sol"";
import ""./interfaces/ICollateralDepositRecord.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

pragma solidity =0.8.7;

contract DepositHook is IHook, Ownable {
    address private _vault;
    IAccountAccessController private _accountAccessController;
    ICollateralDepositRecord private _depositRecord;

    constructor(address _newAccessController, address _newDepositRecord) {
        _accountAccessController = IAccountAccessController(
            _newAccessController
        );
        _depositRecord = ICollateralDepositRecord(_newDepositRecord);
    }

    modifier onlyVault() {
        require(msg.sender == _vault, ""Caller is not the vault"");
        _;
    }

    function hook(
        address _sender,
        uint256 _initialAmount,
        uint256 _finalAmount
    ) external override onlyVault {
        require(
            _accountAccessController.isAccountAllowed(_sender) &&
                !_accountAccessController.isAccountBlocked(_sender),
            ""Account not allowed to deposit""
        );
        _depositRecord.recordDeposit(_sender, _finalAmount);
    }

    function setVault(address _newVault) external override onlyOwner {
        _vault = _newVault;
        emit VaultChanged(_newVault);
    }

    function getVault() external view returns (address) {
        return _vault;
    }

    function getAccountAccessController()
        external
        view
        returns (IAccountAccessController)
    {
        return _accountAccessController;
    }

    function getDepositRecord()
        external
        view
        returns (ICollateralDepositRecord)
    {
        return _depositRecord;
    }
}",370
RealWorld_TA_100_ILongShortToken_RealWorld_20240812095854.log,100,ILongShortToken,43104,2416,45520,74.0,0.26384,"// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.7;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/**
 * @notice LongShortToken contract representing PrePOMarket positions.
 *
 * The token can represent either a Long or Short position for the
 * PrePOMarket it belongs to.
 */
interface ILongShortToken is IERC20 {
    /**
     * @dev Inherited from OpenZeppelin Ownable.
     * @return Address of the current owner
     */
    function owner() external returns (address);

    /**
     * @notice Mints `amount` tokens to `recipient`. Allows PrePOMarket to mint
     * positions for users.
     * @dev Only callable by `owner()` (should be PrePOMarket).
     * @param recipient Address of the recipient
     * @param amount Amount of tokens to mint
     */
    function mint(address recipient, uint256 amount) external;

    /**
     * @notice Destroys `amount` tokens from `account`, deducting from the
     * caller's allowance.
     * @dev Inherited from OpenZeppelin ERC20Burnable.
     * @param account Address of the account to destroy tokens from
     * @param amount Amount of tokens to destroy
     */
    function burnFrom(address account, uint256 amount) external;
}",287
RealWorld_TA_101_PCLLiquidatedStage.t_RealWorld_20240812153243.log,101,PCLLiquidatedStage.t,87389,4448,91837,104.0,0.525905,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLStageTests/PCLLiquidatedStage.t.sol';

contract PCLLiquidatedStageZeroCollateral is PCLLiquidatedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(requestId, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!LIQUIDATED');
    }
}",797
RealWorld_TA_101_adminVerifier.t_RealWorld_20240812163457.log,101,adminVerifier.t,330387,2826,333213,113.0,1.708455,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import 'forge-std/Test.sol';
import '../../Verification/adminVerifier.sol';
import '../../Verification/Verification.sol';
import '../../SublimeProxy.sol';

import '../roles/Admin.sol';
import '../roles/User.sol';
import '@openzeppelin/contracts/cryptography/ECDSA.sol';

contract AdminVerifierTests is Test {
    AdminVerifier adminVerifier;
    Verification verification;

    Admin proxyAdmin;
    Admin admin;
    Admin fakeAdmin;
    User user;
    User anotherUser;

    uint256 constant activationDelay = 1;
    uint256 constant signValidity = 365 days;
    uint256 constant signerPrivateKey = 0xb57992e36fcf5e1bf95840b39f83a5c57936bb391b50acad27e53b05bf751f71;
    uint256 constant newSignerPrivateKey = 0xc903396ee8a81ce8729bc48c2e71034e516a11e9b1c516addb602a55cd88e555;

    string constant verifierName = 'sublime';
    string constant verifierVersion = 'v1';

    bytes32 _TYPE_HASH;
    bytes32 _HASHED_NAME;
    bytes32 _HASHED_VERSION;

    function setUp() public {
        proxyAdmin = new Admin();
        admin = new Admin();
        fakeAdmin = new Admin();
        user = new User();
        anotherUser = new User();

        Verification verificationImplementation = new Verification();
        SublimeProxy verificationProxy = new SublimeProxy(address(verificationImplementation), address(proxyAdmin), '');
        verification = Verification(address(verificationProxy));
        admin.initializeVerification(verification, address(admin), activationDelay);

        AdminVerifier adminVerifierImplementation = new AdminVerifier(address(verification));
        SublimeProxy adminVerifierProxy = new SublimeProxy(address(adminVerifierImplementation), address(proxyAdmin), '');
        adminVerifier = AdminVerifier(address(adminVerifierProxy));
        admin.initializeAdminVerifier(
            adminVerifier,
            address(admin),
            vm.addr(signerPrivateKey),
            signValidity,
            verifierName,
            verifierVersion
        );

        admin.addVerifier(address(verification), address(adminVerifier));

        bytes32 hashedName = keccak256(bytes(verifierName));
        bytes32 hashedVersion = keccak256(bytes(verifierVersion));
        _HASHED_NAME = hashedName;
        _HASHED_VERSION = hashedVersion;

        _TYPE_HASH = keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');
    }

    // Generating signatures should show valid signatures
    function test_generateSignatures() public {
        string memory userData = 'someUserData';
        // bool _isMasterLinked = true;

        address _user = 0xe33896558027811799165C5A85B7c9C318a0e7c4;

        address adminVerifierCustomAddress = 0x6469d5A63e28E2fa8cC37969e0817cf7e2F6F50b;

        uint256 _timestamp = 1655312381 + 1 days;
        bytes32 digest = _calculateDigest(userData, _user, _timestamp);
        bytes32 hash = _hashTypedDataV4_withContractAddress(digest, adminVerifierCustomAddress);

        (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(signerPrivateKey, hash);

        log_named_uint('timestamp', _timestamp);
        log_named_uint('v', _v);
        log_named_bytes32('_r', _r);
        log_named_bytes32('_s', _s);
    }

    // Registering a new user should pass
    function test_registerUser(string memory _userData, bool _isMasterLinked) public {
        if (bytes(_userData).length <= 2) return;

        uint256 _timestamp = block.timestamp + 1 minutes;
        bytes32 digest = _calculateDigest(_userData, address(user), _timestamp);
        bytes32 hash = _hashTypedDataV4(digest);

        (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(signerPrivateKey, hash);
        user.registerUserUsingAdminVerifier(adminVerifier, _isMasterLinked, _v, _r, _s, _userData, _timestamp);

        assertEq(adminVerifier.userData(address(user)), _userData);
    }

    // Registering user with the same digest should fail
    function test_cannot_use_same_digest_twice(string memory _userData, bool _isMasterLinked) public {
        if (bytes(_userData).length <= 2) return;
        uint256 _timestamp = block.timestamp + 1 minutes;
        bytes32 digest = _calculateDigest(_userData, address(user), _timestamp);
        bytes32 hash = _hashTypedDataV4(digest);

        (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(signerPrivateKey, hash);
        user.registerUserUsingAdminVerifier(adminVerifier, _isMasterLinked, _v, _r, _s, _userData, _timestamp);

        user.unregisterUserFromAdminVerifier(adminVerifier);

        try user.registerUserUsingAdminVerifier(adminVerifier, _isMasterLinked, _v, _r, _s, _userData, _timestamp) {
            revert('should revert as same digest is tried being used');
        } catch Error(string memory reason) {
            assertEq(reason, 'AV:RS3');
        }
    }

    // Regitering user with invalid signer address should fail
    function test_ec_recover(
        string memory _userData,
        bool _isMasterLinked,
        bytes calldata randomBytes
    ) public {
        if (bytes(_userData).length <= 2 || bytes(randomBytes).length <= 72) return;
        bytes32 wrongHash;
        uint256 _timestamp = block.timestamp + 1 minutes;

        {
            _timestamp = block.timestamp + 1 minutes;
            bytes32 digest = _calculateDigest(_userData, address(user), _timestamp);
            bytes32 hash = _hashTypedDataV4(digest);
            wrongHash = keccak256(abi.encode(randomBytes, hash));
        }

        (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(signerPrivateKey, wrongHash);
        try user.registerUserUsingAdminVerifier(adminVerifier, _isMasterLinked, _v, _r, _s, _userData, _timestamp) {
            revert('signer should be address 0');
        } catch Error(string memory reason) {
            bool result = keccak256(abi.encode(reason)) == keccak256(abi.encode('AV:RS4')) ||
                keccak256(abi.encode(reason)) == keccak256(abi.encode('AV:RS5'));
            assertEq(result, true);
        }
    }

    // Regitering user with invalid signer address should fail
    function test_ec_recover_2(string memory _userData, bool _isMasterLinked) public {
        if (bytes(_userData).length <= 2) return;

        uint256 _timestamp = block.timestamp + 1 minutes;
        bytes32 digest = _calculateDigest(_userData, address(user), _timestamp);
        bytes32 hash = _hashTypedDataV4(digest);
        bytes32 wrongHash = _hashTypedDataV4(hash);

        (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(signerPrivateKey, wrongHash);

        try user.registerUserUsingAdminVerifier(adminVerifier, _isMasterLinked, _v, _r, _s, _userData, _timestamp) {
            revert('signer should be invalid address');
        } catch Error(string memory reason) {
            assertEq(reason, 'AV:RS5');
        }
    }

    // Registering user after the sign validity has passed should fail
    function test_registerUserAfterSignValidity(string memory _userData, bool _isMasterLinked) public {
        if (bytes(_userData).length <= 2) return;

        uint256 _timestamp = block.timestamp + 1 minutes;
        bytes32 digest = _calculateDigest(_userData, address(user), _timestamp);
        bytes32 hash = _hashTypedDataV4(digest);

        (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(signerPrivateKey, hash);
        vm.warp(block.timestamp + 1 minutes + adminVerifier.signValidity());
        try user.registerUserUsingAdminVerifier(adminVerifier, _isMasterLinked, _v, _r, _s, _userData, _timestamp) {
            revert('Should revert after sign validity has expired');
        } catch Error(string memory reason) {
            assertEq(reason, 'AV:RS2');
        }
    }

    // Registering an already registered user should fail
    function test_cannot_register_if_already_registered(string memory _userData, bool _isMasterLinked) public {
        if (bytes(_userData).length <= 2) return;

        uint256 _timestamp = block.timestamp + 1 minutes;
        bytes32 digest = _calculateDigest(_userData, address(user), _timestamp);
        bytes32 hash = _hashTypedDataV4(digest);

        (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(signerPrivateKey, hash);
        user.registerUserUsingAdminVerifier(adminVerifier, _isMasterLinked, _v, _r, _s, _userData, _timestamp);

        try user.registerUserUsingAdminVerifier(adminVerifier, _isMasterLinked, _v, _r, _s, _userData, _timestamp) {
            revert('Should revert if tried to register multiple times');
        } catch Error(string memory reason) {
            assertEq(reason, 'AV:RS1');
        }
    }

    // Updating signer with the current signer address should fail
    function test_update_signer_same_address() public {
        try admin.updateSignerInAdminVerifier(adminVerifier, adminVerifier.signerAddress()) {
            revert('Using same address to update signer should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'AV:IUSA1');
        }
    }

    // Updating signer with the zero address should fail
    function test_update_signer_zero_address() public {
        try admin.updateSignerInAdminVerifier(adminVerifier, address(0)) {
            revert('Using zero address to update signer should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'AV:IUSA2');
        }
    }

    // Updating signer should pass
    function test_update_signer() public {
        admin.updateSignerInAdminVerifier(adminVerifier, vm.addr(newSignerPrivateKey));
        assertEq(adminVerifier.signerAddress(), vm.addr(newSignerPrivateKey));
    }

    // Updating sign validity with same value as current sign validity should fail
    function test_update_signValidity_same_value() public {
        try admin.updateSignValidityInAdminVerifier(adminVerifier, adminVerifier.signValidity()) {
            revert('Using same value to update sign validity should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'AV:IUSV1');
        }
    }

    // Updating sign validity with zero value should fail
    function test_update_signValidity_zero_value() public {
        try admin.updateSignValidityInAdminVerifier(adminVerifier, 0) {
            revert('Using zero value to update sign validity should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'AV:IUSV2');
        }
    }

    // Updating sign validity by invalid owner should fail
    function test_update_signValidity_invalid_owner() public {
        try proxyAdmin.updateSignValidityInAdminVerifier(adminVerifier, 11267) {
            revert('Using zero value to update sign validity should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'TransparentUpgradeableProxy: admin cannot fallback to proxy target');
        }

        try fakeAdmin.updateSignValidityInAdminVerifier(adminVerifier, 11267) {
            revert('Using zero value to update sign validity should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    // Updating sign validity should pass
    function test_update_signValidity(uint256 newSignValidity) public {
        if (newSignValidity == 0 || adminVerifier.signValidity() == newSignValidity) return;

        admin.updateSignValidityInAdminVerifier(adminVerifier, newSignValidity);
        assertEq(adminVerifier.signValidity(), newSignValidity);
    }

    // Unregistering a registered user should pass
    function test_unregisterUser(string memory _userData, bool _isMasterLinked) public {
        if (bytes(_userData).length <= 2) return;
        test_registerUser(_userData, _isMasterLinked);

        emit log_named_uint('block.timestamp', block.timestamp);

        user.unregisterUserFromAdminVerifier(adminVerifier);
        assertEq(verification.masterAddresses(address(user), address(adminVerifier)), 0);
    }

    // Unregistering a non-existant user should fail
    function test_unregister_when_no_user() public {
        try user.unregisterUserFromAdminVerifier(adminVerifier) {
            revert('Should revert if user is not registered');
        } catch Error(string memory reason) {
            assertEq(reason, 'AV:IUU1');
        }
    }

    // Unregistering a user by Admin should pass
    function test_unregister_by_admin(string memory _userData, bool _isMasterLinked) public {
        if (bytes(_userData).length <= 2) return;
        test_registerUser(_userData, _isMasterLinked);

        emit log_named_uint('block.timestamp', block.timestamp);

        admin.unregisterUserByAdminInAdminVerifier(adminVerifier, address(user));
        assertEq(verification.masterAddresses(address(user), address(adminVerifier)), 0);
    }

    // Registering with black listed digest should fail
    function test_registering_with_black_listed_digest(string memory _userData, bool _isMasterLinked) public {
        if (bytes(_userData).length <= 2) return;

        uint256 _timestamp = block.timestamp + 1 minutes;
        bytes32 digest = _calculateDigest(_userData, address(user), _timestamp);
        bytes32 hash = _hashTypedDataV4(digest);

        admin.blacklistDigestInAdminVerifier(adminVerifier, digest);

        (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(signerPrivateKey, hash);
        try user.registerUserUsingAdminVerifier(adminVerifier, _isMasterLinked, _v, _r, _s, _userData, _timestamp) {
            revert('Should revert as digest is blacklisted');
        } catch Error(string memory reason) {
            assertEq(reason, 'AV:RS3');
        }
    }

    // ---- internal ---- //

    function _calculateDigest(
        string memory _userData,
        address _msgSender,
        uint256 _timestamp
    ) internal pure returns (bytes32) {
        bytes32 digest = keccak256(
            abi.encode(
                keccak256('set(string userData,address userAddr,uint256 timestamp)'),
                keccak256(bytes(_userData)),
                _msgSender,
                _timestamp
            )
        );

        return digest;
    }

    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {
        return keccak256(abi.encodePacked('\x19\x01', _domainSeparatorV4(), structHash));
    }

    function _domainSeparatorV4() internal view returns (bytes32) {
        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());
    }

    function _buildDomainSeparator(
        bytes32 typeHash,
        bytes32 name,
        bytes32 version
    ) private view returns (bytes32) {
        return keccak256(abi.encode(typeHash, name, version, _getChainId(), address(adminVerifier)));
    }

    function _getChainId() private view returns (uint256 chainId) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        // solhint-disable-next-line no-inline-assembly
        assembly {
            chainId := chainid()
        }
    }

    function _EIP712NameHash() internal view virtual returns (bytes32) {
        return _HASHED_NAME;
    }

    function _EIP712VersionHash() internal view virtual returns (bytes32) {
        return _HASHED_VERSION;
    }

    // --------------- only for testing ------------- //
    function _hashTypedDataV4_withContractAddress(bytes32 structHash, address contractAddress) internal view virtual returns (bytes32) {
        return keccak256(abi.encodePacked('\x19\x01', _domainSeparatorV4_withContractAddress(contractAddress), structHash));
    }

    function _domainSeparatorV4_withContractAddress(address contractAddress) internal view returns (bytes32) {
        return _buildDomainSeparator_withContractAddress(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), contractAddress);
    }

    function _buildDomainSeparator_withContractAddress(
        bytes32 typeHash,
        bytes32 name,
        bytes32 version,
        address contractAddress
    ) private view returns (bytes32) {
        return keccak256(abi.encode(typeHash, name, version, _getChainId(), contractAddress));
    }
}",3648
RealWorld_TA_101_ICToken_RealWorld_20240812182957.log,101,ICToken,29998,1734,31732,71.0,0.18467,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface ICToken {
    function underlying() external view returns (address);

    function mint(uint256 mintAmount) external returns (uint256);

    function redeem(uint256 redeemTokens) external returns (uint256);

    function balanceOfUnderlying(address account) external returns (uint256);

    function exchangeRateCurrent() external returns (uint256);

    function comptroller() external view returns (address);

    function getCash() external returns (uint256);

    function borrow(uint256 borrowAmount) external returns (uint256);

    function repayBorrow(uint256 repayAmount) external returns (uint256);
}",138
RealWorld_TA_101_CLUser_RealWorld_20240812170631.log,101,CLUser,86870,3062,89932,94.0,0.49559,"//SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../../../CreditLine/CreditLine.sol';
import '../Helpers/CLConstants.sol';

contract CLUser {
    function createRequest(address creditLineAddress, CLConstants.RequestParams memory requestData) public returns (uint256) {
        CreditLine creditLine = CreditLine(creditLineAddress);

        uint256 _id = creditLine.request(
            requestData.requestTo,
            requestData.borrowLimit,
            requestData.borrowRate,
            requestData.autoLiquidation,
            requestData.collateralRatio,
            requestData.borrowAsset,
            requestData.borrowAssetStrategy,
            requestData.collateralAsset,
            requestData.collateralStrategy,
            requestData.requestAsLender
        );

        return _id;
    }

    function cancelRequest(address creditLineAddress, uint256 id) public {
        CreditLine creditLine = CreditLine(creditLineAddress);

        creditLine.cancel(id);
    }

    function acceptRequest(address creditLineAddress, uint256 id) public {
        CreditLine creditLine = CreditLine(creditLineAddress);

        creditLine.accept(id);
    }

    function borrow(
        address creditLineAddress,
        uint256 id,
        uint256 amount
    ) public {
        CreditLine creditLine = CreditLine(creditLineAddress);

        creditLine.borrow(id, amount);
    }

    function repay(
        address creditLineAddress,
        uint256 id,
        uint256 amount
    ) public {
        CreditLine creditLine = CreditLine(creditLineAddress);

        creditLine.repay(id, amount);
    }

    function addCollateral(
        address creditLineAddress,
        uint256 id,
        uint256 amount,
        bool fromSavingsAccount
    ) public {
        CreditLine creditLine = CreditLine(creditLineAddress);

        creditLine.depositCollateral(id, amount, fromSavingsAccount);
    }

    function withdrawCollateral(
        address creditLineAddress,
        uint256 id,
        uint256 amount,
        bool toSavingsAccount
    ) public {
        CreditLine creditLine = CreditLine(creditLineAddress);

        creditLine.withdrawCollateral(id, amount, toSavingsAccount);
    }

    function withdrawAllCollateral(
        address creditLineAddress,
        uint256 id,
        bool toSavingsAccount
    ) public {
        CreditLine creditLine = CreditLine(creditLineAddress);

        creditLine.withdrawAllCollateral(id, toSavingsAccount);
    }

    function updateBorrowLimit(
        address creditLineAddress,
        uint256 id,
        uint128 newBorrowLimit
    ) public {
        CreditLine creditLine = CreditLine(creditLineAddress);

        creditLine.updateBorrowLimit(id, newBorrowLimit);
    }

    function close(address creditLineAddress, uint256 id) public {
        CreditLine creditLine = CreditLine(creditLineAddress);

        creditLine.close(id);
    }

    function liquidate(
        address creditLineAddress,
        uint256 id,
        bool toSavingsAccount
    ) public {
        CreditLine creditLine = CreditLine(creditLineAddress);

        creditLine.liquidate(id, toSavingsAccount);
    }

    function setAllowance(
        address spender,
        address token,
        uint256 amount
    ) public {
        IERC20(token).approve(spender, amount);
    }

    function setAllowanceForSavingsAccount(
        address savingsAccount,
        address token,
        address spender,
        uint256 amount
    ) public {
        ISavingsAccount SavingsAccount = ISavingsAccount(savingsAccount);

        SavingsAccount.approve(token, spender, amount);
    }

    function savingsAccountDeposit(
        address savingsAccount,
        address token,
        address strategy,
        address to,
        uint256 amount
    ) public {
        ISavingsAccount SavingsAccount = ISavingsAccount(savingsAccount);

        SavingsAccount.deposit(token, strategy, to, amount);
    }
}",818
RealWorld_TA_101_PCLClosedStage.t_RealWorld_20240812153429.log,101,PCLClosedStage.t,78168,4469,82637,107.0,0.48022,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLStageTests/PCLClosedStage.t.sol';

contract PCLClosedStageZeroCollateral is PCLClosedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        // Now we assert that we are in the ACTIVE state
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), 2);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(requestId, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // And borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(requestId, currentDebt);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!CLOSED');
    }
}",699
RealWorld_TA_101_PCLLiquidatedStage.t_RealWorld_20240812154303.log,101,PCLLiquidatedStage.t,87091,3712,90803,99.0,0.509695,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../../PCLStageTests/PCLLiquidatedStage.t.sol';

contract PCLLiquidatedStageZeroCollateralBorrowCompound is PCLLiquidatedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(requestId, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!LIQUIDATED');
    }
}",800
RealWorld_TA_101_PCLLiquidatedStage.t_RealWorld_20240812150818.log,101,PCLLiquidatedStage.t,85579,4519,90098,121.0,0.518275,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLLiquidatedStage.t.sol';

contract PCLLiquidatedStageCollateralCompoundBorrowCompound is PCLLiquidatedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }
}",779
RealWorld_TA_101_User_RealWorld_20240812162754.log,101,User,192558,4247,196805,131.0,1.04773,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../../SavingsAccount/SavingsAccount.sol';
import '../../interfaces/IYield.sol';
import '../../yield/CompoundYield.sol';
import '../../yield/NoYield.sol';
import '../../PriceOracle.sol';
import '../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../interfaces/ILenderPool.sol';
import '../../PooledCreditLine/PooledCreditLine.sol';
import '../../PooledCreditLine/LenderPool.sol';
import '../../mocks/MockToken.sol';
import '../../Verification/twitterVerifier.sol';
import '../../Verification/adminVerifier.sol';
import '../../Verification/Verification.sol';

import '@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol';
import '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

contract User is IERC1155ReceiverUpgradeable, IPooledCreditLineDeclarations {
    using SafeERC20 for IERC20;

    /******************************************************************************
     ******* Savings account specific functions ***********************************
     ******************************************************************************/

    function depositToSavingsAccount(
        address savingsAccount,
        uint256 _amount,
        address _token,
        address _strategy,
        address _to
    ) public {
        SavingsAccount(savingsAccount).deposit(_token, _strategy, _to, _amount);
    }

    function switchStrategyInSavingsAccount(
        address savingsAccount,
        address _currentStrategy,
        address _newStrategy,
        address _token,
        uint256 _amount
    ) public {
        SavingsAccount(savingsAccount).switchStrategy(_currentStrategy, _newStrategy, _token, _amount);
    }

    function approveToSavingsAccount(
        address savingsAccount,
        address _token,
        address _to,
        uint256 _amount
    ) public {
        SavingsAccount(savingsAccount).approve(_token, _to, _amount);
    }

    function withdrawFromSavingsAccount(
        address savingsAccount,
        address _token,
        address _strategy,
        address _from,
        address _to,
        uint256 _amount,
        bool _receiveShares
    ) public {
        SavingsAccount(savingsAccount).withdrawFrom(_token, _strategy, _from, _to, _amount, _receiveShares);
    }

    function withdrawAllSavingsAccount(address savingsAccount, address _token) public {
        SavingsAccount(savingsAccount).withdrawAll(_token);
    }

    function withdrawAllTokenFromStrategySavingsAccount(
        address savingsAccount,
        address _token,
        address _strategy
    ) public {
        SavingsAccount(savingsAccount).withdrawAll(_token, _strategy);
    }

    function transferFromSavingsAccount(
        address savingsAccount,
        address _token,
        address _strategy,
        address _from,
        address _to,
        uint256 _amount
    ) public {
        SavingsAccount(savingsAccount).transferFrom(_token, _strategy, _from, _to, _amount);
    }

    function transferSavingsAccount(
        address savingsAccount,
        address _token,
        address _strategy,
        address _to,
        uint256 _amount
    ) public {
        SavingsAccount(savingsAccount).transfer(_token, _strategy, _to, _amount);
    }

    function lockTokensForCompoundYield(
        address payable yield,
        address user,
        address asset,
        uint256 amount
    ) public {
        CompoundYield(yield).lockTokens(user, asset, amount);
    }

    function unlockTokensForCompoundYield(
        address payable yield,
        address asset,
        address to,
        uint256 amount
    ) public {
        CompoundYield(yield).unlockTokens(asset, to, amount);
    }

    function lockTokensForNoYield(
        address yield,
        address user,
        address asset,
        uint256 amount
    ) public {
        NoYield(yield).lockTokens(user, asset, amount);
    }

    function unlockTokensForNoYield(
        address yield,
        address asset,
        address to,
        uint256 amount
    ) public {
        NoYield(yield).unlockTokens(asset, to, amount);
    }

    function setAllowanceForSavingsAccount(
        address savingsAccountAddress,
        uint256 amount,
        address token,
        address spender
    ) public {
        ISavingsAccount savingsAccount = ISavingsAccount(savingsAccountAddress);

        savingsAccount.approve(token, spender, amount);
    }

    function savingsAccountWithdraw(
        address savingsAccountAddress,
        address _token,
        address _strategy,
        address _to,
        uint256 _amount,
        bool _receiveShares
    ) public {
        ISavingsAccount savingsAccount = ISavingsAccount(savingsAccountAddress);

        savingsAccount.withdraw(_token, _strategy, _to, _amount, _receiveShares);
    }

    /*****************************************************************************
     ******* END of Savings account specific functions ****************************
     ******************************************************************************/

    function approveToken(
        address token,
        address spender,
        uint256 amount
    ) public {
        IERC20(token).safeApprove(spender, 0);
        IERC20(token).safeApprove(spender, amount);
    }

    // ----- ierc receiver implmentation --------//
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) external virtual override returns (bytes4) {
        return bytes4(keccak256('onERC1155Received(address,address,uint256,uint256,bytes)'));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return bytes4(keccak256('onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)'));
    }

    function supportsInterface(bytes4) external pure override returns (bool) {
        return true;
    }

    /*****************************************************************************
     ******* Start of twitter verifier specific functions ****************************
     ******************************************************************************/

    function registerUserUsingTwitterVerifier(
        TwitterVerifier twitterVerifier,
        bool _isMasterLinked,
        uint8 _v,
        bytes32 _r,
        bytes32 _s,
        string memory _twitterId,
        string memory _tweetId,
        uint256 _timestamp
    ) public {
        twitterVerifier.registerSelf(_isMasterLinked, _v, _r, _s, _twitterId, _tweetId, _timestamp);
    }

    function unregisterUserFromTwitterVerifier(TwitterVerifier twitterVerifier) public {
        twitterVerifier.unregisterSelf();
    }

    /*****************************************************************************
     ******* END of twitter verifier specific functions ****************************
     ******************************************************************************/

    /*****************************************************************************
     ******* Strat of admin verifier specific functions ****************************
     ******************************************************************************/

    function registerUserUsingAdminVerifier(
        AdminVerifier adminVerifier,
        bool _isMasterLinked,
        uint8 _v,
        bytes32 _r,
        bytes32 _s,
        string memory _userData,
        uint256 _timestamp
    ) public {
        adminVerifier.registerSelf(_isMasterLinked, _v, _r, _s, _userData, _timestamp);
    }

    function unregisterUserFromAdminVerifier(AdminVerifier adminVerifier) public {
        adminVerifier.unregisterSelf();
    }

    /*****************************************************************************
     ******* END of admin verifier specific functions ****************************
     ******************************************************************************/

    /********************************************************************************************************************************
    Generic User functions. Callable by anyone. Mostly view function. Written to avoid stack too deep in test contracts
    *********************************************************************************************************************************/

    function fetchCreditLineVariable(
        address pooledCreditLineAddress,
        uint256 pooledCreditLineID,
        string memory variable
    ) public view returns (uint256) {
        PooledCreditLine pooledCreditLine = PooledCreditLine(pooledCreditLineAddress);
        (
            ,
            uint256 creditLineVariablePrincipal,
            uint256 creditLineVariableTotalInterestRepaid,
            uint256 creditLineVariableLastPrincipalUpdateTime,
            uint256 creditLineVariableInterestAccruedTillLastPrincipalUpdate
        ) = pooledCreditLine.pooledCreditLineVariables(pooledCreditLineID);
        if (keccak256(abi.encodePacked(variable)) == keccak256(abi.encodePacked('principal'))) {
            return creditLineVariablePrincipal;
        } else if (keccak256(abi.encodePacked(variable)) == keccak256(abi.encodePacked('totalInterestRepaid'))) {
            return creditLineVariableTotalInterestRepaid;
        } else if (keccak256(abi.encodePacked(variable)) == keccak256(abi.encodePacked('lastPrincipalUpdateTime'))) {
            return creditLineVariableLastPrincipalUpdateTime;
        } else if (keccak256(abi.encodePacked(variable)) == keccak256(abi.encodePacked('interestAccruedTillLastPrincipalUpdate'))) {
            return creditLineVariableInterestAccruedTillLastPrincipalUpdate;
        } else {
            revert('Incorrect credit line variable entered');
        }
    }

    function setAllowance(
        address approvedAddress,
        address token,
        uint256 amount
    ) public {
        IERC20(token).approve(approvedAddress, amount);
    }

    function increaseAllowance(
        address approvedAddress,
        address token,
        uint256 amount
    ) public {
        ERC20(token).increaseAllowance(approvedAddress, amount);
    }

    function requestAddressLinkingInVerifier(Verification verification, address _linkedAddress) public {
        verification.requestAddressLinking(_linkedAddress);
    }

    function cancelAddressLinkingRequestInVerification(Verification verification, address _linkedAddress) public {
        verification.cancelAddressLinkingRequest(_linkedAddress);
    }

    function linkAddressInVerification(Verification verification, address _masterAddress) public {
        verification.linkAddress(_masterAddress);
    }

    function unlinkAddressInVerification(Verification verification, address _linkedAddress) public {
        verification.unlinkAddress(_linkedAddress);
    }
}",2118
RealWorld_TA_101_PCLCancelledStage.t_RealWorld_20240812152820.log,101,PCLCancelledStage.t,56913,2904,59817,83.0,0.342645,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLStageTests/PCLCancelledStage.t.sol';

contract PCLCancelledStageZeroCollateral is PCLCancelledStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        // Lend any amount lesser than the borrowLimit
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        lender_0 = lenders[0].lenderAddress;

        // Let's travel a few days, but stay within the collection period
        vm.warp(block.timestamp + request.collectionPeriod / 2);

        // Borrower tries to cancel the PCL
        borrower.cancelRequest(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED, '!CANCELLED');
    }
}",441
RealWorld_TA_101_IVerifier_RealWorld_20240812182051.log,101,IVerifier,29455,1173,30628,66.0,0.170735,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface IVerifier {
    /**
     * @notice emitted when a user is registered
     * @param user address of user registered
     * @param isMasterLinked if true, master address is also considered to be linked to itself
     * @param metadata any metadata related to registered user
     */
    event UserRegistered(address indexed user, bool isMasterLinked, string indexed metadata);

    /**
     * @notice emitted when a user is unregistered
     * @param user address of the user unregistered
     */
    event UserUnregistered(address indexed user);
}",133
RealWorld_TA_101_PCLActiveStateCompoundYield.t_RealWorld_20240812161338.log,101,PCLActiveStateCompoundYield.t,65089,3886,68975,98.0,0.403165,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLActiveState.t.sol';
import '../../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracleCompoundYield is PCLActiveStatePriceOracle {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }
}",533
RealWorld_TA_101_PCLRequestedStateCompoundYield.t_RealWorld_20240812161518.log,101,PCLRequestedStateCompoundYield.t,61347,3331,64678,99.0,0.373355,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLRequestedState.t.sol';
import '../../Helpers/PCLParent.t.sol';

contract PCLRequestedStatePriceOracleCompoundYield is PCLRequestedStatePriceOracle {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED, '!Requested');
    }
}",496
RealWorld_TA_101_PCLRequestedState.t_RealWorld_20240812155852.log,101,PCLRequestedState.t,512286,3981,516267,141.0,2.64105,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLRequestedStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED, '!Requested');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: A requested PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start a PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S2');
        }
    }

    // Test 2: Collateral cannot be deposited
    function test_collateralCannotBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try borrower.depositCollateral(requestId, _minimumCollateralRequired, false) {
            revert('Collateral cannot be deposited');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, 0);
    }

    // Test 3.1: Collateral cannot be withdrawn
    function test_collateralCannotBeWithdrawn(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Collateral cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 3.2: All Collateral cannot be withdrawn
    function test_allCollateralCannotBeWithdrawn(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Collateral cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 4: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);

        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);

        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: Borrowable amount remains zero
    function test_borrowableAmountIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        assertEq(_borrowableAmount, 0);
    }

    // Test 6: A requested PCL cannot be closed
    function test_pclCannotBeClosed(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('PCL cannot be closed');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    // Test 7: Collateral ratio remains infinite
    function test_collateralRatioIsInfinite(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, type(uint256).max);
    }

    // Test 7.1: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero() public {
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.2: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero() public {
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from a requested PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders can withdraw liquidity
    function test_lendersCanWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));
        uint256 _userPoolTokenBalance = lp.balanceOf(address(_lender0), requestId);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _userBorrowTokenBalanceBefore = IERC20(request.borrowAsset).balanceOf(address(_lender0));
        _lender0.withdrawLiquidity(requestId);
        uint256 _userBorrowTokenBalanceAfter = IERC20(request.borrowAsset).balanceOf(address(_lender0));
        assertEq(_userPoolTokenBalance, _userBorrowTokenBalanceAfter - _userBorrowTokenBalanceBefore);

        _userPoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        assertEq(_userPoolTokenBalance, 0);
    }

    // Test 10: A requested PCL cannot be liquidated
    function test_lendersCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate a requested PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 11: Admin should be able to terminate
    function test_adminCanTerminatePCL(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertTrue((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate) == 0);
    }

    // Test 12: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.1: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest cannot be withdrawn amidst price fluctuations
    function test_lendersCannotWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try lender1.withdrawInterest(requestId) {
            revert('Interest cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    // Test 14: A requested PCL can be cancelled
    function test_pclCanBeCancelled(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        createMultipleLenders(requestId, 5, uint128(request.borrowLimit - 10), request.borrowAsset);
        vm.warp(block.timestamp + (request.collectionPeriod - 1 days));

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.cancelRequest(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    function assert_helperFunctionalitiesInRequestedState(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from a requested PCL before its collection period
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_helperFunctionsInRequestedState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInRequestedState(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}",5971
RealWorld_TA_101_creditLine.HelperFunctions.t_RealWorld_20240812164017.log,101,creditLine.HelperFunctions.t,782274,224,782498,114.0,3.91585,"pragma solidity 0.7.6;
pragma abicoder v2;

import './Helpers/CLParent.sol';
import '../../PriceOracle.sol';

import '@openzeppelin/contracts/math/SafeMath.sol';

contract CreditLine_HelperFunctionTests is CLParent {
    using SafeMath for uint256;

    CreditLine creditLine;
    PriceOracle priceOracle;

    uint256 constant YEAR_IN_SECONDS = 365 days;
    uint256 constant SCALING_FACTOR = 1e18;

    uint256 public creditLineId;
    address public borrowAssetStrategy;
    address public collateralStrategy;
    uint256 _ratioOfPrices;
    uint256 _decimals;
    uint256 calculatedInterest;
    uint256 calculatedCollateralRatio;
    uint256 borrowRate;
    uint256 principal;
    uint256 totalInterestRepaid;
    uint256 collateralRatio;
    uint256 collateralTokens;

    function setUp() public virtual {
        CLSetUp();

        creditLine = CreditLine(creditLineAddress);
        priceOracle = PriceOracle(priceOracleAddress);

        (_ratioOfPrices, _decimals) = priceOracle.getLatestPrice(address(usdc), address(borrowAsset));

        requestData.requestTo = address(lender);
        // Borrow Asset equivalent of 1,000,000,000 in USD
        requestData.borrowLimit = uint128(uint256(CLConstants.maxBorrowLimit / 1e6).mul(_ratioOfPrices).div(10**_decimals));
        requestData.borrowRate = CLConstants.maxBorrowRate / 1e18;
        requestData.autoLiquidation = false;
        requestData.collateralRatio = CLConstants.maxCollteralRatio / 1e18;
        requestData.borrowAsset = address(borrowAsset);
        requestData.borrowAssetStrategy = noYieldAddress;
        requestData.collateralAsset = address(collateralAsset);
        requestData.collateralStrategy = noYieldAddress;
        requestData.requestAsLender = false;

        creditLineId = goToActiveStage();

        // Setting global parameters
        borrowAssetStrategy = requestData.borrowAssetStrategy;
        collateralStrategy = requestData.collateralStrategy;
    }

    //----------------------- Credit line calculateInterest tests -----------------------//

    // Should have zero interest when principal is not borrowed, after collateral is deposited
    function test_calculateInterest_DepositCollateral() public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();
        uint256 timeElapsed = 10 days;

        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        // Time travel by 10 days
        _increaseBlock(block.timestamp + timeElapsed);

        // Interest after depositing collateral should be zero
        (, , , borrowRate, , , , , , , ) = creditLine.creditLineConstants(creditLineId);
        (, principal, , , ) = creditLine.creditLineVariables(creditLineId);

        uint256 currentInterest = creditLine.calculateInterestScaled(principal, borrowRate, timeElapsed).div(SCALING_FACTOR);
        assertEq(currentInterest, 0);
    }

    // Should have non-zero interest after principal is borrowed
    function test_calculateInterest_Borrow(uint128 _borrowAmount, uint128 _timeElapsed) public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();
        uint256 timeElapsed = scaleToRange256(_timeElapsed, 1, 7500 days);

        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        uint256 Borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        uint256 BorrowAmount = scaleToRange256(_borrowAmount, 1, Borrowable);
        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, BorrowAmount);

        borrower.borrow(address(creditLine), creditLineId, BorrowAmount);
        _increaseBlock(block.timestamp + timeElapsed);
        assert_calculatedInterest(creditLineId, timeElapsed);
    }

    // Should have non-zero interest after some amount is repaid and zero after entire amount is repaid
    function test_calculateInterest_Repay(uint128 _repayAmount, uint128 _timeElapsed) public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();
        uint256 timeElapsed = scaleToRange256(_timeElapsed, 1, 7500 days);

        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        uint256 Borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, Borrowable);

        borrower.borrow(address(creditLine), creditLineId, Borrowable);
        _increaseBlock(block.timestamp + 10 days);

        uint256 currentDebt = creditLine.calculateCurrentDebt(creditLineId);
        uint256 repayAmount = scaleToRange256(_repayAmount, currentDebt.sub(Borrowable).add(1), currentDebt);

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(borrowAsset), address(borrower), repayAmount);
        borrower.setAllowance(address(creditLine), address(borrowAsset), repayAmount);

        borrower.repay(address(creditLine), creditLineId, repayAmount);
        assert_calculatedInterest(creditLineId, timeElapsed);

        _increaseBlock(block.timestamp + 10 days);

        uint256 remainingDebt = creditLine.calculateCurrentDebt(creditLineId);

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(borrowAsset), address(borrower), remainingDebt);
        borrower.setAllowance(address(creditLine), address(borrowAsset), remainingDebt);

        borrower.repay(address(creditLine), creditLineId, remainingDebt);

        // Interest after repaying entire credit line should be zero
        (, , , borrowRate, , , , , , , ) = creditLine.creditLineConstants(creditLineId);
        (, principal, , , ) = creditLine.creditLineVariables(creditLineId);

        uint256 currentInterest = creditLine.calculateInterestScaled(principal, borrowRate, timeElapsed).div(SCALING_FACTOR);
        assertEq(currentInterest, 0);
    }

    //----------------------- Credit line calculateInterest, assert helper -----------------------//

    function assert_calculatedInterest(uint256 _creditLineId, uint256 _timeElapsed) public {
        (, , , borrowRate, , , , , , , ) = creditLine.creditLineConstants(_creditLineId);
        (, principal, , , ) = creditLine.creditLineVariables(_creditLineId);

        uint256 currentInterest = creditLine.calculateInterestScaled(principal, borrowRate, _timeElapsed).div(SCALING_FACTOR);
        calculatedInterest = principal.mul(borrowRate).mul(_timeElapsed).div(SCALING_FACTOR).div(YEAR_IN_SECONDS);
        assertEq(currentInterest, calculatedInterest);
    }

    //----------------------- Credit line calculateInterestAccrued tests -----------------------//

    // Should have zero interest when principal is not borrowed, after collateral is deposited
    function test_calculateInterestAccrued_DepositCollateral() public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();
        uint256 timeElapsed = 10 days;

        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        _increaseBlock(block.timestamp + timeElapsed);

        uint256 currentInterest = creditLine.calculateInterestAccrued(creditLineId);
        assertEq(currentInterest, 0);
    }

    // Should have non-zero interest after principal is borrowed
    function test_calculateInterestAccrued_Borrow(uint128 _borrowAmount, uint128 _timeElapsed) public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();
        uint256 timeElapsed = scaleToRange256(_timeElapsed, 1, 7500 days);
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        uint256 Borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        uint256 BorrowAmount = scaleToRange256(_borrowAmount, 1, Borrowable);
        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, BorrowAmount);

        borrower.borrow(address(creditLine), creditLineId, BorrowAmount);
        _increaseBlock(block.timestamp + timeElapsed);
        assert_calculateInterestAccrued(creditLineId, timeElapsed);
    }

    // Should have non-zero interest after some amount is repaid
    function test_calculateInterestAccrued_noPrincipal_Repay(uint128 _repayAmount, uint128 _timeElapsed) public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();
        uint256 timeElapsed = scaleToRange256(_timeElapsed, 1, 7500 days);
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        uint256 Borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, Borrowable);

        borrower.borrow(address(creditLine), creditLineId, Borrowable);

        _increaseBlock(block.timestamp + timeElapsed);

        uint256 interest = creditLine.calculateInterestAccrued(creditLineId);
        uint256 repayAmount = scaleToRange256(_repayAmount, 1, interest);

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(borrowAsset), address(borrower), repayAmount);
        borrower.setAllowance(address(creditLine), address(borrowAsset), repayAmount);

        borrower.repay(address(creditLine), creditLineId, repayAmount);
        assert_calculateInterestAccrued(creditLineId, timeElapsed);
    }

    //----------------------- Credit line calculateInterestAccrued, assert helper -----------------------//

    function assert_calculateInterestAccrued(uint256 _creditLineId, uint256 _timeElapsed) public {
        (, , , borrowRate, , , , , , , ) = creditLine.creditLineConstants(_creditLineId);
        (, principal, , , ) = creditLine.creditLineVariables(_creditLineId);

        uint256 currentInterest = creditLine.calculateInterestAccrued(_creditLineId);
        calculatedInterest = principal.mul(borrowRate).mul(_timeElapsed);
        if (calculatedInterest % SCALING_FACTOR.mul(YEAR_IN_SECONDS) != 0) {
            calculatedInterest = calculatedInterest.div(SCALING_FACTOR).div(YEAR_IN_SECONDS) + 1;
        } else {
            calculatedInterest = calculatedInterest.div(SCALING_FACTOR).div(YEAR_IN_SECONDS);
        }
        assertEq(currentInterest, calculatedInterest);
    }

    //----------------------- Credit line calculateCurrentDebt tests -----------------------//

    // Should have zero debt when principal is not borrowed, after collateral is deposited
    function test_calculateCurrentDebt_DepositCollateral() public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();
        uint256 timeElapsed = 10 days;

        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        _increaseBlock(block.timestamp + timeElapsed);

        uint256 currentDebt = creditLine.calculateCurrentDebt(creditLineId);
        assertEq(currentDebt, 0);
    }

    // Should have non-zero debt immediately after principal is borrowed
    function test_calculateCurrentDebt_Borrow(uint128 _borrowAmount, uint128 _timeElapsed) public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();
        uint256 timeElapsed = scaleToRange256(_timeElapsed, 1, 7500 days);
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        uint256 Borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        uint256 BorrowAmount = scaleToRange256(_borrowAmount, 1, Borrowable);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, BorrowAmount);

        borrower.borrow(address(creditLine), creditLineId, BorrowAmount);

        _increaseBlock(block.timestamp + timeElapsed);
        assert_calculateCurrentDebt(creditLineId, timeElapsed);
    }

    // Should have less debt after some amount is repaid
    function test_calculateCurrentDebt_Repay(uint128 _repayAmount, uint128 _timeElapsed) public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();
        uint256 timeElapsed = scaleToRange256(_timeElapsed, 1, 7500 days);

        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        uint256 Borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, Borrowable);

        borrower.borrow(address(creditLine), creditLineId, Borrowable);

        _increaseBlock(block.timestamp + timeElapsed);

        uint256 currentDebt = creditLine.calculateCurrentDebt(creditLineId);
        uint256 repayAmount = scaleToRange256(_repayAmount, 1, currentDebt);

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(borrowAsset), address(borrower), repayAmount);
        borrower.setAllowance(address(creditLine), address(borrowAsset), repayAmount);

        borrower.repay(address(creditLine), creditLineId, repayAmount);
        (, , , borrowRate, , , , , , , ) = creditLine.creditLineConstants(creditLineId);
        (, principal, totalInterestRepaid, , ) = creditLine.creditLineVariables(creditLineId);

        currentDebt = creditLine.calculateCurrentDebt(creditLineId);
        uint256 currentInterest = creditLine.calculateInterestAccrued(creditLineId);
        assertEq(currentDebt, currentInterest.add(principal).sub(totalInterestRepaid));
    }

    //----------------------- Credit line calculateCurrentDebt, assert helper -----------------------//

    function assert_calculateCurrentDebt(uint256 _creditLineId, uint256 _timeElapsed) public {
        (, , , borrowRate, , , , , , , ) = creditLine.creditLineConstants(_creditLineId);
        (, principal, , , ) = creditLine.creditLineVariables(_creditLineId);

        uint256 currentDebt = creditLine.calculateCurrentDebt(_creditLineId);
        calculatedInterest = principal.mul(borrowRate).mul(_timeElapsed);
        if (calculatedInterest % SCALING_FACTOR.mul(YEAR_IN_SECONDS) != 0) {
            calculatedInterest = calculatedInterest.div(SCALING_FACTOR).div(YEAR_IN_SECONDS) + 1;
        } else {
            calculatedInterest = calculatedInterest.div(SCALING_FACTOR).div(YEAR_IN_SECONDS);
        }
        assertEq(currentDebt, calculatedInterest.add(principal));
    }

    //----------------------- Credit line calculateTotalCollateralTokens tests -----------------------//

    // Should have same amount of collateral tokens, after addCollateral operation
    function test_calculateTotalCollateralTokens_DepositCollateral(uint128 _amount) public {
        uint256 amount = scaleToRange256(_amount, 1, collateralAsset.totalSupply());
        uint256 timeElapsed = 10 days;
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        uint256 collateralShares = IYield(collateralStrategy).getSharesForTokens(amount, address(collateralAsset));
        _increaseBlock(block.timestamp + timeElapsed);
        assert_calculateTotalCollateralTokens(creditLineId, collateralShares);
    }

    // Should have same amount of collateral tokens, after addCollateral operation
    function test_calculateTotalCollateralTokens_DepositCollateralTwice(uint128 _amount, uint128 _secondAmount) public {
        uint256 maxAmount = collateralAsset.totalSupply();
        uint256 amount = scaleToRange256(_amount, 1, maxAmount.div(3));
        uint256 secondAmount = scaleToRange256(_secondAmount, 1, maxAmount.div(3));
        uint256 timeElapsed = 5 days;
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        uint256 collateralShares = IYield(collateralStrategy).getSharesForTokens(amount, address(collateralAsset));
        _increaseBlock(block.timestamp + timeElapsed);
        assert_calculateTotalCollateralTokens(creditLineId, collateralShares);

        // Adding collateral again
        admin.transferToken(address(collateralAsset), address(borrower), secondAmount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), secondAmount);

        borrower.addCollateral(address(creditLine), creditLineId, secondAmount, false);
        uint256 collateralShares1 = IYield(collateralStrategy).getSharesForTokens(secondAmount, address(collateralAsset));
        _increaseBlock(block.timestamp + timeElapsed);
        assert_calculateTotalCollateralTokens(creditLineId, collateralShares.add(collateralShares1));
    }

    // Should have same amount of collateral tokens, after borrow operation
    function test_calculateTotalCollateralTokens_Borrow(uint128 _borrowAmount) public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        uint256 collateralShares = IYield(collateralStrategy).getSharesForTokens(amount, address(collateralAsset));

        uint256 Borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        uint256 BorrowAmount = scaleToRange256(_borrowAmount, 1, Borrowable);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, BorrowAmount);

        borrower.borrow(address(creditLine), creditLineId, BorrowAmount);
        assert_calculateTotalCollateralTokens(creditLineId, collateralShares);
    }

    // Should have same amount of collateral tokens, after repayment operation
    function test_calculateTotalCollateralTokens_Repay(uint128 _repayAmount) public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();

        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        uint256 collateralShares = IYield(collateralStrategy).getSharesForTokens(amount, address(collateralAsset));
        uint256 Borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, Borrowable);

        borrower.borrow(address(creditLine), creditLineId, Borrowable);
        uint256 repayAmount = scaleToRange256(_repayAmount, 1, borrowAsset.totalSupply());

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(borrowAsset), address(borrower), repayAmount);
        borrower.setAllowance(address(creditLine), address(borrowAsset), repayAmount);

        borrower.repay(address(creditLine), creditLineId, repayAmount);
        assert_calculateTotalCollateralTokens(creditLineId, collateralShares);
    }

    //----------------------- Credit line calculateTotalCollateralTokens, assert helper -----------------------//

    function assert_calculateTotalCollateralTokens(uint256 _creditLineId, uint256 _collateralShares) public {
        uint256 totalCollateral = creditLine.calculateTotalCollateralTokens(_creditLineId);
        uint256 calculatedCollateral = IYield(collateralStrategy).getTokensForShares(_collateralShares, address(collateralAsset));
        assertApproxEqRel(totalCollateral, calculatedCollateral, 1e14);
    }

    //----------------------- Credit line calculateCurrentCollateralRatio tests -----------------------//

    // Current debt is zero, CCR = max(uint256)
    function test_calculateCurrentCollateralRatio_DepositCollateral() public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        (collateralRatio, ) = creditLine.calculateCurrentCollateralRatio(creditLineId);
        assertEq(collateralRatio, type(uint256).max);
    }

    // Should have non-zero collateral ratio immediately after principal is borrowed
    // If current debt is zero, CCR = max(uint256)
    function test_calculateCurrentCollateralRatio_Borrow(uint128 _borrowAmount) public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();

        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        uint256 collateralShares = IYield(collateralStrategy).getSharesForTokens(amount, address(collateralAsset));

        uint256 Borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        uint256 BorrowAmount = scaleToRange256(_borrowAmount, 1, Borrowable);
        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, BorrowAmount);

        borrower.borrow(address(creditLine), creditLineId, BorrowAmount);
        assert_calculateCurrentCollateralRatio(creditLineId, collateralShares);
    }

    // Should have non-zero collateral ratio after some amount is repaid
    function test_calculateCurrentCollateralRatio_Repay(uint128 _repayAmount) public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();

        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        uint256 collateralShares = IYield(collateralStrategy).getSharesForTokens(amount, address(collateralAsset));
        uint256 Borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, Borrowable);

        borrower.borrow(address(creditLine), creditLineId, Borrowable);

        uint256 repayAmount = scaleToRange256(_repayAmount, 1, borrowAsset.totalSupply());

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(borrowAsset), address(borrower), repayAmount);
        borrower.setAllowance(address(creditLine), address(borrowAsset), repayAmount);

        borrower.repay(address(creditLine), creditLineId, repayAmount);
        assert_calculateCurrentCollateralRatio(creditLineId, collateralShares);
    }

    //----------------------- Credit line calculateCurrentCollateralRatio tests -----------------------//

    function assert_calculateCurrentCollateralRatio(uint256 _creditLineId, uint256 _collateralShares) public {
        (, principal, , , ) = creditLine.creditLineVariables(_creditLineId);

        (_ratioOfPrices, _decimals) = IPriceOracle(priceOracle).getLatestPrice(address(collateralAsset), address(borrowAsset));

        (collateralRatio, ) = creditLine.calculateCurrentCollateralRatio(_creditLineId);
        uint256 totalCollateral = IYield(collateralStrategy).getTokensForShares(_collateralShares, address(collateralAsset));
        if (principal == 0) {
            // After complete repayment
            assertEq(collateralRatio, type(uint256).max);
        } else {
            calculatedCollateralRatio = totalCollateral.mul(_ratioOfPrices).div(10**_decimals).mul(SCALING_FACTOR).div(principal);
            assertApproxEqRel(collateralRatio, calculatedCollateralRatio, 1e14);
        }
    }

    //----------------------- Credit line calculateBorrowableAmount tests -----------------------//

    // Should have zero borrowable amount when collateral is not deposited
    function test_calculateBorrowableAmount() public {
        uint256 borrowableAmount = creditLine.calculateBorrowableAmount(creditLineId);
        assertEq(borrowableAmount, 0);
    }

    // Should have some borrowable amount after collateral is deposited
    function test_calculateBorrowableAmount_DepositCollateral(uint128 _amount) public {
        uint256 amount = scaleToRange256(_amount, 1, collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        (, , , borrowRate, collateralRatio, , , , , , ) = creditLine.creditLineConstants(creditLineId);
        (, principal, , , ) = creditLine.creditLineVariables(creditLineId);

        (_ratioOfPrices, _decimals) = IPriceOracle(priceOracle).getLatestPrice(address(collateralAsset), address(borrowAsset));

        uint256 borrowableAmount = creditLine.calculateBorrowableAmount(creditLineId);
        uint256 totalCollateral = creditLine.calculateTotalCollateralTokens(creditLineId);
        uint256 calculatedMaxPossible = totalCollateral.mul(_ratioOfPrices).div(collateralRatio).mul(SCALING_FACTOR).div(10**_decimals);
        assertApproxEqRel(borrowableAmount, Math.min(requestData.borrowLimit, calculatedMaxPossible), 1e14);
    }

    // Should have non-zero borrowable amount immediately after some amount is borrowed
    function test_calculateBorrowableAmount_Borrow(uint128 _borrowAmount, uint128 _timeElapsed) public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();
        uint256 timeElapsed = scaleToRange256(_timeElapsed, 1, 7500 days);
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        uint256 collateralShares = IYield(collateralStrategy).getSharesForTokens(amount, address(collateralAsset));

        uint256 Borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        uint256 BorrowAmount = scaleToRange256(_borrowAmount, 1, Borrowable);
        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, BorrowAmount);

        borrower.borrow(address(creditLine), creditLineId, BorrowAmount);
        _increaseBlock(block.timestamp + timeElapsed);

        assert_calculateBorrowableAmount(creditLineId, collateralShares);
    }

    // Should have zero borrowable amount immediately after all amount is borrowed
    function test_calculateBorrowableAmount_BorrowAll() public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        uint256 collateralShares = IYield(collateralStrategy).getSharesForTokens(amount, address(collateralAsset));

        uint256 Borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, Borrowable);

        borrower.borrow(address(creditLine), creditLineId, Borrowable);

        assert_calculateBorrowableAmount(creditLineId, collateralShares);
    }

    // Should have zero borrowable after some amount is repaid
    function test_calculateBorrowableAmount_Repay(
        uint128 _borrowAmount,
        uint128 _repayAmount,
        uint128 _timeElapsed
    ) public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();
        uint256 timeElapsed = scaleToRange256(_timeElapsed, 1, 7500 days);
        uint256 repayAmount = scaleToRange256(_repayAmount, 1, borrowAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        uint256 collateralShares = IYield(collateralStrategy).getSharesForTokens(amount, address(collateralAsset));

        uint256 Borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        uint256 BorrowAmount = scaleToRange256(_borrowAmount, 1, Borrowable);
        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, BorrowAmount);

        borrower.borrow(address(creditLine), creditLineId, BorrowAmount);

        _increaseBlock(block.timestamp + timeElapsed);

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(borrowAsset), address(borrower), repayAmount);
        borrower.setAllowance(address(creditLine), address(borrowAsset), repayAmount);

        try borrower.repay(address(creditLine), creditLineId, repayAmount) {
            assert_calculateBorrowableAmount(creditLineId, collateralShares);
        } catch Error(string memory reason) {
            assertEq(reason, 'SA:D2');
        }
    }

    //----------------------- Credit line calculateBorrowableAmount, assert help -----------------------//

    function assert_calculateBorrowableAmount(uint256 _creditLineId, uint256 _collateralShares) public {
        (, , , , collateralRatio, , , , , , ) = creditLine.creditLineConstants(_creditLineId);
        (, principal, totalInterestRepaid, , ) = creditLine.creditLineVariables(creditLineId);

        (_ratioOfPrices, _decimals) = IPriceOracle(priceOracle).getLatestPrice(address(collateralAsset), address(borrowAsset));

        uint256 borrowableAmount = creditLine.calculateBorrowableAmount(_creditLineId);
        uint256 totalCollateral = IYield(collateralStrategy).getTokensForShares(_collateralShares, address(collateralAsset));
        uint256 interestAccrued = creditLine.calculateInterestAccrued(_creditLineId);

        uint256 maxBorrowableAmount = totalCollateral.mul(_ratioOfPrices).div(collateralRatio).mul(SCALING_FACTOR).div(10**_decimals);

        if (maxBorrowableAmount <= principal.add(interestAccrued).sub(totalInterestRepaid)) {
            assertEq(borrowableAmount, 0);
        } else {
            assertApproxEqRel(
                borrowableAmount,
                Math.min(
                    maxBorrowableAmount - principal.add(interestAccrued).sub(totalInterestRepaid),
                    requestData.borrowLimit - principal
                ),
                1e14
            );
        }
    }

    //----------------------- Credit line withdrawableCollateral tests -----------------------//

    // Should have zero withdrawable collateral when collateral is not deposited
    function test_withdrawableCollateral() public {
        uint256 withdrawable = creditLine.withdrawableCollateral(creditLineId);
        assertEq(withdrawable, 0);
    }

    // Should have withdrawable amount = collateral deposited, when no amount is borrowed
    function test_withdrawableCollateral_DepositCollateral(uint128 _amount) public {
        uint256 amount = scaleToRange256(_amount, 1, collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        uint256 withdrawable = creditLine.withdrawableCollateral(creditLineId);
        assertApproxEqAbs(withdrawable, amount, 1);
    }

    // Should have withdrawable amount < collateral deposited, when some amount is borrowed
    function test_withdrawableCollateral_Borrow(uint128 _borrowAmount, uint128 _timeElapsed) public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();
        uint256 timeElapsed = scaleToRange256(_timeElapsed, 1, 7500 days);
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        uint256 Borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        uint256 BorrowAmount = scaleToRange256(_borrowAmount, 1, Borrowable);
        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, BorrowAmount);

        borrower.borrow(address(creditLine), creditLineId, BorrowAmount);
        _increaseBlock(block.timestamp + timeElapsed);
        assert_withdrawableCollateral(creditLineId);
    }

    // Should have non-zero withdrawable collateral after some amount is repaid
    function test_withdrawableCollateral_Repay(uint128 _repayAmount, uint128 _timeElapsed) public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();
        uint256 timeElapsed = scaleToRange256(_timeElapsed, 1, 7500 days);
        uint256 repayAmount = scaleToRange256(_repayAmount, 1, borrowAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        uint256 Borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, Borrowable);

        borrower.borrow(address(creditLine), creditLineId, Borrowable);

        _increaseBlock(block.timestamp + timeElapsed);

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(borrowAsset), address(borrower), repayAmount);
        borrower.setAllowance(address(creditLine), address(borrowAsset), repayAmount);

        borrower.repay(address(creditLine), creditLineId, repayAmount);
        _increaseBlock(block.timestamp + timeElapsed);
        assert_withdrawableCollateral(creditLineId);
    }

    //----------------------- Credit line withdrawableCollateral, assert helper -----------------------//

    function assert_withdrawableCollateral(uint256 _creditLineId) public {
        (, , , borrowRate, collateralRatio, , , , , , ) = creditLine.creditLineConstants(_creditLineId);
        (, principal, , , ) = creditLine.creditLineVariables(_creditLineId);

        (_ratioOfPrices, _decimals) = IPriceOracle(priceOracle).getLatestPrice(address(collateralAsset), address(borrowAsset));

        uint256 withdrawable = creditLine.withdrawableCollateral(_creditLineId);
        uint256 currentDebt = creditLine.calculateCurrentDebt(_creditLineId);
        uint256 totalCollateral = creditLine.calculateTotalCollateralTokens(_creditLineId);
        uint256 calculatedWithdrawable = currentDebt.mul(collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(SCALING_FACTOR);

        if (calculatedWithdrawable >= totalCollateral) {
            // value more than total collateral tokens
            assertEq(withdrawable, 0);
        } else {
            assertApproxEqRel(withdrawable, totalCollateral.sub(calculatedWithdrawable), 1e14);
        }
    }

    //----------------------- Credit line borrowTokensToLiquidate tests -----------------------//

    // Should have zero borrowTokensToLiquidate when principal is not borrowed, after collateral is deposited
    function test_borrowTokensToLiquidate_DepositCollateral() public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        uint256 Toliquidate = creditLine.borrowTokensToLiquidate(creditLineId);
        // current debt is 0, hence borrowTokens to liquidate is also 0
        assertEq(Toliquidate, 0);
    }

    // Should have non-zero borrowTokensToLiquidate immediately after principal is borrowed
    function test_borrowTokensToLiquidate_Borrow(uint128 _borrowAmount, uint128 _timeElapsed) public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();
        uint256 timeElapsed = scaleToRange256(_timeElapsed, 1, 7500 days);
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        uint256 collateralShares = IYield(collateralStrategy).getSharesForTokens(amount, address(collateralAsset));

        uint256 Borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        uint256 BorrowAmount = scaleToRange256(_borrowAmount, 1, Borrowable);
        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, BorrowAmount);

        borrower.borrow(address(creditLine), creditLineId, BorrowAmount);
        _increaseBlock(block.timestamp + timeElapsed);
        assert_borrowTokensToLiquidate(creditLineId, collateralShares);
    }

    // Should have non-zero borrowTokensToLiquidate after some amount is repaid
    function test_borrowTokensToLiquidate_Repay(uint128 _repayAmount, uint128 _timeElapsed) public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();
        uint256 timeElapsed = scaleToRange256(_timeElapsed, 1, 7500 days);
        uint256 repayAmount = scaleToRange256(_repayAmount, 1, borrowAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        uint256 collateralShares = IYield(collateralStrategy).getSharesForTokens(amount, address(collateralAsset));
        uint256 Borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, Borrowable);

        borrower.borrow(address(creditLine), creditLineId, Borrowable);

        _increaseBlock(block.timestamp + timeElapsed);

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(borrowAsset), address(borrower), repayAmount);
        borrower.setAllowance(address(creditLine), address(borrowAsset), repayAmount);

        borrower.repay(address(creditLine), creditLineId, repayAmount);
        assert_borrowTokensToLiquidate(creditLineId, collateralShares);
    }

    //----------------------- Credit line borrowTokensToLiquidate, assert helper -----------------------//

    function assert_borrowTokensToLiquidate(uint256 _creditLineId, uint256 _collateralShares) public {
        (_ratioOfPrices, _decimals) = IPriceOracle(priceOracle).getLatestPrice(address(collateralAsset), address(borrowAsset));
        uint256 liquidatorRewardFraction = creditLine.liquidatorRewardFraction();
        uint256 Toliquidate = creditLine.borrowTokensToLiquidate(_creditLineId);
        uint256 debt = creditLine.calculateCurrentDebt(_creditLineId);
        uint256 equivalentCollateral = (debt).mul(10**_decimals).div(_ratioOfPrices);
        uint256 totalCollateral = IYield(collateralStrategy).getTokensForShares(_collateralShares, address(collateralAsset));
        if (equivalentCollateral > totalCollateral) {
            equivalentCollateral = totalCollateral;
        }
        uint256 borrowTokens = (equivalentCollateral.mul(uint256(SCALING_FACTOR).sub(liquidatorRewardFraction)).div(SCALING_FACTOR))
            .mul(_ratioOfPrices)
            .div(10**_decimals);
        assertApproxEqRel(Toliquidate, borrowTokens, 1e14);
    }
}",9330
RealWorld_TA_101_PCLActiveStage.t_RealWorld_20240812150704.log,101,PCLActiveStage.t,45753,2244,47997,72.0,0.273645,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLActiveStage.t.sol';

contract PCLActiveStageCollateralCompoundBorrowCompound is PCLActiveStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * (10**ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
    }
}",322
RealWorld_TA_101_ILenderPool_RealWorld_20240812182729.log,101,ILenderPool,37491,1855,39346,70.0,0.224555,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface ILenderPool {
    /**
     * @notice emitted when lender withdraws from pool of poole-credit-lines
     * @param amount amount that lender withdraws from borrow pool
     * @param lenderAddress address to which amount is withdrawn
     */
    event LiquidityWithdrawn(uint256 amount, address indexed lenderAddress);

    function create(
        uint256 _id,
        address _verifier,
        address _token,
        address _strategy,
        uint256 _borrowLimit,
        uint256 _minBorrowAmount,
        uint256 _collectionPeriod,
        bool _areTokensTransferable
    ) external;

    function start(uint256 _id) external;

    function borrowed(uint256 _id, uint256 _sharesBorrowed) external;

    function repaid(
        uint256 _id,
        uint256 _sharesRepaid,
        uint256 _interestShares
    ) external;

    function requestCancelled(uint256 _id) external;

    function terminate(uint256 id, address to) external;
}",228
RealWorld_TA_101_Constants_RealWorld_20240812141920.log,101,Constants,136951,1767,138718,83.0,0.720095,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';

library Constants {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    address constant wethGateway = 0xcc9a0B7c43DC2a5F023Bb9b738E45B0Ef6B06E04;
    address constant aaveProtocolDataProvider = 0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d;
    address constant aaveLendingPoolAddressesProvider = 0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5;

    // Price feed addresses
    // We'll be creating price feeds for:-
    // 1. WETH / USDC
    // 2. WBTC / WETH
    // 3. WBTC / DAI
    address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;
    address constant SHIB = 0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE;
    address constant BAT = 0x0D8775F648430679A709E98d2b0Cb6250d2887EF;

    // Chainlink base feeds against USD
    address constant ETH_priceFeedChainlink = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;
    address constant WBTC_priceFeedChainlink = 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c;
    address constant DAI_priceFeedChainlink = 0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9;
    address constant USDC_priceFeedChainlink = 0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6;

    address constant USDC_ETH_priceFeedUniswap = 0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640;
    address constant WBTC_WETH_priceFeedUniswap = 0xCBCdF9626bC03E24f779434178A73a0B4bad62eD;
    address constant WBTC_DAI_priceFeedUniswap = 0x391E8501b626C623d39474AfcA6f9e46c2686649; //has low liquidity

    address public constant ethUsdcPool = 0x8ad599c3A0ff1De082011EFDDc58f1908eb6e6D8;

    IERC20 constant dai = IERC20(DAI);
    IERC20 constant usdc = IERC20(USDC);
    IERC20 constant weth = IERC20(WETH);
    IERC20 constant wbtc = IERC20(WBTC);
    IERC20 constant shib = IERC20(SHIB);

    uint256 constant USD_decimals = 10**6; // USDC precision decimals
    uint256 constant BTC_decimals = 10**8; // WBTC precision decimals
    uint256 constant DAI_decimals = 10**18; // DAI precision decimals
    uint256 constant WETH_decimals = 10**18; // WETH precision decimals
    uint256 constant SHIB_decimals = 10**18; // SHIB precision decimals

    uint256 constant WAD = 10**18;
    uint256 constant RAY = 10**27;

    uint256 constant verificationActivationDelay = 0;
    uint256 public constant maxStrategies = 10;

    address public constant COMPTROLLER = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;
    address public constant cETH = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;
    address public constant cUSDC = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;
    address public constant cDAI = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;
    address public constant cWBTC = 0xccF4429DB6322D5C611ee964527D42E5d685DD6a;

    address public constant weth9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address public constant _wethGateway = 0xcc9a0B7c43DC2a5F023Bb9b738E45B0Ef6B06E04;
    address public constant _protocolDataProvider = 0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d;
    address public constant _lendingPoolAddressesProvider = 0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5;
    address public constant _treasuryAddress = 0xC055b964a32B8275F41A1521fA9A4AbfE0eC5F09;

    uint128 public constant CHAINLINK_HEARTBEAT = type(uint128).max;
}",1445
RealWorld_TA_101_PCLLifecycleTestCompoundYield.t_RealWorld_20240812152648.log,101,PCLLifecycleTestCompoundYield.t,28390,3393,31783,90.0,0.20981,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import './PCLLifecycleTest.t.sol';

contract PCLLifecycleTestCompoundYield is PCLLifecycleTest {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        super.setUp();
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
    }
}",109
RealWorld_TA_101_creditLine.Compound.ActiveStage.t_RealWorld_20240812165906.log,101,creditLine.Compound.ActiveStage.t,29104,2371,31475,82.0,0.19294,"pragma solidity 0.7.6;
pragma abicoder v2;

import '../creditLine.ActiveStage.t.sol';

contract CreditLine_Compound_ActiveStageTests is CreditLine_ActiveStageTests {
    function setUp() public override {
        super.setUp();

        requestData.borrowAssetStrategy = compoundYieldAddress;
        requestData.collateralStrategy = compoundYieldAddress;

        creditLineId = goToActiveStage();

        // Setting global parameters
        borrowAssetStrategy = requestData.borrowAssetStrategy;
        collateralStrategy = requestData.collateralStrategy;
    }
}",113
RealWorld_TA_101_CompoundYield_RealWorld_20240812174334.log,101,CompoundYield,287872,5579,293451,213.0,1.55094,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/ICEther.sol';
import '../interfaces/Invest/ICToken.sol';
import '../interfaces/Invest/IComptroller.sol';
import '../interfaces/IWETH9.sol';

/**
 * @title Yield contract
 * @notice Implements the functions to lock/unlock tokens into available exchanges
 * @author Sublime
 **/
contract CompoundYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuardUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    //-------------------------------- Constants start --------------------------------/

    // address of treasury where tokens are sent in case of emergencies
    address public immutable TREASURY;

    /**
     * @notice stores the address of wrapped eth token
     **/
    address public immutable WETH;

    /**
     * @notice stores the address of savings account contract
     **/
    address public immutable SAVINGS_ACCOUNT;

    //-------------------------------- Constants end --------------------------------/

    //-------------------------------- Global vars start --------------------------------/

    /**
     * @notice the max amount that can be deposited for every token to the yield contract
     */
    mapping(address => uint256) public depositLimit;

    /**
     * @notice stores the address of liquidity token for a given base token
     */
    mapping(address => address) public override liquidityToken;

    //-------------------------------- Global vars end --------------------------------/

    //-------------------------------- Events start --------------------------------/

    /**
     * @notice emitted when all tokens are withdrawn, in case of emergencies
     * @param asset address of the token being withdrawn
     * @param withdrawTo address of the wallet to which tokens are withdrawn
     * @param tokensReceived amount of tokens received
     **/
    event EmergencyWithdraw(address indexed asset, address indexed withdrawTo, uint256 tokensReceived);

    /**
     * @notice emitted when liquidity token address of an asset is updated
     * @param asset the address of asset
     * @param protocolToken address of the liquidity token for the asset
     **/
    event TokenAddressesUpdated(address indexed asset, address indexed protocolToken);

    //-------------------------------- Events end --------------------------------/

    //-------------------------------- Modifiers start --------------------------------/

    /**
     * @notice checks if contract is invoked by savings account
     **/
    modifier onlySavingsAccount() {
        require(msg.sender == SAVINGS_ACCOUNT, 'CY:OSA1');
        _;
    }

    //-------------------------------- Modifiers end --------------------------------/

    //-------------------------------- Init start --------------------------------/

    /**
     * @notice constructor
     * @param _weth address of the wrapped Ether contract
     * @param _treasury address of the TREASURY where tokens are sent in case of emergencies
     * @param _savingsAccount address of the savings account contract
     **/
    constructor(
        address _weth,
        address _treasury,
        address _savingsAccount
    ) {
        require(_weth != address(0), 'CY:C1');
        require(_treasury != address(0), 'CY:C2');
        require(_savingsAccount != address(0), 'CY:C3');
        WETH = _weth;
        TREASURY = _treasury;
        SAVINGS_ACCOUNT = _savingsAccount;
    }

    /**
     * @notice used to initialize the variables in the contract
     * @dev can only be called once
     * @param _owner address of the owner
     **/
    function initialize(address _owner) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
    }

    //-------------------------------- Init end --------------------------------/

    //-------------------------------- lock start --------------------------------/

    /**
     * @notice Used to lock tokens in available protocol
     * @dev Asset Tokens to be locked must be approved to this contract by user
     * @param _user the address of user
     * @param _asset the address of token to invest
     * @param _amount the amount of asset
     * @return sharesReceived amount of shares received
     **/
    function lockTokens(
        address _user,
        address _asset,
        uint256 _amount
    ) external override onlySavingsAccount nonReentrant returns (uint256) {
        uint256 _sharesReceived;
        address _investedTo = liquidityToken[_asset];

        uint256 _totalBalance = ICToken(_investedTo).balanceOfUnderlying(address(this));
        require(depositLimit[_asset] > _totalBalance.add(_amount), 'CY:LT1');

        IERC20(_asset).safeTransferFrom(_user, address(this), _amount);
        if (_asset == WETH) {
            IWETH9(WETH).withdraw(_amount);
            _sharesReceived = _depositETH(_investedTo, _amount);
        } else {
            _sharesReceived = _depositERC20(_asset, _investedTo, _amount);
        }
        emit LockedTokens(_user, _investedTo, _sharesReceived);
        return _sharesReceived;
    }

    function _depositETH(address _cToken, uint256 _amount) private returns (uint256) {
        uint256 _initialCTokenBalance = IERC20(_cToken).balanceOf(address(this));
        //mint cToken
        ICEther(_cToken).mint{value: _amount}();

        uint256 _latterCTokenBalance = IERC20(_cToken).balanceOf(address(this));
        uint256 _sharesReceived = _latterCTokenBalance.sub(_initialCTokenBalance);
        return _sharesReceived;
    }

    function _depositERC20(
        address _asset,
        address _cToken,
        uint256 _amount
    ) private returns (uint256) {
        uint256 _initialCTokenBalance = IERC20(_cToken).balanceOf(address(this));
        //mint cToken
        IERC20(_asset).safeApprove(_cToken, 0);
        IERC20(_asset).safeApprove(_cToken, _amount);
        require(ICToken(_cToken).mint(_amount) == 0, 'CY:IDERC1');

        uint256 _latterCTokenBalance = IERC20(_cToken).balanceOf(address(this));
        uint256 _sharesReceived = _latterCTokenBalance.sub(_initialCTokenBalance);
        return _sharesReceived;
    }

    //-------------------------------- lock end --------------------------------/

    //-------------------------------- unlock start --------------------------------/

    /**
     * @notice Used to unlock tokens from available protocol
     * @param _asset the address of the underlying token (Example: For Compound, Underlying token of cTokenA is TokenA)
     * @param _to address to transfer tokens to
     * @param _shares the amount of shares to unlock
     * @return amount of tokens received
     **/
    function unlockTokens(
        address _asset,
        address _to,
        uint256 _shares
    ) external override onlySavingsAccount nonReentrant returns (uint256) {
        address _investedTo = liquidityToken[_asset];
        uint256 _received;
        if (_asset == WETH) {
            _received = _withdrawETH(_investedTo, _shares);
            IWETH9(WETH).deposit{value: _received}();
        } else {
            _received = _withdrawERC(_asset, _investedTo, _shares);
        }
        IERC20(_asset).safeTransfer(_to, _received);

        emit UnlockedTokens(_asset, _received);
        return _received;
    }

    /**
     * @notice Used to unlock shares
     * @param _asset the address of share token (Example: For Compound, Share token of TokenA is cTokenA)
     * @param _to address to transfer shares to
     * @param _shares the amount of shares to unlock
     * @return received amount of shares received
     **/
    function unlockShares(
        address _asset,
        address _to,
        uint256 _shares
    ) external override onlySavingsAccount nonReentrant returns (uint256) {
        if (_shares == 0) return 0;

        IERC20(_asset).safeTransfer(_to, _shares);

        emit UnlockedShares(_asset, _shares);
        return _shares;
    }

    function _withdrawETH(address _cToken, uint256 _shares) private returns (uint256) {
        uint256 _ethBalance = address(this).balance;

        require(ICEther(_cToken).redeem(_shares) == 0, 'CY:IWE1');

        return (address(this).balance.sub(_ethBalance));
    }

    function _withdrawERC(
        address _asset,
        address _cToken,
        uint256 _shares
    ) private returns (uint256) {
        uint256 _initialAssetBalance = IERC20(_asset).balanceOf(address(this));
        require(ICToken(_cToken).redeem(_shares) == 0, 'CY:IWERC1');
        uint256 _tokensReceived = IERC20(_asset).balanceOf(address(this)).sub(_initialAssetBalance);
        return _tokensReceived;
    }

    //-------------------------------- unlock end --------------------------------/

    //-------------------------------- Admin functions start --------------------------------/

    /**
     * @notice used to withdraw all tokens of a type in case of emergencies
     * @dev only owner can withdraw
     * @param _asset address of the token being withdrawn
     * @param _wallet address to which tokens are withdrawn
     */
    function emergencyWithdraw(address _asset, address _wallet) external onlyOwner returns (uint256) {
        require(_wallet != address(0), 'CY:EW1');
        address _investedTo = liquidityToken[_asset];
        uint256 _received;

        uint256 _amount = ICToken(_investedTo).balanceOfUnderlying(address(this));

        uint256 _availableCash = ICToken(_investedTo).getCash();
        if (_amount > _availableCash) {
            _amount = _availableCash;
        }

        uint256 _amountInShares = getSharesForTokens(_amount, _asset);

        if (_asset == WETH) {
            _received = _withdrawETH(_investedTo, _amountInShares);
            IWETH9(WETH).deposit{value: _received}();
        } else {
            _received = _withdrawERC(_asset, _investedTo, _amountInShares);
        }
        IERC20(_asset).safeTransfer(_wallet, _received);

        emit EmergencyWithdraw(_asset, _wallet, _received);
        return _received;
    }

    /**
     * @notice withdraw the comp tokens supplied
     * @dev only owner can call
     * @param _comptroller address of the comptroller contract
     * @param _compToken address of the comp token
     */
    function claimCompTokens(address _comptroller, address _compToken) external onlyOwner returns (uint256) {
        IComptroller(_comptroller).claimComp(address(this));
        uint256 _compBalance = IERC20(_compToken).balanceOf(address(this));
        IERC20(_compToken).safeTransfer(TREASURY, _compBalance);
        return _compBalance;
    }

    //-------------------------------- Admin functions end --------------------------------/

    //-------------------------------- Global var setters start --------------------------------/

    function setDepositLimit(address _asset, uint256 _limit) external onlyOwner {
        depositLimit[_asset] = _limit;
    }

    /**
     * @notice used to link a liquidity token to an asset
     * @dev can only be called by owner
     * @param _asset address of the token
     * @param _liquidityToken address of the liquidityToken for the given token
     **/
    function addTokenAddress(address _asset, address _liquidityToken) external onlyOwner {
        require(liquidityToken[_asset] == address(0), 'CY:ATA1');
        liquidityToken[_asset] = _liquidityToken;
        emit TokenAddressesUpdated(_asset, _liquidityToken);
    }

    /**
     * @notice used to update liquidity token for an asset
     * @dev can only be called by owner and only in emergency scenarios, add/removeTokenAddress is used in general
     * @param _asset address of the token
     * @param _liquidityToken address of the liquidityToken for the given token
     **/
    function forceUpdateTokenAddress(address _asset, address _liquidityToken) external onlyOwner {
        liquidityToken[_asset] = _liquidityToken;
        emit TokenAddressesUpdated(_asset, _liquidityToken);
    }

    /**
     * @notice used to remove liquidity token associated with an asset
     * @dev can only be called by owner
     * @param _asset address of the token
     * @param _liquidityToken address of the liquidityToken for the given token
     **/
    function removeTokenAddress(address _asset, address _liquidityToken) external onlyOwner {
        address _currentLiquidityToken = liquidityToken[_asset];
        require(_currentLiquidityToken != address(0), 'CY:RTA1');
        require(_currentLiquidityToken == _liquidityToken, 'CY:RTA2');
        require(ICToken(_currentLiquidityToken).balanceOfUnderlying(address(this)) == 0, 'CY:RTA3');
        delete liquidityToken[_asset];
        emit TokenAddressesUpdated(_asset, address(0));
    }

    //-------------------------------- Global var setters end --------------------------------/

    //-------------------------------- Utils start --------------------------------/
    /**
     * @dev Used to get amount of underlying tokens for given number of shares
     * @param _shares the amount of shares
     * @param _asset the address of token locked
     * @return amount of underlying tokens
     **/
    function getTokensForShares(uint256 _shares, address _asset) external override returns (uint256) {
        //balanceOfUnderlying returns underlying balance for total shares
        if (_shares == 0) return 0;
        address cToken = liquidityToken[_asset];
        uint256 exchangeRateCurrent = ICToken(cToken).exchangeRateCurrent();
        require(exchangeRateCurrent != 0, 'CY:GTFS1');
        uint256 amount = exchangeRateCurrent.mul(_shares).div(1e18);
        return amount;
    }

    /**
     * @notice Used to get number of shares from an amount of underlying tokens
     * @param _amount the amount of tokens
     * @param _asset the address of token
     * @return amount of shares for given tokens
     **/
    function getSharesForTokens(uint256 _amount, address _asset) public override returns (uint256) {
        address cToken = liquidityToken[_asset];
        uint256 exchangeRateCurrent = ICToken(cToken).exchangeRateCurrent();
        require(exchangeRateCurrent != 0, 'CY:GSFT1');
        return (_amount.mul(1e18)).div(exchangeRateCurrent);
    }

    //-------------------------------- Utils end --------------------------------/

    receive() external payable {
        require(msg.sender == liquidityToken[WETH] || msg.sender == WETH, 'CY:R1');
    }
}",3229
RealWorld_TA_101_PCLCancelledStateCompoundYield.t_RealWorld_20240812161659.log,101,PCLCancelledStateCompoundYield.t,70011,3906,73917,113.0,0.428175,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLCancelledState.t.sol';
import '../../Helpers/PCLParent.t.sol';

contract PCLCancelledStatePriceOracleCompoundYield is PCLCancelledStatePriceOracle {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        lender_0 = lenders[0].lenderAddress;

        // Let's travel a few days, but stay within the collection period
        vm.warp(block.timestamp + request.collectionPeriod / 2);

        // Borrower tries to cancel the PCL
        borrower.cancelRequest(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED, '!Cancelled');
    }
}",597
RealWorld_TA_101_PCLExpiredStage.t_RealWorld_20240812153743.log,101,PCLExpiredStage.t,80419,4618,85037,112.0,0.494455,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLStageTests/PCLExpiredStage.t.sol';

contract PCLExpiredStageZeroCollateral is PCLExpiredStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(requestId, _requiredCollateral, false);
        }
        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }
}",715
RealWorld_TA_101_PCLExpiredStage.t_RealWorld_20240812150511.log,101,PCLExpiredStage.t,79157,4154,83311,111.0,0.478865,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLExpiredStage.t.sol';

contract PCLExpiredStageCollateralCompoundBorrowNoYield is PCLExpiredStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }
}",705
RealWorld_TA_101_PCLParent.t_RealWorld_20240812162258.log,101,PCLParent.t,520406,7162,527568,200.0,2.74527,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
import '@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol';

import '../../roles/User.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../PriceOracle.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../SavingsAccount/SavingsAccountUtil.sol';
import '../../../Verification/Verification.sol';
import '../../../Verification/twitterVerifier.sol';
import '../../Constants.sol';
import '../../../mocks/MockToken.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockVerification.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../..//interfaces/IWETH9.sol';
import '../../ProtocolFeeCollector.sol';
import '../../roles/CompoundUser.sol';
import '../Roles/PCLAdmin.t.sol';
import './PCLConstants.t.sol';
import 'forge-std/Test.sol';

contract PCLParent is IPooledCreditLineDeclarations, Test {
    using stdStorage for StdStorage;

    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for ERC20;

    uint256 constant BLOCK_TIME = 20;

    bool isForked;

    address public priceOracleAddress;
    address public collateralCTokenAddress;
    address public borrowCTokenAddress;

    address public collateralAssetAggregatorAddress;
    address public borrowAssetAggregatorAddress;
    address public usdcAggregatorAddress;

    IERC20 public collateralAsset;
    IERC20 public borrowAsset;
    IERC20 public usdc;
    IWETH9 public weth;

    address public mockAdminVerifier1;
    address public mockAdminVerifier2;

    address public savingsAccountAddress;
    address public noYieldAddress;
    address public compoundYieldAddress;
    address public limitsManagerAddress;
    address public pooledCreditLineAddress;
    address public lenderPoolAddress;

    LenderPool lp;
    PooledCreditLine pcl;

    PCLAdmin public proxyAdmin;
    PCLAdmin public admin;
    address public protocolFeeCollectorAddress;

    PCLUser public borrower;
    CompoundUser public compoundUser;

    struct LenderInfo {
        address lenderAddress;
        uint256 amount;
    }

    mapping(uint256 => LenderInfo) public lenders;
    uint256 numLenders;

    Request request;

    function setCollateralAsset() public virtual {
        if (isForked) {
            collateralAsset = ERC20(Constants.WBTC);
            collateralAssetAggregatorAddress = Constants.WBTC_priceFeedChainlink;
            collateralCTokenAddress = Constants.cWBTC;
        } else {
            collateralAsset = new MockToken('CollateralAsset', 'MT1', 18, 1e40, address(admin));
            collateralAssetAggregatorAddress = address(new MockV3Aggregator(18, 12876423400040030304304));
        }
    }

    function setBorrowAsset() public virtual {
        if (isForked) {
            borrowAsset = ERC20(Constants.DAI);
            borrowAssetAggregatorAddress = Constants.DAI_priceFeedChainlink;
            borrowCTokenAddress = Constants.cDAI;
        } else {
            borrowAsset = new MockToken('BorrowAsset', 'MT2', 8, 1e40, address(admin));
            borrowAssetAggregatorAddress = address(new MockV3Aggregator(8, 195040576));
        }
    }

    function setUp() public virtual {
        uint256 _chainId = getChainID();
        if (_chainId == 1) {
            isForked = true;
        }

        // setting global actors
        proxyAdmin = new PCLAdmin(pooledCreditLineAddress, lenderPoolAddress);
        admin = new PCLAdmin(pooledCreditLineAddress, lenderPoolAddress);
        compoundUser = new CompoundUser();

        /* --- deploying contracts ----*/

        // deploying  mock protocol fee collector
        protocolFeeCollectorAddress = address(new ProtocolFeeCollector());

        /***** set up verification *****/
        // deploy verification related contracts
        address verificationAddress = admin.deployVerification(address(proxyAdmin));

        // deploy mock admin verifier
        mockAdminVerifier1 = admin.deployMockAdminVerifier(verificationAddress);
        mockAdminVerifier2 = admin.deployMockAdminVerifier(verificationAddress);

        // whitelist mockAdminVerifier
        admin.addVerifier(verificationAddress, mockAdminVerifier1);
        admin.addVerifier(verificationAddress, mockAdminVerifier2);

        /***** set up savings account *****/
        // deploy strategy registry
        address strategyRegistryAddress = admin.deployStrategyRegistry(PCLConstants.maxStrategies);
        // deploy savings account
        savingsAccountAddress = admin.deploySavingsAccount(strategyRegistryAddress);
        // deploy no yield
        noYieldAddress = admin.deployNoYield(address(admin), savingsAccountAddress, protocolFeeCollectorAddress);
        // add savings strategies to savings account
        admin.addSavingsAccountStrategy(strategyRegistryAddress, noYieldAddress);

        setCollateralAsset();
        setBorrowAsset();

        if (isForked) {
            // forked mode
            usdc = ERC20(Constants.USDC);
            weth = IWETH9(Constants.WETH);

            writeTokenBalance(address(admin), address(collateralAsset), collateralAsset.totalSupply());
            writeTokenBalance(address(admin), address(borrowAsset), borrowAsset.totalSupply());
            writeTokenBalance(address(admin), Constants.USDC, usdc.totalSupply());
            // weth.deposit{value: 1e30}();
            // IERC20(Constants.WETH).transfer(address(admin), 1e30);

            // deploy aggregators
            usdcAggregatorAddress = Constants.USDC_priceFeedChainlink;

            // deploy compound yield
            compoundYieldAddress = admin.deployCompoundYield(
                address(admin),
                savingsAccountAddress,
                address(weth),
                protocolFeeCollectorAddress
            );
            admin.addSavingsAccountStrategy(strategyRegistryAddress, compoundYieldAddress);
            admin.addTokenAddressForCompoundYield(payable(compoundYieldAddress), address(collateralAsset), collateralCTokenAddress);
            admin.addTokenAddressForCompoundYield(payable(compoundYieldAddress), address(borrowAsset), borrowCTokenAddress);
            admin.addTokenAddressForNoYield(noYieldAddress, address(borrowAsset));
            admin.addTokenAddressForNoYield(noYieldAddress, address(collateralAsset));
        } else {
            // standard mode

            vm.warp(block.timestamp + 10);

            usdc = new MockToken('USDC', 'USDC', 6, 1e20, address(admin));
            weth = new MockWETH();

            // deploy aggregators
            usdcAggregatorAddress = address(new MockV3Aggregator(6, 1000000));

            // deploy compound yield
            compoundYieldAddress = admin.deployCompoundYield(
                address(admin),
                savingsAccountAddress,
                address(weth),
                protocolFeeCollectorAddress
            );
            admin.addSavingsAccountStrategy(strategyRegistryAddress, compoundYieldAddress);

            // adding cToken for collateralAsset
            collateralCTokenAddress = admin.deployMockCToken(address(collateralAsset), compoundYieldAddress, noYieldAddress);
            admin.transferOwnership(address(collateralAsset), collateralCTokenAddress);

            // adding cToken for borrowAsset
            borrowCTokenAddress = admin.deployMockCToken(address(borrowAsset), compoundYieldAddress, noYieldAddress);
            admin.transferOwnership(address(borrowAsset), borrowCTokenAddress);
        }

        /***** set up price oracles *****/
        // deploy price oracle contract
        priceOracleAddress = admin.deployPriceOracle(address(admin), PCLConstants.uniswapPriceAveragingPeriod);

        // add aggregators to the oracle
        admin.setChainlinkFeedAddress(
            priceOracleAddress,
            address(collateralAsset),
            collateralAssetAggregatorAddress,
            Constants.CHAINLINK_HEARTBEAT
        );
        admin.setChainlinkFeedAddress(
            priceOracleAddress,
            address(borrowAsset),
            borrowAssetAggregatorAddress,
            Constants.CHAINLINK_HEARTBEAT
        );
        admin.setChainlinkFeedAddress(priceOracleAddress, address(usdc), usdcAggregatorAddress, Constants.CHAINLINK_HEARTBEAT);

        limitsManagerAddress = admin.deployLimitsManager(address(proxyAdmin), address(usdc), priceOracleAddress);

        {
            (pooledCreditLineAddress, lenderPoolAddress) = admin.deployPCLContracts(
                address(proxyAdmin), //proxyAdmin
                savingsAccountAddress, //savingsAccount
                verificationAddress, //verification
                priceOracleAddress, //priceOracle
                strategyRegistryAddress, //strategyRegistry
                limitsManagerAddress,
                protocolFeeCollectorAddress //protocolFeeCollector
            );
        }

        pcl = PooledCreditLine(pooledCreditLineAddress);
        lp = LenderPool(lenderPoolAddress);

        // setting PCL actors
        borrower = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        //emit log_named_address('borrower', address(borrower));
        //emit log_named_address('pcl in pclparent', pooledCreditLineAddress);
        // Verifying the borrower
        borrower.registerSelf(mockAdminVerifier2);
        // this is done to activate the registered user
        vm.warp(block.timestamp + Verification(verificationAddress).activationDelay());
    }

    function randomAmountToLend(uint256 _seed, uint256 _maxVal) public view returns (uint256) {
        // _amountToLend will only be 0 if the random number is a multiple of _maxVal
        // in this case we add a 1 to it.
        uint256 _amountToLend = uint256(keccak256(abi.encodePacked(block.timestamp, _seed))) % _maxVal;
        if (_amountToLend == 0) {
            _amountToLend = _amountToLend.add(1);
        }
        return _amountToLend;
    }

    /**
     * @dev Helper function used within generalizedLender to create a single lender and lend
     * @param _pooledCreditLineID Pooled credit line ID
     * @param _amountToLend Amount to lend
     * @param _asset Asset to be lent
     * @return address of the lender created
     */
    function createLender(
        uint256 _pooledCreditLineID,
        uint256 _amountToLend,
        address _asset
    ) public returns (address) {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(_asset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(_asset), type(uint256).max);
        _pooledCreditLineLender.lend(_pooledCreditLineID, _amountToLend);

        return address(_pooledCreditLineLender);
    }

    /**
     * @dev used to lend into a PCL in collection stage. lenders.lenderAddress & lenders.amount store details of every lender
     * @param _pooledCreditLineID id of the PCL to lend into
     * @param _nLenders number of lenders that must be created. If 0, it'll create random number of lenders
     * @param _amountToLend cumulative amount that all lenders must lend
     * @param _asset to be lent
     * @return the final number of lenders created by the function.
     */
    function createMultipleLenders(
        uint256 _pooledCreditLineID,
        uint256 _nLenders,
        uint128 _amountToLend,
        address _asset
    ) public returns (uint256) {
        if (_amountToLend < _nLenders) {
            address _lender = createLender(_pooledCreditLineID, _amountToLend, _asset);
            lenders[0].lenderAddress = _lender;
            lenders[0].amount = _amountToLend;

            return 1;
        }

        if (_nLenders != 0) {
            uint256 _maxAmountPerLender = _amountToLend / _nLenders;
            require(_maxAmountPerLender != 0, '_amountToLend is too small');
            uint256 _penultimateCumulativeAmountSupplied = 0;
            address _lender;

            for (uint256 i; i < _nLenders - 1; ++i) {
                uint256 _amountLent = randomAmountToLend(_penultimateCumulativeAmountSupplied, _maxAmountPerLender);

                // executing lend, and getting address of lender
                _lender = createLender(_pooledCreditLineID, _amountLent, _asset);

                // updating state mapping for address of lender and amount lent
                lenders[i].lenderAddress = _lender;
                lenders[i].amount = _amountLent;

                _penultimateCumulativeAmountSupplied += _amountLent;
            }

            uint256 _amountLeft = _amountToLend - _penultimateCumulativeAmountSupplied;

            // executing lend, and getting address of lender
            _lender = createLender(_pooledCreditLineID, _amountLeft, _asset);

            // updating state mapping for address of lender and amount lent
            lenders[_nLenders - 1].lenderAddress = _lender;
            lenders[_nLenders - 1].amount = _amountLeft;

            return _nLenders;
        } else {
            uint256 _cumAmountLent = 0;
            uint256 _lenderCounter = 0;
            address _lender;
            while (_cumAmountLent < _amountToLend) {
                uint256 _maxLendableAmount = _amountToLend - _cumAmountLent;
                uint256 _amountLent;
                _amountLent = randomAmountToLend(_cumAmountLent, _maxLendableAmount);
                _lender = createLender(_pooledCreditLineID, _amountLent, _asset);
                _cumAmountLent += _amountLent;
                lenders[_lenderCounter].lenderAddress = _lender;
                lenders[_lenderCounter].amount = _amountLent;

                _lenderCounter += 1;
            }

            return _lenderCounter + 1;
        }
    }

    /**
     * @dev helper function used to reset arguments used by the generalized lender
     * @param _nLenders number of lenders created by generalizedLender
     */
    function resetLenders(uint256 _nLenders) public {
        for (uint256 i; i <= _nLenders; ++i) {
            lenders[i].lenderAddress = address(0);
            lenders[i].amount = 0;
        }
    }

    function goToActiveStage(uint256 _numLenders, uint128 _amountToLend) public returns (uint256, uint256) {
        require(
            _amountToLend <= request.borrowLimit && _amountToLend >= request.minBorrowAmount,
            'Cannot go to active stage with given params'
        );
        uint256 _id = borrower.createRequest(request);
        uint256 _finalNumLenders = createMultipleLenders(_id, _numLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        borrower.start(_id);

        uint256 _status = uint256(PooledCreditLine(pooledCreditLineAddress).getStatusAndUpdate(_id));
        assertEq(_status, 2);

        return (_id, _finalNumLenders);
    }

    function scaleToRange256(
        uint256 value,
        uint256 min,
        uint256 max
    ) internal pure returns (uint256) {
        require(max != 0 && max >= min, 'wrong input');
        if (max == min) return max;
        return min + (value % (max - min));
    }

    function scaleToRange128(
        uint128 value,
        uint128 min,
        uint128 max
    ) internal pure returns (uint128) {
        require(max != 0 && max >= min, 'wrong input');
        if (max == min) return max;
        return min + (value % (max - min));
    }

    function getChainID() internal pure returns (uint256) {
        uint256 id;
        assembly {
            id := chainid()
        }
        return id;
    }

    function writeTokenBalance(
        address who,
        address token,
        uint256 amt
    ) internal {
        if (token != Constants.WETH) {
            uint256 _totalSupply = IERC20(token).totalSupply();
            uint256 _curBalance = IERC20(token).balanceOf(who);
            stdstore.target(token).sig(IERC20(token).balanceOf.selector).with_key(who).checked_write(amt + _curBalance);
            stdstore.target(token).sig(IERC20(token).totalSupply.selector).checked_write(_totalSupply + amt);
        } else {
            token.call{value: amt}('');
            IWETH9(token).transfer(who, amt);
        }
    }

    function borrowFromCompound(
        address _cToken,
        uint256 _collateralAmount,
        uint256 _borrowAmount
    ) public returns (uint256) {
        // borrowing from compound
        address(compoundUser).call{value: _collateralAmount}('');
        // emit log_named_uint(""ether balance"", address(compoundUser).balance);
        compoundUser.mintCETH(Constants.cETH, _collateralAmount);
        // emit log_named_uint(""cEther Balance"", IERC20(Constants.cETH).balanceOf(address(compoundUser)));
        address[] memory _cTokens = new address[](1);
        _cTokens[0] = Constants.cETH;
        compoundUser.enterMarkets(Constants.COMPTROLLER, _cTokens);
        // (, uint256 _liquidity, ) = IComptroller(Constants.COMPTROLLER).getAccountLiquidity(address(compoundUser));
        // emit log_named_uint(""account liquidity"", _liquidity);
        return compoundUser.borrow(_cToken, _borrowAmount);
        // emit log_named_uint(""borrow result"", _result);
        // emit log_named_uint(""compoundUser balance"", borrowAsset.balanceOf(address(compoundUser)));
    }

    function _increaseBlock(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(BLOCK_TIME));
    }

    modifier clearMockedCalls() {
        vm.clearMockedCalls();
        _;
    }

    function helper_exchangeRateChanges() public {
        console.log(MockCToken(borrowCTokenAddress).exchangeRateCurrent());
        console.log(MockCToken(collateralCTokenAddress).exchangeRateCurrent());

        uint256 _blockDelta = 1_000_000;
        _increaseBlock(block.timestamp + _blockDelta);

        console.log(MockCToken(borrowCTokenAddress).exchangeRateCurrent());
        console.log(MockCToken(collateralCTokenAddress).exchangeRateCurrent());
    }

    function helper_increaseExchangeRateSlowly(address _assetCTokenAddress) public {
        console.log(MockCToken(_assetCTokenAddress).exchangeRateCurrent());
        uint256 _exchangeRateCurrent = MockCToken(_assetCTokenAddress).exchangeRateCurrent();
        uint256 _blockDelta = 1_000_000;
        _increaseBlock(block.timestamp + _blockDelta);
        uint256 _exchangeRateMocked = (_exchangeRateCurrent * (1e18 + (_blockDelta * 1e4))) / 1e18;
        if (isForked) {
            vm.mockCall(
                _assetCTokenAddress,
                abi.encodeWithSelector(MockCToken.exchangeRateCurrent.selector),
                abi.encode(_exchangeRateMocked)
            );
        } else {
            MockCToken(_assetCTokenAddress).mockExchangeRateStored(_exchangeRateMocked);
        }

        console.log(MockCToken(_assetCTokenAddress).exchangeRateCurrent());
    }

    function helper_increaseExchangeRateSteeply(address _assetCTokenAddress) public {
        console.log(MockCToken(_assetCTokenAddress).exchangeRateCurrent());
        uint256 _exchangeRateCurrent = MockCToken(_assetCTokenAddress).exchangeRateCurrent();
        uint256 _blockDelta = 1_000_000;
        _increaseBlock(block.timestamp + _blockDelta);
        if (isForked) {
            vm.mockCall(
                _assetCTokenAddress,
                abi.encodeWithSelector(MockCToken.exchangeRateCurrent.selector),
                abi.encode(_exchangeRateCurrent * 2)
            );
        } else {
            MockCToken(_assetCTokenAddress).mockExchangeRateStored(_exchangeRateCurrent * 2);
        }

        console.log(MockCToken(_assetCTokenAddress).exchangeRateCurrent());
    }

    function helper_decreaseExchangeRateToZero(address _assetCTokenAddress) public {
        if (isForked) {
            vm.mockCall(_assetCTokenAddress, abi.encodeWithSelector(MockCToken.exchangeRateCurrent.selector), abi.encode(0));
        } else {
            MockCToken(_assetCTokenAddress).mockExchangeRateStored(0);
        }
    }

    function helper_priceChanges(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public clearMockedCalls {
        (
            uint80 _borrowAssetRoundId,
            int256 _borrowAssetPrice,
            uint256 _borrowAssetStartedAt,
            uint256 _borrowAssetUpdatedAt,
            uint80 _borrowAssetAnsweredInRound
        ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (
            uint80 _collateralAssetRoundId,
            int256 _collateralAssetPrice,
            uint256 _collateralAssetStartedAt,
            uint256 _collateralAssetUpdatedAt,
            uint80 _collateralAssetAnsweredInRound
        ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        _borrowAssetPriceSeed = scaleToRange256(_borrowAssetPriceSeed, 1, 10000);
        _collateralAssetPriceSeed = scaleToRange256(_collateralAssetPriceSeed, 1, 10000);

        log_named_int('Borrow asset price', _borrowAssetPrice);
        log_named_int('Collateral asset price', _collateralAssetPrice);
        log_named_uint('Borrow asset seed', _borrowAssetPriceSeed);
        log_named_uint('Collateral asset seed', _collateralAssetPriceSeed);

        _borrowAssetPrice = (_borrowAssetPrice * int256(_borrowAssetPriceSeed)) / 100;
        _collateralAssetPrice = (_collateralAssetPrice * int256(_collateralAssetPriceSeed)) / 100;

        log_named_int('Borrow asset price', _borrowAssetPrice);
        log_named_int('Collateral asset price', _collateralAssetPrice);

        vm.mockCall(
            borrowAssetAggregatorAddress,
            abi.encodeWithSelector(MockV3Aggregator.latestRoundData.selector),
            abi.encode(_borrowAssetRoundId, _borrowAssetPrice, _borrowAssetStartedAt, _borrowAssetUpdatedAt, _borrowAssetAnsweredInRound)
        );
        vm.mockCall(
            collateralAssetAggregatorAddress,
            abi.encodeWithSelector(MockV3Aggregator.latestRoundData.selector),
            abi.encode(
                _collateralAssetRoundId,
                _collateralAssetPrice,
                _collateralAssetStartedAt,
                _collateralAssetUpdatedAt,
                _collateralAssetAnsweredInRound
            )
        );
    }

    function helper_decreaseAssetPrice(address _assetAggregatorAddress, uint256 _seed) public clearMockedCalls {
        (
            uint80 _assetRoundId,
            int256 _assetPrice,
            uint256 _assetStartedAt,
            uint256 _assetUpdatedAt,
            uint80 _assetAnsweredInRound
        ) = MockV3Aggregator(_assetAggregatorAddress).latestRoundData();

        _seed = scaleToRange256(_seed, 1, 95);
        _assetPrice = (_assetPrice * int256(_seed)) / 100;

        vm.mockCall(
            _assetAggregatorAddress,
            abi.encodeWithSelector(MockV3Aggregator.latestRoundData.selector),
            abi.encode(_assetRoundId, _assetPrice, _assetStartedAt, _assetUpdatedAt, _assetAnsweredInRound)
        );
    }

    function helper_increaseAssetPrice(address _assetAggregatorAddress, uint256 _seed) public clearMockedCalls {
        (
            uint80 _assetRoundId,
            int256 _assetPrice,
            uint256 _assetStartedAt,
            uint256 _assetUpdatedAt,
            uint80 _assetAnsweredInRound
        ) = MockV3Aggregator(_assetAggregatorAddress).latestRoundData();

        _seed = scaleToRange256(_seed, 105, 10000);
        _assetPrice = (_assetPrice * int256(_seed)) / 100;

        vm.mockCall(
            _assetAggregatorAddress,
            abi.encodeWithSelector(MockV3Aggregator.latestRoundData.selector),
            abi.encode(_assetRoundId, _assetPrice, _assetStartedAt, _assetUpdatedAt, _assetAnsweredInRound)
        );
    }

    function helper_decreaseAssetPriceToZero(address _assetAggregatorAddress) public clearMockedCalls {
        (
            uint80 _assetRoundId,
            int256 _assetPrice,
            uint256 _assetStartedAt,
            uint256 _assetUpdatedAt,
            uint80 _assetAnsweredInRound
        ) = MockV3Aggregator(_assetAggregatorAddress).latestRoundData();
        vm.mockCall(
            _assetAggregatorAddress,
            abi.encodeWithSelector(MockV3Aggregator.latestRoundData.selector),
            abi.encode(_assetRoundId, 0, _assetStartedAt, _assetUpdatedAt, _assetAnsweredInRound)
        );
    }

    function helper_smallPriceChanges(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public clearMockedCalls {
        (
            uint80 _borrowAssetRoundId,
            int256 _borrowAssetPrice,
            uint256 _borrowAssetStartedAt,
            uint256 _borrowAssetUpdatedAt,
            uint80 _borrowAssetAnsweredInRound
        ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (
            uint80 _collateralAssetRoundId,
            int256 _collateralAssetPrice,
            uint256 _collateralAssetStartedAt,
            uint256 _collateralAssetUpdatedAt,
            uint80 _collateralAssetAnsweredInRound
        ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();
        {
            _borrowAssetPriceSeed = scaleToRange256(_borrowAssetPriceSeed, 95, 105);
            _collateralAssetPriceSeed = scaleToRange256(_collateralAssetPriceSeed, 95, 105);

            _borrowAssetPrice = (_borrowAssetPrice * int256(_borrowAssetPriceSeed)) / 100;
            _collateralAssetPrice = (_collateralAssetPrice * int256(_collateralAssetPriceSeed)) / 100;
        }
        vm.mockCall(
            borrowAssetAggregatorAddress,
            abi.encodeWithSelector(MockV3Aggregator.latestRoundData.selector),
            abi.encode(_borrowAssetRoundId, _borrowAssetPrice, _borrowAssetStartedAt, _borrowAssetUpdatedAt, _borrowAssetAnsweredInRound)
        );
        vm.mockCall(
            collateralAssetAggregatorAddress,
            abi.encodeWithSelector(MockV3Aggregator.latestRoundData.selector),
            abi.encode(
                _collateralAssetRoundId,
                _collateralAssetPrice,
                _collateralAssetStartedAt,
                _collateralAssetUpdatedAt,
                _collateralAssetAnsweredInRound
            )
        );
    }
}",6067
RealWorld_TA_101_MockToken_RealWorld_20240812140007.log,101,MockToken,40846,2300,43146,76.0,0.25023,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
import '@openzeppelin/contracts/access/Ownable.sol';

contract MockToken is ERC20, Ownable {
    constructor(
        string memory name,
        string memory symbol,
        uint8 decimals_,
        uint256 initialSupply,
        address _owner
    ) Ownable() ERC20(name, symbol) {
        _setupDecimals(decimals_);
        _mint(_owner, initialSupply);
        Ownable.transferOwnership(_owner);
    }

    function mint(address _to, uint256 _amount) external onlyOwner {
        require(_amount != 0, 'Token::burn: invalid amount');
        _mint(_to, _amount);
    }

    function approve(address _spender, uint256 _amount) public override returns (bool) {
        // copied from USDT contract
        // https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code
        require(!((_amount != 0) && (allowance(msg.sender, _spender) != 0)), 'MT:A1');
        return super.approve(_spender, _amount);
    }
}",270
RealWorld_TA_101_PriceOracleTest.t_RealWorld_20240812141730.log,101,PriceOracleTest.t,197799,3298,201097,108.0,1.054955,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import 'forge-std/Test.sol';
import '../PriceOracle.sol';
import './Constants.sol';
import '../mocks/MockToken.sol';
import '../mocks/MockV3Aggregator.sol';
import './roles/Admin.sol';

contract PriceOracleTest is Test {
    PriceOracle priceOracle;
    bool isForked;
    IERC20 public collateralAsset;
    IERC20 public borrowAsset;
    address public collateralAssetAggregatorAddress;
    address public borrowAssetAggregatorAddress;
    address uniswapPoolAddress;
    uint32 uniswapPriceAveragingPeriod;

    function setCollateralAsset() public {
        if (isForked) {
            collateralAsset = ERC20(Constants.WBTC);
            collateralAssetAggregatorAddress = Constants.WBTC_priceFeedChainlink;
        } else {
            collateralAsset = new MockToken('CollateralAsset', 'MT1', 18, 1e40, address(this));
            collateralAssetAggregatorAddress = address(new MockV3Aggregator(18, 12876423400040030304304));
        }
    }

    function setBorrowAsset() public {
        if (isForked) {
            borrowAsset = ERC20(Constants.DAI);
            borrowAssetAggregatorAddress = Constants.DAI_priceFeedChainlink;
        } else {
            borrowAsset = new MockToken('BorrowAsset', 'MT2', 8, 1e40, address(this));
            borrowAssetAggregatorAddress = address(new MockV3Aggregator(8, 195040576));
        }
    }

    function setUp() public {
        uint256 _chainId = getChainID();
        if (_chainId == 1) {
            isForked = true;
        }
        priceOracle = new PriceOracle(1 days);
        uniswapPriceAveragingPeriod = 10;
        priceOracle.initialize(address(this), uniswapPriceAveragingPeriod);
        assertTrue(address(priceOracle) != address(0));
        setBorrowAsset();
        setCollateralAsset();
        uniswapPoolAddress = Constants.WBTC_DAI_priceFeedUniswap;
    }

    function test_fail_doesFeedExist_chainLink() public {
        assertFalse(priceOracle.doesFeedExist(address(borrowAsset), address(collateralAsset)));
        assertFalse(priceOracle.doesFeedExist(address(collateralAsset), address(borrowAsset)));
    }

    function test_doesFeedExist_chainLink() public {
        priceOracle.setChainlinkFeedAddress(address(collateralAsset), collateralAssetAggregatorAddress, 1 days);
        priceOracle.setChainlinkFeedAddress(address(borrowAsset), borrowAssetAggregatorAddress, 1 days);
        assertTrue(priceOracle.doesFeedExist(address(borrowAsset), address(collateralAsset)));
        assertTrue(priceOracle.doesFeedExist(address(collateralAsset), address(borrowAsset)));
    }

    function test_doesFeedExist_uniswap() public {
        priceOracle.setUniswapFeedAddress(address(borrowAsset), address(collateralAsset), uniswapPoolAddress);
        assertTrue(priceOracle.doesFeedExist(address(borrowAsset), address(collateralAsset)));
        assertTrue(priceOracle.doesFeedExist(address(collateralAsset), address(borrowAsset)));
    }

    function test_setUniswapFeedAddress() public {
        try priceOracle.setUniswapFeedAddress(address(borrowAsset), address(borrowAsset), address(0)) {
            revert('setUniswapFeedAddress should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:SUFA1');
        }
    }

    function test_setChainlinkFeedAddress_fail_1() public {
        try priceOracle.setChainlinkFeedAddress(address(0), collateralAssetAggregatorAddress, 1 days) {
            revert('setChainlinkFeedAddress should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGD1');
        }
    }

    function test_setChainlinkFeedAddress_fail_2() public {
        try priceOracle.setChainlinkFeedAddress(address(collateralAsset), collateralAssetAggregatorAddress, 2 days) {
            revert('setChainlinkFeedAddress should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:SCFA1');
        }
    }

    event UniswapPriceAveragingPeriodUpdated(uint32 uniswapPriceAveragingPeriod);

    function test_setUniswapPriceAveragingPeriod() public {
        vm.expectEmit(true, true, true, true);
        emit UniswapPriceAveragingPeriodUpdated(uniswapPriceAveragingPeriod + 100);
        priceOracle.setUniswapPriceAveragingPeriod(uniswapPriceAveragingPeriod + 100);
    }

    function test_fail_setUniswapPriceAveragingPeriod() public {
        try priceOracle.setUniswapPriceAveragingPeriod(0) {
            revert('setUniswapPriceAveragingPeriod should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:ISUPAP1');
        }
        try priceOracle.setUniswapPriceAveragingPeriod(uniswapPriceAveragingPeriod) {
            revert('setUniswapPriceAveragingPeriod should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:ISUPAP2');
        }
    }

    function test_getLatestPrice_chainLink() public {
        priceOracle.setChainlinkFeedAddress(address(collateralAsset), collateralAssetAggregatorAddress, 1 days);
        priceOracle.setChainlinkFeedAddress(address(borrowAsset), borrowAssetAggregatorAddress, 1 days);

        (uint256 _price, uint256 _decimals) = priceOracle.getLatestPrice(address(borrowAsset), address(collateralAsset));
        assertTrue(_decimals == 18);
        assertTrue(_price > 0);
    }

    function test_getLatestPrice_uniswap() public {
        if (isForked) {
            priceOracle.setUniswapFeedAddress(address(borrowAsset), address(collateralAsset), uniswapPoolAddress);
            (uint256 _price, uint256 _decimals) = priceOracle.getLatestPrice(address(borrowAsset), address(collateralAsset));
            assertTrue(_decimals == 18);
            assertTrue(_price > 0);
        }
    }

    function test_getLatestPrice_uniswap_2() public {
        (uint256 _price, uint256 _decimals) = priceOracle.getUniswapLatestPrice(address(borrowAsset), address(collateralAsset));
        assertTrue(_price == 0);
        assertTrue(_decimals == 0);
    }

    function test_fail_getLatestPrice_1() public {
        priceOracle.setUniswapFeedAddress(address(borrowAsset), address(collateralAsset), address(0));
        try priceOracle.getLatestPrice(address(borrowAsset), address(collateralAsset)) {
            revert('getLatestPrice should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    function test_fail_getLatestPrice_2() public {
        priceOracle.setChainlinkFeedAddress(address(collateralAsset), collateralAssetAggregatorAddress, 1 days);
        priceOracle.setChainlinkFeedAddress(address(borrowAsset), borrowAssetAggregatorAddress, 1 days);

        vm.mockCall(
            address(borrowAssetAggregatorAddress),
            abi.encodeWithSelector(AggregatorV3Interface.latestRoundData.selector),
            abi.encode(1, 0, block.timestamp, block.timestamp, 2)
        );

        try priceOracle.getLatestPrice(address(borrowAsset), address(collateralAsset)) {
            revert('getLatestPrice should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    function test_fail_getLatestPrice_3() public {
        priceOracle.setChainlinkFeedAddress(address(collateralAsset), collateralAssetAggregatorAddress, 1 days);
        priceOracle.setChainlinkFeedAddress(address(borrowAsset), borrowAssetAggregatorAddress, 1 days);

        vm.mockCall(
            address(borrowAssetAggregatorAddress),
            abi.encodeWithSelector(AggregatorV3Interface.latestRoundData.selector),
            abi.encode(4, 10, block.timestamp, block.timestamp, 1)
        );

        try priceOracle.getLatestPrice(address(borrowAsset), address(collateralAsset)) {
            revert('getLatestPrice should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    function test_fail_getLatestPrice_4() public {
        priceOracle.setChainlinkFeedAddress(address(collateralAsset), collateralAssetAggregatorAddress, 1 days);
        priceOracle.setChainlinkFeedAddress(address(borrowAsset), borrowAssetAggregatorAddress, 1 days);

        vm.mockCall(
            address(collateralAssetAggregatorAddress),
            abi.encodeWithSelector(AggregatorV3Interface.latestRoundData.selector),
            abi.encode(1, 0, block.timestamp, block.timestamp, 2)
        );

        try priceOracle.getLatestPrice(address(borrowAsset), address(collateralAsset)) {
            revert('getLatestPrice should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    function test_fail_getLatestPrice_5() public {
        priceOracle.setChainlinkFeedAddress(address(collateralAsset), collateralAssetAggregatorAddress, 1 days);
        priceOracle.setChainlinkFeedAddress(address(borrowAsset), borrowAssetAggregatorAddress, 1 days);

        vm.mockCall(
            address(collateralAssetAggregatorAddress),
            abi.encodeWithSelector(AggregatorV3Interface.latestRoundData.selector),
            abi.encode(4, 10, block.timestamp, block.timestamp, 2)
        );

        try priceOracle.getLatestPrice(address(borrowAsset), address(collateralAsset)) {
            revert('getLatestPrice should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    function getChainID() internal pure returns (uint256) {
        uint256 id;
        assembly {
            id := chainid()
        }
        return id;
    }
}",2169
RealWorld_TA_101_IPriceOracle_RealWorld_20240812181439.log,101,IPriceOracle,46436,1609,48045,73.0,0.26436,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface IPriceOracle {
    /**
     * @notice emitted when chainlink price feed for a token is updated
     * @param token address of token for which price feed is updated
     * @param priceOracle address of the updated price feed for the token
     * @param heartbeat the time delta after which the price from the feed is discarded
     */
    event ChainlinkFeedUpdated(address indexed token, address indexed priceOracle, uint256 indexed heartbeat);

    /**
     * @notice emitted when uniswap price feed for a token pair is updated
     * @param token1 address of numerator address in price feed
     * @param token2 address of denominator address in price feed
     * @param feedId unique id for the token pair irrespective of the order of tokens
     * @param pool address of the pool from which price feed can be queried
     */
    event UniswapFeedUpdated(address indexed token1, address indexed token2, bytes32 feedId, address indexed pool);

    /**
     * @notice emitted when price averaging window for uniswap price feeds is updated
     * @param uniswapPriceAveragingPeriod period during which uniswap prices are averaged over to avoid attacks
     */
    event UniswapPriceAveragingPeriodUpdated(uint32 uniswapPriceAveragingPeriod);

    function getLatestPrice(address num, address den) external view returns (uint256 price, uint256 decimals);

    function doesFeedExist(address token1, address token2) external view returns (bool feedExists);
}",337
RealWorld_TA_101_IPool_RealWorld_20240812181935.log,101,IPool,106272,2215,108487,74.0,0.57566,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface IPool {
    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repaymennt defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }
    /**
     * @notice Emitted when pool is cancelled either on borrower request or insufficient funds collected
     */
    event PoolCancelled();

    /**
     * @notice Emitted when pool is terminated by admin
     */
    event PoolTerminated();

    /**
     * @notice Emitted when pool is closed after repayments are complete
     */
    event PoolClosed();

    /**
     * @notice emitted when borrower posts collateral
     * @param borrower address of the borrower
     * @param amount amount denominated in collateral asset
     * @param sharesReceived shares received after transferring collaterla to pool savings strategy
     */
    event CollateralAdded(address indexed borrower, uint256 amount, uint256 sharesReceived);

    /**
     * @notice emitted when borrower posts collateral after a margin call
     * @param borrower address of the borrower
     * @param lender lender who margin called
     * @param amount amount denominated in collateral asset
     * @param sharesReceived shares received after transferring collaterla to pool savings strategy
     */
    event MarginCallCollateralAdded(address indexed borrower, address indexed lender, uint256 amount, uint256 sharesReceived);

    /**
     * @notice emitted when borrower withdraws excess collateral
     * @param borrower address of borrower
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(address indexed borrower, uint256 amount);

    /**
     * @notice emitted when lender supplies liquidity to a pool
     * @param amountSupplied amount that was supplied
     * @param lenderAddress address of the lender. allows for delegation of lending
     */
    event LiquiditySupplied(uint256 amountSupplied, address indexed lenderAddress);

    /**
     * @notice emitted when borrower withdraws loan
     * @param amount tokens the borrower withdrew, taking into account the deducted protocol fee
     * @param protocolFee protocol fee deducted when borrower withdrew the amount
     */
    event AmountBorrowed(uint256 amount, uint256 protocolFee);

    /**
     * @notice emitted when lender withdraws from borrow pool
     * @param amount amount that lender withdraws from borrow pool
     * @param lenderAddress address to which amount is withdrawn
     */
    event LiquidityWithdrawn(uint256 amount, address indexed lenderAddress);

    /**
     * @notice emitted when lender exercises a margin/collateral call
     * @param lenderAddress address of the lender who exercises margin calls
     */
    event MarginCalled(address indexed lenderAddress);

    /**
     * @notice emitted when collateral backing lender is liquidated because of a margin call
     * @param liquidator address that calls the liquidateForLender() function
     * @param lender lender who initially exercised the margin call
     * @param _tokenReceived amount received by liquidator denominated in collateral asset
     */
    event LenderLiquidated(address indexed liquidator, address indexed lender, uint256 _tokenReceived);

    /**
     * @notice emitted when a pool is liquidated for missing repayment
     * @param liquidator address of the liquidator
     */
    event PoolLiquidated(address indexed liquidator);

    function getLoanStatus() external view returns (uint256 loanStatus);

    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external;

    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _isDirect
    ) external;

    function withdrawBorrowedAmount() external;

    function borrower() external returns (address poolBorrower);

    function getMarginCallEndTime(address _lender) external returns (uint256 marginCallEndTimeForLender);

    function getBalanceDetails(address _lender) external view returns (uint256 lenderPoolTokens, uint256 totalPoolTokens);

    function totalSupply() external view returns (uint256 totalPoolTokens);

    function closeLoan() external;

    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint64 _repaymentInterval,
        uint64 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external;

    function lend(
        address _lender,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external;
}",1052
RealWorld_TA_101_PCLMaxBorrow.t_RealWorld_20240812142351.log,101,PCLMaxBorrow.t,209315,5020,214335,120.0,1.146975,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../SublimeProxy.sol';
import '../../PooledCreditLine/PooledCreditLine.sol';
import '../../PooledCreditLine/LenderPool.sol';
import '../../PriceOracle.sol';
import '../../interfaces/IPriceOracle.sol';
import '../../SavingsAccount/SavingsAccount.sol';
import '../../yield/StrategyRegistry.sol';
import '../../yield/NoYield.sol';
import '../../yield/CompoundYield.sol';
import '../../mocks/MockV3Aggregator.sol';
import '../../mocks/MockToken.sol';
import '../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../interfaces/ISavingsAccount.sol';
import './Helpers/PCLParent.t.sol';

contract PCLMaxBorrow is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        // increasing by 2% because of precision errors
        //_requiredCollateral = _requiredCollateral.mul(101).div(100);
        admin.transferToken(address(collateralAsset), address(borrower), _requiredCollateral);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);
        // calculateBorrowableAmount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        // emit log_named_uint('_borrowableAmount', _borrowableAmount);
        // borrow the required amount
        borrower.borrow(requestId, _borrowableAmount);
        // emit log_named_uint('current debt', pcl.calculateCurrentDebt(requestId));
        // emit log_named_uint('principal', pcl.getPrincipal(requestId));
    }

    function test_calculateCurrentRatio() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('request.collateralRatio', request.collateralRatio);
        emit log_named_uint('_collateralRatio', _collateralRatio);
        assertApproxEqRel(request.collateralRatio, _collateralRatio, 1e16);
    }

    function test_borrowAbleAmount() public {
        uint256 _borrowAble = pcl.calculateBorrowableAmount(requestId);
        // pcl always has 1 unit borrow able even after borrowing everything
        assertTrue(_borrowAble >= 1);
        emit log_named_uint('_borrowAble', _borrowAble);
    }

    function test_borrowOneUint() public {
        uint256 _borrowAble = pcl.calculateBorrowableAmount(requestId);
        vm.expectRevert(bytes('PCL:IWBA1'));
        borrower.borrow(requestId, _borrowAble);
    }

    function test_withdrawableCollateral() public {
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        // because not all tokens were borrowed
        assertTrue(_withdrawableCollateral > 0);
        emit log_named_uint('withdrawableCollateral', _withdrawableCollateral);
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 shares);

    function test_withdrawCollateral() public {
        uint256 _amount = pcl.withdrawableCollateral(requestId);
        uint256 _amountInShares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, request.collateralAsset);
        emit log_named_uint('_amountInShares', _amountInShares);
        uint256 _prevBalance = collateralAsset.balanceOf(address(borrower));
        vm.expectEmit(true, true, true, true);
        emit CollateralSharesWithdrawn(requestId, _amountInShares);
        borrower.withdrawCollateral(requestId, _amount, false);
        uint256 _curBalance = collateralAsset.balanceOf(address(borrower));
        emit log_named_uint('withdrawableCollateral', pcl.withdrawableCollateral(requestId));
        assertTrue(pcl.withdrawableCollateral(requestId) <= 1);
    }

    function test_repay() public {
        _increaseBlock(block.timestamp + 1 days);
        borrower.setAllowance(pooledCreditLineAddress, request.borrowAsset, 1);
        uint256 _prevDebt = pcl.calculateCurrentDebt(requestId);
        emit log_named_uint('_prevDebt', _prevDebt);
        borrower.repay(requestId, 1);
        uint256 _curDebt = pcl.calculateCurrentDebt(requestId);
        emit log_named_uint('_curDebt', _curDebt);
        assertTrue(_prevDebt.sub(_curDebt) == 1);
    }

    function test_liquidate() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        _increaseBlock(block.timestamp + request.duration + request.defaultGracePeriod);
        uint256 _lpBalanceBorrowAsset = ISavingsAccount(savingsAccountAddress).getTotalTokens(lenderPoolAddress, request.borrowAsset);
        uint256 _expectedBorrowAssetTransferred = _lpBalanceBorrowAsset.mul(lp.balanceOf(address(_lender), requestId)).div(
            lp.totalSupply(requestId)
        );
        emit log_named_uint('_expectedBorrowAssetTransferred', _expectedBorrowAssetTransferred);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        emit log_named_uint('_collateralTokens', _collateralTokens);
        uint256 _maxCollateralTransferred = _collateralTokens.mul(lp.balanceOf(address(_lender), requestId)).div(lp.totalSupply(requestId));
        emit log_named_uint('_maxCollateralTransferred', _maxCollateralTransferred);
        uint256 _prevBalanceBorrowAsset = borrowAsset.balanceOf(address(_lender));
        uint256 _prevBalanceCollateralAsset = collateralAsset.balanceOf(address(_lender));
        _lender.liquidate(requestId, true);
        uint256 _finalBalanceBorrowAsset = borrowAsset.balanceOf(address(_lender));
        uint256 _finalBalanceCollateralAsset = collateralAsset.balanceOf(address(_lender));
        // no principal left to withdraw
        emit log_named_uint('_prevBalanceBorrowAsset', _prevBalanceBorrowAsset);
        emit log_named_uint('_finalBalanceBorrowAsset', _finalBalanceBorrowAsset);
        assertApproxEqRel(_finalBalanceBorrowAsset.sub(_prevBalanceBorrowAsset), _expectedBorrowAssetTransferred, 1e14);
        emit log_named_uint('actual collateral transferred', _finalBalanceCollateralAsset.sub(_prevBalanceCollateralAsset));
        assertTrue(_finalBalanceCollateralAsset.sub(_prevBalanceCollateralAsset) <= _maxCollateralTransferred);
    }

    event InterestWithdrawn(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawInterest(uint256 fractionOfRepaymentAmount) public {
        uint256 size = 10000;
        if (fractionOfRepaymentAmount == 0) {
            fractionOfRepaymentAmount = size - 1;
        }
        PCLUser _lender1 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender2 = PCLUser(lenders[1].lenderAddress);
        PCLUser _lender3 = PCLUser(lenders[3].lenderAddress);
        fractionOfRepaymentAmount = fractionOfRepaymentAmount % size;
        _increaseBlock(block.timestamp + BLOCK_TIME * 10);

        uint256 _interestAmount = pcl.calculateInterestAccrued(requestId);
        uint256 _toRepay = _interestAmount.mul(fractionOfRepaymentAmount).div(size);
        if (_toRepay == 0) return;
        borrower.setAllowance(pooledCreditLineAddress, request.borrowAsset, _toRepay);
        borrower.repay(requestId, _toRepay);
        vm.expectEmit(true, true, false, false);
        emit InterestWithdrawn(requestId, address(_lender1), 0);
        _lender1.withdrawInterest(requestId);

        _increaseBlock(block.timestamp + BLOCK_TIME);
        vm.expectEmit(true, true, false, false);
        emit InterestWithdrawn(requestId, address(_lender2), 0);
        _lender2.withdrawInterest(requestId);

        _increaseBlock(block.timestamp + BLOCK_TIME);
        vm.expectEmit(true, true, false, false);
        emit InterestWithdrawn(requestId, address(_lender3), 0);
        _lender3.withdrawInterest(requestId);
    }

    function test_terminate() public {
        uint256 _startBalanceBorrowAsset = borrowAsset.balanceOf(address(admin));
        uint256 _startBalanceCollateralAsset = collateralAsset.balanceOf(address(admin));
        uint256 _collateralTransferred = pcl.calculateTotalCollateralTokens(requestId);
        emit log_named_uint('_collateralTransferred', _collateralTransferred);
        admin.terminate(requestId);
        uint256 _endBalanceBorrowAsset = borrowAsset.balanceOf(address(admin));
        uint256 _endBalanceCollateralAsset = collateralAsset.balanceOf(address(admin));
        assertApproxEqRel(_collateralTransferred, _endBalanceCollateralAsset.sub(_startBalanceCollateralAsset), 1e16);
        assertTrue(_endBalanceBorrowAsset.sub(_startBalanceBorrowAsset) >= 1);
    }
}",2359
RealWorld_TA_101_PCLLiquidatedStage.t_RealWorld_20240812151519.log,101,PCLLiquidatedStage.t,86340,4391,90731,95.0,0.51952,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLLiquidatedStage.t.sol';

contract PCLLiquidatedStageCollateralNoYieldBorrowCompound is PCLLiquidatedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }
}",781
RealWorld_TA_101_PCLClosedStage.t_RealWorld_20240812150332.log,101,PCLClosedStage.t,76739,4015,80754,97.0,0.463995,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLClosedStage.t.sol';

contract PCLClosedStageCollateralCompoundBorrowNoYield is PCLClosedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        // Now we assert that we are in the ACTIVE state
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), 2);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // And borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(requestId, currentDebt);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
}",684
RealWorld_TA_101_ICreditLine_RealWorld_20240812181711.log,101,ICreditLine,23974,1637,25611,68.0,0.15261,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface ICreditline {
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external;

    function repay(uint256 _id, uint256 _amount) external;
}",67
RealWorld_TA_101_PCLLiquidatedStage.t_RealWorld_20240812145008.log,101,PCLLiquidatedStage.t,807016,68,807084,113.0,4.03644,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}",9533
RealWorld_TA_101_PCLActiveStage.t_RealWorld_20240812151352.log,101,PCLActiveStage.t,46229,2639,48868,85.0,0.283925,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLActiveStage.t.sol';

contract PCLActiveStageCollateralNoYieldBorrowCompound is PCLActiveStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * (10**ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
    }
}",324
RealWorld_TA_101_PCLExpiredStateCompoundYield.t_RealWorld_20240812160815.log,101,PCLExpiredStateCompoundYield.t,90548,4329,94877,104.0,0.53932,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLExpiredState.t.sol';
import '../../Helpers/PCLParent.t.sol';

contract PCLExpiredStatePriceOracleCompoundYield is PCLExpiredStatePriceOracle {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        // Now we assert that we are in the ACTIVE state
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), 2);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }
}",848
RealWorld_TA_101_ILimitsManager_RealWorld_20240812180828.log,101,ILimitsManager,38708,1613,40321,73.0,0.2258,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

interface ILimitsManager {
    /*
     * @notice Used to define limits for the pooled credit line parameters
     * @param min the minimum threshold for the parameter
     * @param max the maximum threshold for the parameter
     */
    struct Limits {
        uint256 min;
        uint256 max;
    }

    function isWithinLimits(uint256 _value, Limits calldata _limits) external pure virtual returns (bool);

    function limitBorrowedInUSDC(
        address _borrowAsset,
        uint256 _borrowLimit,
        uint256 _minBorrowAmount
    ) external view virtual;

    function getIdealCollateralRatioLimits() external view virtual returns (Limits memory);

    function getBorrowRateLimits() external view virtual returns (Limits memory);

    function getCollectionPeriodLimits() external view virtual returns (Limits memory);

    function getDurationLimits() external view virtual returns (Limits memory);

    function getDefaultGracePeriodLimits() external view virtual returns (Limits memory);

    function getGracePenaltyRateLimits() external view virtual returns (Limits memory);
}",243
RealWorld_TA_101_PCLUser.t_RealWorld_20240812155003.log,101,PCLUser.t,131686,3946,135632,105.0,0.73735,"//SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../../roles/User.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '../../../Verification/Verification.sol';
import '../../../mocks/MockAdminVerifier.sol';

contract PCLUser is IPooledCreditLineDeclarations, User {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    PooledCreditLine pcl;
    LenderPool lp;

    constructor(address _pclAddress, address _lpAddress) {
        pcl = PooledCreditLine(_pclAddress);
        lp = LenderPool(_lpAddress);
    }

    function updatePCL(address _pclAddress) public {
        pcl = PooledCreditLine(_pclAddress);
    }

    function updateLP(address _lpAddress) public {
        lp = LenderPool(_lpAddress);
    }

    function registerSelf(address _verifier) public {
        MockAdminVerifier verifier = MockAdminVerifier(payable(_verifier));
        verifier.registerSelf();
    }

    /******************************************************************************
     ******* PCL Borrower-specific functions **************************************
     ******************************************************************************/

    function createRequest(Request memory _request) public returns (uint256) {
        uint256 _id = pcl.request(_request);
        return _id;
    }

    function cancelRequest(uint256 _id) public {
        pcl.cancelRequest(_id);
    }

    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) public {
        pcl.depositCollateral(_id, _amount, _fromSavingsAccount);
    }

    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) public {
        pcl.withdrawCollateral(_id, _amount, _toSavingsAccount);
    }

    function withdrawAllCollateral(uint256 _id, bool _toSavingsAccount) public {
        pcl.withdrawAllCollateral(_id, _toSavingsAccount);
    }

    function borrow(uint256 _id, uint256 _amount) public {
        pcl.borrow(_id, _amount);
    }

    function repay(uint256 _id, uint256 _amount) public {
        pcl.repay(_id, _amount);
    }

    function close(uint256 _id) public {
        pcl.close(_id);
    }

    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256) {
        return pcl.calculateTotalCollateralTokens(_id);
    }

    function getRequiredCollateral(uint256 _id, uint256 _amount) public view returns (uint256) {
        return pcl.getRequiredCollateral(_id, _amount);
    }

    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        return pcl.calculateBorrowableAmount(_id);
    }

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        return pcl.calculateInterestAccrued(_id);
    }

    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        return pcl.withdrawableCollateral(_id);
    }

    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        return pcl.calculateCurrentDebt(_id);
    }

    function getPrincipal(uint256 _id) public view {
        pcl.getPrincipal(_id);
    }

    function getStatus(uint256 _id) public returns (PooledCreditLineStatus) {
        return pcl.getStatusAndUpdate(_id);
    }

    function calculateCurrentCollateralRatio(uint256 _id) public returns (uint256) {
        return pcl.calculateCurrentCollateralRatio(_id);
    }

    /******************************************************************************
     ******* End of PCL Borrower-specific functions *******************************
     ******************************************************************************/

    /******************************************************************************
     ******* PCL Lender-specific functions ****************************************
     ******************************************************************************/

    function start(uint256 _id) public {
        lp.start(_id);
    }

    function lend(uint256 _id, uint256 _amount) public {
        lp.lend(_id, _amount);
    }

    function liquidate(uint256 _id, bool _withdraw) public {
        lp.liquidate(_id, _withdraw);
    }

    function withdrawTokensAfterLiquidation(uint256 _id) public {
        lp.withdrawTokensAfterLiquidation(_id);
    }

    function withdrawInterest(uint256 _id) public {
        lp.withdrawInterest(_id);
    }

    function withdrawLiquidity(uint256 _id) public {
        lp.withdrawLiquidity(_id);
    }

    function withdrawLiquidation(uint256 _id) public {
        lp.withdrawTokensAfterLiquidation(_id);
    }

    function calculatePrincipalWithdrawable(uint256 _id, address _lender) public returns (uint256) {
        return lp.calculatePrincipalWithdrawable(_id, _lender);
    }

    function transferLPTokens(
        address _to,
        uint256 _id,
        uint256 _amount
    ) public {
        bytes memory emptyBytes;
        lp.safeTransferFrom(address(this), _to, _id, _amount, emptyBytes);
    }

    function getLenderInterest(uint256 _id, address _lender) public returns (uint256) {
        uint256 interest = lp.getLenderInterestWithdrawable(_id, _lender);
        return interest;
    }

    /******************************************************************************
     ******* End of PCL Lender-specific functions **********************
     *******************************************************************************/

    /******************************************************************************
     ******* PCL invalid functions **********************
     *******************************************************************************/

    function accept(uint256 _id, uint256 _amount) public {
        pcl.accept(_id, _amount, address(this));
    }

    function cancelRequestOnLowCollection(uint256 _id) public {
        pcl.cancelRequestOnLowCollection(_id);
    }

    function collateralTokensToLiquidate(uint256 _id, uint256 _borrowTokens) public view returns (uint256) {
        return pcl.getEquivalentCollateralTokens(_id, _borrowTokens);
    }

    // To check for failure scenarios, can't be invoked in general
    function noAccessLiquidate(uint256 _id) public {
        pcl.liquidate(_id);
    }

    function terminate(uint256 _id) public {
        pcl.terminate(_id);
    }

    /******************************************************************************
     ******* END PCL invalid functions **********************
     *******************************************************************************/
}",1370
RealWorld_TA_101_LenderPool_RealWorld_20240812180206.log,101,LenderPool,765536,474,766010,123.0,3.83716,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol';
import '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '../interfaces/ISavingsAccount.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ILenderPool.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IPooledCreditLine.sol';
import '../interfaces/IPooledCreditLineEnums.sol';

/**
 * @title Contract that deals with pooling of capital from lenders
 * @notice Implements the functions related to lender pooling
 * @author Sublime
 **/

contract LenderPool is ERC1155Upgradeable, ReentrancyGuardUpgradeable, IPooledCreditLineEnums, ILenderPool {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    //-------------------------------- Constants start --------------------------------//

    /**
     * @notice address of savings account
     */
    ISavingsAccount public immutable SAVINGS_ACCOUNT;
    /**
     * @notice address of pooled credit line
     */
    IPooledCreditLine public immutable POOLED_CREDIT_LINE;
    /**
     * @notice address of verification module
     */
    IVerification public immutable VERIFICATION;
    /*
     * @notice Factor with which certain variables/constants are multiplied to maintain precision
     */
    uint256 constant SCALING_FACTOR = 1e18;

    //-------------------------------- Constants end --------------------------------//

    //-------------------------------- State variables start --------------------------------//

    /**
     * @notice Struct that stores the interest withdrawn by the lender of a specific credit line
     * @param borrowerInterestSharesWithdrawn interest paid by borrower in shares, withdrawn by lender
     * @param yieldInterestWithdrawnShares interest from yield strategy withdrawn by lender
     */
    struct LenderInfo {
        uint256 borrowerInterestSharesWithdrawn;
        uint256 yieldInterestWithdrawnShares;
    }

    /**
     * @notice Struct that stores the constants of a pooled credit line
     * @param startTime Timestamp at which pooled credit line starts
     * @param borrowAsset address of token that is being lent by lenders & borrowed by borrower
     * @param collateralAsset address of token that is used as collateral deposited by the borrower
     * @param borrowLimit max tokens that was requested by borrower
     * @param minBorrowAmount min tokens that was requested by borrower
     * @param lenderVerifier address of verifier with which lenders should be verified to lend
     * @param borrowAssetStrategy address of strategy to deposit lent tokens to in savings account
     * @param areTokensTransferable boolean that represents if pool tokens for pooled credit line are transferable
     */
    struct LenderPoolConstants {
        uint256 startTime;
        address borrowAsset;
        address collateralAsset;
        uint256 borrowLimit;
        uint256 minBorrowAmount;
        address lenderVerifier;
        address borrowAssetStrategy;
        bool areTokensTransferable;
    }

    /**
     * @notice Struct that stores the variables of a pooled credit line
     * @param lenders mapping that stores lender specific info for the pooled credit line
     * @param sharesHeld total shares of borrow token held by the pooled credit line
              sharesHeld is set when the pcl is started and is equal to the shares equivalent to borrowLimit
              when any amount is borrowed sharedHeld is reduced and when interest is withdrawn sharesHeld is reduced
              when any amount is repaid sharedHeld is increased.
              if any liquidity is withdrawn by the lender after liquidation or closing of the pcl, sharesHeld is
              not changed.
     * @param borrowerInterestShares total interest in shares repaid by borrower
     * @param borrowerInterestSharesWithdrawn shares withdrawn from borrowerInterestShares
     * @param yieldInterestWithdrawnShares total yield interest in shares withdrawn by all lenders together
     * @param collateralHeld total collateral tokens held by pooled credit line in case of liquidation
     */
    struct LenderPoolVariables {
        mapping(address => LenderInfo) lenders;
        uint256 sharesHeld;
        uint256 borrowerInterestShares;
        uint256 borrowerInterestSharesWithdrawn;
        uint256 yieldInterestWithdrawnShares;
        uint256 collateralHeld;
    }

    /**
     * @notice Mapping that stores constants for pooledCreditLine against it's id
     */
    mapping(uint256 => LenderPoolConstants) public pooledCLConstants;
    /**
     * @notice Mapping that stores variables for pooledCreditLine against it's id
     */
    mapping(uint256 => LenderPoolVariables) public pooledCLVariables;
    /**
     * @notice Mapping that stores total pooledCreditLine token supply against the creditLineId
     * @dev Since ERC1155 tokens don't support the totalSupply function it is maintained here
     */
    mapping(uint256 => uint256) public totalSupply;

    //-------------------------------- State variables end --------------------------------//

    //-------------------------------- Modifiers start --------------------------------//

    /**
     * @notice Modifier that allows only pooled credit line to call a function
     */
    modifier onlyPooledCreditLine() {
        require(msg.sender == address(POOLED_CREDIT_LINE), 'LP:OPCL1');
        _;
    }

    //-------------------------------- Modifiers end --------------------------------//

    //-------------------------------- Events start --------------------------------//

    //--------------------------- LenderPool events start ---------------------------//

    /**
     * @notice Emitted when lender deposits tokens for pooled credit line
     * @param id identifier for the pooled credit line
     * @param user address of the user
     * @param amount amount of tokens lent by user
     */
    event Lend(uint256 indexed id, address indexed user, uint256 amount);
    /**
     * @notice Emitted when liquidity provided by lender is withdrawn when pool is not cancelled
     * @param id identifier for the pooled credit line
     * @param user address of the lender
     * @param shares amount of shares of liquidity provided initially by lender withdrawn
     */
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);
    /**
     * @notice Emitted when liquidity provided by lender is withdrawn as pool is cancelled
     * @param id identifier for the pooled credit line
     * @param user address of the lender
     * @param amount amount of tokens lent by the user which is withdrawn on pooled credit line cancellation
     */
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);
    /**
     * @notice Emitted when interest by yield or/and borrower is withdrawn
     * @param id identifier for the pooled credit line
     * @param user address of the lender
     * @param shares shares withdrawn by lender from interest accrued by yield as well as supplied by borrower
     */
    event InterestWithdrawn(uint256 indexed id, address indexed user, uint256 shares);
    /**
     * @notice Emitted when a lender withdraws their share of liquidation
     * @param id identifier for the pooled credit line
     * @param user address of the lender
     * @param collateralShare share of collateral withdrawn by lender from liquidation
     */
    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    /**
     * @notice Emitted when a pooled credit line is liquidated by a lender
     * @param id identifier for the pooled credit line
     * @param collateralLiquidated amount of collateral that is received after liquidation
     */
    event Liquidated(uint256 indexed id, uint256 collateralLiquidated);

    //--------------------------- LenderPool events end ---------------------------//

    //-------------------------------- Events end --------------------------------//

    //-------------------------------- Init start --------------------------------//

    /**
     * @notice constructor to initialize immutable global variables
     * @param _pooledCreditLine address of pooled credit line contract
     * @param _savingsAccount address of savings account contract
     * @param _verification address of verification contract
     */
    constructor(
        address _pooledCreditLine,
        address _savingsAccount,
        address _verification
    ) {
        require(_pooledCreditLine != address(0), 'LP:C1');
        require(_savingsAccount != address(0), 'LP:C2');
        require(_verification != address(0), 'LP:C3');
        POOLED_CREDIT_LINE = IPooledCreditLine(_pooledCreditLine);
        SAVINGS_ACCOUNT = ISavingsAccount(_savingsAccount);
        VERIFICATION = IVerification(_verification);
    }

    /**
     * @notice initializes the contract in context of proxy
     */
    function initialize() external initializer {
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        __ERC1155_init('URI');
    }

    //-------------------------------- Init end --------------------------------//

    //-------------------------------- PCL creation start --------------------------------//

    /**
     * @notice function invoked when creating pooled credit line
     * @dev only pooled credit line can call the create function
     * @param _id identifier for the pooled credit line
     * @param _lenderVerifier address of verifier with which lenders should be verified to lend
     * @param _borrowAsset address of token that is being lent by lenders & borrowed by borrower
     * @param _borrowAssetStrategy address of strategy to deposit lent tokens to savings account
     * @param _borrowLimit max tokens that was requested by borrower
     * @param _minBorrowAmount min tokens that was requested by borrower
     * @param _collectionPeriod time for which tokens can be lent to pooled credit lines
     * @param _areTokensTransferable boolean that represents if pool tokens for credit line are transferable
     */
    function create(
        uint256 _id,
        address _lenderVerifier,
        address _borrowAsset,
        address _borrowAssetStrategy,
        uint256 _borrowLimit,
        uint256 _minBorrowAmount,
        uint256 _collectionPeriod,
        bool _areTokensTransferable
    ) external override nonReentrant onlyPooledCreditLine {
        pooledCLConstants[_id].startTime = block.timestamp.add(_collectionPeriod);
        pooledCLConstants[_id].borrowAsset = _borrowAsset;
        pooledCLConstants[_id].borrowLimit = _borrowLimit;
        pooledCLConstants[_id].minBorrowAmount = _minBorrowAmount;
        pooledCLConstants[_id].lenderVerifier = _lenderVerifier;
        pooledCLConstants[_id].borrowAssetStrategy = _borrowAssetStrategy;
        pooledCLConstants[_id].areTokensTransferable = _areTokensTransferable;

        uint256 allowance = SAVINGS_ACCOUNT.allowance(address(this), _borrowAsset, address(POOLED_CREDIT_LINE));
        if (allowance != type(uint256).max) {
            SAVINGS_ACCOUNT.approve(_borrowAsset, address(POOLED_CREDIT_LINE), type(uint256).max);
        }
    }

    //-------------------------------- PCL creation end --------------------------------//

    //-------------------------------- Lend & accept start --------------------------------//

    /**
     * @notice Function used by lenders to lend to pooled credit line
     * @dev lent amount is deposited to savings account only once borrow limit is reached or if start is called
     * @param _id identifier for the pooled credit line
     * @param _amount amount of borrow tokens to lend
     */
    function lend(uint256 _id, uint256 _amount) external nonReentrant {
        require(_amount != 0, 'LP:L1');
        require(VERIFICATION.isUser(msg.sender, pooledCLConstants[_id].lenderVerifier), 'LP:L2');
        require(block.timestamp < pooledCLConstants[_id].startTime, 'LP:L3');

        uint256 _totalLent = totalSupply[_id];
        uint256 _maxLent = pooledCLConstants[_id].borrowLimit;
        require(_maxLent > _totalLent, 'LP:L4');

        uint256 _amountToLend = _amount;
        if (_totalLent.add(_amount) > _maxLent) {
            _amountToLend = _maxLent.sub(_totalLent);
        }
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;

        IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amountToLend);
        _mint(msg.sender, _id, _amountToLend, '');

        emit Lend(_id, msg.sender, _amountToLend);
    }

    /**
     * @notice function used to start the pooled credit line once the start time is reached
     * @dev this function needs to be called by the borrower
     * @param _id identifier for the pooled credit line
     */
    function start(uint256 _id) external override nonReentrant {
        uint256 _startTime = pooledCLConstants[_id].startTime;
        require(_startTime != 0, 'LP:S1');
        // PCL can be started once the collection period is over
        require(block.timestamp >= _startTime, 'LP:S2');
        // PCL cannot be started once it has ended
        // PCL remains in the REQUESTED stage if it is not started
        // check _withdrawLiquidity method to see how these cases are handled
        require(block.timestamp < POOLED_CREDIT_LINE.getEndsAt(_id), 'LP:S3');

        uint256 _totalLent = totalSupply[_id];
        require(_totalLent >= pooledCLConstants[_id].minBorrowAmount, 'LP:S4');

        _accept(_id, _totalLent);
    }

    function _accept(uint256 _id, uint256 _amount) private {
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        IERC20(_borrowAsset).safeApprove(_strategy, _amount);
        pooledCLVariables[_id].sharesHeld = SAVINGS_ACCOUNT.deposit(_borrowAsset, _strategy, address(this), _amount);

        // If msg.sender is not borrower, then tx is rejected
        POOLED_CREDIT_LINE.accept(_id, _amount, msg.sender);

        pooledCLConstants[_id].borrowLimit = _amount;
        delete pooledCLConstants[_id].startTime;
        delete pooledCLConstants[_id].minBorrowAmount;
    }

    //-------------------------------- Lend & accept end --------------------------------//

    //-------------------------------- callbacks start --------------------------------//

    /**
     * @notice Function invoked on borrow from the pooled credit line
     * @dev only pooledCreditLineContract can invoke
     * @param _id identifier for the pooled credit line
     * @param _sharesBorrowed amount of shares borrowed
     */
    function borrowed(uint256 _id, uint256 _sharesBorrowed) external override nonReentrant onlyPooledCreditLine {
        pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_sharesBorrowed);
    }

    /**
     * @notice Function invoked when repayment is done to pooled credit line
     * @dev only pooledCreditLineContract can invoke
     * @param _id identifier for the pooled credit line
     * @param _sharesRepaid shares repaid
     * @param _interestShares interest in shares repaid
     */
    function repaid(
        uint256 _id,
        uint256 _sharesRepaid,
        uint256 _interestShares
    ) external override nonReentrant onlyPooledCreditLine {
        pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.add(_sharesRepaid);
        pooledCLVariables[_id].borrowerInterestShares = pooledCLVariables[_id].borrowerInterestShares.add(_interestShares);
    }

    /**
     * @notice Function invoked when pooled credit line is cancelled
     * @dev only pooledCreditLineContract can invoke
     * @param _id identifier for the pooled credit line
     */
    function requestCancelled(uint256 _id) external override onlyPooledCreditLine {
        // We want *function lend* to fail, so that lenders do not keep on lending even after the CL is cancelled.
        delete pooledCLConstants[_id].startTime;

        // After this, we cannot delete *pooledCLConstants[_id]*, else we risk getting stuck with some of the lenders'
        // liquidity inside of this contract. Therefore, after this, the user must themselves call *withdrawLiquidity*
    }

    /**
     * @notice Function invoked when pooled credit line is terminated by admin
     * @dev only pooledCreditLineContract can invoke
     * @param _id identifier for the pooled credit line
     * @param _to address to which all the borrow tokens are transferred
     */
    function terminate(uint256 _id, address _to) external override nonReentrant onlyPooledCreditLine {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        // this is the maximum amount which can be borrowed from the PCL
        uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;
        // the borrower has not borrowed this much amount yet
        // for eg: _borrowedLimit is 1000 DAI and the amount borrowed is 90 DAI
        // also _notBorrowed == _borrowedLimit when the PCL has not started
        uint256 _notBorrowed = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
        uint256 _notBorrowedInShares = IYield(_strategy).getSharesForTokens(_notBorrowed, _borrowAsset);
        uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;
        if (_sharesHeld != 0) {
            uint256 _totalInterestInShares = _sharesHeld.sub(_notBorrowedInShares);
            // the amount of _borrowAsset deposited by lenders against the PCL is equal to totalSupply[_id]
            // when the PCL is active totalSupply[_id] == _borrowedLimit
            // but _borrowLimit is some cases can be different than totalSupply[_id]
            // for eg: before the PCL has started the borrowLimit asked by borrower is 1000 DAI
            // but the lenders have only deposited 900 DAI till now so totalSupply[_id] is 900 DAI
            // another eg is when the PCL has already been liquidated and some lenders have withdrawn the funds
            // in this case too _borrowedLimit is greater than the totalSupply[_id]
            // we multiply _notBorrowedInShares with the ratio of totalSupply[_id]/_borrowLimit
            // this is done to get the _actualNotBorrowedInShares which might be less than the
            // _notBorrowedInShares because of totalSupply[_id] being less than _borrowedLimit
            uint256 _actualNotBorrowedInShares = _notBorrowedInShares.mul(totalSupply[_id]).div(_borrowedTokens);
            // shareWithdrawable = _actualNotBorrowedInShares + _totalInterestInShares
            // _totalInterestInShares is not adjusted for change in totalSupply[_id] because
            // no withdrawal of the principal fund deposited in the PCL can happen when it is active
            // interest withdrawn from the PCL has already been deducted from sharesHeld
            // interest (borrow + yield) come into the picture only after the PCL was activated in its lifetime
            // borrowInterest is accrued only when PCL is active
            // yield interest is accrued funds are deposited in the _strategy contract and is intrinsic to the shares
            // any change in the totalSupply[_id] on does affect the interest shares in the PCL
            uint256 _totalBorrowAsset = _actualNotBorrowedInShares.add(_totalInterestInShares);
            if (_totalBorrowAsset != 0) {
                SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _totalBorrowAsset, false);
            }
        }

        uint256 _collateralHeld = pooledCLVariables[_id].collateralHeld;
        if (_collateralHeld != 0) {
            // transferring the collateral that is transferred to Lender pool to distribute among lenders as part of liquidation
            IERC20(pooledCLConstants[_id].collateralAsset).safeTransfer(_to, _collateralHeld);
        }
        delete pooledCLConstants[_id];
        delete pooledCLVariables[_id];
    }

    //-------------------------------- callbacks end --------------------------------//

    //-------------------------------- Interest start --------------------------------//

    /**
     * @notice Function used to withdraw interest repaid by the borrower and
               the yield interest generated by the borrow assets deposited in the strategy
     * @dev Tokens lent are locked till end of Pooled Credit line. 
            Any interest paid by borrower can be withdrawn by lenders proportional to
            their token balances for that pooled credit line. Partial withdrawal of
            interest is not allowed. Whenever they call the `withdrawInterest` function
            they will get the entire amount of interest that is owed to them by that time
     * @param _id identifier for the pooled credit line
     */
    function withdrawInterest(uint256 _id) external nonReentrant {
        uint256 _interestSharesWithdrawn = _withdrawInterest(_id, msg.sender);
        require(_interestSharesWithdrawn != 0, 'LP:WI1');
    }

    function _withdrawInterest(uint256 _id, address _lender) private returns (uint256 _interestSharesWithdrawn) {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        // this checks if the constants are not deleted
        require(_strategy != address(0), 'LP:IWI1');

        uint256 _interestSharesToWithdraw = _updateInterestSharesToWithdraw(_id, _lender, _strategy, _borrowAsset);

        if (_interestSharesToWithdraw != 0) {
            pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesToWithdraw);
            SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _lender, _interestSharesToWithdraw, false);
            emit InterestWithdrawn(_id, _lender, _interestSharesToWithdraw);
        }

        return _interestSharesToWithdraw;
    }

    /*
     * @dev this function updates the interest shares withdrawn by the lender.
            interest shares are of 2 types
            - borrowerInterestSharesWithdrawn: this is the interest paid by the borrower and withdrawn by the lender
            - yieldInterestWithdrawnShares: this is the interest accrued from the yield strategy and withdrawn by the lender
     */
    function _updateInterestSharesToWithdraw(
        uint256 _id,
        address _lender,
        address _strategy,
        address _borrowAsset
    ) private returns (uint256) {
        uint256 _lenderBalance = balanceOf(_lender, _id);
        if (_lenderBalance == 0) {
            return 0;
        }

        uint256 _borrowLimit = pooledCLConstants[_id].borrowLimit;
        (uint256 _borrowerInterestSharesForLender, uint256 _yieldInterestSharesForLender) = _calculateLenderInterest(
            _id,
            _lender,
            _strategy,
            _borrowAsset,
            _lenderBalance,
            _borrowLimit
        );

        if (_borrowerInterestSharesForLender != 0) {
            pooledCLVariables[_id].lenders[_lender].borrowerInterestSharesWithdrawn = pooledCLVariables[_id]
                .lenders[_lender]
                .borrowerInterestSharesWithdrawn
                .add(_borrowerInterestSharesForLender);
            pooledCLVariables[_id].borrowerInterestSharesWithdrawn = pooledCLVariables[_id].borrowerInterestSharesWithdrawn.add(
                _borrowerInterestSharesForLender
            );
        }

        if (_yieldInterestSharesForLender != 0) {
            pooledCLVariables[_id].lenders[_lender].yieldInterestWithdrawnShares = pooledCLVariables[_id]
                .lenders[_lender]
                .yieldInterestWithdrawnShares
                .add(_yieldInterestSharesForLender);
            pooledCLVariables[_id].yieldInterestWithdrawnShares = pooledCLVariables[_id].yieldInterestWithdrawnShares.add(
                _yieldInterestSharesForLender
            );
        }

        return _yieldInterestSharesForLender.add(_borrowerInterestSharesForLender);
    }

    /**
     * @notice Function used to get interest withdrawable by a lender in pooled credit line.
               the interest this function returns is a sum of borrowerInterest + yieldInterest
               borrower interest is the interest paid by the borrower
               yield interest is the interest generated by the yield strategy
     * @dev it is a view function as far as the Pooled credit lines are concerned and doesn't 
            make any state changes except for getSharesForTokens and getTokensForShares in yield
     * @param _lender address of lender for whom interest is withdrawn
     */
    function getLenderInterestWithdrawable(uint256 _id, address _lender) external returns (uint256) {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        // get borrower repayments and yield interest shares
        (uint256 _borrowerInterestShares, uint256 _yieldInterestShares) = _calculateLenderInterest(
            _id,
            _lender,
            _strategy,
            _borrowAsset,
            balanceOf(_lender, _id),
            pooledCLConstants[_id].borrowLimit
        );
        // convert total interest shares into tokens and return
        return IYield(_strategy).getTokensForShares(_borrowerInterestShares.add(_yieldInterestShares), _borrowAsset);
    }

    function _calculateLenderInterest(
        uint256 _id,
        address _lender,
        address _strategy,
        address _borrowAsset,
        uint256 _lenderBalance,
        uint256 _borrowLimit
    ) private returns (uint256 _borrowerInterestSharesForLender, uint256 _yieldInterestSharesForLender) {
        uint256 _totalInterestWithdrawableInShares;
        {
            uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;
            // _sharesHeld is set in the _accept method
            // _sharesHeld == 0 is in these PCL stages: not created, requested, cancelled and terminated
            if (_sharesHeld == 0) {
                return (0, 0);
            }
            uint256 _notBorrowed = _borrowLimit.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
            uint256 _notBorrowedInShares = IYield(_strategy).getSharesForTokens(_notBorrowed, _borrowAsset);
            _totalInterestWithdrawableInShares = _sharesHeld.sub(_notBorrowedInShares);
        }
        uint256 _borrowerInterestShares = pooledCLVariables[_id].borrowerInterestShares;
        _borrowerInterestSharesForLender = (_borrowerInterestShares.mul(_lenderBalance).div(_borrowLimit)).sub(
            pooledCLVariables[_id].lenders[_lender].borrowerInterestSharesWithdrawn
        );

        {
            uint256 _borrowerInterestWithdrawableInShares = _borrowerInterestShares.sub(
                pooledCLVariables[_id].borrowerInterestSharesWithdrawn
            );
            // _notBorrowed is converted to _notBorrowedInShares using the current exchange rate
            // The difference in _sharesHeld and (_notBorrowedInShares + shares withdrawn)
            // is the _totalYieldInterest
            _yieldInterestSharesForLender = 0;
            if (_totalInterestWithdrawableInShares > _borrowerInterestWithdrawableInShares) {
                uint256 _totalYieldInterestShares = _totalInterestWithdrawableInShares.sub(_borrowerInterestWithdrawableInShares).add(
                    pooledCLVariables[_id].yieldInterestWithdrawnShares
                );
                _yieldInterestSharesForLender = (_totalYieldInterestShares.mul(_lenderBalance).div(_borrowLimit)).sub(
                    pooledCLVariables[_id].lenders[_lender].yieldInterestWithdrawnShares
                );
            }
        }
    }

    //-------------------------------- Interest end --------------------------------//

    //-------------------------------- Liquidity withdraw start --------------------------------//

    /**
     * @notice Function to withdraw liquidity by lender
     * @dev Liquidity can be withdrawn when the pooled credit line in the following scenarios
            - pcl is cancelled by the borrower
            - pcl gets cancelled because because desired amount wasn't reached
            - pcl gets cancelled because it was never started by the borrower and endTime has reached
            - pcl is liquidated before the endTime has reached
            - pcl is liquidated after the endTime has reached
            - pcl is closed after all repayments
           in the other cases this function reverts
     * @param _id identifier for the pooled credit line
     */

    function withdrawLiquidity(uint256 _id) external nonReentrant {
        _withdrawLiquidity(_id, false);
    }

    function _withdrawLiquidity(uint256 _id, bool _isLiquidationWithdrawn) private {
        uint256 _liquidityProvided = balanceOf(msg.sender, _id);
        require(_liquidityProvided != 0, 'LP:IWL1');

        PooledCreditLineStatus _status = POOLED_CREDIT_LINE.getStatusAndUpdate(_id);

        address _borrowAsset = pooledCLConstants[_id].borrowAsset;

        if (_status == PooledCreditLineStatus.REQUESTED) {
            if (block.timestamp >= pooledCLConstants[_id].startTime && totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount) {
                POOLED_CREDIT_LINE.cancelRequestOnLowCollection(_id);
            } else if (block.timestamp >= POOLED_CREDIT_LINE.getEndsAt(_id)) {
                POOLED_CREDIT_LINE.cancelRequestOnRequestedStateAtEnd(_id);
            } else {
                revert('LP:IWL3');
            }
            _status = PooledCreditLineStatus.CANCELLED;
            delete pooledCLConstants[_id].startTime;
        }

        if (_status == PooledCreditLineStatus.CANCELLED) {
            // Case 0:
            // Credit Line request was cancelled by the borrower, which deletes the creditLineVariables, hence status = uint256(0)
            // Cancellation can only be done in the REQUESTED state, therefore, the borrowLimit target was also not met
            // &&
            // Case 1: Pooled credit line never started because desired amount wasn't reached
            // _maxToLend is 0 if credit line is accepted so this case is never run

            //transfer liquidity provided
            IERC20(_borrowAsset).safeTransfer(msg.sender, _liquidityProvided);
            emit WithdrawLiquidityOnCancel(_id, msg.sender, _liquidityProvided);
        } else if (_status == PooledCreditLineStatus.CLOSED || _status == PooledCreditLineStatus.LIQUIDATED) {
            if (_status == PooledCreditLineStatus.LIQUIDATED) {
                // _isLiquidationWithdrawn is true when _withdrawLiquidity is called from within
                // withdrawTokensAfterLiquidation which means the lender is withdrawing all assets after the PCL
                // has been liquidated. Once PCL has been liquidated lender cannot call withdrawLiquidity directly
                require(_isLiquidationWithdrawn, 'LP:IWL2');
            }
            // all other cases distribute the sharesHeld proportional to their poolToken balances
            address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
            uint256 _principalWithdrawable = _calculatePrincipalWithdrawable(_id, msg.sender);
            uint256 _interestSharesWithdrawable = _updateInterestSharesToWithdraw(_id, msg.sender, _strategy, _borrowAsset);
            uint256 _interestWithdrawable;
            if (_interestSharesWithdrawable != 0) {
                _interestWithdrawable = IYield(_strategy).getTokensForShares(_interestSharesWithdrawable, _borrowAsset);
                pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesWithdrawable);
            }
            uint256 _amountToWithdraw = _principalWithdrawable.add(_interestWithdrawable);
            uint256 _sharesToWithdraw = IYield(_strategy).getSharesForTokens(_amountToWithdraw, _borrowAsset);
            if (_sharesToWithdraw != 0) {
                SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, msg.sender, _sharesToWithdraw, false);
            }
            emit WithdrawLiquidity(_id, msg.sender, _sharesToWithdraw);
        } else {
            revert('LP:IWL3');
        }

        _burn(msg.sender, _id, _liquidityProvided);
    }

    /**
     * @notice Function that can be used to calculate principal withdrawable
     * @param _id identifier for the pooled credit line
     * @param _lender lender whose share of principal is to be withdrawn
     * @return Principal withdrawable
     */
    function calculatePrincipalWithdrawable(uint256 _id, address _lender) external returns (uint256) {
        PooledCreditLineStatus _status = POOLED_CREDIT_LINE.getStatusAndUpdate(_id);
        if (_status == PooledCreditLineStatus.CLOSED || _status == PooledCreditLineStatus.LIQUIDATED) {
            return _calculatePrincipalWithdrawable(_id, _lender);
        } else if (
            _status == PooledCreditLineStatus.CANCELLED ||
            (_status == PooledCreditLineStatus.REQUESTED &&
                ((block.timestamp >= pooledCLConstants[_id].startTime && totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount) ||
                    block.timestamp >= POOLED_CREDIT_LINE.getEndsAt(_id)))
        ) {
            // this else if block covers the conditions when PCL was cancelled OR
            // the PCL was in requested stage but never started
            return balanceOf(_lender, _id);
        } else {
            return 0;
        }
    }

    /*
    * @dev returns the amount of principal the lender can withdraw after the pcl has been liquidated or closed
           this value is equal to (total lent amount - principal borrowed) * lenders lp balance / total lent amount
    */
    function _calculatePrincipalWithdrawable(uint256 _id, address _lender) private view returns (uint256) {
        uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;
        uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
        uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);
        return _principalWithdrawable;
    }

    //-------------------------------- Liquidity withdraw end --------------------------------//

    //-------------------------------- Liquidation start --------------------------------//

    /**
     * @notice Function used to liquidate a pooled credit line
     * @dev only one of the lenders can liquidate their pooled credit line
     * @param _id identifier for the pooled credit line
     * @param _withdraw flag used to identify if lender's share of
              liquidated collateral and liquidity (amount lent + interest) is also withdrawn
     */
    function liquidate(uint256 _id, bool _withdraw) external nonReentrant {
        uint256 _lendingShare = balanceOf(msg.sender, _id);
        require(_lendingShare != 0, 'LP:LIQ1');
        // This line would call the liquidate function in the pooledCreditLine contract.
        // Which would transfer the totalCollateralTokens to the pooledCreditLine contract.
        (address _collateralAsset, uint256 _collateralLiquidated) = POOLED_CREDIT_LINE.liquidate(_id);
        pooledCLConstants[_id].collateralAsset = _collateralAsset;
        pooledCLVariables[_id].collateralHeld = _collateralLiquidated;

        emit Liquidated(_id, _collateralLiquidated);

        if (_withdraw) {
            // This function would give the share of the lender who called this function from the total liquidated amount
            // this will withdraw both the _collateralAsset and the borrowAsset
            _withdrawTokensAfterLiquidation(_id, _lendingShare);
        }
    }

    /**
     * @notice Function used to withdraw lender's share of liquidated collateral and the borrowAsset
     * @param _id identifier for the pooled credit line
     */
    function withdrawTokensAfterLiquidation(uint256 _id) external nonReentrant {
        uint256 _lendingShare = balanceOf(msg.sender, _id);
        require(_lendingShare != 0, 'LP:WLC1');
        _withdrawTokensAfterLiquidation(_id, _lendingShare);
    }

    function _withdrawTokensAfterLiquidation(uint256 _id, uint256 _balance) private {
        address _collateralAsset = pooledCLConstants[_id].collateralAsset;
        require(_collateralAsset != address(0), 'LP:IWLC1');
        uint256 _collateralLiquidated = pooledCLVariables[_id].collateralHeld;
        uint256 _currentSupply = totalSupply[_id];

        uint256 _lenderCollateralShare = _balance.mul(_collateralLiquidated).div(_currentSupply);

        if (_lenderCollateralShare != 0) {
            pooledCLVariables[_id].collateralHeld = pooledCLVariables[_id].collateralHeld.sub(_lenderCollateralShare);

            IERC20(_collateralAsset).safeTransfer(msg.sender, _lenderCollateralShare);
            emit LiquidationWithdrawn(_id, msg.sender, _lenderCollateralShare);
        }
        // this will withdraw the lender's share of liquidity (amount lent + interest)
        _withdrawLiquidity(_id, true);
    }

    //-------------------------------- Liquidation end --------------------------------//

    //-------------------------------- Pre token transfer start --------------------------------//

    function _beforeTokenTransfer(
        address,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory
    ) internal override {
        require(from != to, 'LP:IT1');
        for (uint256 i; i < ids.length; ++i) {
            uint256 id = ids[i];
            if (to != address(0)) {
                // cannot transfer to the borrower
                require(to != POOLED_CREDIT_LINE.getBorrowerAddress(id), 'LP:IT2');
                // cannot transfer to a non verified user
                require(VERIFICATION.isUser(to, pooledCLConstants[id].lenderVerifier), 'LP:IT3');
            }

            uint256 amount = amounts[i];

            if (from == address(0)) {
                // this is the case for minting tokens
                // increase the total supply of lp tokens
                totalSupply[id] = totalSupply[id].add(amount);
            } else if (to == address(0)) {
                // this is the case for burn
                // reduce the total supply of lp tokens
                uint256 supply = totalSupply[id];
                require(supply >= amount, 'LP:IT4');
                totalSupply[id] = supply - amount;
            } else {
                // case for user to user transfer
                require(pooledCLConstants[id].areTokensTransferable, 'LP:IT5');
            }

            if (from != address(0)) {
                // we need to transfer the lender info from to the receiving address
                _rebalanceInterestWithdrawn(id, amount, from, to);
            }
        }
    }

    function _rebalanceInterestWithdrawn(
        uint256 id,
        uint256 amount,
        address from,
        address to
    ) private {
        if (from != address(0) && to != address(0)) {
            // if the transfer is from user to user, we will withdraw all the interest for the user
            // this is done because we need to transfer the lender info
            // if the interest is not withdrawn the [from] user will not be able to withdraw the interest owned to them
            _withdrawInterest(id, from);
            _withdrawInterest(id, to);
        }

        uint256 fromBalance = balanceOf(from, id);
        require(fromBalance != 0, 'LP:IRIW1');

        uint256 yieldInterestOnTransferAmount = pooledCLVariables[id].lenders[from].yieldInterestWithdrawnShares.mul(amount).div(
            fromBalance
        );
        uint256 borrowerInterestOnTransferAmount = pooledCLVariables[id].lenders[from].borrowerInterestSharesWithdrawn.mul(amount).div(
            fromBalance
        );

        if (borrowerInterestOnTransferAmount != 0) {
            pooledCLVariables[id].lenders[from].borrowerInterestSharesWithdrawn = pooledCLVariables[id]
                .lenders[from]
                .borrowerInterestSharesWithdrawn
                .sub(borrowerInterestOnTransferAmount);
        }

        if (yieldInterestOnTransferAmount != 0) {
            pooledCLVariables[id].lenders[from].yieldInterestWithdrawnShares = pooledCLVariables[id]
                .lenders[from]
                .yieldInterestWithdrawnShares
                .sub(yieldInterestOnTransferAmount);
        }

        if (to != address(0)) {
            if (borrowerInterestOnTransferAmount != 0) {
                pooledCLVariables[id].lenders[to].borrowerInterestSharesWithdrawn = pooledCLVariables[id]
                    .lenders[to]
                    .borrowerInterestSharesWithdrawn
                    .add(borrowerInterestOnTransferAmount);
            }
            if (yieldInterestOnTransferAmount != 0) {
                pooledCLVariables[id].lenders[to].yieldInterestWithdrawnShares = pooledCLVariables[id]
                    .lenders[to]
                    .yieldInterestWithdrawnShares
                    .add(yieldInterestOnTransferAmount);
            }
        }
    }

    //-------------------------------- Pre token transfer end --------------------------------//

    //-------------------------------- getters start --------------------------------//

    /**
     * @notice Function used to get withdrawal info of a lender for a specific pooled credit line
     * @param _id identifier for the pooled credit line
     * @param _lender address of the lender for which query is made
     * @return returns lender info
     */
    function getLenderInfo(uint256 _id, address _lender) external view returns (LenderInfo memory) {
        return pooledCLVariables[_id].lenders[_lender];
    }

    //-------------------------------- getters end --------------------------------//
}",9069
RealWorld_TA_101_PCLTerminatedStage.t_RealWorld_20240812153937.log,101,PCLTerminatedStage.t,90718,3773,94491,112.0,0.52905,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLStageTests/PCLTerminatedStage.t.sol';

contract PCLTerminatedStageZeroCollateral is PCLTerminatedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * (10**ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), collateralToDeposit);

            // We want to deposit collateral now
            if (request.collateralRatio != 0) {
                borrower.depositCollateral(requestId, collateralToDeposit, false);
            }
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_timeWarp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.setAllowance(address(pcl), address(borrowAsset), interestAccrued + 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        admin.terminate(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED, '!Terminated');
        notCreatedRequestId = requestId;
    }
}",841
RealWorld_TA_101_creditLine.UpdateFunctions.t_RealWorld_20240812164214.log,101,creditLine.UpdateFunctions.t,313743,3175,316918,113.0,1.632215,"pragma solidity 0.7.6;

import './Helpers/CLParent.sol';

contract CreditLine_UpdateFunctionTests is CLParent {
    CreditLine cl;

    function setUp() public {
        CLSetUp();

        cl = CreditLine(creditLineAddress);
    }

    //----------------------- Credit line update protocol fee collector, failing tests -----------------------//

    // Should fail when same address is used for fee collector update
    function test_updateProtocolFeeCollector_SameAddress() public {
        address currentFeeCollector = cl.protocolFeeCollector();
        try admin.updateProtocolFeeCollector(currentFeeCollector, address(cl)) {
            revert('REVERT: Same Value');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:UPFC1');
        }
    }

    // Should fail when zero address is used for fee collector update
    function test_updateProtocolFeeCollector_zeroAddress() public {
        try admin.updateProtocolFeeCollector(address(0), address(cl)) {
            revert('REVERT: Zero Address');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:IUPFC1');
        }
    }

    // Should fail when invalid actor (not admin) calls updates
    function test_updateProtocolFeeCollector_InvalidActor() public {
        address randomAddr = address(uint256(keccak256(abi.encodePacked(block.timestamp))));
        try cl.updateProtocolFeeCollector(randomAddr) {
            revert('REVERT: Invalid actor');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    //----------------------- Credit line update protocol fee collector, passing tests -----------------------//

    // Should fail when fee collector address is updated
    function test_creditLineUpdateProtocolFeeCollector(address protocolFeeCollector) public {
        try admin.updateProtocolFeeCollector(protocolFeeCollector, address(cl)) {
            address updatedFeeCollector = cl.protocolFeeCollector();
            assertEq(updatedFeeCollector, protocolFeeCollector);
        } catch Error(string memory reason) {
            if (compareStrings(reason, 'CL:UPFC1')) {
                log_string('Same address used for update');
            } else if (compareStrings(reason, 'CL:IUPFC1')) {
                log_string('address(0) used for update');
            } else {
                revert(reason);
            }
        }
    }

    //----------------------- Credit line update protocol fee fraction, failing tests -----------------------//

    // Should fail when same value is used for updates
    function test_updateProtocolFeeFraction_SameValue() public {
        uint256 currentProtocolFee = cl.protocolFeeFraction();
        try admin.updateProtocolFeeFraction(currentProtocolFee, address(cl)) {
            revert('REVERT: Same Value');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:UPFF1');
        }
    }

    // Should fail when vaue >1 is used for updates
    function test_updateProtocolFeeFraction_InvalidFraction() public {
        try admin.updateProtocolFeeFraction(1e20, address(cl)) {
            revert('REVERT: Invalid value');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:IUPFF1');
        }
    }

    // Should fail when invalid actor (not admin) calls updates
    function test_updateProtocolFeeFraction_InvalidActor() public {
        try cl.updateProtocolFeeFraction(1e25) {
            revert('REVERT: Invalid actor');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    //----------------------- Credit line update protocol fee fraction, passing tests -----------------------//

    // Should pass when protocol fee is updated
    function test_creditLineUpdateProtocolFeeFraction(uint256 protocolFeeFraction) public {
        try admin.updateProtocolFeeFraction(protocolFeeFraction, address(cl)) {
            uint256 updatedProtocolFee = cl.protocolFeeFraction();
            assertEq(updatedProtocolFee, protocolFeeFraction);
        } catch Error(string memory reason) {
            if (compareStrings(reason, 'CL:UPFF1')) {
                log_string('Same value used for update');
            } else if (compareStrings(reason, 'CL:IUPFF1')) {
                log_string('invalid (>1) value used for update');
            } else {
                revert(reason);
            }
        }
    }

    // Should pass when zero vaue is used for updates
    function test_updateProtocolFeeFraction_zeroValue() public {
        admin.updateProtocolFeeFraction(0, address(cl));
        uint256 updatedProtocolFee = cl.protocolFeeFraction();
        assertEq(updatedProtocolFee, 0);
    }

    //----------------------- Credit line update liquidator reward fraction, failing tests -----------------------//

    // Should fail when same value is used for updates
    function test_updateLiquidatorRewardFraction_SameValue() public {
        uint256 currentLiquidatorReward = cl.liquidatorRewardFraction();
        try admin.updateLiquidatorRewardFraction(currentLiquidatorReward, address(cl)) {
            revert('REVERT: Same Value');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:ULRF1');
        }
    }

    // Should fail when value higher than limit is used for updates
    function test_updateLiquidatorRewardFraction_ExceedsValue() public {
        try admin.updateLiquidatorRewardFraction(1e18 + 1, address(cl)) {
            revert('REVERT: Invalid value');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:IULRF1');
        }
    }

    // Should fail when invalid actor (not admin) calls updates
    function test_updateLiquidatorRewardFraction_InvalidActor() public {
        try cl.updateLiquidatorRewardFraction(1e25) {
            revert('REVERT: Invalid actor');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    //----------------------- Credit line update liquidator reward fraction, passing tests -----------------------//

    // Should pass when liquidator reward fraction is updated
    function test_creditLineUpdateLiquidatorRewardFraction(uint256 liquidatorReward) public {
        try admin.updateLiquidatorRewardFraction(liquidatorReward, address(cl)) {
            uint256 updatedLiquidatorReward = cl.liquidatorRewardFraction();
            assertEq(updatedLiquidatorReward, liquidatorReward);
        } catch Error(string memory reason) {
            if (compareStrings(reason, 'CL:ULRF1')) {
                log_string('Same value used for update');
            } else if (compareStrings(reason, 'CL:IULRF1')) {
                log_string('invalid (>1) value used for update');
            } else {
                revert(reason);
            }
        }
    }

    // Should pass when zero vaue is used for updates
    function test_updateLiquidatorRewardFraction_zeroValue() public {
        admin.updateLiquidatorRewardFraction(0, address(cl));
        uint256 updatedLiquidatorReward = cl.liquidatorRewardFraction();
        assertEq(updatedLiquidatorReward, 0);
    }

    //----------------------- Credit line update borrow limit limits, failing tests -----------------------//

    // Should fail when the same limits are used for updates
    function test_updateBorrowLimitLimits_SameLimits() public {
        (uint256 currMin, uint256 currMax) = cl.borrowLimitLimits();
        try admin.updateBorrowLimitLimits(currMin, currMax, address(cl)) {
            revert('REVERT: Same Value');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:UBLL2');
        }
    }

    // Should fail when min limit > max limit
    function test_updateBorrowLimitLimits_MaxMin() public {
        try admin.updateBorrowLimitLimits(1e20, 1, address(cl)) {
            revert('REVERT: Invalid Value');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:UBLL1');
        }
    }

    // Should fail when invalid actor (not admin) calls updates
    function test_updateBorrowLimitLimits_InvalidActor() public {
        try cl.updateBorrowLimitLimits(1, 1e20) {
            revert('REVERT: Invalid actor');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    //----------------------- Credit line update borrow limit limits, passing tests -----------------------//

    // Should pass when borrow limit limits are updated
    function test_creditLineupdateBorrowLimitLimits(uint128 _min, uint128 _max) public {
        try admin.updateBorrowLimitLimits(_min, _max, address(cl)) {
            (uint256 min, uint256 max) = cl.borrowLimitLimits();
            assertEq(min, uint256(_min));
            assertEq(max, uint256(_max));
        } catch Error(string memory reason) {
            if (compareStrings(reason, 'CL:UBLL2')) {
                log_string('Same values used for update');
            } else if (compareStrings(reason, 'CL:UBLL1')) {
                log_string('Invalid values used for update');
            } else {
                revert(reason);
            }
        }
    }

    // Should pass when zero value is used for limits
    function test_updateBorrowLimitLimits_zero() public {
        admin.updateBorrowLimitLimits(0, 0, address(cl));
        (uint256 min, uint256 max) = cl.borrowLimitLimits();
        assertEq(min, 0);
        assertEq(max, 0);
    }

    // Should pass when same limit value is used (both minimum)
    function test_updateBorrowLimitLimits_SameMin() public {
        admin.updateBorrowLimitLimits(1, 1, address(cl));
        (uint256 min, uint256 max) = cl.borrowLimitLimits();
        assertEq(min, 1);
        assertEq(max, 1);
    }

    // Should pass when same limit value is used (both maximum)
    function test_updateBorrowLimitLimits_SameMax() public {
        admin.updateBorrowLimitLimits(1e20, 1e20, address(cl));
        (uint256 min, uint256 max) = cl.borrowLimitLimits();
        assertEq(min, 1e20);
        assertEq(max, 1e20);
    }

    //----------------------- Credit line update ideal collateral ratio limits, failing tests -----------------------//

    // Should fail when same limits are used for updates
    function test_updateIdealCollateralRatioLimits_SameLimits() public {
        (uint256 currMin, uint256 currMax) = cl.idealCollateralRatioLimits();
        try admin.updateIdealCollateralRatioLimits(currMin, currMax, address(cl)) {
            revert('REVERT: Same Value');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:UICRL2');
        }
    }

    // Should fail when min limit > max limit
    function test_updateIdealCollateralRatioLimits_MaxMin() public {
        try admin.updateIdealCollateralRatioLimits(1e30, 1, address(cl)) {
            revert('REVERT: Invalid Value');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:UICRL1');
        }
    }

    // Should fail when invalid actor (not admin) calls updates
    function test_updateIdealCollateralRatioLimits_InvalidActor() public {
        try cl.updateIdealCollateralRatioLimits(1, 1e30) {
            revert('REVERT: Invalid actor');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    //----------------------- Credit line update ideal collateral ratio limits, passing tests -----------------------//

    // Should pass when ideal collateral ratio is updated
    function test_creditLineupdateIdealCollateralRatioLimits(uint128 _min, uint128 _max) public {
        try admin.updateIdealCollateralRatioLimits(_min, _max, address(cl)) {
            (uint256 min, uint256 max) = cl.idealCollateralRatioLimits();
            assertEq(min, uint256(_min));
            assertEq(max, uint256(_max));
        } catch Error(string memory reason) {
            if (compareStrings(reason, 'CL:UICRL2')) {
                log_string('Same values used for update');
            } else if (compareStrings(reason, 'CL:UICRL1')) {
                log_string('Invalid values used for update');
            } else {
                revert(reason);
            }
        }
    }

    // Should pass when zero value is used for limits
    function test_updateIdealCollateralRatioLimits_zero() public {
        admin.updateIdealCollateralRatioLimits(0, 0, address(cl));
        (uint256 min, uint256 max) = cl.idealCollateralRatioLimits();
        assertEq(min, 0);
        assertEq(max, 0);
    }

    // Should fail when same limit value is used (both minimum)
    function test_updateIdealCollateralRatioLimits_SameMin() public {
        admin.updateIdealCollateralRatioLimits(1, 1, address(cl));
        (uint256 min, uint256 max) = cl.idealCollateralRatioLimits();
        assertEq(min, 1);
        assertEq(max, 1);
    }

    // Should fail when same limit value is used (both maximum)
    function test_updateIdealCollateralRatioLimits_SameMax() public {
        admin.updateIdealCollateralRatioLimits(1e30, 1e30, address(cl));
        (uint256 min, uint256 max) = cl.idealCollateralRatioLimits();
        assertEq(min, 1e30);
        assertEq(max, 1e30);
    }

    //----------------------- Credit line update borrow rate limits, failing tests -----------------------//

    // Should fail when same values are used for updates
    function test_updateBorrowRateLimits_SameLimits() public {
        (uint256 currMin, uint256 currMax) = cl.borrowRateLimits();
        try admin.updateBorrowRateLimits(currMin, currMax, address(cl)) {
            revert('REVERT: Same Value');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:UBRL2');
        }
    }

    // Should fail when min limit > max limit
    function test_updateBorrowRateLimits_MaxMin() public {
        try admin.updateBorrowRateLimits(1e20, 1, address(cl)) {
            revert('REVERT: Invalid Value');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:UBRL1');
        }
    }

    // Should fail when invalid actor (not admin) calls updates
    function test_updateBorrowRateLimits_InvalidActor() public {
        try cl.updateBorrowRateLimits(1, 1e20) {
            revert('REVERT: Invalid actor');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    //----------------------- Credit line update borrow rate limits, passing tests -----------------------//

    // Should pass when borrow rate limit is updated
    function test_creditLineupdateBorrowRateLimits(uint128 _min, uint128 _max) public {
        try admin.updateBorrowRateLimits(_min, _max, address(cl)) {
            (uint256 min, uint256 max) = cl.borrowRateLimits();
            assertEq(min, uint256(_min));
            assertEq(max, uint256(_max));
        } catch Error(string memory reason) {
            if (compareStrings(reason, 'CL:UBRL2')) {
                log_string('Same values used for update');
            } else if (compareStrings(reason, 'CL:UBRL1')) {
                log_string('invalid values used for update');
            } else {
                revert(reason);
            }
        }
    }

    // Should pass when zero value is used for update
    function test_updateBorrowRateLimits_zero() public {
        admin.updateBorrowRateLimits(0, 0, address(cl));
        (uint256 min, uint256 max) = cl.borrowRateLimits();
        assertEq(min, 0);
        assertEq(max, 0);
    }

    // Should fail when same limit value is used for update (both minimum)
    function test_updateBorrowRateLimits_SameMin() public {
        admin.updateBorrowRateLimits(1, 1, address(cl));
        (uint256 min, uint256 max) = cl.borrowRateLimits();
        assertEq(min, 1);
        assertEq(max, 1);
    }

    // Should fail when same limit value is used for update (both maximum)
    function test_updateBorrowRateLimits_SameMax() public {
        admin.updateBorrowRateLimits(1e30, 1e30, address(cl));
        (uint256 min, uint256 max) = cl.borrowRateLimits();
        assertEq(min, 1e30);
        assertEq(max, 1e30);
    }
}",3560
RealWorld_TA_101_PCLActiveStage.t_RealWorld_20240812144658.log,101,PCLActiveStage.t,1470866,43,1470909,188.0,7.35519,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}",17882
RealWorld_TA_101_PCLLiquidatedState.t_RealWorld_20240812155332.log,101,PCLLiquidatedState.t,597033,3981,601014,160.0,3.064785,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        //The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        // Now we assert that we are in the ACTIVE state
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), 2);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 200);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: A Liquidated PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start a PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral cannot be deposited
    function test_collateralCannotBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try borrower.depositCollateral(requestId, _minimumCollateralRequired, false) {
            revert('Collateral cannot be deposited');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    // Test 3: Withdrawable collateral is zero (since in this case, total collateral remaining < collateral to liquidate)
    function test_withdrawableCollateralIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertApproxEqAbs(_withdrawableCollateral, 0, 2);
    }

    // Test 3: Withdrawable collateral is non-zero if total collateral remaining > collateral to liquidate
    function test_withdrawableCollateralIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral * 2);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        borrower.depositCollateral(_requestId, _requiredCollateral * 2, false);
        uint256 _borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, _borrowableAmount);
        vm.warp(block.timestamp + request.duration / 2);
        uint256 _currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(_requestId, _currentDebt / 2);
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lender_0).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_requestId);
        assertGt(_withdrawableCollateral, 0);
    }

    // Test 3.2: Collateral can or cannot be withdrawn
    function test_collateralCanOrCannotBeWithdrawn(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _tokens = (pcl.depositedCollateralInShares(requestId) * ICToken(collateralCTokenAddress).exchangeRateCurrent()) / 1e18;
        if (_tokens > 0) {
            uint256 _borrowerBalanceBefore = collateralAsset.balanceOf(address(borrower));
            borrower.withdrawCollateral(requestId, 1, false);
            uint256 _borrowerBalanceAfter = collateralAsset.balanceOf(address(borrower));
            assertGe(_borrowerBalanceAfter, _borrowerBalanceBefore);
        } else {
            try borrower.withdrawCollateral(requestId, 1, false) {
                revert('Collateral cannot be withdrawn');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:WC1');
            }
        }
    }

    // Test 3.3: All collateral can or cannot be withdrawn
    function test_allCollateralCanOrCannotBeWithdrawn(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _tokens = (pcl.depositedCollateralInShares(requestId) * ICToken(collateralCTokenAddress).exchangeRateCurrent()) / 1e18;
        if (_tokens > 0) {
            uint256 _borrowerBalanceBefore = collateralAsset.balanceOf(address(borrower));
            borrower.withdrawAllCollateral(requestId, false);
            uint256 _borrowerBalanceAfter = collateralAsset.balanceOf(address(borrower));
            assertGe(_borrowerBalanceAfter, _borrowerBalanceBefore);
        } else {
            try borrower.withdrawAllCollateral(requestId, false) {
                revert('All collateral cannot be withdrawn');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:WAC1');
            }
        }
    }

    // Test 4: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);

        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);

        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: Borrowable amount remains zero
    function test_borrowableAmountIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 6: A Liquidated PCL cannot be closed
    function test_pclCannotBeClosed(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('PCL cannot be closed');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    // Test 7: Collateral ratio remains zero
    function test_collateralRatioRemainsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertApproxEqAbs(_collateralRatioNew / 1e16, 0, 9);
    }

    // Test 7.1: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.2: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders can withdraw liquidation
    function test_lendersCanWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _userPoolTokenBalance = lp.balanceOf(address(lender_0), requestId);
        uint256 _lenderInterestOwed = PCLUser(lender_0).getLenderInterest(requestId, lender_0);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _userBorrowTokenBalanceBefore = IERC20(request.borrowAsset).balanceOf(address(lender_0));
        uint256 _userCollateralTokenBalanceBefore = IERC20(request.collateralAsset).balanceOf(address(lender_0));
        PCLUser(lender_0).withdrawLiquidation(requestId);
        uint256 _userBorrowTokenBalanceAfter = IERC20(request.borrowAsset).balanceOf(address(lender_0));
        uint256 _userCollateralTokenBalanceAfter = IERC20(request.collateralAsset).balanceOf(address(lender_0));
        assertGt(_userPoolTokenBalance + _lenderInterestOwed, _userBorrowTokenBalanceAfter - _userBorrowTokenBalanceBefore);
        assertGt(_userCollateralTokenBalanceAfter - _userCollateralTokenBalanceBefore, 0);
        _userPoolTokenBalance = lp.balanceOf(address(lender_0), requestId);
        assertEq(_userPoolTokenBalance, 0);
    }

    // Test 9: Lenders cannot withdraw liquidity
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try PCLUser(lender_0).withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }
    }

    // Test 10: A Liquidated PCL cannot be liquidated
    function test_lendersCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // lender_0 tries to liquidate the PCL
        try PCLUser(lender_0).liquidate(requestId, _withdraw) {
            revert('Cannot liquidate a Liquidated PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L2');
        }
    }

    // Test 11: Admin can terminate pcl
    function test_adminCanTerminatePCL(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        admin.terminate(requestId);
        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt(_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate, 0);
    }

    // Test 12: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.1: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);
        uint256 lender1BalanceAfter = borrowAsset.balanceOf(address(lender1));
        assertEq(lender1BalanceAfter, lender1Balance + lender1InterestOwed);
        assertEq(lender1.getLenderInterest(requestId, address(lender1)), 0);
    }

    // Test 14: A Liquidated PCL cannot be cancelled
    function test_pclCannotBeCancelled(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('PCL cannot be cancelled');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function assert_helperFunctionalitiesInLiquidatedState(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertApproxEqAbs(_currentCR1 / 1e16, 0, 9);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertGe(_principalWithdrawable, 0); // Since the lenders can withdraw their liquidity from a closed PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertApproxEqAbs(_withdrawableCollateral, 0, 2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertApproxEqAbs(_totalCollateral, 0, 2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_helperFunctionsInLiquidatedState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInLiquidatedState(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}",7030
RealWorld_TA_101_SublimeProxy_RealWorld_20240812135902.log,101,SublimeProxy,24094,1270,25364,63.0,0.14587,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol';

contract SublimeProxy is TransparentUpgradeableProxy {
    constructor(
        address logic,
        address admin,
        bytes memory data
    ) payable TransparentUpgradeableProxy(logic, admin, data) {}
}",74
RealWorld_TA_101_creditLine.Compound.Repayments.t_RealWorld_20240812170202.log,101,creditLine.Compound.Repayments.t,65454,5178,70632,122.0,0.43083,"pragma solidity 0.7.6;
pragma abicoder v2;

import '../creditLine.Repayments.t.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

contract CreditLine_Compound_RepaymentTests is CreditLine_RepaymentTests {
    using SafeMath for uint256;

    function setUp() public override {
        CLSetUp();

        creditLine = CreditLine(creditLineAddress);
        priceOracle = PriceOracle(priceOracleAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = priceOracle.getLatestPrice(address(usdc), address(borrowAsset));

        requestData.requestTo = address(lender);
        // Borrow Asset equivalent of 1,000,000,000 in USD
        requestData.borrowLimit = uint128(uint256(CLConstants.maxBorrowLimit / 1e6).mul(_ratioOfPrices).div(10**_decimals));
        requestData.borrowRate = CLConstants.maxBorrowRate / 1e18;
        requestData.autoLiquidation = false;
        requestData.collateralRatio = CLConstants.maxCollteralRatio / 1e18;
        requestData.borrowAsset = address(borrowAsset);
        requestData.collateralAsset = address(collateralAsset);
        requestData.requestAsLender = false;

        requestData.borrowAssetStrategy = compoundYieldAddress;
        requestData.collateralStrategy = compoundYieldAddress;

        // Adding addresses to array
        userList.push(address(admin));
        userList.push(address(borrower));
        userList.push(address(lender));
        userList.push(address(liquidator));

        creditLineId = goToActiveStage();

        amount = 10**(ERC20(address(collateralAsset)).decimals());

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount.div(1000));
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount.div(1000));

        borrower.addCollateral(address(creditLine), creditLineId, amount.div(1000), false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), requestData.borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);

        // Time travel by 10 days
        vm.warp(block.timestamp + 10 days);
    }
}",512
RealWorld_TA_101_BeforeLiquidationFailureCases.t_RealWorld_20240812143943.log,101,BeforeLiquidationFailureCases.t,413244,4567,417811,136.0,2.15756,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

import '../Helpers/PCLParent.t.sol';

contract BeforeLiquidationFailureCases is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    uint256 requestId;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
    }

    function test_noLiquidationIfCollateralRatioIsFineAndNotExpired1() public {
        assert_noLiquidationIfCollateralRatioIsFineAndNotExpired(requestId, uint128(request.minBorrowAmount), 0);
    }

    function test_noLiquidationIfCollateralRatioIsFineAndNotExpired2() public {
        assert_noLiquidationIfCollateralRatioIsFineAndNotExpired(requestId, request.borrowLimit, request.duration - 1);
    }

    function test_noLiquidationIfCollateralRatioIsFineAndNotExpired3() public {
        assert_noLiquidationIfCollateralRatioIsFineAndNotExpired(requestId, uint128(request.minBorrowAmount), request.duration - 1);
    }

    function test_noLiquidationIfCollateralRatioIsFineAndNotExpired4() public {
        assert_noLiquidationIfCollateralRatioIsFineAndNotExpired(requestId, uint128(request.minBorrowAmount), 0);
    }

    function assert_noLiquidationIfCollateralRatioIsFineAndNotExpired(
        uint256 _pclId,
        uint256 _amountToBorrow,
        uint256 _warpTime
    ) internal {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_pclId, _amountToBorrow) + 1;

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        borrower.depositCollateral(_pclId, _collateralRequired, false);

        borrower.borrow(requestId, _amountToBorrow.mul(90).div(100));

        vm.warp(block.timestamp + _warpTime);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_pclId, true) {
            revert('Borrower liquidating should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_noLiquidationIfCollateralRatioIsFineAtExpirationTimestamp1() public {
        assert_noLiquidationIfCollateralRatioIsFineAtExpirationTimestamp(requestId, uint128(request.minBorrowAmount));
    }

    function test_noLiquidationIfCollateralRatioIsFineAtExpirationTimestamp2() public {
        assert_noLiquidationIfCollateralRatioIsFineAtExpirationTimestamp(requestId, request.borrowLimit);
    }

    function assert_noLiquidationIfCollateralRatioIsFineAtExpirationTimestamp(uint256 _pclId, uint256 _amountToBorrow) internal {
        // adding 1 to ensure that any diff due to imprecision issues is covered
        uint256 _collateralRequired = pcl.getRequiredCollateral(_pclId, _amountToBorrow) + 1;
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        borrower.depositCollateral(_pclId, _collateralRequired, false);
        borrower.borrow(_pclId, _amountToBorrow.mul(90).div(100));

        vm.warp(block.timestamp + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_pclId, true) {
            revert('Borrower liquidating should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_noLiquidateIfInGracePeriod1() public {
        assert_noLiquidateIfInGracePeriod(requestId, request.borrowLimit, request.duration + 1);
    }

    function test_noLiquidateIfInGracePeriod2() public {
        assert_noLiquidateIfInGracePeriod(requestId, request.borrowLimit, request.duration + request.defaultGracePeriod - 1);
    }

    function test_noLiquidateIfInGracePeriod3() public {
        assert_noLiquidateIfInGracePeriod(requestId, uint128(request.minBorrowAmount), request.duration + 1);
    }

    function test_noLiquidateIfInGracePeriod4() public {
        assert_noLiquidateIfInGracePeriod(requestId, uint128(request.minBorrowAmount), request.duration + request.defaultGracePeriod - 1);
    }

    function assert_noLiquidateIfInGracePeriod(
        uint256 _pclId,
        uint256 _amountToBorrow,
        uint256 _warpTime
    ) internal {
        // adding 1 to ensure that any diff due to imprecision issues is covered
        uint256 _collateralRequired = pcl.getRequiredCollateral(_pclId, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        borrower.depositCollateral(_pclId, _collateralRequired, false);

        borrower.borrow(_pclId, _amountToBorrow.mul(90).div(100));

        vm.warp(block.timestamp + _warpTime);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_pclId, true) {
            revert('Borrower liquidating should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_noLiquidationIfBorrowPriceDropsToZero(uint128 _amountToBorrow) public {
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint128 _warpTime = uint128(request.duration + request.defaultGracePeriod + 1);
        assert_noLiquidationIfBorrowPriceDropsToZero(requestId, _amountToBorrow, _warpTime);
    }

    function assert_noLiquidationIfBorrowPriceDropsToZero(
        uint256 _pclId,
        uint256 _amountToBorrow,
        uint256 _warpTime
    ) internal {
        // adding 1 to ensure that any diff due to imprecision issues is covered
        uint256 _collateralRequired = pcl.getRequiredCollateral(_pclId, _amountToBorrow) + 1;

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        borrower.depositCollateral(_pclId, _collateralRequired, false);

        borrower.borrow(requestId, _amountToBorrow.mul(90).div(100));

        vm.warp(block.timestamp + _warpTime);

        vm.mockCall(
            priceOracleAddress,
            abi.encodeWithSelector(IPriceOracle.getLatestPrice.selector, address(collateralAsset), address(borrowAsset)),
            abi.encode(0, 0) // price, decimals
        );

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.liquidate(_pclId, true) {
            revert('Borrower liquidating should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'SafeMath: division by zero');
        }
    }

    function test_noLiquidationIfBorrowerTries(uint128 _amountToBorrow) public {
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint128 _warpTime = uint128(request.duration + request.defaultGracePeriod + 1);
        assert_noLiquidationIfBorrowerTries(requestId, _amountToBorrow, _warpTime);
    }

    function assert_noLiquidationIfBorrowerTries(
        uint256 _pclId,
        uint256 _amountToBorrow,
        uint256 _warpTime
    ) internal {
        // adding 1 to ensure that any diff due to imprecision issues is covered
        uint256 _collateralRequired = pcl.getRequiredCollateral(_pclId, _amountToBorrow) + 1;

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        borrower.depositCollateral(_pclId, _collateralRequired, false);

        borrower.borrow(requestId, _amountToBorrow.mul(90).div(100));

        vm.warp(block.timestamp + _warpTime);

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(1);
        }

        try borrower.liquidate(_pclId, true) {
            revert('Borrower liquidating should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    function test_noLiquidateIfAdminTries(uint128 _amountToBorrow, uint128 _warpTime) public {
        _amountToBorrow = scaleToRange128(_amountToBorrow, 1, request.borrowLimit);
        _warpTime = scaleToRange128(_warpTime, 1, uint128(request.duration + request.defaultGracePeriod + request.duration));
        assert_noLiquidateIfAdminTries(requestId, _amountToBorrow, _warpTime);
    }

    function assert_noLiquidateIfAdminTries(
        uint256 _pclId,
        uint256 _amountToBorrow,
        uint256 _warpTime
    ) internal {
        // adding 1 to ensure that any diff due to imprecision issues is covered
        uint256 _collateralRequired = pcl.getRequiredCollateral(_pclId, _amountToBorrow) + 1;

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        borrower.depositCollateral(_pclId, _collateralRequired, false);

        borrower.borrow(requestId, _amountToBorrow);

        vm.warp(block.timestamp + _warpTime);

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(1);
        }

        try admin.liquidate(_pclId, true) {
            revert('Borrower liquidating should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    function test_noLiquidateIfNotLenderButWasOnceTries(
        uint128 _amountToBorrow,
        uint128 _warpTime,
        uint128 _lenderIndex
    ) public {
        _amountToBorrow = scaleToRange128(_amountToBorrow, 1, request.borrowLimit);
        _warpTime = scaleToRange128(_warpTime, 0, uint128(request.duration + request.defaultGracePeriod + request.duration));
        // this pool has 10 lenders and 0th lender is the one who receives the tokens
        _lenderIndex = scaleToRange128(_lenderIndex, 1, 9);
        assert_noLiquidateIfNotLenderButWasOnceTries(requestId, _amountToBorrow, _warpTime, _lenderIndex);
    }

    function assert_noLiquidateIfNotLenderButWasOnceTries(
        uint256 _pclId,
        uint256 _amountToBorrow,
        uint256 _warpTime,
        uint256 _lenderIndex
    ) internal {
        // adding 1 to ensure that any diff due to imprecision issues is covered
        uint256 _collateralRequired = pcl.getRequiredCollateral(_pclId, _amountToBorrow) + 1;

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        borrower.depositCollateral(_pclId, _collateralRequired, false);

        borrower.borrow(requestId, _amountToBorrow);

        vm.warp(block.timestamp + _warpTime);
        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(1);
        }

        PCLUser _lender = PCLUser(lenders[_lenderIndex].lenderAddress);

        _lender.transferLPTokens(lenders[0].lenderAddress, _pclId, lenders[_lenderIndex].amount);

        try _lender.liquidate(_pclId, true) {
            revert('Borrower liquidating should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    function test_noLiquidateIfPrincipalZero(
        uint128 _amountToBorrow,
        uint128 _warpTime,
        uint128 _lenderIndex
    ) public {
        _amountToBorrow = scaleToRange128(_amountToBorrow, 1, request.borrowLimit);
        _warpTime = scaleToRange128(_warpTime, 0, uint128(request.duration + request.defaultGracePeriod + request.duration));
        _lenderIndex = scaleToRange128(_lenderIndex, 0, 9);
        assert_noLiquidateIfPrincipalZero(requestId, _amountToBorrow, _warpTime, _lenderIndex);
    }

    function assert_noLiquidateIfPrincipalZero(
        uint256 _pclId,
        uint256 _amountToBorrow,
        uint256 _warpTime,
        uint256 _lenderIndex
    ) internal {
        // adding 1 to ensure that any diff due to imprecision issues is covered
        uint256 _collateralRequired = pcl.getRequiredCollateral(_pclId, _amountToBorrow) + 1;

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        borrower.depositCollateral(_pclId, _collateralRequired, false);

        vm.warp(block.timestamp + _warpTime);

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(1);
        }

        PCLUser _lender = PCLUser(lenders[_lenderIndex].lenderAddress);
        try _lender.liquidate(_pclId, true) {
            revert('Borrower liquidating should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_noLiquidateIfPCLContractLiquidateMethodIsCalledByAdmin(uint128 _amountToBorrow, uint128 _warpTime) public {
        _amountToBorrow = scaleToRange128(_amountToBorrow, 1, request.borrowLimit);
        _warpTime = scaleToRange128(_warpTime, 0, uint128(request.duration + request.defaultGracePeriod + request.duration));
        assert_noLiquidateIfPCLContractLiquidateMethodIsCalledByAdmin(requestId, _amountToBorrow, _warpTime);
    }

    function assert_noLiquidateIfPCLContractLiquidateMethodIsCalledByAdmin(
        uint256 _pclId,
        uint256 _amountToBorrow,
        uint256 _warpTime
    ) internal {
        // adding 1 to ensure that any diff due to imprecision issues is covered
        uint256 _collateralRequired = pcl.getRequiredCollateral(_pclId, _amountToBorrow) + 1;

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        borrower.depositCollateral(_pclId, _collateralRequired, false);

        borrower.borrow(requestId, _amountToBorrow);

        vm.warp(block.timestamp + _warpTime);

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(1);
        }

        try admin.noAccessLiquidate(_pclId) {
            revert('Borrower liquidating should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OLP1');
        }
    }

    function test_noLiquidateIfPCLContractLiquidateMethodIsCalledByLender(
        uint128 _amountToBorrow,
        uint128 _warpTime,
        uint128 _lenderIndex
    ) public {
        _amountToBorrow = scaleToRange128(_amountToBorrow, 1, request.borrowLimit);
        _warpTime = scaleToRange128(_warpTime, 0, uint128(request.duration + request.defaultGracePeriod + request.duration));
        _lenderIndex = scaleToRange128(_lenderIndex, 0, 9);
        PCLUser _lender = PCLUser(lenders[_lenderIndex].lenderAddress);
        assert_noLiquidateIfPCLContractLiquidateMethodIsCalledByAnyUser(requestId, _amountToBorrow, _warpTime, _lender);
    }

    function test_noLiquidateIfPCLContractLiquidateMethodIsCalledByBorrower(uint128 _amountToBorrow, uint128 _warpTime) public {
        _amountToBorrow = scaleToRange128(_amountToBorrow, 1, request.borrowLimit);
        _warpTime = scaleToRange128(_warpTime, 0, uint128(request.duration + request.defaultGracePeriod + request.duration));

        assert_noLiquidateIfPCLContractLiquidateMethodIsCalledByAnyUser(requestId, _amountToBorrow, _warpTime, borrower);
    }

    function test_noLiquidateIfPCLContractLiquidateMethodIsCalledByOthers(uint128 _amountToBorrow, uint128 _warpTime) public {
        _amountToBorrow = scaleToRange128(_amountToBorrow, 1, request.borrowLimit);
        _warpTime = scaleToRange128(_warpTime, 0, uint128(request.duration + request.defaultGracePeriod + request.duration));

        PCLUser _randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_noLiquidateIfPCLContractLiquidateMethodIsCalledByAnyUser(requestId, _amountToBorrow, _warpTime, _randomUser);
    }

    function assert_noLiquidateIfPCLContractLiquidateMethodIsCalledByAnyUser(
        uint256 _pclId,
        uint256 _amountToBorrow,
        uint256 _warpTime,
        PCLUser _user
    ) internal {
        // adding 1 to ensure that any diff due to imprecision issues is covered
        uint256 _collateralRequired = pcl.getRequiredCollateral(_pclId, _amountToBorrow) + 1;

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        borrower.depositCollateral(_pclId, _collateralRequired, false);

        borrower.borrow(requestId, _amountToBorrow);

        vm.warp(block.timestamp + _warpTime);

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(1);
        }

        try _user.noAccessLiquidate(_pclId) {
            revert('Borrower liquidating should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OLP1');
        }
    }

    function test_noLiquidateIfZeroCollateral(uint128 _amountToBorrow, uint128 _warpTime) public {
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        _warpTime = scaleToRange128(_warpTime, 0, uint128(request.duration + request.defaultGracePeriod + request.duration));
        request.collateralRatio = 0;
        goToActiveStage(10, uint128(_amountToBorrow));
    }

    function assert_noLiquidateIfZeroCollateral(
        uint256 _pclId,
        uint256 _amountToBorrow,
        uint256 _warpTime
    ) internal {
        borrower.borrow(requestId, _amountToBorrow);

        vm.warp(block.timestamp + _warpTime);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.liquidate(_pclId, true) {
            revert('Borrower liquidating should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }
}",4854
RealWorld_TA_101_creditLine.Compound.EdgeCases.t_RealWorld_20240812170030.log,101,creditLine.Compound.EdgeCases.t,25747,1894,27641,90.0,0.166615,"pragma solidity 0.7.6;
pragma abicoder v2;

import '../creditLine.EdgeCases.t.sol';

contract CreditLine_Compound_EdgeCaseTests is CreditLine_EdgeCaseTests {
    function setUp() public override {
        super.setUp();

        requestData.borrowAssetStrategy = compoundYieldAddress;
        requestData.collateralStrategy = compoundYieldAddress;
    }
}",80
RealWorld_TA_101_PCLActiveStage.t_RealWorld_20240812150002.log,101,PCLActiveStage.t,46442,2723,49165,87.0,0.28667,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLActiveStage.t.sol';

contract PCLActiveStageCollateralCompoundBorrowNoYield is PCLActiveStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * (10**ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
    }
}",324
RealWorld_TA_101_PCLAdmin.t_RealWorld_20240812155150.log,101,PCLAdmin.t,129266,3251,132517,100.0,0.71135,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';

import '../../ProtocolFeeCollector.sol';
import '../../roles/Admin.sol';
import '../../../SublimeProxy.sol';
import '../../../PriceOracle.sol';
import '../../../CreditLine/CreditLine.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../yield/CompoundYield.sol';
import '../Helpers/PCLConstants.t.sol';
import './PCLUser.t.sol';
import '../../../PooledCreditLine/LimitsManager.sol';
import '../../../interfaces/ILimitsManager.sol';

contract PCLAdmin is PCLUser, Admin {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    bytes emptyBytes;

    constructor(address _pclAddress, address _lpAddress) PCLUser(_pclAddress, _lpAddress) {}

    function deployLimitsManager(
        address _proxyAdmin,
        address _usdc,
        address _priceOracle
    ) public returns (address) {
        LimitsManager _limitsManagerImpl = new LimitsManager(_usdc, _priceOracle);
        address sublimeProxy = address(new SublimeProxy(address(_limitsManagerImpl), _proxyAdmin, emptyBytes));
        LimitsManager limitsManager = LimitsManager(sublimeProxy);
        limitsManager.initialize(address(this));
        limitsManager.updateBorrowAmountUSDCLimits(PCLConstants.minBorrowLimit, PCLConstants.maxBorrowLimit);
        limitsManager.updateBorrowRateLimits(PCLConstants.minBorrowRate, PCLConstants.maxBorrowRate);
        limitsManager.updateCollectionPeriodLimits(PCLConstants.minCollectionPeriod, PCLConstants.maxCollectionPeriod);
        limitsManager.updateDefaultGracePeriodLimits(PCLConstants.minDefaultGraceDuration, PCLConstants.maxDefaultGraceDuration);
        limitsManager.updateDurationLimits(PCLConstants.minDuration, PCLConstants.maxDuration);
        limitsManager.updateGracePenaltyRateLimits(PCLConstants.minGracePenaltyRate, PCLConstants.maxGracePenaltyRate);
        limitsManager.updateIdealCollateralRatioLimits(PCLConstants.minCollateralRatio, PCLConstants.maxCollateralRatio);
        return sublimeProxy;
    }

    function deployPCLContracts(
        address _proxyAdmin,
        address _savingsAccount,
        address _verification,
        address _priceOracle,
        address _strategyRegistry,
        address _limitsManager,
        address _mockProtocolFeeCollector
    ) public returns (address, address) {
        //address _placeHolder = address(this);
        // use any address and latter change to, here used _placeHolder

        {
            address _lenderPoolProxyAddress = address(new SublimeProxy(address(this), _proxyAdmin, emptyBytes));
            PooledCreditLine pclImplementation = new PooledCreditLine(
                _lenderPoolProxyAddress,
                _priceOracle,
                _savingsAccount,
                _strategyRegistry,
                _verification,
                _limitsManager,
                1e18 / 10
            );
            address sublimeProxy = address(new SublimeProxy(address(pclImplementation), _proxyAdmin, emptyBytes));
            pcl = PooledCreditLine(sublimeProxy);
            //emit log_named_address('pooledcreditline address', address(pcl));

            LenderPool _lenderPoolImplementation = new LenderPool(address(pcl), _savingsAccount, _verification);
            lp = LenderPool(payable(_lenderPoolProxyAddress));

            Admin(_proxyAdmin).changeImplementationAddressOfProxy(_lenderPoolProxyAddress, address(_lenderPoolImplementation));
            //emit log_named_address('lender pool1', address(_lenderPool));
            //emit log_named_address('lender pool2', address(_lenderPoolProxyAddress));
        }

        lp.initialize();

        pcl.initialize(address(this), PCLConstants.protocolFeeFraction, _mockProtocolFeeCollector);
        return (address(pcl), address(lp));
    }

    function updateBorrowLimitLimits(uint256 _min, uint256 _max) public {
        ILimitsManager _limitsManager = pcl.LIMITS_MANAGER();
        LimitsManager(address(_limitsManager)).updateBorrowAmountUSDCLimits(_min, _max);
    }

    function updateIdealCollateralRatioLimits(uint256 _min, uint256 _max) public {
        ILimitsManager _limitsManager = pcl.LIMITS_MANAGER();
        LimitsManager(address(_limitsManager)).updateIdealCollateralRatioLimits(_min, _max);
    }

    function updateBorrowRateLimits(uint256 _min, uint256 _max) public {
        ILimitsManager _limitsManager = pcl.LIMITS_MANAGER();
        LimitsManager(address(_limitsManager)).updateBorrowRateLimits(_min, _max);
    }

    function updateCollectionPeriodLimits(uint256 _min, uint256 _max) public {
        ILimitsManager _limitsManager = pcl.LIMITS_MANAGER();
        LimitsManager(address(_limitsManager)).updateCollectionPeriodLimits(_min, _max);
    }

    function updateDurationLimits(uint256 _min, uint256 _max) public {
        ILimitsManager _limitsManager = pcl.LIMITS_MANAGER();
        LimitsManager(address(_limitsManager)).updateDurationLimits(_min, _max);
    }

    function updateDefaultGracePeriodLimits(uint256 _min, uint256 _max) public {
        ILimitsManager _limitsManager = pcl.LIMITS_MANAGER();
        LimitsManager(address(_limitsManager)).updateDefaultGracePeriodLimits(_min, _max);
    }

    function updateGracePenaltyRateLimits(uint256 _min, uint256 _max) public {
        ILimitsManager _limitsManager = pcl.LIMITS_MANAGER();
        LimitsManager(address(_limitsManager)).updateGracePenaltyRateLimits(_min, _max);
    }

    function updateProtocolFeeFraction(uint256 _protocolFeeFraction) public {
        pcl.updateProtocolFeeFraction(_protocolFeeFraction);
    }

    function updateProtocolFeeCollector(address _protocolFeeCollector) public {
        pcl.updateProtocolFeeCollector(_protocolFeeCollector);
    }
}",1341
RealWorld_TA_101_creditLine.EdgeCases.t_RealWorld_20240812165619.log,101,creditLine.EdgeCases.t,499940,4958,504898,164.0,2.59886,"pragma solidity 0.7.6;
pragma abicoder v2;

import './Helpers/CLParent.sol';
import '../../SavingsAccount/SavingsAccount.sol';
import '../../PriceOracle.sol';

import '@openzeppelin/contracts/math/SafeMath.sol';

contract CreditLine_EdgeCaseTests is CLParent {
    using SafeMath for uint256;

    CreditLine creditLine;
    SavingsAccount savingsAccount;
    PriceOracle priceOracle;

    uint256 status;
    uint256 creditLineId;
    uint256 protocolFee;
    address borrowAssetStrategy;
    address collateralStrategy;

    uint256 constant SCALING_FACTOR = 1e18;

    function setUp() public virtual {
        CLSetUp();

        creditLine = CreditLine(creditLineAddress);
        savingsAccount = SavingsAccount(savingsAccountAddress);
        priceOracle = PriceOracle(priceOracleAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = priceOracle.getLatestPrice(address(usdc), address(borrowAsset));

        requestData.requestTo = address(lender);
        // Borrow Asset equivalent of 1,000,000,000 in USD
        requestData.borrowLimit = uint128(uint256(CLConstants.maxBorrowLimit / 1e6).mul(_ratioOfPrices).div(10**_decimals));
        requestData.borrowRate = CLConstants.maxBorrowRate / 1e12;
        requestData.autoLiquidation = false;
        requestData.collateralRatio = CLConstants.maxCollteralRatio / 1e18;
        requestData.borrowAsset = address(borrowAsset);
        requestData.borrowAssetStrategy = noYieldAddress;
        requestData.collateralAsset = address(collateralAsset);
        requestData.collateralStrategy = noYieldAddress;
        requestData.requestAsLender = false;

        protocolFee = creditLine.protocolFeeFraction();

        admin.updateBorrowLimitLimits(0, type(uint256).max, address(creditLine));
        admin.updateIdealCollateralRatioLimits(0, type(uint256).max, address(creditLine));
        admin.updateBorrowRateLimits(0, type(uint256).max, address(creditLine));
    }

    // Borrow Limit = 0

    // Depositing collateral into creditline should pass with correct parameters
    function test_creditLineDeposit_BL0(uint128 _amount) public {
        uint256 amount = scaleToRange256(_amount, 1, collateralAsset.totalSupply());
        requestData.borrowLimit = 0;
        creditLineId = goToActiveStage();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);
    }

    // Cannot borrow anything if Borrow Limit is set to 0
    function test_BorrowFromCreditLine_BL0(uint128 _borrowAmount) public {
        uint256 collateralAmount = 100 * 10**(ERC20(address(collateralAsset)).decimals());
        uint256 borrowAmount = scaleToRange256(_borrowAmount, 1, borrowAsset.totalSupply());
        requestData.borrowLimit = 0;
        creditLineId = goToActiveStage();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), collateralAmount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), collateralAmount);

        borrower.addCollateral(address(creditLine), creditLineId, collateralAmount, false);

        uint256 borrowableAmount = creditLine.calculateBorrowableAmount(creditLineId);
        assertEq(borrowableAmount, 0);
        // Since borrowableAmount = 0, cannot borrow anything from the credit line

        // Adding tokens to lender and depositing to lender's savings Account
        assert_creditLineLend(address(lender), address(borrowAsset), borrowAmount);

        // Borrowing non-zero amount when borrowable = 0
        try borrower.borrow(address(creditLine), creditLineId, borrowAmount) {
            revert('REVERT: Borrowing more than allowed');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:B2');
        }

        // Borrowing borrowable amount (amount = 0)
        try borrower.borrow(address(creditLine), creditLineId, borrowableAmount) {
            revert('REVERT: Borrowing zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:B1');
        }
    }

    // Can withdraw the entire amount deposited as borrow is not possible
    function test_WithdrawAllCollateral_BL0(uint128 _amount) public {
        uint256 amount = scaleToRange256(_amount, 1, collateralAsset.totalSupply());
        requestData.borrowLimit = 0;
        creditLineId = goToActiveStage();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 balanceBorrower = collateralAsset.balanceOf(address(borrower));
        borrower.withdrawAllCollateral(creditLineAddress, creditLineId, false);
        uint256 balanceBorrowerAfter = collateralAsset.balanceOf(address(borrower));

        assertApproxEqAbs(balanceBorrowerAfter.sub(balanceBorrower), amount, 2);
    }

    // Can withdraw the entire amount deposited as borrow is not possible
    function test_WithdrawCollateral_BL0(uint128 _amount) public {
        uint256 amount = scaleToRange256(_amount, 1, collateralAsset.totalSupply());
        requestData.borrowLimit = 0;
        creditLineId = goToActiveStage();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 balanceBorrower = collateralAsset.balanceOf(address(borrower));
        try borrower.withdrawCollateral(creditLineAddress, creditLineId, amount, false) {
            uint256 balanceBorrowerAfter = collateralAsset.balanceOf(address(borrower));

            assertEq(balanceBorrowerAfter.sub(balanceBorrower), amount);
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:WC3');
        }
    }

    // Should be able to close credit line
    function test_CloseCreditLine_BL0() public {
        uint256 amount = 100 * 10**(ERC20(address(collateralAsset)).decimals());
        requestData.borrowLimit = 0;
        creditLineId = goToActiveStage();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        // Closing the credit line
        uint256 balanceBorrower = collateralAsset.balanceOf(address(borrower));
        borrower.close(creditLineAddress, creditLineId);
        uint256 balanceBorrowerAfter = collateralAsset.balanceOf(address(borrower));

        assertApproxEqAbs(balanceBorrowerAfter.sub(balanceBorrower), amount, 2);

        uint256 _status = uint256(creditLine.getCreditLineStatus(creditLineId));
        assertEq(_status, 0); // status should revert to NOT_CREATED
    }

    // Should be able to withdraw all collateral and then close the credit line
    function test_WithdrawAndCloseCreditLine_BL0() public {
        uint256 amount = 100 * 10**(ERC20(address(collateralAsset)).decimals());
        requestData.borrowLimit = 0;
        creditLineId = goToActiveStage();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        // withdraw collateral from credit line
        uint256 balanceBorrower = collateralAsset.balanceOf(address(borrower));
        try borrower.withdrawCollateral(creditLineAddress, creditLineId, amount, false) {
            uint256 balanceBorrowerAfter = collateralAsset.balanceOf(address(borrower));

            assertEq(balanceBorrowerAfter.sub(balanceBorrower), amount);

            // close credit line
            borrower.close(creditLineAddress, creditLineId);
            uint256 _status = uint256(creditLine.getCreditLineStatus(creditLineId));
            assertEq(_status, 0); // status should revert to NOT_CREATED
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:WC3');
        }
    }

    // Should be able to withdraw all collateral and then close the credit line
    function test_WithdrawAndCloseCreditLine1_BL0() public {
        uint256 amount = 100 * 10**(ERC20(address(collateralAsset)).decimals());
        requestData.borrowLimit = 0;
        creditLineId = goToActiveStage();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        // withdraw collateral from credit line
        uint256 balanceBorrower = collateralAsset.balanceOf(address(borrower));
        borrower.withdrawAllCollateral(creditLineAddress, creditLineId, false);
        uint256 balanceBorrowerAfter = collateralAsset.balanceOf(address(borrower));

        assertApproxEqAbs(balanceBorrowerAfter.sub(balanceBorrower), amount, 2);

        // close credit line
        borrower.close(creditLineAddress, creditLineId);
        uint256 _status = uint256(creditLine.getCreditLineStatus(creditLineId));
        assertEq(_status, 0); // status should revert to NOT_CREATED
    }

    // Collateral ratio = 0

    // Depositing collateral into creditline should pass with correct parameters
    function test_creditLineDeposit_CR0(uint128 _amount) public {
        uint256 amount = scaleToRange256(_amount, 1, collateralAsset.totalSupply());
        requestData.collateralRatio = 0;
        creditLineId = goToActiveStage();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);
    }

    function assert_creditLineDeposit(uint256 _creditLineId, uint256 _amount) public {
        collateralStrategy = requestData.collateralStrategy;
        // assert the received shares and deposited amount equivalent shares are equal
        uint256 sharesReceived = creditLine.collateralShareInStrategy(_creditLineId);
        uint256 sharesOfAmount = IYield(collateralStrategy).getSharesForTokens(_amount, address(collateralAsset));

        assertEq(sharesReceived, sharesOfAmount);
    }

    function assert_creditLineLend(
        address _user,
        address _asset,
        uint256 _amount
    ) public {
        borrowAssetStrategy = requestData.borrowAssetStrategy;
        uint256 userBalanceSABefore = savingsAccount.balanceInShares(_user, _asset, borrowAssetStrategy);

        savingsAccount_depositHelper(_user, _asset, borrowAssetStrategy, _amount);

        uint256 userBalanceSA = savingsAccount.balanceInShares(_user, _asset, borrowAssetStrategy);
        uint256 sharesOfAmount = IYield(borrowAssetStrategy).getSharesForTokens(_amount, _asset);
        assertEq(userBalanceSA.sub(userBalanceSABefore), sharesOfAmount);
    }

    function test_BorrowFromCreditLine_CR0(uint128 _borrowAmount) public {
        uint256 amount = 100 * 10**(ERC20(address(collateralAsset)).decimals());
        borrowAssetStrategy = requestData.borrowAssetStrategy;
        requestData.collateralRatio = 0;
        creditLineId = goToActiveStage();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        // For CR=0, borrowable amount = borrowLimit
        uint256 borrowableAmount = creditLine.calculateBorrowableAmount(creditLineId);
        assertEq(borrowableAmount, requestData.borrowLimit);
        uint256 borrowAmount = scaleToRange256(_borrowAmount, 1, borrowableAmount);

        // Adding tokens to lender and depositing to lender's savings Account
        assert_creditLineLend(address(lender), address(borrowAsset), borrowAmount);

        borrower.borrow(address(creditLine), creditLineId, borrowAmount);
        uint256 borrowShares = IYield(borrowAssetStrategy).getSharesForTokens(borrowAmount, address(borrowAsset));
        assert_creditLineBorrow(creditLineId, borrowShares);
    }

    function assert_creditLineBorrow(uint256 _creditLineId, uint256 _borrowShares) public {
        borrowAssetStrategy = requestData.borrowAssetStrategy;
        uint256 _borrowAmount = IYield(borrowAssetStrategy).getTokensForShares(_borrowShares, address(borrowAsset));
        // Checking balances
        uint256 protocolFeeAmount = _borrowAmount.mul(protocolFee).div(SCALING_FACTOR);
        uint256 expectedAmount = _borrowAmount.sub(protocolFeeAmount);

        uint256 borrowerBalance = borrowAsset.balanceOf(address(borrower));
        assertEq(expectedAmount, borrowerBalance);

        uint256 lenderBalanceSA = savingsAccount.balanceInShares(address(lender), address(borrowAsset), borrowAssetStrategy);
        assertEq(lenderBalanceSA, 0);

        uint256 feeCollectorBalance = borrowAsset.balanceOf(protocolFeeCollectorAddress);
        assertEq(feeCollectorBalance, protocolFeeAmount);

        // Variable updates
        (, uint256 principal, , uint256 lastPrincipalUpdateTime, ) = creditLine.creditLineVariables(_creditLineId);

        assertEq(principal, _borrowAmount);
        assertEq(lastPrincipalUpdateTime, block.timestamp);
    }

    function test_WithdrawCollateral_CR0(uint128 _amount) public {
        uint256 amount = scaleToRange256(_amount, 1, collateralAsset.totalSupply());
        requestData.collateralRatio = 0;
        creditLineId = goToActiveStage();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        // Adding tokens to lender and depositing to lender's savings Account
        assert_creditLineLend(address(lender), address(borrowAsset), requestData.borrowLimit);

        // For CR=0, borrowable amount = borrowLimit
        borrower.borrow(address(creditLine), creditLineId, requestData.borrowLimit);
        uint256 borrowShares = IYield(borrowAssetStrategy).getSharesForTokens(requestData.borrowLimit, address(borrowAsset));
        assert_creditLineBorrow(creditLineId, borrowShares);

        uint256 balanceBorrower = collateralAsset.balanceOf(address(borrower));
        try borrower.withdrawCollateral(creditLineAddress, creditLineId, amount, false) {
            uint256 balanceBorrowerAfter = collateralAsset.balanceOf(address(borrower));

            assertEq(balanceBorrowerAfter.sub(balanceBorrower), amount);

            (, uint256 principal, , , ) = creditLine.creditLineVariables(creditLineId);
            assertEq(principal, requestData.borrowLimit);
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:WC3');
        }
    }

    function test_BorrowWithoutCollateralDeposit_CR0() public {
        requestData.collateralRatio = 0;
        creditLineId = goToActiveStage();

        // Adding tokens to lender and depositing to lender's savings Account
        assert_creditLineLend(address(lender), address(borrowAsset), requestData.borrowLimit);

        // For CR=0, borrowable amount = borrowLimit
        borrower.borrow(address(creditLine), creditLineId, requestData.borrowLimit);
        uint256 borrowShares = IYield(borrowAssetStrategy).getSharesForTokens(requestData.borrowLimit, address(borrowAsset));
        assert_creditLineBorrow(creditLineId, borrowShares);
    }

    // Borrower should not be able to liquidate credit line if CR=0
    function test_BorowAndLiquidateCreditLine_CR0_borrower() public {
        requestData.collateralRatio = 0;
        requestData.autoLiquidation = true;
        creditLineId = goToActiveStage();

        // Adding tokens to lender and depositing to lender's savings Account
        assert_creditLineLend(address(lender), address(borrowAsset), requestData.borrowLimit);

        // For CR=0, borrowable amount = borrowLimit
        borrower.borrow(address(creditLine), creditLineId, requestData.borrowLimit);
        uint256 borrowShares = IYield(borrowAssetStrategy).getSharesForTokens(requestData.borrowLimit, address(borrowAsset));
        assert_creditLineBorrow(creditLineId, borrowShares);

        try borrower.liquidate(creditLineAddress, creditLineId, false) {
            revert('REVERT: Should not be able to liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:L3');
        }
    }

    // Liquidator should not be able to liquidate credit line if CR=0
    function test_BorowAndLiquidateCreditLine_CR0_liquidator() public {
        requestData.collateralRatio = 0;
        requestData.autoLiquidation = true;
        creditLineId = goToActiveStage();

        // Adding tokens to lender and depositing to lender's savings Account
        assert_creditLineLend(address(lender), address(borrowAsset), requestData.borrowLimit);

        // For CR=0, borrowable amount = borrowLimit
        borrower.borrow(address(creditLine), creditLineId, requestData.borrowLimit);
        uint256 borrowShares = IYield(borrowAssetStrategy).getSharesForTokens(requestData.borrowLimit, address(borrowAsset));
        assert_creditLineBorrow(creditLineId, borrowShares);

        try liquidator.liquidate(creditLineAddress, creditLineId, false) {
            revert('REVERT: Should not be able to liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:L3');
        }
    }

    // Lender should be able to liquidate credit line if CR=0
    function test_BorowAndLiquidateCreditLine_CR0_lender() public {
        requestData.collateralRatio = 0;
        creditLineId = goToActiveStage();

        // Adding tokens to lender and depositing to lender's savings Account
        assert_creditLineLend(address(lender), address(borrowAsset), requestData.borrowLimit);

        // For CR=0, borrowable amount = borrowLimit
        borrower.borrow(address(creditLine), creditLineId, requestData.borrowLimit);
        uint256 borrowShares = IYield(borrowAssetStrategy).getSharesForTokens(requestData.borrowLimit, address(borrowAsset));
        assert_creditLineBorrow(creditLineId, borrowShares);

        uint256 currentBalance = collateralAsset.balanceOf(address(lender));
        lender.liquidate(creditLineAddress, creditLineId, false);
        uint256 balanceAfter = collateralAsset.balanceOf(address(lender));
        assertEq(balanceAfter.sub(currentBalance), 0);
    }

    // Borrow Rate = 0

    // Depositing collateral into creditline should pass with correct parameters
    function test_creditLineDeposit_BR0(uint128 _amount) public {
        uint256 amount = scaleToRange256(_amount, 1, collateralAsset.totalSupply());
        requestData.borrowRate = 0;
        creditLineId = goToActiveStage();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);
    }

    // Borrowing from credit line should pass
    function test_BorrowFromCreditLine_BR0(uint256 _borrowAmount) public {
        requestData.borrowRate = 0;
        creditLineId = goToActiveStage();

        uint256 amount = 10_000 * 10**(ERC20(address(collateralAsset)).decimals());

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        uint256 borrowableAmount = creditLine.calculateBorrowableAmount(creditLineId);

        uint256 borrowAmount = scaleToRange256(_borrowAmount, 1, borrowableAmount);

        // Adding tokens to lender and depositing to lender's savings Account
        assert_creditLineLend(address(lender), address(borrowAsset), borrowAmount);

        borrower.borrow(address(creditLine), creditLineId, borrowAmount);
        uint256 borrowShares = IYield(borrowAssetStrategy).getSharesForTokens(borrowAmount, address(borrowAsset));
        assert_creditLineBorrow(creditLineId, borrowShares);
    }

    // Repaying a credit line should pass
    // No interest is accrued and only principal is repaid
    function test_RepayCreditLine_BR0() public {
        requestData.borrowRate = 0;
        creditLineId = goToActiveStage();

        uint256 amount = 10_000 * 10**(ERC20(address(collateralAsset)).decimals());

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        uint256 borrowableAmount = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        assert_creditLineLend(address(lender), address(borrowAsset), borrowableAmount);

        borrower.borrow(address(creditLine), creditLineId, borrowableAmount);

        // Time travel by 10 days
        _increaseBlock(block.timestamp + 10 days);

        // Calculating interest accrued
        uint256 interest = creditLine.calculateInterestAccrued(creditLineId);
        uint256 currentDebt = creditLine.calculateCurrentDebt(creditLineId);

        assertEq(interest, 0);
        assertApproxEqRel(currentDebt, borrowableAmount, 1e14);

        // add balance to borrower
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(creditLine), address(borrowAsset), currentDebt);

        // Repaying total debt
        borrower.repay(address(creditLine), creditLineId, currentDebt);
        borrower.close(address(creditLine), creditLineId);
        status = uint256(creditLine.getCreditLineStatus(creditLineId));
        assertEq(status, 0);
    }

    // updateBorrowLimit, attack scenarios

    // lender can update borrow limit and accept based on the new limit
    function test_updateBorrowLimit_Requested(uint128 _newBorrowLimit) public {
        creditLineId = borrower.createRequest(creditLineAddress, requestData);

        try lender.updateBorrowLimit(creditLineAddress, creditLineId, _newBorrowLimit) {
            lender.acceptRequest(creditLineAddress, creditLineId);
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:ILB1');
        }
    }

    // lender should be able to update borrow limit after borrower has borrowed (borrow limit borrowed)
    // Further borrowing should not be possible
    function test_updateBorrowLimit_Borrowed(uint128 _newBorrowLimit) public {
        creditLineId = goToActiveStage();

        // add collateral to credit line
        uint256 amount = 10_000 * 10**(ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        // borrower borrows amount = borrow limit
        assert_creditLineLend(address(lender), address(borrowAsset), requestData.borrowLimit);

        borrower.borrow(address(creditLine), creditLineId, requestData.borrowLimit);
        uint256 borrowShares = IYield(borrowAssetStrategy).getSharesForTokens(requestData.borrowLimit, address(borrowAsset));
        assert_creditLineBorrow(creditLineId, borrowShares);

        // updating borrow limit to lt older borrow limit after borrower has borrowed borrow limit amount
        (uint256 _ratioOfPrices, uint256 _decimals) = priceOracle.getLatestPrice(address(usdc), address(borrowAsset));
        uint128 newLimitForBorrowLimit = uint128(uint256(CLConstants.maxBorrowLimit / 1e7).mul(_ratioOfPrices).div(10**_decimals));
        uint128 newBorrowLimit = scaleToRange128(_newBorrowLimit, 1, newLimitForBorrowLimit);

        try lender.updateBorrowLimit(creditLineAddress, creditLineId, newBorrowLimit) {
            getCreditlineConstants(creditLineId);
            assertEq(constantsCheck.borrowLimit, newBorrowLimit);
            try creditLine.calculateBorrowableAmount(creditLineId) {
                revert('Should revert as principal>borrowLimit');
            } catch Error(string memory reason) {
                assertEq(reason, 'SafeMath: subtraction overflow');
            }
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:ILB1');
        }
    }
}",5759
RealWorld_TA_101_IPoolFactory_RealWorld_20240812182317.log,101,IPoolFactory,123825,1628,125453,82.0,0.651685,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface IPoolFactory {
    /**
     * @notice emitted when a Pool is created
     * @param pool the address of the Pool
     * @param borrower the address of the borrower who created the pool
     */
    event PoolCreated(address indexed pool, address indexed borrower);

    /**
     * @notice emitted when the init function definition Pool.sol logic is updated
     * @param updatedSelector the new init function definition for the Pool logic contract
     */
    event PoolInitSelectorUpdated(bytes4 updatedSelector);

    /**
     * @notice emitted when the Pool.sol logic is updated
     * @param updatedPoolLogic the address of the new Pool logic contract
     */
    event PoolLogicUpdated(address indexed updatedPoolLogic);

    /**
     * @notice emitted when the user registry is updated
     * @param updatedBorrowerRegistry address of the contract storing the user registry
     */
    event UserRegistryUpdated(address indexed updatedBorrowerRegistry);

    /**
     * @notice emitted when the strategy registry is updated
     * @param updatedStrategyRegistry address of the contract storing the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed updatedStrategyRegistry);

    /**
     * @notice emitted when the Repayments.sol logic is updated
     * @param updatedRepaymentImpl the address of the new implementation of the Repayments logic
     */
    event RepaymentImplUpdated(address indexed updatedRepaymentImpl);

    /**
     * @notice emitted when the PriceOracle.sol is updated
     * @param updatedPriceOracle address of the new implementation of the PriceOracle
     */
    event PriceOracleUpdated(address indexed updatedPriceOracle);

    /**
     * @notice emitted when the SavingsAccount.sol is updated
     * @param savingsAccount address of the new implementation of the SavingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when the collection period parameter for Pools is updated
     * @param updatedCollectionPeriod the new value of the collection period for Pools
     */
    event CollectionPeriodUpdated(uint256 updatedCollectionPeriod);

    /**
     * @notice emitted when the loan withdrawal parameter for Pools is updated
     * @param updatedLoanWithdrawalDuration the new value of the loan withdrawal period for Pools
     */
    event LoanWithdrawalDurationUpdated(uint256 updatedLoanWithdrawalDuration);

    /**
     * @notice emitted when the marginCallDuration variable is updated
     * @param updatedMarginCallDuration Duration (in seconds) for which a margin call is active
     */
    event MarginCallDurationUpdated(uint256 updatedMarginCallDuration);

    /**
     * @notice emitted when miBorrowFraction variable is updated
     * @param updatedMinBorrowFraction Updated value of miBorrowFraction
     */
    event MinBorrowFractionUpdated(uint256 updatedMinBorrowFraction);

    /**
     * @notice emitted when liquidatorRewardFraction variable is updated
     * @param updatedLiquidatorRewardFraction updated value of liquidatorRewardFraction
     */
    event LiquidatorRewardFractionUpdated(uint256 updatedLiquidatorRewardFraction);

    /**
     * @notice emitted when poolCancelPenaltyMultiple variable is updated
     * @param updatedPoolCancelPenaltyMultiple updated value of poolCancelPenaltyMultiple
     */
    event PoolCancelPenaltyMultipleUpdated(uint256 updatedPoolCancelPenaltyMultiple);

    /**
     * @notice emitted when fee that protocol changes for pools is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address updatedProtocolFeeCollector);

    /**
     * @notice emitted when threhsolds for one of the parameters (poolSizeLimit, collateralRatioLimit, borrowRateLimit, repaymentIntervalLimit, noOfRepaymentIntervalsLimit) is updated
     * @param limitType specifies the parameter whose limits are being updated
     * @param max maximum threshold value for limitType
     * @param min minimum threshold value for limitType
     */
    event LimitsUpdated(string indexed limitType, uint256 max, uint256 min);

    /**
     * @notice emitted when the list of supported borrow assets is updated
     * @param borrowToken address of the borrow asset
     * @param isSupported true if borrowToken is a valid borrow asset, false if borrowToken is an invalid borrow asset
     */
    event BorrowTokenUpdated(address indexed borrowToken, bool isSupported);

    /**
     * @notice emitted when the list of supported collateral assets is updated
     * @param collateralToken address of the collateral asset
     * @param isSupported true if collateralToken is a valid collateral asset, false if collateralToken is an invalid collateral asset
     */
    event CollateralTokenUpdated(address indexed collateralToken, bool isSupported);

    /**
     * @notice emitted when no strategy address in the pool is updated
     * @param noStrategy address of noYield contract
     */
    event NoStrategyUpdated(address noStrategy);

    function savingsAccount() external view returns (address);

    function owner() external view returns (address);

    function poolRegistry(address pool) external view returns (uint256);

    function priceOracle() external view returns (address);

    function repaymentImpl() external view returns (address);

    function userRegistry() external view returns (address);

    function collectionPeriod() external view returns (uint256);

    function loanWithdrawalDuration() external view returns (uint256);

    function marginCallDuration() external view returns (uint256);

    function minBorrowFraction() external view returns (uint256);

    function liquidatorRewardFraction() external view returns (uint256);

    function poolCancelPenaltyMultiple() external view returns (uint256);

    function getProtocolFeeData() external view returns (uint256 protocolFeeFraction, address protocolFeeCollector);

    function noStrategyAddress() external view returns (address);
}",1276
RealWorld_TA_101_PCLExpiredState.t_RealWorld_20240812160115.log,101,PCLExpiredState.t,726050,68,726118,111.0,3.63161,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        // Now we assert that we are in the ACTIVE state
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), 2);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An expired PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralRemainsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateralNew, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 4.2
    function test_withdrawAllCollateralIsPossibleAfterRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 balanceBefore = collateralAsset.balanceOf(address(borrower));
        borrower.withdrawAllCollateral(requestId, false);
        assertGt(collateralAsset.balanceOf(address(borrower)), balanceBefore);
    }

    // Test 5: An expired PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An expired PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);

        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);

        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An expired  PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An expired PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an expired PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An expired PCL cannot be liquidated if principal != 0 but CR >= ICR
    function test_lendersCannotLiquidateIfIdealCollateralRatioIsNotBreached(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Small price fluctuations
        helper_smallPriceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 10.3: An expired PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseCollateralAssetPriceSteeply();
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.4: An expired PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseBorrowAssetPriceSteeply();
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.2: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15: Borrowable amount remains zero
    function test_borrowableAmountRemainsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        assertEq(_borrowableAmount, 0);
    }

    // Test 16: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInExpiredState(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since the state is expired
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionsInExpiredState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInExpiredState(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function helper_decreaseCollateralAssetPriceSteeply() public clearMockedCalls {
        (
            uint80 _assetRoundId,
            int256 _assetPrice,
            uint256 _assetStartedAt,
            uint256 _assetUpdatedAt,
            uint80 _assetAnsweredInRound
        ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        vm.mockCall(
            collateralAssetAggregatorAddress,
            abi.encodeWithSelector(MockV3Aggregator.latestRoundData.selector),
            abi.encode(_assetRoundId, int256(_collateralAssetPriceMin / 2), _assetStartedAt, _assetUpdatedAt, _assetAnsweredInRound)
        );
    }

    function helper_increaseBorrowAssetPriceSteeply() public clearMockedCalls {
        (
            uint80 _assetRoundId,
            int256 _assetPrice,
            uint256 _assetStartedAt,
            uint256 _assetUpdatedAt,
            uint80 _assetAnsweredInRound
        ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();

        vm.mockCall(
            borrowAssetAggregatorAddress,
            abi.encodeWithSelector(MockV3Aggregator.latestRoundData.selector),
            abi.encode(_assetRoundId, int256(_borrowAssetPriceMax * 2), _assetStartedAt, _assetUpdatedAt, _assetAnsweredInRound)
        );
    }
}",8615
RealWorld_TA_101_StrategyRegistry.t_RealWorld_20240812163842.log,101,StrategyRegistry.t,227722,2477,230199,93.0,1.18815,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import 'forge-std/Test.sol';

import '../Constants.sol';
import '../ProtocolFeeCollector.sol';

import '../roles/Admin.sol';
import '../roles/User.sol';

contract StrategyRegistryTests is Test {
    using SafeMath for uint256;

    // Logic implementation contract addresses
    address public savingsAccountAddress;
    address public strategyRegistryAddress;
    address public noYieldAddress;
    address public extraYieldAddress;
    address public extraYieldAddress1;
    address public compoundYieldAddress;
    address public protocolFeeCollectorAddress;

    // Admins for deployements
    Admin public admin;
    Admin public fakeAdmin;

    // Extra actors
    User public borrower;
    User public lender;
    User public liquidator;

    function setUp() public {
        // setting admin addresses
        admin = new Admin();
        fakeAdmin = new Admin();

        // setting extra actors
        borrower = new User();
        lender = new User();
        liquidator = new User();

        // deploying  mock protocol fee collector
        protocolFeeCollectorAddress = address(new ProtocolFeeCollector());
        // deploying strategy registry contract
        strategyRegistryAddress = admin.deployStrategyRegistry(Constants.maxStrategies);
        // deploying savings account contract
        savingsAccountAddress = admin.deploySavingsAccount(strategyRegistryAddress);

        // deploying yield contracts
        noYieldAddress = admin.deployNoYield(address(admin), savingsAccountAddress, protocolFeeCollectorAddress);
        extraYieldAddress = admin.deployNoYield(address(admin), savingsAccountAddress, protocolFeeCollectorAddress);
        extraYieldAddress1 = admin.deployNoYield(address(admin), savingsAccountAddress, protocolFeeCollectorAddress);

        //----------------------- Deployment code end -----------------------//
    }

    // Events
    event StrategyAdded(address indexed strategy);
    event StrategyRemoved(address indexed strategy);
    event MaxStrategiesUpdated(uint256 maxStrategies);

    //----------------------- Strategy Registry updateMaxStrategies, failing tests-----------------------//

    // Updating max strategies to zero should fail
    function test_updateMaxStrategies_zero() public {
        try admin.updateMaxStrategies(strategyRegistryAddress, 0) {
            revert('Updating max strategies to zero should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'SR:IUMS1');
        }
    }

    // Updating max strategies by inalid owner should fail
    function test_updateMaxStrategies_invalidOwner() public {
        try fakeAdmin.updateMaxStrategies(strategyRegistryAddress, 7) {
            revert('Updating max strategies by inalid owner should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    //----------------------- Strategy Registry updateMaxStrategies, passing tests-----------------------//

    // Updating maximum strategies should pass
    function test_updateMaxStrategies(uint256 _maxStrategies) public {
        if (_maxStrategies == 0) {
            return;
        }
        StrategyRegistry _strategyRegistry = StrategyRegistry(strategyRegistryAddress);

        vm.expectEmit(true, true, false, true);
        emit MaxStrategiesUpdated(_maxStrategies);
        admin.updateMaxStrategies(strategyRegistryAddress, _maxStrategies);
        assertEq(_strategyRegistry.maxStrategies(), _maxStrategies);
    }

    //----------------------- Strategy Registry addStrategy, failing tests-----------------------//

    // Adding strategies more than max strategy should fail
    function test_addStrategy_excessStrategies() public {
        admin.updateMaxStrategies(strategyRegistryAddress, 1);

        admin.addSavingsAccountStrategy(strategyRegistryAddress, noYieldAddress);
        try admin.addSavingsAccountStrategy(strategyRegistryAddress, extraYieldAddress) {
            revert('Adding strategies more than max strategies should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'SR:AS1');
        }
    }

    // Adding existing strategy should fail
    function test_addStrategy_existingStrategy() public {
        admin.addSavingsAccountStrategy(strategyRegistryAddress, noYieldAddress);
        try admin.addSavingsAccountStrategy(strategyRegistryAddress, noYieldAddress) {
            revert('Adding existing strategy should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'SR:AS2');
        }
    }

    // Adding zero address strategy should fail
    function test_addStrategy_zeroAddress() public {
        try admin.addSavingsAccountStrategy(strategyRegistryAddress, address(0)) {
            revert('Adding zero address strategy should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'SR:AS3');
        }
    }

    // Adding new strategy by invalid owner should fail
    function test_addStrategy_invalidOwner() public {
        try fakeAdmin.addSavingsAccountStrategy(strategyRegistryAddress, noYieldAddress) {
            revert('Adding new strategy by invalid owner should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    //----------------------- Strategy Registry addStrategy, passing tests-----------------------//

    // Adding new strategies should pass
    function test_addStrategy() public {
        StrategyRegistry _strategyRegistry = StrategyRegistry(strategyRegistryAddress);

        // Adding new strategy
        vm.expectEmit(true, true, false, true);
        emit StrategyAdded(noYieldAddress);
        admin.addSavingsAccountStrategy(strategyRegistryAddress, noYieldAddress);

        // new strategy checks
        assertEq(_strategyRegistry.registry(noYieldAddress), 1);
        assertEq(_strategyRegistry.strategies(0), noYieldAddress);

        // Adding new strategy
        vm.expectEmit(true, true, false, true);
        emit StrategyAdded(extraYieldAddress);
        admin.addSavingsAccountStrategy(strategyRegistryAddress, extraYieldAddress);

        // new strategy checks
        assertEq(_strategyRegistry.registry(extraYieldAddress), 1);
        assertEq(_strategyRegistry.strategies(1), extraYieldAddress);
    }

    //----------------------- Strategy Registry removeStrategy, failing tests-----------------------//

    // Removing invalid strategy address should fail
    function test_removeStrategy_invalidStrategy() public {
        test_addStrategy();
        try admin.removeStrategy(strategyRegistryAddress, 1, noYieldAddress) {
            revert('Removing invalid strategy address should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'SR:RS1');
        }
    }

    // Removing strategy by invalid owner should fail
    function test_removeStrategy_invalidOwner() public {
        test_addStrategy();
        try fakeAdmin.removeStrategy(strategyRegistryAddress, 1, extraYieldAddress) {
            revert('Removing strategy by invalid owner should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    //----------------------- Strategy Registry removeStrategy, passing tests-----------------------//

    // Removing strategy should pass
    function test_removeStrategy_lastIndex() public {
        test_addStrategy();
        StrategyRegistry _strategyRegistry = StrategyRegistry(strategyRegistryAddress);

        // Removing strategies
        vm.expectEmit(true, true, false, true);
        emit StrategyRemoved(extraYieldAddress);
        admin.removeStrategy(strategyRegistryAddress, 1, extraYieldAddress);

        // Removed strategy checks
        assertEq(_strategyRegistry.registry(extraYieldAddress), 0);
        assertEq(_strategyRegistry.retiredRegistry(extraYieldAddress), 1);
    }

    // Removing strategy should pass
    function test_removeStrategy_randomIndex() public {
        test_addStrategy();
        StrategyRegistry _strategyRegistry = StrategyRegistry(strategyRegistryAddress);

        // Removing strategies
        vm.expectEmit(true, true, false, true);
        emit StrategyRemoved(noYieldAddress);
        admin.removeStrategy(strategyRegistryAddress, 0, noYieldAddress);

        // Removed strategy checks
        assertEq(_strategyRegistry.registry(noYieldAddress), 0);
        assertEq(_strategyRegistry.retiredRegistry(noYieldAddress), 1);
    }

    //----------------------- Strategy Registry updateStrategy, failing tests-----------------------//

    // Updating strategy with invalid index should fail
    function test_updateStrategy_invalidIndex() public {
        test_addStrategy();
        try admin.updateStrategy(strategyRegistryAddress, 2, extraYieldAddress, extraYieldAddress1) {
            revert('Updating strategy with invalid index should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'SR:US1');
        }
    }

    // Updating strategy with invalid old strategy should fail
    function test_updateStrategy_invalidOldStrategy() public {
        test_addStrategy();
        try admin.updateStrategy(strategyRegistryAddress, 1, extraYieldAddress1, extraYieldAddress1) {
            revert('Updating strategy with invalid old strategy should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'SR:US2');
        }
    }

    // Updating strategy with zero address new strategy should fail
    function test_updateStrategy_zeroNewStrategy() public {
        test_addStrategy();
        try admin.updateStrategy(strategyRegistryAddress, 1, extraYieldAddress, address(0)) {
            revert('Updating strategy with zero address new strategy should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'SR:US3');
        }
    }

    // Updating strategy with invalid new strategy should fail
    function test_updateStrategy_invalidNewStrategy() public {
        test_addStrategy();
        try admin.updateStrategy(strategyRegistryAddress, 1, extraYieldAddress, noYieldAddress) {
            revert('Updating strategy with invalid new strategy should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'SR:US4');
        }
    }

    // Updating strategy by invalid owner should fail
    function test_updateStrategy_invalidOwner() public {
        test_addStrategy();
        try fakeAdmin.updateStrategy(strategyRegistryAddress, 1, extraYieldAddress, extraYieldAddress1) {
            revert('Updating strategy by invalid owner should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    //----------------------- Strategy Registry updateStrategy, passing tests-----------------------//

    // Updating strategy should pass
    function test_updateStrategy() public {
        test_addStrategy();
        StrategyRegistry _strategyRegistry = StrategyRegistry(strategyRegistryAddress);

        // Updating strategy
        vm.expectEmit(true, true, false, true);
        emit StrategyRemoved(extraYieldAddress);
        vm.expectEmit(true, true, false, true);
        emit StrategyAdded(extraYieldAddress1);
        admin.updateStrategy(strategyRegistryAddress, 1, extraYieldAddress, extraYieldAddress1);

        // Old strategy checks
        assertEq(_strategyRegistry.registry(extraYieldAddress), 0);
        assertEq(_strategyRegistry.retiredRegistry(extraYieldAddress), 1);

        // New strategy checks
        assertEq(_strategyRegistry.registry(extraYieldAddress1), 1);
        assertEq(_strategyRegistry.strategies(1), extraYieldAddress1);
    }

    //----------------------- Strategy Registry util functions-----------------------//

    // Getting list of strategies should pass
    function test_getStrategies() public {
        test_addStrategy();
        StrategyRegistry _strategyRegistry = StrategyRegistry(strategyRegistryAddress);

        // Getting list of strategies
        address[] memory _strategies = _strategyRegistry.getStrategies();

        // Strategy list checks
        assertEq(_strategies[0], noYieldAddress);
        assertEq(_strategies[1], extraYieldAddress);
    }

    // Checking validity of strategeis should pass
    function test_isValidStrategy() public {
        test_addStrategy();
        StrategyRegistry _strategyRegistry = StrategyRegistry(strategyRegistryAddress);

        // Checking strategy validity (For valid strategy)
        bool isValid = _strategyRegistry.isValidStrategy(noYieldAddress);
        assertTrue(isValid);

        // Checking strategy validity (For valid strategy)
        isValid = _strategyRegistry.isValidStrategy(extraYieldAddress);
        assertTrue(isValid);

        // Checking strategy validity (For invalid strategy)
        isValid = _strategyRegistry.isValidStrategy(extraYieldAddress1);
        assertTrue(!isValid);
    }
}",2568
RealWorld_TA_101_SavingsAccountEthUtils_RealWorld_20240812172524.log,101,SavingsAccountEthUtils,38601,2260,40861,85.0,0.238205,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '../interfaces/IWETH9.sol';
import '../interfaces/ISavingsAccount.sol';

contract SavingsAccountEthUtils {
    IWETH9 public immutable weth;
    ISavingsAccount public immutable savingsAccount;

    constructor(address _weth, address _savingsAccount) {
        require(_weth != address(0), 'SAEU:C1');
        require(_savingsAccount != address(0), 'SAEU:C2');
        weth = IWETH9(_weth);
        savingsAccount = ISavingsAccount(_savingsAccount);
    }

    function depositEth(address _strategy, address _to) external payable {
        require(msg.value != 0, 'SAEU:DE1');
        _toWETHAndApprove(address(savingsAccount), msg.value);
        savingsAccount.deposit(address(weth), _strategy, _to, msg.value);
    }

    function _toWETHAndApprove(address _address, uint256 _amount) private {
        weth.deposit{value: _amount}();
        weth.approve(_address, _amount);
    }
}",242
RealWorld_TA_101_PCLLifecycleTestWETHUSDC.t_RealWorld_20240812152359.log,101,PCLLifecycleTestWETHUSDC.t,59076,2573,61649,89.0,0.34684,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../interfaces/IPriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';
import './PCLLifecycleTest.t.sol';

contract PCLLifecycleTestWETHUSDC is PCLLifecycleTest {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setCollateralAsset() public override {
        if (isForked) {
            collateralAsset = ERC20(Constants.USDC);
            collateralAssetAggregatorAddress = Constants.USDC_priceFeedChainlink;
            collateralCTokenAddress = Constants.cUSDC;
        } else {
            collateralAsset = new MockToken('CollateralAsset', 'MUSDC', 6, 1e40, address(admin));
            collateralAssetAggregatorAddress = address(new MockV3Aggregator(6, 12876423400));
        }
    }

    function setBorrowAsset() public override {
        if (isForked) {
            borrowAsset = IERC20(Constants.WETH);
            borrowAssetAggregatorAddress = Constants.ETH_priceFeedChainlink;
            borrowCTokenAddress = Constants.cETH;
        } else {
            borrowAsset = new MockToken('BorrowAsset', 'MWETH', 18, 1e40, address(admin));
            borrowAssetAggregatorAddress = address(new MockV3Aggregator(18, 1950405767382174661));
        }
    }

    function setUp() public override {
        super.setUp();
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
    }
}",502
RealWorld_TA_101_adminVerifier_RealWorld_20240812173926.log,101,adminVerifier,153880,4266,158146,122.0,0.85472,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/drafts/EIP712Upgradeable.sol';
import '@openzeppelin/contracts/cryptography/ECDSA.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IVerifier.sol';

contract AdminVerifier is Initializable, IVerifier, OwnableUpgradeable, EIP712Upgradeable {
    //-------------------------------- Constants start --------------------------------/

    /**
     * @notice stores the verification contract instance
     */
    IVerification public immutable VERIFICATION;

    //-------------------------------- Constants end --------------------------------/

    //-------------------------------- Global vars start --------------------------------/

    /**
     * @notice stores the signer address
     */
    address public signerAddress;
    /**
     * @notice time for which signature by signer is valid
     */
    uint256 public signValidity;

    //-------------------------------- Global vars end --------------------------------/

    //-------------------------------- State vars start --------------------------------/

    /**
     * @notice stores the user metadata against their address
     */
    mapping(address => string) public userData;
    // hash of signature is used to ensure one sig can only be used once
    mapping(bytes32 => address) private usedDigests;

    //-------------------------------- State vars end --------------------------------/

    //-------------------------------- Events start --------------------------------/

    /**
     * @notice emitted when Signer address is updated
     * @param signerAddress address of the updated verification contract
     */
    event SignerUpdated(address indexed signerAddress);
    /**
     * @notice emitted when time for which sig is valid is updated
     * @param signValidity time to which validity of sign is updated
     */
    event SignValidityUpdated(uint256 signValidity);

    //-------------------------------- Events end --------------------------------/

    //-------------------------------- Init start --------------------------------/

    /**
     * @notice constructor
     * @dev initializes the immutables
     * @param _verification Verification contract address
     **/
    constructor(address _verification) {
        require(_verification != address(0), 'C1');
        VERIFICATION = IVerification(_verification);
    }

    /// @notice Initializes the variables of the contract
    /// @dev Contract follows proxy pattern and this function is used to initialize the variables for the contract in the proxy
    /// @param _admin Admin of the verification contract who can add verifiers and remove masterAddresses deemed invalid
    /// @param _signerAddress Address of the signer bot verifying users and signing off-chain messages
    /// @param _signValidity time for which signature from a signer is valid
    /// @param _name name of the verifier (used in domain seperator)
    /// @param _version version of the verifier (used in domain seperator)
    function initialize(
        address _admin,
        address _signerAddress,
        uint256 _signValidity,
        string memory _name,
        string memory _version
    ) external initializer {
        super.__Ownable_init();
        super.transferOwnership(_admin);
        _updateSignerAddress(_signerAddress);
        _updateSignValidity(_signValidity);
        __EIP712_init(_name, _version);
    }

    //-------------------------------- Init end --------------------------------/

    //-------------------------------- Register start --------------------------------/

    /**
     * @notice used to register user
     * @dev to register, valid signatures form the signer address are needed.
            this is the only requirement for getting verified
     * @param _v int v
     * @param _r part signed message hash
     * @param _s part signed message hash
     * @param _timestamp timestamp for the signed message
     * @param _userData metadata related to user
     * @param _isMasterLinked should master address be linked to itself
     */

    function registerSelf(
        bool _isMasterLinked,
        uint8 _v,
        bytes32 _r,
        bytes32 _s,
        string memory _userData,
        uint256 _timestamp
    ) external {
        require(bytes(userData[msg.sender]).length == 0, 'AV:RS1');
        require(block.timestamp < _timestamp + signValidity, 'AV:RS2');
        require(bytes(_userData).length != 0, 'AV:RS6');
        bytes32 digest = keccak256(
            abi.encode(
                keccak256('set(string userData,address userAddr,uint256 timestamp)'),
                keccak256(bytes(_userData)),
                msg.sender,
                _timestamp
            )
        );
        require(usedDigests[digest] == address(0), 'AV:RS3');

        bytes32 hash = _hashTypedDataV4(digest);
        address signer = ECDSA.recover(hash, _v, _r, _s);
        require(signer != address(0), 'AV:RS4');
        require(signer == signerAddress, 'AV:RS5');

        VERIFICATION.registerMasterAddress(msg.sender, _isMasterLinked);
        userData[msg.sender] = _userData;
        usedDigests[digest] = msg.sender;
        emit UserRegistered(msg.sender, _isMasterLinked, _userData);
    }

    //-------------------------------- Register end --------------------------------/

    //-------------------------------- Unregister start --------------------------------/

    /**
     * @notice used to unregister self
     * @dev users themselves can unregister themself
     */
    function unregisterSelf() external {
        _unregisterUser(msg.sender);
    }

    /**
     * @notice used to unregister user
     * @dev owners can unregister users
     */
    function unregisterUser(address _user) external onlyOwner {
        _unregisterUser(_user);
    }

    function _unregisterUser(address _user) private {
        string memory _userdata = userData[_user];
        require(bytes(_userdata).length != 0, 'AV:IUU1');
        delete userData[_user];
        VERIFICATION.unregisterMasterAddress(_user, address(this));
        emit UserUnregistered(_user);
    }

    //-------------------------------- Unregister end --------------------------------/

    //-------------------------------- Global var setters start --------------------------------/

    /**
     * @notice used to update signer address
     * @dev only owner can update
     * @param _signerAddress address of the signer to verify addresses
     */
    function updateSignerAddress(address _signerAddress) external onlyOwner {
        _updateSignerAddress(_signerAddress);
    }

    function _updateSignerAddress(address _signerAddress) private {
        require(_signerAddress != signerAddress, 'AV:IUSA1');
        require(_signerAddress != address(0), 'AV:IUSA2');
        signerAddress = _signerAddress;
        emit SignerUpdated(_signerAddress);
    }

    /**
     * @notice used to update time for which sign is valid
     * @dev only owner can update
     * @param _signValidity time for which sign will be valid
     */
    function updateSignValidity(uint256 _signValidity) external onlyOwner {
        _updateSignValidity(_signValidity);
    }

    function _updateSignValidity(uint256 _signValidity) private {
        require(_signValidity != signValidity, 'AV:IUSV1');
        require(_signValidity != 0, 'AV:IUSV2');
        signValidity = _signValidity;
        emit SignValidityUpdated(_signValidity);
    }

    //-------------------------------- Global var setters end --------------------------------/

    /**
     * @notice blacklist a digest
     * @dev only owner can update
     * @param _hash digest hash to be blacklisted
     */
    function blackListDigest(bytes32 _hash) external onlyOwner {
        usedDigests[_hash] = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);
    }
}",1589
RealWorld_TA_101_PCLClosedStage.t_RealWorld_20240812145203.log,101,PCLClosedStage.t,696120,68,696188,112.0,3.48196,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}",8140
RealWorld_TA_101_CreditLine_RealWorld_20240812173255.log,101,CreditLine,934543,588,935131,158.0,4.684475,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../Math.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../interfaces/IStrategyRegistry.sol';
import '../interfaces/ICreditLine.sol';

/**
 * @title Credit Line contract with Methods related to creditLines
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuardUpgradeable, OwnableUpgradeable, ICreditline {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    //-------------------------------- Constants start --------------------------------//

    // number of seconds in an year
    uint256 internal constant YEAR_IN_SECONDS = 365 days;

    // Factor to multiply variables to maintain precision
    uint256 public constant SCALING_FACTOR = 1e18;

    // address of USDC contract
    address immutable USDC;

    /**
     * @notice stores the instance of price oracle contract
     **/
    IPriceOracle public immutable PRICE_ORACLE;

    /**
     * @notice stores the instance of savings account contract
     **/
    ISavingsAccount public immutable SAVINGS_ACCOUNT;

    /**
     * @notice stores the instance of strategy registry contract
     **/
    IStrategyRegistry public immutable STRATEGY_REGISTRY;

    //-------------------------------- Constants end --------------------------------//

    //-------------------------------- Global vars starts --------------------------------//

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by SCALING_FACTOR to maintain precision
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by SCALING_FACTOR to maintain precision
     **/
    uint256 public liquidatorRewardFraction;

    //-------------------------------- Global vars ends --------------------------------//

    //-------------------------------- Variable limits starts --------------------------------//

    /*
     * @notice Used to define limits for the credit line parameters
     * @param min the minimum threshold for the parameter
     * @param max the maximum threshold for the parameter
     */
    struct Limits {
        uint256 min;
        uint256 max;
    }

    /*
     * @notice Used to set the min/max borrow limits for credit lines
     */
    Limits public borrowLimitLimits;

    /*
     * @notice Used to set the min/max collateral ratio for credit lines
     * @dev multiplied by SCALING_FACTOR to maintain precision
     */
    Limits public idealCollateralRatioLimits;

    /*
     * @notice Used to set the min/max borrow rate for credit lines
     * @dev multiplied by SCALING_FACTOR to maintain precision
     */
    Limits public borrowRateLimits;

    //-------------------------------- Variable limits ends --------------------------------//

    //-------------------------------- CreditLine state starts --------------------------------//

    /**
     * @notice Various states a credit line can be in
     */
    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE
    }

    /**
    * @notice Struct to store all the variables for a credit line
    * @param status Represents the status of credit line
    * @param principal total principal borrowed in credit line
    * @param totalInterestRepaid total interest repaid in the credit line
    * @param lastPrincipalUpdateTime timestamp when principal was last updated. Principal is 
                updated on borrow or repay
    * @param interestAccruedTillLastPrincipalUpdate interest accrued till last time principal was updated
     */
    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    /**
    * @notice Struct to store all the constants for a credit line
    * @dev only borrowLimit can be updated by lender
    * @param autoLiquidation if true, anyone can liquidate if collateral ratio is below threshold
    * @param requestByLender if true, lender else borrower created credit line request 
    * @param borrowLimit max amount of borrowAsset that can be borrowed in aggregate at any point
    * @param borrowRate Rate of interest multiplied by SCALING_FACTOR
    * @param idealCollateralRatio ratio of collateral to debt below which collateral is 
                                    liquidated multiplied by SCALING_FACTOR
    * @param lender address of the lender of credit line
    * @param borrower address of the borrower of credit line
    * @param borrowAsset address of asset borrowed in credit line
    * @param collateralAsset address of asset collateralized in credit line
    * @param collateralStrategy address of the strategy into which collateral is deposited
     */
    struct CreditLineConstants {
        bool autoLiquidation;
        bool requestByLender;
        uint128 borrowLimit;
        uint128 borrowRate;
        uint256 idealCollateralRatio;
        address lender;
        address borrower;
        address borrowAsset;
        address borrowAssetStrategy;
        address collateralAsset;
        address collateralStrategy;
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    /**
     * @notice stores the collateral shares in collateral strategy
     * @dev creditLineId => collateralShares
     **/
    mapping(uint256 => uint256) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    //-------------------------------- CreditLine State ends --------------------------------//

    //-------------------------------- Modifiers start --------------------------------//

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id identifier for the credit line
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'CL:OCLB1');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id identifier for the credit line
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'CL:OCLL1');
        _;
    }

    //-------------------------------- Modifiers end --------------------------------//

    //-------------------------------- Events start --------------------------------//

    //--------------------------- Limits event start ---------------------------//

    /**
     * @notice emitted when threhsolds for one of the parameters (borrowLimitLimits, idealCollateralRatioLimits, borrowRateLimits) is updated
     * @param limitType specifies the parameter whose limits are being updated
     * @param max maximum threshold value for limitType
     * @param min minimum threshold value for limitType
     */
    event LimitsUpdated(string indexed limitType, uint256 max, uint256 min);

    //--------------------------- Limits event end ---------------------------//

    //--------------------------- Global variable update events start ---------------------------//

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @dev updatedProtocolFee is scaled by SCALING_FACTOR
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @dev liquidatorRewardFraction is scaled by SCALING_FACTOR
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    //--------------------------- Global variable update events end ---------------------------//

    //--------------------------- CreditLine state events start ---------------------------//

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id identifier for the credit line
     * @param shares amount of shares of collateral deposited
     */
    event CollateralSharesDeposited(uint256 indexed id, uint256 shares);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id identifier for the credit line
     * @param shares amount of shares of collateral withdrawn
     */
    event CollateralSharesWithdrawn(uint256 indexed id, uint256 shares);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id identifier for the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     * @param requestByLender true if lender made request, false if borrower did
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower, bool requestByLender);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id identifier for the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id identifier for the credit line from which tokens are borrowed
     * @param borrowShares amount of shares of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowShares);

    /**
     * @notice emitted when credit line is accepted
     * @param id identifier for the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id identifier for the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id identifier for the credit line
     * @param repayer address of the repayer
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, address indexed repayer, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id identifier for the credit line
     * @param repayer address of the repayer
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, address indexed repayer, uint256 repayAmount);

    /**
     * @notice emitted when credit line is cancelled
     * @param id id of the credit line that was cancelled
     */
    event CreditLineCancelled(uint256 indexed id);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id identifier for the credit line
     * @param closedByLender is true when it is closed by lender
     */
    event CreditLineClosed(uint256 indexed id, bool closedByLender);

    /**
     * @notice emitted when the borrow limit is updated for the credit line
     * @param id identifier for the credit line
     * @param updatedBorrowLimit updated value of borrow limit
     */
    event BorrowLimitUpdated(uint256 indexed id, uint128 updatedBorrowLimit);

    //--------------------------- CreditLine state events end ---------------------------//

    //-------------------------------- Events end --------------------------------//

    //-------------------------------- Limits code starts --------------------------------//

    /**
     * @notice invoked to check if credit lines parameters are within thresholds
     * @dev min or max = 0 is considered as no limit set
     * @param _value supplied value of the parameter
     * @param _min minimum threshold of the parameter
     * @param _max maximum threshold of the parameter
     */
    function isWithinLimits(
        uint256 _value,
        uint256 _min,
        uint256 _max
    ) private pure returns (bool) {
        return (_value >= _min && _value <= _max);
    }

    function _limitBorrowedInUSDC(address _borrowToken, uint256 _borrowLimit) private view {
        (uint256 _ratioOfPrices, uint256 _decimals) = PRICE_ORACLE.getLatestPrice(_borrowToken, USDC);
        uint256 _poolsizeInUSD = _borrowLimit.mul(_ratioOfPrices).div(10**_decimals);
        require(isWithinLimits(_poolsizeInUSD, borrowLimitLimits.min, borrowLimitLimits.max), 'CL:ILB1');
    }

    /**
     * @notice used to update the thresholds of the borrow limit of the credit line
     * @param _min updated value of the minimum threshold value of the borrow limit in lowest units of USDC
     * @param _max updated value of the maximum threshold value of the borrow limit in lowest units of USDC
     */
    function updateBorrowLimitLimits(uint256 _min, uint256 _max) external onlyOwner {
        require(_min <= _max, 'CL:UBLL1');
        require(!(borrowLimitLimits.min == _min && borrowLimitLimits.max == _max), 'CL:UBLL2');
        borrowLimitLimits = Limits(_min, _max);
        emit LimitsUpdated('borrowLimit', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the ideal collateral ratio of the credit line
     * @dev ideal collateral ratio limits are multiplied by SCALING_FACTOR
     * @param _min updated value of the minimum threshold value of the ideal collateral ratio
     * @param _max updated value of the maximum threshold value of the ideal collateral ratio
     */
    function updateIdealCollateralRatioLimits(uint256 _min, uint256 _max) external onlyOwner {
        require(_min <= _max, 'CL:UICRL1');
        require(!(idealCollateralRatioLimits.min == _min && idealCollateralRatioLimits.max == _max), 'CL:UICRL2');
        idealCollateralRatioLimits = Limits(_min, _max);
        emit LimitsUpdated('idealCollateralRatio', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the borrow rate of the credit line
     * @dev borrow rate limits are multiplied by SCALING_FACTOR
     * @param _min updated value of the minimum threshold value of the borrow rate
     * @param _max updated value of the maximum threshold value of the borrow rate
     */
    function updateBorrowRateLimits(uint256 _min, uint256 _max) external onlyOwner {
        require(_min <= _max, 'CL:UBRL1');
        require(!(borrowRateLimits.min == _min && borrowRateLimits.max == _max), 'CL:UBRL2');
        borrowRateLimits = Limits(_min, _max);
        emit LimitsUpdated('borrowRate', _min, _max);
    }

    //-------------------------------- Limits code end --------------------------------//

    //-------------------------------- Global var update code start --------------------------------//

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner. Scaled by SCALING_FACTOR
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        require(protocolFeeFraction != _protocolFee, 'CL:UPFF1');
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) private {
        require(_protocolFee <= SCALING_FACTOR, 'CL:IUPFF1');
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        require(protocolFeeCollector != _protocolFeeCollector, 'CL:UPFC1');
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) private {
        require(_protocolFeeCollector != address(0), 'CL:IUPFC1');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner. Scaled by SCALING_FACTOR
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        require(liquidatorRewardFraction != _rewardFraction, 'CL:ULRF1');
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) private {
        require(_rewardFraction <= SCALING_FACTOR, 'CL:IULRF1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    //-------------------------------- Global var update code end --------------------------------//

    //-------------------------------- Initialize code start --------------------------------//

    /**
     * @notice used to initialize the immutables in contract
     * @param _usdc address of usdc contract
     */
    constructor(
        address _usdc,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry
    ) {
        require(_usdc != address(0), 'CL:CON1');
        USDC = _usdc;

        require(_priceOracle != address(0), 'CL:CON2');
        PRICE_ORACLE = IPriceOracle(_priceOracle);

        require(_savingsAccount != address(0), 'CL:CON3');
        SAVINGS_ACCOUNT = ISavingsAccount(_savingsAccount);

        require(_strategyRegistry != address(0), 'CL:CON4');
        STRATEGY_REGISTRY = IStrategyRegistry(_strategyRegistry);
    }

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol. Scaled by SCALING_FACTOR
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator.
                                        Scaled by SCALING_FACTOR
     */
    function initialize(
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();

        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    //-------------------------------- Initialize code end --------------------------------//

    //-------------------------------- CreditLine creation code start --------------------------------//

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested. Scaled by SCALING_FACTOR
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated.
                                Scaled by SCALING_FACTOR
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */
    function request(
        address _requestTo,
        uint128 _borrowLimit,
        uint128 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _borrowAssetStrategy,
        address _collateralAsset,
        address _collateralStrategy,
        bool _requestAsLender
    ) external nonReentrant returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'CL:R1');
        require(_requestTo != address(0), 'CL:R2');
        require(PRICE_ORACLE.doesFeedExist(_borrowAsset, _collateralAsset), 'CL:R3');
        _limitBorrowedInUSDC(_borrowAsset, _borrowLimit);
        require(isWithinLimits(_borrowRate, borrowRateLimits.min, borrowRateLimits.max), 'CL:R4');
        // collateral ratio = 0 is a special case which is allowed
        if (_collateralRatio != 0) {
            require(isWithinLimits(_collateralRatio, idealCollateralRatioLimits.min, idealCollateralRatioLimits.max), 'CL:R5');
        }
        require(STRATEGY_REGISTRY.registry(_borrowAssetStrategy) != 0, 'CL:R6');
        require(STRATEGY_REGISTRY.registry(_collateralStrategy) != 0, 'CL:R7');
        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        require(_lender != _borrower, 'CL:R8');

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _borrowAssetStrategy,
            _collateralAsset,
            _collateralStrategy,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower, _requestAsLender);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint128 _borrowLimit,
        uint128 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _borrowAssetStrategy,
        address _collateralAsset,
        address _collateralStrategy,
        bool _requestByLender
    ) private returns (uint256) {
        uint256 _id = ++creditLineCounter;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].borrowAssetStrategy = _borrowAssetStrategy;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].collateralStrategy = _collateralStrategy;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(creditLineVariables[_id].status == CreditLineStatus.REQUESTED, 'CL:A1');
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            _requestByLender ? (msg.sender == creditLineConstants[_id].borrower) : (msg.sender == creditLineConstants[_id].lender),
            'CL:A2'
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    //-------------------------------- CreditLine creation code end --------------------------------//

    //-------------------------------- Collateral management start --------------------------------//

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external override nonReentrant {
        require(_amount != 0, 'CL:DC1');
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CL:DC2');
        require(creditLineConstants[_id].lender != msg.sender, 'CL:DC3');

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _strategy = creditLineConstants[_id].collateralStrategy;
        uint256 _sharesDeposited;

        if (_fromSavingsAccount) {
            _sharesDeposited = SAVINGS_ACCOUNT.transferFrom(_collateralAsset, _strategy, msg.sender, address(this), _amount);
        } else {
            IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
            IERC20(_collateralAsset).safeApprove(_strategy, _amount);

            _sharesDeposited = SAVINGS_ACCOUNT.deposit(_collateralAsset, _strategy, address(this), _amount);
        }
        collateralShareInStrategy[_id] = collateralShareInStrategy[_id].add(_sharesDeposited);

        emit CollateralSharesDeposited(_id, _sharesDeposited);
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        require(_amount != 0, 'CL:WC1');
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CL:WC2');
        uint256 _currentWithdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _currentWithdrawableCollateral, 'CL:WC3');
        uint256 _amountInShares = _transferCollateral(
            _id,
            creditLineConstants[_id].collateralAsset,
            msg.sender,
            _amount,
            _toSavingsAccount
        );
        emit CollateralSharesWithdrawn(_id, _amountInShares);
    }

    /**
     * @notice used to withdraw all the permissible collateral as per the current col ratio
     * @dev if the withdrawable collateral amount is non-zero the transaction will pass
     * @param _id identifier for the credit line
    * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawAllCollateral(uint256 _id, bool _toSavingsAccount) external nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CL:WAC1');
        _withdrawAllCollateral(_id, msg.sender, _toSavingsAccount);
    }

    function _withdrawAllCollateral(
        uint256 _id,
        address _to,
        bool _toSavingsAccount
    ) private {
        uint256 _currentWithdrawableCollateral = withdrawableCollateral(_id);
        if (_currentWithdrawableCollateral != 0) {
            uint256 _amountInShares = _transferCollateral(
                _id,
                creditLineConstants[_id].collateralAsset,
                _to,
                _currentWithdrawableCollateral,
                _toSavingsAccount
            );
            emit CollateralSharesWithdrawn(_id, _amountInShares);
        }
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        uint256 _ratioOfPrices;
        uint256 _decimals;
        uint256 _totalCollateralTokens;
        {
            // avoids stack too deep by restricting scope of _collateralAsset
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            _totalCollateralTokens = _calculateTotalCollateralTokens(_id, _collateralAsset);

            (_ratioOfPrices, _decimals) = PRICE_ORACLE.getLatestPrice(_collateralAsset, creditLineConstants[_id].borrowAsset);
        }
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .mul(10**_decimals)
            .div(_ratioOfPrices)
            .div(SCALING_FACTOR);

        if (_collateralNeeded >= _totalCollateralTokens) return 0;

        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        address _to,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) private returns (uint256) {
        address _strategy = creditLineConstants[_id].collateralStrategy;
        uint256 _amountInShares = IYield(_strategy).getSharesForTokens(_amountInTokens, _asset);
        if (_amountInShares == 0) return 0;

        collateralShareInStrategy[_id] = collateralShareInStrategy[_id].sub(_amountInShares);

        if (_toSavingsAccount) {
            SAVINGS_ACCOUNT.transferShares(_asset, _strategy, _to, _amountInShares);
        } else {
            SAVINGS_ACCOUNT.withdrawShares(_asset, _strategy, _to, _amountInShares, false);
        }

        return _amountInShares;
    }

    //-------------------------------- Collateral management end --------------------------------//

    //-------------------------------- Borrow code start --------------------------------//

    /**
     * @notice used to update the borrow limit of the creditLine
     * @dev can only be updated by lender
     * @param _id identifier for the credit line
     * @param _newBorrowLimit updated value of the borrow limit for the credit line
     */
    function updateBorrowLimit(uint256 _id, uint128 _newBorrowLimit) external nonReentrant onlyCreditLineLender(_id) {
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        _limitBorrowedInUSDC(_borrowAsset, uint256(_newBorrowLimit));
        creditLineConstants[_id].borrowLimit = _newBorrowLimit;
        emit BorrowLimitUpdated(_id, _newBorrowLimit);
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(_status == CreditLineStatus.ACTIVE, 'CL:CBA1');

        uint256 _collateralRatio = creditLineConstants[_id].idealCollateralRatio;
        uint256 _maxPossible = type(uint256).max;
        if (_collateralRatio != 0) {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            (uint256 _ratioOfPrices, uint256 _decimals) = PRICE_ORACLE.getLatestPrice(
                _collateralAsset,
                creditLineConstants[_id].borrowAsset
            );

            uint256 _totalCollateralToken = _calculateTotalCollateralTokens(_id, _collateralAsset);
            _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(_collateralRatio).mul(SCALING_FACTOR).div(10**_decimals);
        }

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;
        uint256 _principal = creditLineVariables[_id].principal;

        if (_maxPossible <= _currentDebt) return 0;

        return Math.min(_borrowLimit.sub(_principal), _maxPossible.sub(_currentDebt));
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev can only be called in ACTIVE stage
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external nonReentrant onlyCreditLineBorrower(_id) {
        require(_amount != 0, 'CL:B1');
        require(_amount <= calculateBorrowableAmount(_id), 'CL:B2');
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = calculateInterestAccrued(_id);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
        uint256 _shares = SAVINGS_ACCOUNT.withdrawFrom(
            _borrowAsset,
            creditLineConstants[_id].borrowAssetStrategy,
            creditLineConstants[_id].lender,
            address(this),
            _amount,
            false
        );
        uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));

        uint256 _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_tokenDiffBalance);

        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(SCALING_FACTOR);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
        IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        emit BorrowedFromCreditLine(_id, _shares);
    }

    //-------------------------------- Borrow code end --------------------------------//

    //-------------------------------- Repayments code start --------------------------------//

    /**
    @dev Regarding increaseAllowanceToCreditLineSince the borrower is giving money into the credit line, 
        we need to make sure that the Credit Line then has the allowance to use those funds
     */
    function _repay(uint256 _id, uint256 _amount) private {
        address _borrowAssetStrategy = creditLineConstants[_id].borrowAssetStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
        IERC20(_borrowAsset).safeApprove(_borrowAssetStrategy, _amount);
        SAVINGS_ACCOUNT.deposit(_borrowAsset, _borrowAssetStrategy, _lender, _amount);
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     */

    function repay(uint256 _id, uint256 _amount) external override nonReentrant {
        require(_amount != 0, 'CL:REP1');
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CL:REP2');
        require(creditLineConstants[_id].lender != msg.sender, 'CL:REP3');

        uint256 _totalInterestAccrued = calculateInterestAccrued(_id);
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, msg.sender, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, msg.sender, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) private {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    //-------------------------------- Repayments code end --------------------------------//

    //-------------------------------- Liquidation code start --------------------------------//

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, shares are transferred from savingsAccount
                                otherwise tokens are  from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external nonReentrant {
        uint256 _currentCollateralRatio;
        uint256 _totalCollateralTokens;
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CL:L1');
        require(creditLineVariables[_id].principal != 0, 'CL:L2');

        address _lender = creditLineConstants[_id].lender;
        // For ideal collateral ratio = 0, Borrower can borrow tokens without depositing any collateral.
        // When liquidating a credit line with 0 creditLineConstants[_id].idealCollateralRatio,
        // the condition `_currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio` will always revert.
        // This avoids the liquidation of unsecured loans even when the borrower is defaulting on the loan.
        // The if condition allows the lender to bypass the collateral ratio check in case of a defaulted unsecured loan.
        // This allows the liquidation of the defaulted unsecured loan and flagging the borrower as defaulted.
        // Third party users are NOT allowed to bypass the checks to avoid flase flagging of the borrower.
        if (creditLineConstants[_id].idealCollateralRatio != 0 || msg.sender != _lender) {
            (_currentCollateralRatio, _totalCollateralTokens) = calculateCurrentCollateralRatio(_id);
            require(_currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio, 'CL:L3');
        }
        require(creditLineConstants[_id].autoLiquidation || msg.sender == _lender, 'CL:L4');

        uint256 _currentDebt = calculateCurrentDebt(_id);
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        uint256 _collateralToLiquidate = _equivalentCollateral(_collateralAsset, _borrowAsset, _currentDebt);

        if (_collateralToLiquidate > _totalCollateralTokens) {
            _collateralToLiquidate = _totalCollateralTokens;
        }

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _collateralToLiquidate);
            IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
        }
        // transfering collateral for providing debt tokens to liquidator
        _transferCollateral(_id, _collateralAsset, msg.sender, _collateralToLiquidate, _toSavingsAccount);
        if (_collateralToLiquidate < _totalCollateralTokens) {
            // transfering remaining collateral to borrower
            _transferCollateral(
                _id,
                _collateralAsset,
                creditLineConstants[_id].borrower,
                _totalCollateralTokens.sub(_collateralToLiquidate),
                false
            );
        }
        delete creditLineConstants[_id];
        delete creditLineVariables[_id];
        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        uint256 _currentDebt = calculateCurrentDebt(_id);
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        uint256 _collateralToLiquidate = _equivalentCollateral(_collateralAsset, _borrowAsset, _currentDebt);
        uint256 _totalCollateralTokens = _calculateTotalCollateralTokens(_id, _collateralAsset);

        if (_collateralToLiquidate > _totalCollateralTokens) {
            _collateralToLiquidate = _totalCollateralTokens;
        }

        return _borrowTokensToLiquidate(creditLineConstants[_id].borrowAsset, _collateralAsset, _collateralToLiquidate);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _collateralTokens
    ) private view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = PRICE_ORACLE.getLatestPrice(_collateralAsset, _borrowAsset);
        uint256 _borrowTokens = (
            _collateralTokens.mul(uint256(SCALING_FACTOR).sub(liquidatorRewardFraction)).div(SCALING_FACTOR).mul(_ratioOfPrices).div(
                10**_decimals
            )
        );

        return _borrowTokens;
    }

    function _equivalentCollateral(
        address _collateralAsset,
        address _borrowAsset,
        uint256 _borrowTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = PRICE_ORACLE.getLatestPrice(_collateralAsset, _borrowAsset);
        uint256 _collateralTokens = (_borrowTokens.mul(10**_decimals).div(_ratioOfPrices));

        return _collateralTokens;
    }

    //-------------------------------- Liquidation code end --------------------------------//

    //-------------------------------- close/cancel code start --------------------------------//
    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CL:C1');
        require(msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender, 'CL:C2');
        require(creditLineVariables[_id].principal == 0, 'CL:C3');

        _withdrawAllCollateral(_id, creditLineConstants[_id].borrower, false);
        bool closedByLender = (msg.sender == creditLineConstants[_id].lender);

        delete creditLineConstants[_id];
        delete creditLineVariables[_id];
        emit CreditLineClosed(_id, closedByLender);
    }

    /**
     * @dev used to cancel credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function cancel(uint256 _id) external {
        require(creditLineVariables[_id].status == CreditLineStatus.REQUESTED, 'CL:CP1');
        require(msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender, 'CL:CP2');
        delete creditLineVariables[_id];
        delete creditLineConstants[_id];
        emit CreditLineCancelled(_id);
    }

    //-------------------------------- close/cancel code end --------------------------------//

    //-------------------------------- Utilities code start --------------------------------//

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by SCALING_FACTOR to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public returns (uint256, uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        (uint256 _ratioOfPrices, uint256 _decimals) = PRICE_ORACLE.getLatestPrice(_collateralAsset, creditLineConstants[_id].borrowAsset);

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 totalCollateralTokens = _calculateTotalCollateralTokens(_id, _collateralAsset);
        uint256 currentCollateralRatio = type(uint256).max;
        if (currentDebt != 0) {
            currentCollateralRatio = totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(SCALING_FACTOR).div(currentDebt);
        }

        return (currentCollateralRatio, totalCollateralTokens);
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        return _calculateTotalCollateralTokens(_id, _collateralAsset);
    }

    function _calculateTotalCollateralTokens(uint256 _id, address _collateralAsset) private returns (uint256) {
        address _strategy = creditLineConstants[_id].collateralStrategy;

        uint256 _collateralShares = collateralShareInStrategy[_id];
        uint256 _collateral = IYield(_strategy).getTokensForShares(_collateralShares, _collateralAsset);

        return _collateral;
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @param _timeElapsed It is the time interval in seconds for which interest is calculated
     * @return interest per second for the given parameters scaled by SCALING_FACTOR
     */
    function calculateInterestScaled(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        return (_principal.mul(_borrowRate).mul(_timeElapsed).div(YEAR_IN_SECONDS));
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */
    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccruedScaled = calculateInterestScaled(
            creditLineVariables[_id].principal,
            creditLineConstants[_id].borrowRate,
            _timeElapsed
        );
        uint256 _interestAccrued = _divAndCeil(_interestAccruedScaled, SCALING_FACTOR);
        return _interestAccrued.add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate);
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal).add(_interestAccrued).sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @dev Used to get the current status of the credit line
     * @param _id identifier for the credit line
     * @return credit line status
     */
    function getCreditLineStatus(uint256 _id) external view returns (CreditLineStatus) {
        return creditLineVariables[_id].status;
    }

    function _divAndCeil(uint256 _num, uint256 _denom) private pure returns (uint256) {
        uint256 _divResult = _num.div(_denom);
        if (_divResult * _denom != _num) {
            _divResult++;
        }
        return _divResult;
    }

    //-------------------------------- Utilities code end --------------------------------//
}",11112
RealWorld_TA_101_IPooledCreditLineEnums_RealWorld_20240812180944.log,101,IPooledCreditLineEnums,27998,1156,29154,73.0,0.16311,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface IPooledCreditLineEnums {
    enum PooledCreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        EXPIRED,
        LIQUIDATED,
        CANCELLED
    }

    /*
     * @notice a PCL can be cancelled in 3 different cases denoted by the enums
     */
    enum CancellationStatus {
        BORROWER_BEFORE_START,
        LENDER_LOW_COLLECTION,
        LENDER_NOT_STARTED_AT_END
    }
}",119
RealWorld_TA_101_PCLActiveStage.t_RealWorld_20240812153118.log,101,PCLActiveStage.t,47860,2301,50161,83.0,0.28532,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLStageTests/PCLActiveStage.t.sol';

contract PCLActiveStageZeroCollateral is PCLActiveStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * (10**ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!ACTIVE');
    }
}",341
RealWorld_TA_101_IHevm_RealWorld_20240812172415.log,101,IHevm,35256,1449,36705,67.0,0.20526,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface Hevm {
    // Sets block timestamp to `x`
    function warp(uint256 x) external view;

    // Sets slot `loc` of contract `c` to value `val`
    function store(
        address c,
        bytes32 loc,
        bytes32 val
    ) external view;

    // Reads the slot `loc` of contract `c`
    function load(address c, bytes32 loc) external view returns (bytes32 val);

    // Generates address derived from private key `sk`
    function addr(uint256 sk) external view returns (address _addr);

    // Signs `digest` with private key `sk` (WARNING: this is insecure as it leaks the private key)
    function sign(uint256 sk, bytes32 digest)
        external
        view
        returns (
            uint8 v,
            bytes32 r,
            bytes32 s
        );
}",199
RealWorld_TA_101_MockWETH_RealWorld_20240812141502.log,101,MockWETH,59445,2767,62212,79.0,0.352565,"// SPDX-License-Identifier: GNU V3

// Thanks to https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code for the code

pragma solidity 0.7.6;

import '../interfaces/IWETH9.sol';

contract MockWETH is IWETH9 {
    string public name = 'Wrapped Ether';
    string public symbol = 'WETH';
    uint8 public decimals = 18;

    event Approval(address indexed src, address indexed guy, uint256 wad);
    event Transfer(address indexed src, address indexed dst, uint256 wad);
    event Deposit(address indexed dst, uint256 wad);
    event Withdrawal(address indexed src, uint256 wad);

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    constructor() payable {
        deposit();
    }

    function deposit() public payable override {
        balanceOf[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 wad) public override {
        require(balanceOf[msg.sender] >= wad);
        balanceOf[msg.sender] -= wad;
        msg.sender.transfer(wad);
        emit Withdrawal(msg.sender, wad);
    }

    function totalSupply() public view returns (uint256) {
        return address(this).balance;
    }

    function approve(address guy, uint256 wad) public override returns (bool) {
        allowance[msg.sender][guy] = wad;
        emit Approval(msg.sender, guy, wad);
        return true;
    }

    function transfer(address dst, uint256 wad) public override returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }

    function transferFrom(
        address src,
        address dst,
        uint256 wad
    ) public returns (bool) {
        require(balanceOf[src] >= wad);

        if (src != msg.sender && allowance[src][msg.sender] != uint256(-1)) {
            require(allowance[src][msg.sender] >= wad);
            allowance[src][msg.sender] -= wad;
        }

        balanceOf[src] -= wad;
        balanceOf[dst] += wad;

        emit Transfer(src, dst, wad);

        return true;
    }
}",499
RealWorld_TA_101_creditLine.Compound.Lifecycle.t_RealWorld_20240812170407.log,101,creditLine.Compound.Lifecycle.t,24895,1764,26659,69.0,0.159755,"pragma solidity 0.7.6;
pragma abicoder v2;

import '../creditLine.Lifecycle.t.sol';

contract CreditLine_Compound_LifecycleTests is CreditLine_LifecycleTests {
    function setUp() public override {
        super.setUp();

        requestData.borrowAssetStrategy = compoundYieldAddress;
        requestData.collateralStrategy = compoundYieldAddress;
    }
}",77
RealWorld_TA_101_creditLine.Lifecycle.t_RealWorld_20240812164656.log,101,creditLine.Lifecycle.t,407054,5959,413013,161.0,2.15445,"pragma solidity 0.7.6;
pragma abicoder v2;

import './Helpers/CLParent.sol';
import '../../SavingsAccount/SavingsAccount.sol';
import '../../PriceOracle.sol';

import '@openzeppelin/contracts/math/SafeMath.sol';

// Possible paths //
// NotCreated -> Requested //
// Requested -> Active //
// Requested -> Closed (NotCreated)//
// Requested -> Cancelled (NotCreated)//
// Active -> Closed (NotCreated)//
// Active -> Liquidated (NotCreated)//

contract CreditLine_LifecycleTests is CLParent {
    using SafeMath for uint256;

    uint256 status;
    uint256 creditLineId;
    uint256 protocolFee;
    uint256 constant SCALING_FACTOR = 1e18;

    CreditLine creditLine;
    SavingsAccount savingsAccount;
    PriceOracle priceOracle;

    function setUp() public virtual {
        CLSetUp();

        creditLine = CreditLine(creditLineAddress);
        savingsAccount = SavingsAccount(savingsAccountAddress);
        priceOracle = PriceOracle(priceOracleAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = priceOracle.getLatestPrice(address(usdc), address(borrowAsset));

        requestData.requestTo = address(lender);
        // Borrow Asset equivalent of 1,000,000,000 in USD
        requestData.borrowLimit = uint128(uint256(CLConstants.maxBorrowLimit / 1e6).mul(_ratioOfPrices).div(10**_decimals));
        requestData.borrowRate = CLConstants.maxBorrowRate / 1e18;
        requestData.autoLiquidation = false;
        requestData.collateralRatio = 350 * (CLConstants.maxCollteralRatio / 1e11);
        requestData.borrowAsset = address(borrowAsset);
        requestData.borrowAssetStrategy = noYieldAddress;
        requestData.collateralAsset = address(collateralAsset);
        requestData.collateralStrategy = noYieldAddress;
        requestData.requestAsLender = false;

        protocolFee = creditLine.protocolFeeFraction();
    }

    // Events
    event CollateralSharesDeposited(uint256 indexed id, uint256 shares);
    event CollateralSharesWithdrawn(uint256 indexed id, uint256 shares);
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower, bool requestByLender);
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);
    event CreditLineAccepted(uint256 indexed id);
    event PartialCreditLineRepaid(uint256 indexed id, address indexed repayer, uint256 repayAmount);
    event CompleteCreditLineRepaid(uint256 indexed id, address indexed repayer, uint256 repayAmount);
    event CreditLineCancelled(uint256 indexed id);
    event CreditLineClosed(uint256 indexed id, bool closedByLender);

    // Adding enough collateral for a target collateral ratio, should give the same current collateral ratio
    // Assuming borrower borrows amount = borrow limit
    function test_targetCollateralRatio(uint256 _collateralRatio) public {
        requestData.collateralRatio = 15 * 1e16; // 15%
        // Request for a creditLine
        creditLineId = borrower.createRequest(creditLineAddress, requestData);
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        // Accept a creditLine
        lender.acceptRequest(creditLineAddress, creditLineId);
        status = uint256(creditLine.getCreditLineStatus(creditLineId));
        assertEq(status, 2); // Should return to Active stage

        // Calculating required collateral amount for target collateral ratio
        uint256 targetCollateralRatio = scaleToRange256(_collateralRatio, requestData.collateralRatio, CLConstants.maxCollteralRatio);
        (uint256 _ratioOfPrices, uint256 _decimals) = priceOracle.getLatestPrice(address(collateralAsset), address(borrowAsset));
        uint256 collateralRequired = targetCollateralRatio.mul(requestData.borrowLimit).div(_ratioOfPrices).mul(10**_decimals).div(
            SCALING_FACTOR
        );

        if (collateralRequired <= ERC20(collateralAsset).totalSupply()) {
            // Adding tokens to borrower and setting allowance for creditline contract
            admin.transferToken(address(collateralAsset), address(borrower), collateralRequired);
            borrower.setAllowance(address(creditLine), address(collateralAsset), collateralRequired);

            borrower.addCollateral(address(creditLine), creditLineId, collateralRequired, false);
            assert_creditLineDeposit(creditLineId, collateralRequired);

            // Collateral ratio should be type(uint256).max, before borrowing any amount
            (uint256 currentCollateralRatio, uint256 totalCollateralTokens) = creditLine.calculateCurrentCollateralRatio(creditLineId);
            assertEq(currentCollateralRatio, type(uint256).max);
            assertApproxEqRel(totalCollateralTokens, collateralRequired, 1e14);

            // Borrowable amount check
            uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);
            assertApproxEqRel(borrowable, requestData.borrowLimit, 1e14);

            // Adding tokens to lender and depositing to lender's savings Account
            savingsAccount_depositHelper(address(lender), address(borrowAsset), requestData.borrowAssetStrategy, borrowable);

            borrower.borrow(address(creditLine), creditLineId, borrowable);
            uint256 borrowShares = IYield(requestData.borrowAssetStrategy).getSharesForTokens(borrowable, address(borrowAsset));
            assert_creditLineBorrow(creditLineId, borrowShares);

            // Current collateral ratio should be equal to target collateral ratio as borrow amount is equal to borrow limit
            (currentCollateralRatio, totalCollateralTokens) = creditLine.calculateCurrentCollateralRatio(creditLineId);
            assertApproxEqRel(currentCollateralRatio, targetCollateralRatio, 1e14);
        }
    }

    function test_RequestedToCancelled() public {
        // Request for a creditLine
        vm.expectEmit(true, true, false, true);
        emit CreditLineRequested(1, address(lender), address(borrower), false);
        creditLineId = borrower.createRequest(creditLineAddress, requestData);
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        // Cancel creditLine
        vm.expectEmit(true, true, false, true);
        emit CreditLineCancelled(creditLineId);
        borrower.cancelRequest(creditLineAddress, creditLineId);
        status = uint256(creditLine.getCreditLineStatus(creditLineId));
        assertEq(status, 0); // Should return to Not_Created stage
    }

    function test_RequestedToActiveToClosed_withOutBorrow(uint256 _amount) public {
        // Request for a creditLine
        vm.expectEmit(true, true, false, true);
        emit CreditLineRequested(1, address(lender), address(borrower), false);
        creditLineId = borrower.createRequest(creditLineAddress, requestData);
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        // Accept a creditLine
        vm.expectEmit(true, true, false, true);
        emit CreditLineAccepted(creditLineId);
        lender.acceptRequest(creditLineAddress, creditLineId);
        status = uint256(creditLine.getCreditLineStatus(creditLineId));
        assertEq(status, 2); // Should return to Active stage

        // Deposit to creditLine
        uint256 amount = scaleToRange256(_amount, 1, collateralAsset.totalSupply());

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        uint256 collateralShares = IYield(requestData.collateralStrategy).getSharesForTokens(amount, address(collateralAsset));
        vm.expectEmit(true, true, false, true);
        emit CollateralSharesDeposited(creditLineId, collateralShares);
        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 withdrawable = creditLine.withdrawableCollateral(creditLineId);
        if (withdrawable > 0) {
            uint256 withdrawShares = IYield(requestData.collateralStrategy).getSharesForTokens(withdrawable, address(collateralAsset));
            // Close the creditLine
            vm.expectEmit(true, true, false, true);
            emit CollateralSharesWithdrawn(creditLineId, withdrawShares);
            vm.expectEmit(true, true, false, true);
            emit CreditLineClosed(creditLineId, true);
            lender.close(creditLineAddress, creditLineId);
            status = uint256(creditLine.getCreditLineStatus(creditLineId));
            assertEq(status, 0); // Should return to Not_Created stage
        }
    }

    function test_RequestedToActiveToLiquidated(uint256 _amount, uint256 _borrowAmount) public {
        // Request for a creditLine
        vm.expectEmit(true, true, false, true);
        emit CreditLineRequested(1, address(lender), address(borrower), false);
        creditLineId = borrower.createRequest(creditLineAddress, requestData);
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        // Accept a creditLine
        vm.expectEmit(true, true, false, true);
        emit CreditLineAccepted(creditLineId);
        lender.acceptRequest(creditLineAddress, creditLineId);
        status = uint256(creditLine.getCreditLineStatus(creditLineId));
        assertEq(status, 2); // Should return to Active stage

        // Deposit to creditLine
        uint256 amount = scaleToRange256(_amount, 1, collateralAsset.totalSupply());

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        uint256 collateralShares = IYield(requestData.collateralStrategy).getSharesForTokens(amount, address(collateralAsset));
        vm.expectEmit(true, true, false, true);
        emit CollateralSharesDeposited(creditLineId, collateralShares);
        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        // Borrow from a creditLine
        uint256 Borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        (uint256 _ratioOfPrices, uint256 _decimals) = priceOracle.getLatestPrice(address(collateralAsset), address(borrowAsset));
        uint256 collateralTokens = IYield(requestData.collateralStrategy).getTokensForShares(collateralShares, address(collateralAsset));
        uint256 calculateBorrowable = collateralTokens.mul(_ratioOfPrices).div(requestData.collateralRatio).mul(SCALING_FACTOR).div(
            10**_decimals
        );
        assertEq(Borrowable, Math.min(requestData.borrowLimit, calculateBorrowable));

        if (Borrowable > 0) {
            uint256 BorrowAmount = scaleToRange256(_borrowAmount, 1, Borrowable);

            // Adding tokens to lender and depositing to lender's savings Account
            savingsAccount_depositHelper(address(lender), address(borrowAsset), requestData.borrowAssetStrategy, BorrowAmount);
            uint256 borrowShares = IYield(requestData.borrowAssetStrategy).getSharesForTokens(BorrowAmount, address(borrowAsset));
            uint256 borrowAmount = IYield(requestData.borrowAssetStrategy).getTokensForShares(borrowShares, address(borrowAsset));
            uint256 expectedBorrow = borrowAmount.sub(borrowAmount.mul(protocolFee).div(SCALING_FACTOR));
            vm.expectEmit(true, true, false, true);
            emit BorrowedFromCreditLine(creditLineId, borrowAmount);
            borrower.borrow(address(creditLine), creditLineId, BorrowAmount);
            assert_creditLineBorrow(creditLineId, borrowShares);

            if (!isForked) {
                borrowAssetMockAggregator.updateAnswer(9795040576);
            } else {
                _increaseBlock(block.timestamp + 7500000000 days);
            }

            (uint256 currentColRatio, ) = creditLine.calculateCurrentCollateralRatio(creditLineId);
            if (expectedBorrow > 0 && currentColRatio < requestData.collateralRatio) {
                // Liquidate the creditLine
                vm.expectEmit(true, true, false, true);
                emit CreditLineLiquidated(creditLineId, address(lender));
                lender.liquidate(creditLineAddress, creditLineId, false);
                status = uint256(creditLine.getCreditLineStatus(creditLineId));
                assertEq(status, 0); // Should return to Not_Created stage
            }
        }
    }

    function test_RequestedToActiveToClosed_AfterRepay(uint256 _amount, uint256 _borrowAmount) public {
        // Request for a creditLine
        vm.expectEmit(true, true, false, true);
        emit CreditLineRequested(1, address(lender), address(borrower), false);
        creditLineId = borrower.createRequest(creditLineAddress, requestData);
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        // Accept a creditLine
        vm.expectEmit(true, true, false, true);
        emit CreditLineAccepted(creditLineId);
        lender.acceptRequest(creditLineAddress, creditLineId);
        status = uint256(creditLine.getCreditLineStatus(creditLineId));
        assertEq(status, 2); // Should return to Active stage

        // Deposit to creditLine
        uint256 amount = scaleToRange256(_amount, 1, collateralAsset.totalSupply());

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        uint256 collateralShares = IYield(requestData.collateralStrategy).getSharesForTokens(amount, address(collateralAsset));
        vm.expectEmit(true, true, false, true);
        emit CollateralSharesDeposited(creditLineId, collateralShares);
        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        // Borrow from a creditLine
        uint256 Borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        (uint256 _ratioOfPrices, uint256 _decimals) = priceOracle.getLatestPrice(address(collateralAsset), address(borrowAsset));
        uint256 collateralTokens = IYield(requestData.collateralStrategy).getTokensForShares(collateralShares, address(collateralAsset));
        uint256 calculateBorrowable = collateralTokens.mul(_ratioOfPrices).div(requestData.collateralRatio).mul(SCALING_FACTOR).div(
            10**_decimals
        );
        assertEq(Borrowable, Math.min(requestData.borrowLimit, calculateBorrowable));

        if (Borrowable > 0) {
            uint256 BorrowAmount = scaleToRange256(_borrowAmount, 1, Borrowable);

            // Adding tokens to lender and depositing to lender's savings Account
            savingsAccount_depositHelper(address(lender), address(borrowAsset), requestData.borrowAssetStrategy, BorrowAmount);
            uint256 borrowShares = IYield(requestData.borrowAssetStrategy).getSharesForTokens(BorrowAmount, address(borrowAsset));
            uint256 borrowAmount = IYield(requestData.borrowAssetStrategy).getTokensForShares(borrowShares, address(borrowAsset));
            vm.expectEmit(true, true, false, true);
            emit BorrowedFromCreditLine(creditLineId, borrowAmount);
            borrower.borrow(address(creditLine), creditLineId, BorrowAmount);
            assert_creditLineBorrow(creditLineId, borrowShares);

            if (borrowShares > 0) {
                try lender.close(creditLineAddress, creditLineId) {
                    revert('Should not be able to close before complete Repayment');
                } catch Error(string memory reason) {
                    assertEq(reason, 'CL:C3');
                }

                // Repay the creditLine
                vm.expectEmit(true, true, false, true);
                emit CompleteCreditLineRepaid(creditLineId, address(borrower), borrowAmount);
                assert_creditLineRepay_FullDebt(address(borrower), creditLineId, address(borrowAsset), BorrowAmount);

                uint256 totalCollateral = IYield(requestData.collateralStrategy).getTokensForShares(
                    collateralShares,
                    address(collateralAsset)
                );
                uint256 withdrawShares = IYield(requestData.collateralStrategy).getSharesForTokens(
                    totalCollateral,
                    address(collateralAsset)
                );
                // Close the creditLine
                vm.expectEmit(true, true, false, true);
                emit CollateralSharesWithdrawn(creditLineId, withdrawShares);
                vm.expectEmit(true, true, false, true);
                emit CreditLineClosed(creditLineId, true);
                lender.close(creditLineAddress, creditLineId);
                status = uint256(creditLine.getCreditLineStatus(creditLineId));
                assertEq(status, 0); // Should return to Not_Created stage
            }
        }
    }

    //----------------------- Assert helper functions -----------------------//

    function assert_creditlineConstantsAndStatus(
        uint256 _creditLineId,
        address _requestBy,
        CLConstants.RequestParams memory requestData
    ) public {
        getCreditlineConstants(_creditLineId);

        if (requestData.requestAsLender) {
            assertEq(constantsCheck.lender, _requestBy);
            assertEq(constantsCheck.borrower, requestData.requestTo);
        } else {
            assertEq(constantsCheck.lender, requestData.requestTo);
            assertEq(constantsCheck.borrower, _requestBy);
        }

        assertEq(constantsCheck.borrowLimit, requestData.borrowLimit);
        assertEq(constantsCheck.idealCollateralRatio, requestData.collateralRatio);
        assertEq(constantsCheck.borrowRate, requestData.borrowRate);
        assertEq(constantsCheck.borrowAsset, requestData.borrowAsset);
        assertEq(constantsCheck.collateralAsset, requestData.collateralAsset);
        assertEq(constantsCheck.collateralStrategy, requestData.collateralStrategy);

        status = uint256(creditLine.getCreditLineStatus(_creditLineId));
        assertEq(status, 1); // Checking if creditLine status is updated to REQUESTED
    }

    function assert_creditLineDeposit(uint256 _creditLineId, uint256 _amount) public {
        // assert the received shares and deposited amount equivalent shares are equal
        uint256 sharesReceived = creditLine.collateralShareInStrategy(_creditLineId);
        uint256 sharesOfAmount = IYield(requestData.collateralStrategy).getSharesForTokens(_amount, address(collateralAsset));

        assertEq(sharesReceived, sharesOfAmount);
    }

    function assert_creditLineBorrow(uint256 _creditLineId, uint256 _borrowShares) public {
        uint256 _borrowAmount = IYield(requestData.borrowAssetStrategy).getTokensForShares(_borrowShares, address(borrowAsset));
        // Checking balances
        uint256 protocolFeeAmount = _borrowAmount.mul(protocolFee).div(SCALING_FACTOR);
        uint256 expectedAmount = _borrowAmount.sub(protocolFeeAmount);

        uint256 borrowerBalance = borrowAsset.balanceOf(address(borrower));
        assertEq(expectedAmount, borrowerBalance);

        uint256 lenderBalance = borrowAsset.balanceOf(address(lender));
        assertEq(lenderBalance, 0);

        uint256 lenderBalanceSA = savingsAccount.balanceInShares(address(lender), address(borrowAsset), requestData.borrowAssetStrategy);
        assertEq(lenderBalanceSA, 0);

        uint256 feeCollectorBalance = borrowAsset.balanceOf(protocolFeeCollectorAddress);
        assertEq(feeCollectorBalance, protocolFeeAmount);

        // Variable updates
        (, uint256 principal, , uint256 lastPrincipalUpdateTime, ) = creditLine.creditLineVariables(_creditLineId);

        assertEq(principal, _borrowAmount);
        assertEq(lastPrincipalUpdateTime, block.timestamp);
    }

    function assert_creditLineRepay_FullDebt(
        address _user,
        uint256 _creditLineId,
        address _asset,
        uint256 _amount
    ) public {
        // initialize the user
        CLUser user = CLUser(_user);
        uint256 currentDebt = creditLine.calculateCurrentDebt(_creditLineId);

        // add balance to user
        admin.transferToken(_asset, _user, _amount);
        user.setAllowance(address(creditLine), _asset, _amount);

        // getting balance of the user before repayment
        uint256 balanceBefore = IERC20(_asset).balanceOf(_user);

        // repay the credit line
        user.repay(address(creditLine), _creditLineId, _amount);

        // getting the balance after repayment
        uint256 balanceAfter = IERC20(_asset).balanceOf(_user);

        // assert: balance change for user should be equal to amount repaid
        uint256 balanceDiff = balanceBefore.sub(balanceAfter);
        assertEq(balanceDiff, currentDebt);

        // checking the variable updates after repayment
        (
            ,
            uint256 principal,
            uint256 totalInterestRepaid,
            uint256 lastPrincipalUpdateTime,
            uint256 interestAccruedTillLastPrincipalUpdate
        ) = creditLine.creditLineVariables(_creditLineId);

        // if total debt is repaid, credit line is reset
        assertEq(principal, 0);
        assertEq(totalInterestRepaid, 0);
        assertEq(lastPrincipalUpdateTime, 0);
        assertEq(interestAccruedTillLastPrincipalUpdate, 0);
    }
}",4665
RealWorld_TA_101_MinimumBeaconProxy2_RealWorld_20240812174858.log,101,MinimumBeaconProxy2,36722,1737,38459,81.0,0.21835,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/proxy/IBeacon.sol';

contract MinimumBeaconProxy {
    address private immutable beacon;

    constructor(address _beacon) {
        require(_beacon != address(0), 'MBP2:C1');
        beacon = _beacon;
    }

    function _implementation() internal view virtual returns (address) {
        return IBeacon(beacon).implementation();
    }

    fallback() external {
        address impl = _implementation();
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)

            returndatacopy(0, 0, returndatasize())

            switch result
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }
}",217
RealWorld_TA_101_PCLClosedStage.t_RealWorld_20240812154444.log,101,PCLClosedStage.t,77995,3714,81709,98.0,0.464255,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../../PCLStageTests/PCLClosedStage.t.sol';

contract PCLClosedStageZeroCollateralBorrowCompound is PCLClosedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        // Now we assert that we are in the ACTIVE state
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), 2);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(requestId, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // And borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(requestId, currentDebt);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!CLOSED');
    }
}",702
RealWorld_TA_101_LimitsManager_RealWorld_20240812180639.log,101,LimitsManager,217655,3597,221252,107.0,1.160215,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/ILimitsManager.sol';
import '../interfaces/IPriceOracle.sol';

contract LimitsManager is OwnableUpgradeable, ILimitsManager {
    using SafeMath for uint256;

    //-------------------------------- Constants start --------------------------------//

    /**
     * @notice address of USDC token
     */
    address public immutable USDC;

    /**
     * @notice stores the address of price oracle contract
     **/
    IPriceOracle public immutable PRICE_ORACLE;

    //-------------------------------- Constants end --------------------------------//

    //-------------------------------- Variable limits starts --------------------------------//

    /*
     * @notice Used to set the min/max borrow limits for pooled credit lines
     * @dev IMPORTANT: the limit values are in USDC, so need to be converted to borrowAsset
            check how this is used in method _limitBorrowedInUSDC
     */
    Limits borrowAmountUSDCLimits;

    /*
     * @notice Used to set the min/max collateral ratio for pooled credit lines
     */
    Limits idealCollateralRatioLimits;

    /*
     * @notice Used to set the min/max borrow rate for pooled credit lines
     */
    Limits borrowRateLimits;

    /*
     * @notice Used to set the min/max collection period for pooled credit lines
     */
    Limits collectionPeriodLimits;

    /*
     * @notice Used to set the min/max duration of pooled credit lines
     */
    Limits durationLimits;

    /*
     * @notice Used to set the min/max grace period before default for pooled credit lines
     */
    Limits defaultGracePeriodLimits;

    /*
     * @notice Used to set the min/max Penalty rate during grace period for pooled credit lines
     */
    Limits gracePenaltyRateLimits;

    //-------------------------------- Variable limits ends --------------------------------//

    //--------------------------- Limits event start ---------------------------//

    /**
     * @notice emitted when thresholds for one of the parameters is updated
     * @param limitType specifies the parameter whose limits are being updated
     * @param min minimum threshold value for limitType
     * @param max maximum threshold value for limitType
     */
    event LimitsUpdated(string indexed limitType, uint256 min, uint256 max);

    //--------------------------- Limits event end ---------------------------//

    constructor(address _usdc, address _priceOracle) {
        require(_usdc != address(0), 'LM:CON1');
        require(_priceOracle != address(0), 'LM:CON2');
        USDC = _usdc;
        PRICE_ORACLE = IPriceOracle(_priceOracle);
    }

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _owner address of owner who can change global variables
     */
    function initialize(address _owner) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);
    }

    //-------------------------------- Limits code starts --------------------------------//

    /**
     * @notice invoked to check if credit lines parameters are within thresholds
     * @dev min or max = 0 is considered as no limit set
     * @param _value supplied value of the parameter
     * @param _limits the limits to check
     */
    function isWithinLimits(uint256 _value, Limits memory _limits) public pure override returns (bool) {
        return (_value >= _limits.min && _value <= _limits.max);
    }

    /*
     * @notice checks if the _borrowLimit and _minBorrowAmount value is within the USDC limits set for the contract
     * @dev this method fetches the price of the borrowAsset in terms of USDC to convert the _borrowLimit and
     *      _minBorrowAmount values in to USDC and compare it with the limits set in the contract
     * @param _borrowAsset address of the borrow asset in the PCL request
     * @param _borrowLimit the maximum borrow amount for the PCL request
     * @param _minBorrowAmount the minimum borrow amount for the PCL request
     */
    function limitBorrowedInUSDC(
        address _borrowAsset,
        uint256 _borrowLimit,
        uint256 _minBorrowAmount
    ) public view override {
        (uint256 _ratioOfPrices, uint256 _decimals) = PRICE_ORACLE.getLatestPrice(_borrowAsset, USDC);
        uint256 _maxBorrowAmountInUSDC = _borrowLimit.mul(_ratioOfPrices).div(10**_decimals);
        uint256 _borrowAmountUSDCLimitsMin = borrowAmountUSDCLimits.min;

        require(isWithinLimits(_maxBorrowAmountInUSDC, borrowAmountUSDCLimits), 'PCL:ILB1');

        require(_minBorrowAmount <= _borrowLimit, 'PCL:ILB2');
        uint256 _minBorrowAmountInUSDC = _minBorrowAmount.mul(_ratioOfPrices).div(10**_decimals);
        require(_minBorrowAmountInUSDC >= _borrowAmountUSDCLimitsMin, 'PCL:ILB3');
    }

    /**
     * @notice used to update the thresholds of the borrow limit of the pooled credit line
     * @param _min updated value of the minimum threshold value of the borrow limit in lowest units of USDC
     * @param _max updated value of the maximum threshold value of the borrow limit in lowest units of USDC
     */
    function updateBorrowAmountUSDCLimits(uint256 _min, uint256 _max) external onlyOwner {
        require(_min <= _max, 'PCL:UBLL1');
        require(!(borrowAmountUSDCLimits.min == _min && borrowAmountUSDCLimits.max == _max), 'PCL:UBLL2');
        borrowAmountUSDCLimits = Limits(_min, _max);
        emit LimitsUpdated('borrowLimit', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the ideal collateral ratio of the pooled credit line
     * @param _min updated value of the minimum threshold value of the ideal collateral ratio
     * @param _max updated value of the maximum threshold value of the ideal collateral ratio
     */
    function updateIdealCollateralRatioLimits(uint256 _min, uint256 _max) external onlyOwner {
        require(_min <= _max, 'PCL:UICRL1');
        require(!(idealCollateralRatioLimits.min == _min && idealCollateralRatioLimits.max == _max), 'PCL:UICRL2');
        idealCollateralRatioLimits = Limits(_min, _max);
        emit LimitsUpdated('idealCollateralRatio', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the borrow rate of the pooled credit line
     * @param _min updated value of the minimum threshold value of the borrow rate
     * @param _max updated value of the maximum threshold value of the borrow rate
     */
    function updateBorrowRateLimits(uint256 _min, uint256 _max) external onlyOwner {
        require(_min <= _max, 'PCL:UBRL1');
        require(!(borrowRateLimits.min == _min && borrowRateLimits.max == _max), 'PCL:UBRL2');
        borrowRateLimits = Limits(_min, _max);
        emit LimitsUpdated('borrowRate', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the collection period of the pooled credit line
     * @param _min updated value of the minimum threshold value of the collection period
     * @param _max updated value of the maximum threshold value of the collection period
     */
    function updateCollectionPeriodLimits(uint256 _min, uint256 _max) external onlyOwner {
        require(_min <= _max, 'PCL:UCPL1');
        require(!(collectionPeriodLimits.min == _min && collectionPeriodLimits.max == _max), 'PCL:UCPL2');
        collectionPeriodLimits = Limits(_min, _max);
        emit LimitsUpdated('collectionPeriod', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the duration of the pooled credit line
     * @param _min updated value of the minimum threshold value of the duration
     * @param _max updated value of the maximum threshold value of the duration
     */
    function updateDurationLimits(uint256 _min, uint256 _max) external onlyOwner {
        require(_min <= _max, 'PCL:UDL1');
        require(!(durationLimits.min == _min && durationLimits.max == _max), 'PCL:UDL2');
        durationLimits = Limits(_min, _max);
        emit LimitsUpdated('duration', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the grace period after which pooled credit line defaults
     * @param _min updated value of the minimum threshold value of the default grace period
     * @param _max updated value of the maximum threshold value of the default grace period
     */
    function updateDefaultGracePeriodLimits(uint256 _min, uint256 _max) external onlyOwner {
        require(_min <= _max, 'PCL:UDGPL1');
        require(!(defaultGracePeriodLimits.min == _min && defaultGracePeriodLimits.max == _max), 'PCL:UDGPL2');
        defaultGracePeriodLimits = Limits(_min, _max);
        emit LimitsUpdated('defaultGracePeriod', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the penalty rate in grace period of the pooled credit line
     * @param _min updated value of the minimum threshold value of the penalty rate in grace period
     * @param _max updated value of the maximum threshold value of the penalty rate in grace period
     */
    function updateGracePenaltyRateLimits(uint256 _min, uint256 _max) external onlyOwner {
        require(_min <= _max, 'PCL:UGPRL1');
        require(!(gracePenaltyRateLimits.min == _min && gracePenaltyRateLimits.max == _max), 'PCL:UGPRL2');
        gracePenaltyRateLimits = Limits(_min, _max);
        emit LimitsUpdated('gracePenaltyRate', _min, _max);
    }

    //-------------------------------- Limits code end --------------------------------//

    //-------------------------------- getters start --------------------------------//

    function getIdealCollateralRatioLimits() external view override returns (Limits memory) {
        return idealCollateralRatioLimits;
    }

    function getBorrowRateLimits() external view override returns (Limits memory) {
        return borrowRateLimits;
    }

    function getCollectionPeriodLimits() external view override returns (Limits memory) {
        return collectionPeriodLimits;
    }

    function getDurationLimits() external view override returns (Limits memory) {
        return durationLimits;
    }

    function getDefaultGracePeriodLimits() external view override returns (Limits memory) {
        return defaultGracePeriodLimits;
    }

    function getGracePenaltyRateLimits() external view override returns (Limits memory) {
        return gracePenaltyRateLimits;
    }

    //-------------------------------- getters end --------------------------------//
}",2390
RealWorld_TA_101_PCLClosedState.t_RealWorld_20240812155614.log,101,PCLClosedState.t,545523,4278,549801,156.0,2.813175,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLClosedStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        //The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        // Now we assert that we are in the ACTIVE state
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), 2);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(requestId, currentDebt);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: A Closed PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start a PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral cannot be deposited
    function test_collateralCannotBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try borrower.depositCollateral(requestId, _minimumCollateralRequired, false) {
            revert('Collateral cannot be deposited');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);

        assertApproxEqAbs(_withdrawableCollateral, 0, 2);
    }

    // Test 3.1: Collateral can or cannot be withdrawn
    function test_collateralCanOrCannotBeWithdrawn(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _tokens = (pcl.depositedCollateralInShares(requestId) * ICToken(collateralCTokenAddress).exchangeRateCurrent()) / 1e18;
        if (_tokens > 0) {
            uint256 _borrowerBalanceBefore = collateralAsset.balanceOf(address(borrower));
            borrower.withdrawCollateral(requestId, 1, false);
            uint256 _borrowerBalanceAfter = collateralAsset.balanceOf(address(borrower));
            assertGe(_borrowerBalanceAfter, _borrowerBalanceBefore);
        } else {
            try borrower.withdrawCollateral(requestId, 1, false) {
                revert('Collateral cannot be withdrawn');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:WC1');
            }
        }
    }

    // Test 3.2: All collateral can or cannot be withdrawn
    function test_allCollateralCanOrCannotBeWithdrawn(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _tokens = (pcl.depositedCollateralInShares(requestId) * ICToken(collateralCTokenAddress).exchangeRateCurrent()) / 1e18;
        if (_tokens > 0) {
            uint256 _borrowerBalanceBefore = collateralAsset.balanceOf(address(borrower));
            borrower.withdrawAllCollateral(requestId, false);
            uint256 _borrowerBalanceAfter = collateralAsset.balanceOf(address(borrower));
            assertGe(_borrowerBalanceAfter, _borrowerBalanceBefore);
        } else {
            try borrower.withdrawAllCollateral(requestId, false) {
                revert('All collateral cannot be withdrawn');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:WAC1');
            }
        }
    }

    // Test 4: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: Borrowable amount remains zero
    function test_borrowableAmountIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        assertEq(_borrowableAmount, 0);
    }

    // Test 6: A Closed PCL cannot be closed
    function test_pclCannotBeClosed(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try borrower.close(requestId) {
            revert('PCL cannot be closed');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    // Test 7: Collateral ratio remains infinite
    function test_collateralRatioIsInfinite(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, type(uint256).max);
    }

    // Test 7.1: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero() public {
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.2: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero() public {
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try PCLUser(lender_0).withdrawLiquidation(requestId) {
            revert('Lender cannot withdraw liquidation tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders can withdraw liquidity
    function test_lendersCanWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _userPoolTokenBalance = lp.balanceOf(lender_0, requestId);
        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, lender_0);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _userBorrowTokenBalanceBefore = IERC20(request.borrowAsset).balanceOf(lender_0);
        PCLUser(lender_0).withdrawLiquidity(requestId);
        uint256 _userBorrowTokenBalanceAfter = IERC20(request.borrowAsset).balanceOf(lender_0);
        assertApproxEqRel(_userPoolTokenBalance + _lenderInterestOwed, _userBorrowTokenBalanceAfter - _userBorrowTokenBalanceBefore, 1e16);

        _userPoolTokenBalance = lp.balanceOf(lender_0, requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, lender_0);
        assertEq(_userPoolTokenBalance, 0);
        assertEq(_lenderInterestOwed, 0);
    }

    // Test 10: A Closed PCL cannot be liquidated
    function test_lendersCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // lender_0 tries to liquidate the PCL
        try PCLUser(lender_0).liquidate(requestId, _withdraw) {
            revert('Cannot liquidate a Closed PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 11: Admin can terminate pcl
    function test_adminCanTerminatePCL(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        admin.terminate(requestId);
        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGe((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt(_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate, 0);
    }

    // Test 12: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.1: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);
        uint256 lender1BalanceAfter = borrowAsset.balanceOf(address(lender1));
        assertEq(lender1BalanceAfter, lender1Balance + lender1InterestOwed);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(lender1)), 0);
    }

    // Test 14: A Closed PCL cannot be cancelled
    function test_pclCannotBeCancelled(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try borrower.cancelRequest(requestId) {
            revert('PCL cannot be cancelled');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function assert_helperFunctionalitiesInClosedState(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1));
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertGt(_principalWithdrawable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertApproxEqAbs(_withdrawableCollateral, 0, 2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertApproxEqAbs(_totalCollateral, 0, 2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_helperFunctionsInClosedState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInClosedState(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}",6391
RealWorld_TA_101_Verification_RealWorld_20240812173535.log,101,Verification,191343,2958,194301,106.0,1.015875,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IVerification.sol';

/// @title Contract that handles linking identity of user to address
contract Verification is Initializable, IVerification, OwnableUpgradeable {
    //-------------------------------- Global vars start --------------------------------/

    /// @notice Delay in seconds after which addresses are activated once registered or linked
    uint256 public activationDelay;

    /// @notice Tells whether a given verifier is valid
    /// @dev Mapping that stores valid verifiers as added by admin. verifier -> true/false
    /// @return boolean that represents if the specified verifier is valid
    mapping(address => bool) public override verifiers;

    //-------------------------------- Global vars end --------------------------------/

    //-------------------------------- State vars start --------------------------------/

    struct LinkedAddress {
        uint64 activatesAt;
        address masterAddress;
    }

    /// @notice Maps masterAddress with the verifier that was used to verify it and the time when master address is active
    /// @dev Mapping is from masterAddress -> verifier -> activationTime
    /// @return Verifier used to verify the given master address
    mapping(address => mapping(address => uint256)) public masterAddresses;

    /// @notice Maps linkedAddresses with the master address and activation time
    /// @dev Mapping is linkedAddress -> (MasterAddress, activationTimestamp)
    /// @return Returns the master address and activation time for the linkedAddress
    mapping(address => LinkedAddress) public linkedAddresses;

    /// @notice Maps address to link with the master addres
    /// @dev Mapping is linkedAddress -> MasterAddress -> isPending
    /// @return Returns if linkedAddress has a pending request from master address
    mapping(address => mapping(address => bool)) public pendingLinkAddresses;

    //-------------------------------- State vars end --------------------------------/

    //-------------------------------- Modifiers start --------------------------------/

    /// @notice Prevents anyone other than a valid verifier from calling a function
    modifier onlyVerifier() {
        require(verifiers[msg.sender], 'V:OV1');
        _;
    }

    //-------------------------------- Modifiers end --------------------------------/

    //-------------------------------- Init start --------------------------------/

    /// @notice Initializes the variables of the contract
    /// @dev Contract follows proxy pattern and this function is used to initialize the variables for the contract in the proxy
    /// @param _admin Admin of the verification contract who can add verifiers and remove masterAddresses deemed invalid
    /// @param _activationDelay Delay in seconds after which addresses are registered or linked
    function initialize(address _admin, uint256 _activationDelay) external initializer {
        super.__Ownable_init();
        super.transferOwnership(_admin);
        _updateActivationDelay(_activationDelay);
    }

    //-------------------------------- Init end --------------------------------/

    //-------------------------------- Master Address Mgmt start --------------------------------/

    /// @notice Only verifier can add register master address
    /// @dev Multiple accounts can be linked to master address to act on behalf. Master address can be registered by multiple verifiers
    /// @param _masterAddress address which is registered as verified
    /// @param _isMasterLinked boolean which specifies if the masterAddress has to be added as a linked address
    ///                        _isMasterLinked is used to support users who want to keep the master address as a cold wallet for security
    function registerMasterAddress(address _masterAddress, bool _isMasterLinked) external override onlyVerifier {
        require(masterAddresses[_masterAddress][msg.sender] == 0, 'V:RMA1');
        uint256 _masterAddressActivatesAt = block.timestamp + activationDelay;
        masterAddresses[_masterAddress][msg.sender] = _masterAddressActivatesAt;
        emit UserRegistered(_masterAddress, msg.sender, _masterAddressActivatesAt);

        if (_isMasterLinked) {
            _linkAddress(_masterAddress, _masterAddress);
        }
    }

    /// @notice Master address can be unregistered by registered verifier or owner
    /// @dev unregistering master address doesn't affect linked addreses mapping to master address, though they would not be verified by this verifier anymore
    /// @param _masterAddress address which is being unregistered
    /// @param _verifier verifier address from which master address is unregistered
    function unregisterMasterAddress(address _masterAddress, address _verifier) external override {
        if (msg.sender != super.owner()) {
            require(masterAddresses[_masterAddress][msg.sender] != 0, 'V:UMA1');
            delete masterAddresses[_masterAddress][msg.sender];
        } else {
            delete masterAddresses[_masterAddress][_verifier];
        }
        emit UserUnregistered(_masterAddress, _verifier, msg.sender);
    }

    //-------------------------------- Master Address Mgmt end --------------------------------/

    //-------------------------------- Linked Address Mgmt start --------------------------------/

    /// @notice Used by master address to request linking another address to it
    /// @dev only master address can initiate linking of another address
    /// @param _linkedAddress address which is to be linked
    function requestAddressLinking(address _linkedAddress) external {
        require(linkedAddresses[_linkedAddress].masterAddress == address(0), 'V:RAL1');
        pendingLinkAddresses[_linkedAddress][msg.sender] = true;
        emit AddressLinkingRequested(_linkedAddress, msg.sender);
    }

    /// @notice Used by master address to cancel request linking another address to it
    /// @param  _linkedAddress address which is to be linked
    function cancelAddressLinkingRequest(address _linkedAddress) external {
        require(pendingLinkAddresses[_linkedAddress][msg.sender], 'V:CALR1');
        delete pendingLinkAddresses[_linkedAddress][msg.sender];
        emit AddressLinkingRequestCancelled(_linkedAddress, msg.sender);
    }

    /// @notice Link an address with a master address
    /// @dev Master address to which the address is being linked need not be verified
    ///     link address can only accept the request made by a master address, but can't initiate a linking request
    /// @param _masterAddress master address to link to
    function linkAddress(address _masterAddress) external {
        require(_masterAddress != address(0), 'V:LA1');
        require(linkedAddresses[msg.sender].masterAddress == address(0), 'V:LA2');
        require(pendingLinkAddresses[msg.sender][_masterAddress], 'V:LA3');
        _linkAddress(msg.sender, _masterAddress);
        delete pendingLinkAddresses[msg.sender][_masterAddress];
    }

    /// @notice Unlink address with master address
    /// @dev a single address can be linked to only one master address
    /// @param _linkedAddress Address that is being unlinked
    function unlinkAddress(address _linkedAddress) external {
        address _linkedTo = linkedAddresses[_linkedAddress].masterAddress;
        require(_linkedTo == msg.sender, 'V:UA1');
        delete linkedAddresses[_linkedAddress];
        emit AddressUnlinked(_linkedAddress, _linkedTo);
    }

    function _linkAddress(address _linked, address _master) private {
        uint64 _linkedAddressActivatesAt = uint64(block.timestamp + activationDelay);
        linkedAddresses[_linked] = LinkedAddress(_linkedAddressActivatesAt, _master);
        emit AddressLinked(_linked, _master, _linkedAddressActivatesAt);
    }

    //-------------------------------- Linked Address Mgmt end --------------------------------/

    //-------------------------------- Utils start --------------------------------/

    /// @notice User to verify if an address is linked to a master address that is registered with verifier
    /// @dev view function
    /// @param _user address which has to be checked if mapped against a verified master address
    /// @param _verifier verifier with which master address has to be verified
    /// @return if the user is linke dto a registered master address
    function isUser(address _user, address _verifier) external view override returns (bool) {
        LinkedAddress memory _linkedAddress = linkedAddresses[_user];
        uint256 _masterActivatesAt = masterAddresses[_linkedAddress.masterAddress][_verifier];
        if (
            !verifiers[_verifier] ||
            _linkedAddress.masterAddress == address(0) ||
            _linkedAddress.activatesAt > block.timestamp ||
            _masterActivatesAt > block.timestamp ||
            _masterActivatesAt == 0
        ) {
            return false;
        }
        return true;
    }

    //-------------------------------- Utils end --------------------------------/

    //-------------------------------- Global var setters start --------------------------------/

    /// @notice owner can update activation delay
    /// @param _activationDelay updated value of activation delay for registered/linking addresses in seconds
    function updateActivationDelay(uint256 _activationDelay) external onlyOwner {
        _updateActivationDelay(_activationDelay);
    }

    function _updateActivationDelay(uint256 _activationDelay) private {
        activationDelay = _activationDelay;
        emit ActivationDelayUpdated(_activationDelay);
    }

    /// @notice owner can add new verifier
    /// @dev Verifier can add master address or remove addresses added by it
    /// @param _verifier Address of the verifier contract
    function addVerifier(address _verifier) external onlyOwner {
        require(_verifier != address(0), 'V:AV1');
        require(!verifiers[_verifier], 'V:AV2');
        verifiers[_verifier] = true;
        emit VerifierAdded(_verifier);
    }

    /// @notice owner can remove exisiting verifier
    /// @dev Verifier can add master address or remove addresses added by it
    /// @param _verifier Address of the verifier contract
    function removeVerifier(address _verifier) external onlyOwner {
        require(verifiers[_verifier], 'V:RV1');
        delete verifiers[_verifier];
        emit VerifierRemoved(_verifier);
    }

    //-------------------------------- Global var setters end --------------------------------/
}",2050
RealWorld_TA_101_creditLine.Repayments.t_RealWorld_20240812165340.log,101,creditLine.Repayments.t,608524,4739,613263,157.0,3.1374,"pragma solidity 0.7.6;
pragma abicoder v2;

import './Helpers/CLParent.sol';
import '../../PriceOracle.sol';

import '@openzeppelin/contracts/math/SafeMath.sol';

contract CreditLine_RepaymentTests is CLParent {
    using SafeMath for uint256;

    uint256 creditLineId;
    uint256 amount;

    CreditLine creditLine;
    PriceOracle priceOracle;

    address[] public userList;

    function setUp() public virtual {
        CLSetUp();

        creditLine = CreditLine(creditLineAddress);
        priceOracle = PriceOracle(priceOracleAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = priceOracle.getLatestPrice(address(usdc), address(borrowAsset));

        requestData.requestTo = address(lender);
        // Borrow Asset equivalent of 1,000,000,000 in USD
        requestData.borrowLimit = uint128(uint256(CLConstants.maxBorrowLimit / 1e6).mul(_ratioOfPrices).div(10**_decimals));
        requestData.borrowRate = CLConstants.maxBorrowRate / 1e18;
        requestData.autoLiquidation = false;
        requestData.collateralRatio = CLConstants.maxCollteralRatio / 1e18;
        requestData.borrowAsset = address(borrowAsset);
        requestData.borrowAssetStrategy = noYieldAddress;
        requestData.collateralAsset = address(collateralAsset);
        requestData.collateralStrategy = noYieldAddress;
        requestData.requestAsLender = false;

        // Adding addresses to array
        userList.push(address(admin));
        userList.push(address(borrower));
        userList.push(address(lender));
        userList.push(address(liquidator));

        creditLineId = goToActiveStage();

        amount = 10_000 * 10**(ERC20(address(collateralAsset)).decimals());

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), requestData.borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);

        // Time travel by 10 days
        _increaseBlock(block.timestamp + 10 days);
    }

    //----------------------- Credit line Repay, failing tests -----------------------//

    // Repaying zero amount should fail
    function test_RepayZeroAmount() public {
        try borrower.repay(address(creditLine), creditLineId, 0) {
            revert('REVERT: Cannot repay zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:REP1');
        }
    }

    // Repaying to invalid (not ACTIVE) creditline should fail
    function test_RepayInvalidCreditLine() public {
        // Request a credit line
        uint256 newCreditLineId = borrower.createRequest(address(creditLine), requestData);

        // add balance to user
        admin.transferToken(address(borrowAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(borrowAsset), amount);

        try borrower.repay(address(creditLine), newCreditLineId, amount) {
            revert('REVERT: Cannot repay to invalid creditline');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:REP2');
        }
    }

    // Lender should not be allowed to repay the creditline
    function test_RepayInvalidActor() public {
        // add balance to user
        admin.transferToken(address(borrowAsset), address(lender), amount);
        lender.setAllowance(address(creditLine), address(borrowAsset), amount);

        try lender.repay(address(creditLine), creditLineId, amount) {
            revert('REVERT: Invalid actor cannot repay');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:REP3');
        }
    }

    // Repaying creditline with insufficient balance should fail
    function test_RepayInsufficientBalance() public {
        uint256 toRepay = creditLine.calculateCurrentDebt(creditLineId);
        // add balance to user
        admin.transferToken(address(borrowAsset), address(borrower), toRepay.sub(10));
        borrower.setAllowance(address(creditLine), address(borrowAsset), toRepay.sub(10));

        try borrower.repay(address(creditLine), creditLineId, toRepay) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    //----------------------- Credit line Repay, passing tests -----------------------//

    // Any actor, except lender can repay any amount
    function test_creditLineRepay_RandomUser() public {
        // Testing the function for all the different actors
        for (uint256 i = 0; i < userList.length; i++) {
            if (i == 0) {
                CLAdmin user = CLAdmin(userList[i]);

                // Time travel by 10 days and repay
                _increaseBlock(block.timestamp + 10 days);
                uint256 Interest = creditLine.calculateInterestAccrued(creditLineId);

                // Repay and related checks
                assert_creditLineRepay_amountGTinterest(address(user), creditLineId, address(borrowAsset), Interest.add(100));
            } else {
                CLUser user = CLUser(userList[i]);

                if (userList[i] != address(lender)) {
                    // Time travel by 10 days and repay remaining interest
                    _increaseBlock(block.timestamp + 10 days);
                    uint256 Interest = creditLine.calculateInterestAccrued(creditLineId);
                    (, , uint256 interestRepaid, , ) = creditLine.creditLineVariables(creditLineId);

                    // Repay and related checks
                    assert_creditLineRepay_amountLTEinterest(
                        address(user),
                        creditLineId,
                        address(borrowAsset),
                        Interest.sub(interestRepaid)
                    );
                }
            }
        }
    }

    // Borrower Repaying amount>Interest & amount<Total Debt from Wallet should pass
    function test_creditLineRepay_amountGTInterest(uint128 _repayAmount) public {
        // Checking for variable values
        uint256 Interest = creditLine.calculateInterestAccrued(creditLineId);
        (, uint256 principal, , , ) = creditLine.creditLineVariables(creditLineId);
        uint256 repayAmount = scaleToRange256(_repayAmount, Interest.add(1), principal.add(Interest));

        // Repay and related checks
        assert_creditLineRepay_amountGTinterest(address(borrower), creditLineId, address(borrowAsset), repayAmount);
    }

    // Borrower Repaying amount=Total Debt from Wallet should pass
    function test_creditLineRepay_totalDebt(uint128 _repayAmount) public {
        // Checking for variable values
        uint256 totalCurrentDebt = creditLine.calculateCurrentDebt(creditLineId);
        uint256 repayAmount = scaleToRange256(_repayAmount, totalCurrentDebt, borrowAsset.totalSupply());

        // Repay and related checks
        assert_creditLineRepay_FullDebt(address(borrower), creditLineId, address(borrowAsset), repayAmount);
    }

    // Borrower Repaying amount=Interest from Wallet should pass
    function test_creditLineRepay_interest() public {
        // Checking for variable values
        uint256 Interest = creditLine.calculateInterestAccrued(creditLineId);

        // Repay and related checks
        assert_creditLineRepay_amountLTEinterest(address(borrower), creditLineId, address(borrowAsset), Interest);
    }

    // Borrower Repaying amount<Interest from Wallet should pass
    function test_creditLineRepay_amountLTInterest(uint128 _repayAmount) public {
        // Checking for variable values
        uint256 Interest = creditLine.calculateInterestAccrued(creditLineId);
        uint256 repayAmount = scaleToRange256(_repayAmount, 1, Interest);

        // Repay and related checks
        assert_creditLineRepay_amountLTEinterest(address(borrower), creditLineId, address(borrowAsset), repayAmount);
    }

    // Two installment repayments, repayment completed in two installments

    // 1. Repaying amount<Interest should pass
    // 2. Repaying remaining amount should pass
    function test_creditLineRepay_twoInstallments_1(uint128 _repayAmount) public {
        // Checking for variable values
        uint256 Interest = creditLine.calculateInterestAccrued(creditLineId);
        uint256 repayAmount = scaleToRange256(_repayAmount, 1, Interest);
        // Repay and related checks
        assert_creditLineRepay_amountLTEinterest(address(borrower), creditLineId, address(borrowAsset), repayAmount);

        // Time travel by 10 days
        _increaseBlock(block.timestamp + 10 days);

        // Repay and related checks
        uint256 remainingRepayment = creditLine.calculateCurrentDebt(creditLineId);
        assert_creditLineRepay_FullDebt(address(borrower), creditLineId, address(borrowAsset), remainingRepayment);
    }

    // 1. Repaying amount=Interest should pass
    // 2. Repaying remaining amount should pass
    function test_creditLineRepay_twoInstallments_2() public {
        // Checking for variable values
        uint256 Interest = creditLine.calculateInterestAccrued(creditLineId);

        // Repay and related checks
        assert_creditLineRepay_amountLTEinterest(address(borrower), creditLineId, address(borrowAsset), Interest);

        // Time travel by 10 days
        _increaseBlock(block.timestamp + 10 days);

        // Repay and related checks
        uint256 remainingRepayment = creditLine.calculateCurrentDebt(creditLineId);
        assert_creditLineRepay_FullDebt(address(borrower), creditLineId, address(borrowAsset), remainingRepayment);
    }

    // 1. Repaying amount>Interest should pass
    // 2. Repaying remaining amount should pass
    function test_creditLineRepay_twoInstallments_3(uint128 _repayAmount) public {
        // Checking for variable values
        uint256 Interest = creditLine.calculateInterestAccrued(creditLineId);
        uint256 debt = creditLine.calculateCurrentDebt(creditLineId);
        uint256 repayAmount = scaleToRange256(_repayAmount, Interest.add(1), debt);
        // Repay and related checks
        assert_creditLineRepay_amountGTinterest(address(borrower), creditLineId, address(borrowAsset), repayAmount);

        // Time travel by 10 days
        _increaseBlock(block.timestamp + 10 days);

        // Repay and related checks
        uint256 remainingRepayment = creditLine.calculateCurrentDebt(creditLineId);
        assert_creditLineRepay_FullDebt(address(borrower), creditLineId, address(borrowAsset), remainingRepayment);
    }

    // Three installment repayments, incomplete repayment in three installments

    // 1. Repaying amount=Interest should pass
    // 2. Repaying amount=Interest should pass
    // 3. Repaying remaining amount should pass
    function test_creditLineRepay_threeInstallments_1() public {
        // Checking for variable values
        uint256 Interest = creditLine.calculateInterestAccrued(creditLineId);

        // Repay and related checks
        assert_creditLineRepay_amountLTEinterest(address(borrower), creditLineId, address(borrowAsset), Interest);

        // Time travel by 10 days
        _increaseBlock(block.timestamp + 10 days);

        // Checking for variable values
        uint256 interestToRepay = creditLine.calculateInterestAccrued(creditLineId);
        (, , uint256 interestRepaid, , ) = creditLine.creditLineVariables(creditLineId);
        // Repay and related checks
        assert_creditLineRepay_amountLTEinterest(
            address(borrower),
            creditLineId,
            address(borrowAsset),
            interestToRepay.sub(interestRepaid)
        );

        // Time travel by 10 days
        _increaseBlock(block.timestamp + 10 days);

        // Repay and related checks
        uint256 remainingRepayment = creditLine.calculateCurrentDebt(creditLineId);
        assert_creditLineRepay_FullDebt(address(borrower), creditLineId, address(borrowAsset), remainingRepayment);
    }

    // 1. Repaying amount>Interest should pass
    // 2. Repaying amount>Interest should pass
    // 3. Repaying remaining amount should pass
    function test_creditLineRepay_threeInstallments_2(uint128 _repay1, uint128 _repay2) public {
        // Checking for variable values
        uint256 Interest = creditLine.calculateInterestAccrued(creditLineId);
        uint256 debt = creditLine.calculateCurrentDebt(creditLineId);
        uint256 repay1 = scaleToRange256(_repay1, Interest.add(1), debt);
        // Repay and related checks
        assert_creditLineRepay_amountGTinterest(address(borrower), creditLineId, address(borrowAsset), repay1);

        // Time travel by 10 days
        _increaseBlock(block.timestamp + 10 days);

        // Checking for variable values
        uint256 interestToRepay = creditLine.calculateInterestAccrued(creditLineId);
        (, , uint256 interestRepaid, , ) = creditLine.creditLineVariables(creditLineId);
        debt = creditLine.calculateCurrentDebt(creditLineId);
        uint256 repay2 = scaleToRange256(_repay2, interestToRepay.sub(interestRepaid).add(1), debt);
        // Repay and related checks
        assert_creditLineRepay_amountGTinterest(address(borrower), creditLineId, address(borrowAsset), repay2);

        // Time travel by 10 days
        _increaseBlock(block.timestamp + 10 days);

        // Repay and related checks
        debt = creditLine.calculateCurrentDebt(creditLineId);
        assert_creditLineRepay_FullDebt(address(borrower), creditLineId, address(borrowAsset), debt);
    }

    // 1. Repaying amount<Interest should pass
    // 2. Repaying amount<Interest should pass
    // 3. Repaying remaining amount should pass
    function test_creditLineRepay_threeInstallments_3(uint128 _repay1, uint128 _repay2) public {
        // Checking for variable values
        uint256 Interest = creditLine.calculateInterestAccrued(creditLineId);
        uint256 repay1 = scaleToRange256(_repay1, 1, Interest);
        // Repay and related checks
        assert_creditLineRepay_amountLTEinterest(address(borrower), creditLineId, address(borrowAsset), repay1);

        // Time travel by 10 days
        _increaseBlock(block.timestamp + 10 days);

        // Checking for variable values
        uint256 interestToRepay = creditLine.calculateInterestAccrued(creditLineId);
        (, , uint256 interestRepaid, , ) = creditLine.creditLineVariables(creditLineId);
        uint256 repay2 = scaleToRange256(_repay2, 1, interestToRepay.sub(interestRepaid));
        // Repay and related checks
        assert_creditLineRepay_amountLTEinterest(address(borrower), creditLineId, address(borrowAsset), repay2);

        // Time travel by 10 days
        _increaseBlock(block.timestamp + 10 days);

        // Repay and related checks
        uint256 remainingRepayment = creditLine.calculateCurrentDebt(creditLineId);
        assert_creditLineRepay_FullDebt(address(borrower), creditLineId, address(borrowAsset), remainingRepayment);
    }

    // 1. Repaying amount>Interest should pass
    // 2. Repaying amount<Interest should pass
    // 3. Repaying remaining amount should pass
    function test_creditLineRepay_threeInstallments_4(uint128 _repay1, uint128 _repay2) public {
        // Checking for variable values
        uint256 Interest = creditLine.calculateInterestAccrued(creditLineId);
        uint256 debt = creditLine.calculateCurrentDebt(creditLineId);
        uint256 repay1 = scaleToRange256(_repay1, Interest.add(1), debt);

        // Repay and related checks
        assert_creditLineRepay_amountGTinterest(address(borrower), creditLineId, address(borrowAsset), repay1);

        // Time travel by 10 days
        _increaseBlock(block.timestamp + 10 days);

        // Checking for variable values
        uint256 interestToRepay = creditLine.calculateInterestAccrued(creditLineId);
        (, , uint256 interestRepaid, , ) = creditLine.creditLineVariables(creditLineId);
        if (interestToRepay.sub(interestRepaid) > 1) {
            uint256 repay2 = scaleToRange256(_repay2, 1, interestToRepay.sub(interestRepaid));
            // Repay and related checks
            assert_creditLineRepay_amountLTEinterest(address(borrower), creditLineId, address(borrowAsset), repay2);

            // Time travel by 10 days
            _increaseBlock(block.timestamp + 10 days);

            // Repay and related checks
            debt = creditLine.calculateCurrentDebt(creditLineId);
            assert_creditLineRepay_FullDebt(address(borrower), creditLineId, address(borrowAsset), debt);
        }
    }

    // 1. Repaying amount<Interest should pass
    // 2. Repaying amount>Interest should pass
    // 3. Repaying remaining amount should pass
    function test_creditLineRepay_threeInstallments_5(uint128 _repay1, uint128 _repay2) public {
        // Checking for variable values
        uint256 Interest = creditLine.calculateInterestAccrued(creditLineId);
        uint256 repay1 = scaleToRange256(_repay1, 1, Interest);
        // Repay and related checks
        assert_creditLineRepay_amountLTEinterest(address(borrower), creditLineId, address(borrowAsset), repay1);

        // Time travel by 10 days
        _increaseBlock(block.timestamp + 10 days);

        // Checking for variable values
        uint256 interestToRepay = creditLine.calculateInterestAccrued(creditLineId);
        (, , uint256 interestRepaid, , ) = creditLine.creditLineVariables(creditLineId);
        uint256 debt = creditLine.calculateCurrentDebt(creditLineId);
        uint256 repay2 = scaleToRange256(_repay2, interestToRepay.sub(interestRepaid).add(1), debt);
        // Repay and related checks
        assert_creditLineRepay_amountGTinterest(address(borrower), creditLineId, address(borrowAsset), repay2);

        // Time travel by 10 days
        _increaseBlock(block.timestamp + 10 days);

        // Repay and related checks
        debt = creditLine.calculateCurrentDebt(creditLineId);
        assert_creditLineRepay_FullDebt(address(borrower), creditLineId, address(borrowAsset), debt);
    }

    //----------------------- Credit line Repay, Assert helper -----------------------//

    function assert_creditLineRepay_FullDebt(
        address _user,
        uint256 _creditLineId,
        address _asset,
        uint256 _amount
    ) public {
        uint256 currentDebt = creditLine.calculateCurrentDebt(_creditLineId);

        if (_user == address(admin)) {
            // initialize the user
            CLAdmin user = CLAdmin(_user);

            // add balance to user
            user.setAllowance(address(creditLine), _asset, _amount);

            // getting balance of the user before repayment
            uint256 balanceBefore = IERC20(_asset).balanceOf(_user);

            // repay the credit line
            user.repay(address(creditLine), _creditLineId, _amount);

            // getting the balance after repayment
            uint256 balanceAfter = IERC20(_asset).balanceOf(_user);

            // assert: balance change for user should be equal to amount repaid
            uint256 balanceDiff = balanceBefore.sub(balanceAfter);
            assertEq(balanceDiff, currentDebt);
        } else {
            // initialize the user
            CLUser user = CLUser(_user);

            // add balance to user
            admin.transferToken(_asset, _user, _amount);
            user.setAllowance(address(creditLine), _asset, _amount);

            // getting balance of the user before repayment
            uint256 balanceBefore = IERC20(_asset).balanceOf(_user);

            // repay the credit line
            user.repay(address(creditLine), _creditLineId, _amount);

            // getting the balance after repayment
            uint256 balanceAfter = IERC20(_asset).balanceOf(_user);

            // assert: balance change for user should be equal to amount repaid
            uint256 balanceDiff = balanceBefore.sub(balanceAfter);
            assertEq(balanceDiff, currentDebt);
        }

        // checking the variable updates after repayment
        (
            ,
            uint256 principal,
            uint256 totalInterestRepaid,
            uint256 lastPrincipalUpdateTime,
            uint256 interestAccruedTillLastPrincipalUpdate
        ) = creditLine.creditLineVariables(_creditLineId);

        // if total debt is repaid, credit line is reset
        assertEq(principal, 0);
        assertEq(totalInterestRepaid, 0);
        assertEq(lastPrincipalUpdateTime, 0);
        assertEq(interestAccruedTillLastPrincipalUpdate, 0);
    }

    function assert_creditLineRepay_amountGTinterest(
        address _user,
        uint256 _creditLineId,
        address _asset,
        uint256 _amount
    ) public {
        uint256 interest = creditLine.calculateInterestAccrued(_creditLineId);
        uint256 currentDebt = creditLine.calculateCurrentDebt(_creditLineId);

        if (_user == address(admin)) {
            // initialize the user
            CLAdmin user = CLAdmin(_user);

            // add balance to user
            user.setAllowance(address(creditLine), _asset, _amount);

            // getting balance of the user before repayment
            uint256 balanceBefore = IERC20(_asset).balanceOf(_user);

            // repay the credit line
            user.repay(address(creditLine), _creditLineId, _amount);

            // getting the balance after repayment
            uint256 balanceAfter = IERC20(_asset).balanceOf(_user);

            // assert: balance change for user should be equal to amount repaid
            uint256 balanceDiff = balanceBefore.sub(balanceAfter);
            assertEq(balanceDiff, _amount);
        } else {
            // initialize the user
            CLUser user = CLUser(_user);

            // add balance to user
            admin.transferToken(_asset, _user, _amount);
            user.setAllowance(address(creditLine), _asset, _amount);

            // getting balance of the user before repayment
            uint256 balanceBefore = IERC20(_asset).balanceOf(_user);

            // repay the credit line
            user.repay(address(creditLine), _creditLineId, _amount);

            // getting the balance after repayment
            uint256 balanceAfter = IERC20(_asset).balanceOf(_user);

            // assert: balance change for user should be equal to amount repaid
            uint256 balanceDiff = balanceBefore.sub(balanceAfter);
            assertEq(balanceDiff, _amount);
        }

        // checking the variable updates after repayment
        (
            ,
            uint256 principal,
            uint256 totalInterestRepaid,
            uint256 lastPrincipalUpdateTime,
            uint256 interestAccruedTillLastPrincipalUpdate
        ) = creditLine.creditLineVariables(_creditLineId);

        // all variables are updated, principal updated
        assertEq(principal, currentDebt.sub(_amount));
        assertEq(totalInterestRepaid, interest);
        assertEq(lastPrincipalUpdateTime, block.timestamp);
        assertEq(interestAccruedTillLastPrincipalUpdate, interest);
    }

    function assert_creditLineRepay_amountLTEinterest(
        address _user,
        uint256 _creditLineId,
        address _asset,
        uint256 _amount
    ) public {
        (
            ,
            uint256 principalBefore,
            uint256 interestRepaid,
            uint256 prinipalUpdateTime,
            uint256 interestTillLastPrincipalUpdate
        ) = creditLine.creditLineVariables(_creditLineId);

        if (_user == address(admin)) {
            // initialize the user
            CLAdmin user = CLAdmin(_user);

            // add balance to user
            user.setAllowance(creditLineAddress, _asset, _amount);

            // getting balance of the user before repayment
            uint256 balanceBefore = IERC20(_asset).balanceOf(_user);

            // repay the credit line
            user.repay(creditLineAddress, _creditLineId, _amount);

            // getting the balance after repayment
            uint256 balanceAfter = IERC20(_asset).balanceOf(_user);

            // assert: balance change for user should be equal to amount repaid
            assertEq(balanceBefore.sub(balanceAfter), _amount);
        } else {
            // initialize the user
            CLUser user = CLUser(_user);

            // add balance to user
            admin.transferToken(_asset, _user, _amount);
            user.setAllowance(creditLineAddress, _asset, _amount);

            // getting balance of the user before repayment
            uint256 balanceBefore = IERC20(_asset).balanceOf(_user);

            // repay the credit line
            user.repay(creditLineAddress, _creditLineId, _amount);

            // getting the balance after repayment
            uint256 balanceAfter = IERC20(_asset).balanceOf(_user);

            // assert: balance change for user should be equal to amount repaid
            assertEq(balanceBefore.sub(balanceAfter), _amount);
        }

        // checking the variable updates after repayment
        (
            ,
            uint256 principal,
            uint256 totalInterestRepaid,
            uint256 lastPrincipalUpdateTime,
            uint256 interestAccruedTillLastPrincipalUpdate
        ) = creditLine.creditLineVariables(_creditLineId);

        // only repaid interest is updated
        assertEq(principal, principalBefore);
        assertEq(totalInterestRepaid, interestRepaid.add(_amount));
        assertEq(lastPrincipalUpdateTime, prinipalUpdateTime);
        assertEq(interestAccruedTillLastPrincipalUpdate, interestTillLastPrincipalUpdate);
    }

    //----------------------- Credit line close, failing tests -----------------------//

    // Invalid actor should not be able to close creditline
    function test_CloseInvalidActor() public {
        // Checking for variable values
        uint256 toRepay = creditLine.calculateCurrentDebt(creditLineId);

        // Repay and related checks
        assert_creditLineRepay_FullDebt(address(borrower), creditLineId, address(borrowAsset), toRepay);

        // Testing the function for all the different actors
        for (uint256 i = 0; i < userList.length; i++) {
            if (i == 0) {
                CLAdmin user = CLAdmin(userList[i]);

                try user.close(address(creditLine), creditLineId) {
                    revert('REVERT: Admin cannot close credit line');
                } catch Error(string memory reason) {
                    assertEq(reason, 'CL:C2');
                }
            } else {
                CLUser user = CLUser(userList[i]);

                if (!(userList[i] == address(lender) || userList[i] == address(borrower))) {
                    try user.close(address(creditLine), creditLineId) {
                        revert('REVERT: Invalid actor cannot close credit line');
                    } catch Error(string memory reason) {
                        assertEq(reason, 'CL:C2');
                    }
                }
            }
        }
    }

    // Closing invalid creditline should fail (REQUESTED status)
    function test_CloseInvalidCreditLineStatus() public {
        uint256 RequestedCL = borrower.createRequest(address(creditLine), requestData);

        try lender.close(address(creditLine), RequestedCL) {
            revert('REVERT: Cannot close invalid creditline');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:C1');
        }
    }

    // Cannot close creditline when principal is not repaid
    function test_CloseInvalidPrincipalState() public {
        try borrower.close(address(creditLine), creditLineId) {
            revert('REVERT: Cannot close if principal is not repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:C3');
        }
    }

    //----------------------- Credit line close, passing tests -----------------------//

    // Borrower should be able to close creditline
    function test_creditLineClose_asBorrower() public {
        // Checking for variable values
        uint256 toRepay = creditLine.calculateCurrentDebt(creditLineId);
        assert_creditLineRepay_FullDebt(address(borrower), creditLineId, address(borrowAsset), toRepay);

        assert_creditLineClose(address(borrower), creditLineId);
    }

    // Lender should be able to close creditline
    function test_creditLineClose_asLender() public {
        // Checking for variable values
        uint256 toRepay = creditLine.calculateCurrentDebt(creditLineId);
        assert_creditLineRepay_FullDebt(address(borrower), creditLineId, address(borrowAsset), toRepay);

        assert_creditLineClose(address(lender), creditLineId);
    }

    // Borrower should be able to close credit line, with multiple repayments
    function test_Close_asBorrower_multipleRepayments() public {
        // 1st repayment
        uint256 Interest = creditLine.calculateInterestAccrued(creditLineId);
        assert_creditLineRepay_amountLTEinterest(address(borrower), creditLineId, address(borrowAsset), Interest.sub(10));

        // 2nd repayment
        uint256 toRepay = creditLine.calculateCurrentDebt(creditLineId);
        assert_creditLineRepay_FullDebt(address(borrower), creditLineId, address(borrowAsset), toRepay);

        assert_creditLineClose(address(borrower), creditLineId);
    }

    // Lender should be able to close credit line, with multiple repayments
    function test_Close_asLender_multipleRepayments() public {
        // 1st repayment
        uint256 Interest = creditLine.calculateInterestAccrued(creditLineId);
        assert_creditLineRepay_amountLTEinterest(address(borrower), creditLineId, address(borrowAsset), Interest.sub(10));

        // 2nd repayment
        uint256 toRepay = creditLine.calculateCurrentDebt(creditLineId);
        assert_creditLineRepay_FullDebt(address(borrower), creditLineId, address(borrowAsset), toRepay);

        assert_creditLineClose(address(lender), creditLineId);
    }

    // Borrower should be able to close credit line in active stage before borrowing
    function test_creditLineClose_activeStage_asBorrower() public {
        // Go to active stage
        uint256 newCreditLine = goToActiveStage();

        assert_creditLineClose(address(borrower), newCreditLine);
    }

    // Lender should be able to close credit line in active stage before borrowing
    function test_creditLineClose_activeStage_asLender() public {
        // Go to active stage
        uint256 newCreditLine = goToActiveStage();

        assert_creditLineClose(address(lender), newCreditLine);
    }

    //----------------------- Credit line close, passing tests -----------------------//

    function assert_creditLineClose(address _user, uint256 _creditLineId) public {
        CLUser user = CLUser(_user);

        uint256 withdrawable = creditLine.withdrawableCollateral(_creditLineId);

        uint256 borrowerBalance = collateralAsset.balanceOf(address(borrower));
        user.close(address(creditLine), _creditLineId);
        uint256 borrowerBalanceAfter = collateralAsset.balanceOf(address(borrower));

        uint256 borrowerBalanceDiff = borrowerBalanceAfter.sub(borrowerBalance);

        assertApproxEqAbs(borrowerBalanceDiff, withdrawable, 1);

        uint256 status = uint256(creditLine.getCreditLineStatus(_creditLineId));
        assertEq(status, 0); // Credit Line variable are deleted
    }
}",7061
RealWorld_TA_101_ITwitterVerifier_RealWorld_20240812181822.log,101,ITwitterVerifier,24930,1787,26717,71.0,0.16039,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface ITwitterVerifier {
    function registerSelf(
        bool _isMasterLinked,
        uint8 _v,
        bytes32 _r,
        bytes32 _s,
        string memory _twitterId,
        uint256 _deadline
    ) external;

    function unregisterSelf() external;
}",76
RealWorld_TA_101_PCLTerminatedStage.t_RealWorld_20240812145822.log,101,PCLTerminatedStage.t,125466,3462,128928,98.0,0.69657,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';
import './PCLNotCreatedStage.t.sol';

contract PCLTerminatedStage is PCLNotCreatedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public virtual override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * (10**ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), collateralToDeposit);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_timeWarp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.setAllowance(address(pcl), address(borrowAsset), interestAccrued + 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        admin.terminate(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED, '!Terminated');
        notCreatedRequestId = requestId;
    }

    function test_lenderCannotLiquidateANotCreatedPCL() public override {
        assert_liquidate_functionality_in_notCreated_state(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a notCreated PCL',
            'PCL:L1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_notcreatedState() public override {
        assert_withdraw_liquidation_in_notcreated_state(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from a notcreated PCL',
            'LP:IWLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromANotCreatedPCL() public override {
        assert_withdraw_liquidity_functionality_in_NotCreated_state(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.NOT_CREATED),
            false,
            'Lender cannot withdraw liquidity a PCL in NotCreated state',
            'LP:IWL3'
        );
    }
}",1274
RealWorld_TA_101_CLConstants_RealWorld_20240812172152.log,101,CLConstants,52676,1557,54233,71.0,0.29452,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

library CLConstants {
    uint128 constant minBorrowLimit = 1e8; // $100
    uint128 constant maxBorrowLimit = 1e15; // $1,000,000,000

    uint128 constant minCollateralRatio = 1;
    uint128 constant maxCollteralRatio = 1e30;

    uint128 constant minBorrowRate = 1;
    uint128 constant maxBorrowRate = 1e30;

    uint256 public constant maxStrategies = 10;

    uint256 public constant protocolFeeFraction = 10e16;

    uint256 public constant liquidatorRewardFraction = 10e15;

    uint32 public constant uniswapPriceAveragingPeriod = 10;

    address public constant hevmAddress = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;
    address public constant BAT = 0x0D8775F648430679A709E98d2b0Cb6250d2887EF;
    address public constant USDC = 0xb7a4F3E9097C08dA09517b5aB877F7a917224ede;

    struct CreditLineConstants {
        bool autoLiquidation;
        bool requestByLender;
        uint256 borrowLimit;
        uint256 borrowRate;
        uint256 idealCollateralRatio;
        address lender;
        address borrower;
        address borrowAsset;
        address borrowAssetStrategy;
        address collateralAsset;
        address collateralStrategy;
    }

    struct RequestParams {
        address requestTo;
        uint128 borrowLimit;
        uint128 borrowRate;
        bool autoLiquidation;
        uint256 collateralRatio;
        address borrowAsset;
        address borrowAssetStrategy;
        address collateralAsset;
        address collateralStrategy;
        bool requestAsLender;
    }
}",413
RealWorld_TA_101_ICEther_RealWorld_20240812183225.log,101,ICEther,22632,1069,23701,61.0,0.13454,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface ICEther {
    function mint() external payable;

    function redeem(uint256 redeemTokens) external returns (uint256);

    function getCash() external returns (uint256);
}",53
RealWorld_TA_101_PCLCancelledState.t_RealWorld_20240812143742.log,101,PCLCancelledState.t,398118,3449,401567,119.0,2.05957,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLCancelledStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;
    address lender_0;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5000 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED, '!Requested');

        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        lender_0 = lenders[0].lenderAddress;

        // Borrower tries to cancel the PCL
        borrower.cancelRequest(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED, '!Cancelled');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED, '!Cancelled');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: A cancelled PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start a cancelled PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral cannot be deposited
    function test_collateralCannotBeDeposited() public {
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), 100);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        try borrower.depositCollateral(requestId, 100, false) {
            revert('Collateral cannot be deposited');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Collateral cannot be withdrawn
    function test_collateralCannotBeWithdrawn() public {
        helper_exchangeRateChanges();

        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Collateral cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    // Test 5: All Collateral cannot be withdrawn
    function test_allCollateralCannotBeWithdrawn() public {
        helper_exchangeRateChanges();

        try borrower.withdrawAllCollateral(requestId, false) {
            revert('All collateral cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    // Test 6: A cancelled PCL cannot be closed
    function test_pclCannotBeClosed() public {
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('PCL cannot be closed');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    // Test 7: Required collateral should not work
    function test_requiredCollateralReverts() public {
        helper_exchangeRateChanges();

        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    // Test 8: Collateral tokens calculation should not work
    function test_totalCollateralTokensReverts() public {
        helper_exchangeRateChanges();

        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CTCT1');
        }
    }

    // Test 9: Collateral ratio should not work
    function test_collateralRatioReverts() public {
        helper_exchangeRateChanges();

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Calculate collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    // Test 10: A cancelled PCL cannnot be cancelled
    function test_pclCannotBeCancelled() public {
        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('PCL cannot be cancelled');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    // Test 11: Admin should not be able to terminate
    function test_adminCannotTerminatePCL() public {
        helper_exchangeRateChanges();

        // Admin terminates the PCL
        try admin.terminate(requestId) {
            revert('Admin cannot terminate a cancelled PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CTCT1');
        }
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        helper_exchangeRateChanges();

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower cannot repay
    function test_borrowerCannotRepay() public {
        helper_exchangeRateChanges();

        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        try borrower.repay(requestId, 1) {
            revert('Borrower cannot repay');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    // Test 14: A cancelled PCL cannot be liquidated
    function test_lendersCannotLiquidate(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate a cancelled PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 15: Lenders cannot withdraw liquidation
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from a cancelled PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders can withdraw liquidity
    function test_lendersCanWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _userPoolTokenBalance = lp.balanceOf(address(_lender0), requestId);

        helper_exchangeRateChanges();

        uint256 _userBorrowTokenBalanceBefore = IERC20(request.borrowAsset).balanceOf(address(_lender0));
        _lender0.withdrawLiquidity(requestId);
        uint256 _userBorrowTokenBalanceAfter = IERC20(request.borrowAsset).balanceOf(address(_lender0));
        assertEq(_userPoolTokenBalance, _userBorrowTokenBalanceAfter - _userBorrowTokenBalanceBefore);

        _userPoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        assertEq(_userPoolTokenBalance, 0);
    }

    // Test 17: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest cannot be withdrawn amidst exchange rate fluctuations
    function test_lendersCannotWithdrawInterest() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        helper_exchangeRateChanges();

        try lender1.withdrawInterest(requestId) {
            revert('Interest cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalities(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CANCELLED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, lp.balanceOf(address(_lender), requestId));

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        try _borrower.calculateTotalCollateralTokens(_id) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CTCT1');
        }

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id)) {
            revert('Collateral tokens to liquidate should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CTTL1');
        }

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CANCELLED);
    }

    function test_helperFunctions() public {
        assert_helperFunctionalities(requestId);
    }
}",4554
RealWorld_TA_101_PCLClosedState.t_RealWorld_20240812142828.log,101,PCLClosedState.t,522136,4634,526770,145.0,2.70336,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLClosedStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    address lender_0;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(requestId, currentDebt);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: A closed PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start a closed PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral cannot be deposited
    function test_collateralCannotBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        try borrower.depositCollateral(requestId, _minimumCollateralRequired, false) {
            revert('Collateral cannot be deposited');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);

        assertApproxEqAbs(_withdrawableCollateral, 0, 2);
    }

    // Test 4: Balance remains same after withdrawing collateral
    function test_balanceRemainsSameAfterWithdrawCollateral() public {
        helper_exchangeRateChanges();
        uint256 _borrowerBalanceBefore = collateralAsset.balanceOf(address(borrower));
        uint256 _tokens = (pcl.depositedCollateralInShares(requestId) * ICToken(collateralCTokenAddress).exchangeRateCurrent()) / 1e18;
        if (_tokens > 0) {
            borrower.withdrawCollateral(requestId, 1, false);
        } else {
            try borrower.withdrawCollateral(requestId, 1, false) {
                revert('Collateral cannot be withdrawn');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:WC1');
            }
        }
        uint256 _borrowerBalanceAfter = collateralAsset.balanceOf(address(borrower));
        assertApproxEqAbs(_borrowerBalanceAfter, _borrowerBalanceBefore, 2);
    }

    // Test 5: Balance remains same after withdrawing all collateral
    function test_balanceRemainsSameAfterWithdrawAllCollateral() public {
        helper_exchangeRateChanges();
        uint256 _borrowerBalanceBefore = collateralAsset.balanceOf(address(borrower));
        uint256 _tokens = (pcl.depositedCollateralInShares(requestId) * ICToken(collateralCTokenAddress).exchangeRateCurrent()) / 1e18;
        if (_tokens > 0) {
            borrower.withdrawAllCollateral(requestId, false);
        } else {
            try borrower.withdrawAllCollateral(requestId, false) {
                revert('All Collateral cannot be withdrawn');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:WAC1');
            }
        }
        uint256 _borrowerBalanceAfter = collateralAsset.balanceOf(address(borrower));
        assertApproxEqAbs(_borrowerBalanceAfter, _borrowerBalanceBefore, 2);
    }

    // Test 6: A closed PCL cannot be closed
    function test_pclCannotBeClosed() public {
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('PCL cannot be closed');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens remains zero if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensRemainsZeroIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        assertApproxEqAbs(_collateralTokens, 0, 2);
    }

    // Test 8.1: Collateral tokens may revert if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensMayRevertIfCollateralCTokenExchangeRateDecreasesToZero() public {
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        uint256 _shares = pcl.depositedCollateralInShares(requestId);
        if (_shares > 0) {
            try pcl.calculateTotalCollateralTokens(requestId) {
                revert('Total collateral tokens should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'CY:GTFS1');
            }
        } else {
            uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
            assertEq(_collateralTokens, 0);
        }
    }

    // Test 9: Collateral ratio remains infinite
    function test_collateralRatioIsInfinite() public {
        helper_exchangeRateChanges();
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, type(uint256).max);
    }

    // Test 10: A Closed PCL cannot be cancelled
    function test_pclCannotBeCancelled() public {
        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('PCL cannot be cancelled');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin can terminate pcl
    function test_adminCanTerminatePCL() public {
        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        admin.terminate(requestId);
        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGe((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt(_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate, 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        helper_exchangeRateChanges();

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower cannot repay
    function test_borrowerCannotRepay() public {
        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        try borrower.repay(requestId, 1) {
            revert('Borrower cannot repay');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    // Test 14: A requested PCL cannot be liquidated
    function test_lendersCannotLiquidate(bool _withdraw) public {
        helper_exchangeRateChanges();

        // lender_0 tries to liquidate the PCL
        try PCLUser(lender_0).liquidate(requestId, _withdraw) {
            revert('Cannot liquidate a closed PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 15: Lenders cannot withdraw liquidated collateral tokens
    function test_lendersCannotWithdrawLiquidation() public {
        helper_exchangeRateChanges();

        // lender_0 tries to withdraw the liquidated collateral tokens
        try PCLUser(lender_0).withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from a closed PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders can withdraw liquidity
    function test_lendersCanWithdrawLiquidity() public {
        helper_exchangeRateChanges();

        uint256 _userPoolTokenBalance = lp.balanceOf(lender_0, requestId);
        uint256 _userInterestOwed = lp.getLenderInterestWithdrawable(requestId, lender_0);

        uint256 _userBorrowTokenBalanceBefore = IERC20(request.borrowAsset).balanceOf(lender_0);
        PCLUser(lender_0).withdrawLiquidity(requestId);
        uint256 _userBorrowTokenBalanceAfter = IERC20(request.borrowAsset).balanceOf(lender_0);
        assertApproxEqRel(
            _userPoolTokenBalance + _userInterestOwed,
            _userBorrowTokenBalanceAfter - _userBorrowTokenBalanceBefore,
            0.0001e18
        );

        _userPoolTokenBalance = lp.balanceOf(lender_0, requestId);
        _userInterestOwed = lp.getLenderInterestWithdrawable(requestId, lender_0);
        assertEq(_userPoolTokenBalance, 0);
        assertEq(_userInterestOwed, 0);
    }

    // Test 17: Pool token transfers should be possible in a closed PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in a closed PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInClosedState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = lp.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, lp.balanceOf(address(_lender), requestId));

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertApproxEqAbs(_withdrawableCollateral, 0, 2);

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertApproxEqAbs(_totalCollateral, 0, 2);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_helperFunctionsInClosedState() public {
        assert_helperFunctionalitiesInClosedState(requestId);
    }
}",6095
RealWorld_TA_101_CreditLineEthUtils_RealWorld_20240812173116.log,101,CreditLineEthUtils,41158,2635,43793,97.0,0.25849,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '../interfaces/IWETH9.sol';
import '../interfaces/ICreditLine.sol';

contract CreditLineEthUtils {
    IWETH9 public immutable weth;
    ICreditline public immutable creditlines;

    constructor(address _weth, address _creditLines) {
        require(_weth != address(0), 'CLEU:C1');
        require(_creditLines != address(0), 'CLEU:C2');
        weth = IWETH9(_weth);
        creditlines = ICreditline(_creditLines);
    }

    function depositEthAsCollateralToCreditLine(uint256 _id) external payable {
        require(msg.value != 0, 'CLEU:DECCL1');
        weth.deposit{value: msg.value}();
        weth.approve(address(creditlines), msg.value);
        creditlines.depositCollateral(_id, msg.value, false);
    }

    function repayEthToCreditLines(uint256 _id) external payable {
        require(msg.value != 0, 'CLEU:RECL1');
        weth.deposit{value: msg.value}();
        weth.approve(address(creditlines), msg.value);
        creditlines.repay(_id, msg.value);
    }
}",273
RealWorld_TA_101_IPooledCreditLine_RealWorld_20240812182841.log,101,IPooledCreditLine,33864,1983,35847,73.0,0.20898,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '../interfaces/IPooledCreditLineDeclarations.sol';

interface IPooledCreditLine is IPooledCreditLineDeclarations {
    function accept(
        uint256 _id,
        uint256 _amount,
        address _by
    ) external;

    function liquidate(uint256 _id) external returns (address, uint256);

    function getPrincipal(uint256 _id) external view returns (uint256);

    function getBorrowerAddress(uint256 _id) external view returns (address);

    function getEndsAt(uint256 _id) external view returns (uint256);

    function cancelRequestOnLowCollection(uint256 _id) external;

    function cancelRequestOnRequestedStateAtEnd(uint256 _id) external;

    function getStatusAndUpdate(uint256 _id) external returns (PooledCreditLineStatus);
}",183
RealWorld_TA_101_StrategyRegistry_RealWorld_20240812174709.log,101,StrategyRegistry,109882,3398,113280,107.0,0.61737,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IStrategyRegistry.sol';

contract StrategyRegistry is Initializable, OwnableUpgradeable, IStrategyRegistry {
    using SafeMath for uint256;

    //-------------------------------- Global vars start --------------------------------/

    /**
     * @notice max strategies allowed to be whitelisted
     * @dev this limit ensures that strategies array is not too big to iterate
     **/
    uint256 public maxStrategies;

    //-------------------------------- Global vars end --------------------------------/

    //-------------------------------- State vars start --------------------------------/

    /**
     * @notice list of whitelisted strategies
     **/
    address[] public strategies;

    /**
     * @notice registry which maps whitelisted strategies to true
     **/
    mapping(address => uint256) public override registry;

    /**
     * @notice registry which maps retired strategies which were once whitelisted to true
     **/
    mapping(address => uint256) public retiredRegistry;

    //-------------------------------- State vars end --------------------------------/

    //-------------------------------- Init start --------------------------------/

    /**
     * @notice used to initialize the paramters of strategy registry
     * @dev can only be called once
     * @param _owner address of the owner
     * @param _maxStrategies maximum number of strategies allowed
     **/
    function initialize(address _owner, uint256 _maxStrategies) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateMaxStrategies(_maxStrategies);
    }

    //-------------------------------- Init end --------------------------------/

    //-------------------------------- Strategy mgmt start --------------------------------/

    /**
     * @dev Add strategies to invest in. Please ensure that number of strategies are less than maxStrategies.
     * @param _strategy address of the strategy contract
     **/
    function addStrategy(address _strategy) external override onlyOwner {
        require(strategies.length + 1 <= maxStrategies, 'SR:AS1');
        require(registry[_strategy] == 0, 'SR:AS2');
        require(_strategy != address(0), 'SR:AS3');
        registry[_strategy] = 1;
        strategies.push(_strategy);

        emit StrategyAdded(_strategy);
    }

    /**
     * @dev Remove strategy to invest in.
     * @param _strategyIndex Index of the strategy to remove
     * @param _strategyAddress Address of the strategy to remove
     **/
    function removeStrategy(uint256 _strategyIndex, address _strategyAddress) external override onlyOwner {
        address _strategy = strategies[_strategyIndex];
        require(_strategy == _strategyAddress, 'SR:RS1');
        address[] memory _strategies = strategies;
        for (uint256 i = _strategyIndex; i < _strategies.length - 1; ++i) {
            strategies[i] = _strategies[i + 1];
        }
        strategies.pop();
        delete registry[_strategy];
        retiredRegistry[_strategy] = 1;

        emit StrategyRemoved(_strategy);
    }

    /**
     * @dev Update strategy to invest in.
     * @param _strategyIndex Index of the strategy to remove
     * @param _oldStrategy Strategy that is to be removed
     * @param _newStrategy Updated strategy
     **/
    function updateStrategy(
        uint256 _strategyIndex,
        address _oldStrategy,
        address _newStrategy
    ) external override onlyOwner {
        require(_strategyIndex < strategies.length, 'SR:US1');
        require(strategies[_strategyIndex] == _oldStrategy, 'SR:US2');
        require(_newStrategy != address(0), 'SR:US3');
        require(registry[_newStrategy] == 0, 'SR:US4');
        strategies[_strategyIndex] = _newStrategy;

        delete registry[_oldStrategy];
        retiredRegistry[_oldStrategy] = 1;
        emit StrategyRemoved(_oldStrategy);
        registry[_newStrategy] = 1;
        emit StrategyAdded(_newStrategy);
    }

    //-------------------------------- Strategy mgmt end --------------------------------/

    //-------------------------------- Utils start --------------------------------/
    /**
     * @notice used to get whitelisted strategies list
     * @return array of whitelisted strategies
     **/
    function getStrategies() external view override returns (address[] memory) {
        return strategies;
    }

    function isValidStrategy(address _strategy) external view override returns (bool) {
        return (registry[_strategy] != 0 || retiredRegistry[_strategy] != 0);
    }

    //-------------------------------- Utils end --------------------------------/

    //-------------------------------- Global var setters start --------------------------------/
    /**
     * @notice used to update max strategies allowed
     * @dev only owner can invoke
     * @param _maxStrategies updated number of max strategies allowed
     **/
    function updateMaxStrategies(uint256 _maxStrategies) external onlyOwner {
        _updateMaxStrategies(_maxStrategies);
    }

    function _updateMaxStrategies(uint256 _maxStrategies) private {
        require(_maxStrategies != 0, 'SR:IUMS1');
        maxStrategies = _maxStrategies;
        emit MaxStrategiesUpdated(_maxStrategies);
    }

    //-------------------------------- Global var setters end --------------------------------/
}",1101
RealWorld_TA_101_Beacon_RealWorld_20240812175334.log,101,Beacon,30657,1664,32321,72.0,0.186565,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
import '@openzeppelin/contracts/proxy/IBeacon.sol';
import '@openzeppelin/contracts/access/Ownable.sol';

contract Beacon is IBeacon, Ownable {
    address public impl;

    constructor(address _owner, address _impl) {
        require(_owner != address(0), 'B:C1');
        require(_impl != address(0), 'B:C2');
        impl = _impl;
        transferOwnership(_owner);
    }

    function implementation() external view override returns (address) {
        return impl;
    }

    function changeImpl(address _newImpl) external onlyOwner {
        impl = _newImpl;
    }
}",153
RealWorld_TA_101_PCLCancelledStage.t_RealWorld_20240812144201.log,101,PCLCancelledStage.t,640924,4064,644988,155.0,3.2859,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLCancelledStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Lend any amount lesser than the borrowLimit
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        // Let's travel a few days, but stay within the collection period
        vm.warp(block.timestamp + request.collectionPeriod / 2);

        // Borrower tries to cancel the PCL
        borrower.cancelRequest(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_cancelled_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    function test_adminCannotStartACancelledPCL() public {
        assert_start_functionality_in_cancelled_state(requestId, admin, 'Admin cannot start a PCL in cancelled state', 'LP:S1');
    }

    function test_borrowerCannotStartACancelledPCL() public {
        assert_start_functionality_in_cancelled_state(requestId, borrower, 'Borrower cannot start a PCL in cancelled state', 'LP:S1');
    }

    function test_lenderCannotStartACancelledPCL() public {
        assert_start_functionality_in_cancelled_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in cancelled state',
            'LP:S1'
        );
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_cancelled_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    function test_adminCannotCancelACancelledPCL() public {
        assert_cancel_functionality_in_cancelled_state(requestId, admin, 'Admin cannot Cancel a PCL in cancelled state', 'PCL:OCLB1');
    }

    // The Borrower is trying to cancel a cancelled PCL, but cannot because address(borrower) is now address(0).
    // And therefore, he gets the OCLB1 error.
    // Discuss.
    function test_borrowerCannotCancelACancelledPCL() public {
        assert_cancel_functionality_in_cancelled_state(requestId, borrower, 'Borrower cannot Cancel a PCL in cancelled state', 'PCL:OCLB1');
    }

    // The Lender is trying to cancel a cancelled PCL, but cannot because address(lenders[0].lenderAddress) is now address(0).
    // And therefore, he gets the OCLB1 error.
    // Discuss.
    function test_lenderCannotCancelACancelledPCL() public {
        assert_cancel_functionality_in_cancelled_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in cancelled state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_cancelled_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    function test_adminCannotCloseACancelledPCL() public {
        assert_close_functionality_in_cancelled_state(requestId, admin, 'Admin cannot close a cancelled PCL', 'PCL:OCLB1');
    }

    // The Borrower is trying to close a cancelled PCL, but cannot because address(borrower) is now address(0).
    // And therefore, he gets the OCLB1 error.
    // Discuss.
    function test_borrowerCannotCloseACancelledPCL() public {
        assert_close_functionality_in_cancelled_state(requestId, borrower, 'Borrower cannot close a cancelled PCL', 'PCL:OCLB1');
    }

    // The Lender is trying to close a cancelled PCL, but cannot because address(lenders[0].lenderAddress) is now address(0).
    // And therefore, he gets the OCLB1 error.
    // Discuss.
    function test_lenderCannotCloseACancelledPCL() public {
        assert_close_functionality_in_cancelled_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a cancelled PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_cancelled_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertEq(_poolTokenBalanceOld, (_borrowTokenBalanceNew - _borrowTokenBalanceOld));
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_cancelled_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in cancelled state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_cancelled_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in cancelled state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_cancelled_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_cancelled_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    function test_adminCannotLiquidateACancelledPCL() public {
        assert_liquidate_functionality_in_cancelled_state(requestId, false, admin, 'Admin cannot liquidate a cancelled PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateACancelledPCL() public {
        assert_liquidate_functionality_in_cancelled_state(
            requestId,
            false,
            borrower,
            'Borrower cannot liquidate a cancelled PCL',
            'LP:LIQ1'
        );
    }

    function test_lenderCannotLiquidateACancelledPCL() public {
        assert_liquidate_functionality_in_cancelled_state(
            requestId,
            true,
            PCLUser(address(0)),
            'Lender cannot liquidate a cancelled PCL',
            'PCL:L1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInCancelledState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    function test_adminCannotRepayACancelledPCL() public {
        assertRepayFunctionalityInCancelledState(requestId, admin, 'Admin cannot repay a cancelled PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayACancelledPCL() public {
        assertRepayFunctionalityInCancelledState(requestId, borrower, 'Borrower cannot repay a cancelled PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayACancelledPCL() public {
        assertRepayFunctionalityInCancelledState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a cancelled PCL',
            'PCL:REP2'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_cancelled_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.terminate(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    function test_adminCannotTerminateACancelledPCL() public {
        assert_terminate_functionality_in_cancelled_state(requestId, admin, 'Cannot terminate a cancelled PCL', 'PCL:CTCT1');
    }

    function test_borrowerCannotTerminateACancelledPCL() public {
        assert_terminate_functionality_in_cancelled_state(
            requestId,
            borrower,
            'Cannot terminate a cancelled PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateACancelledPCL() public {
        assert_terminate_functionality_in_cancelled_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a cancelled PCL',
            'Ownable: caller is not the owner'
        );
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInCancelledState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CANCELLED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInCancelledState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInCancelledState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInCancelledState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInCancelledState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInCancelledState(requestId, 1, admin, 'Admin cannot borrow a PCL in cancelled state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInCancelledState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in cancelled state', 'PCL:OCLB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInCancelledState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in cancelled state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInCancelledState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInCancelledState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in cancelled state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInCancelledState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in cancelled state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInCancelledState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in cancelled state',
            'PCL:OCLB1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInCancelledState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in cancelled state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_cancelled_state(
        uint256 _id,
        PCLUser,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);

        // 1. calculatePrincipalWithdrawable
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_userLiquidity, _principalWithdrawable);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens (testFail passes for this. This call breaks. Discuss.)
        try _borrower.calculateTotalCollateralTokens(_id) {
            revert('This call should not be working in CANCELLED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CTCT1');
        }

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0);

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            revert('This call should not be working in CANCELLED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            revert('This call should not be working in CANCELLED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CTTL1');
        }

        // 9. calculateTotalCollateralTokens
        try _borrower.calculateTotalCollateralTokens(_id) {
            revert('This call should not be working in CANCELLED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CTCT1');
        }
    }

    function test_helperFunctionInCancelledState() public {
        assert_helper_functionalities_in_cancelled_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_cancelled_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CANCELLED);

        uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
        uint256 _borrowTokenBalanceOld = borrowAsset.balanceOf(address(_user));

        try _user.withdrawInterest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
        uint256 _borrowTokenBalanceNew = borrowAsset.balanceOf(address(_user));

        assertEq(_poolTokenBalanceOld, _poolTokenBalanceNew);
        assertEq(_borrowTokenBalanceNew, _borrowTokenBalanceOld);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CANCELLED);
    }

    function test_adminCannotWithdrawInterestFromACancelledPCL() public {
        assert_withdraw_interest_functionality_in_cancelled_state(
            requestId,
            admin,
            'Should not have been able to withdraw interest',
            'LP:WI1'
        );
    }

    function test_borrowerCannotWithdrawInterestFromACancelledPCL() public {
        assert_withdraw_interest_functionality_in_cancelled_state(
            requestId,
            borrower,
            'Should not have been able to withdraw interest',
            'LP:WI1'
        );
    }

    function test_lenderCannotWithdrawInterestFromACancelledPCL() public {
        assert_withdraw_interest_functionality_in_cancelled_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not have been able to withdraw interest',
            'LP:WI1'
        );
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    function assert_pool_token_transfer_in_cancelled_stage(
        uint256 _id,
        uint256 _stateToAssert_1,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert_1);
        _fromUserPoolTokenSupply = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupply = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            log_named_uint('From User Pool MockToken Supply', _fromUserPoolTokenSupply);
            log_named_uint('To User Pool MockToken Supply', _toUserPoolTokenSupply);
            log_named_uint('Amount to transfer', (_fromUserPoolTokenSupply / _fractionOfPTSupply));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupply / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupply - (_fromUserPoolTokenSupply / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupply / _fractionOfPTSupply) + _toUserPoolTokenSupply));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupply) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupply, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupply), 0);
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToNonVerifiedUser() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_pooledCreditLineLender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_cancelled_stage(
            requestId,
            6,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_cancelled_stage(
            requestId,
            6,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_cancelled_stage(
            requestId,
            6,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }
}",7378
RealWorld_TA_101_MockVerification_RealWorld_20240812140124.log,101,MockVerification,26547,2043,28590,86.0,0.173595,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

contract MockVerification {
    mapping(address => mapping(address => bool)) public isUser;

    function addUser(address _user, address _verifier) external {
        isUser[_user][_verifier] = true;
    }

    function removeUser(address _user, address _verifier) external {
        delete isUser[_user][_verifier];
    }
}",89
RealWorld_TA_101_twitterVerifier_RealWorld_20240812173723.log,101,twitterVerifier,165286,4046,169332,120.0,0.90735,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/drafts/EIP712Upgradeable.sol';
import '@openzeppelin/contracts/cryptography/ECDSA.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IVerifier.sol';

contract TwitterVerifier is Initializable, IVerifier, OwnableUpgradeable, EIP712Upgradeable {
    //-------------------------------- Constants start --------------------------------/

    /**
     * @notice stores the verification contract instance
     */
    IVerification public immutable VERIFICATION;

    //-------------------------------- Constants end --------------------------------/

    /**
     * @notice Structure for the user data
     */
    struct UserStructData {
        string twitterId;
        string tweetId;
    }

    /**
     * @notice stores the user metadata against their address
     */
    mapping(address => UserStructData) public userData;
    /**
     * @notice stores the user address against twitterId
     */
    mapping(string => address) public twitterIdMap;
    /**
     * @notice stores the user address against tweetId
     */
    mapping(string => address) public usedTweetIds;
    // Stores the hash of the digest against the address of user who used it
    mapping(bytes32 => address) private usedDigests;
    /**
     * @notice stores the signer address
     */
    address public signerAddress;
    /**
     * @notice time for which signature by signer is valid
     */
    uint256 public signValidity;

    /**
     * @notice emitted when Signer address is updated
     * @param signerAddress address of the updated verification contract
     */
    event SignerUpdated(address indexed signerAddress);
    /**
     * @notice emitted when time for which sig is valid is updated
     * @param signValidity time to which validity of sign is updated
     */
    event SignValidityUpdated(uint256 signValidity);

    /**
     * @notice constructor
     * @dev initializes the immutables
     * @param _verification Verification contract address
     **/
    constructor(address _verification) {
        require(_verification != address(0), 'C1');
        VERIFICATION = IVerification(_verification);
    }

    /// @notice Initializes the variables of the contract
    /// @dev Contract follows proxy pattern and this function is used to initialize the variables for the contract in the proxy
    /// @param _admin Admin of the verification contract who can add verifiers and remove masterAddresses deemed invalid
    /// @param _signerAddress Address of the signer bot verifying users and signing off-chain messages
    /// @param _signValidity time for which signature is valid
    /// @param _name name of the verifier (used in domain seperator)
    /// @param _version version of the verifier (used in domain seperator)
    function initialize(
        address _admin,
        address _signerAddress,
        uint256 _signValidity,
        string memory _name,
        string memory _version
    ) external initializer {
        super.__Ownable_init();
        super.transferOwnership(_admin);
        _updateSignerAddress(_signerAddress);
        _updateSignValidity(_signValidity);
        __EIP712_init(_name, _version);
    }

    /**
     * @notice used to register user
     * @dev Users register themselves using message signed by the admin
     * @param _v int v
     * @param _r part signed message hash
     * @param _s part signed message hash
     * @param _timestamp timestamp for the signed message
     * @param _twitterId metadata related to user :  here ""twitterId""
     * @param _tweetId metadata related to user :  here ""tweetId""
     * @param _isMasterLinked should master address be linked to itself
     */

    function registerSelf(
        bool _isMasterLinked,
        uint8 _v,
        bytes32 _r,
        bytes32 _s,
        string memory _twitterId,
        string memory _tweetId,
        uint256 _timestamp
    ) external {
        require(bytes(userData[msg.sender].twitterId).length == 0, 'TV:RS1');
        require(twitterIdMap[_twitterId] == address(0), 'TV:RS2');
        require(bytes(_twitterId).length != 0, 'TV:RS9');
        require(bytes(_tweetId).length != 0, 'TV:RS8');
        require(usedTweetIds[_tweetId] == address(0), 'TV:RS3');
        require(block.timestamp < _timestamp + signValidity, 'TV:RS4');

        bytes32 digest = keccak256(
            abi.encode(
                keccak256('set(string twitterId,string tweetId,address userAddr,uint256 timestamp)'),
                keccak256(bytes(_twitterId)),
                keccak256(bytes(_tweetId)),
                msg.sender,
                _timestamp
            )
        );
        require(usedDigests[digest] == address(0), 'TV:RS5');

        bytes32 hash = _hashTypedDataV4(digest);
        address signer = ECDSA.recover(hash, _v, _r, _s);

        require(signer != address(0), 'TV:RS6');
        require(signer == signerAddress, 'TV:RS7');

        VERIFICATION.registerMasterAddress(msg.sender, _isMasterLinked);
        userData[msg.sender] = UserStructData(_twitterId, _tweetId);
        twitterIdMap[_twitterId] = msg.sender;
        usedTweetIds[_tweetId] = msg.sender;
        usedDigests[digest] = msg.sender;
        emit UserRegistered(msg.sender, _isMasterLinked, string(abi.encode(_twitterId, _tweetId)));
    }

    /**
     * @notice used to unregister self
     * @dev users themselves can unregister themself
     */
    function unregisterSelf() external {
        _unregisterUser(msg.sender);
    }

    /**
     * @notice used to unregister user
     * @dev owners can unregister users
     */
    function unregisterUser(address _user) external onlyOwner {
        _unregisterUser(_user);
    }

    function _unregisterUser(address _user) private {
        string memory _userdata = userData[_user].twitterId;
        require(bytes(_userdata).length != 0, 'TV:IUU1');
        delete twitterIdMap[_userdata];
        delete userData[_user];
        VERIFICATION.unregisterMasterAddress(_user, address(this));
        emit UserUnregistered(_user);
    }

    /**
     * @notice used to update signer address
     * @dev only owner can update
     * @param _signerAddress address of the verification contract
     */
    function updateSignerAddress(address _signerAddress) external onlyOwner {
        _updateSignerAddress(_signerAddress);
    }

    function _updateSignerAddress(address _signerAddress) private {
        require(_signerAddress != signerAddress, 'TV:IUSA1');
        require(_signerAddress != address(0), 'TV:IUSA2');
        signerAddress = _signerAddress;
        emit SignerUpdated(_signerAddress);
    }

    /**
     * @notice used to update time for which sign is valid
     * @dev only owner can update
     * @param _signValidity time for which sign will be valid
     */
    function updateSignValidity(uint256 _signValidity) external onlyOwner {
        _updateSignValidity(_signValidity);
    }

    function _updateSignValidity(uint256 _signValidity) private {
        require(_signValidity != signValidity, 'TV:IUSV1');
        require(_signValidity != 0, 'TV:IUSV2');
        signValidity = _signValidity;
        emit SignValidityUpdated(_signValidity);
    }

    /**
     * @notice blacklist a digest
     * @dev only owner can update
     * @param _hash digest hash to be blacklisted
     */
    function blackListDigest(bytes32 _hash) external onlyOwner {
        usedDigests[_hash] = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);
    }
}",1729
RealWorld_TA_101_Admin_RealWorld_20240812163007.log,101,Admin,241907,5790,247697,145.0,1.325335,"// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';

import '../ProtocolFeeCollector.sol';
import '../../PriceOracle.sol';
import '../../CreditLine/CreditLine.sol';
import '../../yield/StrategyRegistry.sol';
import '../../SublimeProxy.sol';
import '../../CreditLine/CreditLine.sol';
import '../../yield/NoYield.sol';
import '../../yield/CompoundYield.sol';
import '../../Verification/Verification.sol';
import '../../SavingsAccount/SavingsAccount.sol';
import '../Constants.sol';
import '../../mocks/MockCToken.sol';
import '../../mocks/MockToken.sol';
import '../../mocks/MockAdminVerifier.sol';
import '../interfaces/IProxyUpgrade.sol';
import '../../Verification/twitterVerifier.sol';
import '../../Verification/adminVerifier.sol';

contract Admin {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    function changeImplementationAddressOfProxy(address proxy, address newImplementation) public {
        ProxyUpgrade(proxy).upgradeTo(newImplementation);
    }

    function getImplementationAddressOfProxy(SublimeProxy sublimeProxyInstance) public returns (address) {
        address implAddress = sublimeProxyInstance.implementation();
        return implAddress;
    }

    /******************************************************************************
     ******* SavingsAccount specific functions ************************************
     ******************************************************************************/

    function initSavingsAccount(address savingsAccount, address _owner) public {
        SavingsAccount(savingsAccount).initialize(_owner);
    }

    function addSavingsAccountStrategy(address _strategyRegistry, address _strategyAddress) public {
        StrategyRegistry(_strategyRegistry).addStrategy(_strategyAddress);
    }

    function updateMaxStrategies(address _strategyRegistry, uint256 _maxStrategies) public {
        StrategyRegistry(_strategyRegistry).updateMaxStrategies(_maxStrategies);
    }

    function removeStrategy(
        address _strategyRegistry,
        uint256 _strategyIndex,
        address _strategyAddress
    ) public {
        StrategyRegistry(_strategyRegistry).removeStrategy(_strategyIndex, _strategyAddress);
    }

    function updateStrategy(
        address _strategyRegistry,
        uint256 _strategyIndex,
        address _oldStrategy,
        address _newStrategy
    ) public {
        StrategyRegistry(_strategyRegistry).updateStrategy(_strategyIndex, _oldStrategy, _newStrategy);
    }

    function updateProtocolFeeFraction(address creditLine, uint256 protocolFee) public {
        CreditLine(creditLine).updateProtocolFeeFraction(protocolFee);
    }

    function setDepositLimitForCompoundYield(
        address payable _compound,
        address _asset,
        uint256 _limit
    ) public {
        CompoundYield(_compound).setDepositLimit(_asset, _limit);
    }

    function addTokenAddressForCompoundYield(
        address payable yield,
        address _asset,
        address _liquidityToken
    ) public {
        CompoundYield(yield).addTokenAddress(_asset, _liquidityToken);
        setDepositLimitForCompoundYield(yield, _asset, type(uint256).max);
    }

    function addTokenAddressForNoYield(address yield, address _asset) public {
        NoYield(yield).addTokenAddress(_asset);
    }

    function transferOwnership(address _contract, address _to) public {
        MockToken(_contract).transferOwnership(_to);
    }

    function emergencyWithdrawFromCompoundYield(
        address payable yield,
        address _asset,
        address _wallet
    ) public {
        CompoundYield(yield).emergencyWithdraw(_asset, _wallet);
    }

    function forceUpdateTokenAddressForCompoundYield(
        address payable yield,
        address _asset,
        address _liquidityToken
    ) public {
        CompoundYield(yield).forceUpdateTokenAddress(_asset, _liquidityToken);
    }

    function emergencyWithdrawFromNoYield(
        address yield,
        address _asset,
        uint256 _amount
    ) public {
        NoYield(yield).emergencyWithdraw(_asset, _amount);
    }

    /******************************************************************************
     ******* END SavingsAccount specific functions ************************************
     ******************************************************************************/

    /******************************************************************************
     ******* PriceOracle specific functions ***************************************
     ******************************************************************************/

    function deployPriceOracle(address _admin, uint32 _uniswapPriceAvgPeriod) public returns (address) {
        PriceOracle _priceOracle = new PriceOracle(Constants.CHAINLINK_HEARTBEAT);
        _priceOracle.initialize(_admin, _uniswapPriceAvgPeriod);

        return address(_priceOracle);
    }

    function setChainlinkFeedAddress(
        address priceOracle,
        address token,
        address aggregator,
        uint128 heartbeat
    ) public {
        PriceOracle(priceOracle).setChainlinkFeedAddress(token, aggregator, heartbeat);
    }

    // NEEDS FORKING
    function setUpAllOracles(address priceOracleAddress) public {
        PriceOracle priceOracle = PriceOracle(priceOracleAddress);

        priceOracle.setChainlinkFeedAddress(Constants.WETH, Constants.ETH_priceFeedChainlink, Constants.CHAINLINK_HEARTBEAT);
        priceOracle.setChainlinkFeedAddress(Constants.DAI, Constants.DAI_priceFeedChainlink, Constants.CHAINLINK_HEARTBEAT);
        priceOracle.setChainlinkFeedAddress(Constants.USDC, Constants.USDC_priceFeedChainlink, Constants.CHAINLINK_HEARTBEAT);
        priceOracle.setChainlinkFeedAddress(Constants.WBTC, Constants.WBTC_priceFeedChainlink, Constants.CHAINLINK_HEARTBEAT);

        priceOracle.setUniswapFeedAddress(Constants.USDC, Constants.WETH, Constants.USDC_ETH_priceFeedUniswap);
        priceOracle.setUniswapFeedAddress(Constants.WBTC, Constants.WETH, Constants.WBTC_WETH_priceFeedUniswap);
        priceOracle.setUniswapFeedAddress(Constants.WBTC, Constants.DAI, Constants.WBTC_DAI_priceFeedUniswap);
    }

    /******************************************************************************
     ******* END PriceOracle specific functions ***************************************
     ******************************************************************************/

    /******************************************************************************
     ******* Verification specific functions ***************************************
     ******************************************************************************/

    function initializeVerification(
        Verification verification,
        address _admin,
        uint256 _activationDelay
    ) public {
        verification.initialize(_admin, _activationDelay);
    }

    /******************************************************************************
     ******* End Verification specific functions ***************************************
     ******************************************************************************/

    /******************************************************************************
     ******* Verifier specific functions ***************************************
     ******************************************************************************/

    function initializeTwitterVerifier(
        TwitterVerifier twitterVerifier,
        address _admin,
        address _signerAddress,
        uint256 _signValidity,
        string calldata _name,
        string calldata _version
    ) public {
        twitterVerifier.initialize(_admin, _signerAddress, _signValidity, _name, _version);
    }

    function addVerifier(address _verification, address _verifier) public {
        Verification(_verification).addVerifier(_verifier);
    }

    function removeVerifier(address _verification, address _verifier) public {
        Verification(_verification).removeVerifier(_verifier);
    }

    function verifyUser(address _user, address _verifier) public {
        MockAdminVerifier verifier = MockAdminVerifier(payable(_verifier));
        verifier.registerUserViaOwner(_user);
    }

    function blacklistDigestInTwitterVerifier(TwitterVerifier verifier, bytes32 digest) public {
        verifier.blackListDigest(digest);
    }

    function blacklistDigestInAdminVerifier(AdminVerifier verifier, bytes32 digest) public {
        verifier.blackListDigest(digest);
    }

    function updateSignerInTwitterVerifier(TwitterVerifier verifier, address newSigner) public {
        verifier.updateSignerAddress(newSigner);
    }

    function updateSignerInAdminVerifier(AdminVerifier verifier, address newSigner) public {
        verifier.updateSignerAddress(newSigner);
    }

    function updateSignValidityInTwitterVerifier(TwitterVerifier verifier, uint256 signValidity) public {
        verifier.updateSignValidity(signValidity);
    }

    function updateSignValidityInAdminVerifier(AdminVerifier verifier, uint256 signValidity) public {
        verifier.updateSignValidity(signValidity);
    }

    function unregisterUserByAdminInAdminVerifier(AdminVerifier verifier, address user) public {
        verifier.unregisterUser(user);
    }

    function unregisterUserByAdminInTwitterVerifier(TwitterVerifier verifier, address user) public {
        verifier.unregisterUser(user);
    }

    function initializeAdminVerifier(
        AdminVerifier adminVerifier,
        address _admin,
        address _signerAddress,
        uint256 _signValidity,
        string calldata _name,
        string calldata _version
    ) public {
        adminVerifier.initialize(_admin, _signerAddress, _signValidity, _name, _version);
    }

    /******************************************************************************
     ******* END Verifier specific functions ***************************************
     ******************************************************************************/

    /******************************************************************************
     ******* Verification specific functions ***************************************
     ******************************************************************************/

    function registerMasterAddressInVerificaction(
        Verification verification,
        address _masterAddress,
        bool _isMasterLinked
    ) public {
        verification.registerMasterAddress(_masterAddress, _isMasterLinked);
    }

    function unregisterMasterAddressInVerification(
        Verification verification,
        address _masterAddress,
        address _verifier
    ) public {
        verification.unregisterMasterAddress(_masterAddress, _verifier);
    }

    function updateActivationDelayInVerification(Verification verification, uint256 _activationDelay) public {
        verification.updateActivationDelay(_activationDelay);
    }

    /******************************************************************************
     ******* End Verification specific functions ***************************************
     ******************************************************************************/

    /******************************************************************************
     ******* DEPLOYEMNT specific functions ***************************************
     ******************************************************************************/

    function deployVerification(address) public returns (address) {
        Verification _verification = new Verification();
        _verification.initialize(address(this), 0);

        return address(_verification);
    }

    function deployMockAdminVerifier(address _verification) public returns (address) {
        MockAdminVerifier _mockAdminVerifier = new MockAdminVerifier();
        _mockAdminVerifier.initialize(address(this), _verification, 'MockAdminVerifier', '1.0');

        return address(_mockAdminVerifier);
    }

    function deployStrategyRegistry(uint256 _maxStrategies) public returns (address) {
        StrategyRegistry _strategyRegistry = new StrategyRegistry();
        _strategyRegistry.initialize(address(this), _maxStrategies);

        return address(_strategyRegistry);
    }

    function deploySavingsAccount(address _strategyRegistry) public returns (address) {
        SavingsAccount _savingsAccount = new SavingsAccount(_strategyRegistry);
        _savingsAccount.initialize(address(this));

        return address(_savingsAccount);
    }

    function deployNoYield(
        address _admin,
        address _savingsAccount,
        address _treasury
    ) public returns (address) {
        NoYield _noYield = new NoYield(_treasury, _savingsAccount);
        _noYield.initialize(_admin);

        return address(_noYield);
    }

    function deployCompoundYield(
        address _admin,
        address _savingsAccount,
        address _mockWETH,
        address _treasury
    ) public returns (address) {
        CompoundYield _compoundYield = new CompoundYield(_mockWETH, _treasury, _savingsAccount);
        _compoundYield.initialize(_admin);

        return address(_compoundYield);
    }

    function deployMockCToken(
        address _underlying,
        address _compoundYield,
        address _noYield
    ) public returns (address) {
        MockCToken _mockCToken = new MockCToken(address(_underlying));
        addTokenAddressForCompoundYield(payable(_compoundYield), _underlying, address(_mockCToken));
        addTokenAddressForNoYield(_noYield, _underlying);
        return address(_mockCToken);
    }

    /******************************************************************************
     ******* END DEPLOYEMNT specific functions ***************************************
     ******************************************************************************/

    function transferToken(
        address token,
        address recipient,
        uint256 amount
    ) public {
        IERC20(token).safeTransfer(recipient, amount);
    }

    function getFunctionSignature(string memory signature) public pure returns (bytes4) {
        return bytes4(keccak256(bytes(signature)));
    }

    function execute(
        address target,
        uint256 value,
        bytes calldata callData
    ) public {
        (bool success, ) = target.call{value: value}(callData);
        require(success, 'Transaction execution reverted.');
    }

    function executeFuncSig(
        address target,
        uint256 value,
        string memory signature,
        bytes calldata callData
    ) public {
        (bool success, ) = target.call{value: value}(abi.encodePacked(getFunctionSignature(signature), callData));
        require(success, 'Transaction execution reverted.');
    }
}",2716
RealWorld_TA_101_PCLRequestedState.t_RealWorld_20240812143056.log,101,PCLRequestedState.t,513635,3731,517366,135.0,2.642795,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLRequestedStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5000 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED, '!Requested');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED, '!Requested');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: A requested PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start a requested PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S2');
        }
    }

    // Test 2: Collateral cannot be deposited
    function test_collateralCannotBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        try borrower.depositCollateral(requestId, _minimumCollateralRequired, false) {
            revert('Collateral cannot be deposited');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Collateral cannot be withdrawn
    function test_collateralCannotBeWithdrawn() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Collateral cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: All Collateral cannot be withdrawn
    function test_allCollateralCannotBeWithdrawn() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('All collateral cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: A requested PCL cannot be closed
    function test_pclCannotBeClosed() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.close(requestId) {
            revert('PCL cannot be closed');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens remains zero if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensRemainsZeroIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);

        assertEq(_collateralTokens, 0);
    }

    // Test 8.1: Collateral tokens remains zero if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRemainsZeroIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);

        assertEq(_collateralTokens, 0);
    }

    // Test 9: Collateral ratio remains infinite
    function test_collateralRatioIsInfinite() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, type(uint256).max);
    }

    // Test 10: A requested PCL can be cancelled
    function test_pclCanBeCancelled() public {
        createMultipleLenders(requestId, 5, uint128(request.borrowLimit - 10), request.borrowAsset);

        helper_exchangeRateChanges();
        borrower.cancelRequest(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    // Test 11: Admin should be able to terminate
    function test_adminCanTerminatePCL() public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertTrue((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate) == 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower cannot repay
    function test_borrowerCannotRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        try borrower.repay(requestId, 1) {
            revert('Borrower cannot repay');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    // Test 14: A requested PCL cannot be liquidated
    function test_lendersCannotLiquidate(bool _withdraw) public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate a requested PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 15: Lenders cannot withdraw liquidation
    function test_lendersCannotWithdrawLiquidation() public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an requested PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders can withdraw liquidity
    function test_lendersCanWithdrawLiquidity() public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));
        uint256 _userPoolTokenBalance = lp.balanceOf(address(_lender0), requestId);

        helper_exchangeRateChanges();

        uint256 _userBorrowTokenBalanceBefore = IERC20(request.borrowAsset).balanceOf(address(_lender0));
        _lender0.withdrawLiquidity(requestId);
        uint256 _userBorrowTokenBalanceAfter = IERC20(request.borrowAsset).balanceOf(address(_lender0));
        assertEq(_userPoolTokenBalance, _userBorrowTokenBalanceAfter - _userBorrowTokenBalanceBefore);

        _userPoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        assertEq(_userPoolTokenBalance, 0);
    }

    // Test 17: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest cannot be withdrawn amidst exchange rate fluctuations
    function test_lendersCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        helper_exchangeRateChanges();

        try lender1.withdrawInterest(requestId) {
            revert('Interest cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalities(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from a requested PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_helperFunctions() public {
        assert_helperFunctionalities(requestId);
    }
}",6014
RealWorld_TA_101_IComptroller_RealWorld_20240812183111.log,101,IComptroller,30883,1889,32772,72.0,0.192195,"// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

interface IComptroller {
    function claimComp(address) external;

    function compSpeeds(address _cToken) external view returns (uint256);

    function compSupplySpeeds(address _cToken) external view returns (uint256);

    function claimComp(
        address[] calldata holders,
        address[] calldata cTokens,
        bool borrowers,
        bool suppliers
    ) external;

    function getAccountLiquidity(address account)
        external
        view
        returns (
            uint256,
            uint256,
            uint256
        );

    function enterMarkets(address[] calldata cTokens) external returns (uint256[] memory);
}",151
RealWorld_TA_101_Pool_RealWorld_20240812175022.log,101,Pool,925052,546,925598,189.0,4.63618,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ReentrancyGuardUpgradeable, ERC20PausableUpgradeable, IPool {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    //-------------------------------- Constants start --------------------------------//

    // Address of the price oracle contract
    IPriceOracle immutable PRICE_ORACLE;
    // Address of the savings account contract
    ISavingsAccount immutable SAVINGS_ACCOUNT;
    // address of the repayments contract
    IRepayment immutable REPAYMENT;
    // address of the pool factory contract
    IPoolFactory immutable POOL_FACTORY;
    // Factor to multiply variables to maintain precision
    uint256 constant SCALING_FACTOR = 1e18;

    //-------------------------------- Constants end --------------------------------//

    //-------------------------------- Pool state start --------------------------------//

    /**
     * @notice Struct that is used to store lending details of a lender
     * @param marginCallEndTime timestamp at which margin call raised by lender ends
     * @param effectiveInterestWithdrawn interest withdrawn adjusted for the balance of lender
     * @param extraLiquidityShares shares of collateral that are added by borrower in response to lender margin call
     */
    struct LendingDetails {
        uint256 marginCallEndTime;
        uint256 effectiveInterestWithdrawn;
        uint256 extraLiquidityShares;
    }

    /**
     * @notice Struct that is used to store constants related to a pool
     * @param loanStartTime timestamp at which loan starts
     * @param loanWithdrawalDeadline timestamp by which borrower should withdraw the lent amount
     * @param noOfRepaymentIntervals number of intervals in which repayments are done
     * @param repaymentInterval length of interval to make each repayment
     * @param borrower address of the borrower of credit line
     * @param collateralAsset address of the asset used as collateral in pool
     * @param borrowAsset address of the asset used as borrow asset in pool
     * @param poolSavingsStrategy address of strategy in which collateral is deposited
     * @param lenderVerifier address of verifier for the lender
     * @param borrowRate interest rate scaled by SCALING_FACTOR for the loan
     * @param idealCollateralRatio collateral ratio scaled by SCALING_FACTOR below which pool can be liquidated
     * @param borrowAmountRequested the amount of borrow asset requested by the borrower
     */
    struct PoolConstants {
        uint64 loanStartTime;
        uint64 loanWithdrawalDeadline;
        uint64 noOfRepaymentIntervals;
        uint64 repaymentInterval;
        address borrower;
        address collateralAsset;
        address borrowAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
        uint256 borrowRate;
        uint256 idealCollateralRatio;
        uint256 borrowAmountRequested;
    }

    /**
     * @notice Struct that is used to store variables related to a pool
     * @param loanStatus status of the pool
     * @param baseLiquidityShares total shares received by depositing collateral into strategy excluding collateral on margin calls
     * @param extraLiquidityShares total shares received by depositing collateral as part of margin calls
     * @param penaltyLiquidityAmount Tokens received on liquidation of cancel penalty
     */
    struct PoolVariables {
        LoanStatus loanStatus;
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    //-------------------------------- Pool state end --------------------------------//

    //-------------------------------- Modifiers start --------------------------------//

    /**
     * @notice checks if the msg.sender is pool's valid borrower
     */
    modifier onlyBorrower() {
        require(msg.sender == poolConstants.borrower, 'P:OB1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid lender
     */
    modifier isLender() {
        require(balanceOf(msg.sender) != 0, 'P:IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == POOL_FACTORY.owner(), 'P:OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == address(REPAYMENT), 'P:OR1');
        _;
    }

    //-------------------------------- Modifiers end --------------------------------//

    //-------------------------------- Initializers start --------------------------------//

    constructor(
        address _priceOracle,
        address _savingsAccount,
        address _repaymentImpl,
        address _poolFactory
    ) {
        require(_priceOracle != address(0), 'P:C1');
        require(_savingsAccount != address(0), 'P:C2');
        require(_repaymentImpl != address(0), 'P:C3');
        require(_poolFactory != address(0), 'P:C4');

        PRICE_ORACLE = IPriceOracle(_priceOracle);
        SAVINGS_ACCOUNT = ISavingsAccount(_savingsAccount);
        REPAYMENT = IRepayment(_repaymentImpl);
        POOL_FACTORY = IPoolFactory(_poolFactory);
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint64 _repaymentInterval,
        uint64 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external override initializer nonReentrant {
        require(msg.sender == address(POOL_FACTORY), 'P:I1');
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = uint64(block.timestamp.add(_collectionPeriod));
        poolConstants.loanWithdrawalDeadline = uint64(block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration));
        __ReentrancyGuard_init();
        __ERC20_init('Pool Tokens', 'PT');
        _setupDecimals(ERC20Upgradeable(_borrowAsset).decimals());
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) private {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(SCALING_FACTOR), 'P:ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    //-------------------------------- Initializers end --------------------------------//

    //-------------------------------- Collateral management start --------------------------------//

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */

    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external override nonReentrant {
        require(_amount != 0, 'P:DC1');
        require(balanceOf(msg.sender) == 0, 'P:DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice private function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) private {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            _sharesReceived = SavingsAccountUtil.savingsAccountTransferShares(
                SAVINGS_ACCOUNT,
                _collateralAsset,
                _poolSavingsStrategy,
                address(this),
                _receiver,
                _collateralShares
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice private function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) private {
        LoanStatus _loanStatus = poolVariables.loanStatus;
        require(_loanStatus == LoanStatus.ACTIVE || _loanStatus == LoanStatus.COLLECTION, 'P:IDC1');
        uint256 _sharesReceived = _deposit(
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this),
            _amount,
            _transferFromSavingsAccount,
            true
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'P:ACMC1');
        require(balanceOf(msg.sender) == 0, 'P:ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'P:ACMC3');

        require(_amount != 0, 'P:ACMC4');

        uint256 _sharesReceived = _deposit(
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this),
            _amount,
            _transferFromSavingsAccount,
            true
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    //-------------------------------- Collateral management end --------------------------------//

    //-------------------------------- Lend code start --------------------------------//

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender Address of lender on behalf of whom tokens are lent
     * @param _amount Amount of tokens lent
     * @param _strategy address of strategy from which tokens are lent if done from savings account,
     * @param _fromSavingsAccount in case of direct deposits it is false
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external override nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'P:L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(POOL_FACTORY.userRegistry()).isUser(_lender, _lenderVerifier), 'P:L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'P:L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;

        _deposit(_borrowToken, _strategy, msg.sender, address(this), _amount, _fromSavingsAccount, false);
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    //-------------------------------- Lend code end --------------------------------//

    //-------------------------------- Borrow code start --------------------------------//

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime <= block.timestamp &&
                block.timestamp <= poolConstants.loanWithdrawalDeadline,
            'P:WBA1'
        );
        uint256 _tokensLent = totalSupply();
        require(_tokensLent >= POOL_FACTORY.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(SCALING_FACTOR), 'P:WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'P:WBA3');

        uint64 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        address _borrowAsset = poolConstants.borrowAsset;

        REPAYMENT.initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            _borrowAsset
        );

        (uint256 _protocolFeeFraction, address _collector) = POOL_FACTORY.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(SCALING_FACTOR);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        if (_protocolFee != 0) {
            SavingsAccountUtil.transferTokens(_borrowAsset, address(this), _collector, _protocolFee);
        }
        SavingsAccountUtil.transferTokens(_borrowAsset, address(this), msg.sender, _feeAdjustedWithdrawalAmount);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    //-------------------------------- Borrow code end --------------------------------/

    //-------------------------------- Margin call code start --------------------------------/

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */
    function requestMarginCall() external nonReentrant isLender {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'P:RMC1');

        require(getMarginCallEndTime(msg.sender) == 0, 'P:RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'P:RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(POOL_FACTORY.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external nonReentrant {
        _canLenderBeLiquidated(_lender);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, _collateralAsset);

        uint256 _debtOwedToLender = interestToPay().mul(_lenderBalance).div(totalSupply()).add(_lenderBalance);
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralToLiquidate = getEquivalentTokens(_borrowAsset, _collateralAsset, _debtOwedToLender);
        if (_collateralToLiquidate > _lenderCollateralTokens) {
            _collateralToLiquidate = _lenderCollateralTokens;
        }
        _liquidateForLender(_lender, _collateralToLiquidate, _borrowAsset, _fromSavingsAccount);

        uint256 _amountReceived = _withdraw(
            poolConstants.collateralAsset,
            msg.sender,
            _poolSavingsStrategy,
            _lenderCollateralTokens,
            _toSavingsAccount,
            _recieveLiquidityShare
        );
        if (_collateralToLiquidate != _lenderCollateralTokens) {
            address _borrower = poolConstants.borrower;
            _withdraw(
                poolConstants.collateralAsset,
                poolConstants.borrower,
                _poolSavingsStrategy,
                _lenderCollateralTokens.sub(_collateralToLiquidate),
                false,
                false
            );
            emit CollateralWithdrawn(_borrower, _lenderCollateralTokens.sub(_collateralToLiquidate));
        }
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice private function to liquidate lender of the borrow pool
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     */
    function _liquidateForLender(
        address _lender,
        uint256 _lenderCollateralTokens,
        address _borrowAsset,
        bool _fromSavingsAccount
    ) private {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(_lenderCollateralTokens, POOL_FACTORY.liquidatorRewardFraction());

        _deposit(_borrowAsset, _poolSavingsStrategy, msg.sender, _lender, _lenderLiquidationTokens, _fromSavingsAccount, false);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) private {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'P:ICLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'P:ICLBL2');
        require(_marginCallEndTime < block.timestamp, 'P:ICLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'P:ICLBL4');
        require(balanceOf(_lender) != 0, 'P:ICLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender) private returns (uint256, uint256) {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        uint256 _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        uint256 _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
        return (_lenderCollateralLPShare, _lenderBalance);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = POOL_FACTORY.marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    //-------------------------------- Margin call code end --------------------------------/

    //-------------------------------- Liquidation code start --------------------------------/

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'P:LP1');
        require(REPAYMENT.didBorrowerDefault(address(this)), 'P:LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens;
        uint256 _collateralToLiquidate;
        {
            uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
            _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

            uint256 _currentDebt = totalSupply().add(interestToPay());
            _collateralToLiquidate = getEquivalentTokens(_borrowAsset, _collateralAsset, _currentDebt);
        }

        if (_collateralToLiquidate > _collateralTokens) {
            _collateralToLiquidate = _collateralTokens;
        }

        uint256 _poolBorrowTokens = correspondingBorrowTokens(_collateralToLiquidate, POOL_FACTORY.liquidatorRewardFraction());
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_borrowAsset, POOL_FACTORY.noStrategyAddress(), msg.sender, address(this), _poolBorrowTokens, _fromSavingsAccount, false);
        _withdraw(_collateralAsset, msg.sender, _poolSavingsStrategy, _collateralToLiquidate, _toSavingsAccount, _recieveLiquidityShare);
        if (_collateralToLiquidate != _collateralTokens) {
            address _borrower = poolConstants.borrower;
            _withdraw(_collateralAsset, _borrower, _poolSavingsStrategy, _collateralTokens.sub(_collateralToLiquidate), false, false);
            emit CollateralWithdrawn(_borrower, _collateralTokens.sub(_collateralToLiquidate));
        }
        emit PoolLiquidated(msg.sender);
    }

    //-------------------------------- Liquidation code end --------------------------------/

    //-------------------------------- cancel code start --------------------------------/

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'P:CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < POOL_FACTORY.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(SCALING_FACTOR)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = uint256(poolConstants.loanWithdrawalDeadline);

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'P:CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = POOL_FACTORY.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(SCALING_FACTOR)
            .mul(_collateralLiquidityShare)
            .mul(_penaltyTime)
            .div(SCALING_FACTOR)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) private {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is cancelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'P:LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'P:LCP2');
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(poolVariables.baseLiquidityShares, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(_collateralTokens, POOL_FACTORY.liquidatorRewardFraction());
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, msg.sender, address(this), _liquidationTokens);
        _withdraw(
            poolConstants.collateralAsset,
            msg.sender,
            poolConstants.poolSavingsStrategy,
            _collateralTokens,
            _toSavingsAccount,
            _receiveLiquidityShare
        );
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) private view returns (uint256) {
        uint256 _penaltyTime = uint256(poolConstants.repaymentInterval);
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    //-------------------------------- cancel code end --------------------------------/

    //-------------------------------- Lender withdrawals start --------------------------------/

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'P:WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        } else if (_loanStatus == LoanStatus.CANCELLED) {
            uint256 _penaltyShare = _toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply());
            _toTransfer = _toTransfer.add(_penaltyShare);
            poolVariables.penaltyLiquidityAmount = poolVariables.penaltyLiquidityAmount.sub(_penaltyShare);
        } else if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, address(this), msg.sender, _toTransfer);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice private function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) private {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) return;

        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, address(this), _lender, _amountToWithdraw);
    }

    /**
     * @notice public function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = REPAYMENT.getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    //-------------------------------- Lender withdrawals end --------------------------------/

    //-------------------------------- Pool end start --------------------------------/

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'P:CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external nonReentrant onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        emit PoolTerminated();
    }

    //-------------------------------- Pool end end --------------------------------/

    //-------------------------------- Token transfer start --------------------------------/

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'P:ITT1');
        }
        require(_from != _to, 'P:ITT6');
        require(_to != poolConstants.borrower, 'P:ITT2');

        if (_from == address(0)) {
            return;
        }
        _settleOnTokenTransfer(_from, _to, _amount);
    }

    /**
     * @notice used to settle borrow pool token balances among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _settleOnTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) private nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;

        if (_lenderVerifier != address(0) && _to != address(0)) {
            require(IVerification(POOL_FACTORY.userRegistry()).isUser(_to, _lenderVerifier), 'P:ITT5');
        }

        if (_to != address(0)) {
            require(getMarginCallEndTime(_from) == 0, 'P:ITT3');
            require(getMarginCallEndTime(_to) == 0, 'P:ITT4');
        }

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers

        _withdrawRepayment(_from);
        if (_to != address(0)) {
            _withdrawRepayment(_to);
        }
        uint256 _totalRepaidAmount = REPAYMENT.getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        if (_to != address(0)) {
            uint256 _toBalance = balanceOf(_to);
            lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        }

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        if (_to != address(0)) {
            lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
        }
    }

    //-------------------------------- Token transfer end --------------------------------/

    //-------------------------------- Utils start --------------------------------/

    //-------------------------------- Interest utils start --------------------------------/

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return interest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        (uint256 _loanDurationCoveredScaled, uint256 _interestPerSecondScaled) = REPAYMENT.getInterestCalculationVars(address(this));
        uint256 _loanDurationTillNowScaled = (block.timestamp.sub(uint256(poolConstants.loanStartTime))).mul(SCALING_FACTOR);

        if (_loanDurationTillNowScaled <= _loanDurationCoveredScaled) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecondScaled.mul(_loanDurationTillNowScaled.sub(_loanDurationCoveredScaled)).div(
            SCALING_FACTOR**2
        );

        return _interestAccrued;
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    //-------------------------------- Interest utils end --------------------------------/

    //-------------------------------- CollateralRatio utils start --------------------------------/

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _currentCollateralTokens = IYield(poolConstants.poolSavingsStrategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);

        return _equivalentCollateral.mul(SCALING_FACTOR).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        return (calculateCollateralRatio(totalSupply(), _liquidityShares));
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    //-------------------------------- CollateralRatio utils end --------------------------------/

    //-------------------------------- Token transfer utils end --------------------------------/

    /**
     * @notice private function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        address _asset,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo,
        uint256 _amount,
        bool _fromSavingsAccount,
        bool _toSavingsAccount
    ) private returns (uint256) {
        uint256 _sharesReceived;
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                SAVINGS_ACCOUNT,
                _asset,
                _poolSavingsStrategy,
                _depositFrom,
                _depositTo,
                _amount,
                false, // this means tokens are never withdrawn as shares but always as the based tokens
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                SAVINGS_ACCOUNT,
                _asset,
                _poolSavingsStrategy,
                _depositFrom,
                _depositTo,
                _amount,
                _toSavingsAccount
            );
        }
        return _sharesReceived;
    }

    /**
     * @notice private function used to withdraw tokens
     * @param _asset address of the asset to be withdrawn
     * @param _to address to which tokens are withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        address _asset,
        address _to,
        address _poolSavingsStrategy,
        uint256 _amountInTokens,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) private returns (uint256) {
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                SAVINGS_ACCOUNT,
                _asset,
                _poolSavingsStrategy,
                address(this),
                _to,
                _amountInTokens,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    //-------------------------------- Token transfer utils end --------------------------------/

    //-------------------------------- Token comparision utils start --------------------------------/

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(uint256 _totalCollateralTokens, uint256 _fraction) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = PRICE_ORACLE.getLatestPrice(poolConstants.collateralAsset, poolConstants.borrowAsset);
        return
            _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(SCALING_FACTOR).sub(_fraction)).div(SCALING_FACTOR);
    }

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = PRICE_ORACLE.getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    //-------------------------------- Token comparision utils end --------------------------------/

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, 'P:CCP1')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    //-------------------------------- State getter utils start --------------------------------/

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }

    //-------------------------------- State getter utils end --------------------------------/

    //-------------------------------- Utils end --------------------------------/
}",11156
RealWorld_TA_101_PCLActiveState.t_RealWorld_20240812143501.log,101,PCLActiveState.t,1282299,68,1282367,158.0,6.412855,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}",15517
RealWorld_TA_101_PriceOracle_RealWorld_20240812135601.log,101,PriceOracle,230108,4007,234115,116.0,1.23068,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol';
import '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/token/ERC20/ERC20.sol';

import './interfaces/IPriceOracle.sol';

contract PriceOracle is Initializable, OwnableUpgradeable, IPriceOracle {
    using SafeMath for uint256;

    //-------------------------------- Constants start --------------------------------/

    uint256 constant SCALING_EXPONENT = 18;
    uint256 constant SCALING_FACTOR = 10**(SCALING_EXPONENT);

    uint128 public immutable MAX_CHAINLINK_HEARTBEAT;

    //-------------------------------- Constants end --------------------------------/

    //-------------------------------- Global vars start --------------------------------/

    /**
     * @notice Struct that stores the chainlink price oracle and decimals related to the token
     * @param oracle address of price oracle of token against USD
     * @param decimals no of decimals for the price from oracle
     * @param heartbeat the time delta after which the price from the feed is discarded
     **/
    struct PriceData {
        address oracle;
        uint8 decimals;
        uint128 heartbeat;
    }
    /**
     * @notice stores the price oracle and its decimals for chainlink feeds
     **/
    mapping(address => PriceData) public chainlinkFeedAddresses;

    // stores the decimals for the token against the address
    mapping(address => uint256) decimals;

    /**
     * @notice stores the addresses of price feeds for uniswap token pairs
     **/
    mapping(bytes32 => address) public uniswapPools;

    // price averaging period for uniswap
    uint32 uniswapPriceAveragingPeriod;

    //-------------------------------- Global vars end --------------------------------/

    //-------------------------------- Init start --------------------------------/

    /**
     * @notice Used to initialize param during deployment
     * @dev invoked on deployment
     * @param _maxChainlinkHeartbeat max interval between within which chainlink oracle data is updated
     **/
    constructor(uint128 _maxChainlinkHeartbeat) {
        MAX_CHAINLINK_HEARTBEAT = _maxChainlinkHeartbeat;
    }

    /**
     * @notice Used to initialize the price oracle contract
     * @dev can only be invoked once
     * @param _admin owner of the price oracle
     * @param _uniswapPriceAveragingPeriod period for uniswap price averaging
     **/
    function initialize(address _admin, uint32 _uniswapPriceAveragingPeriod) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_admin);
        _setUniswapPriceAveragingPeriod(_uniswapPriceAveragingPeriod);
    }

    //-------------------------------- Init end --------------------------------/

    //-------------------------------- price start --------------------------------/
    /**
     * @notice Used to get price of the num vs den token from chainlink
     * @param num the address of the token for which price in queried
     * @param den the address of the token in which price is queried
     * @return price of the num in terms of den
     * @return no of decimals for the price
     **/
    function getChainlinkLatestPrice(address num, address den) public view returns (uint256, uint256) {
        PriceData memory _feedData1 = chainlinkFeedAddresses[num];
        PriceData memory _feedData2 = chainlinkFeedAddresses[den];

        if (_feedData1.oracle == address(0) || _feedData2.oracle == address(0)) return (0, 0);

        int256 price1;
        int256 price2;
        {
            uint80 roundID1;
            uint256 timeStamp1;
            uint80 answeredInRound1;
            (roundID1, price1, , timeStamp1, answeredInRound1) = AggregatorV3Interface(_feedData1.oracle).latestRoundData();
            if ((price1 == 0) || block.timestamp > timeStamp1 + _feedData1.heartbeat || answeredInRound1 < roundID1) return (0, 0);
        }
        {
            uint80 roundID2;
            uint256 timeStamp2;
            uint80 answeredInRound2;
            (roundID2, price2, , timeStamp2, answeredInRound2) = AggregatorV3Interface(_feedData2.oracle).latestRoundData();
            if ((price2 == 0) || block.timestamp > timeStamp2 + _feedData2.heartbeat || answeredInRound2 < roundID2) return (0, 0);
        }
        uint256 price = uint256(price1)
            .mul(10**_feedData2.decimals)
            .mul(SCALING_FACTOR)
            .div(uint256(price2))
            .div(10**_feedData1.decimals)
            .mul(10**decimals[den])
            .div(10**decimals[num]);
        return (price, SCALING_EXPONENT);
    }

    /**
     * @notice Used to get price of the num vs den token from uniswap
     * @param num the address of the token for which price in queried
     * @param den the address of the token in which price is queried
     * @return price of the num in terms of wei for num and denom tokens
     * @return no of decimals for the price
     **/
    function getUniswapLatestPrice(address num, address den) public view returns (uint256, uint256) {
        bytes32 _poolTokensId = getUniswapPoolTokenId(num, den);
        address _pool = uniswapPools[_poolTokensId];
        if (_pool == address(0)) return (0, 0);

        (int24 _twapTick, ) = OracleLibrary.consult(_pool, uniswapPriceAveragingPeriod);
        uint256 _price = OracleLibrary.getQuoteAtTick(_twapTick, uint128(SCALING_FACTOR), num, den);
        return (_price, SCALING_EXPONENT);
    }

    /**
     * @notice Used to get price of the num vs den token
     * @param num the address of the token for which price in queried
     * @param den the address of the token in which price is queried
     * @return price of the num in terms of den
     * @return no of decimals for the price
     **/
    function getLatestPrice(address num, address den) external view override returns (uint256, uint256) {
        uint256 _price;
        uint256 _decimals;
        (_price, _decimals) = getChainlinkLatestPrice(num, den);
        if (_price != 0) return (_price, _decimals);

        (_price, _decimals) = getUniswapLatestPrice(num, den);
        if (_price != 0) return (_price, _decimals);
        revert('PO:GLP1');
    }

    //-------------------------------- price end --------------------------------/

    //-------------------------------- Global var setters start --------------------------------/

    /**
     * @notice Used to set the price feed address for a token in chainlink
     * @dev only owner can set
     * @param _token address of token for which price feed is added
     * @param _priceFeed address of the price feed for the token
     * @param _heartbeat the time delta after which the price from the feed is discarded
     **/
    function setChainlinkFeedAddress(
        address _token,
        address _priceFeed,
        uint128 _heartbeat
    ) external onlyOwner {
        require(_heartbeat <= MAX_CHAINLINK_HEARTBEAT, 'PO:SCFA1');
        uint8 priceOracleDecimals = AggregatorV3Interface(_priceFeed).decimals();
        chainlinkFeedAddresses[_token] = PriceData(_priceFeed, priceOracleDecimals, _heartbeat);
        decimals[_token] = getDecimals(_token);
        emit ChainlinkFeedUpdated(_token, _priceFeed, _heartbeat);
    }

    /**
     * @notice Used to set the price feed address for a token pair in uniswap
     * @dev only owner can set
     * @param token1 address of one of the tokens for which price feed is added
     * @param token2 address of other token for which price feed is added
     * @param pool addrewss of the price feed for the token pair
     **/
    function setUniswapFeedAddress(
        address token1,
        address token2,
        address pool
    ) external onlyOwner {
        require(token1 != token2, 'PO:SUFA1');
        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);
        uniswapPools[_poolTokensId] = pool;
        emit UniswapFeedUpdated(token1, token2, _poolTokensId, pool);
    }

    /**
     * @notice Used to set the period in which uniswap price is averaged
     * @dev only owner can set. This is used to prevent attacks to control price feed
     * @param _uniswapPriceAveragingPeriod period for uniswap price averaging
     **/
    function setUniswapPriceAveragingPeriod(uint32 _uniswapPriceAveragingPeriod) external onlyOwner {
        _setUniswapPriceAveragingPeriod(_uniswapPriceAveragingPeriod);
    }

    function _setUniswapPriceAveragingPeriod(uint32 _uniswapPriceAveragingPeriod) private {
        require(_uniswapPriceAveragingPeriod != 0, 'PO:ISUPAP1');
        require(_uniswapPriceAveragingPeriod != uniswapPriceAveragingPeriod, 'PO:ISUPAP2');
        uniswapPriceAveragingPeriod = _uniswapPriceAveragingPeriod;
        emit UniswapPriceAveragingPeriodUpdated(_uniswapPriceAveragingPeriod);
    }

    //-------------------------------- Global var setters end --------------------------------/

    //-------------------------------- Utils start --------------------------------/

    /**
     * @notice Used to get decimals for a token
     * @param _token address of the token
     * @return number of decimals for the token
     **/
    function getDecimals(address _token) private view returns (uint8) {
        require(AddressUpgradeable.isContract(_token), 'PO:IGD1');

        try ERC20(_token).decimals() returns (uint8 v) {
            return v;
        } catch Error(string memory) {
            return 0;
        } catch (bytes memory) {
            return 0;
        }
    }

    // gets the token id for a pair of tokens irrespective of the order
    function getUniswapPoolTokenId(address num, address den) private pure returns (bytes32) {
        require(num != address(0) && den != address(0), 'PO:IGUPT1');

        if (uint256(num) < uint256(den)) {
            return keccak256(abi.encodePacked(num, den));
        } else {
            return keccak256(abi.encodePacked(den, num));
        }
    }

    /**
     * @notice used to check if price feed exists between 2 tokens
     * @param token1 one of the token for which price feed is to be checked
     * @param token2 other token for which price feed is to be checked
     * @return if price feed exists for the token pair
     **/
    function doesFeedExist(address token1, address token2) external view override returns (bool) {
        if (chainlinkFeedAddresses[token1].oracle != address(0) && chainlinkFeedAddresses[token2].oracle != address(0)) {
            return true;
        }

        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);

        if (uniswapPools[_poolTokensId] != address(0)) return true;

        return false;
    }

    //-------------------------------- Utils end --------------------------------/
}",2556
RealWorld_TA_101_IWETH9_RealWorld_20240812181325.log,101,IWETH9,24013,1213,25226,72.0,0.144325,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface IWETH9 {
    function deposit() external payable;

    function withdraw(uint256 wad) external;

    function approve(address spender, uint256 amount) external returns (bool);

    function transfer(address dst, uint256 wad) external returns (bool);
}",70
RealWorld_TA_101_creditLine.ActiveStage.t_RealWorld_20240812164939.log,101,creditLine.ActiveStage.t,977335,68,977403,131.0,4.888035,"pragma solidity 0.7.6;
pragma abicoder v2;

import './Helpers/CLParent.sol';
import '../../SavingsAccount/SavingsAccount.sol';
import '../../PriceOracle.sol';

import '@openzeppelin/contracts/math/SafeMath.sol';

contract CreditLine_ActiveStageTests is CLParent {
    using SafeMath for uint256;

    uint256 creditLineId;
    uint256 protocolFee;
    uint256 constant SCALING_FACTOR = 1e18;
    address borrowAssetStrategy;
    address collateralStrategy;

    CreditLine creditLine;
    SavingsAccount savingsAccount;
    PriceOracle priceOracle;

    address[] public userList;

    function setUp() public virtual {
        CLSetUp();

        creditLine = CreditLine(creditLineAddress);
        savingsAccount = SavingsAccount(savingsAccountAddress);
        priceOracle = PriceOracle(priceOracleAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = priceOracle.getLatestPrice(address(usdc), address(borrowAsset));

        requestData.requestTo = address(lender);
        // Borrow Asset equivalent of 1,000,000,000 in USD
        requestData.borrowLimit = uint128(uint256(CLConstants.maxBorrowLimit / 1e6).mul(_ratioOfPrices).div(10**_decimals));
        requestData.borrowRate = CLConstants.maxBorrowRate / 1e18;
        requestData.autoLiquidation = false;
        requestData.collateralRatio = (350 * CLConstants.maxCollteralRatio) / 1e11;
        requestData.borrowAsset = address(borrowAsset);
        requestData.borrowAssetStrategy = noYieldAddress;
        requestData.collateralAsset = address(collateralAsset);
        requestData.collateralStrategy = noYieldAddress;
        requestData.requestAsLender = false;

        creditLineId = goToActiveStage();

        // Setting global parameters
        protocolFee = creditLine.protocolFeeFraction();
        borrowAssetStrategy = requestData.borrowAssetStrategy;
        collateralStrategy = requestData.collateralStrategy;

        // Adding addresses to array
        userList.push(address(admin));
        userList.push(address(borrower));
        userList.push(address(lender));
        userList.push(address(liquidator));
    }

    //----------------------- ACTIVE stage, failing tests -----------------------//

    // Cannot accept credit line in ACTIVE stage
    function test_active_accept() public {
        try lender.acceptRequest(creditLineAddress, creditLineId) {
            revert('REVERT: Cannot accpet ACTIVE credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:A1');
        }
    }

    //----------------------- Credit line Deposit, failing tests -----------------------//

    // Depositing zero collateral amount should fail
    function test_DepositZeroCollateralAmount() public {
        uint256 amountZero = 0;
        try borrower.addCollateral(address(creditLine), creditLineId, amountZero, false) {
            revert('REVERT: Cannot deposit zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:DC1');
        }
    }

    // Depositing collateral for invalid (REQUESTED) creditline should fail
    function test_DepositInvalidCreditLine() public {
        uint256 amount = 10_000 * 10**ERC20(address(collateralAsset)).decimals();

        uint256 newCreditLine = borrower.createRequest(address(creditLine), requestData);

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        try borrower.addCollateral(address(creditLine), newCreditLine, amount, false) {
            revert('REVERT: Cannot deposit to invalid (REQUESTED) Creditline');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:DC2');
        }
    }

    // Creditline lender should not be able to deposit collateral
    function test_LenderCannotDepositCollateral() public {
        uint256 amount = 10_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(lender), amount);
        lender.setAllowance(address(creditLine), address(collateralAsset), amount);

        try lender.addCollateral(address(creditLine), creditLineId, amount, false) {
            revert('REVERT: Invalid Actor cannot deposit');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:DC3');
        }
    }

    // Depositing collateral amount more than available balance should fail
    function test_CollateralDepositCannotExceedBalance() public {
        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        // Adding collateral more than the balance amount
        try borrower.addCollateral(address(creditLine), creditLineId, amount + 1, false) {
            revert('REVERT: Insufficient amount');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    //----------------------- Credit line Deposit, passing tests -----------------------//

    // Depositing collateral into creditline should pass with correct parameters
    function test_creditLineDeposit_fromWallet(uint128 _amount) public {
        uint256 amount = scaleToRange256(_amount, 1, collateralAsset.totalSupply());

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        assert_creditLineDeposit(creditLineId, address(borrower), amount, false);
    }

    // Depositing collateral into creditline should pass with correct parameters
    function test_creditLineDeposit_fromSavingsAccount(uint128 _amount) public {
        uint256 amount = scaleToRange256(_amount, 1, collateralAsset.totalSupply() / 100);
        uint256 liquidityShares = IYield(collateralStrategy).getSharesForTokens(amount, address(collateralAsset));

        // Adding tokens to borrower and setting allowance for creditline contract
        savingsAccount_depositHelper(address(borrower), address(collateralAsset), collateralStrategy, liquidityShares);

        assert_creditLineDeposit(creditLineId, address(borrower), amount, true);
    }

    // Any user (except lender) should be able to deposit collateral from wallet
    function test_DepositByRandomUser_fromWallet() public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();

        // Testing the function for all the different actors
        for (uint256 i = 0; i < userList.length; i++) {
            if (i == 0) {
                CLAdmin user = CLAdmin(userList[i]);

                // Setting allowance for creditline contract
                user.setAllowance(address(creditLine), address(collateralAsset), amount);

                assert_creditLineDeposit(creditLineId, address(user), amount, false);
            } else {
                CLUser user = CLUser(userList[i]);

                if (userList[i] != address(lender)) {
                    // Adding tokens to user and setting allowance for credit line
                    admin.transferToken(address(collateralAsset), address(user), amount);
                    user.setAllowance(address(creditLine), address(collateralAsset), amount);

                    assert_creditLineDeposit(creditLineId, address(user), amount, false);
                }
            }
        }
    }

    // Any user (except lender) should be able to deposit collateral from savings Account
    function test_DepositByRandomUser_fromSavingsAccount() public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();
        uint256 liquidityShares = IYield(collateralStrategy).getSharesForTokens(amount, address(collateralAsset));

        // Testing the function for all the different actors
        for (uint256 i = 0; i < userList.length; i++) {
            if (i == 0) {
                CLAdmin user = CLAdmin(userList[i]);

                // set token allowance
                user.setAllowance(savingsAccountAddress, address(collateralAsset), liquidityShares);
                user.setAllowance(collateralStrategy, address(collateralAsset), liquidityShares);

                // set savings account allowance
                user.setAllowanceForSavingsAccount(savingsAccountAddress, address(collateralAsset), creditLineAddress, liquidityShares);

                // deposit into savings account
                user.savingsAccountDeposit(
                    savingsAccountAddress,
                    address(collateralAsset),
                    collateralStrategy,
                    address(user),
                    liquidityShares
                );

                assert_creditLineDeposit(creditLineId, address(user), amount, true);
            } else {
                CLUser user = CLUser(userList[i]);

                if (userList[i] != address(lender)) {
                    // Adding tokens to borrower and setting allowance for creditline contract
                    savingsAccount_depositHelper(address(user), address(collateralAsset), collateralStrategy, liquidityShares);

                    assert_creditLineDeposit(creditLineId, address(user), amount, true);
                }
            }
        }
    }

    //----------------------- Credit line Deposit, Assert helper -----------------------//

    function assert_creditLineDeposit(
        uint256 _creditLineId,
        address _user,
        uint256 _amount,
        bool _fromSavingsAccount
    ) public {
        // Checking collateral balance of credit line before deposit
        uint256 sharesBefore = creditLine.collateralShareInStrategy(_creditLineId);

        if (_user == address(admin)) {
            CLAdmin user = CLAdmin(_user);

            // Depositing collateral into credit line
            user.addCollateral(address(creditLine), _creditLineId, _amount, _fromSavingsAccount);
        } else {
            CLUser user = CLUser(_user);

            // Depositing collateral into credit line
            user.addCollateral(address(creditLine), _creditLineId, _amount, _fromSavingsAccount);
        }

        // assert the received shares and deposited amount equivalent shares are equal
        uint256 sharesReceived = creditLine.collateralShareInStrategy(_creditLineId);
        uint256 sharesOfAmount = IYield(collateralStrategy).getSharesForTokens(_amount, address(collateralAsset));

        assertEq(sharesReceived.sub(sharesBefore), sharesOfAmount);
    }

    //----------------------- Credit line Borrow, failing tests -----------------------//

    // Borrowing more than borrowable (limit) amount should fail
    function test_BorrowExcessAmount() public {
        uint256 amount = 10_000 * 10**ERC20(address(collateralAsset)).decimals();
        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable + 1);

        try borrower.borrow(address(creditLine), creditLineId, borrowable + 1) {
            revert('REVERT: Cannot borrow if collateral ratio is disturbed');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:B2');
        }
    }

    // Borrowing from creditline with amount more than lender balance should fail
    // Borrowable amount > lender balance of borrow tokens
    function test_BorrowExceedsLenderBalance() public {
        uint256 amount = 10**ERC20(address(collateralAsset)).decimals();
        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding less tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable - 1);

        try borrower.borrow(address(creditLine), creditLineId, borrowable) {
            revert('REVERT: Insufficient balance');
        } catch Error(string memory reason) {
            assertEq(reason, 'SA:ISA1');
        }
    }

    // Borrowing from creditline by invalid actor (not borrower) should fail
    function test_BorrowInvalidBorrower() public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();
        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable.add(100));

        // Testing the function for all the different actors
        for (uint256 i = 0; i < userList.length; i++) {
            if (i == 0) {
                CLAdmin user = CLAdmin(userList[i]);

                try user.borrow(address(creditLine), creditLineId, borrowable) {
                    revert('REVERT: Invalid actor cannot borrow');
                } catch Error(string memory reason) {
                    assertEq(reason, 'CL:OCLB1');
                }
            } else {
                CLUser user = CLUser(userList[i]);

                if (userList[i] != address(borrower)) {
                    try user.borrow(address(creditLine), creditLineId, borrowable) {
                        revert('REVERT: Invalid actor cannot borrow');
                    } catch Error(string memory reason) {
                        assertEq(reason, 'CL:OCLB1');
                    }
                }
            }
        }
    }

    // Borrowing from invalid creditline (REQUESTED stage) should fail
    function test_BorrowInvalidCreditline() public {
        uint256 RequestedCL = borrower.createRequest(address(creditLine), requestData);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, 1e20);

        try borrower.borrow(address(creditLine), RequestedCL, 1e20) {
            revert('REVERT: Cannot borrow from invalid creditline');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:CBA1');
        }
    }

    //----------------------- Credit line Borrow, passing tests -----------------------//

    // Borrower should be able to borrow from credit line
    // Adding enough collateral to borrow amount = borrow limit
    function test_creditLineBorrow_borrowLimit(uint256 _borrowAmount) public {
        (uint256 _ratioOfPrices, uint256 _decimals) = PriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );

        uint256 maxBorrowAmount = requestData.borrowLimit;
        uint256 collateralAmount = requestData.collateralRatio.mul(maxBorrowAmount).div(_ratioOfPrices).mul(10**_decimals).div(
            SCALING_FACTOR
        );

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), collateralAmount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), collateralAmount);

        borrower.addCollateral(address(creditLine), creditLineId, collateralAmount, false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        assertApproxEqRel(borrowable, maxBorrowAmount, 1e9); // 0.000000001 difference

        uint256 borrowAmount = scaleToRange256(_borrowAmount, 1, maxBorrowAmount.sub(maxBorrowAmount.mul(1e10).div(1e18))); // based on precision difference

        // Adding required tokens to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowAmount);

        borrower.borrow(address(creditLine), creditLineId, borrowAmount);
        uint256 borrowShares = IYield(borrowAssetStrategy).getSharesForTokens(borrowAmount, address(borrowAsset));
        assert_creditLineBorrow(creditLineId, borrowShares);
    }

    // Borrower should be able to borrow from credit line
    // Adding only enough collateral to borrow the amount = borrow limit / 2
    function test_creditLineBorrow_halfOfBorrowLimit(uint256 _borrowAmount) public {
        (uint256 _ratioOfPrices, uint256 _decimals) = PriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );

        uint256 maxBorrowAmount = requestData.borrowLimit / 2;
        uint256 collateralAmount = requestData.collateralRatio.mul(maxBorrowAmount).div(_ratioOfPrices).mul(10**_decimals).div(
            SCALING_FACTOR
        );

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), collateralAmount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), collateralAmount);

        borrower.addCollateral(address(creditLine), creditLineId, collateralAmount, false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        assertApproxEqRel(borrowable, maxBorrowAmount, 1e9); // 0.000000001 difference

        uint256 borrowAmount = scaleToRange256(_borrowAmount, 1, maxBorrowAmount.sub(maxBorrowAmount.mul(1e10).div(1e18))); // based on precision difference

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowAmount);

        borrower.borrow(address(creditLine), creditLineId, borrowAmount);
        uint256 borrowShares = IYield(borrowAssetStrategy).getSharesForTokens(borrowAmount, address(borrowAsset));
        assert_creditLineBorrow(creditLineId, borrowShares);
    }

    // Borrower should be able to borrow from credit line
    // Adding minimum collateral amount (1 unit)
    function test_creditLineBorrow_minCollateral(uint256 _borrowAmount) public {
        (uint256 _ratioOfPrices, uint256 _decimals) = PriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 collateralAmount = 1 * 10**ERC20(address(collateralAsset)).decimals(); // 1 unit of collateral token
        uint256 maxBorrowAmount = _ratioOfPrices.mul(collateralAmount).div(requestData.collateralRatio).mul(SCALING_FACTOR).div(
            10**_decimals
        );

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), collateralAmount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), collateralAmount);

        borrower.addCollateral(address(creditLine), creditLineId, collateralAmount, false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        assertApproxEqRel(borrowable, maxBorrowAmount, 1e10); // 0.00000001 difference

        uint256 borrowAmount = scaleToRange256(_borrowAmount, 1, maxBorrowAmount.sub(maxBorrowAmount.mul(1e11).div(1e18))); // based on precision difference

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowAmount);

        borrower.borrow(address(creditLine), creditLineId, borrowAmount);
        uint256 borrowShares = IYield(borrowAssetStrategy).getSharesForTokens(borrowAmount, address(borrowAsset));
        assert_creditLineBorrow(creditLineId, borrowShares);
    }

    //----------------------- Credit line Borrow , Assert helper -----------------------//

    function assert_creditLineBorrow(uint256 _creditLineId, uint256 _borrowShares) public {
        uint256 _borrowAmount = IYield(borrowAssetStrategy).getTokensForShares(_borrowShares, address(borrowAsset));

        // Checking balances
        uint256 protocolFeeAmount = _borrowAmount.mul(protocolFee).div(SCALING_FACTOR);
        uint256 expectedAmount = _borrowAmount.sub(protocolFeeAmount);

        uint256 borrowerBalance = borrowAsset.balanceOf(address(borrower));
        assertEq(expectedAmount, borrowerBalance);

        uint256 lenderBalanceSA = savingsAccount.balanceInShares(address(lender), address(borrowAsset), borrowAssetStrategy);
        assertEq(lenderBalanceSA, 0);

        uint256 feeCollectorBalance = borrowAsset.balanceOf(protocolFeeCollectorAddress);
        assertEq(feeCollectorBalance, protocolFeeAmount);

        // Variable updates
        (, uint256 principal, , uint256 lastPrincipalUpdateTime, ) = creditLine.creditLineVariables(_creditLineId);

        assertEq(principal, _borrowAmount);
        assertEq(lastPrincipalUpdateTime, block.timestamp);
    }

    //----------------------- Credit line withdraw collateral , failing tests -----------------------//

    // Should not be able to withdraw zero collateral from creditline
    function test_WithdrawCollateralZeroAmount() public {
        uint256 amount = 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);

        try borrower.withdrawCollateral(address(creditLine), creditLineId, 0, false) {
            revert('REVERT: Cannot withdraw zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:WC1');
        }
    }

    // Invalid Actor should not be able to withdraw collateral from creditline
    function test_WithdrawCollateralInvalidActor() public {
        uint256 amount = 10**ERC20(address(collateralAsset)).decimals();
        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);

        uint256 withdrawAmount = creditLine.withdrawableCollateral(creditLineId);

        // Testing the function for all the different actors
        for (uint256 i = 0; i < userList.length; i++) {
            if (i == 0) {
                CLAdmin user = CLAdmin(userList[i]);

                try user.withdrawCollateral(address(creditLine), creditLineId, withdrawAmount, false) {
                    revert('REVERT: Invalid actor cannot withdraw');
                } catch Error(string memory reason) {
                    assertEq(reason, 'CL:OCLB1');
                }
            } else {
                CLUser user = CLUser(userList[i]);

                if (userList[i] != address(borrower)) {
                    try user.withdrawCollateral(address(creditLine), creditLineId, withdrawAmount, false) {
                        revert('REVERT: Invalid actor cannot withdraw');
                    } catch Error(string memory reason) {
                        assertEq(reason, 'CL:OCLB1');
                    }
                }
            }
        }
    }

    // withdrawing collateral more than the limit should fail
    function test_WithdrawCollateralInvalidAmount() public {
        uint256 amount = 10**ERC20(address(collateralAsset)).decimals();
        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);

        uint256 withdrawAmount = creditLine.withdrawableCollateral(creditLineId);

        try borrower.withdrawCollateral(address(creditLine), creditLineId, withdrawAmount + 1, false) {
            revert('REVERT: Cannot withdraw excess amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:WC3');
        }
    }

    //----------------------- Credit line withdraw collateral , passing tests -----------------------//

    // borrower should be able to withdraw extra collateral from wallet
    // Adding only enough collateral to borrow amount = borrow limit and borrowing some amount
    function test_creditLineWithdrawCollateral_toWallet(uint256 _borrowAmount, uint256 _withdrawAmount) public {
        (uint256 _ratioOfPrices, uint256 _decimals) = PriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );

        uint256 maxBorrowAmount = requestData.borrowLimit;
        uint256 collateralAmount = requestData.collateralRatio.mul(maxBorrowAmount).div(_ratioOfPrices).mul(10**_decimals).div(
            SCALING_FACTOR
        );

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), collateralAmount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), collateralAmount);

        borrower.addCollateral(address(creditLine), creditLineId, collateralAmount, false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        assertApproxEqRel(borrowable, maxBorrowAmount, 1e9); // 0.000000001 difference

        uint256 borrowAmount = scaleToRange256(_borrowAmount, 1, borrowable);

        // Adding required tokens to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowAmount);

        borrower.borrow(address(creditLine), creditLineId, borrowAmount);

        // checking withdrawable amount
        uint256 withdrawable = creditLine.withdrawableCollateral(creditLineId);

        (_ratioOfPrices, _decimals) = PriceOracle(priceOracleAddress).getLatestPrice(address(collateralAsset), address(borrowAsset));
        uint256 borrowDiff = maxBorrowAmount.sub(borrowAmount);
        uint256 collateralEquivalentDiff = requestData.collateralRatio.mul(borrowDiff).div(_ratioOfPrices).mul(10**_decimals).div(
            SCALING_FACTOR
        );

        // emit log_named_uint('withdrawable',withdrawable);
        // emit log_named_uint('collateralEquivalentDiff',collateralEquivalentDiff);
        assertApproxEqAbs(withdrawable, collateralEquivalentDiff, 1);

        uint256 WithdrawAmount = scaleToRange256(_withdrawAmount, 1, withdrawable);
        assert_creditLineWithdrawCollateral(creditLineId, WithdrawAmount, false);
    }

    // Withdrawing collateral from creditline to savings account should pass
    // Adding only enough collateral to borrow amount = borrow limit and borrowing some amount
    function test_creditLineWithdrawCollateral_toSavingsAccount(uint128 _borrowAmount, uint128 _withdrawAmount) public {
        (uint256 _ratioOfPrices, uint256 _decimals) = PriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );

        uint256 maxBorrowAmount = requestData.borrowLimit;
        uint256 collateralAmount = requestData.collateralRatio.mul(maxBorrowAmount).div(_ratioOfPrices).mul(10**_decimals).div(
            SCALING_FACTOR
        );

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), collateralAmount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), collateralAmount);

        borrower.addCollateral(address(creditLine), creditLineId, collateralAmount, false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        assertApproxEqRel(borrowable, maxBorrowAmount, 1e9); // 0.000000001 difference

        uint256 borrowAmount = scaleToRange256(_borrowAmount, 1, borrowable);

        // Adding required tokens to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowAmount);

        borrower.borrow(address(creditLine), creditLineId, borrowAmount);

        // checking withdrawable amount
        uint256 withdrawable = creditLine.withdrawableCollateral(creditLineId);

        (_ratioOfPrices, _decimals) = PriceOracle(priceOracleAddress).getLatestPrice(address(collateralAsset), address(borrowAsset));
        uint256 borrowDiff = maxBorrowAmount.sub(borrowAmount);
        uint256 collateralEquivalentDiff = requestData.collateralRatio.mul(borrowDiff).div(_ratioOfPrices).mul(10**_decimals).div(
            SCALING_FACTOR
        );

        // emit log_named_uint('withdrawable',withdrawable);
        // emit log_named_uint('collateralEquivalentDiff',collateralEquivalentDiff);
        assertApproxEqAbs(withdrawable, collateralEquivalentDiff, 1);
        uint256 WithdrawAmount = scaleToRange256(_withdrawAmount, 1, withdrawable);

        admin.transferToken(address(collateralAsset), address(borrower), WithdrawAmount);
        borrower.setAllowance(savingsAccountAddress, address(collateralAsset), WithdrawAmount);
        borrower.setAllowance(collateralStrategy, address(collateralAsset), WithdrawAmount);

        borrower.setAllowanceForSavingsAccount(savingsAccountAddress, address(collateralAsset), address(creditLine), WithdrawAmount);

        assert_creditLineWithdrawCollateral(creditLineId, WithdrawAmount, true);
    }

    //----------------------- Credit line withdraw collateral, Assert helper -----------------------//

    function assert_creditLineWithdrawCollateral(
        uint256 _creditLineId,
        uint256 _withdrawAmount,
        bool _toSavingsAccount
    ) public {
        uint256 balanceBorrower = 0;
        uint256 balanceBorrowerAfter = 0;

        if (_toSavingsAccount) {
            balanceBorrower = savingsAccount.balanceInShares(address(borrower), address(collateralAsset), collateralStrategy);
            try borrower.withdrawCollateral(address(creditLine), _creditLineId, _withdrawAmount, _toSavingsAccount) {
                balanceBorrowerAfter = savingsAccount.balanceInShares(address(borrower), address(collateralAsset), collateralStrategy);
                uint256 withdrawShares = IYield(collateralStrategy).getSharesForTokens(_withdrawAmount, address(collateralAsset));
                assertApproxEqAbs(withdrawShares, balanceBorrowerAfter.sub(balanceBorrower), 1);
            } catch Error(string memory reason) {
                assertEq(reason, 'CL:WC1');
            }
        } else {
            balanceBorrower = collateralAsset.balanceOf(address(borrower));
            try borrower.withdrawCollateral(address(creditLine), _creditLineId, _withdrawAmount, _toSavingsAccount) {
                balanceBorrowerAfter = collateralAsset.balanceOf(address(borrower));
                assertApproxEqAbs(_withdrawAmount, balanceBorrowerAfter.sub(balanceBorrower), 1);
            } catch Error(string memory reason) {
                assertEq(reason, 'CL:WC1');
            }
        }
    }

    //----------------------- Credit line withdraw ALL collateral , failing tests -----------------------//

    // Invalid Actor should not be able to withdraw collateral from creditline
    function test_WithdrawAllCollateralInvalidActor() public {
        uint256 amount = 10**ERC20(address(collateralAsset)).decimals();
        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);

        // Testing the function for all the different actors
        for (uint256 i = 0; i < userList.length; i++) {
            if (i == 0) {
                CLAdmin user = CLAdmin(userList[i]);

                try user.withdrawAllCollateral(address(creditLine), creditLineId, false) {
                    revert('REVERT: Invalid actor cannot withdraw');
                } catch Error(string memory reason) {
                    assertEq(reason, 'CL:OCLB1');
                }
            } else {
                CLUser user = CLUser(userList[i]);

                if (userList[i] != address(borrower)) {
                    try user.withdrawAllCollateral(address(creditLine), creditLineId, false) {
                        revert('REVERT: Invalid actor cannot withdraw');
                    } catch Error(string memory reason) {
                        assertEq(reason, 'CL:OCLB1');
                    }
                }
            }
        }
    }

    //----------------------- Credit line withdraw ALL collateral , passing tests -----------------------//

    // Withdrawing collateral from creditline to wallet should pass
    // Adding only enough collateral to borrow amount = borrow limit
    function test_creditLineWithdrawAllCollateral_toWallet(uint256 _borrowAmount) public {
        (uint256 _ratioOfPrices, uint256 _decimals) = PriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );

        uint256 maxBorrowAmount = requestData.borrowLimit;
        uint256 collateralAmount = requestData.collateralRatio.mul(maxBorrowAmount).div(_ratioOfPrices).mul(10**_decimals).div(
            SCALING_FACTOR
        );

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), collateralAmount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), collateralAmount);

        borrower.addCollateral(address(creditLine), creditLineId, collateralAmount, false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        assertApproxEqRel(borrowable, maxBorrowAmount, 1e9); // 0.000000001 difference

        uint256 borrowAmount = scaleToRange256(_borrowAmount, 1, borrowable);

        // Adding required tokens to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowAmount);

        borrower.borrow(address(creditLine), creditLineId, borrowAmount);

        assert_creditLineWithdrawAllCollateral(creditLineId, false);
    }

    // Withdrawing collateral from creditline to savings account should pass
    function test_creditLineWithdrawAllCollateral_toSavingsAccount(uint256 _borrowAmount) public {
        (uint256 _ratioOfPrices, uint256 _decimals) = PriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );

        uint256 maxBorrowAmount = requestData.borrowLimit;
        uint256 collateralAmount = requestData.collateralRatio.mul(maxBorrowAmount).div(_ratioOfPrices).mul(10**_decimals).div(
            SCALING_FACTOR
        );

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), collateralAmount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), collateralAmount);

        borrower.addCollateral(address(creditLine), creditLineId, collateralAmount, false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        assertApproxEqRel(borrowable, maxBorrowAmount, 1e9); // 0.000000001 difference

        uint256 borrowAmount = scaleToRange256(_borrowAmount, 1, borrowable);

        // Adding required tokens to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowAmount);

        borrower.borrow(address(creditLine), creditLineId, borrowAmount);

        uint256 withdrawAmount = creditLine.withdrawableCollateral(creditLineId);

        admin.transferToken(address(collateralAsset), address(borrower), withdrawAmount);
        borrower.setAllowance(savingsAccountAddress, address(collateralAsset), withdrawAmount);
        borrower.setAllowance(collateralStrategy, address(collateralAsset), withdrawAmount);

        borrower.setAllowanceForSavingsAccount(savingsAccountAddress, address(collateralAsset), address(creditLine), withdrawAmount);

        assert_creditLineWithdrawAllCollateral(creditLineId, true);
    }

    //----------------------- Credit line withdraw ALL collateral, Assert helper -----------------------//

    function assert_creditLineWithdrawAllCollateral(uint256 _creditLineId, bool _toSavingsAccount) public {
        uint256 balanceBorrower = 0;
        uint256 balanceBorrowerAfter = 0;
        uint256 withdrawAmount = creditLine.withdrawableCollateral(creditLineId);

        if (_toSavingsAccount) {
            balanceBorrower = savingsAccount.balanceInShares(address(borrower), address(collateralAsset), collateralStrategy);
            try borrower.withdrawAllCollateral(address(creditLine), _creditLineId, _toSavingsAccount) {
                balanceBorrowerAfter = savingsAccount.balanceInShares(address(borrower), address(collateralAsset), collateralStrategy);
                uint256 withdrawShares = IYield(collateralStrategy).getSharesForTokens(withdrawAmount, address(collateralAsset));
                assertApproxEqAbs(withdrawShares, balanceBorrowerAfter.sub(balanceBorrower), 1);
            } catch Error(string memory reason) {
                assertEq(reason, 'CL:WC1');
            }
        } else {
            balanceBorrower = collateralAsset.balanceOf(address(borrower));
            try borrower.withdrawAllCollateral(address(creditLine), _creditLineId, _toSavingsAccount) {
                balanceBorrowerAfter = collateralAsset.balanceOf(address(borrower));
                assertApproxEqAbs(withdrawAmount, balanceBorrowerAfter.sub(balanceBorrower), 1);
            } catch Error(string memory reason) {
                assertEq(reason, 'CL:WC1');
            }
        }
    }

    //----------------------- Credit line liquidate, failing tests -----------------------//

    // liqidate function should fail if the prinipal is zero
    function test_LiquidateZeroPrincipal() public {
        uint256 amount = 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        try lender.liquidate(address(creditLine), creditLineId, false) {
            revert('REVERT: Cannot liquidate if principal = 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:L2');
        }
    }

    // Liquidating a credit line should fail, if the liquidator does not have enough token balance
    function test_creditLineLiquidate_LessLiquidatorBalance() public {
        uint256 amount = 10**ERC20(address(collateralAsset)).decimals();
        requestData.autoLiquidation = true;

        // Requesting a creditline
        uint256 newCreditLine = goToActiveStage();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount.mul(2).div(30000));
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount.mul(2).div(30000));

        borrower.addCollateral(address(creditLine), newCreditLine, amount.mul(2).div(30000), false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(newCreditLine);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), newCreditLine, borrowable);

        if (!isForked) {
            borrowAssetMockAggregator.updateAnswer(9795040576);
        } else {
            setCurrentCollRatio();
        }

        uint256 tokensToLiquidate = creditLine.borrowTokensToLiquidate(newCreditLine);

        admin.transferToken(address(borrowAsset), address(liquidator), tokensToLiquidate.sub(1));
        liquidator.setAllowance(address(creditLine), address(borrowAsset), tokensToLiquidate.sub(1));

        try liquidator.liquidate(address(creditLine), newCreditLine, false) {
            revert('REVERT: Balance too low');
        } catch Error(string memory reason) {
            if (isForked) {
                assertEq(reason, 'Dai/insufficient-balance');
            } else {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            }
        }
    }

    // CreditLine cannot be liquidated if the collateral ratio is higher than ideal value
    function test_LiquidateInvalidCollateralRatio() public {
        uint256 amount = 10**ERC20(address(collateralAsset)).decimals();
        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);

        try lender.liquidate(address(creditLine), creditLineId, false) {
            revert('REVERT: Cannot liquidate if collateral ratio > min collateral ratio');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:L3');
        }
    }

    // Credit line cannot be liquidated if it is not in ACTIVE stage
    function test_LiquidateInvalidCreditLine() public {
        // Request a credit line
        uint256 newCreditLineId = borrower.createRequest(address(creditLine), requestData);

        try lender.liquidate(address(creditLine), newCreditLineId, false) {
            revert('REVERT: Cannot liquidate invalid creditline');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:L1');
        }
    }

    // Invalid actor (except lender) should not be able to liquidate credit line
    // autoLiquidate = false, Only lender can liquidates
    function test_LiquidateInvalidActor() public {
        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();
        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount.div(5));
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount.div(5));

        borrower.addCollateral(address(creditLine), creditLineId, amount.div(5), false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);

        if (!isForked) {
            borrowAssetMockAggregator.updateAnswer(9795040576);
        } else {
            setCurrentCollRatio();
        }

        // Testing the function for all the different actors
        for (uint256 i = 0; i < userList.length; i++) {
            if (i == 0) {
                CLAdmin user = CLAdmin(userList[i]);

                try user.liquidate(address(creditLine), creditLineId, false) {
                    revert('REVERT: Invalid actor cannot liquidate');
                } catch Error(string memory reason) {
                    assertEq(reason, 'CL:L4');
                }
            } else {
                CLUser user = CLUser(userList[i]);

                if (userList[i] != address(lender)) {
                    try user.liquidate(address(creditLine), creditLineId, false) {
                        revert('REVERT: Invalid actor cannot liquidate');
                    } catch Error(string memory reason) {
                        assertEq(reason, 'CL:L4');
                    }
                }
            }
        }
    }

    //----------------------- Credit line liquidate, passing tests -----------------------//

    // Liquidating a credit line should pass (from lender's wallet)
    // autoLiquidate = false, lender liquidates
    function test_creditLineLiquidate_fromWallet() public {
        uint256 amount = 10 * 10**ERC20(address(collateralAsset)).decimals();
        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount.mul(2).div(5));
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount.mul(2).div(5));

        borrower.addCollateral(address(creditLine), creditLineId, amount.mul(2).div(5), false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);

        if (!isForked) {
            borrowAssetMockAggregator.updateAnswer(9795040576);
        } else {
            setCurrentCollRatio();
        }
        assert_creditLineLiquidate(address(lender), creditLineId, false);
    }

    // Liquidating a credit line should pass (from lender's savings account)
    // autoLiquidate = false, lender liquidates
    function test_creditLineLiquidate_fromSavingsAccount() public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();
        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount.mul(5).div(100));
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount.mul(5).div(100));

        borrower.addCollateral(address(creditLine), creditLineId, amount.mul(5).div(100), false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);

        if (!isForked) {
            borrowAssetMockAggregator.updateAnswer(9795040576);
        } else {
            setCurrentCollRatio();
        }
        assert_creditLineLiquidate(address(lender), creditLineId, true);
    }

    // Liquidating a credit line should pass (from lender's wallet)
    // autoLiquidate = true, lender liquidates
    function test_LiquidateTrue_byLender() public {
        uint256 amount = 1 * 10**ERC20(address(collateralAsset)).decimals();
        requestData.autoLiquidation = true;

        // Requesting a creditline
        uint256 newCreditLine = goToActiveStage();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount.mul(3).div(5));
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount.mul(3).div(5));

        borrower.addCollateral(address(creditLine), newCreditLine, amount.mul(3).div(5), false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(newCreditLine);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), newCreditLine, borrowable);

        if (!isForked) {
            borrowAssetMockAggregator.updateAnswer(9795040576);
        } else {
            setCurrentCollRatio();
        }
        assert_creditLineLiquidate(address(lender), newCreditLine, false);
    }

    // Liquidating a credit line should pass (from liquidator's wallet)
    // autoLiquidate = true, liquidator liquidates
    function test_LiquidateTrue_byLiquidator() public {
        uint256 amount = 10 * 10**ERC20(address(collateralAsset)).decimals();
        requestData.autoLiquidation = true;

        // Requesting a creditline
        uint256 newCreditLine = goToActiveStage();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount.mul(95).div(100));
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount.mul(95).div(100));

        borrower.addCollateral(address(creditLine), newCreditLine, amount.mul(95).div(100), false);

        uint256 borrowable = creditLine.calculateBorrowableAmount(newCreditLine);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), newCreditLine, borrowable);

        if (!isForked) {
            borrowAssetMockAggregator.updateAnswer(9795040576);
        } else {
            setCurrentCollRatio();
        }
        assert_creditLineLiquidate(address(liquidator), newCreditLine, false);
    }

    //----------------------- Credit line liquidate, Assert helper -----------------------//

    function assert_creditLineLiquidate(
        address _user,
        uint256 _creditLineId,
        bool _fromSavingsAccount
    ) public {
        uint256 tokensToLiquidate = creditLine.borrowTokensToLiquidate(_creditLineId);
        uint256 totalCollateralTokens = creditLine.calculateTotalCollateralTokens(_creditLineId);
        uint256 currentBalance;
        uint256 balanceAfter;
        uint256 balanceDiff;

        uint256 currentDebt = creditLine.calculateCurrentDebt(_creditLineId);
        (uint256 _ratioOfPrices, uint256 _decimals) = PriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 collateralToLiquidate = currentDebt.mul(10**_decimals).div(_ratioOfPrices);
        if (collateralToLiquidate > totalCollateralTokens) {
            collateralToLiquidate = totalCollateralTokens;
        }

        CLUser user = CLUser(_user);

        admin.transferToken(address(borrowAsset), address(user), tokensToLiquidate);
        user.setAllowance(address(creditLine), address(borrowAsset), tokensToLiquidate);

        if (_fromSavingsAccount) {
            currentBalance = savingsAccount.balanceInShares(address(user), address(collateralAsset), collateralStrategy);
            user.liquidate(address(creditLine), _creditLineId, _fromSavingsAccount);
            balanceAfter = savingsAccount.balanceInShares(address(user), address(collateralAsset), collateralStrategy);
            balanceDiff = balanceAfter.sub(currentBalance);
            uint256 collateralShares = IYield(collateralStrategy).getSharesForTokens(collateralToLiquidate, address(collateralAsset));
            assertApproxEqAbs(balanceDiff, collateralShares, 1);
        } else {
            currentBalance = collateralAsset.balanceOf(address(user));
            user.liquidate(address(creditLine), _creditLineId, _fromSavingsAccount);
            balanceAfter = collateralAsset.balanceOf(address(user));
            balanceDiff = balanceAfter.sub(currentBalance);
            assertApproxEqAbs(balanceDiff, collateralToLiquidate, 1);
        }

        uint256 status = uint256(creditLine.getCreditLineStatus(_creditLineId));
        assertEq(status, 0); // Credit line variables are deleted
    }

    function setCurrentCollRatio() public {
        vm.mockCall(
            priceOracleAddress,
            abi.encodeWithSelector(IPriceOracle.getLatestPrice.selector, address(collateralAsset), address(borrowAsset)),
            abi.encode(1000000, 8) // price, decimals
        );
    }
}",11632
RealWorld_TA_101_PCLExpiredStage.t_RealWorld_20240812145616.log,101,PCLExpiredStage.t,837510,68,837578,124.0,4.18891,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}",9817
RealWorld_TA_101_MockCToken_RealWorld_20240812141154.log,101,MockCToken,75183,6038,81221,115.0,0.496675,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '../interfaces/Invest/ICToken.sol';

interface IERC20Minter is IERC20 {
    function mint(address to, uint256 amount) external;
}

// @dev This contract should be able to mint underlying tokens to work
contract MockCToken is ERC20, ICToken {
    address public override underlying;

    uint256 exchangeRateStored;
    uint256 lastExchangeRateAt;

    constructor(address _underlying) ERC20('CToken', 'CT') {
        underlying = _underlying;
        exchangeRateStored = 1e18;
        lastExchangeRateAt = block.timestamp;
    }

    function mint(uint256 mintAmount) external override returns (uint256) {
        uint256 _shares = (mintAmount * 1e18) / _exchangeRateCurrent();
        IERC20(underlying).transferFrom(msg.sender, address(this), mintAmount);
        _mint(msg.sender, _shares);
        return 0;
    }

    function redeem(uint256 redeemTokens) external override returns (uint256) {
        uint256 _amount = (redeemTokens * _exchangeRateCurrent()) / 1e18;
        _burn(msg.sender, redeemTokens);
        uint256 _balance = IERC20(underlying).balanceOf(msg.sender);
        if (_amount > _balance) {
            IERC20Minter(underlying).mint(address(this), _amount - _balance);
        }
        IERC20(underlying).transfer(msg.sender, _amount);
        return 0;
    }

    function balanceOfUnderlying(address account) external override returns (uint256) {
        return (balanceOf(account) * _exchangeRateCurrent()) / 1e18;
    }

    function exchangeRateCurrent() external override returns (uint256) {
        return _exchangeRateCurrent();
    }

    function _exchangeRateCurrent() internal returns (uint256) {
        uint256 _currentExchangeRate = (exchangeRateStored * (1e18 + ((block.timestamp - lastExchangeRateAt) * 1e8))) / 1e18;
        exchangeRateStored = _currentExchangeRate;
        lastExchangeRateAt = block.timestamp;
        return _currentExchangeRate;
    }

    function getCash() external override returns (uint256) {
        return (90 * totalSupply()) / 100;
    }

    function comptroller() external view override returns (address) {
        return address(0);
    }

    function borrow(uint256 borrowAmount) external override returns (uint256) {
        return 0;
    }

    function repayBorrow(uint256 repayAmount) external override returns (uint256) {
        return 0;
    }

    function mockExchangeRateStored(uint256 _mockedExchangeRate) external returns (uint256) {
        exchangeRateStored = _mockedExchangeRate;
        lastExchangeRateAt = block.timestamp;
        return 0;
    }
}",652
RealWorld_TA_101_PCL_AdminUpdates.t_RealWorld_20240812161853.log,101,PCL,1490096,43,1490139,165.0,7.45134,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../../roles/User.sol';
import '../../../SublimeProxy.sol';
import '../../../mocks/Paused.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; // Required to check ERC20 balances of different actors

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import './../../roles/Admin.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../Constants.sol';

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';

import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/PCLAdmin.t.sol';
import '../Helpers/PCLConstants.t.sol';
import '../../../SublimeProxy.sol';
import 'forge-std/Test.sol';

contract PCLAdminUpdateTests is IPooledCreditLineDeclarations, Test {
    using SafeMath for uint256;
    using SafeMath for uint128;

    PriceOracle priceOracle;
    SavingsAccount savingsAccount;
    NoYield noYield;
    CompoundYield compoundYield;
    StrategyRegistry strategyRegistry;
    PooledCreditLine pooledCreditLine;
    LenderPool lenderPool;
    MockVerification2 verification;
    MockV3Aggregator aggregator1;
    MockV3Aggregator aggregator2;
    MockV3Aggregator aggregator3;
    MockToken collateralAsset;
    MockToken borrowAsset;
    MockToken USDC;
    MockWETH WETH;
    MockCToken cToken1;
    MockCToken cToken2;
    Paused pausedContract;
    PCLAdmin proxyAdmin;
    PCLAdmin admin;
    User user;
    User protocolFeeCollector;
    PCLUser pooledCreditLineBorrower;
    PCLUser pooledCreditLineLender_1;
    PCLUser pooledCreditLineLender_2;
    PCLUser pooledCreditLineLender_3;
    PCLUser pooledCreditLineLender_4;
    SublimeProxy sublimeProxyInstance;
    SublimeProxy priceOracleProxyInstance;
    SublimeProxy strategyRegistryProxyInstance;
    SublimeProxy compoundYieldProxyInstance;
    SublimeProxy pooledCreditLineProxyInstance;
    SublimeProxy lenderPoolProxyInstance;
    uint256 pooledCreditLineID;
    PooledCreditLineStatus status;
    uint256 lendAmount;
    uint256 minimumCollateralRequired;
    uint256 collateralToDeposit;
    uint256 borrowableAmount;
    uint256 amountToBorrow;
    uint256 protocolFeeFraction;
    uint256 protocolFee_1;
    uint256 protocolFee_2;
    uint256 protocolFeeCollectorBalance_1;
    uint256 protocolFeeCollectorBalance_2;
    address protocolFeeCollectorNew;
    IPooledCreditLineDeclarations.Request request;

    address pooledCreditLineAddress;
    address lenderPoolAddress;

    function setUp() public {
        // This is for the price oracle to get a non-zero timestamp
        vm.warp(block.timestamp + 10);

        proxyAdmin = new PCLAdmin(pooledCreditLineAddress, lenderPoolAddress);
        admin = new PCLAdmin(pooledCreditLineAddress, lenderPoolAddress);
        user = new User();
        protocolFeeCollector = new User();
        pausedContract = new Paused();

        collateralAsset = new MockToken('MockToken1', 'MT1', 18, 10e40, address(admin));
        borrowAsset = new MockToken('MockToken2', 'MT2', 18, 10e40, address(admin));
        USDC = new MockToken('MockUSDC', 'USDC', 6, 10e20, address(admin));
        WETH = new MockWETH();

        verification = new MockVerification2();
        aggregator1 = new MockV3Aggregator(18, 12876423400040030304304);
        aggregator2 = new MockV3Aggregator(8, 92392394976);
        aggregator3 = new MockV3Aggregator(6, 1000000);

        bytes4 functionSig;
        address sublimeProxy;
        bytes memory emptyBytes;

        PriceOracle _priceOracleImplementation = new PriceOracle(Constants.CHAINLINK_HEARTBEAT);
        priceOracleProxyInstance = new SublimeProxy(address(_priceOracleImplementation), address(proxyAdmin), emptyBytes);
        sublimeProxy = address(priceOracleProxyInstance);
        priceOracle = PriceOracle(payable(sublimeProxy));
        functionSig = admin.getFunctionSignature('initialize(address,uint32)');
        admin.execute(
            address(priceOracle),
            0,
            abi.encodePacked(functionSig, abi.encode(address(admin), address(WETH), PCLConstants.uniswapPriceAveragingPeriod))
        );

        StrategyRegistry _strategyRegistry = new StrategyRegistry();
        strategyRegistryProxyInstance = new SublimeProxy(address(_strategyRegistry), address(proxyAdmin), emptyBytes);
        sublimeProxy = address(strategyRegistryProxyInstance);
        strategyRegistry = StrategyRegistry(sublimeProxy);
        functionSig = admin.getFunctionSignature('initialize(address,uint256)');
        admin.execute(address(strategyRegistry), 0, abi.encodePacked(functionSig, abi.encode(address(admin), 10)));

        SavingsAccount _savingsAccount = new SavingsAccount(address(strategyRegistry));
        sublimeProxyInstance = new SublimeProxy(address(_savingsAccount), address(proxyAdmin), emptyBytes);
        sublimeProxy = address(sublimeProxyInstance);
        savingsAccount = SavingsAccount(sublimeProxy);
        functionSig = admin.getFunctionSignature('initialize(address)');
        admin.execute(address(savingsAccount), 0, abi.encodePacked(functionSig, abi.encode(address(admin))));

        NoYield _noYield = new NoYield(Constants._treasuryAddress, address(savingsAccount));
        sublimeProxy = address(new SublimeProxy(address(_noYield), address(proxyAdmin), emptyBytes));
        noYield = NoYield(sublimeProxy);
        functionSig = admin.getFunctionSignature('initialize(address)');
        admin.execute(address(noYield), 0, abi.encodePacked(functionSig, abi.encode(address(admin))));

        CompoundYield _compoundYield = new CompoundYield(address(WETH), Constants._treasuryAddress, address(savingsAccount));
        compoundYieldProxyInstance = new SublimeProxy(address(_compoundYield), address(proxyAdmin), emptyBytes);
        sublimeProxy = address(compoundYieldProxyInstance);
        compoundYield = CompoundYield(payable(sublimeProxy));
        functionSig = admin.getFunctionSignature('initialize(address)');
        admin.execute(address(compoundYield), 0, abi.encodePacked(functionSig, abi.encode(address(admin))));

        cToken1 = new MockCToken(address(collateralAsset));
        admin.forceUpdateTokenAddressForCompoundYield(address(compoundYield), address(collateralAsset), address(cToken1));
        admin.setDepositLimitForCompoundYield(address(compoundYield), address(collateralAsset), type(uint256).max);
        admin.transferOwnership(address(collateralAsset), address(cToken1));

        cToken2 = new MockCToken(address(borrowAsset));
        admin.forceUpdateTokenAddressForCompoundYield(address(compoundYield), address(borrowAsset), address(cToken2));
        admin.setDepositLimitForCompoundYield(address(compoundYield), address(borrowAsset), type(uint256).max);
        admin.transferOwnership(address(borrowAsset), address(cToken2));

        functionSig = admin.getFunctionSignature('addStrategy(address)');
        admin.execute(address(strategyRegistry), 0, abi.encodePacked(functionSig, abi.encode(address(noYield), 1782)));

        // Adding compoundYield to the strategy
        functionSig = admin.getFunctionSignature('addStrategy(address)');
        admin.execute(address(strategyRegistry), 0, abi.encodePacked(functionSig, abi.encode(address(compoundYield), 1782)));

        LimitsManager _limitsManager;
        {
            LimitsManager _limitsManagerImpl = new LimitsManager(address(USDC), address(priceOracle));
            sublimeProxy = address(new SublimeProxy(address(_limitsManagerImpl), address(proxyAdmin), emptyBytes));
            _limitsManager = LimitsManager(sublimeProxy);
            functionSig = admin.getFunctionSignature('initialize(address)');
            admin.execute(address(_limitsManager), 0, abi.encodePacked(functionSig, abi.encode(address(admin))));
        }

        lenderPoolProxyInstance = new SublimeProxy(address(strategyRegistry), address(proxyAdmin), emptyBytes);
        address lenderPoolProxyAddress = address(lenderPoolProxyInstance); // use any address and latter change to, here used strategyRegistry
        PooledCreditLine _pooledCreditLine = new PooledCreditLine(
            lenderPoolProxyAddress,
            address(priceOracle),
            address(savingsAccount),
            address(strategyRegistry),
            address(verification),
            address(_limitsManager),
            1e18 / 10
        );
        pooledCreditLineProxyInstance = new SublimeProxy(address(_pooledCreditLine), address(proxyAdmin), emptyBytes);
        sublimeProxy = address(pooledCreditLineProxyInstance);
        pooledCreditLine = PooledCreditLine(sublimeProxy);

        LenderPool _lenderPool = new LenderPool(address(pooledCreditLine), address(savingsAccount), address(verification));
        lenderPool = LenderPool(lenderPoolProxyAddress);
        proxyAdmin.changeImplementationAddressOfProxy(address(lenderPool), address(_lenderPool));
        functionSig = admin.getFunctionSignature('initialize()');
        admin.execute(address(lenderPool), 0, abi.encodePacked(functionSig));

        functionSig = admin.getFunctionSignature('initialize(address,uint256,address)');
        admin.execute(
            address(pooledCreditLine),
            0,
            abi.encodePacked(functionSig, abi.encode(address(admin), 10e16, address(protocolFeeCollector)))
        );

        pooledCreditLineAddress = address(pooledCreditLine);
        lenderPoolAddress = address(lenderPool);

        pooledCreditLineBorrower = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        pooledCreditLineLender_1 = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        pooledCreditLineLender_2 = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        pooledCreditLineLender_3 = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        pooledCreditLineLender_4 = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        admin.setChainlinkFeedAddress(address(priceOracle), address(collateralAsset), address(aggregator1), Constants.CHAINLINK_HEARTBEAT);
        admin.setChainlinkFeedAddress(address(priceOracle), address(borrowAsset), address(aggregator2), Constants.CHAINLINK_HEARTBEAT);
        admin.setChainlinkFeedAddress(address(priceOracle), address(USDC), address(aggregator3), Constants.CHAINLINK_HEARTBEAT);

        // Adding the verifiers to the verifiers mapping
        verification.whitelistVerifier(PCLConstants._borrowerVerifier);
        verification.whitelistVerifier(PCLConstants._lenderVerifier);

        // Verifying the users
        verification.verifyUser(address(pooledCreditLineBorrower), address(PCLConstants._borrowerVerifier));
        verification.verifyUser(address(pooledCreditLineLender_1), address(PCLConstants._lenderVerifier));
        verification.verifyUser(address(pooledCreditLineLender_2), address(PCLConstants._lenderVerifier));
        verification.verifyUser(address(pooledCreditLineLender_3), address(PCLConstants._lenderVerifier));
        verification.verifyUser(address(pooledCreditLineLender_4), address(PCLConstants._lenderVerifier));

        admin.updateLP(lenderPoolAddress);
        admin.updatePCL(pooledCreditLineAddress);

        // Setting limits for the pooledCreditLine
        admin.updateBorrowRateLimits(PCLConstants.minBorrowRate, PCLConstants.maxBorrowRate);
        admin.updateBorrowLimitLimits(PCLConstants.minBorrowLimit, PCLConstants.maxBorrowLimit);

        admin.updateIdealCollateralRatioLimits(PCLConstants.minCollateralRatio, PCLConstants.maxCollateralRatio);

        admin.updateCollectionPeriodLimits(PCLConstants.minCollectionPeriod, PCLConstants.maxCollectionPeriod);

        admin.updateDurationLimits(PCLConstants.minDuration, PCLConstants.maxDuration);

        admin.updateDefaultGracePeriodLimits(PCLConstants.minDefaultGraceDuration, PCLConstants.maxDefaultGraceDuration);

        admin.updateGracePenaltyRateLimits(PCLConstants.minGracePenaltyRate, PCLConstants.maxGracePenaltyRate);

        // Setting up the request parameteres for creating a PCL
        request.borrowLimit = uint128(1_000_000 * 1e18);
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = address(PCLConstants._lenderVerifier);
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 1e18;
        request.borrowAssetStrategy = address(compoundYield);
        request.collateralAssetStrategy = address(compoundYield);
        request.borrowerVerifier = address(PCLConstants._borrowerVerifier);
        request.areTokensTransferable = true;
    }

    // Test1: Admin increases ideal collateral ratio limits
    function test_increaseCollateralRatioLimit() public {
        request.collateralRatio = PCLConstants.maxCollateralRatio.mul(100);
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower cannot increase collateral ratio limit');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R8');
        }

        admin.updateIdealCollateralRatioLimits(PCLConstants.minCollateralRatio, PCLConstants.maxCollateralRatio.mul(100));
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    // Test2: Admin decreases the ideal collateral ratio limit
    function test_decreaseCollateralRatioLimit() public {
        request.collateralRatio = PCLConstants.minCollateralRatio.div(100);
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower cannot change the collateral ratio limit ');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R8');
        }

        admin.updateIdealCollateralRatioLimits(PCLConstants.minCollateralRatio.div(100), PCLConstants.maxCollateralRatio);

        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    // Test3: Increase borrow Rate Limits
    function test_increaseBorrowRateLimit() public {
        request.borrowRate = uint128(PCLConstants.maxBorrowRate.mul(100));
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower cannot change the Borrow Rate Limits');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R7');
        }

        admin.updateBorrowRateLimits(PCLConstants.minBorrowRate, PCLConstants.maxBorrowRate.mul(100));
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    // Test4: Decrease borrow rate limits
    function test_decreaseBorrowRateLimit() public {
        request.borrowRate = uint128(PCLConstants.minBorrowRate.div(100));
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower cannot change the Borrow Rate Limits');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R7');
        }

        admin.updateBorrowRateLimits(PCLConstants.minBorrowRate.div(100), PCLConstants.maxBorrowRate);
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    // Test5: Increase collection Limits
    function test_increaseCollectionPeriodLimit() public {
        request.collectionPeriod = PCLConstants.maxCollectionPeriod.mul(10);
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower cannot change the Collection Period Limits');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R9');
        }

        admin.updateCollectionPeriodLimits(PCLConstants.minCollectionPeriod, PCLConstants.maxCollectionPeriod.mul(10));
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    // Test6: Decrease collection Limits
    function test_decreaseCollectionPeriodLimit() public {
        request.collectionPeriod = PCLConstants.minCollectionPeriod.div(10);
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower cannot change the Borrow Rate Limits');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R9');
        }

        admin.updateCollectionPeriodLimits(PCLConstants.minCollectionPeriod.div(10), PCLConstants.maxCollectionPeriod);
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    // Test7: Decrease duration Limits
    function test_decreaseDurationLimits() public {
        request.duration = PCLConstants.minDuration.div(100);
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower cannot change the Duration Limits');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R10');
        }
        admin.updateDurationLimits(PCLConstants.minDuration.div(100), PCLConstants.maxDuration);
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    // Test8: Increase duration Limits
    function test_increaseDurationLimits() public {
        request.duration = PCLConstants.maxDuration.mul(100);
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower should not be able to change duration limits');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R10');
        }
        admin.updateDurationLimits(PCLConstants.minDuration, PCLConstants.maxDuration.mul(100));
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    // Test9: Increase Default Grace Period Limits
    function test_increaseDefaultGracePeriodLimits() public {
        request.defaultGracePeriod = PCLConstants.maxDefaultGraceDuration.mul(100);
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower cannot change default grace period limits');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R11');
        }
        admin.updateDefaultGracePeriodLimits(PCLConstants.minDefaultGraceDuration, PCLConstants.maxDefaultGraceDuration.mul(100));
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    // Test10: Decrease Default Grace Period Limits
    function test_decreaseDefaultGracePeriodLimits() public {
        request.defaultGracePeriod = PCLConstants.minDefaultGraceDuration.div(100);
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower cannot change default grace period limits');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R11');
        }
        admin.updateDefaultGracePeriodLimits(PCLConstants.minDefaultGraceDuration.div(100), PCLConstants.maxDefaultGraceDuration);
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    // Test11 Increase Grace Penalty Rate Limits
    function test_increaseGracePenaltyRateLimits() public {
        request.gracePenaltyRate = PCLConstants.maxGracePenaltyRate.mul(100);
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower cannot change grace penalty rates');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R12');
        }
        admin.updateGracePenaltyRateLimits(PCLConstants.minGracePenaltyRate, PCLConstants.maxGracePenaltyRate.mul(100));
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    // Test12 Decrease Grace Penalty Rate Limits
    function test_decreaseGracePenaltyRateLimits() public {
        request.gracePenaltyRate = PCLConstants.minGracePenaltyRate.div(100);
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower cannot change grace penalty rate');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R12');
        }

        admin.updateGracePenaltyRateLimits(PCLConstants.minGracePenaltyRate.div(100), PCLConstants.maxGracePenaltyRate);
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotUpdateBorrowLimitLimitsWithMinMoreThanMax() public {
        try admin.updateBorrowLimitLimits(PCLConstants.maxBorrowLimit, PCLConstants.minBorrowLimit) {
            revert('Admin cannot decrease the borrow limit less than minimum');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UBLL1');
        }
    }

    function test_cannotUpdateBorrowLimitLimitsSameAsPrevious() public {
        try admin.updateBorrowLimitLimits(PCLConstants.minBorrowLimit, PCLConstants.maxBorrowLimit) {
            revert('Admin cannot increase the borrow limit more than maximum');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UBLL2');
        }
    }

    function test_cannotUpdateIdealCollateralRatioLimitsWithMinMoreThanMax() public {
        try admin.updateIdealCollateralRatioLimits(PCLConstants.maxCollateralRatio, PCLConstants.minCollateralRatio) {
            revert('Admin cannot set minimum ideal collateral ratio more than the max permissible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UICRL1');
        }
    }

    function test_cannotUpdateIdealCollateralRatioLimitsSameAsPrevious() public {
        try admin.updateIdealCollateralRatioLimits(PCLConstants.minCollateralRatio, PCLConstants.maxCollateralRatio) {
            revert('Admin cannot update ideal collateral ratio limits same as previous');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UICRL2');
        }
    }

    function test_cannotUpdateBorrowRateLimitsWithMinMoreThanMax() public {
        try admin.updateBorrowRateLimits(PCLConstants.maxBorrowRate, PCLConstants.minBorrowRate) {
            revert('Cannot update borrow rate limits as min more than max');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UBRL1');
        }
    }

    function test_cannotUpdateBorrowRateLimitsSameAsPrevious() public {
        try admin.updateBorrowRateLimits(PCLConstants.minBorrowRate, PCLConstants.maxBorrowRate) {
            revert(' ');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UBRL2');
        }
    }

    function test_cannotUpdateCollectionPeriodLimitsWithMinMoreThanMax() public {
        try admin.updateCollectionPeriodLimits(PCLConstants.maxCollectionPeriod, PCLConstants.minCollectionPeriod) {
            revert('Cannot set the min collection period as more than the max permissible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UCPL1');
        }
    }

    function test_cannotUpdateCollectionPeriodLimitsSameAsPrevious() public {
        try admin.updateCollectionPeriodLimits(PCLConstants.minCollectionPeriod, PCLConstants.maxCollectionPeriod) {
            revert(' Admin cannot set the collection period the same as current value');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UCPL2');
        }
    }

    function test_cannotUpdateDurationLimitsWithMinMoreThanMax() public {
        try admin.updateDurationLimits(PCLConstants.maxDuration, PCLConstants.minDuration) {
            revert('Cannot set min duration more than the max permissible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UDL1');
        }
    }

    function test_cannotUpdateDurationLimitsSameAsPrevious() public {
        try admin.updateDurationLimits(PCLConstants.minDuration, PCLConstants.maxDuration) {
            revert('Admin cannot set the duration limits the same as current values');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UDL2');
        }
    }

    function test_cannotUpdateDefaultGracePeriodLimitsWithMinMoreThanMax() public {
        try admin.updateDefaultGracePeriodLimits(PCLConstants.maxDefaultGraceDuration, PCLConstants.minDefaultGraceDuration) {
            revert('Cannot set min default grace period more than the max permissible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UDGPL1');
        }
    }

    function test_cannotUpdateDefaultGracePeriodLimitsSameAsPrevious() public {
        try admin.updateDefaultGracePeriodLimits(PCLConstants.minDefaultGraceDuration, PCLConstants.maxDefaultGraceDuration) {
            revert('Admin cannot set the default grace period limits the same as current values');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UDGPL2');
        }
    }

    function test_cannotUpdateGracePenaltyRateLimitsWithMinMoreThanMax() public {
        try admin.updateGracePenaltyRateLimits(PCLConstants.maxGracePenaltyRate, PCLConstants.minGracePenaltyRate) {
            revert('Admin cannot set minimum grace penalty rate limit than the max permissible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UGPRL1');
        }
    }

    function test_cannotUpdateGracePenaltyRateLimitsSameAsPrevious() public {
        try admin.updateGracePenaltyRateLimits(PCLConstants.minGracePenaltyRate, PCLConstants.maxGracePenaltyRate) {
            revert('Cannot update the protocol fee fraction to be lower than min');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UGPRL2');
        }
    }

    function test_cannotUpdateProtocolFeeFractionMoreThanMax() public {
        try admin.updateProtocolFeeFraction(PCLConstants.protocolFeeFraction + 1) {
            revert('Cannot update the protocol fee fraction to be higher than max');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IUPFF1');
        }
    }

    function test_cannotUpdateProtocolFeeFractionSameAsPrevious() public {
        try admin.updateProtocolFeeFraction(PCLConstants.protocolFeeFraction) {
            revert('Cannot update the protocol fee fraction the same as before');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UPFF1');
        }
    }

    function test_cannotUpdateProtocolFeeCollectorWithZeroAddress() public {
        try admin.updateProtocolFeeCollector(address(0)) {
            revert('Cannot set the protocolFeeCollector as address(0)');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IUPFC1');
        }
    }

    function test_cannotUpdateProtocolFeeCollectorSameAsPrevious() public {
        try admin.updateProtocolFeeCollector(address(protocolFeeCollector)) {
            revert('Cannot update the protocolFeeCollector address same as before');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UPFC1');
        }
    }

    // Test15: Change the protocol fee collector address in the middle of a working PCL
    function test_changeProtocolFeeCollectorAddress() public {
        address protocolFeeCollectorOld = pooledCreditLine.protocolFeeCollector();

        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED); //Status should change to REQUESTED

        // Transferring borrow tokens to the lender
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // Since borrow can only be done after the collection period,
        vm.warp(block.timestamp + request.collectionPeriod);
        pooledCreditLineBorrower.start(pooledCreditLineID);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Calculating the borrowable amount:
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        amountToBorrow = borrowableAmount.div(4);

        //Trying to borrow the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        // Calculating the protocolFee on amountToBorrow
        protocolFeeFraction = pooledCreditLine.protocolFeeFraction();
        protocolFee_1 = (amountToBorrow.mul(protocolFeeFraction)).div(1e18);

        // Asserting that protocolFeeCollector got the correct amount of fee
        protocolFeeCollectorBalance_1 = IERC20(address(borrowAsset)).balanceOf(address(protocolFeeCollector));
        assertApproxEqAbs(protocolFee_1, protocolFeeCollectorBalance_1, 2);

        // Update the address of protocolFeeCollector
        admin.updateProtocolFeeCollector(address(pooledCreditLineLender_3));
        protocolFeeCollectorNew = pooledCreditLine.protocolFeeCollector();

        // Assert that the protocolFeeCollector address indeed got updated.
        assertEq(protocolFeeCollectorNew, address(pooledCreditLineLender_3));
        assertTrue(protocolFeeCollectorOld != protocolFeeCollectorNew);

        // Finding the initial balance of the new protocolFeeCollector before second withdrawal
        uint256 protocolFeeCollectorBalance_2Initial = IERC20(address(borrowAsset)).balanceOf(protocolFeeCollectorNew);
        log_uint(protocolFeeCollectorBalance_2Initial);

        // Borrowing some more money so that the protocol fee gets deducted
        amountToBorrow = borrowableAmount.div(2);
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        // Balance of protocolFeeCollector after the second withdrawal
        uint256 protocolFeeCollectorBalance_2Final = IERC20(address(borrowAsset)).balanceOf(protocolFeeCollectorNew);

        // Since the protocolFeeCollector address has changed, now their balance should be equal to the newly calculated protocolFee
        protocolFee_2 = (amountToBorrow.mul(protocolFeeFraction)).div(1e18);
        protocolFeeCollectorBalance_2 = protocolFeeCollectorBalance_2Final.sub(protocolFeeCollectorBalance_2Initial);
        assertApproxEqAbs(protocolFee_2, protocolFeeCollectorBalance_2, 2);
        assertApproxEqAbs(protocolFeeCollectorBalance_1, IERC20(address(borrowAsset)).balanceOf(address(protocolFeeCollectorOld)), 2);
    }

    // Test16: Change the protocolFeeFraction
    function test_changeProtocolFeeFraction() public {
        uint256 protocolFeeFractionOld = pooledCreditLine.protocolFeeFraction();

        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED); //Status should change to REQUESTED

        // Transferring borrow tokens to the lender
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // Since borrow can only be done after the collection period,
        vm.warp(block.timestamp + request.collectionPeriod);
        pooledCreditLineBorrower.start(pooledCreditLineID);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Calculating the borrowable amount:
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        amountToBorrow = borrowableAmount.div(2);

        //Trying to borrow half the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        // Calculating the protocol fee on the amountToBorrow
        protocolFeeFraction = pooledCreditLine.protocolFeeFraction();
        protocolFee_1 = (amountToBorrow.mul(protocolFeeFraction)).div(1e18);
        uint256 protocolFeeCollectorBalanceInitial = IERC20(address(borrowAsset)).balanceOf(address(protocolFeeCollector));

        // Update the protocolFeeFraction
        admin.updateProtocolFeeFraction(1e16);
        uint256 protocolFeeFractionNew = pooledCreditLine.protocolFeeFraction();

        // Now the borrowable amount should be equal to the earlier amountToBorrow
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        assertApproxEqAbs(borrowableAmount, amountToBorrow, 2);

        //Trying to borrow the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        // Calculating the protocol fee after the second borrow
        protocolFee_2 = (amountToBorrow.mul(protocolFeeFractionNew)).div(1e18);
        uint256 protocolFeeCollectorBalanceFinal = IERC20(address(borrowAsset)).balanceOf(address(protocolFeeCollector));
        uint256 protocolFeeCollectorBalanceAfter2ndBorrow = protocolFeeCollectorBalanceFinal.sub(protocolFeeCollectorBalanceInitial);

        // Asserting that the protocol fee for both borrowals was different even though the amount was same
        assertTrue(!(protocolFeeCollectorBalanceInitial == protocolFeeCollectorBalanceAfter2ndBorrow));
        assertEq(protocolFeeFractionNew, 1e16);
        assertTrue(protocolFeeFractionOld != protocolFeeFractionNew);
    }

    // Test18: Test the pause and upgrade functionality as the admin
    function test_pauseAndUpgradeContractsWhenSomethingBadHappens() public {
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED); //Status should change to REQUESTED

        // Transferring borrow tokens to the lender
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // Since borrow can only be done after the collection period,
        vm.warp(block.timestamp + request.collectionPeriod);
        pooledCreditLineBorrower.start(pooledCreditLineID);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Calculating the borrowable amount:
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        amountToBorrow = borrowableAmount.div(4);

        //Trying to borrow the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        // Something went terribly wrong and noew we want to pause all interactions with the savings account.
        // Setting the new savings account address to address(0) or 0xffff....ff doesn't work. This error is thrown:
        // Revert (""UpgradeableProxy: new implementation is not a contract""
        log_address(address(pausedContract));

        address pcl_savingsAccount_old = address(pooledCreditLine.SAVINGS_ACCOUNT());
        address savingsAccount_impl = proxyAdmin.getImplementationAddressOfProxy(sublimeProxyInstance);
        log_named_address('Old Savings Account', savingsAccount_impl);

        proxyAdmin.changeImplementationAddressOfProxy(address(sublimeProxyInstance), address(pausedContract));

        address pausedContractAddress = proxyAdmin.getImplementationAddressOfProxy(sublimeProxyInstance);
        log_named_address('Paused Contract Address', pausedContractAddress);
        address pcl_savingsAccount_new = address(pooledCreditLine.SAVINGS_ACCOUNT());

        // assert that the savings account address for the pcl should not change
        assertEq(pcl_savingsAccount_new, pcl_savingsAccount_old);

        // Assert that the implementation addresses of the savings account changed to a paused contract
        assertTrue(savingsAccount_impl != pausedContractAddress);

        // Now that the savingsAccount is paused, let's change the proxyImplementation to a patched savingsAccount
        SavingsAccount patchedSavingsAccount = new SavingsAccount(address(strategyRegistry));
        proxyAdmin.changeImplementationAddressOfProxy(address(sublimeProxyInstance), address(patchedSavingsAccount));

        // Now comparing the address of the patchedSavingsAccount with pausedContract
        address patchedSavingsAccountAddress = proxyAdmin.getImplementationAddressOfProxy(sublimeProxyInstance);
        log_named_address('New Saving Account', patchedSavingsAccountAddress);

        assertTrue(patchedSavingsAccountAddress != pausedContractAddress);
    }

    // Test19: Test the pause functionality as the admin
    function testFail_stopSavingsAccountInteraction() public {
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED); //Status should change to REQUESTED

        // Transferring borrow tokens to the lender
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // Since borrow can only be done after the collection period,
        vm.warp(block.timestamp + request.collectionPeriod);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Calculating the borrowable amount:
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        amountToBorrow = borrowableAmount.div(4);

        //Trying to borrow the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        // Something went terribly wrong and noew we want to pause all interactions with the savings account.
        // Setting the new savings account address to address(0) doesn't work. This error is thrown:
        // Revert (""UpgradeableProxy: new implementation is not a contract""
        log_address(address(pausedContract));

        address pcl_savingsAccount_old = address(pooledCreditLine.SAVINGS_ACCOUNT());
        address savingsAccount_impl = proxyAdmin.getImplementationAddressOfProxy(sublimeProxyInstance);
        log_named_address('Old Savings Account', savingsAccount_impl);

        proxyAdmin.changeImplementationAddressOfProxy(address(sublimeProxyInstance), address(pausedContract));

        address pausedContractAddress = proxyAdmin.getImplementationAddressOfProxy(sublimeProxyInstance);
        log_named_address('Paused Contract Address', pausedContractAddress);
        address pcl_savingsAccount_new = address(pooledCreditLine.SAVINGS_ACCOUNT());

        // assert that the savings account address for the pcl should not change
        assertEq(pcl_savingsAccount_new, pcl_savingsAccount_old);

        // Assert that the implementation addresses of the savings account changed to a paused contract
        assertTrue(savingsAccount_impl != pausedContractAddress);

        // This call should break and testFail should succeed
        savingsAccount.getTotalTokens(address(pooledCreditLineBorrower), request.borrowAsset);
    }

    // Test20: Test the pause and upgrade functionality of price oracle as the admin
    function test_pauseAndUpgradePriceOracleContract() public {
        // Create your PCL request
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        // The status of the PCL request should be in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        // Transferring borrow tokens to the lender, and then lender lends to the PCL
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // The collection period gets over
        vm.warp(block.timestamp + request.collectionPeriod);

        // Borrower signs the required documents and then calls the start function
        pooledCreditLineBorrower.start(pooledCreditLineID);

        // Since the borrowLimit is met, the status should change to ACTIVE state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.ACTIVE);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Since borrow can only be done after the collection period,
        vm.warp(block.timestamp + request.collectionPeriod);

        // Calculating the borrowable amount:
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        amountToBorrow = borrowableAmount.div(4);

        // Trying to borrow the a fourth of the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        // Finding out whether the feed exist (in the current price oracle implementation)
        bool doesFeedExistInitial = priceOracle.doesFeedExist(address(request.borrowAsset), address(request.collateralAsset));
        // Something went terribly wrong and now we want to pause all interactions with the price oracle.
        // Setting the new price oracle address to address(0) or 0xffff....ff doesn't work. This error is thrown:
        // Revert (""UpgradeableProxy: new implementation is not a contract"")
        log_address(address(pausedContract));

        address pcl_priceOracle_old = address(pooledCreditLine.PRICE_ORACLE());
        address priceOracle_impl = proxyAdmin.getImplementationAddressOfProxy(priceOracleProxyInstance);
        log_named_address('Old Price Oracle', priceOracle_impl);

        proxyAdmin.changeImplementationAddressOfProxy(address(priceOracleProxyInstance), address(pausedContract));

        address pausedContractAddress = proxyAdmin.getImplementationAddressOfProxy(priceOracleProxyInstance);
        log_named_address('Paused Contract Address', pausedContractAddress);
        address pcl_priceOracle_new = address(pooledCreditLine.PRICE_ORACLE());

        // assert that the price oracle address for the pcl should not change
        assertEq(pcl_priceOracle_new, pcl_priceOracle_old);

        // Assert that the implementation addresses of the price oracle changed to a paused contract
        assertTrue(priceOracle_impl != pausedContractAddress);

        // Now that the priceOracle is paused, let's change the proxyImplementation to a patched priceOracle
        PriceOracle patchedPriceOracle = new PriceOracle(type(uint128).max);
        proxyAdmin.changeImplementationAddressOfProxy(address(priceOracleProxyInstance), address(patchedPriceOracle));

        // Now comparing the address of the patchedPriceOracle with pausedContract
        address patchedPriceOracleAddress = proxyAdmin.getImplementationAddressOfProxy(priceOracleProxyInstance);
        log_named_address('New Price Oracle', patchedPriceOracleAddress);

        bool doesFeedExistFinal = priceOracle.doesFeedExist(address(request.borrowAsset), address(request.collateralAsset));

        assertTrue(patchedPriceOracleAddress != pausedContractAddress);
        assertTrue(doesFeedExistFinal == doesFeedExistInitial);
    }

    // Test21: Test the pause functionality of price oracle as the admin
    function testFail_stopPriceOracleInteraction() public {
        // Create your PCL request
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        // The status of the PCL request should be in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        // Transferring borrow tokens to the lender, and then lender lends to the PCL
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // The collection period gets over
        vm.warp(block.timestamp + request.collectionPeriod);

        // Borrower signs the required documents and then calls the start function
        pooledCreditLineBorrower.start(pooledCreditLineID);

        // Since the borrowLimit is met, the status should change to ACTIVE state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.ACTIVE);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Since borrow can only be done after the collection period,
        vm.warp(block.timestamp + request.collectionPeriod);

        // Calculating the borrowable amount:
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        amountToBorrow = borrowableAmount.div(4);

        // Trying to borrow the a fourth of the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        // Finding out whether the feed exist (in the current price oracle implementation)
        bool doesFeedExistInitial = priceOracle.doesFeedExist(address(request.borrowAsset), address(request.collateralAsset));
        assertTrue(doesFeedExistInitial);

        // Something went terribly wrong and now we want to pause all interactions with the price oracle.
        // Setting the new price oracle address to address(0) or 0xffff....ff doesn't work. This error is thrown:
        // Revert (""UpgradeableProxy: new implementation is not a contract"")
        log_address(address(pausedContract));

        address pcl_priceOracle_old = address(pooledCreditLine.PRICE_ORACLE());
        address priceOracle_impl = proxyAdmin.getImplementationAddressOfProxy(priceOracleProxyInstance);
        log_named_address('Old Price Oracle', priceOracle_impl);

        proxyAdmin.changeImplementationAddressOfProxy(address(priceOracleProxyInstance), address(pausedContract));

        address pausedContractAddress = proxyAdmin.getImplementationAddressOfProxy(priceOracleProxyInstance);
        log_named_address('Paused Contract Address', pausedContractAddress);
        address pcl_priceOracle_new = address(pooledCreditLine.PRICE_ORACLE());

        // assert that the price oracle address for the pcl should not change
        assertEq(pcl_priceOracle_new, pcl_priceOracle_old);

        // Assert that the implementation addresses of the price oracle changed to a paused contract
        assertTrue(priceOracle_impl != pausedContractAddress);

        // Now that the price oracle contract is essentially paused, we should not be able to call priceOracle functions
        // This call should fail
        bool doesFeedExistFinal = priceOracle.doesFeedExist(address(request.borrowAsset), address(request.collateralAsset));
    }

    // Test22: Test the pause and upgrade functionality of Strategy Registry
    function test_pauseAndUpgradeStrategyRegistryContract() public {
        // Create your PCL request
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        // The status of the PCL request should be in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        // Transferring borrow tokens to the lender, and then lender lends to the PCL
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // The collection period gets over
        vm.warp(block.timestamp + request.collectionPeriod);

        // Borrower signs the required documents and then calls the start function
        pooledCreditLineBorrower.start(pooledCreditLineID);

        // Since the borrowLimit is met, the status should change to ACTIVE state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.ACTIVE);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Since borrow can only be done after the collection period,
        vm.warp(block.timestamp + request.collectionPeriod);

        // Calculating the borrowable amount:
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        amountToBorrow = borrowableAmount.div(4);

        // Trying to borrow the a fourth of the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        // Finding the number of strategies in the strategy registry
        address[] memory strategyList = strategyRegistry.getStrategies();
        uint256 noOfStrategies = strategyList.length;

        // The number of strategies should be 2 (Compound Yield and No Yield)
        assertEq(noOfStrategies, 2);

        // Something went terribly wrong and now we want to pause all interactions with the strategy registry.
        // Setting the new strategy registry address to address(0) or 0xffff....ff doesn't work. This error is thrown:
        // Revert (""UpgradeableProxy: new implementation is not a contract"")
        address pcl_strategyRegistry_old = address(pooledCreditLine.STRATEGY_REGISTRY());
        address strategyRegistry_impl = proxyAdmin.getImplementationAddressOfProxy(strategyRegistryProxyInstance);

        // Changing the implementation contract for the strategy registry proxy
        proxyAdmin.changeImplementationAddressOfProxy(address(strategyRegistryProxyInstance), address(pausedContract));

        // Now the implementation contract has been changed to the Paused contract
        address pausedContractAddress = proxyAdmin.getImplementationAddressOfProxy(strategyRegistryProxyInstance);
        address pcl_strategyRegistry_new = address(pooledCreditLine.STRATEGY_REGISTRY());

        // assert that the strategy registry address for the pcl should not change
        assertEq(pcl_strategyRegistry_new, pcl_strategyRegistry_old);

        // Assert that the implementation addresses of the strategy registry changed to a paused contract
        assertTrue(strategyRegistry_impl != pausedContractAddress);

        // Now that the strategyRegistry is paused, let's change the proxyImplementation to a patched strategyRegistry
        StrategyRegistry patchedStrategyRegistry = new StrategyRegistry();
        proxyAdmin.changeImplementationAddressOfProxy(address(strategyRegistryProxyInstance), address(patchedStrategyRegistry));

        // Now comparing the address of the patchedStrategyRegistry with pausedContract
        address patchedStrategyRegistryAddress = proxyAdmin.getImplementationAddressOfProxy(strategyRegistryProxyInstance);

        // Checking whether the state of the StrategyRegistry contract was maintained after the upgrade or not
        strategyList = strategyRegistry.getStrategies();
        uint256 noOfStrategiesFinal = strategyList.length;

        assertTrue(patchedStrategyRegistryAddress != pausedContractAddress); // This asserts that the implementation contract did change
        assertTrue(noOfStrategiesFinal == noOfStrategies);
    }

    // Test23: Test the pause functionality of Strategy Registry as the admin
    function testFail_stopStrategyRegistryContract() public {
        // Create your PCL request
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        // The status of the PCL request should be in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        // Transferring borrow tokens to the lender, and then lender lends to the PCL
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // The collection period gets over
        vm.warp(block.timestamp + request.collectionPeriod);

        // Borrower signs the required documents and then calls the start function
        pooledCreditLineBorrower.start(pooledCreditLineID);

        // Since the borrowLimit is met, the status should change to ACTIVE state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.ACTIVE);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Since borrow can only be done after the collection period,
        vm.warp(block.timestamp + request.collectionPeriod);

        // Calculating the borrowable amount:
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        amountToBorrow = borrowableAmount.div(4);

        // Trying to borrow the a fourth of the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        // Finding the number of strategies in the strategy registry
        address[] memory strategyList = strategyRegistry.getStrategies();
        uint256 noOfStrategies = strategyList.length;

        // The number of strategies should be 2 (Compound Yield and No Yield)
        assertEq(noOfStrategies, 2);

        // Something went terribly wrong and now we want to pause all interactions with the strategy registry.
        // Setting the new strategy registry address to address(0) or 0xffff....ff doesn't work. This error is thrown:
        // Revert (""UpgradeableProxy: new implementation is not a contract"")
        address pcl_strategyRegistry_old = address(pooledCreditLine.STRATEGY_REGISTRY());
        address strategyRegistry_impl = proxyAdmin.getImplementationAddressOfProxy(strategyRegistryProxyInstance);

        // Changing the implementation contract for the strategy registry proxy
        proxyAdmin.changeImplementationAddressOfProxy(address(strategyRegistryProxyInstance), address(pausedContract));

        // Now the implementation contract has been changed to the Paused contract
        address pausedContractAddress = proxyAdmin.getImplementationAddressOfProxy(strategyRegistryProxyInstance);
        address pcl_strategyRegistry_new = address(pooledCreditLine.STRATEGY_REGISTRY());

        // assert that the strategy registry address for the pcl should not change
        assertEq(pcl_strategyRegistry_new, pcl_strategyRegistry_old);

        // Assert that the implementation addresses of the strategy registry changed to a paused contract
        assertTrue(strategyRegistry_impl != pausedContractAddress);

        // Checking whether the state of the StrategyRegistry contract was maintained after the upgrade or not
        // This call should break (since we cannot call these functions from the Paused contract)
        strategyList = strategyRegistry.getStrategies();
    }

    // Test24: Test the pause and upgrade functionality of Compound Yield Contract
    function test_pauseAndUpgradeCompoundYieldContract() public {
        // Create the request
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        // The status of the PCL request should be in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        // Transferring borrow tokens to the lender, and then lender lends to the PCL
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // The collection period gets over
        vm.warp(block.timestamp + request.collectionPeriod);

        // Borrower signs the required documents and then calls the start function
        pooledCreditLineBorrower.start(pooledCreditLineID);

        // Since the borrowLimit is met, the status should change to ACTIVE state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.ACTIVE);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Since borrow can only be done after the collection period,
        vm.warp(block.timestamp + request.collectionPeriod);

        // Calculating the borrowable amount:
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        amountToBorrow = borrowableAmount.div(4);

        // Trying to borrow the a fourth of the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        uint256 balanceInShares = savingsAccount.balanceInShares(
            address(pooledCreditLine),
            address(request.collateralAsset),
            address(compoundYield)
        );
        assertTrue(balanceInShares > 0);
        uint256 depositLimit = compoundYield.depositLimit(request.collateralAsset);

        // Some bug is discovered in the NoYield contract and we want to pause all interactions with the NoYield contract now.
        address compoundYieldAddressInPCL = strategyRegistry.getStrategies()[1];
        address compoundYieldImplementation = proxyAdmin.getImplementationAddressOfProxy(compoundYieldProxyInstance);

        proxyAdmin.changeImplementationAddressOfProxy(address(compoundYieldProxyInstance), address(pausedContract));

        // The implementation contract has changed but the proxy address should remain the same for PCL
        address compoundYieldAddressInPCLWhenPaused = strategyRegistry.getStrategies()[1];
        address compoundYieldImplementationWhenPaused = proxyAdmin.getImplementationAddressOfProxy(compoundYieldProxyInstance);

        assertTrue(compoundYieldAddressInPCL == compoundYieldAddressInPCLWhenPaused);
        assertTrue(compoundYieldImplementation != compoundYieldImplementationWhenPaused);

        // Now we assume that we patched the CompoundYield contract
        CompoundYield patchedCompoundYield = new CompoundYield(address(WETH), Constants._treasuryAddress, address(savingsAccount));
        proxyAdmin.changeImplementationAddressOfProxy(address(compoundYieldProxyInstance), address(patchedCompoundYield));

        // Let's see if the implementation address changed or not
        address compoundYieldImplementationPatched = proxyAdmin.getImplementationAddressOfProxy(compoundYieldProxyInstance);

        assertTrue(compoundYieldImplementationWhenPaused != compoundYieldImplementationPatched);
        assertTrue(compoundYieldImplementation != compoundYieldImplementationPatched);

        address compoundYieldAddressInPCLPatched = strategyRegistry.getStrategies()[1];
        assertTrue(compoundYieldAddressInPCLWhenPaused == compoundYieldAddressInPCLPatched);

        // Let us see if the state was maintained or not
        uint256 balanceInSharesFinal = savingsAccount.balanceInShares(
            address(pooledCreditLine),
            address(request.collateralAsset),
            address(compoundYield)
        );
        assertTrue(balanceInShares == balanceInSharesFinal);
        uint256 depositLimitFinal = compoundYield.depositLimit(request.collateralAsset);
        assertTrue(depositLimit == depositLimitFinal);
    }

    // Test24: Test the pause functionality of Compound Yield Contract. No interaction is possible with Compound yield contract.
    function testFail_pauseCompoundYieldContract() public {
        // Create the request
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        // The status of the PCL request should be in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        // Transferring borrow tokens to the lender, and then lender lends to the PCL
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // The collection period gets over
        vm.warp(block.timestamp + request.collectionPeriod);

        // Borrower signs the required documents and then calls the start function
        pooledCreditLineBorrower.start(pooledCreditLineID);

        // Since the borrowLimit is met, the status should change to ACTIVE state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.ACTIVE);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Since borrow can only be done after the collection period,
        vm.warp(block.timestamp + request.collectionPeriod);

        // Calculating the borrowable amount:
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        amountToBorrow = borrowableAmount.div(4);

        // Trying to borrow the a fourth of the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        uint256 balanceInShares = savingsAccount.balanceInShares(
            address(pooledCreditLine),
            address(request.collateralAsset),
            address(compoundYield)
        );
        assertTrue(balanceInShares > 0);
        uint256 depositLimit = compoundYield.depositLimit(request.collateralAsset);

        // Some bug is discovered in the NoYield contract and we want to pause all interactions with the NoYield contract now.
        address compoundYieldAddressInPCL = strategyRegistry.getStrategies()[1];
        address compoundYieldImplementation = proxyAdmin.getImplementationAddressOfProxy(compoundYieldProxyInstance);

        proxyAdmin.changeImplementationAddressOfProxy(address(compoundYieldProxyInstance), address(pausedContract));

        // The implementation contract has changed but the proxy address should remain the same for PCL
        address compoundYieldAddressInPCLWhenPaused = strategyRegistry.getStrategies()[1];
        address compoundYieldImplementationWhenPaused = proxyAdmin.getImplementationAddressOfProxy(compoundYieldProxyInstance);

        assertTrue(compoundYieldAddressInPCL == compoundYieldAddressInPCLWhenPaused);
        assertTrue(compoundYieldImplementation != compoundYieldImplementationWhenPaused);

        uint256 depositLimitFinal = compoundYield.depositLimit(request.collateralAsset);
    }

    // Test25: Pause and upgrade the PooledCreditLine contract
    function test_pauseAndUpgradePCLContract() public {
        // Create the request
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        // The status of the PCL request should be in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        // Transferring borrow tokens to the lender, and then lender lends to the PCL
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // The collection period gets over
        vm.warp(block.timestamp + request.collectionPeriod);

        // Borrower signs the required documents and then calls the start function
        pooledCreditLineBorrower.start(pooledCreditLineID);

        // Since the borrowLimit is met, the status should change to ACTIVE state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.ACTIVE);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Since borrow can only be done after the collection period,
        vm.warp(block.timestamp + request.collectionPeriod);

        // Calculating the borrowable amount:
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        amountToBorrow = borrowableAmount.div(4);

        // Trying to borrow the a fourth of the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        // Checking the state with the current implementation
        uint256 protocolFeeFractionCurrent = pooledCreditLine.protocolFeeFraction();
        uint256 depositedCollateralCurrent = pooledCreditLine.depositedCollateralInShares(pooledCreditLineID);

        // Some bug is discovered in the PCL contract and we want to pause all interactions with the PCL contract now
        address pclAddressCurrent = address(pooledCreditLine);
        address pclImplementationCurrent = proxyAdmin.getImplementationAddressOfProxy(pooledCreditLineProxyInstance);

        proxyAdmin.changeImplementationAddressOfProxy(address(pooledCreditLineProxyInstance), address(pausedContract));

        // The implementation contract has changed but the proxy address itself should remain the same
        address pclAddressPaused = address(pooledCreditLine);
        address pclImplementationPaused = proxyAdmin.getImplementationAddressOfProxy(pooledCreditLineProxyInstance);

        assertTrue(pclAddressCurrent == pclAddressPaused);
        assertTrue(pclImplementationCurrent != pclImplementationPaused);

        // Now we assume we patched the PCL contract
        PooledCreditLine patchedPCL = new PooledCreditLine(
            address(lenderPool),
            address(USDC),
            address(priceOracle),
            address(savingsAccount),
            address(strategyRegistry),
            address(verification),
            1e18 / 10
        );
        proxyAdmin.changeImplementationAddressOfProxy(address(pooledCreditLineProxyInstance), address(patchedPCL));

        // Let's see if the implementation address changed or not
        address pclImplementationPatched = proxyAdmin.getImplementationAddressOfProxy(pooledCreditLineProxyInstance);
        address pclAddressPatched = address(pooledCreditLine);

        assertTrue(pclImplementationPaused != pclImplementationPatched);
        assertTrue(pclImplementationCurrent != pclImplementationPatched);
        assertTrue(pclAddressPaused == pclAddressPatched);

        // Checking the state with the patched implementation
        uint256 protocolFeeFractionPatched = pooledCreditLine.protocolFeeFraction();
        uint256 depositedCollateralPatched = pooledCreditLine.depositedCollateralInShares(pooledCreditLineID);

        assertTrue(protocolFeeFractionPatched == protocolFeeFractionCurrent);
        assertTrue(depositedCollateralPatched == depositedCollateralCurrent);
    }

    // Test26: No interaction with the PCL is possible when the contract is paused
    function testFail_stopPCLContract() public {
        // Create the request
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        // The status of the PCL request should be in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        // Transferring borrow tokens to the lender, and then lender lends to the PCL
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // The collection period gets over
        vm.warp(block.timestamp + request.collectionPeriod);

        // Borrower signs the required documents and then calls the start function
        pooledCreditLineBorrower.start(pooledCreditLineID);

        // Since the borrowLimit is met, the status should change to ACTIVE state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.ACTIVE);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Checking the state with the current implementation
        uint256 protocolFeeFractionCurrent = pooledCreditLine.protocolFeeFraction();
        uint256 depositedCollateralCurrent = pooledCreditLine.depositedCollateralInShares(pooledCreditLineID);

        // Some bug is discovered in the PCL contract and we want to pause all interactions with the PCL contract now
        address pclAddressCurrent = address(pooledCreditLine);
        address pclImplementationCurrent = proxyAdmin.getImplementationAddressOfProxy(pooledCreditLineProxyInstance);

        proxyAdmin.changeImplementationAddressOfProxy(address(pooledCreditLineProxyInstance), address(pausedContract));

        // The implementation contract has changed but the proxy address itself should remain the same
        address pclAddressPaused = address(pooledCreditLine);
        address pclImplementationPaused = proxyAdmin.getImplementationAddressOfProxy(pooledCreditLineProxyInstance);

        assertTrue(pclAddressCurrent == pclAddressPaused);
        assertTrue(pclImplementationCurrent != pclImplementationPaused);

        uint256 protocolFeeFractionPatched = pooledCreditLine.protocolFeeFraction();
        uint256 depositedCollateralPatched = pooledCreditLine.depositedCollateralInShares(pooledCreditLineID);

        assertTrue(protocolFeeFractionPatched == protocolFeeFractionCurrent);
        assertTrue(depositedCollateralPatched == depositedCollateralCurrent);
    }

    // Test27: Pause and upgrade the LenderPool contract
    function test_pauseAndUpgradeLPContract() public {
        // Create the request
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        // The status of the PCL request should be in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        // Transferring borrow tokens to the lender, and then lender lends (half of the borrowLimit) to the PCL
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount / 2);

        // Since the borrowLimit is not met, the status should remain in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        uint256 totalSupplyCurrent = lenderPool.totalSupply(pooledCreditLineID);
        (, , , , uint256 collateralHeldCurrent) = lenderPool.pooledCLVariables(pooledCreditLineID);
        (uint256 startTimeCurrent, , , , , , , ) = lenderPool.pooledCLConstants(pooledCreditLineID);

        // Some bug is discovered in the LP contract and we want to pause all interactions with the LP contract now
        address lpAddressCurrent = address(lenderPool);
        address lpImplementationCurrent = proxyAdmin.getImplementationAddressOfProxy(lenderPoolProxyInstance);

        proxyAdmin.changeImplementationAddressOfProxy(address(lenderPoolProxyInstance), address(pausedContract));

        // The implementation contract has changed but the proxy address itself should remain the same
        address lpAddressPaused = address(lenderPool);
        address lpImplementationPaused = proxyAdmin.getImplementationAddressOfProxy(lenderPoolProxyInstance);

        assertTrue(lpAddressCurrent == lpAddressPaused);
        assertTrue(lpImplementationCurrent != lpImplementationPaused);

        // Now we assume we patched the LP contract
        LenderPool patchedLP = new LenderPool(address(pooledCreditLine), address(savingsAccount), address(verification));
        proxyAdmin.changeImplementationAddressOfProxy(address(lenderPoolProxyInstance), address(patchedLP));

        // Let's see if the implementation address changed or not
        address lpImplementationPatched = proxyAdmin.getImplementationAddressOfProxy(lenderPoolProxyInstance);
        address lpAddressPatched = address(lenderPool);

        assertTrue(lpImplementationPaused != lpImplementationPatched);
        assertTrue(lpImplementationCurrent != lpImplementationPatched);
        assertTrue(lpAddressPaused == lpAddressPatched);

        // Checking the state with the patched implementation
        uint256 totalSupplyPatched = lenderPool.totalSupply(pooledCreditLineID);
        (, , , , uint256 collateralHeldPatched) = lenderPool.pooledCLVariables(pooledCreditLineID);
        (uint256 startTimePatched, , , , , , , ) = lenderPool.pooledCLConstants(pooledCreditLineID);

        assertTrue(totalSupplyCurrent == totalSupplyPatched);
        assertTrue(collateralHeldCurrent == collateralHeldPatched);
        assertTrue(startTimeCurrent == startTimePatched);
    }

    // Test28: No interaction with the LP is possible when the contract is paused
    function testFail_stopLPContracts() public {
        // Create the request
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        // The status of the PCL request should be in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        // Transferring borrow tokens to the lender, and then lender lends (half of the borrowLimit) to the PCL
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount / 2);

        // Since the borrowLimit is not met, the status should remain in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        // Calling these functions from the correct implementation contract of the LenderPool to see if they are working or not
        uint256 totalSupplyCurrent = lenderPool.totalSupply(pooledCreditLineID);
        (, , , , uint256 collateralHeldCurrent) = lenderPool.pooledCLVariables(pooledCreditLineID);
        (uint256 startTimeCurrent, , , , , , , ) = lenderPool.pooledCLConstants(pooledCreditLineID);

        // Some bug is discovered in the LP contract and we want to pause all interactions with the LP contract now
        address lpAddressCurrent = address(lenderPool);
        address lpImplementationCurrent = proxyAdmin.getImplementationAddressOfProxy(lenderPoolProxyInstance);

        proxyAdmin.changeImplementationAddressOfProxy(address(lenderPoolProxyInstance), address(pausedContract));

        // The implementation contract has changed but the proxy address itself should remain the same
        address lpAddressPaused = address(lenderPool);
        address lpImplementationPaused = proxyAdmin.getImplementationAddressOfProxy(lenderPoolProxyInstance);

        assertTrue(lpAddressCurrent == lpAddressPaused);
        assertTrue(lpImplementationCurrent != lpImplementationPaused);

        // These calls should fail (since the implementation contract does not contain this function)
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount / 4);
    }
}",17904
RealWorld_TA_101_ProtocolFeeCollector_RealWorld_20240812142045.log,101,ProtocolFeeCollector,30425,1461,31886,73.0,0.181345,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';

contract ProtocolFeeCollector is ReentrancyGuard, OwnableUpgradeable {
    function initialize(address _owner) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);
    }
}",168
RealWorld_TA_101_PCLActiveStage.t_RealWorld_20240812154131.log,101,PCLActiveStage.t,48491,3091,51582,90.0,0.304275,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../../PCLStageTests/PCLActiveStage.t.sol';

contract PCLActiveStageZeroCollateralBorrowCompound is PCLActiveStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * (10**ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!ACTIVE');
    }
}",344
RealWorld_TA_101_MockVerification2_RealWorld_20240812141038.log,101,MockVerification2,38132,2532,40664,74.0,0.2413,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

contract MockVerification2 {
    mapping(address => bool) public verifiers;
    mapping(address => mapping(address => bool)) public verifiedUsers;

    function isUser(address _user, address _verifier) public view returns (bool) {
        return verifiedUsers[_verifier][_user];
    }

    function verifyUser(address _user, address _verifier) public {
        if (verifiers[_verifier]) {
            verifiedUsers[_verifier][_user] = true;
        } else {
            verifiedUsers[_verifier][_user] = false;
        }
    }

    function unverifyUser(address _user) public {
        require(verifiers[msg.sender], 'Only authorized verifiers can unverify users');
        require(verifiedUsers[msg.sender][_user] == false, 'User either already unverified or was not verified by you');
        verifiedUsers[msg.sender][_user] = false;
    }

    function whitelistVerifier(address _verifier) public {
        verifiers[_verifier] = true;
    }
}",224
RealWorld_TA_101_PCLLiquidatedStage.t_RealWorld_20240812150131.log,101,PCLLiquidatedStage.t,85978,4432,90410,119.0,0.51853,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLLiquidatedStage.t.sol';

contract PCLLiquidatedStageCollateralCompoundBorrowNoYield is PCLLiquidatedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }
}",781
RealWorld_TA_101_PCLClosedStateCompoundYield.t_RealWorld_20240812161001.log,101,PCLClosedStateCompoundYield.t,91085,3926,95011,110.0,0.533945,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLClosedState.t.sol';
import '../../Helpers/PCLParent.t.sol';

contract PCLClosedStatePriceOracleCompoundYield is PCLClosedStatePriceOracle {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        //The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        // Now we assert that we are in the ACTIVE state
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), 2);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(requestId, currentDebt);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }
}",866
RealWorld_TA_101_CLAdmin_RealWorld_20240812170808.log,101,CLAdmin,114503,3982,118485,111.0,0.652155,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '../../roles/Admin.sol';
import '../Helpers/CLConstants.sol';

contract CLAdmin is Admin {
    function deployCLContracts(
        address _mockUSDC,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _mockProtocolFeeCollector
    ) public returns (address) {
        CreditLine _creditLine = new CreditLine(_mockUSDC, _priceOracle, _savingsAccount, _strategyRegistry);

        _creditLine.initialize(
            address(this),
            CLConstants.protocolFeeFraction,
            _mockProtocolFeeCollector,
            CLConstants.liquidatorRewardFraction
        );
        return (address(_creditLine));
    }

    function updateBorrowLimitLimits(
        uint256 _min,
        uint256 _max,
        address _creditLinAddress
    ) public {
        CreditLine _creditLine = CreditLine(_creditLinAddress);
        _creditLine.updateBorrowLimitLimits(_min, _max);
    }

    function updateIdealCollateralRatioLimits(
        uint256 _min,
        uint256 _max,
        address _creditLinAddress
    ) public {
        CreditLine _creditLine = CreditLine(_creditLinAddress);
        _creditLine.updateIdealCollateralRatioLimits(_min, _max);
    }

    function updateBorrowRateLimits(
        uint256 _min,
        uint256 _max,
        address _creditLinAddress
    ) public {
        CreditLine _creditLine = CreditLine(_creditLinAddress);
        _creditLine.updateBorrowRateLimits(_min, _max);
    }

    function updateProtocolFeeFraction(uint256 _protocolFeeFraction, address _creditLinAddress) public {
        CreditLine _creditLine = CreditLine(_creditLinAddress);
        _creditLine.updateProtocolFeeFraction(_protocolFeeFraction);
    }

    function updateProtocolFeeCollector(address _protocolFeeCollector, address _creditLinAddress) public {
        CreditLine _creditLine = CreditLine(_creditLinAddress);
        _creditLine.updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function updateLiquidatorRewardFraction(uint256 _rewardFraction, address _creditLinAddress) public {
        CreditLine _creditLine = CreditLine(_creditLinAddress);
        _creditLine.updateLiquidatorRewardFraction(_rewardFraction);
    }

    //----------------------- Valid credit line function calls -----------------------//

    function borrow(
        address creditLineAddress,
        uint256 id,
        uint256 amount
    ) public {
        CreditLine creditLine = CreditLine(creditLineAddress);

        creditLine.borrow(id, amount);
    }

    function repay(
        address creditLineAddress,
        uint256 id,
        uint256 amount
    ) public {
        CreditLine creditLine = CreditLine(creditLineAddress);

        creditLine.repay(id, amount);
    }

    function setAllowance(
        address spender,
        address token,
        uint256 amount
    ) public {
        IERC20(token).approve(spender, amount);
    }

    function addCollateral(
        address creditLineAddress,
        uint256 id,
        uint256 amount,
        bool fromSavingsAccount
    ) public {
        CreditLine creditLine = CreditLine(creditLineAddress);

        creditLine.depositCollateral(id, amount, fromSavingsAccount);
    }

    function withdrawCollateral(
        address creditLineAddress,
        uint256 id,
        uint256 amount,
        bool toSavingsAccount
    ) public {
        CreditLine creditLine = CreditLine(creditLineAddress);

        creditLine.withdrawCollateral(id, amount, toSavingsAccount);
    }

    function withdrawAllCollateral(
        address creditLineAddress,
        uint256 id,
        bool toSavingsAccount
    ) public {
        CreditLine creditLine = CreditLine(creditLineAddress);

        creditLine.withdrawAllCollateral(id, toSavingsAccount);
    }

    function setAllowanceForSavingsAccount(
        address savingsAccount,
        address token,
        address spender,
        uint256 amount
    ) public {
        SavingsAccount(savingsAccount).approve(token, spender, amount);
    }

    function savingsAccountDeposit(
        address savingsAccount,
        address token,
        address strategy,
        address to,
        uint256 amount
    ) public {
        SavingsAccount(savingsAccount).deposit(token, strategy, to, amount);
    }

    //----------------------- Invalid credit line function calls -----------------------//

    function acceptRequest(address creditLineAddress, uint256 id) public {
        CreditLine creditLine = CreditLine(creditLineAddress);

        creditLine.accept(id);
    }

    function cancelRequest(address creditLineAddress, uint256 id) public {
        CreditLine creditLine = CreditLine(creditLineAddress);

        creditLine.cancel(id);
    }

    function close(address creditLineAddress, uint256 id) public {
        CreditLine creditLine = CreditLine(creditLineAddress);

        creditLine.close(id);
    }

    function updateBorrowLimit(
        address creditLineAddress,
        uint256 id,
        uint128 newBorrowLimit
    ) public {
        CreditLine creditLine = CreditLine(creditLineAddress);

        creditLine.updateBorrowLimit(id, newBorrowLimit);
    }

    function liquidate(
        address creditLineAddress,
        uint256 id,
        bool toSavingsAccount
    ) public {
        CreditLine creditLine = CreditLine(creditLineAddress);

        creditLine.liquidate(id, toSavingsAccount);
    }
}",1155
RealWorld_TA_101_MockV3Aggregator_RealWorld_20240812140416.log,101,MockV3Aggregator,70280,3213,73493,84.0,0.41566,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol';

/**
 * @title MockV3Aggregator
 * @notice Based on the FluxAggregator contract
 * @notice Use this contract when you need to test
 * other contract's ability to read data from an
 * aggregator contract, but how the aggregator got
 * its answer is unimportant
 */
contract MockV3Aggregator is AggregatorV3Interface {
    uint256 public constant override version = 0;

    uint8 public override decimals;
    int256 public latestAnswer;
    uint256 public latestTimestamp;
    uint256 public latestRound;

    mapping(uint256 => int256) public getAnswer;
    mapping(uint256 => uint256) public getTimestamp;
    mapping(uint256 => uint256) private getStartedAt;

    constructor(uint8 _decimals, int256 _initialAnswer) {
        decimals = _decimals;
        updateAnswer(_initialAnswer);
    }

    function updateAnswer(int256 _answer) public {
        latestAnswer = _answer;
        latestTimestamp = block.timestamp;
        latestRound++;
        getAnswer[latestRound] = _answer;
        getTimestamp[latestRound] = block.timestamp;
        getStartedAt[latestRound] = block.timestamp;
    }

    function updateRoundData(
        uint80 _roundId,
        int256 _answer,
        uint256 _timestamp,
        uint256 _startedAt
    ) public {
        latestRound = _roundId;
        latestAnswer = _answer;
        latestTimestamp = _timestamp;
        getAnswer[latestRound] = _answer;
        getTimestamp[latestRound] = _timestamp;
        getStartedAt[latestRound] = _startedAt;
    }

    function getRoundData(uint80 _roundId)
        external
        view
        override
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        return (_roundId, getAnswer[_roundId], getStartedAt[_roundId], getTimestamp[_roundId], _roundId);
    }

    function latestRoundData()
        external
        view
        override
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        return (uint80(latestRound), getAnswer[latestRound], getStartedAt[latestRound], getTimestamp[latestRound], uint80(latestRound));
    }

    function setAnswer(int256 _answer) public {
        updateAnswer(_answer);
    }

    function description() external view override returns (string memory) {
        return 'v0.6/tests/MockV3Aggregator.sol';
    }
}",603
RealWorld_TA_101_Paused_RealWorld_20240812141623.log,101,Paused,19926,1138,21064,65.0,0.12239,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

contract Paused {}",20
RealWorld_TA_101_PCLCancelledState.t_RealWorld_20240812160552.log,101,PCLCancelledState.t,427579,4202,431781,141.0,2.221935,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLCancelledStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        lender_0 = lenders[0].lenderAddress;

        // Let's travel a few days, but stay within the collection period
        vm.warp(block.timestamp + request.collectionPeriod / 2);

        // Borrower tries to cancel the PCL
        borrower.cancelRequest(requestId);
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED, '!Cancelled');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: A cancelled PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start a PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral cannot be deposited
    function test_collateralCannotBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), 100);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try borrower.depositCollateral(requestId, 100, false) {
            revert('Collateral cannot be deposited');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, 0);
    }

    // Test 3.1: Collateral cannot be withdrawn
    function test_collateralCannotBeWithdrawn(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Collateral cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    // Test 3.2: All Collateral cannot be withdrawn
    function test_allCollateralCannotBeWithdrawn(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Collateral cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    // Test 4: Required collateral should not work
    function test_requiredCollateralReverts(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    // Test 5: Borrowable amount remains zero
    function test_borrowableAmountIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 6: A cancelled PCL cannot be closed
    function test_pclCannotBeClosed(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('PCL cannot be closed');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    // Test 7: Collateral ratio should not work
    function test_collateralRatioReverts(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Calculate collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try PCLUser(lender_0).withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from a cancelled PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders can withdraw liquidity
    function test_lendersCanWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _userPoolTokenBalance = lp.balanceOf(address(lender_0), requestId);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _userBorrowTokenBalanceBefore = IERC20(request.borrowAsset).balanceOf(address(lender_0));
        PCLUser(lender_0).withdrawLiquidity(requestId);
        uint256 _userBorrowTokenBalanceAfter = IERC20(request.borrowAsset).balanceOf(address(lender_0));
        assertEq(_userPoolTokenBalance, _userBorrowTokenBalanceAfter - _userBorrowTokenBalanceBefore);

        _userPoolTokenBalance = lp.balanceOf(address(lender_0), requestId);
        assertEq(_userPoolTokenBalance, 0);
    }

    // Test 10: A cancelled PCL cannot be liquidated
    function test_lendersCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // lender_0 tries to liquidate the PCL
        try PCLUser(lender_0).liquidate(requestId, _withdraw) {
            revert('Cannot liquidate a cancelled PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 11: Admin should not be able to terminate
    function test_adminCannotTerminatePCL(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Admin terminates the PCL
        try admin.terminate(requestId) {
            revert('Admin cannot terminate a cancelled PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CTCT1');
        }
    }

    // Test 12: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.1: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest cannot be withdrawn amidst price fluctuations
    function test_lendersCannotWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try lender1.withdrawInterest(requestId) {
            revert('Interest cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    // Test 14: A cancelled PCL cannot be cancelled
    function test_pclCannotBeCancelled(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        vm.warp(block.timestamp + (request.collectionPeriod - 1 days));

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try borrower.cancelRequest(requestId) {
            revert('PCL cannot be cancelled');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function assert_helperFunctionalitiesInCancelledState(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CANCELLED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            try pcl.calculateCurrentCollateralRatio(requestId) {
                revert('Calculate collateral ratio should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'PO:IGUPT1');
            }
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertGt(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from a requested PCL before its collection period
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            try _borrower.calculateTotalCollateralTokens(_id) {
                revert('Collateral tokens should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:CTCT1');
            }
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            try _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id)) {
                revert('Collateral tokens should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:CTTL1');
            }
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CANCELLED);
    }

    function test_helperFunctionsInCancelledState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInCancelledState(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}",4902
RealWorld_TA_101_CLParent_RealWorld_20240812171926.log,101,CLParent,263030,6043,269073,144.0,1.43601,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
import '@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol';

import 'forge-std/Test.sol';

import './CLConstants.sol';
import '../Roles/CLAdmin.sol';
import '../Roles/CLUser.sol';

import '../../../mocks/MockToken.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../interfaces/IWETH9.sol';
import '../../ProtocolFeeCollector.sol';
import '../../Constants.sol';

interface Hevm {
    function warp(uint256) external;

    function store(
        address,
        bytes32,
        bytes32
    ) external;
}

contract CLParent is Test {
    using stdStorage for StdStorage;
    using SafeMath for uint256;

    uint256 constant BLOCK_TIME = 20;

    CLConstants.CreditLineConstants constantsCheck;
    CLConstants.RequestParams requestData;

    bool isForked;

    // ERC20
    ERC20 public collateralAsset;
    ERC20 public borrowAsset;
    ERC20 public usdc;
    IWETH9 public weth;

    // Compound tokens(CTokens)
    address public collateralCTokenAddress; //collateralCToken; //mockCToken1;
    address public borrowCTokenAddress; //borrowCToken; //mockCToken2;

    // Price aggregators (mock)
    MockV3Aggregator public collateralAssetMockAggregator;
    MockV3Aggregator public borrowAssetMockAggregator;
    MockV3Aggregator public usdcMockAggregator;

    // Price aggregators (mock)
    address public collateralAssetAggregatorAddress;
    address public borrowAssetAggregatorAddress;
    address public usdcAggregatorAddress;

    // Logic implementation contract addresses
    address public priceOracleAddress;
    address public savingsAccountAddress;
    address public strategyRegistryAddress;
    address public noYieldAddress;
    address public compoundYieldAddress;
    address public protocolFeeCollectorAddress;
    address public creditLineAddress;

    // Admins for deployements
    CLAdmin public admin;

    // Credit line actors
    CLUser public borrower;
    CLUser public lender;
    CLUser public liquidator;

    function CLSetUp() public {
        uint256 _chainId = getChainID();
        if (_chainId == 1) {
            isForked = true;
        }

        // setting admin addresses
        admin = new CLAdmin();

        // setting Credit line actors
        borrower = new CLUser();
        lender = new CLUser();
        liquidator = new CLUser();

        // deploying  mock protocol fee collector
        protocolFeeCollectorAddress = address(new ProtocolFeeCollector());
        // deploying strategy registry contract
        strategyRegistryAddress = admin.deployStrategyRegistry(CLConstants.maxStrategies);
        // deploying savings account contract
        savingsAccountAddress = admin.deploySavingsAccount(strategyRegistryAddress);
        // deploying no yield contract
        noYieldAddress = admin.deployNoYield(address(admin), savingsAccountAddress, protocolFeeCollectorAddress);

        // adding savings strategies to savings account
        admin.addSavingsAccountStrategy(strategyRegistryAddress, noYieldAddress);

        if (isForked) {
            // forked mode

            //----------------------- Deployment code start -----------------------//
            collateralAsset = ERC20(Constants.WBTC);
            borrowAsset = ERC20(Constants.DAI);
            usdc = ERC20(Constants.USDC);
            weth = IWETH9(Constants.WETH);

            writeTokenBalance(address(admin), address(collateralAsset), collateralAsset.totalSupply());
            writeTokenBalance(address(admin), address(borrowAsset), borrowAsset.totalSupply());
            writeTokenBalance(address(admin), Constants.USDC, usdc.totalSupply());
            // weth.deposit{value: 1e30}();
            // IERC20(Constants.WETH).transfer(address(admin), 1e30);

            // setting price aggregator addresses
            collateralAssetAggregatorAddress = Constants.WBTC_priceFeedChainlink;
            borrowAssetAggregatorAddress = Constants.DAI_priceFeedChainlink;
            usdcAggregatorAddress = Constants.USDC_priceFeedChainlink;

            collateralCTokenAddress = Constants.cWBTC;
            borrowCTokenAddress = Constants.cDAI;

            // deploying compound yield contract
            compoundYieldAddress = admin.deployCompoundYield(
                address(admin),
                savingsAccountAddress,
                address(weth),
                protocolFeeCollectorAddress
            );

            // adding savings strategies to savings account
            admin.addSavingsAccountStrategy(strategyRegistryAddress, compoundYieldAddress);

            // adding cToken for collateralAsset
            admin.addTokenAddressForCompoundYield(payable(compoundYieldAddress), Constants.WBTC, Constants.cWBTC);
            admin.setDepositLimitForCompoundYield(payable(compoundYieldAddress), Constants.WBTC, type(uint256).max);
            admin.setDepositLimitForCompoundYield(payable(compoundYieldAddress), Constants.cWBTC, type(uint256).max);

            // adding cToken for borrowAsset
            admin.addTokenAddressForCompoundYield(payable(compoundYieldAddress), Constants.DAI, Constants.cDAI);
            admin.setDepositLimitForCompoundYield(payable(compoundYieldAddress), Constants.DAI, type(uint256).max);
            admin.setDepositLimitForCompoundYield(payable(compoundYieldAddress), Constants.cDAI, type(uint256).max);

            // adding token addresses for noYield
            admin.addTokenAddressForNoYield(noYieldAddress, Constants.WBTC);
            admin.addTokenAddressForNoYield(noYieldAddress, Constants.DAI);
        } else {
            // mock contract deployments
            vm.warp(block.timestamp + 10);

            //----------------------- Deployment code start -----------------------//

            // deploying mock tokens
            collateralAsset = new MockToken('CollateralAsset', 'MT1', 18, 1e40, address(admin));
            borrowAsset = new MockToken('BorrowAsset', 'MT2', 8, 1e40, address(admin));
            usdc = new MockToken('USDC', 'USDC', 6, 1e20, address(admin));
            weth = new MockWETH();

            // deploying price aggregators
            collateralAssetMockAggregator = new MockV3Aggregator(18, 12876423400040030304304);
            borrowAssetMockAggregator = new MockV3Aggregator(8, 195040576);
            usdcMockAggregator = new MockV3Aggregator(6, 1000000);

            // setting price aggregator addresses
            collateralAssetAggregatorAddress = address(collateralAssetMockAggregator);
            borrowAssetAggregatorAddress = address(borrowAssetMockAggregator);
            usdcAggregatorAddress = address(usdcMockAggregator);

            // deploying compound yield contract
            compoundYieldAddress = admin.deployCompoundYield(
                address(admin),
                savingsAccountAddress,
                address(weth),
                protocolFeeCollectorAddress
            );

            // adding savings strategies to savings account
            admin.addSavingsAccountStrategy(strategyRegistryAddress, compoundYieldAddress);

            // adding cToken for collateralAsset
            collateralCTokenAddress = admin.deployMockCToken(address(collateralAsset), compoundYieldAddress, noYieldAddress);
            admin.transferOwnership(address(collateralAsset), collateralCTokenAddress);

            // adding cToken for borrowAsset
            borrowCTokenAddress = admin.deployMockCToken(address(borrowAsset), compoundYieldAddress, noYieldAddress);
            admin.transferOwnership(address(borrowAsset), borrowCTokenAddress);
        }

        // deploying price oracle
        priceOracleAddress = admin.deployPriceOracle(address(admin), CLConstants.uniswapPriceAveragingPeriod);

        // adding aggregators to price oracle contract
        admin.setChainlinkFeedAddress(
            priceOracleAddress,
            address(collateralAsset),
            collateralAssetAggregatorAddress,
            Constants.CHAINLINK_HEARTBEAT
        );
        admin.setChainlinkFeedAddress(
            priceOracleAddress,
            address(borrowAsset),
            borrowAssetAggregatorAddress,
            Constants.CHAINLINK_HEARTBEAT
        );
        admin.setChainlinkFeedAddress(priceOracleAddress, address(usdc), usdcAggregatorAddress, Constants.CHAINLINK_HEARTBEAT);

        // deploying credit line contract
        creditLineAddress = admin.deployCLContracts(
            address(usdc),
            priceOracleAddress,
            savingsAccountAddress,
            strategyRegistryAddress,
            protocolFeeCollectorAddress
        );

        //----------------------- Deployment code end -----------------------//

        admin.updateBorrowLimitLimits(CLConstants.minBorrowLimit, CLConstants.maxBorrowLimit, creditLineAddress);
        admin.updateIdealCollateralRatioLimits(CLConstants.minCollateralRatio, CLConstants.maxCollteralRatio, creditLineAddress);
        admin.updateBorrowRateLimits(CLConstants.minBorrowRate, CLConstants.maxBorrowRate, creditLineAddress);
    }

    function goToActiveStage() public returns (uint256) {
        uint256 _id = borrower.createRequest(creditLineAddress, requestData);

        getCreditlineConstants(_id);

        if (requestData.requestAsLender) {
            assertEq(constantsCheck.lender, address(borrower));
            assertEq(constantsCheck.borrower, requestData.requestTo);
        } else {
            assertEq(constantsCheck.lender, requestData.requestTo);
            assertEq(constantsCheck.borrower, address(borrower));
        }
        assertEq(constantsCheck.borrowLimit, requestData.borrowLimit);
        assertEq(constantsCheck.idealCollateralRatio, requestData.collateralRatio);
        assertEq(constantsCheck.borrowRate, requestData.borrowRate);
        assertEq(constantsCheck.borrowAsset, requestData.borrowAsset);
        assertEq(constantsCheck.collateralAsset, requestData.collateralAsset);
        assertEq(constantsCheck.collateralStrategy, requestData.collateralStrategy);

        uint256 status = uint256(CreditLine(creditLineAddress).getCreditLineStatus(_id));
        assertEq(status, 1); // Checking if creditLine status is updated to REQUESTED

        CLUser requestedLender = CLUser(requestData.requestTo);
        requestedLender.acceptRequest(creditLineAddress, _id);

        status = uint256(CreditLine(creditLineAddress).getCreditLineStatus(_id));
        assertEq(status, 2); // Checking if creditLine status is updated to ACTIVE

        return (_id);
    }

    function savingsAccount_depositHelper(
        address _user,
        address _asset,
        address _strategy,
        uint256 _amount
    ) public {
        CLUser user = CLUser(_user);

        // mint tokens for user
        admin.transferToken(_asset, address(user), _amount);

        // set token allowance
        user.setAllowance(savingsAccountAddress, _asset, _amount);
        user.setAllowance(_strategy, _asset, _amount);

        // set savings account allowance
        user.setAllowanceForSavingsAccount(savingsAccountAddress, _asset, creditLineAddress, _amount);

        // deposit into savings account
        user.savingsAccountDeposit(savingsAccountAddress, _asset, _strategy, address(user), _amount);
    }

    function getCreditlineConstants(uint256 _id) public {
        (
            bool _autoLiquidation,
            bool _requestByLender,
            uint256 _borrowLimit,
            uint256 _borrowRate,
            uint256 _idealCollateralRatio,
            address _lender,
            address _borrower,
            address _borrowAsset,
            address _borrowAssetStrategy,
            address _collateralAsset,
            address _collateralStrategy
        ) = CreditLine(creditLineAddress).creditLineConstants(_id);

        constantsCheck.autoLiquidation = _autoLiquidation;
        constantsCheck.requestByLender = _requestByLender;
        constantsCheck.borrowLimit = _borrowLimit;
        constantsCheck.borrowRate = _borrowRate;
        constantsCheck.idealCollateralRatio = _idealCollateralRatio;
        constantsCheck.lender = _lender;
        constantsCheck.borrower = _borrower;
        constantsCheck.borrowAsset = _borrowAsset;
        constantsCheck.borrowAssetStrategy = _borrowAssetStrategy;
        constantsCheck.collateralAsset = _collateralAsset;
        constantsCheck.collateralStrategy = _collateralStrategy;
    }

    function scaleToRange256(
        uint256 value,
        uint256 min,
        uint256 max
    ) internal pure returns (uint256) {
        require(max != 0 && max >= min, 'wrong input');
        if (max == min) return max;
        return min + (value % (max - min));
    }

    function scaleToRange128(
        uint128 value,
        uint128 min,
        uint128 max
    ) internal pure returns (uint128) {
        require(max != 0 && max >= min, 'wrong input');
        if (max == min) return max;
        return min + (value % (max - min));
    }

    function compareStrings(string memory a, string memory b) public pure returns (bool) {
        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));
    }

    function getChainID() internal pure returns (uint256) {
        uint256 id;
        assembly {
            id := chainid()
        }
        return id;
    }

    function writeTokenBalance(
        address who,
        address token,
        uint256 amt
    ) internal {
        uint256 _totalSupply = IERC20(token).totalSupply();
        stdstore.target(token).sig(IERC20(token).totalSupply.selector).checked_write(_totalSupply + amt);
        stdstore.target(token).sig(IERC20(token).balanceOf.selector).with_key(who).checked_write(_totalSupply + amt);
    }

    function _increaseBlock(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(BLOCK_TIME));
    }
}",2963
RealWorld_TA_101_PCLNotCreatedStage.t_RealWorld_20240812144438.log,101,PCLNotCreatedStage.t,593276,3354,596630,138.0,3.03346,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLNotCreatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    uint256 notCreatedRequestId;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * (10**ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);

        // Create a few lenders
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount + 1), request.borrowAsset);

        notCreatedRequestId = requestId + 1;
        assertTrue(pcl.getStatusAndUpdate(notCreatedRequestId) == PooledCreditLineStatus.NOT_CREATED);
    }

    // Test1: Test setup
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(notCreatedRequestId) == PooledCreditLineStatus.NOT_CREATED);
    }

    /*************************************************************************************************************************************
    START function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_notCreated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
    }

    function test_adminCannotStartANotCreatedPCL() public {
        assert_start_functionality_in_notCreated_state(notCreatedRequestId, admin, 'Admin cannot start a PCL in notCreated state', 'LP:S1');
    }

    function test_borrowerCannotStartANotCreatedPCL() public {
        assert_start_functionality_in_notCreated_state(
            notCreatedRequestId,
            borrower,
            'Borrower cannot start a PCL in notCreated state',
            'LP:S1'
        );
    }

    function test_lenderCannotStartANotCreatedPCL() public {
        assert_start_functionality_in_notCreated_state(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress), // This lender is from a different PCL with requestId, since lenders for PCL with notCreatedRequestId do not exist
            'Lender cannot start a PCL in notCreated state',
            'LP:S1'
        );
    }

    /**************************************************************************************************************************************
    CANCEL function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_notCreated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
    }

    function test_adminCannotCancelANotCreatedPCL() public {
        assert_cancel_functionality_in_notCreated_state(
            notCreatedRequestId,
            admin,
            'Admin cannot Cancel a PCL in notCreated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotCancelANotCreatedPCL() public {
        assert_cancel_functionality_in_notCreated_state(
            notCreatedRequestId,
            borrower,
            'Borrower cannot Cancel a PCL in notCreated state',
            'PCL:OCLB1'
        );
    }

    function test_lenderCannotCancelANotCreatedPCL() public {
        assert_cancel_functionality_in_notCreated_state(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in notCreated state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    CLOSE function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_notCreated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
    }

    function test_adminCannotCloseANotCreatedPCL() public {
        assert_close_functionality_in_notCreated_state(notCreatedRequestId, admin, 'Admin cannot close a notCreated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseANotCreatedPCL() public {
        assert_close_functionality_in_notCreated_state(
            notCreatedRequestId,
            borrower,
            'Borrower cannot close a notCreated PCL',
            'PCL:OCLB1'
        );
    }

    function test_lenderCannotCloseANotCreatedPCL() public {
        assert_close_functionality_in_notCreated_state(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a notCreated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInNotCreatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the NotCreated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInNotCreatedState(notCreatedRequestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInNotCreatedState(notCreatedRequestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInNotCreatedState(notCreatedRequestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInNotCreatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInNotCreatedState(
            notCreatedRequestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.NOT_CREATED),
            'Admin cannot borrow a PCL in NotCreated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowANotCreatedPCL() public {
        assertBorrowFunctionalityInNotCreatedState(
            notCreatedRequestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.NOT_CREATED),
            'Borrower cannot borrow a PCL in NotCreated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInNotCreatedState(
            notCreatedRequestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.NOT_CREATED),
            'Borrower cannot borrow a PCL in NotCreated state',
            'PCL:OCLB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInNotCreatedState(
            notCreatedRequestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.NOT_CREATED),
            'Lender cannot borrow a PCL in NotCreated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInNotCreatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        _user.setAllowance(address(pcl), address(borrowAsset), 100);

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayANotCreatedPCL() public {
        assertRepayFunctionalityInNotCreatedState(
            notCreatedRequestId,
            admin,
            uint256(PooledCreditLineStatus.NOT_CREATED),
            'Admin cannot repay a NotCreated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayANotCreatedPCL() public {
        assertRepayFunctionalityInNotCreatedState(
            notCreatedRequestId,
            borrower,
            uint256(PooledCreditLineStatus.NOT_CREATED),
            'Borrower cannot repay a NotCreated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayANotCreatedPCL() public {
        assertRepayFunctionalityInNotCreatedState(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.NOT_CREATED),
            'Lender cannot repay a NotCreated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInNotCreatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInNotCreatedState(
            notCreatedRequestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.NOT_CREATED),
            'Admin cannot withdraw collateral in NotCreated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInNotCreatedState(
            notCreatedRequestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.NOT_CREATED),
            'Borrower cannot withdraw collateral in NotCreated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInNotCreatedState(
            notCreatedRequestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.NOT_CREATED),
            'Borrower cannot withdraw zero collateral in NotCreated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInNotCreatedState(
            notCreatedRequestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.NOT_CREATED),
            'Lender cannot withdraw collateral in NotCreated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_NotCreated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromANotCreatedPCL() public {
        assert_withdraw_liquidity_functionality_in_NotCreated_state(
            notCreatedRequestId,
            admin,
            uint256(PooledCreditLineStatus.NOT_CREATED),
            false,
            'Admin cannot withdraw liquidity a PCL in NotCreated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromANotCreatedPCL() public {
        assert_withdraw_liquidity_functionality_in_NotCreated_state(
            notCreatedRequestId,
            borrower,
            uint256(PooledCreditLineStatus.NOT_CREATED),
            false,
            'Borrower cannot withdraw liquidity a PCL in NotCreated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromANotCreatedPCL() public virtual {
        assert_withdraw_liquidity_functionality_in_NotCreated_state(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.NOT_CREATED),
            false,
            'Lender cannot withdraw liquidity a PCL in NotCreated state',
            'LP:IWL1'
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_notCreated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            console.log(reason);
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
    }

    function test_adminCannotLiquidateANotCreatedPCL() public {
        assert_liquidate_functionality_in_notCreated_state(
            notCreatedRequestId,
            admin,
            'Admin cannot liquidate a notCreated PCL',
            'LP:LIQ1'
        );
    }

    function test_borrowerCannotLiquidateANotCreatedPCL() public {
        assert_liquidate_functionality_in_notCreated_state(
            notCreatedRequestId,
            borrower,
            'Borrower cannot liquidate a notCreated PCL',
            'LP:LIQ1'
        );
    }

    function test_lenderCannotLiquidateANotCreatedPCL() public virtual {
        assert_liquidate_functionality_in_notCreated_state(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a notCreated PCL',
            'LP:LIQ1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_notCreated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawInterest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
    }

    function test_adminCannotWithdrawInterestFromANotCreatedPCL() public {
        assert_withdraw_interest_functionality_in_notCreated_state(
            notCreatedRequestId,
            admin,
            'No interest can be withdrawn in a not-created PCL',
            'LP:IWI1'
        );
    }

    function test_borrowerCannotWithdrawInterestFromANotCreatedPCL() public {
        assert_withdraw_interest_functionality_in_notCreated_state(
            notCreatedRequestId,
            borrower,
            'No interest can be withdrawn in a not-created PCL',
            'LP:IWI1'
        );
    }

    function test_lenderCannotWithdrawInterestFromANotCreatedPCL() public {
        assert_withdraw_interest_functionality_in_notCreated_state(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            'No interest can be withdrawn in a not-created PCL',
            'LP:IWI1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests 
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_notCreated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.terminate(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
    }

    function test_adminCannotTerminateANotCreatedPCL() public {
        assert_terminate_functionality_in_notCreated_state(
            notCreatedRequestId,
            admin,
            'Cannot terminate a PCL that is not created',
            'PCL:CTCT1'
        );
    }

    function test_borrowerCannotTerminateANotCreatedPCL() public {
        assert_terminate_functionality_in_notCreated_state(
            notCreatedRequestId,
            borrower,
            'Cannot terminate a PCL that is not created',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateANotCreatedPCL() public {
        assert_terminate_functionality_in_notCreated_state(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is not created',
            'Ownable: caller is not the owner'
        );
    }

    /**************************************************************************************************************************************
    Pool Token Transfer function tests 
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_notCreated_stage(
        uint256 _id,
        PCLUser _fromUser,
        address _toUser,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply = lp.balanceOf(address(_fromUser), _id);
        try _fromUser.transferLPTokens(_toUser, _id, (_fromUserPoolTokenSupply / _fractionOfPTSupply)) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_notCreated_stage(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            lenders[1].lenderAddress,
            1,
            'Should not have gone through',
            'LP:IT3'
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_notCreated_stage(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            lenders[1].lenderAddress,
            2,
            'Should not have gone through',
            'LP:IT3'
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_notCreated_stage(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            address(admin),
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_cannotBurnPoolToken() public {
        assert_pool_token_transfer_in_notCreated_stage(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            address(0),
            1,
            'Should not have gone through',
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf() public {
        assert_pool_token_transfer_in_notCreated_stage(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            lenders[0].lenderAddress,
            1,
            'Should not have gone through',
            'LP:IT1'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                notCreatedRequestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(notCreatedRequestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(notCreatedRequestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(notCreatedRequestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(notCreatedRequestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_notcreated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_notcreatedState() public {
        assert_withdraw_liquidation_in_notcreated_state(
            notCreatedRequestId,
            admin,
            'Cannot withdraw liquidation/liquidity from a notcreated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_notcreatedState() public {
        assert_withdraw_liquidation_in_notcreated_state(
            notCreatedRequestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from a notcreated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_notcreatedState() public virtual {
        assert_withdraw_liquidation_in_notcreated_state(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from a notcreated PCL',
            'LP:WLC1'
        );
    }

    /**************************************************************************************************************************************
    View/calculation function tests 
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_notCreated_state(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculatePrincipalWithdrawable
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0);

        // 2. withdrawableCollateral
        try _borrower.withdrawableCollateral(_id) {
            revert('withdrawable collateral cannot be called in a not created PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CTCT1');
        }

        // 3. calculateTotalCollateralTokens
        try _borrower.calculateTotalCollateralTokens(_id) {
            revert('Total collateral tokens cannot be calculated for a not created PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CTCT1');
        }

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0);

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        // Test Number 7 should ideally have been returning a revert string, but right now they return PO:IGUPT1

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1));
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0);
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CTTL1');
        }
    }

    function test_helperFunctionInNotCreatedState() public {
        assert_helper_functionalities_in_notCreated_state(notCreatedRequestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}",6804
RealWorld_TA_101_PCLLifecycleTest.t_RealWorld_20240812152021.log,101,PCLLifecycleTest.t,1166636,68,1166704,215.0,5.83454,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../Helpers/PCLParent.t.sol';

/*

possible paths:
- not created -> requested
- requested -> cancelled
- requested -> terminated
- requested -> active
- active -> closed
- active -> expired
- active -> liquidated
- active -> terminated
- liquidated -> terminated
- closed -> terminated
- expired -> terminated
- expired -> liquidated
- expired -> closed

enum PooledCreditLineStatus {
     NOT_CREATED,
     REQUESTED,
     ACTIVE,
     CLOSED,
     EXPIRED,
     LIQUIDATED,
     CANCELLED
     TERMINATED
}

*/

contract PCLLifecycleTest is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    event PooledCreditLineAccepted(uint256 indexed id, uint256 amount);

    uint256 t0;
    uint256 requestId;
    uint128 amountToLend;
    uint256 randomNumber1;
    uint256 randomNumber2;
    uint256 randomNumber3;
    uint256 actualBorrowLimit;

    function setUp() public virtual override {
        super.setUp();

        t0 = block.timestamp;
        // fuzzed
        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128(PCLConstants.minBorrowRate.mul(5));
        // fuzzed
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = PCLConstants.maxDuration;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = PCLConstants.minDefaultGraceDuration;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = PCLConstants.minCollectionPeriod;
        // fuzzed
        request.minBorrowAmount = 90_000 * (10**ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;
    }

    function goToRequestedStageFuzzed(
        uint256 _borrowLimitInUsd,
        uint256 _collateralRatio,
        uint128 _amountToLend,
        uint256 _randomNumber1,
        uint256 _randomNumber2,
        uint256 _randomNumber3
    ) public {
        randomNumber1 = scaleToRange256(_randomNumber1, 1, 10);
        randomNumber2 = scaleToRange256(_randomNumber2, 2, 10);
        randomNumber3 = scaleToRange256(_randomNumber3, 3, 10);

        request.borrowRate = scaleToRange128(_amountToLend, PCLConstants.minBorrowRate, uint128(PCLConstants.maxBorrowRate.div(20)));
        emit log_named_uint('borrowRate', request.borrowRate);
        request.duration = PCLConstants.maxDuration.div(randomNumber3);
        request.collectionPeriod = PCLConstants.minCollectionPeriod.mul(randomNumber2);
        request.defaultGracePeriod = PCLConstants.minDefaultGraceDuration.mul(randomNumber1);

        {
            _borrowLimitInUsd = scaleToRange256(_borrowLimitInUsd, PCLConstants.minBorrowLimit, PCLConstants.maxBorrowLimit);
            emit log_named_uint('_borrowLimitInUsd', _borrowLimitInUsd);
            request.collateralRatio = scaleToRange256(_collateralRatio, PCLConstants.minCollateralRatio, PCLConstants.maxCollateralRatio);
            emit log_named_uint('request.collateralRatio', request.collateralRatio);

            if (_borrowLimitInUsd <= PCLConstants.minBorrowLimit.mul(110).div(100)) {
                request.collateralRatio = pcl.SCALING_FACTOR();
            }

            (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
                address(borrowAsset),
                address(usdc)
            );
            emit log_named_decimal_uint('_ratioOfPrices', _ratioOfPrices, _decimals);
            // adding 1 because of rounding down by division with _ratioOfPrices
            request.borrowLimit = uint128(_borrowLimitInUsd.mul(10**_decimals).div(_ratioOfPrices).add(1));
            emit log_named_uint('request.borrowLimit', request.borrowLimit);
            uint256 _minBorrowAmount;
            if (randomNumber3 < randomNumber2) {
                _minBorrowAmount = request.borrowLimit.mul(randomNumber3).div(randomNumber2);
            } else {
                _minBorrowAmount = request.borrowLimit.mul(randomNumber2).div(randomNumber3 + 1);
            }
            // convert _minBorrowAmount to usdc and compare with min in pcl constants
            if (_minBorrowAmount.mul(_ratioOfPrices).div(10**_decimals) < PCLConstants.minBorrowLimit) {
                _minBorrowAmount = PCLConstants.minBorrowLimit.mul(10**_decimals).div(_ratioOfPrices);
            }
            // adding 1 because of rounding down by division with _ratioOfPrices
            request.minBorrowAmount = _minBorrowAmount.add(1);
            emit log_named_uint('request.minBorrowAmount', request.minBorrowAmount);
        }

        // taking enough to go into active stage
        amountToLend = scaleToRange128(_amountToLend, uint128(request.minBorrowAmount), request.borrowLimit);
        emit log_named_uint('amountToLend', amountToLend);

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // move a bit ahead in time
        _increaseBlock(t0 + (request.collectionPeriod.div(randomNumber2)));

        numLenders = createMultipleLenders(requestId, randomNumber3, amountToLend, request.borrowAsset);
        emit log_named_uint('numLenders', numLenders);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
        // check total supply
        assertEq(amountToLend, lp.totalSupply(requestId));
    }

    function test_requestToActiveToLiquidatePCL(
        uint256 _borrowLimitInUsd,
        uint256 _collateralRatio,
        uint128 _amountToLend,
        uint256 _randomNumber1,
        uint256 _randomNumber2,
        uint256 _randomNumber3
    ) public {
        goToRequestedStageFuzzed(_borrowLimitInUsd, _collateralRatio, _amountToLend, _randomNumber1, _randomNumber2, _randomNumber3);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        {
            vm.expectRevert(bytes('PCL:IB2'));
            borrower.borrow(requestId, request.borrowLimit.div(randomNumber3));

            vm.expectRevert(bytes('LP:WI1'));
            _lender.withdrawInterest(requestId);

            vm.expectRevert(bytes('LP:IWL3'));
            _lender.withdrawLiquidity(requestId);

            vm.expectRevert(bytes('PCL:L1'));
            _lender.liquidate(requestId, false);

            vm.expectRevert(bytes('LP:IWLC1'));
            _lender.withdrawTokensAfterLiquidation(requestId);
        }

        // start the pcl
        {
            // go head in time
            _increaseBlock(t0 + request.collectionPeriod);
            vm.expectEmit(true, true, false, true);
            emit PooledCreditLineAccepted(requestId, amountToLend);
            borrower.start(requestId);
            // check status
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        }

        {
            (, , , actualBorrowLimit, , , , ) = lp.pooledCLConstants(requestId);
        }

        uint256 _requiredCollateral;

        {
            // try to borrow some tokens
            uint256 _amountToBorrow = amountToLend.mul(randomNumber2).div(11);
            emit log_named_uint('_amountToBorrow', _amountToBorrow);
            bool isOverLimit;
            vm.expectRevert(bytes('PCL:IB3'));
            borrower.borrow(requestId, _amountToBorrow);
            // decide how much collateral is needed
            _requiredCollateral = pcl.getRequiredCollateral(requestId, _amountToBorrow);
            emit log_named_uint('_requiredCollateral', _requiredCollateral);
            if (_requiredCollateral > collateralAsset.balanceOf(address(admin))) {
                _requiredCollateral = collateralAsset.balanceOf(address(admin)).div(randomNumber3);
                isOverLimit = true;
            }
            admin.transferToken(address(collateralAsset), address(borrower), _requiredCollateral);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _requiredCollateral);
            borrower.depositCollateral(requestId, _requiredCollateral, false);
            uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
            emit log_named_uint('_borrowableAmount', _borrowableAmount);
            if (!isOverLimit) {
                // adding 1 for precision errors
                if (stdMath.delta(_amountToBorrow, _borrowableAmount) > 2 && _requiredCollateral > 1e3) {
                    assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e16);
                }
            }
            // borrow the required amount
            uint256 _startBalance = borrowAsset.balanceOf(address(borrower));
            borrower.borrow(requestId, _borrowableAmount);
            assertApproxEqRel(
                _borrowableAmount.mul(pcl.SCALING_FACTOR().sub(pcl.protocolFeeFraction())).div(pcl.SCALING_FACTOR()),
                borrowAsset.balanceOf(address(borrower)).sub(_startBalance),
                1e14
            );
        }

        {
            // verify current collateral ratio
            emit log_named_uint('_curCollateralRatio', pcl.calculateCurrentCollateralRatio(requestId));
            assertApproxEqRel(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio, 1e14);
        }

        // go ahead in time to accrue interest
        _increaseBlock(t0 + request.collectionPeriod + request.duration.div(randomNumber3));

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        emit log_named_uint('_interestAccrued', _interestAccrued);

        {
            if (_interestAccrued > borrowAsset.balanceOf(address(borrower))) {
                if (_interestAccrued > borrowAsset.balanceOf(address(admin))) {
                    writeTokenBalance(address(admin), request.borrowAsset, _interestAccrued);
                }
                admin.transferToken(request.borrowAsset, address(borrower), _interestAccrued.sub(borrowAsset.balanceOf(address(borrower))));
            }
            // repay the interest only
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _interestAccrued);
            borrower.repay(requestId, _interestAccrued);
        }

        uint256 _totalLenderInterest;

        {
            // get total lender interest
            for (uint256 i; i < numLenders; ++i) {
                _totalLenderInterest = _totalLenderInterest.add(lp.getLenderInterestWithdrawable(requestId, lenders[i].lenderAddress));
            }
            emit log_named_uint('_totalLenderInterest', _totalLenderInterest);

            (
                uint256 _sharesHeld,
                uint256 _borrowerInterestShares,
                uint256 _borrowerInterestSharesWithdrawn,
                uint256 _yieldInterestWithdrawnShares,

            ) = lp.pooledCLVariables(requestId);
            emit log_named_uint('_sharesHeld', _sharesHeld);
            emit log_named_uint('_borrowerInterestShares', _borrowerInterestShares);
            emit log_named_uint('_borrowerInterestSharesWithdrawn', _borrowerInterestSharesWithdrawn);
            emit log_named_uint('_yieldInterestWithdrawnShares', _yieldInterestWithdrawnShares);
            uint256 _notBorrowedInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
                actualBorrowLimit.sub(pcl.getPrincipal(requestId)),
                request.borrowAsset
            );
            emit log_named_uint('_notBorrowedInShares', _notBorrowedInShares);

            uint256 _expectedYieldInterestShares = _sharesHeld
                .sub(_notBorrowedInShares)
                .sub(_borrowerInterestShares)
                .sub(_borrowerInterestSharesWithdrawn)
                .sub(_yieldInterestWithdrawnShares);
            uint256 _expectedYieldInterest = IYield(request.borrowAssetStrategy).getTokensForShares(
                _expectedYieldInterestShares,
                request.borrowAsset
            );
            emit log_named_uint('_expectedYieldInterest', _expectedYieldInterest);
            assertApproxEqRel(_interestAccrued, _totalLenderInterest.sub(_expectedYieldInterest), 1e16);
        }

        {
            uint256 _totalWithdrawn;
            // lender withdraws interest
            uint256 _prevBalance = borrowAsset.balanceOf(address(_lender));
            uint256 _lenderInterest = lp.getLenderInterestWithdrawable(requestId, address(_lender));
            _lender.withdrawInterest(requestId);
            _totalWithdrawn = borrowAsset.balanceOf(address(_lender)).sub(_prevBalance);
            assertApproxEqRel(borrowAsset.balanceOf(address(_lender)).sub(_prevBalance), _lenderInterest, 1e16);

            uint256 _prevBalanceI;
            for (uint256 i = 1; i < numLenders; ++i) {
                _prevBalanceI = borrowAsset.balanceOf(lenders[i].lenderAddress);
                PCLUser(lenders[i].lenderAddress).withdrawInterest(requestId);
                _totalWithdrawn = _totalWithdrawn.add(borrowAsset.balanceOf(lenders[i].lenderAddress).sub(_prevBalanceI));
            }
            emit log_named_uint('_totalWithdrawn', _totalWithdrawn);
            assertApproxEqRel(_totalWithdrawn, _totalLenderInterest, 1e16);
        }

        {
            // borrow again
            vm.expectRevert(bytes('PCL:IB3'));
            borrower.borrow(requestId, amountToLend.div(randomNumber3));

            // go ahead in time a bit for more interest to accrued
            _increaseBlock(block.timestamp + request.duration.div(randomNumber3));
        }

        {
            emit log_named_uint('_curCollateralRatio', pcl.calculateCurrentCollateralRatio(requestId));
            if (pcl.calculateCurrentCollateralRatio(requestId) > request.collateralRatio) {
                // amount of collateral deposited has grown because of yield interest
                assertTrue(_requiredCollateral < pcl.calculateTotalCollateralTokens(requestId));
                _increaseBlock(t0 + request.collectionPeriod + request.duration + request.defaultGracePeriod);
            } else {
                assertLe(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
            }
        }

        uint256 _startBalanceBorrowAssetLender = borrowAsset.balanceOf(address(_lender));
        uint256 _collateralTokensLiquidated = pcl.calculateTotalCollateralTokens(requestId);
        emit log_named_uint('_collateralTokensLiquidated', _collateralTokensLiquidated);
        uint256 _principalWithdrawable = actualBorrowLimit
            .sub(pcl.getPrincipal(requestId))
            .mul(lp.balanceOf(address(_lender), requestId))
            .div(lp.totalSupply(requestId));
        emit log_named_uint('_principalWithdrawable', _principalWithdrawable);
        uint256 _interestWithdrawable = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        emit log_named_uint('_interestWithdrawable', _interestWithdrawable);

        // pcl can be liquidated
        {
            _lender.liquidate(requestId, true);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
            uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(requestId);
            emit log_named_uint('_totalCollateral', _totalCollateral);
            uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
            emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);

            assertEq(_withdrawableCollateral, _totalCollateral);

            if (_totalCollateral != 0) {
                _collateralTokensLiquidated = _collateralTokensLiquidated.sub(_withdrawableCollateral);
            }
        }

        // borrower still has borrowed assets minnus the paid interest
        // principal * (1 - protocal_fee) - interest paid == borrow asset balance of the borrower
        // not borrower balance of borrowAsset is 0 initially
        {
            uint256 _expectedBorrowAmountReceived = pcl
                .getPrincipal(requestId)
                .mul(pcl.SCALING_FACTOR().sub(pcl.protocolFeeFraction()))
                .div(pcl.SCALING_FACTOR());
            uint256 _expectedBorrowerBalance;
            if (_interestAccrued <= _expectedBorrowAmountReceived) {
                _expectedBorrowerBalance = _expectedBorrowAmountReceived.sub(_interestAccrued);
            } else {
                _expectedBorrowerBalance = 0;
            }
            emit log_named_uint('_expectedBorrowerBalance', _expectedBorrowerBalance);
            assertApproxEqAbs(_expectedBorrowerBalance, borrowAsset.balanceOf(address(borrower)), 2);
        }

        {
            // lender has the got back the principal left
            uint256 _expectedBorrowAssetWithdrawn = _principalWithdrawable.add(_interestWithdrawable);
            emit log_named_uint('_expectedBorrowAssetWithdrawn', _expectedBorrowAssetWithdrawn);
            assertApproxEqRel(
                _expectedBorrowAssetWithdrawn,
                borrowAsset.balanceOf(address(_lender)).sub(_startBalanceBorrowAssetLender),
                1e15
            );
        }
        {
            // lender has the got their share of the collateral
            // collateral_liquidated * lenders_lent_amount / total_lent_amount == collateral asset balance of the lender
            uint256 _lenderCollateral = _collateralTokensLiquidated.mul(lenders[0].amount).div(amountToLend);
            uint256 _collateralAssetBalance = collateralAsset.balanceOf(address(_lender));
            emit log_named_uint('_lenderCollateral', _lenderCollateral);
            emit log_named_uint('_collateralAssetBalance', _collateralAssetBalance);
            if (stdMath.delta(_lenderCollateral, _collateralAssetBalance) > 2) {
                assertApproxEqRel(_lenderCollateral, _collateralAssetBalance, 1e16);
            }
        }

        {
            PCLUser _lastLender = PCLUser(lenders[numLenders - 1].lenderAddress);
            uint256 _startCollateralBalance = collateralAsset.balanceOf(address(_lastLender));
            uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(_lastLender));
            emit log_named_uint('pcl.getPrincipal', pcl.getPrincipal(requestId));
            emit log_named_uint('lp balance', lp.balanceOf(address(_lastLender), requestId));
            uint256 _principalWithdrawable = lp.calculatePrincipalWithdrawable(requestId, address(_lastLender));
            emit log_named_uint('_principalWithdrawable', _principalWithdrawable);
            uint256 _interestWithdrawable = lp.getLenderInterestWithdrawable(requestId, address(_lastLender));
            emit log_named_uint('_interestWithdrawable', _interestWithdrawable);
            emit log_named_uint('borrow asset withdrawable of lender', _principalWithdrawable.add(_interestWithdrawable));
            // we cannot use lp balances because total supply is now not equal to amount lent
            uint256 _expectedCollateralWithdrawn = _collateralTokensLiquidated.mul(lenders[numLenders - 1].amount).div(amountToLend);
            emit log_named_uint('_expectedCollateralWithdrawn', _expectedCollateralWithdrawn);
            _lastLender.withdrawTokensAfterLiquidation(requestId);
            if (
                stdMath.delta(_startCollateralBalance.add(_expectedCollateralWithdrawn), collateralAsset.balanceOf(address(_lastLender))) >
                2
            ) {
                assertApproxEqRel(
                    _startCollateralBalance.add(_expectedCollateralWithdrawn),
                    collateralAsset.balanceOf(address(_lastLender)),
                    1e15
                );
            }

            emit log_named_uint('_expectedBorrowAssetWithdrawn', _principalWithdrawable.add(_interestWithdrawable));
            assertApproxEqRel(
                _startBorrowAssetBalance.add(_principalWithdrawable.add(_interestWithdrawable)),
                borrowAsset.balanceOf(address(_lastLender)),
                1e15
            );
        }
    }

    event Lend(uint256 indexed id, address indexed user, uint256 amount);
    event BorrowedFromPooledCreditLine(uint256 indexed id, uint256 borrowAmount);
    event AccrueInterest(uint256 cashPrior, uint256 interestAccumulated, uint256 borrowIndexNew, uint256 totalBorrowsNew);

    function test_requestToActiveToClosedPCL(
        uint256 _randomAmount,
        uint256 _collateralRatio,
        uint128 _amountToLend,
        uint256 _randomNumber1,
        uint256 _randomNumber2,
        uint256 _randomNumber3
    ) public {
        goToRequestedStageFuzzed(_randomAmount, _collateralRatio, _amountToLend, _randomNumber1, _randomNumber2, _randomNumber3);

        {
            if (request.borrowLimit > amountToLend) {
                PCLUser _lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
                vm.expectRevert(bytes('LP:L1'));
                _lender.lend(requestId, 0);
                vm.expectRevert(bytes('LP:L2'));
                _lender.lend(requestId, 1e2);

                address _lenderAddress = createLender(requestId, request.borrowLimit - amountToLend, request.borrowAsset);
                lenders[numLenders] = LenderInfo(_lenderAddress, request.borrowLimit - amountToLend);
                amountToLend = request.borrowLimit;
                assertEq(request.borrowLimit, lp.totalSupply(requestId));
            } else {
                assertEq(request.borrowLimit, lp.totalSupply(requestId));
                PCLUser _lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
                _lender.registerSelf(mockAdminVerifier1);
                vm.expectRevert(bytes('LP:L4'));
                _lender.lend(requestId, amountToLend.div(randomNumber3));
            }
        }

        // start the pcl
        {
            // go head in time
            _increaseBlock(t0 + request.collectionPeriod);
            vm.expectEmit(true, true, false, true);
            emit PooledCreditLineAccepted(requestId, amountToLend);
            borrower.start(requestId);
            // check status
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        }

        {
            (, , , actualBorrowLimit, , , , ) = lp.pooledCLConstants(requestId);
        }

        {
            // deposit collateral
            uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, actualBorrowLimit);
            if (_maxCollateral > collateralAsset.balanceOf(address(admin))) {
                _maxCollateral = collateralAsset.balanceOf(address(admin));
            }
            uint256 _collateralAmount = scaleToRange256(_randomAmount, _maxCollateral.div(100), _maxCollateral);
            admin.transferToken(request.collateralAsset, address(borrower), _collateralAmount);
            borrower.setAllowance(pooledCreditLineAddress, request.collateralAsset, _collateralAmount);
            borrower.depositCollateral(requestId, _collateralAmount, false);
            emit log_named_uint('_collateralAmount', _collateralAmount);
        }

        {
            uint256 _expectedBorrowedAmount = pcl
                .calculateBorrowableAmount(requestId)
                .mul(pcl.SCALING_FACTOR().sub(pcl.protocolFeeFraction()))
                .div(pcl.SCALING_FACTOR());
            borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));
            emit log_named_uint('_expectedBorrowedAmount', _expectedBorrowedAmount);
            assertApproxEqRel(_expectedBorrowedAmount, borrowAsset.balanceOf(address(borrower)), 1e14);
        }

        // go ahead in time to accrue interest
        _increaseBlock(block.timestamp + request.duration.div(randomNumber3));

        {
            // check cur collateral ratio
            uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
            uint256 _moreCollateralRequired;
            if (pcl.getRequiredCollateral(requestId, pcl.calculateCurrentDebt(requestId)) > pcl.calculateTotalCollateralTokens(requestId)) {
                _moreCollateralRequired = pcl.getRequiredCollateral(requestId, pcl.calculateCurrentDebt(requestId)).sub(
                    pcl.calculateTotalCollateralTokens(requestId)
                );
            }
            if (_moreCollateralRequired > 0) {
                emit log_named_uint('_moreCollateralRequired', _moreCollateralRequired);
                if (_moreCollateralRequired > collateralAsset.balanceOf(address(admin))) {
                    writeTokenBalance(address(admin), request.collateralAsset, _moreCollateralRequired);
                }
                admin.transferToken(request.collateralAsset, address(borrower), _moreCollateralRequired);
                borrower.setAllowance(pooledCreditLineAddress, request.collateralAsset, _moreCollateralRequired);
                borrower.depositCollateral(requestId, _moreCollateralRequired, false);
                // check cur collateral ratio
                if (_moreCollateralRequired > 1e3) {
                    // this condition is because otherwise the error is high
                    assertApproxEqRel(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio, 1e16);
                }
            } else {
                // check how much more can be borrowed
                // the borrow rate is too low the yield is more nd the collateral ratio has increased
                uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, pcl.calculateCurrentDebt(requestId));
                assertLe(_collateralRequired, pcl.calculateTotalCollateralTokens(requestId));
            }
        }

        // go ahead in time to accrue interest
        {
            emit log_named_uint('before warp borrowCTokenAddress exchange rate', ICToken(borrowCTokenAddress).exchangeRateCurrent());
            _increaseBlock(block.timestamp + request.duration.div(randomNumber3));
            emit log_named_uint('after warp borrowCTokenAddress exchange rate', ICToken(borrowCTokenAddress).exchangeRateCurrent());
        }

        {
            // pay back interest
            uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
            uint256 _toRepay = _interestAccrued;
            if (borrowAsset.balanceOf(address(borrower)) < _interestAccrued) {
                _toRepay = borrowAsset.balanceOf(address(borrower));
            }
            borrower.setAllowance(pooledCreditLineAddress, request.borrowAsset, _toRepay);
            borrower.repay(requestId, _toRepay);
            emit log_named_uint('pcl.withdrawableCollateral(requestId)', pcl.withdrawableCollateral(requestId));
            emit log_named_uint('pcl.calculateTotalCollateralTokens(requestId)', pcl.calculateTotalCollateralTokens(requestId));
            emit log_named_uint('pcl.getRequiredCollateral', pcl.getRequiredCollateral(requestId, pcl.calculateCurrentDebt(requestId)));
            // check withdrawable collateral
            if (pcl.withdrawableCollateral(requestId) > 1e3) {
                assertApproxEqRel(
                    pcl.withdrawableCollateral(requestId),
                    pcl.calculateTotalCollateralTokens(requestId).sub(
                        pcl.getRequiredCollateral(requestId, pcl.calculateCurrentDebt(requestId))
                    ),
                    1e16
                );
            }
        }

        {
            (, , uint256 _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(requestId);
            PCLUser _lender = PCLUser(lenders[0].lenderAddress);
            uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
            uint256 _expectedBorrowInterestForLender = _totalInterestRepaid.mul(lp.balanceOf(address(_lender), requestId)).div(
                lp.totalSupply(requestId)
            );
            emit log_named_uint('_expectedBorrowInterestForLender', _expectedBorrowInterestForLender);
            (uint256 _sharesHeld, uint256 _borrowerInterestShares, , , ) = lp.pooledCLVariables(requestId);
            uint256 _notBorrowedInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
                actualBorrowLimit.sub(pcl.getPrincipal(requestId)),
                request.borrowAsset
            );
            // assuming no interest has been withdrawn by any lender yet
            uint256 _expectedYieldInterestShares = _sharesHeld.sub(_notBorrowedInShares).sub(_borrowerInterestShares);
            uint256 _expectedYieldInterestForBorrower = IYield(request.borrowAssetStrategy)
                .getTokensForShares(_expectedYieldInterestShares, request.borrowAsset)
                .mul(lp.balanceOf(address(_lender), requestId))
                .div(lp.totalSupply(requestId));
            emit log_named_uint('_expectedYieldInterestForBorrower', _expectedYieldInterestForBorrower);
            _lender.withdrawInterest(requestId);
            uint256 _borrowerInterestSharesWithdrawn = lp.getLenderInfo(requestId, address(_lender)).borrowerInterestSharesWithdrawn;
            emit log_named_uint('_borrowerInterestSharesWithdrawn', _borrowerInterestSharesWithdrawn);
            if (_borrowerInterestSharesWithdrawn > 100) {
                assertApproxEqRel(
                    _startBalance.add(_expectedBorrowInterestForLender).add(_expectedYieldInterestForBorrower),
                    borrowAsset.balanceOf(address(_lender)),
                    1e16
                );
                assertApproxEqRel(
                    _expectedBorrowInterestForLender,
                    IYield(request.borrowAssetStrategy).getTokensForShares(_borrowerInterestSharesWithdrawn, request.borrowAsset),
                    1e16
                );
            }
        }

        {
            // withdraw collateral
            uint256 _collateralToWithdraw = pcl.withdrawableCollateral(requestId).div(randomNumber2);
            if (_collateralToWithdraw != 0) {
                borrower.withdrawCollateral(requestId, _collateralToWithdraw, false);
                assertApproxEqAbs(collateralAsset.balanceOf(address(borrower)), _collateralToWithdraw, 3);
            }
        }

        {
            (, , uint256 _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(requestId);
            emit log_named_uint('pcl.calculateInterestAccrued(requestId)', pcl.calculateInterestAccrued(requestId));
            emit log_named_uint('_totalInterestRepaid', _totalInterestRepaid);
            if (pcl.calculateInterestAccrued(requestId).sub(_totalInterestRepaid) == 0) {
                // cannot replay unless there is interest accrued

                // vm.expectRevert not working
                // vm.expectRevert(bytes('PCL:REP4'));
                // borrower.repay(requestId, borrowAsset.balanceOf(address(borrower)).div(randomNumber3));

                try borrower.repay(requestId, borrowAsset.balanceOf(address(borrower)).div(randomNumber3)) {
                    revert('cannot repay when interest is zero');
                } catch Error(string memory reason) {
                    assertEq(reason, 'PCL:REP4');
                }
            }
        }

        // go ahead in time to accrue interest
        _increaseBlock(block.timestamp + request.duration.div(randomNumber3));

        // repay
        {
            uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
            if (_currentDebt > borrowAsset.balanceOf(address(borrower))) {
                uint256 _delta = _currentDebt.sub(borrowAsset.balanceOf(address(borrower)));
                if (_delta > borrowAsset.balanceOf(address(admin))) {
                    writeTokenBalance(address(admin), request.borrowAsset, _delta);
                }
                admin.transferToken(request.borrowAsset, address(borrower), _delta);
            }
            borrower.setAllowance(pooledCreditLineAddress, request.borrowAsset, _currentDebt);
            borrower.repay(requestId, _currentDebt);
            assertEq(0, pcl.calculateCurrentDebt(requestId));
        }

        // go to end and verify if pcl is closed
        _increaseBlock(t0 + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        {
            uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
            uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
            borrower.withdrawAllCollateral(requestId, false);
            assertApproxEqAbs(_withdrawableCollateral.add(_startBalance), collateralAsset.balanceOf(address(borrower)), 3);
        }

        // go forward to avoid sub overflow error in _calculateLenderInterest
        _increaseBlock(block.timestamp + request.duration.div(randomNumber3));

        {
            PCLUser _lender = PCLUser(lenders[numLenders - 1].lenderAddress);
            _lender.withdrawInterest(requestId);
        }

        {
            PCLUser _lender = PCLUser(lenders[numLenders - 1].lenderAddress);
            uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
            uint256 _expectedLiquidityWithdrawn = lp.balanceOf(address(_lender), requestId).add(
                lp.getLenderInterestWithdrawable(requestId, address(_lender))
            );
            emit log_named_uint('_expectedLiquidityWithdrawn', _expectedLiquidityWithdrawn);
            _lender.withdrawLiquidity(requestId);
            uint256 _actualLiquidityWithdrawn = borrowAsset.balanceOf(address(_lender)).sub(_startBalance);
            emit log_named_uint('_actualLiquidityWithdrawn', _actualLiquidityWithdrawn);
            assertApproxEqRel(_expectedLiquidityWithdrawn, _actualLiquidityWithdrawn, 1e15);
        }
    }

    function test_requestToActiveToExpiredPCL(
        uint256 _randomAmount,
        uint256 _collateralRatio,
        uint128 _amountToLend,
        uint256 _randomNumber1,
        uint256 _randomNumber2,
        uint256 _randomNumber3
    ) public {
        goToRequestedStageFuzzed(_randomAmount, _collateralRatio, _amountToLend, _randomNumber1, _randomNumber2, _randomNumber3);

        // start the pcl
        {
            // go head in time
            _increaseBlock(t0 + request.collectionPeriod);
            vm.expectEmit(true, true, false, true);
            emit PooledCreditLineAccepted(requestId, amountToLend);
            borrower.start(requestId);
            // check status
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        }

        {
            (, , , actualBorrowLimit, , , , ) = lp.pooledCLConstants(requestId);
        }

        {
            // borrow tokens
            // try to borrow some tokens
            uint256 _amountToBorrow = actualBorrowLimit.mul(randomNumber2).div(11);
            emit log_named_uint('_amountToBorrow', _amountToBorrow);
            bool isOverLimit;
            // decide how much collateral is needed
            uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, _amountToBorrow);
            emit log_named_uint('_requiredCollateral', _requiredCollateral);
            if (_requiredCollateral > collateralAsset.balanceOf(address(admin))) {
                _requiredCollateral = collateralAsset.balanceOf(address(admin)).div(randomNumber3);
                isOverLimit = true;
            }
            // deposit collateral
            admin.transferToken(address(collateralAsset), address(borrower), _requiredCollateral);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _requiredCollateral);
            borrower.depositCollateral(requestId, _requiredCollateral, false);
            // calculateBorrowableAmount
            uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
            emit log_named_uint('_borrowableAmount', _borrowableAmount);
            if (!isOverLimit) {
                if (stdMath.delta(_amountToBorrow, _borrowableAmount) > 2 && _requiredCollateral > 1e3) {
                    assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e16);
                }
            }
            // borrow the required amount
            borrower.borrow(requestId, _borrowableAmount);
        }

        // go ahead in time to expire the pcl
        _increaseBlock(t0 + request.collectionPeriod + request.duration);

        uint256 _interestAccruedTillExpiry = pcl.calculateInterestAccrued(requestId);
        emit log_named_uint('_interestAccruedTillExpiry', _interestAccruedTillExpiry);

        // the grace period has started
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        {
            uint256 _collateralRequired;
            if (pcl.getRequiredCollateral(requestId, pcl.calculateCurrentDebt(requestId)) > pcl.calculateTotalCollateralTokens(requestId)) {
                _collateralRequired = pcl.getRequiredCollateral(requestId, pcl.calculateCurrentDebt(requestId)).sub(
                    pcl.calculateTotalCollateralTokens(requestId)
                );
            }
            if (_collateralRequired > 0) {
                // because of precision errors
                _collateralRequired = _collateralRequired.mul(110).div(100);
            } else if (pcl.calculateCurrentCollateralRatio(requestId) < request.collateralRatio) {
                // take a random amount
                _collateralRequired = 1e2;
            }
            if (_collateralRequired > 0) {
                if (_collateralRequired > collateralAsset.balanceOf(address(admin))) {
                    writeTokenBalance(address(admin), request.collateralAsset, _collateralRequired);
                }
                emit log_named_uint('_collateralRequired', _collateralRequired);
                admin.transferToken(request.collateralAsset, address(borrower), _collateralRequired);
                borrower.setAllowance(pooledCreditLineAddress, request.collateralAsset, _collateralRequired);
                borrower.depositCollateral(requestId, _collateralRequired, false);
                emit log_named_uint('current Collateral Ratio', pcl.calculateCurrentCollateralRatio(requestId));
                emit log_named_uint('request.collateralRatio', request.collateralRatio);
                assertGe(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
            }
        }

        {
            // (, , uint256 _idealCollateralRatio, , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
            emit log_named_uint('current Collateral Ratio', pcl.calculateCurrentCollateralRatio(requestId));
            // emit log_named_uint('_idealCollateralRatio', _idealCollateralRatio);
            PCLUser _lender = PCLUser(lenders[numLenders - 1].lenderAddress);
            vm.expectRevert(bytes('PCL:L3'));
            _lender.liquidate(requestId, true);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);
            vm.expectRevert(bytes('LP:IWL3'));
            _lender.withdrawLiquidity(requestId);
        }

        _increaseBlock(t0 + request.collectionPeriod + request.duration + request.defaultGracePeriod);

        {
            uint256 _interestAccruedTillEndOfGracePeriod = pcl.calculateInterestAccrued(requestId);
            emit log_named_uint('_interestAccruedTillEndOfGracePeriod', _interestAccruedTillEndOfGracePeriod);
            uint256 _expectedPenaltyInterest = pcl
                .getPrincipal(requestId)
                .mul(request.gracePenaltyRate)
                .mul(request.defaultGracePeriod)
                .div(365 days)
                .div(pcl.SCALING_FACTOR());
            uint256 _expectedPrincipalInterest = pcl
                .getPrincipal(requestId)
                .mul(request.borrowRate)
                .mul(request.defaultGracePeriod)
                .div(365 days)
                .div(pcl.SCALING_FACTOR());
            assertApproxEqRel(
                _expectedPenaltyInterest,
                _interestAccruedTillEndOfGracePeriod.sub(_interestAccruedTillExpiry).sub(_expectedPrincipalInterest),
                1e14
            );
        }

        // can either go for close, liquidation or terminate
    }

    function test_requestToActiveToTerminatedPCL(
        uint256 _randomAmount,
        uint256 _collateralRatio,
        uint128 _amountToLend,
        uint256 _randomNumber1,
        uint256 _randomNumber2,
        uint256 _randomNumber3
    ) public {
        goToRequestedStageFuzzed(_randomAmount, _collateralRatio, _amountToLend, _randomNumber1, _randomNumber2, _randomNumber3);

        // start the pcl
        {
            // go head in time
            _increaseBlock(t0 + request.collectionPeriod);
            vm.expectEmit(true, true, false, true);
            emit PooledCreditLineAccepted(requestId, amountToLend);
            borrower.start(requestId);
            // check status
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        }

        {
            // borrow tokens
            // try to borrow some tokens
            uint256 _amountToBorrow = amountToLend.mul(randomNumber2).div(11);
            emit log_named_uint('_amountToBorrow', _amountToBorrow);
            bool isOverLimit;
            // decide how much collateral is needed
            uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, _amountToBorrow);
            emit log_named_uint('_requiredCollateral', _requiredCollateral);
            if (_requiredCollateral > collateralAsset.balanceOf(address(admin))) {
                _requiredCollateral = collateralAsset.balanceOf(address(admin)).div(randomNumber3);
                isOverLimit = true;
            }
            // deposit collateral
            admin.transferToken(address(collateralAsset), address(borrower), _requiredCollateral);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _requiredCollateral);
            borrower.depositCollateral(requestId, _requiredCollateral, false);
            // calculateBorrowableAmount
            uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
            emit log_named_uint('_borrowableAmount', _borrowableAmount);
            if (!isOverLimit) {
                // adding 1 for precision errors
                if (stdMath.delta(_amountToBorrow, _borrowableAmount) > 2 && _requiredCollateral > 1e3) {
                    assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e16);
                }
            }
            // borrow the required amount
            borrower.borrow(requestId, _borrowableAmount);
        }

        // go ahead in time
        _increaseBlock(t0 + request.collectionPeriod + request.duration.div(randomNumber3));

        {
            // pay some interest
            uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
            uint256 _interestToPay = _interestAccrued.div(randomNumber2);
            if (_interestAccrued > borrowAsset.balanceOf(address(borrower))) {
                uint256 _delta = _interestAccrued.sub(borrowAsset.balanceOf(address(borrower)));
                if (_delta > borrowAsset.balanceOf(address(admin))) {
                    writeTokenBalance(address(admin), request.borrowAsset, _delta);
                }
                admin.transferToken(request.borrowAsset, address(borrower), _delta);
            }
            emit log_named_uint('_interestToPay', _interestToPay);
            borrower.setAllowance(pooledCreditLineAddress, request.borrowAsset, _interestToPay);
            borrower.repay(requestId, _interestToPay);

            assertTrue(lp.getLenderInterestWithdrawable(requestId, lenders[0].lenderAddress) > 0);
        }

        // go ahead in time
        _increaseBlock(block.timestamp + request.duration.div(randomNumber3));

        {
            // lender withdraws interest
            PCLUser _lender = PCLUser(lenders[numLenders - 1].lenderAddress);
            _lender.withdrawInterest(requestId);
        }

        {
            // pay back interest plus some principal
            (, , uint256 _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(requestId);
            uint256 _toRepay = pcl.calculateInterestAccrued(requestId).sub(_totalInterestRepaid).add(
                pcl.getPrincipal(requestId).div(randomNumber2)
            );
            emit log_named_uint('_toRepay', _toRepay);
            if (borrowAsset.balanceOf(address(borrower)) < _toRepay) {
                uint256 _delta = _toRepay.sub(borrowAsset.balanceOf(address(borrower)));
                if (_delta > borrowAsset.balanceOf(address(admin))) {
                    writeTokenBalance(address(admin), request.borrowAsset, _delta);
                }
                admin.transferToken(request.borrowAsset, address(borrower), _delta);
            }
            borrower.setAllowance(pooledCreditLineAddress, request.borrowAsset, _toRepay);
            borrower.repay(requestId, _toRepay);
        }

        {
            // withdraw some collateral
            uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
            emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
            assertTrue(_withdrawableCollateral > 0);
            borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
        }

        // go ahead in time
        _increaseBlock(block.timestamp + request.duration.div(randomNumber3));

        {
            uint256 _startBalanceBorrowAsset = borrowAsset.balanceOf(address(admin));
            uint256 _startBalanceCollateralAsset = collateralAsset.balanceOf(address(admin));
            uint256 _collateralTransferred = pcl.calculateTotalCollateralTokens(requestId);
            emit log_named_uint('_collateralTransferred', _collateralTransferred);

            // borrow tokens transferred calculation
            // NOTE: below calculation works only when totalSupply == borrowLimit
            // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
            // assertEq(lp.totalSupply(requestId), _borrowLimit);
            (uint256 _sharesHeld, , , , ) = lp.pooledCLVariables(requestId);
            uint256 _expectedBorrowAssetTransferred = IYield(request.borrowAssetStrategy).getTokensForShares(
                _sharesHeld,
                request.borrowAsset
            );
            emit log_named_uint('_expectedBorrowAssetTransferred', _expectedBorrowAssetTransferred);

            admin.terminate(requestId);

            uint256 _endBalanceBorrowAsset = borrowAsset.balanceOf(address(admin));
            uint256 _endBalanceCollateralAsset = collateralAsset.balanceOf(address(admin));
            assertApproxEqAbs(_collateralTransferred, _endBalanceCollateralAsset.sub(_startBalanceCollateralAsset), 3);
            assertEq(_expectedBorrowAssetTransferred, _endBalanceBorrowAsset.sub(_startBalanceBorrowAsset));
        }
    }

    function test_requestToExpiredToLiquidatedPCL(
        uint256 _randomAmount,
        uint256 _collateralRatio,
        uint128 _amountToLend,
        uint256 _randomNumber1,
        uint256 _randomNumber2,
        uint256 _randomNumber3
    ) public {
        goToRequestedStageFuzzed(_randomAmount, _collateralRatio, _amountToLend, _randomNumber1, _randomNumber2, _randomNumber3);

        // start the pcl
        {
            // go head in time
            _increaseBlock(t0 + request.collectionPeriod);
            vm.expectEmit(true, true, false, true);
            emit PooledCreditLineAccepted(requestId, amountToLend);
            borrower.start(requestId);
            // check status
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        }

        {
            (, , , actualBorrowLimit, , , , ) = lp.pooledCLConstants(requestId);
        }

        {
            uint256 _collateralAmount = pcl.getRequiredCollateral(requestId, actualBorrowLimit).div(randomNumber2);
            if (_collateralAmount > collateralAsset.balanceOf(address(admin))) {
                _collateralAmount = collateralAsset.balanceOf(address(admin)).div(randomNumber3);
            }
            emit log_named_uint('_collateralAmount', _collateralAmount);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
            borrower.depositCollateral(requestId, _collateralAmount, false);
            // calculateBorrowableAmount
            uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, _borrowableAmount);
        }

        // go ahead in time
        _increaseBlock(t0 + request.collectionPeriod + request.duration.div(randomNumber3));

        {
            // pay some amount
            uint256 _toPay = pcl.calculateInterestAccrued(requestId).div(randomNumber2);
            emit log_named_uint('_toPay', _toPay);
            if (borrowAsset.balanceOf(address(borrower)) < _toPay) {
                uint256 _delta = _toPay.sub(borrowAsset.balanceOf(address(borrower)));
                if (_delta > borrowAsset.balanceOf(address(admin))) {
                    writeTokenBalance(address(admin), request.borrowAsset, _delta);
                }
                admin.transferToken(request.borrowAsset, address(borrower), _delta);
            }
            borrower.setAllowance(pooledCreditLineAddress, request.borrowAsset, _toPay);
            borrower.repay(requestId, _toPay);
            assertTrue(lp.getLenderInterestWithdrawable(requestId, lenders[0].lenderAddress) > 0);
        }

        // withdraw interest
        {
            (, , uint256 _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(requestId);
            PCLUser _lender = PCLUser(lenders[0].lenderAddress);
            uint256 _prevBalance = borrowAsset.balanceOf(address(_lender));
            _lender.withdrawInterest(requestId);
            uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
            uint256 _yieldInterestWithdrawnShares = lp.getLenderInfo(requestId, address(_lender)).yieldInterestWithdrawnShares;
            emit log_named_uint('_yieldInterestWithdrawnShares', _yieldInterestWithdrawnShares);
            uint256 _yieldInterest = IYield(request.borrowAssetStrategy).getTokensForShares(
                _yieldInterestWithdrawnShares,
                request.borrowAsset
            );
            uint256 _borrowerInterestWithdrawn = _totalInterestRepaid.mul(lp.balanceOf(address(_lender), requestId)).div(
                lp.totalSupply(requestId)
            );
            if (_yieldInterestWithdrawnShares > 100) {
                assertApproxEqRel(_yieldInterest.add(_borrowerInterestWithdrawn), _finalBalance.sub(_prevBalance), 1e16);
            }
        }

        // repay again
        {
            // pay some amount
            uint256 _toPay = pcl.calculateInterestAccrued(requestId).div(randomNumber2);
            emit log_named_uint('_toPay', _toPay);
            if (borrowAsset.balanceOf(address(borrower)) < _toPay) {
                uint256 _delta = _toPay.sub(borrowAsset.balanceOf(address(borrower)));
                if (_delta > borrowAsset.balanceOf(address(admin))) {
                    writeTokenBalance(address(admin), request.borrowAsset, _delta);
                }
                admin.transferToken(request.borrowAsset, address(borrower), _delta);
            }
            borrower.setAllowance(pooledCreditLineAddress, request.borrowAsset, _toPay);
            borrower.repay(requestId, _toPay);
            assertTrue(lp.getLenderInterestWithdrawable(requestId, lenders[0].lenderAddress) > 0);
        }

        // go ahead in time by 2 blocks
        _increaseBlock(block.timestamp + BLOCK_TIME.mul(2));

        {
            (, , uint256 _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(requestId);
            PCLUser _lender = PCLUser(lenders[numLenders - 1].lenderAddress);
            uint256 _prevBalance = borrowAsset.balanceOf(address(_lender));
            _lender.withdrawInterest(requestId);
            uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
            uint256 _yieldInterestWithdrawnShares = lp.getLenderInfo(requestId, address(_lender)).yieldInterestWithdrawnShares;
            emit log_named_uint('_yieldInterestWithdrawnShares', _yieldInterestWithdrawnShares);
            uint256 _yieldInterest = IYield(request.borrowAssetStrategy).getTokensForShares(
                _yieldInterestWithdrawnShares,
                request.borrowAsset
            );
            uint256 _borrowerInterestWithdrawn = _totalInterestRepaid.mul(lp.balanceOf(address(_lender), requestId)).div(
                lp.totalSupply(requestId)
            );
            emit log_named_uint('_finalBalance', _finalBalance);
            emit log_named_uint('_prevBalance', _prevBalance);
            if (_yieldInterestWithdrawnShares > 100) {
                assertApproxEqRel(_yieldInterest.add(_borrowerInterestWithdrawn), _finalBalance.sub(_prevBalance), 1e15);
            }
        }

        _increaseBlock(t0 + request.collectionPeriod + request.duration + request.defaultGracePeriod.div(randomNumber3));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        {
            // cannot borrow
            vm.expectRevert(bytes('PCL:IB3'));
            borrower.borrow(requestId, actualBorrowLimit.div(randomNumber3));
            emit log('cannot borrow');
        }

        // cannot withdraw collateral
        {
            // vm.expectRevert not working
            try borrower.withdrawCollateral(requestId, pcl.calculateTotalCollateralTokens(requestId), false) {
                revert('should have thrown error that cannot withdrawCollateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:WC1');
            }
            emit log('cannot withdrawCollateral');
        }

        {
            // can deposit collateral
            uint256 _prevCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
            uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, pcl.calculateCurrentDebt(requestId));
            if (_requiredCollateral <= pcl.calculateTotalCollateralTokens(requestId)) {
                _increaseBlock(t0 + request.collectionPeriod + request.duration + request.defaultGracePeriod);
            } else {
                uint256 _collateralToDeposit = _requiredCollateral.sub(pcl.calculateTotalCollateralTokens(requestId));
                _collateralToDeposit = _collateralToDeposit.div(randomNumber3);
                emit log_named_uint('_collateralToDeposit', _collateralToDeposit);
                if (_collateralToDeposit > 0) {
                    if (_collateralToDeposit > collateralAsset.balanceOf(address(admin))) {
                        _collateralToDeposit = collateralAsset.balanceOf(address(admin));
                    }
                    admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
                    borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralToDeposit);
                    borrower.depositCollateral(requestId, _collateralToDeposit, false);
                    uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
                    emit log_named_uint('_curCollateralRatio', _curCollateralRatio);
                    emit log_named_uint('_prevCollateralRatio', _prevCollateralRatio);
                    assertTrue(_curCollateralRatio >= _prevCollateralRatio);
                }
            }
        }

        {
            // liquidate
            PCLUser _lender = PCLUser(lenders[numLenders - 1].lenderAddress);
            _lender.liquidate(requestId, true);
            emit log_named_uint('pcl.getStatusAndUpdate(requestId)', uint256(pcl.getStatusAndUpdate(requestId)));
            assertTrue(PooledCreditLineStatus.LIQUIDATED == pcl.getStatusAndUpdate(requestId));
        }

        {
            // withdraw liquidated tokens
            PCLUser _lender = PCLUser(lenders[0].lenderAddress);
            uint256 _prevBalance = lp.balanceOf(address(_lender), requestId);
            emit log_named_uint('_prevBalance', _prevBalance);
            assertTrue(_prevBalance > 0);
            _lender.withdrawTokensAfterLiquidation(requestId);
            uint256 _finalBalance = lp.balanceOf(address(_lender), requestId);
            emit log_named_uint('_finalBalance', _finalBalance);
            assertEq(_finalBalance, 0);
        }

        {
            // borrower can withdraw any collateral left
            uint256 _collateralLeft = pcl.calculateTotalCollateralTokens(requestId);
            if (_collateralLeft > 0) {
                emit log_named_uint('_collateralLeft', _collateralLeft);
                uint256 _prevBalance = collateralAsset.balanceOf(address(borrower));
                borrower.withdrawAllCollateral(requestId, false);
                uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
                emit log_named_uint('balance delta', _finalBalance.sub(_prevBalance));
                if (stdMath.delta(_collateralLeft, _finalBalance.sub(_prevBalance)) > 2) {
                    assertApproxEqRel(_collateralLeft, _finalBalance.sub(_prevBalance), 1e15);
                }
            }
        }
    }

    function test_requestToExpiredToTerminatedPCL(
        uint256 _randomAmount,
        uint256 _collateralRatio,
        uint128 _amountToLend,
        uint256 _randomNumber1,
        uint256 _randomNumber2,
        uint256 _randomNumber3
    ) public {
        goToRequestedStageFuzzed(_randomAmount, _collateralRatio, _amountToLend, _randomNumber1, _randomNumber2, _randomNumber3);

        // start the pcl
        {
            // go head in time
            _increaseBlock(t0 + request.collectionPeriod);
            vm.expectEmit(true, true, false, true);
            emit PooledCreditLineAccepted(requestId, amountToLend);
            borrower.start(requestId);
            // check status
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        }

        {
            (, , , actualBorrowLimit, , , , ) = lp.pooledCLConstants(requestId);
        }

        {
            // try to borrow some tokens
            bool isOverLimit;
            uint256 _amountToBorrow = amountToLend.div(randomNumber3);
            emit log_named_uint('_amountToBorrow', _amountToBorrow);

            uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, _amountToBorrow);
            emit log_named_uint('_requiredCollateral', _requiredCollateral);
            if (_requiredCollateral > collateralAsset.balanceOf(address(admin))) {
                _requiredCollateral = collateralAsset.balanceOf(address(admin)).div(randomNumber3);
                isOverLimit = true;
            }
            admin.transferToken(address(collateralAsset), address(borrower), _requiredCollateral);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _requiredCollateral);
            borrower.depositCollateral(requestId, _requiredCollateral, false);
            uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
            emit log_named_uint('_borrowableAmount', _borrowableAmount);
            // borrow the required amount
            uint256 _startBalance = borrowAsset.balanceOf(address(borrower));
            borrower.borrow(requestId, _borrowableAmount);
            assertApproxEqRel(
                _borrowableAmount.mul(pcl.SCALING_FACTOR().sub(pcl.protocolFeeFraction())).div(pcl.SCALING_FACTOR()),
                borrowAsset.balanceOf(address(borrower)).sub(_startBalance),
                1e14
            );
        }

        // go ahead in time to accrue interest
        _increaseBlock(t0 + request.collectionPeriod + request.duration.div(randomNumber3));

        {
            // pay some amount
            uint256 _toPay = pcl.calculateInterestAccrued(requestId).div(10);
            emit log_named_uint('_toPay', _toPay);
            if (borrowAsset.balanceOf(address(borrower)) < _toPay) {
                uint256 _delta = _toPay.sub(borrowAsset.balanceOf(address(borrower)));
                if (_delta > borrowAsset.balanceOf(address(admin))) {
                    writeTokenBalance(address(admin), request.borrowAsset, _delta);
                }
                admin.transferToken(request.borrowAsset, address(borrower), _delta);
            }
            borrower.setAllowance(pooledCreditLineAddress, request.borrowAsset, _toPay);
            borrower.repay(requestId, _toPay);
            assertTrue(lp.getLenderInterestWithdrawable(requestId, lenders[0].lenderAddress) > 0);
        }

        {
            (, , uint256 _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(requestId);
            PCLUser _lender = PCLUser(lenders[numLenders - 1].lenderAddress);
            uint256 _prevBalance = borrowAsset.balanceOf(address(_lender));
            _lender.withdrawInterest(requestId);
            uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
            uint256 _yieldInterestWithdrawnShares = lp.getLenderInfo(requestId, address(_lender)).yieldInterestWithdrawnShares;
            emit log_named_uint('_yieldInterestWithdrawnShares', _yieldInterestWithdrawnShares);
            uint256 _yieldInterest = IYield(request.borrowAssetStrategy).getTokensForShares(
                _yieldInterestWithdrawnShares,
                request.borrowAsset
            );
            uint256 _borrowerInterestWithdrawn = _totalInterestRepaid.mul(lp.balanceOf(address(_lender), requestId)).div(
                lp.totalSupply(requestId)
            );
            if (_yieldInterestWithdrawnShares > 100) {
                // otherwise the delta is too large
                assertApproxEqRel(_yieldInterest.add(_borrowerInterestWithdrawn), _finalBalance.sub(_prevBalance), 1e16);
            }
        }

        // go ahead in time to accrue interest
        _increaseBlock(block.timestamp + BLOCK_TIME.mul(2));

        {
            PCLUser _lender = PCLUser(lenders[0].lenderAddress);
            uint256 _prevBalance = borrowAsset.balanceOf(address(_lender));
            _lender.withdrawInterest(requestId);
            uint256 _curBalance = borrowAsset.balanceOf(address(_lender));
            LenderPool.LenderInfo memory _info = lp.getLenderInfo(requestId, address(_lender));
            uint256 _interest = IYield(request.borrowAssetStrategy).getTokensForShares(
                _info.borrowerInterestSharesWithdrawn.add(_info.yieldInterestWithdrawnShares),
                address(borrowAsset)
            );
            assertApproxEqRel(_interest, _curBalance.sub(_prevBalance), 1e14);
        }

        // go ahead in time to accrue interest
        _increaseBlock(block.timestamp + request.duration.div(randomNumber3));

        // terminate
        {
            uint256 _startBalanceBorrowAsset = borrowAsset.balanceOf(address(admin));
            uint256 _startBalanceCollateralAsset = collateralAsset.balanceOf(address(admin));
            uint256 _collateralTransferred = pcl.calculateTotalCollateralTokens(requestId);
            emit log_named_uint('_collateralTransferred', _collateralTransferred);

            // borrow tokens transferred calculation
            // NOTE: below calculation works only when totalSupply == borrowLimit
            // {
            //     (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
            //     assertEq(lp.totalSupply(requestId), _borrowLimit);
            // }
            uint256 _expectedBorrowAssetTransferred;
            {
                (uint256 _sharesHeld, , , , ) = lp.pooledCLVariables(requestId);
                _expectedBorrowAssetTransferred = IYield(request.borrowAssetStrategy).getTokensForShares(_sharesHeld, request.borrowAsset);
            }
            emit log_named_uint('_expectedBorrowAssetTransferred', _expectedBorrowAssetTransferred);

            admin.terminate(requestId);

            //uint256 _endBalanceBorrowAsset = borrowAsset.balanceOf(address(admin));
            //uint256 _endBalanceCollateralAsset = collateralAsset.balanceOf(address(admin));
            assertApproxEqAbs(_collateralTransferred, (collateralAsset.balanceOf(address(admin))).sub(_startBalanceCollateralAsset), 3);
            assertEq(_expectedBorrowAssetTransferred, (borrowAsset.balanceOf(address(admin))).sub(_startBalanceBorrowAsset));
        }

        {
            // token transfer not possible
            PCLUser _lender = PCLUser(lenders[0].lenderAddress);
            // vm.expectRevert not working
            try
                _lender.transferLPTokens(
                    address(lenders[numLenders - 1].lenderAddress),
                    requestId,
                    lp.balanceOf(address(_lender), requestId)
                )
            {
                revert('cannot transfer tokens');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:IT3');
            }
        }
    }
}",14108
RealWorld_TA_101_PCLExpiredState.t_RealWorld_20240812143313.log,101,PCLExpiredState.t,720758,68,720826,106.0,3.60515,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}",8576
RealWorld_TA_101_ISavingsAccount_RealWorld_20240812182552.log,101,ISavingsAccount,142597,3075,145672,94.0,0.774485,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface ISavingsAccount {
    /**
     * @notice emitted when tokens are deposited into savings account
     * @param user address of user depositing the tokens
     * @param sharesReceived amount of shares received for deposit
     * @param token address of token that is deposited
     * @param strategy strategy into which tokens are deposited
     */
    event Deposited(address indexed user, uint256 sharesReceived, address indexed token, address indexed strategy);

    /**
     * @notice emitted when tokens are switched from one strategy to another
     * @param user address of user switching strategies
     * @param token address of token for which strategies are switched
     * @param sharesDecreasedInCurrentStrategy shares decreased in current strategy
     * @param sharesIncreasedInNewStrategy shares increased in new strategy
     * @param currentStrategy address of the strategy from which tokens are switched
     * @param newStrategy address of the strategy to which tokens are switched
     */
    event StrategySwitched(
        address indexed user,
        address indexed token,
        uint256 sharesDecreasedInCurrentStrategy,
        uint256 sharesIncreasedInNewStrategy,
        address currentStrategy,
        address indexed newStrategy
    );

    /**
     * @notice emitted when tokens are withdrawn from savings account
     * @param from address of user from which tokens are withdrawn
     * @param to address of user to which tokens are withdrawn
     * @param sharesWithdrawn amount of shares withdrawn
     * @param token address of token that is withdrawn
     * @param strategy strategy into which tokens are withdrawn
     * @param receiveShares flag to represent if shares are directly wirthdrawn
     */
    event Withdrawn(
        address indexed from,
        address indexed to,
        uint256 sharesWithdrawn,
        address indexed token,
        address strategy,
        bool receiveShares
    );

    /**
     * @notice emitted when all tokens are withdrawn
     * @param user address of user withdrawing tokens
     * @param tokenReceived amount of tokens withdrawn
     * @param token address of the token withdrawn
     */
    event WithdrawnAll(address indexed user, uint256 tokenReceived, address indexed token);

    /**
     * @notice emitted when tokens are approved
     * @param token address of token approved
     * @param from address of user from who tokens are approved
     * @param to address of user to whom tokens are approved
     * @param amount amount of tokens approved
     */
    event Approved(address indexed token, address indexed from, address indexed to, uint256 amount);

    /**
     * @notice emitted when tokens are transferred
     * @param token address of token transferred
     * @param strategy address of strategy from which tokens are transferred
     * @param from address of user from whom tokens are transferred
     * @param to address of user to whom tokens are transferred
     * @param amount amount of tokens transferred
     */
    event Transfer(address indexed token, address strategy, address indexed from, address indexed to, uint256 amount);

    /**
     * @notice emitted when tokens are transferred
     * @param token address of token transferred
     * @param strategy address of strategy from which tokens are transferred
     * @param from address of user from whom tokens are transferred
     * @param to address of user to whom tokens are transferred
     * @param shares amount of tokens transferred
     */
    event TransferShares(address indexed token, address strategy, address indexed from, address indexed to, uint256 shares);

    /**
     * @notice emitted when strategy registry is updated
     * @param updatedStrategyRegistry updated strategy registry address
     */
    event StrategyRegistryUpdated(address indexed updatedStrategyRegistry);

    function allowance(
        address user,
        address token,
        address to
    ) external returns (uint256 userAllowance);

    function deposit(
        address token,
        address strategy,
        address to,
        uint256 amount
    ) external returns (uint256 sharesReceived);

    /**
     * @dev Used to switch saving strategy of an token
     * @param currentStrategy initial strategy of token
     * @param newStrategy new strategy to invest
     * @param token address of the token
     * @param amount amount of tokens to be reinvested
     */
    function switchStrategy(
        address currentStrategy,
        address newStrategy,
        address token,
        uint256 amount
    ) external;

    /**
     * @dev Used to withdraw token from Saving Account
     * @param withdrawTo address to which token should be sent
     * @param amount amount of tokens to withdraw
     * @param token address of the token to be withdrawn
     * @param strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)
     * @param receiveShares boolean indicating to withdraw in liquidity share or underlying token
     */
    function withdraw(
        address token,
        address strategy,
        address withdrawTo,
        uint256 amount,
        bool receiveShares
    ) external returns (uint256 amountWithdrawn);

    function withdrawAll(address token) external returns (uint256 tokenReceived);

    function withdrawAll(address token, address strategy) external returns (uint256 tokenReceived);

    function approve(
        address token,
        address to,
        uint256 amount
    ) external;

    function increaseAllowance(
        address token,
        address to,
        uint256 amount
    ) external;

    function decreaseAllowance(
        address token,
        address to,
        uint256 amount
    ) external;

    function transferShares(
        address _token,
        address _strategy,
        address _to,
        uint256 _shares
    ) external returns (uint256);

    function transfer(
        address token,
        address strategy,
        address to,
        uint256 amount
    ) external returns (uint256 tokensReceived);

    function transferSharesFrom(
        address token,
        address strategy,
        address from,
        address to,
        uint256 _shares
    ) external returns (uint256);

    function transferFrom(
        address token,
        address strategy,
        address from,
        address to,
        uint256 amount
    ) external returns (uint256 tokensReceived);

    function balanceInShares(
        address user,
        address token,
        address strategy
    ) external view returns (uint256 shareBalance);

    function withdrawFrom(
        address token,
        address strategy,
        address from,
        address to,
        uint256 amount,
        bool receiveShares
    ) external returns (uint256 amountReceived);

    function withdrawShares(
        address token,
        address strategy,
        address to,
        uint256 shares,
        bool receiveShares
    ) external returns (uint256 amountReceived);

    function withdrawSharesFrom(
        address token,
        address strategy,
        address from,
        address to,
        uint256 shares,
        bool receiveShares
    ) external returns (uint256 amountReceived);

    function getTotalTokens(address _user, address _token) external returns (uint256 _totalTokens);
}",1468
RealWorld_TA_101_SavingsAccountUtil_RealWorld_20240812172650.log,101,SavingsAccountUtil,97110,2974,100084,97.0,0.54503,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '../interfaces/ISavingsAccount.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';

library SavingsAccountUtil {
    using SafeERC20 for IERC20;

    function depositFromSavingsAccount(
        ISavingsAccount _savingsAccount,
        address _token,
        address _strategy,
        address _from,
        address _to,
        uint256 _amount,
        bool _withdrawShares,
        bool _toSavingsAccount
    ) internal returns (uint256) {
        require(_token != address(0), 'SAU:IDFSA1');
        if (_toSavingsAccount) {
            return savingsAccountTransfer(_savingsAccount, _token, _strategy, _from, _to, _amount);
        } else {
            return withdrawFromSavingsAccount(_savingsAccount, _token, _strategy, _from, _to, _amount, _withdrawShares);
        }
    }

    function directDeposit(
        ISavingsAccount _savingsAccount,
        address _token,
        address _strategy,
        address _from,
        address _to,
        uint256 _amount,
        bool _toSavingsAccount
    ) internal returns (uint256) {
        require(_token != address(0), 'SAU:IDD1');
        if (_toSavingsAccount) {
            return directSavingsAccountDeposit(_savingsAccount, _token, _strategy, _from, _to, _amount);
        } else {
            return transferTokens(_token, _from, _to, _amount);
        }
    }

    function directSavingsAccountDeposit(
        ISavingsAccount _savingsAccount,
        address _token,
        address _strategy,
        address _from,
        address _to,
        uint256 _amount
    ) private returns (uint256) {
        transferTokens(_token, _from, address(this), _amount);
        address _approveTo = _strategy;
        IERC20(_token).safeApprove(_approveTo, _amount);
        uint256 _sharesReceived = _savingsAccount.deposit(_token, _strategy, _to, _amount);
        return _sharesReceived;
    }

    function savingsAccountTransferShares(
        ISavingsAccount _savingsAccount,
        address _token,
        address _strategy,
        address _from,
        address _to,
        uint256 _shares
    ) internal returns (uint256) {
        if (_from == address(this)) {
            _savingsAccount.transferShares(_token, _strategy, _to, _shares);
        } else {
            _savingsAccount.transferSharesFrom(_token, _strategy, _from, _to, _shares);
        }
        return _shares;
    }

    function savingsAccountTransfer(
        ISavingsAccount _savingsAccount,
        address _token,
        address _strategy,
        address _from,
        address _to,
        uint256 _amount
    ) private returns (uint256) {
        if (_from == address(this)) {
            return _savingsAccount.transfer(_token, _strategy, _to, _amount);
        } else {
            return _savingsAccount.transferFrom(_token, _strategy, _from, _to, _amount);
        }
    }

    function withdrawFromSavingsAccount(
        ISavingsAccount _savingsAccount,
        address _token,
        address _strategy,
        address _from,
        address _to,
        uint256 _amount,
        bool _withdrawShares
    ) private returns (uint256) {
        uint256 _amountReceived;
        if (_from == address(this)) {
            _amountReceived = _savingsAccount.withdraw(_token, _strategy, _to, _amount, _withdrawShares);
        } else {
            _amountReceived = _savingsAccount.withdrawFrom(_token, _strategy, _from, _to, _amount, _withdrawShares);
        }
        return _amountReceived;
    }

    function transferTokens(
        address _token,
        address _from,
        address _to,
        uint256 _amount
    ) internal returns (uint256) {
        if (_amount == 0) return 0;

        if (_from == address(this)) {
            IERC20(_token).safeTransfer(_to, _amount);
        } else {
            //pool
            IERC20(_token).safeTransferFrom(_from, _to, _amount);
        }
        return _amount;
    }
}",951
RealWorld_TA_101_IVerification_RealWorld_20240812181059.log,101,IVerification,74947,1382,76329,73.0,0.402375,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface IVerification {
    /// @notice Event emitted when a verifier is added as valid by admin
    /// @param verifier The address of the verifier contract to be added
    event VerifierAdded(address indexed verifier);

    /// @notice Event emitted when a verifier is to be marked as invalid by admin
    /// @param verifier The address of the verified contract to be marked as invalid
    event VerifierRemoved(address indexed verifier);

    /// @notice Event emitted when a master address is verified by a valid verifier
    /// @param masterAddress The masterAddress which is verifier by the verifier
    /// @param verifier The verifier which verified the masterAddress
    /// @param activatesAt Timestamp at which master address is considered active after the cooldown period
    event UserRegistered(address indexed masterAddress, address indexed verifier, uint256 activatesAt);

    /// @notice Event emitted when a master address is marked as invalid/unregisterd by a valid verifier
    /// @param masterAddress The masterAddress which is unregistered
    /// @param verifier The verifier which verified the masterAddress
    /// @param unregisteredBy The msg.sender by which the user was unregistered
    event UserUnregistered(address indexed masterAddress, address indexed verifier, address indexed unregisteredBy);

    /// @notice Event emitted when an address is linked to masterAddress
    /// @param linkedAddress The address which is linked to masterAddress
    /// @param masterAddress The masterAddress to which address is linked
    /// @param activatesAt Timestamp at which linked address is considered active after the cooldown period
    event AddressLinked(address indexed linkedAddress, address indexed masterAddress, uint256 activatesAt);

    /// @notice Event emitted when an address is unlinked from a masterAddress
    /// @param linkedAddress The address which is linked to masterAddress
    /// @param masterAddress The masterAddress to which address was linked
    event AddressUnlinked(address indexed linkedAddress, address indexed masterAddress);

    /// @notice Event emitted when master address placed a request to link another address to itself
    /// @param linkedAddress The address which is to be linked to masterAddress
    /// @param masterAddress The masterAddress to which address is to be linked
    event AddressLinkingRequested(address indexed linkedAddress, address indexed masterAddress);

    /// @notice Event emitted when master address cancels the request placed to link another address to itself
    /// @param linkedAddress The address which is to be linked to masterAddress
    /// @param masterAddress The masterAddress to which address is to be linked
    event AddressLinkingRequestCancelled(address indexed linkedAddress, address indexed masterAddress);

    /// @notice Event emitted when activation delay is updated
    /// @param activationDelay updated value of activationDelay in seconds
    event ActivationDelayUpdated(uint256 activationDelay);

    function isUser(address _user, address _verifier) external view returns (bool isMsgSenderUser);

    function verifiers(address _verifier) external view returns (bool isValid);

    function registerMasterAddress(address _masterAddress, bool _isMasterLinked) external;

    function unregisterMasterAddress(address _masterAddress, address _verifier) external;
}",671
RealWorld_TA_101_PoolEthUtils_RealWorld_20240812175448.log,101,PoolEthUtils,43140,2726,45866,85.0,0.27022,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '../interfaces/IWETH9.sol';
import '../interfaces/IPool.sol';

contract PoolEthUtils {
    IWETH9 public immutable weth;

    constructor(address _weth) {
        require(_weth != address(0), 'PEU:C1');
        weth = IWETH9(_weth);
    }

    function depositEthAsCollateralToPool(address _pool) external payable {
        _toWETHAndApprove(_pool, msg.value);
        IPool(_pool).depositCollateral(msg.value, false);
    }

    function addEthCollateralInMarginCall(address _pool, address _lender) external payable {
        _toWETHAndApprove(_pool, msg.value);
        IPool(_pool).addCollateralInMarginCall(_lender, msg.value, false);
    }

    function ethLend(
        address _pool,
        address _lender,
        address _strategy
    ) external payable {
        _toWETHAndApprove(_pool, msg.value);
        IPool(_pool).lend(_lender, msg.value, _strategy, false);
    }

    function _toWETHAndApprove(address _address, uint256 _amount) private {
        weth.deposit{value: _amount}();
        weth.approve(_address, _amount);
    }
}",296
RealWorld_TA_101_MockCEther_RealWorld_20240812140850.log,101,MockCEther,54695,5369,60064,106.0,0.380855,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '../interfaces/Invest/ICEther.sol';

// @dev This contract should be able to mint underlying tokens to work
contract MockCEther is ERC20, ICEther {
    uint256 exchangeRateStored;
    uint256 lastExchangeRateAt;

    constructor() ERC20('CEther', 'cETH') {
        exchangeRateStored = 1e18;
        lastExchangeRateAt = block.timestamp;
    }

    function mint() external payable override {
        uint256 _shares = (msg.value * 1e18) / _exchangeRateCurrent();
        _mint(msg.sender, _shares);
    }

    function redeem(uint256 redeemTokens) external override returns (uint256) {
        uint256 _amount = (redeemTokens * _exchangeRateCurrent()) / 1e18;
        _burn(msg.sender, redeemTokens);

        payable(msg.sender).transfer(_amount);
        return 0;
    }

    function balanceOfUnderlying(address account) external returns (uint256) {
        return (balanceOf(account) * _exchangeRateCurrent()) / 1e18;
    }

    function exchangeRateCurrent() external returns (uint256) {
        return _exchangeRateCurrent();
    }

    function _exchangeRateCurrent() internal returns (uint256) {
        uint256 _currentExchangeRate = (exchangeRateStored * (1e18 + ((block.timestamp - lastExchangeRateAt) * 1e8))) / 1e18;
        exchangeRateStored = _currentExchangeRate;
        lastExchangeRateAt = block.timestamp;
        return _currentExchangeRate;
    }

    function getCash() external override returns (uint256) {
        return (90 * totalSupply()) / 100;
    }
}",406
RealWorld_TA_101_PCLClosedStage.t_RealWorld_20240812151656.log,101,PCLClosedStage.t,76648,3874,80522,97.0,0.46072,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLClosedStage.t.sol';

contract PCLClosedStageCollateralNoYieldBorrowCompound is PCLClosedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        // Now we assert that we are in the ACTIVE state
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), 2);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // And borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(requestId, currentDebt);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
}",684
RealWorld_TA_101_GovernanceTester_RealWorld_20240812141351.log,101,GovernanceTester,29799,1796,31595,69.0,0.184915,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

contract GovernanceTester {
    address public gov;
    uint256 public value;

    event valueUpdated(address indexed governance, address indexed sender, uint256 v);

    modifier onlyGov() {
        require(msg.sender == gov, 'GT:OG1');
        _;
    }

    constructor(address _gov, uint256 _val) {
        gov = _gov;
        value = _val;
    }

    function update(uint256 _value) public onlyGov {
        value = _value;
        emit valueUpdated(gov, msg.sender, _value);
    }
}",131
RealWorld_TA_101_PCLActiveState.t_RealWorld_20240812160308.log,101,PCLActiveState.t,1317579,68,1317647,162.0,6.589255,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}",15978
RealWorld_TA_101_PooledCreditLine_RealWorld_20240812180412.log,101,PooledCreditLine,925471,711,926182,145.0,4.641575,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/SafeCast.sol';
import '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../Math.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';
import '../interfaces/ILenderPool.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IPooledCreditLine.sol';
import '../interfaces/ILimitsManager.sol';

/**
 * @title Pooled Credit Line contract with Methods related to creditLines
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract PooledCreditLine is ReentrancyGuardUpgradeable, OwnableUpgradeable, IPooledCreditLine {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    //-------------------------------- Constants start --------------------------------//

    /*
     * @notice number of seconds in an year
     */
    uint256 internal constant YEAR_IN_SECONDS = 365 days;

    /*
     * @notice Factor to multiply variables to maintain precision
     */
    uint256 public constant SCALING_FACTOR = 1e18;

    /**
     * @notice address of lender pool contract
     */
    ILenderPool public immutable LENDER_POOL;

    /**
     * @notice stores the address of savings account contract
     **/
    ISavingsAccount public immutable SAVINGS_ACCOUNT;

    /**
     * @notice stores the address of price oracle contract
     **/
    IPriceOracle public immutable PRICE_ORACLE;

    /**
     * @notice stores the address of limits manager
     **/
    ILimitsManager public immutable LIMITS_MANAGER;

    /**
     * @notice stores the address of strategy registry contract
     **/
    IStrategyRegistry public immutable STRATEGY_REGISTRY;

    /**
     * @notice address that the borrower for pooled credit line should be verified with
     **/
    IVerification public immutable VERIFICATION;

    /**
     * @notice maximum protocol fee fraction allowed, it is multiplied by SCALING_FACTOR
     */
    uint256 public immutable MAXIMUM_PROTOCOL_FEE_FRACTION;

    //-------------------------------- Constants end --------------------------------//

    //-------------------------------- Global vars starts --------------------------------//
    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by SCALING_FACTOR
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    //-------------------------------- Global vars end --------------------------------//

    //-------------------------------- CreditLine state starts --------------------------------//

    /**
     * @notice counter that tracks the number of pooled credit lines created
     * @dev used to create unique identifier for pooled credit lines
     **/
    uint256 public pooledCreditLineCounter;

    /**
     * @notice stores the collateral shares in a pooled credit line per collateral strategy
     * @dev id => collateralShares
     **/
    mapping(uint256 => uint256) public depositedCollateralInShares;

    /**
     * @notice stores the variables to maintain a pooled credit line
     **/
    mapping(uint256 => PooledCreditLineVariables) public pooledCreditLineVariables;

    /**
     * @notice stores the constants related to a pooled credit line
     **/
    mapping(uint256 => PooledCreditLineConstants) public pooledCreditLineConstants;

    //-------------------------------- CreditLine State ends --------------------------------//

    //-------------------------------- Modifiers starts --------------------------------//

    /**
     * @dev checks if called by pooled credit Line Borrower
     * @param _id identifier for the pooled credit line
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(pooledCreditLineConstants[_id].borrower == msg.sender, 'PCL:OCLB1');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender Pool
     **/
    modifier onlyLenderPool() {
        require(address(LENDER_POOL) == msg.sender, 'PCL:OLP1');
        _;
    }

    //-------------------------------- Modifiers end --------------------------------//

    //-------------------------------- Events start --------------------------------//

    //--------------------------- Global variable update events start ---------------------------//

    /**
     * @notice emitted when fee that protocol charges for pooled credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    //--------------------------- Global variable update events end ---------------------------//

    //--------------------------- CreditLine state events start ---------------------------//

    /**
     * @notice emitted when a collateral is deposited into pooled credit line
     * @param id identifier for the pooled credit line
     * @param shares amount of shares of collateral deposited
     */
    event CollateralSharesDeposited(uint256 indexed id, uint256 shares);

    /**
     * @notice emitted when collateral is withdrawn from pooled credit line
     * @param id identifier for the pooled credit line
     * @param shares amount of shares of collateral withdrawn
     */
    event CollateralSharesWithdrawn(uint256 indexed id, uint256 shares);

    /**
     * @notice emitted when a request for new pooled credit line is placed
     * @param id identifier for the pooled credit line
     * @param borrower address of the borrower for credit line
     * @param borrowerVerifier address of the verifier with which borrower is verified
     */
    event PooledCreditLineRequested(uint256 indexed id, address indexed borrower, address indexed borrowerVerifier);

    /**
     * @notice emitted when a pooled credit line is liquidated
     * @param id identifier for the pooled credit line
     * @param shares amount of shares of collateral used for liquidation
     */
    event PooledCreditLineLiquidated(uint256 indexed id, uint256 shares);

    /**
     * @notice emitted when tokens are borrowed from pooled credit line
     * @param id identifier for the pooled credit line
     * @param borrowShares amount of shares of tokens borrowed
     */
    event BorrowedFromPooledCreditLine(uint256 indexed id, uint256 borrowShares);

    /**
     * @notice Emitted when pooled credit line is accepted
     * @param id identifier for the pooled credit line
     * @param amount total amount of tokens lent to pooled credit line
     */
    event PooledCreditLineAccepted(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when the pooled credit line is partially repaid
     * @param id identifier for the pooled credit line
     * @param repayer address of the repayer
     * @param repayAmount amount repaid
     */
    event PartialPooledCreditLineRepaid(uint256 indexed id, address indexed repayer, uint256 repayAmount);

    /**
     * @notice emitted when the pooled credit line is completely repaid
     * @param id identifier for the pooled credit line
     * @param repayer address of the repayer
     * @param repayAmount amount repaid
     */
    event CompletePooledCreditLineRepaid(uint256 indexed id, address indexed repayer, uint256 repayAmount);

    /**
     * @notice emitted when the pooled credit line is closed by the borrower
     * @param id identifier for the pooled credit line
     */
    event PooledCreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when the pooled credit line is cancelled while in REQUESTED state
     * @param id identifier for the pooled credit line
     * @param reason identifier which specifies the reason for which PCL was cancelled
     */
    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);

    /**
     * @notice emitted when the pooled credit line is terminated by owner
     * @param id identifier for the pooled credit line
     */
    event PooledCreditLineTerminated(uint256 indexed id);

    //--------------------------- CreditLine state events end ---------------------------//

    //-------------------------------- Events end --------------------------------//

    //-------------------------------- Global var update code start --------------------------------//

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFeeFraction fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFeeFraction) external onlyOwner {
        require(protocolFeeFraction != _protocolFeeFraction, 'PCL:UPFF1');
        _updateProtocolFeeFraction(_protocolFeeFraction);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFeeFraction) private {
        require(_protocolFeeFraction <= MAXIMUM_PROTOCOL_FEE_FRACTION, 'PCL:IUPFF1');
        protocolFeeFraction = _protocolFeeFraction;
        emit ProtocolFeeFractionUpdated(_protocolFeeFraction);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        require(protocolFeeCollector != _protocolFeeCollector, 'PCL:UPFC1');
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) private {
        require(_protocolFeeCollector != address(0), 'PCL:IUPFC1');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    //-------------------------------- Global var update code end --------------------------------//

    //-------------------------------- Initialize code start --------------------------------//

    /**
     * @notice constructor to initialize immutables
     * @param _lenderPool address of lenderPool contract
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _verification address of the verification contract
     * @param _limitsManager address of the _limitsManager contract
     * @param _maximumProtocolFeeFraction the maximum protocol fee fraction allowed
     */
    constructor(
        address _lenderPool,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _verification,
        address _limitsManager,
        uint256 _maximumProtocolFeeFraction
    ) {
        require(_lenderPool != address(0), 'PCL:CON1');
        require(_priceOracle != address(0), 'PCL:CON2');
        require(_savingsAccount != address(0), 'PCL:CON3');
        require(_strategyRegistry != address(0), 'PCL:CON4');
        require(_verification != address(0), 'PCL:CON5');
        require(_limitsManager != address(0), 'PCL:CON6');
        LENDER_POOL = ILenderPool(_lenderPool);
        PRICE_ORACLE = IPriceOracle(_priceOracle);
        SAVINGS_ACCOUNT = ISavingsAccount(_savingsAccount);
        STRATEGY_REGISTRY = IStrategyRegistry(_strategyRegistry);
        VERIFICATION = IVerification(_verification);
        LIMITS_MANAGER = ILimitsManager(_limitsManager);
        MAXIMUM_PROTOCOL_FEE_FRACTION = _maximumProtocolFeeFraction;
    }

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol (multiplied by SCALING_FACTOR)
     * @param _protocolFeeCollector address to which protocol fee is charged to
     */
    function initialize(
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();

        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    //-------------------------------- Initialize code end --------------------------------//

    //-------------------------------- CreditLine creation code start --------------------------------//

    /**
     * @notice used to request a pooled credit line by a borrower
     * @param _request Credit line creation request
     * @return identifier for the pooled credit line
     */
    function request(Request calldata _request) external nonReentrant returns (uint256) {
        require(VERIFICATION.isUser(msg.sender, _request.borrowerVerifier), 'PCL:R1');
        require(_request.borrowAsset != _request.collateralAsset, 'PCL:R2');
        require(PRICE_ORACLE.doesFeedExist(_request.borrowAsset, _request.collateralAsset), 'PCL:R3');
        require(_request.borrowAsset != address(0) && _request.collateralAsset != address(0), 'PCL:R4');
        require(STRATEGY_REGISTRY.registry(_request.borrowAssetStrategy) != 0, 'PCL:R5');
        require(STRATEGY_REGISTRY.registry(_request.collateralAssetStrategy) != 0, 'PCL:R6');
        LIMITS_MANAGER.limitBorrowedInUSDC(_request.borrowAsset, _request.borrowLimit, _request.minBorrowAmount);
        require(LIMITS_MANAGER.isWithinLimits(_request.borrowRate, LIMITS_MANAGER.getBorrowRateLimits()), 'PCL:R7');
        // collateral ratio = 0 is a special case which is allowed
        if (_request.collateralRatio != 0) {
            require(LIMITS_MANAGER.isWithinLimits(_request.collateralRatio, LIMITS_MANAGER.getIdealCollateralRatioLimits()), 'PCL:R8');
        }
        require(LIMITS_MANAGER.isWithinLimits(_request.collectionPeriod, LIMITS_MANAGER.getCollectionPeriodLimits()), 'PCL:R9');
        require(LIMITS_MANAGER.isWithinLimits(_request.duration, LIMITS_MANAGER.getDurationLimits()), 'PCL:R10');
        require(LIMITS_MANAGER.isWithinLimits(_request.defaultGracePeriod, LIMITS_MANAGER.getDefaultGracePeriodLimits()), 'PCL:R11');
        require(LIMITS_MANAGER.isWithinLimits(_request.gracePenaltyRate, LIMITS_MANAGER.getGracePenaltyRateLimits()), 'PCL:R12');

        require(VERIFICATION.verifiers(_request.lenderVerifier), 'PCL:R13');

        uint256 _id = _createRequest(_request);

        _notifyRequest(
            _id,
            _request.lenderVerifier,
            _request.borrowAsset,
            _request.borrowAssetStrategy,
            _request.borrowLimit,
            _request.minBorrowAmount,
            _request.collectionPeriod,
            _request.areTokensTransferable
        );
        emit PooledCreditLineRequested(_id, msg.sender, _request.borrowerVerifier);
        return _id;
    }

    function _createRequest(Request calldata _request) private returns (uint256) {
        uint256 _id = ++pooledCreditLineCounter;
        pooledCreditLineVariables[_id].status = PooledCreditLineStatus.REQUESTED;

        PooledCreditLineConstants storage _clc = pooledCreditLineConstants[_id];
        _clc.borrower = msg.sender;
        _clc.borrowLimit = _request.borrowLimit;
        _clc.idealCollateralRatio = _request.collateralRatio;
        _clc.borrowRate = _request.borrowRate;
        _clc.borrowAsset = _request.borrowAsset;
        _clc.collateralAsset = _request.collateralAsset;
        _clc.collateralAssetStrategy = _request.collateralAssetStrategy;
        uint256 _endsAt = block.timestamp.add(_request.collectionPeriod).add(_request.duration);
        _clc.startsAt = block.timestamp.add(_request.collectionPeriod);
        _clc.endsAt = _endsAt;
        _clc.defaultsAt = _endsAt.add(_request.defaultGracePeriod);
        _clc.gracePenaltyRate = _request.gracePenaltyRate;
        _clc.borrowAssetStrategy = _request.borrowAssetStrategy;
        return _id;
    }

    /*
     * @notice callback method for LenderPool contract to set the PCL variables
     */
    function _notifyRequest(
        uint256 _id,
        address _lenderVerifier,
        address _borrowAsset,
        address _borrowAssetStrategy,
        uint256 _borrowLimit,
        uint256 _minBorrowedAmount,
        uint256 _collectionPeriod,
        bool _areTokensTransferable
    ) private {
        LENDER_POOL.create(
            _id,
            _lenderVerifier,
            _borrowAsset,
            _borrowAssetStrategy,
            _borrowLimit,
            _minBorrowedAmount,
            _collectionPeriod,
            _areTokensTransferable
        );
    }

    /**
     * @notice used to accept a pooled credit line
     * @dev callback from lender pool contract
     * @param _id identifier for the pooled credit line
     * @param _amount Borrow Limit
     * @param _by user who accepted the PCL
     */
    function accept(
        uint256 _id,
        uint256 _amount,
        address _by
    ) external override nonReentrant onlyLenderPool {
        require(pooledCreditLineVariables[_id].status == PooledCreditLineStatus.REQUESTED, 'PCL:A1');
        require(_by == pooledCreditLineConstants[_id].borrower, 'PCL:A2');
        pooledCreditLineVariables[_id].status = PooledCreditLineStatus.ACTIVE;
        pooledCreditLineConstants[_id].borrowLimit = SafeCast.toUint128(_amount);
        emit PooledCreditLineAccepted(_id, _amount);
    }

    //-------------------------------- CreditLine creation code end --------------------------------//

    //-------------------------------- Collateral management start --------------------------------//

    /**
     * @notice used to deposit collateral into the pooled credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract
     * @param _id identifier for the pooled credit line
     * @param _amount amount of collateral being deposited
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount
                                  otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external nonReentrant {
        require(_amount != 0, 'PCL:DC1');
        PooledCreditLineStatus _status = getStatusAndUpdate(_id);
        require(_status == PooledCreditLineStatus.ACTIVE || _status == PooledCreditLineStatus.EXPIRED, 'PCL:DC2');
        address _collateralAsset = pooledCreditLineConstants[_id].collateralAsset;
        address _strategy = pooledCreditLineConstants[_id].collateralAssetStrategy;
        uint256 _sharesDeposited;

        if (_fromSavingsAccount) {
            _sharesDeposited = SAVINGS_ACCOUNT.transferFrom(_collateralAsset, _strategy, msg.sender, address(this), _amount);
        } else {
            IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
            IERC20(_collateralAsset).safeApprove(_strategy, _amount);

            _sharesDeposited = SAVINGS_ACCOUNT.deposit(_collateralAsset, _strategy, address(this), _amount);
        }
        depositedCollateralInShares[_id] = depositedCollateralInShares[_id].add(_sharesDeposited);

        emit CollateralSharesDeposited(_id, _sharesDeposited);
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the pooled credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred to savingsAccount, else to borrower address directly
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'PCL:WC1');
        require(_amount != 0, 'PCL:WC2');
        (, uint256 _amountInShares) = _transferCollateral(_id, pooledCreditLineConstants[_id].collateralAsset, _amount, _toSavingsAccount);
        emit CollateralSharesWithdrawn(_id, _amountInShares);
    }

    /**
     * @notice used to withdraw all the permissible collateral as per the current collateralRatio
     * @dev if the withdrawable collateral amount is non-zero the transaction will pass
     * @param _id identifier for the pooled credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount
                                otherwise direct from collateral token contract
     */

    function withdrawAllCollateral(uint256 _id, bool _toSavingsAccount) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _collateralWithdrawn = _withdrawAllCollateral(_id, _toSavingsAccount);
        require(_collateralWithdrawn != 0, 'PCL:WAC1');
    }

    function _withdrawAllCollateral(uint256 _id, bool _toSavingsAccount) private returns (uint256 _collateralWithdrawn) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        if (_withdrawableCollateral == 0) {
            return 0;
        }
        (, uint256 _amountInShares) = _transferCollateral(
            _id,
            pooledCreditLineConstants[_id].collateralAsset,
            _withdrawableCollateral,
            _toSavingsAccount
        );
        emit CollateralSharesWithdrawn(_id, _amountInShares);
        return _withdrawableCollateral;
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the pooled credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        PooledCreditLineStatus _status = getStatusAndUpdate(_id);
        if (
            _status == PooledCreditLineStatus.EXPIRED ||
            _status == PooledCreditLineStatus.CANCELLED ||
            _status == PooledCreditLineStatus.REQUESTED
        ) {
            return 0;
        }

        uint256 _totalCollateral = calculateTotalCollateralTokens(_id);

        if (_status == PooledCreditLineStatus.LIQUIDATED || _status == PooledCreditLineStatus.CLOSED) {
            return _totalCollateral;
        }

        (uint256 _ratioOfPrices, uint256 _decimals) = PRICE_ORACLE.getLatestPrice(
            pooledCreditLineConstants[_id].collateralAsset,
            pooledCreditLineConstants[_id].borrowAsset
        );

        uint256 _currentDebt = calculateCurrentDebt(_id);
        uint256 _collateralRatio = pooledCreditLineConstants[_id].idealCollateralRatio;

        // _collateralNeeded is the number of collateral tokens needed to maintain the _collateralRatio
        uint256 _collateralNeeded = _currentDebt.mul(_collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(SCALING_FACTOR);

        if (_collateralNeeded >= _totalCollateral) {
            return 0;
        }
        return _totalCollateral.sub(_collateralNeeded);
    }

    /*
    * @notice this method transfers the collateral tokens to the msg.sender and reduces the depositedCollateralInShares
    *         value to maintain the amount of collateral tokens deposited in the PCL
    * @param _id the id of the pcl
    * @param _asset the collateral asset
    * @param _amountInTokens the amount to be transferred
    * @param _toSavingsAccount if the true the amount if transferred to the savings account of the msg.sender
             else the tokens are directly transferred.
    */
    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) private returns (uint256, uint256) {
        address _strategy = pooledCreditLineConstants[_id].collateralAssetStrategy;
        uint256 _amountInShares = IYield(_strategy).getSharesForTokens(_amountInTokens, _asset);
        uint256 _amountReceived;
        if (_amountInShares == 0) return (0, 0);

        depositedCollateralInShares[_id] = depositedCollateralInShares[_id].sub(_amountInShares, 'PCL:ITC1');

        if (_toSavingsAccount) {
            _amountReceived = SAVINGS_ACCOUNT.transferShares(_asset, _strategy, msg.sender, _amountInShares);
        } else {
            _amountReceived = SAVINGS_ACCOUNT.withdrawShares(_asset, _strategy, msg.sender, _amountInShares, false);
        }

        return (_amountReceived, _amountInShares);
    }

    /**
     * @notice used to calculate the total collateral tokens held in the pcl savings account
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the pooled credit line
     * @return _amount total collateral tokens deposited into the pooled credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256) {
        address _strategy = pooledCreditLineConstants[_id].collateralAssetStrategy;
        require(_strategy != address(0), 'PCL:CTCT1');
        address _collateralAsset = pooledCreditLineConstants[_id].collateralAsset;

        uint256 _collateralShares = depositedCollateralInShares[_id];
        uint256 _collateral = IYield(_strategy).getTokensForShares(_collateralShares, _collateralAsset);

        return _collateral;
    }

    /*
    * @notice this method returns the number of collateral tokens the borrower has to deposit to be able
              to borrow the given _borrowTokenAmount. the return value is calculated based on the idealCollateralRatio
    */
    function getRequiredCollateral(uint256 _id, uint256 _borrowTokenAmount) external view returns (uint256) {
        address _collateralAsset = pooledCreditLineConstants[_id].collateralAsset;
        address _borrowAsset = pooledCreditLineConstants[_id].borrowAsset;

        uint256 _collateral = _equivalentCollateral(_collateralAsset, _borrowAsset, _borrowTokenAmount);

        return _collateral.mul(pooledCreditLineConstants[_id].idealCollateralRatio).div(SCALING_FACTOR);
    }

    //-------------------------------- Collateral management end --------------------------------//

    //-------------------------------- Borrow code start --------------------------------//

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is
            min(amount of borrow asset left in the pcl, amount that is borrowable based on ideal collateral ratio)
     * @param _id identifier for the pooled credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external nonReentrant onlyCreditLineBorrower(_id) {
        _borrow(_id, _amount);
    }

    function _borrow(uint256 _id, uint256 _amount) private {
        require(_amount != 0, 'PCL:IB1');
        require(block.timestamp >= pooledCreditLineConstants[_id].startsAt, 'PCL:IB2');
        // calculateBorrowableAmount is 0, hence statement reverts for all states except ACTIVE
        require(_amount <= calculateBorrowableAmount(_id), 'PCL:IB3');

        address _borrowAsset = pooledCreditLineConstants[_id].borrowAsset;

        uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));

        uint256 _sharesWithdrawn = _withdrawBorrowAmount(_borrowAsset, pooledCreditLineConstants[_id].borrowAssetStrategy, _amount);
        LENDER_POOL.borrowed(_id, _sharesWithdrawn);
        uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));

        uint256 _borrowedAmount = _balanceAfter.sub(_balanceBefore);
        _updateStateOnPrincipalChange(_id, pooledCreditLineVariables[_id].principal.add(_borrowedAmount));

        // protocol fee is collected everytime amount if borrowed
        uint256 _protocolFee = _borrowedAmount.mul(protocolFeeFraction).div(SCALING_FACTOR);
        _borrowedAmount = _borrowedAmount.sub(_protocolFee);

        IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
        IERC20(_borrowAsset).safeTransfer(msg.sender, _borrowedAmount);
        emit BorrowedFromPooledCreditLine(_id, _sharesWithdrawn);
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the pooled credit line
     * @return amount that can be borrowed from the pooled credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        PooledCreditLineStatus _status = getStatusAndUpdate(_id);
        if (_status != PooledCreditLineStatus.ACTIVE) {
            return 0;
        }
        (uint256 _ratioOfPrices, uint256 _decimals) = PRICE_ORACLE.getLatestPrice(
            pooledCreditLineConstants[_id].collateralAsset,
            pooledCreditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateral = calculateTotalCollateralTokens(_id);

        // current debt includes the principal amount + unpaid interest
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralRatio = pooledCreditLineConstants[_id].idealCollateralRatio;
        uint256 _maxPossible = type(uint256).max;
        if (_collateralRatio != 0) {
            // _maxPossible is the amount of borrow tokens which can be borrowed based on the _collateralRatio
            _maxPossible = _totalCollateral.mul(_ratioOfPrices).div(_collateralRatio).mul(SCALING_FACTOR).div(10**_decimals);
        }

        uint256 _borrowLimit = pooledCreditLineConstants[_id].borrowLimit;
        uint256 _principal = pooledCreditLineVariables[_id].principal;

        // if the _maxPossible amount is less than the _currentDebt this means that current collateral ratio is less
        // then the idealCollateralRatio. This PCL can be liquidated now and the borrower has to deposit more collateral
        // to save it from liquidation
        if (_maxPossible <= _currentDebt) return 0;

        // using direct subtraction for _maxPossible because we have a check above for it being greater than _currentDebt
        return Math.min(_borrowLimit.sub(_principal), _maxPossible - _currentDebt);
    }

    function _withdrawBorrowAmount(
        address _asset,
        address _strategy,
        uint256 _amountInTokens
    ) private returns (uint256) {
        uint256 _shares = IYield(_strategy).getSharesForTokens(_amountInTokens, _asset);
        require(_shares != 0, 'PCL:IWBA1');
        SAVINGS_ACCOUNT.withdrawFrom(_asset, _strategy, address(LENDER_POOL), address(this), _amountInTokens, false);
        return _shares;
    }

    //-------------------------------- Borrow code end --------------------------------//

    //-------------------------------- Repayments code start --------------------------------//

    /**
     * @notice used to repay interest and principal to pooled credit line. Interest has to be repaid before
               repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the pooled credit line
     * @param _amount amount being repaid
     */
    function repay(uint256 _id, uint256 _amount) external nonReentrant {
        require(_amount != 0, 'PCL:REP1');
        PooledCreditLineStatus currentStatus = getStatusAndUpdate(_id);
        require(currentStatus == PooledCreditLineStatus.ACTIVE || currentStatus == PooledCreditLineStatus.EXPIRED, 'PCL:REP2');

        uint256 _currentPrincipal = pooledCreditLineVariables[_id].principal;
        uint256 _totalInterestAccrued = calculateInterestAccrued(_id);
        uint256 _interestToPay = _totalInterestAccrued.sub(pooledCreditLineVariables[_id].totalInterestRepaid);
        uint256 _currentDebt = (_currentPrincipal).add(_interestToPay);

        require(_currentDebt != 0, 'PCL:REP3');

        // in case the interest to pay is 0 (expect when interest rate is 0) no repayment can happen
        // this is because it can be then possible to borrow small amounts for short period of time
        // then pay it back with 0 interest. to be safe we allow repayment when there is some _interestToPay
        // this condition also stops flash loans
        if (pooledCreditLineConstants[_id].borrowRate != 0) {
            require(_interestToPay != 0, 'PCL:REP4');
        }

        if (_amount >= _currentDebt) {
            _amount = _currentDebt;
            emit CompletePooledCreditLineRepaid(_id, msg.sender, _amount);
        } else {
            emit PartialPooledCreditLineRepaid(_id, msg.sender, _amount);
        }

        uint256 _principalPaid;
        if (_amount > _interestToPay) {
            _principalPaid = _amount.sub(_interestToPay);
            pooledCreditLineVariables[_id].principal = _currentPrincipal.sub(_principalPaid);
            pooledCreditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            pooledCreditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            pooledCreditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
        } else {
            pooledCreditLineVariables[_id].totalInterestRepaid = pooledCreditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        uint256 _interestPaid = _amount.sub(_principalPaid);
        uint256 _repaidInterestShares = IYield(pooledCreditLineConstants[_id].borrowAssetStrategy).getSharesForTokens(
            _interestPaid,
            pooledCreditLineConstants[_id].borrowAsset
        );

        uint256 _repaidShares = _repay(_id, _amount);
        LENDER_POOL.repaid(_id, _repaidShares, _repaidInterestShares);

        if ((pooledCreditLineVariables[_id].principal == 0) && (currentStatus == PooledCreditLineStatus.EXPIRED)) {
            pooledCreditLineVariables[_id].status = PooledCreditLineStatus.CLOSED;
            emit PooledCreditLineClosed(_id);
        }
    }

    function _repay(uint256 _id, uint256 _amount) private returns (uint256) {
        address _strategy = pooledCreditLineConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCreditLineConstants[_id].borrowAsset;
        IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
        IERC20(_borrowAsset).safeApprove(_strategy, _amount);
        uint256 _sharesReceived = SAVINGS_ACCOUNT.deposit(_borrowAsset, _strategy, address(LENDER_POOL), _amount);
        return _sharesReceived;
    }

    /**
     * @dev Used to calculate the total interest accrued in the pcl since start till now
     * @param _id identifier for the pooled credit line
     * @return total interest accrued in the pcl since start till now
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = pooledCreditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _endTime = pooledCreditLineConstants[_id].endsAt;
        uint256 _penaltyRate = pooledCreditLineConstants[_id].gracePenaltyRate;
        uint256 _principal = pooledCreditLineVariables[_id].principal;
        uint256 _borrowRate = pooledCreditLineConstants[_id].borrowRate;
        uint256 _penaltyInterestScaled;
        if (_lastPrincipalUpdateTime <= _endTime && block.timestamp > _endTime) {
            // this condition means that _lastPrincipalUpdateTime is older than the end time of the PCL
            // so the penalty rate is applicable only on the time from the end time till now.
            _penaltyInterestScaled = _calculateInterestScaled(_principal, _penaltyRate, block.timestamp.sub(_endTime));
        } else if (_lastPrincipalUpdateTime > _endTime) {
            // this condition means that the _lastPrincipalUpdateTime is beyond end time of the PCL
            // so the penalty interest can be applied from _lastPrincipalUpdateTime till now.
            _penaltyInterestScaled = _calculateInterestScaled(_principal, _penaltyRate, block.timestamp.sub(_lastPrincipalUpdateTime));
        }
        uint256 _interestAccruedScaled = _calculateInterestScaled(_principal, _borrowRate, _timeElapsed);
        _interestAccruedScaled = _interestAccruedScaled.add(_penaltyInterestScaled);
        // scale down interestAccured and take ceiling for the interest as it ensures that borrower can't repay frequently to skip interest
        uint256 _interestAccrued = _divAndCeil(_interestAccruedScaled, SCALING_FACTOR);
        return _interestAccrued.add(pooledCreditLineVariables[_id].interestAccruedTillLastPrincipalUpdate);
    }

    /**
     * @dev Used to calculate current debt of borrower against a pooled credit line.
     * @param _id identifier for the pooled credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (pooledCreditLineVariables[_id].principal).add(_interestAccrued).sub(
            pooledCreditLineVariables[_id].totalInterestRepaid
        );
        return _currentDebt;
    }

    //-------------------------------- Repayments code end --------------------------------//

    //-------------------------------- Liquidation code start --------------------------------//

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev this is a callback from the LenderPool.liquidate
            the collateral is directly transferred to lenderPool for lenders to withdraw
     * @param _id identifier for the pooled credit line
     * @return collateral asset received, amount of collateral asset received
     */
    function liquidate(uint256 _id) external override nonReentrant onlyLenderPool returns (address, uint256) {
        PooledCreditLineStatus currentStatus = getStatusAndUpdate(_id);
        require(pooledCreditLineVariables[_id].principal != 0, 'PCL:L1');
        require(currentStatus == PooledCreditLineStatus.ACTIVE || currentStatus == PooledCreditLineStatus.EXPIRED, 'PCL:L2');

        address _collateralAsset = pooledCreditLineConstants[_id].collateralAsset;

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < pooledCreditLineConstants[_id].idealCollateralRatio ||
                block.timestamp >= pooledCreditLineConstants[_id].defaultsAt,
            'PCL:L3'
        );
        uint256 _currentDebt = calculateCurrentDebt(_id);
        address _borrowAsset = pooledCreditLineConstants[_id].borrowAsset;
        uint256 _collateralToLiquidate = _equivalentCollateral(_collateralAsset, _borrowAsset, _currentDebt);
        uint256 _totalCollateral = calculateTotalCollateralTokens(_id);
        if (_collateralToLiquidate > _totalCollateral) {
            _collateralToLiquidate = _totalCollateral;
        }

        pooledCreditLineVariables[_id].status = PooledCreditLineStatus.LIQUIDATED;

        uint256 _collateralReceived;
        uint256 _collateralInShares;
        if (_collateralToLiquidate != 0) {
            (_collateralReceived, _collateralInShares) = _transferCollateral(_id, _collateralAsset, _collateralToLiquidate, false);
        }

        emit PooledCreditLineLiquidated(_id, _collateralInShares);

        return (_collateralAsset, _collateralReceived);
    }

    /**
     * @notice used to calculate collateral tokens equivalent to _borrowTokenAmount
     * @param _id identifier for the pooled credit line
     * @param _borrowTokenAmount amount of borrow tokens for which equivalent collateral is calculated
     * @return collateral tokens equivalent to _borrowTokenAmount
     */
    function getEquivalentCollateralTokens(uint256 _id, uint256 _borrowTokenAmount) external view returns (uint256) {
        address _collateralAsset = pooledCreditLineConstants[_id].collateralAsset;
        require(_collateralAsset != address(0), 'PCL:CTTL1');
        address _borrowAsset = pooledCreditLineConstants[_id].borrowAsset;

        return _equivalentCollateral(_collateralAsset, _borrowAsset, _borrowTokenAmount);
    }

    //-------------------------------- Liquidation code end --------------------------------//

    //-------------------------------- close/cancel code start --------------------------------//

    /**
     * @notice used to close pooled credit line. only callable by the borrower
     * @dev this will also withdraw all the collateral and transfer it to the borrower
     * @param _id identifier for the pooled credit line
     */
    function close(uint256 _id) external nonReentrant onlyCreditLineBorrower(_id) {
        PooledCreditLineStatus _status = pooledCreditLineVariables[_id].status;
        require(_status == PooledCreditLineStatus.ACTIVE || _status == PooledCreditLineStatus.EXPIRED, 'PCL:C1');
        require(pooledCreditLineVariables[_id].principal == 0, 'PCL:C2');
        pooledCreditLineVariables[_id].status = PooledCreditLineStatus.CLOSED;
        _withdrawAllCollateral(_id, false);
        emit PooledCreditLineClosed(_id);
    }

    /**
     * @notice used to cancel a pooled credit line request. only callable by the borrower
     * @dev only callable by the borrower in REQUESTED state
     * @param _id identifier for the pooled credit line
     */
    function cancelRequest(uint256 _id) external nonReentrant onlyCreditLineBorrower(_id) {
        require(pooledCreditLineVariables[_id].status == PooledCreditLineStatus.REQUESTED, 'PCL:CR1');
        require(block.timestamp < pooledCreditLineConstants[_id].startsAt, 'PCL:CR2');
        LENDER_POOL.requestCancelled(_id);
        _cancelRequest(_id, CancellationStatus.BORROWER_BEFORE_START);
    }

    /**
     * @notice Function invoked when pooled credit line cancelled because of low collection
     * @dev only LenderPool can invoke
     * @param _id identifier for the pooled credit line
     */
    function cancelRequestOnLowCollection(uint256 _id) external override nonReentrant onlyLenderPool {
        _cancelRequest(_id, CancellationStatus.LENDER_LOW_COLLECTION);
    }

    /**
     * @notice Function invoked when pooled credit line cancelled because it wasn't started even after end time
     * @dev only LenderPool can invoke
     * @param _id identifier for the pooled credit line
     */
    function cancelRequestOnRequestedStateAtEnd(uint256 _id) external override nonReentrant onlyLenderPool {
        _cancelRequest(_id, CancellationStatus.LENDER_NOT_STARTED_AT_END);
    }

    function _cancelRequest(uint256 _id, CancellationStatus _reason) private {
        delete pooledCreditLineVariables[_id];
        delete pooledCreditLineConstants[_id];
        pooledCreditLineVariables[_id].status = PooledCreditLineStatus.CANCELLED;
        emit PooledCreditLineCancelled(_id, _reason);
    }

    /**
     * @notice Function invoked when pooled credit line is terminated by admin
     * @dev only owner can invoke
     * @param _id identifier for the pooled credit line
     */
    function terminate(uint256 _id) external nonReentrant onlyOwner {
        // This function reverts in `NOT_CREATED` or `CANCELLED` state and hence can't terminate
        uint256 _allCollateral = calculateTotalCollateralTokens(_id);
        // transfers all the collateral held to the owner
        if (_allCollateral != 0) {
            _transferCollateral(_id, pooledCreditLineConstants[_id].collateralAsset, _allCollateral, false);
        }
        // callback to lender poll which transfers all the assets held in lender pool to the admin
        LENDER_POOL.terminate(_id, msg.sender);
        delete pooledCreditLineVariables[_id];
        delete pooledCreditLineConstants[_id];
        emit PooledCreditLineTerminated(_id);
    }

    //-------------------------------- close/cancel code end --------------------------------//

    //-------------------------------- Utilities code start --------------------------------//

    /**
     * @notice used to update(if required) and get the status of pooled credit line
     * @dev keeps track of status of the PCL
     * @param _id identifier for the pooled credit line
     * @return status of pooled credit line
     */
    function getStatusAndUpdate(uint256 _id) public override returns (PooledCreditLineStatus) {
        PooledCreditLineStatus currentStatus = pooledCreditLineVariables[_id].status;
        if (currentStatus == PooledCreditLineStatus.ACTIVE && pooledCreditLineConstants[_id].endsAt <= block.timestamp) {
            if (pooledCreditLineVariables[_id].principal != 0) {
                currentStatus = PooledCreditLineStatus.EXPIRED;
            } else {
                currentStatus = PooledCreditLineStatus.CLOSED;
            }
            pooledCreditLineVariables[_id].status = currentStatus;
        }
        return currentStatus;
    }

    /**
     * @notice Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which pooled Credit Line is approved
     * @param _timeElapsed time in seconds to calculate interest for
     * @return interest per second scaled by SCALING_FACTOR for the given parameters
     */
    function _calculateInterestScaled(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) private pure returns (uint256) {
        return (_principal.mul(_borrowRate).mul(_timeElapsed).div(YEAR_IN_SECONDS));
    }

    /*
     * @notice used to update the pcl variables on borrowing
     */
    function _updateStateOnPrincipalChange(uint256 _id, uint256 _updatedPrincipal) private {
        uint256 _totalInterestAccrued = calculateInterestAccrued(_id);
        pooledCreditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
        pooledCreditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
        pooledCreditLineVariables[_id].principal = _updatedPrincipal;
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the pooled credit line
     * @return collateral ratio multiplied by SCALING_FACTOR to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = PRICE_ORACLE.getLatestPrice(
            pooledCreditLineConstants[_id].collateralAsset,
            pooledCreditLineConstants[_id].borrowAsset
        );

        uint256 _currentDebt = calculateCurrentDebt(_id);
        uint256 _currentCollateralRatio = type(uint256).max;
        if (_currentDebt != 0) {
            _currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(_currentDebt).mul(SCALING_FACTOR).div(
                10**_decimals
            );
        }

        return _currentCollateralRatio;
    }

    function _equivalentCollateral(
        address _collateralAsset,
        address _borrowAsset,
        uint256 _borrowTokenAmount
    ) private view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = PRICE_ORACLE.getLatestPrice(_collateralAsset, _borrowAsset);
        uint256 _collateralTokenAmount = (_borrowTokenAmount.mul(10**_decimals).div(_ratioOfPrices));

        return _collateralTokenAmount;
    }

    function _divAndCeil(uint256 _num, uint256 _denom) private pure returns (uint256) {
        uint256 _divResult = _num.div(_denom);
        if (_divResult * _denom != _num) {
            _divResult++;
        }
        return _divResult;
    }

    //-------------------------------- Utilities code end --------------------------------//

    //-------------------------------- getters start --------------------------------//

    /**
     * @notice used to get the principal borrowed in a pooled credit line
     * @param _id identifier for the pooled credit line
     * @return Returns principal for the given pooled credit line
     */
    function getPrincipal(uint256 _id) external view override returns (uint256) {
        return pooledCreditLineVariables[_id].principal;
    }

    /**
     * @notice used to get the borrower address in a pooled credit line
     * @param _id identifier for the pooled credit line
     * @return Returns borrower address for the given pooled credit line
     */
    function getBorrowerAddress(uint256 _id) external view override returns (address) {
        return pooledCreditLineConstants[_id].borrower;
    }

    /**
     * @notice used to get the endAt time in a pooled credit line
     * @param _id identifier for the pooled credit line
     * @return Returns ends at time for the given pooled credit line
     */
    function getEndsAt(uint256 _id) external view override returns (uint256) {
        return pooledCreditLineConstants[_id].endsAt;
    }

    //-------------------------------- getters end --------------------------------//
}",10994
RealWorld_TA_101_PCLRequestedStage.t_RealWorld_20240812145357.log,101,PCLRequestedStage.t,910993,68,911061,136.0,4.556325,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert(""Lender shouldn't be able to start PCL"");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert(""Admin shouldn't be able to start PCL"");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert(""Random user shouldn't be able to start PCL"");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}",10686
RealWorld_TA_101_creditLine.RequestedStage.t_RealWorld_20240812164409.log,101,creditLine.RequestedStage.t,587773,5090,592863,164.0,3.040665,"pragma solidity 0.7.6;
pragma abicoder v2;

import './Helpers/CLParent.sol';
import '../../PriceOracle.sol';

import '@openzeppelin/contracts/math/SafeMath.sol';

contract CreditLine_RequestedStageTests is CLParent {
    using SafeMath for uint256;

    CreditLine cl;
    PriceOracle priceOracle;

    address[] public userList;

    function setUp() public virtual {
        CLSetUp();

        cl = CreditLine(creditLineAddress);
        priceOracle = PriceOracle(priceOracleAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = priceOracle.getLatestPrice(address(usdc), address(borrowAsset));

        requestData.requestTo = address(lender);
        // Borrow Asset equivalent of 1,000,000,000 in USD
        requestData.borrowLimit = uint128(uint256(CLConstants.maxBorrowLimit / 1e6).mul(_ratioOfPrices).div(10**_decimals));
        requestData.borrowRate = CLConstants.maxBorrowRate;
        requestData.autoLiquidation = false;
        requestData.collateralRatio = CLConstants.maxCollteralRatio;
        requestData.borrowAsset = address(borrowAsset);
        requestData.borrowAssetStrategy = noYieldAddress;
        requestData.collateralAsset = address(collateralAsset);
        requestData.collateralStrategy = noYieldAddress;
        requestData.requestAsLender = false;

        // Adding addresses to array
        userList.push(address(admin));
        userList.push(address(borrower));
        userList.push(address(lender));
        userList.push(address(liquidator));
    }

    //----------------------- REQUESTED stage, failing tests -----------------------//

    // Cannot deposit collateral to credit line in REQUESTED stage
    function test_requested_depositCollateral() public {
        // Request a credit line
        uint256 creditLineId = borrower.createRequest(address(cl), requestData);
        // Checking variable updates
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // _fromSavingsAccount = true
        savingsAccount_depositHelper(address(borrower), address(collateralAsset), requestData.collateralStrategy, amount);
        // deposit collateral to the credit line
        try borrower.addCollateral(creditLineAddress, creditLineId, amount, true) {
            revert('REVERT: Cannot add collateral to requested credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:DC2');
        }

        // _fromSavingsAccount = false
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(creditLineAddress, address(collateralAsset), amount);
        // deposit collateral to the credit line
        try borrower.addCollateral(creditLineAddress, creditLineId, amount, false) {
            revert('REVERT: Cannot add collateral to requested credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:DC2');
        }
    }

    // Cannot withdraw collateral from credit line in REQUESTED stage
    function test_requested_withdrawCollateral() public {
        // Request a credit line
        uint256 creditLineId = borrower.createRequest(address(cl), requestData);
        // Checking variable updates
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // withdraw collateral from the credit line

        // _toSavingsAccount = true
        try borrower.withdrawCollateral(creditLineAddress, creditLineId, amount, true) {
            revert('REVERT: Cannot withdraw collateral from requested credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:WC2');
        }

        // _toSavingsAccount = false
        try borrower.withdrawCollateral(creditLineAddress, creditLineId, amount, false) {
            revert('REVERT: Cannot withdraw collateral from requested credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:WC2');
        }
    }

    // Cannot withdraw all collateral from credit line in REQUESTED stage
    function test_requested_withdrawAllCollateral() public {
        // Request a credit line
        uint256 creditLineId = borrower.createRequest(address(cl), requestData);
        // Checking variable updates
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        // withdraw all collateral from the credit line

        // _toSavingsAccount = true
        try borrower.withdrawAllCollateral(creditLineAddress, creditLineId, true) {
            revert('REVERT: Cannot withdraw collateral from requested credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:WAC1');
        }

        // _toSavingsAccount = false
        try borrower.withdrawAllCollateral(creditLineAddress, creditLineId, false) {
            revert('REVERT: Cannot withdraw collateral from requested credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:WAC1');
        }
    }

    // Cannot borrow from credit line in REQUESTED stage
    function test_requested_borrow() public {
        // Request a credit line
        uint256 creditLineId = borrower.createRequest(address(cl), requestData);
        // Checking variable updates
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        uint256 amount = 1_000 * ERC20(address(borrowAsset)).decimals();

        // borrow from the credit line
        try borrower.borrow(creditLineAddress, creditLineId, amount) {
            revert('REVERT: Cannot borrow from requested credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:CBA1');
        }
    }

    // Cannot repay from credit line in REQUESTED stage
    function test_requested_repay() public {
        // Request a credit line
        uint256 creditLineId = borrower.createRequest(address(cl), requestData);
        // Checking variable updates
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        uint256 amount = 1_000 * ERC20(address(borrowAsset)).decimals();

        // repay the credit line
        try borrower.repay(creditLineAddress, creditLineId, amount) {
            revert('REVERT: Cannot repay requested credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:REP2');
        }
    }

    // Cannot liquidate credit line in REQUESTED stage
    function test_requested_liquidate() public {
        // Request a credit line
        uint256 creditLineId = borrower.createRequest(address(cl), requestData);
        // Checking variable updates
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        // liquidate the credit line

        // _toSavingsAccount = true
        try lender.liquidate(creditLineAddress, creditLineId, true) {
            revert('REVERT: Cannot liquidate requested credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:L1');
        }

        // _toSavingsAccount = false
        try lender.liquidate(creditLineAddress, creditLineId, false) {
            revert('REVERT: Cannot liquidate requested credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:L1');
        }
    }

    // Cannot close credit line in REQUESTED stage
    function test_requested_close() public {
        // Request a credit line
        uint256 creditLineId = borrower.createRequest(address(cl), requestData);
        // Checking variable updates
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        try borrower.close(creditLineAddress, creditLineId) {
            revert('REVERT: Cannot close requested credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:C1');
        }
    }

    //----------------------- Credit line Request, failing tests -----------------------//

    // Requesting creditline with collateral ratio above limits should fail
    function test_RequestInvalidCollateralRatio() public {
        requestData.collateralRatio = CLConstants.maxCollteralRatio + 1;

        try borrower.createRequest(address(cl), requestData) {
            revert('REVERT: Cannot request for invalid collateral ratio limits');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:R5');
        }
    }

    // Requesting creditline with borrow limit outside of limits should fail
    function test_RequestInvalidBorrowLimit() public {
        requestData.borrowLimit = 1;

        try borrower.createRequest(address(cl), requestData) {
            revert('REVERT: Cannot request for invalid borrow limit limits');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:ILB1');
        }
    }

    // Requesting creditline with borrow rate above limits should fail
    function test_RequestInvalidBorrowRate() public {
        requestData.borrowRate = CLConstants.maxBorrowRate + 1;

        try borrower.createRequest(address(cl), requestData) {
            revert('REVERT: Cannot request for invalid borrow rate limits');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:R4');
        }
    }

    // Requesting creditline as borrower with same Lender and Borrower address should fail
    function test_RequestAsBorrower_sameAddresses() public {
        requestData.requestTo = address(borrower);

        try borrower.createRequest(address(cl), requestData) {
            revert('REVERT: Cannot request when borrower == lender');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:R8');
        }
    }

    // Requesting creditline as lender with same Lender and Borrower address should fail
    function test_RequestAsLender_sameAddresses() public {
        requestData.requestAsLender = true;

        try lender.createRequest(address(cl), requestData) {
            revert('REVERT: Cannot request when borrower == lender');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:R8');
        }
    }

    // Requesting creditline with lender as address(0) should fail
    function test_RequestZeroAddressLender() public {
        requestData.requestTo = address(0);

        try borrower.createRequest(address(cl), requestData) {
            revert('REVERT: Cannot request when lender == address(0)');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:R2');
        }
    }

    // Requesting creditline with borrower as address(0) should fail
    function test_RequestZeroAddressBorrower() public {
        requestData.requestTo = address(0);
        requestData.requestAsLender = true;

        try lender.createRequest(address(cl), requestData) {
            revert('REVERT: Cannot request when borrower == address(0)');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:R2');
        }
    }

    // Requesting creditline with borrow asset strategy as address(0) should fail
    function test_RequestZeroBorrowAssetStrategy() public {
        requestData.borrowAssetStrategy = address(0);

        try borrower.createRequest(address(cl), requestData) {
            revert('REVERT: Cannot request when borrow asset strategy == address(0)');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:R6');
        }
    }

    // Requesting creditline with collateral strategy as address(0) should fail
    function test_RequestZeroCollateralStrategy() public {
        requestData.collateralStrategy = address(0);

        try borrower.createRequest(address(cl), requestData) {
            revert('REVERT: Cannot request when collateral strategy == address(0)');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:R7');
        }
    }

    // Requesting creditline with invalid tokens (not supported) should fail
    function test_RequestInvalidTokens() public {
        requestData.collateralAsset = CLConstants.BAT;

        try borrower.createRequest(address(cl), requestData) {
            revert('REVERT: Cannot request for invalid tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:R3');
        }
    }

    // Requesting creditline with same borrow and collateral tokens should fail
    function test_RequestSameTokens() public {
        requestData.collateralAsset = requestData.borrowAsset;

        try borrower.createRequest(address(cl), requestData) {
            revert('REVERT: Cannot request when borrow asset == collateral asset');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:R1');
        }
    }

    //----------------------- Credit line Request, passing tests -----------------------//

    // Requesting creditline as borrower should pass
    function test_RequestAsBorrower_FuzzWithLimits(
        address _requestTo,
        uint128 _borrowLimit,
        uint128 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio
    ) public {
        requestData.requestTo = _requestTo;
        requestData.borrowLimit = _borrowLimit;
        requestData.borrowRate = _borrowRate;
        requestData.autoLiquidation = _autoLiquidation;
        requestData.collateralRatio = _collateralRatio;

        try borrower.createRequest(address(cl), requestData) {
            assert_creditlineConstantsAndStatus(1, address(borrower), requestData);
        } catch Error(string memory reason) {
            if (compareStrings(reason, 'CL:R2')) {
                log_string('Lender is address(0)');
            } else if (compareStrings(reason, 'CL:ILB1')) {
                log_string('Invalid Borrow limits in terms of USD');
            } else if (compareStrings(reason, 'CL:R4')) {
                log_string('Invalid borrow rate limits');
            } else if (compareStrings(reason, 'CL:R5')) {
                log_string('Invalid collateral ratio limits');
            } else {
                revert(reason);
            }
        }
    }

    // Requesting creditline as lender should pass
    function test_RequestAsLender_FuzzWithLimits(
        address _requestTo,
        uint128 _borrowLimit,
        uint128 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio
    ) public {
        requestData.requestTo = _requestTo;
        requestData.borrowLimit = _borrowLimit;
        requestData.borrowRate = _borrowRate;
        requestData.autoLiquidation = _autoLiquidation;
        requestData.collateralRatio = _collateralRatio;
        requestData.requestAsLender = true;

        try lender.createRequest(address(cl), requestData) {
            assert_creditlineConstantsAndStatus(1, address(lender), requestData);
        } catch Error(string memory reason) {
            if (compareStrings(reason, 'CL:R2')) {
                log_string('Borrower is address(0)');
            } else if (compareStrings(reason, 'CL:ILB1')) {
                log_string('Invalid Borrow limits in terms of USD');
            } else if (compareStrings(reason, 'CL:R4')) {
                log_string('Invalid borrow rate limits');
            } else if (compareStrings(reason, 'CL:R5')) {
                log_string('Invalid collateral ratio limits');
            } else {
                revert(reason);
            }
        }
    }

    // Requesting creditline as borrower should pass
    function test_RequestAsBorrower_FuzzNoLimits(
        address _requestTo,
        uint128 _borrowLimit,
        uint128 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio
    ) public {
        admin.updateBorrowLimitLimits(0, type(uint256).max, address(cl));
        admin.updateIdealCollateralRatioLimits(0, type(uint256).max, address(cl));
        admin.updateBorrowRateLimits(0, type(uint256).max, address(cl));

        requestData.requestTo = _requestTo;
        requestData.borrowLimit = _borrowLimit;
        requestData.borrowRate = _borrowRate;
        requestData.autoLiquidation = _autoLiquidation;
        requestData.collateralRatio = _collateralRatio;

        try borrower.createRequest(address(cl), requestData) {
            assert_creditlineConstantsAndStatus(1, address(borrower), requestData);
        } catch Error(string memory reason) {
            if (compareStrings(reason, 'CL:R2')) {
                log_string('Lender is address(0)');
            } else if (compareStrings(reason, 'CL:R8')) {
                log_string('Borrower == Lender');
            } else {
                revert(reason);
            }
        }
    }

    // Requesting creditline as lender should pass
    function test_RequestAsLender_FuzzNoLimits(
        address _requestTo,
        uint128 _borrowLimit,
        uint128 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio
    ) public {
        admin.updateBorrowLimitLimits(0, type(uint256).max, address(cl));
        admin.updateIdealCollateralRatioLimits(0, type(uint256).max, address(cl));
        admin.updateBorrowRateLimits(0, type(uint256).max, address(cl));

        requestData.requestTo = _requestTo;
        requestData.borrowLimit = _borrowLimit;
        requestData.borrowRate = _borrowRate;
        requestData.autoLiquidation = _autoLiquidation;
        requestData.collateralRatio = _collateralRatio;
        requestData.requestAsLender = true;

        try lender.createRequest(address(cl), requestData) {
            assert_creditlineConstantsAndStatus(1, address(lender), requestData);
        } catch Error(string memory reason) {
            if (compareStrings(reason, 'CL:R2')) {
                log_string('Borrower is address(0)');
            } else if (compareStrings(reason, 'CL:R8')) {
                log_string('Borrower == Lender');
            } else {
                revert(reason);
            }
        }
    }

    //----------------------- Credit line Accept, failing tests -----------------------//

    // Accepting creditline with invalid actor (NOT Lender) should fail
    function test_AcceptInvalidAcceptor_RequestedAsBorrower() public {
        // Request a credit line
        uint256 creditLineId = borrower.createRequest(address(cl), requestData);
        // Checking variable updates
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        // Testing the function for all the different actors
        for (uint256 i = 0; i < userList.length; i++) {
            if (i == 0) {
                CLAdmin user = CLAdmin(userList[i]);

                try user.acceptRequest(address(cl), creditLineId) {
                    revert('REVERT: Invalid actor cannot accept');
                } catch Error(string memory reason) {
                    assertEq(reason, 'CL:A2');
                }
            } else {
                CLUser user = CLUser(userList[i]);

                if (userList[i] != requestData.requestTo) {
                    try user.acceptRequest(address(cl), creditLineId) {
                        revert('REVERT: Invalid actor cannot accept');
                    } catch Error(string memory reason) {
                        assertEq(reason, 'CL:A2');
                    }
                }
            }
        }
    }

    // Accepting creditline with invalid actor (NOT Borrower) should fail
    function test_AcceptInvalidAcceptor_RequestedAsLender() public {
        requestData.requestAsLender = true;

        // Request a credit line
        uint256 creditLineId = borrower.createRequest(address(cl), requestData);
        // Checking variable updates
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        // Testing the function for all the different actors
        for (uint256 i = 0; i < userList.length; i++) {
            if (i == 0) {
                CLAdmin user = CLAdmin(userList[i]);

                try user.acceptRequest(address(cl), creditLineId) {
                    revert('REVERT: Invalid actor cannot accept');
                } catch Error(string memory reason) {
                    assertEq(reason, 'CL:A2');
                }
            } else {
                CLUser user = CLUser(userList[i]);

                if (userList[i] != requestData.requestTo) {
                    try user.acceptRequest(address(cl), creditLineId) {
                        revert('REVERT: Invalid actor cannot accept');
                    } catch Error(string memory reason) {
                        assertEq(reason, 'CL:A2');
                    }
                }
            }
        }
    }

    // Accepting creditline with invalid creditline (NOT Requested) should fail
    function test_AcceptInvalidCreditLine() public {
        try borrower.acceptRequest(address(cl), 2) {
            revert('REVERT: Cannot accept invalid creditline');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:A1');
        }
    }

    //----------------------- Credit line Accept, passing tests -----------------------//

    // Accepting creditline as a lender should pass
    function test_Accept_AsLender() public {
        CLUser user = new CLUser();

        for (uint256 i = 0; i < userList.length; i++) {
            if (i == 0) {
                CLAdmin newUser = CLAdmin(userList[i]);
                requestData.requestTo = address(newUser);

                uint256 creditLineId = user.createRequest(address(cl), requestData);
                assert_creditlineConstantsAndStatus(creditLineId, address(user), requestData);
                newUser.acceptRequest(address(cl), creditLineId);

                uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
                assertEq(status, 2); // Checking if creditLine status is updated to ACTIVE
            } else {
                CLUser newUser = CLUser(userList[i]);
                requestData.requestTo = address(newUser);

                uint256 creditLineId = user.createRequest(address(cl), requestData);
                assert_creditlineConstantsAndStatus(creditLineId, address(user), requestData);
                newUser.acceptRequest(address(cl), creditLineId);

                uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
                assertEq(status, 2); // Checking if creditLine status is updated to ACTIVE
            }
        }
    }

    // Accepting creditline as a borrower should pass
    function test_Accept_AsBorrower() public {
        CLUser user = new CLUser();
        requestData.requestAsLender = true;

        for (uint256 i = 0; i < userList.length; i++) {
            if (i == 0) {
                CLAdmin newUser = CLAdmin(userList[i]);
                requestData.requestTo = address(newUser);

                uint256 creditLineId = user.createRequest(address(cl), requestData);
                assert_creditlineConstantsAndStatus(creditLineId, address(user), requestData);
                newUser.acceptRequest(address(cl), creditLineId);

                uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
                assertEq(status, 2); // Checking if creditLine status is updated to ACTIVE
            } else {
                CLUser newUser = CLUser(userList[i]);
                requestData.requestTo = address(newUser);

                uint256 creditLineId = user.createRequest(address(cl), requestData);
                assert_creditlineConstantsAndStatus(creditLineId, address(user), requestData);
                newUser.acceptRequest(address(cl), creditLineId);

                uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
                assertEq(status, 2); // Checking if creditLine status is updated to ACTIVE
            }
        }
    }

    //----------------------- Credit line Cancel, failing tests -----------------------//

    // Invalid actor (other than borrower and lender) should not be able to cancel the credit line
    function test_CancelInvalidActor() public {
        // Request a credit line
        uint256 creditLineId = borrower.createRequest(address(cl), requestData);
        // Checking variable updates
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        for (uint256 i = 0; i < userList.length; i++) {
            if (i == 0) {
                CLAdmin user = CLAdmin(userList[i]);

                try user.cancelRequest(address(cl), creditLineId) {
                    revert('REVERT: Invalid actor cannot cancel');
                } catch Error(string memory reason) {
                    assertEq(reason, 'CL:CP2');
                }
            } else {
                CLUser user = CLUser(userList[i]);

                if (!(userList[i] == address(lender) || userList[i] == address(borrower))) {
                    try user.cancelRequest(address(cl), creditLineId) {
                        revert('REVERT: Invalid actor cannot cancel');
                    } catch Error(string memory reason) {
                        assertEq(reason, 'CL:CP2');
                    }
                }
            }
        }
    }

    // ACTIVE creditline cannot be cancelled
    function test_CancelInvalidStatus() public {
        // Request a credit line
        uint256 creditLineId = borrower.createRequest(address(cl), requestData);
        // Checking variable updates
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        lender.acceptRequest(address(cl), creditLineId);

        uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
        assertEq(status, 2); // Checking if creditLine status is updated to ACTIVE

        try borrower.cancelRequest(address(cl), creditLineId) {
            revert('REVERT: Cannot cancel invalid creditline');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:CP1');
        }
    }

    //----------------------- Credit line Cancel, passing tests -----------------------//

    // Borrower should be able to cancel creditline
    function test_creditLineCancel_asBorrower() public {
        // Request a credit line
        uint256 creditLineId = borrower.createRequest(address(cl), requestData);
        // Checking variable updates
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        borrower.cancelRequest(address(cl), creditLineId);

        uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
        assertEq(status, 0); // Checking if creditLine status is updated to NOT_CREATED
    }

    // Lender should be able to cancel creditline
    function test_creditLineCancel_asLender() public {
        // Request a credit line
        uint256 creditLineId = borrower.createRequest(address(cl), requestData);
        // Checking variable updates
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        lender.cancelRequest(address(cl), creditLineId);

        uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
        assertEq(status, 0); // Checking if creditLine status is updated to NOT_CREATED
    }

    //----------------------- Credit line updateBorrowLimit, failing tests -----------------------//

    // Cannot update borrow limit to newLimit<minBorrowlimit
    function test_updateBorrowLimit_LTLimits() public {
        // Request a credit line
        uint256 creditLineId = borrower.createRequest(address(cl), requestData);
        // Checking variable updates
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        try lender.updateBorrowLimit(creditLineAddress, creditLineId, CLConstants.minBorrowLimit - 1) {
            revert('REVERT: Cannot update borrow limit to values less than accepted range');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:ILB1');
        }
    }

    // Cannot update borrow limit to newLimit>maxBorrowlimit
    function test_updateBorrowLimit_GTLimits() public {
        // Request a credit line
        uint256 creditLineId = borrower.createRequest(address(cl), requestData);
        // Checking variable updates
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        try lender.updateBorrowLimit(creditLineAddress, creditLineId, CLConstants.maxBorrowLimit * 100) {
            revert('REVERT: Cannot update borrow limit to values greater than accepted range');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:ILB1');
        }
    }

    // Invalid actor cannot update borrow limit
    function test_updateBorrowLimit_anyAddress() public {
        // Request a credit line
        uint256 creditLineId = borrower.createRequest(address(cl), requestData);
        // Checking variable updates
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        for (uint256 i = 0; i < userList.length; i++) {
            if (i == 0) {
                CLAdmin user = CLAdmin(userList[i]);

                try user.updateBorrowLimit(creditLineAddress, creditLineId, CLConstants.maxBorrowLimit - 10) {
                    revert('REVERT: Invalid actor cannot update borrow limit');
                } catch Error(string memory reason) {
                    assertEq(reason, 'CL:OCLL1');
                }
            } else {
                CLUser user = CLUser(userList[i]);

                if (userList[i] != address(lender)) {
                    try user.updateBorrowLimit(creditLineAddress, creditLineId, CLConstants.maxBorrowLimit - 10) {
                        revert('REVERT: Invalid actor cannot update borrow limit');
                    } catch Error(string memory reason) {
                        assertEq(reason, 'CL:OCLL1');
                    }
                }
            }
        }
    }

    //----------------------- Credit line updateBorrowLimit, passing tests -----------------------//

    // Cannot update borrow limit function in REQUESTED stage
    function test_requested_updateBorrowLimit(uint128 _newBorrowLimit) public {
        uint128 newBorrowLimit = scaleToRange128(_newBorrowLimit, 1, type(uint128).max);

        // Request a credit line
        uint256 creditLineId = borrower.createRequest(address(cl), requestData);
        // Checking variable updates
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        try lender.updateBorrowLimit(creditLineAddress, creditLineId, newBorrowLimit) {
            assert_creditlineBorrowLimit(creditLineId, newBorrowLimit);
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:ILB1');
        }
    }

    //----------------------- Assert helper functions -----------------------//

    function assert_creditlineConstantsAndStatus(
        uint256 _creditLineId,
        address _requestBy,
        CLConstants.RequestParams memory requestData
    ) public {
        getCreditlineConstants(_creditLineId);

        if (requestData.requestAsLender) {
            assertEq(constantsCheck.lender, _requestBy);
            assertEq(constantsCheck.borrower, requestData.requestTo);
        } else {
            assertEq(constantsCheck.lender, requestData.requestTo);
            assertEq(constantsCheck.borrower, _requestBy);
        }

        assertEq(constantsCheck.borrowLimit, requestData.borrowLimit);
        assertEq(constantsCheck.idealCollateralRatio, requestData.collateralRatio);
        assertEq(constantsCheck.borrowRate, requestData.borrowRate);
        assertEq(constantsCheck.borrowAsset, requestData.borrowAsset);
        assertEq(constantsCheck.collateralAsset, requestData.collateralAsset);
        assertEq(constantsCheck.collateralStrategy, requestData.collateralStrategy);

        uint256 status = uint256(cl.getCreditLineStatus(_creditLineId));
        assertEq(status, 1); // Checking if creditLine status is updated to REQUESTED
    }

    function assert_creditlineBorrowLimit(uint256 _creditLineId, uint256 _newBorrowLimit) public {
        getCreditlineConstants(_creditLineId);

        assertEq(constantsCheck.borrowLimit, _newBorrowLimit);
    }
}",6693
RealWorld_TA_101_SavingsAccount_RealWorld_20240812172829.log,101,SavingsAccount,413628,5418,419046,165.0,2.1765,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '../interfaces/ISavingsAccount.sol';
import '../interfaces/IStrategyRegistry.sol';
import '../interfaces/IYield.sol';

/**
 * @title Savings account contract with Methods related to savings account
 * @notice Implements the functions related to savings account
 * @author Sublime
 **/
contract SavingsAccount is ISavingsAccount, Initializable, OwnableUpgradeable, ReentrancyGuardUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    //-------------------------------- Constants start --------------------------------/

    /**
     * @notice instance of the strategy registry used to whitelist strategies
     */
    IStrategyRegistry public immutable STRATEGY_REGISTRY;

    //-------------------------------- Constants end --------------------------------/

    //-------------------------------- State vars start --------------------------------/

    /**
     * @notice mapping from user to token to strategy to balance of shares
     * @dev user -> token -> strategy (underlying address) -> amount (shares)
     */
    mapping(address => mapping(address => mapping(address => uint256))) public override balanceInShares;

    /**
     * @notice mapping from user to token to toAddress for approval to amount approved
     * @dev user => token => to => amount
     */
    mapping(address => mapping(address => mapping(address => uint256))) public override allowance;

    //-------------------------------- State vars end --------------------------------/

    //-------------------------------- Init start --------------------------------/

    /**
     * @notice constructor
     * @dev initializes the immutables
     * @param _strategyRegistry address of the strategy registry
     **/
    constructor(address _strategyRegistry) {
        require(_strategyRegistry != address(0), 'C1');
        STRATEGY_REGISTRY = IStrategyRegistry(_strategyRegistry);
    }

    /**
     * @dev initialize the contract
     * @param _owner address of the owner of the savings account contract
     **/
    function initialize(address _owner) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
    }

    //-------------------------------- Init end --------------------------------/

    //-------------------------------- Deposit start --------------------------------/

    /**
     * @notice used to deposit tokens into strategy via savings account
     * @param _amount amount of tokens deposited
     * @param _token address of token contract
     * @param _strategy address of the strategy into which tokens are to be deposited
     * @param _to address to deposit to
     * @return amount of shares deposited
     */
    function deposit(
        address _token,
        address _strategy,
        address _to,
        uint256 _amount
    ) external override nonReentrant returns (uint256) {
        require(_to != address(0), 'SA:D1');
        require(_amount != 0, 'SA:D2');
        require(STRATEGY_REGISTRY.registry(_strategy) != 0, 'SA:D3');
        require(_token != address(0), 'SA:D4');
        uint256 _sharesReceived = IYield(_strategy).lockTokens(msg.sender, _token, _amount);
        balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_sharesReceived);
        emit Deposited(_to, _sharesReceived, _token, _strategy);
        return _sharesReceived;
    }

    //-------------------------------- Deposit end --------------------------------/

    //-------------------------------- Switch Strategy start --------------------------------/

    /**
     * @dev Used to switch saving strategy of an _token
     * @param _currentStrategy initial strategy of token
     * @param _newStrategy new strategy to invest
     * @param _token address of the token
     * @param _amount amount of tokens to be reinvested
     */
    function switchStrategy(
        address _currentStrategy,
        address _newStrategy,
        address _token,
        uint256 _amount
    ) external override nonReentrant {
        require(_currentStrategy != _newStrategy, 'SA:SS1');
        require(STRATEGY_REGISTRY.registry(_newStrategy) != 0, 'SA:SS2');
        require(STRATEGY_REGISTRY.isValidStrategy(_currentStrategy), 'SA:SS3');
        require(_amount != 0, 'SA:SS4');

        IYield currentStrategy = IYield(_currentStrategy);
        _amount = currentStrategy.getSharesForTokens(_amount, _token);

        // TODO use trySub - as mentioned in SafeMath library
        balanceInShares[msg.sender][_token][_currentStrategy] = balanceInShares[msg.sender][_token][_currentStrategy].sub(
            _amount,
            'SA:SS5'
        );

        uint256 _tokensReceived = currentStrategy.unlockTokens(_token, address(this), _amount);

        IERC20(_token).safeApprove(_newStrategy, _tokensReceived);

        uint256 _sharesReceived = IYield(_newStrategy).lockTokens(address(this), _token, _tokensReceived);

        balanceInShares[msg.sender][_token][_newStrategy] = balanceInShares[msg.sender][_token][_newStrategy].add(_sharesReceived);
        emit StrategySwitched(msg.sender, _token, _amount, _sharesReceived, _currentStrategy, _newStrategy);
    }

    //-------------------------------- Switch Strategy end --------------------------------/

    //-------------------------------- Allowance start --------------------------------/

    /**
     * @notice used to approve allowance to an address
     * @dev this is prone to race condition, hence increaseAllowance is recommended
     * @param _amount amount of tokens approved
     * @param _token address of token approved
     * @param _to address of the user approved to
     */
    function approve(
        address _token,
        address _to,
        uint256 _amount
    ) external override {
        require(msg.sender != _to, 'SA:A1');
        allowance[msg.sender][_token][_to] = _amount;

        emit Approved(_token, msg.sender, _to, _amount);
    }

    /**
     * @notice used to increase allowance to an address
     * @param _amount amount of tokens allowance is increased by
     * @param _token address of token approved
     * @param _to address of the address approved to
     */
    function increaseAllowance(
        address _token,
        address _to,
        uint256 _amount
    ) external override {
        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].add(_amount);
        allowance[msg.sender][_token][_to] = _updatedAllowance;

        emit Approved(_token, msg.sender, _to, _updatedAllowance);
    }

    /**
     * @notice used to decrease allowance to an address
     * @param _amount amount of tokens allowance is decreased by
     * @param _token address of token approved
     * @param _to address of the user approved to
     */
    function decreaseAllowance(
        address _token,
        address _to,
        uint256 _amount
    ) external override {
        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].sub(_amount, 'SA:DA1');
        allowance[msg.sender][_token][_to] = _updatedAllowance;

        emit Approved(_token, msg.sender, _to, _updatedAllowance);
    }

    //-------------------------------- Allowance ends --------------------------------/

    //-------------------------------- Transfer start --------------------------------/

    /**
     * @notice used to transfer tokens
     * @param _amount amount of tokens transferred
     * @param _token address of token transferred
     * @param _strategy address of the strategy from which tokens are transferred
     * @param _to address of the user tokens are transferred to
     * @return amount of shares transferred
     */
    function transfer(
        address _token,
        address _strategy,
        address _to,
        uint256 _amount
    ) external override returns (uint256) {
        require(_amount != 0, 'SA:T1');
        require(_to != address(0), 'SA:T2');
        require(STRATEGY_REGISTRY.registry(_strategy) != 0, 'SA:T3');

        uint256 _shares = IYield(_strategy).getSharesForTokens(_amount, _token);

        _transfer(_token, _strategy, msg.sender, _to, _shares);

        return _shares;
    }

    /**
     * @notice used to transfer tokens
     * @param _shares shares of tokens transferred
     * @param _token address of token transferred
     * @param _strategy address of the strategy from which tokens are transferred
     * @param _to address of the user tokens are transferred to
     * @return amount of shares transferred
     */
    function transferShares(
        address _token,
        address _strategy,
        address _to,
        uint256 _shares
    ) external override returns (uint256) {
        require(_shares != 0, 'SA:TS1');
        require(_to != address(0), 'SA:TS2');
        require(STRATEGY_REGISTRY.registry(_strategy) != 0, 'SA:TS3');

        _transfer(_token, _strategy, msg.sender, _to, _shares);

        return _shares;
    }

    /**
     * @notice used to transfer tokens from allowance by another address
     * @param _amount amount of tokens transferred
     * @param _token address of token transferred
     * @param _strategy address of the strategy from which tokens are transferred
     * @param _from address from whose allowance tokens are transferred
     * @param _to address of the user tokens are transferred to
     * @return the amount of tokens in terms of LP tokens of _token in _strategy strategy of
     *         savingsAccount that will be transferred from the _from address to the _to address
     */
    function transferFrom(
        address _token,
        address _strategy,
        address _from,
        address _to,
        uint256 _amount
    ) external override returns (uint256) {
        require(_amount != 0, 'SA:TF1');
        require(_from != address(0), 'SA:TF2');
        require(_to != address(0), 'SA:TF3');
        require(STRATEGY_REGISTRY.registry(_strategy) != 0, 'SA:TF4');

        //update allowance
        _spendAllowance(_token, _from, msg.sender, _amount);

        uint256 _shares = IYield(_strategy).getSharesForTokens(_amount, _token);

        _transfer(_token, _strategy, _from, _to, _shares);

        return _shares;
    }

    /**
     * @notice used to transfer tokens from allowance by another address
     * @param _shares shares of tokens transferred
     * @param _token address of token transferred
     * @param _strategy address of the strategy from which tokens are transferred
     * @param _from address from whose allowance tokens are transferred
     * @param _to address of the user tokens are transferred to
     * @return number of shares transferred
     */
    function transferSharesFrom(
        address _token,
        address _strategy,
        address _from,
        address _to,
        uint256 _shares
    ) external override returns (uint256) {
        require(_shares != 0, 'SA:TFS1');
        require(_from != address(0), 'SA:TFS2');
        require(_to != address(0), 'SA:TFS3');
        require(STRATEGY_REGISTRY.registry(_strategy) != 0, 'SA:TFS4');

        uint256 _amount = IYield(_strategy).getTokensForShares(_shares, _token);

        _spendAllowance(_token, _from, msg.sender, _amount);

        _transfer(_token, _strategy, _from, _to, _shares);

        return _shares;
    }

    function _transfer(
        address _token,
        address _strategy,
        address _from,
        address _to,
        uint256 _shares
    ) private {
        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(_shares, 'SA:IT1');

        balanceInShares[_to][_token][_strategy] = (balanceInShares[_to][_token][_strategy]).add(_shares);

        emit Transfer(_token, _strategy, _from, _to, _shares);
    }

    function _spendAllowance(
        address _token,
        address _from,
        address _spender,
        uint256 _amount
    ) private {
        uint256 _currentAllowance = allowance[_from][_token][_spender];
        if (_currentAllowance != type(uint256).max) {
            allowance[_from][_token][_spender] = _currentAllowance.sub(_amount, 'SA:ISA1');
        }
    }

    //-------------------------------- Transfer end --------------------------------/

    //-------------------------------- Withdraw start --------------------------------/

    /**
     * @dev Used to withdraw token from Saving Account
     * @param _to address to which token should be sent
     * @param _amount amount of tokens to withdraw
     * @param _token address of the token to be withdrawn
     * @param _strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)
     * @param _receiveShares boolean indicating to withdraw in liquidity share or underlying token
     * @return amount of tokens received from withdrawal
     */
    function withdraw(
        address _token,
        address _strategy,
        address _to,
        uint256 _amount,
        bool _receiveShares
    ) external override nonReentrant returns (uint256) {
        require(_amount != 0, 'SA:W1');
        require(_to != address(0), 'SA:W2');
        require(STRATEGY_REGISTRY.isValidStrategy(_strategy), 'SA:W3');

        uint256 _shares = IYield(_strategy).getSharesForTokens(_amount, _token);

        uint256 _amountReceived = _withdraw(_token, _strategy, msg.sender, _to, _shares, _receiveShares);

        return _amountReceived;
    }

    /**
     * @dev Used to withdraw token from Saving Account
     * @param _to address to which token should be sent
     * @param _shares amount of shares to withdraw
     * @param _token address of the token to be withdrawn
     * @param _strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)
     * @param _receiveShares boolean indicating to withdraw in liquidity share or underlying token
     * @return amount of tokens received from withdrawal
     */
    function withdrawShares(
        address _token,
        address _strategy,
        address _to,
        uint256 _shares,
        bool _receiveShares
    ) external override nonReentrant returns (uint256) {
        require(_shares != 0, 'SA:WS1');
        require(_to != address(0), 'SA:WS2');
        require(STRATEGY_REGISTRY.isValidStrategy(_strategy), 'SA:WS3');

        uint256 _amountReceived = _withdraw(_token, _strategy, msg.sender, _to, _shares, _receiveShares);

        return _amountReceived;
    }

    /**
     * @dev Used to withdraw token from allowance of Saving Account
     * @param _from address from which tokens will be withdrawn
     * @param _to address to which token should be withdrawn
     * @param _amount amount of tokens to withdraw
     * @param _token address of the token to be withdrawn
     * @param _strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)
     * @param _receiveShares boolean indicating to withdraw in liquidity share or underlying token
     * @return amount of tokens received from withdrawal
     */

    function withdrawFrom(
        address _token,
        address _strategy,
        address _from,
        address _to,
        uint256 _amount,
        bool _receiveShares
    ) external override nonReentrant returns (uint256) {
        require(_amount != 0, 'SA:WF1');
        require(_from != address(0), 'SA:WF2');
        require(_to != address(0), 'SA:WF3');
        require(STRATEGY_REGISTRY.isValidStrategy(_strategy), 'SA:WF4');

        _spendAllowance(_token, _from, msg.sender, _amount);

        uint256 _shares = IYield(_strategy).getSharesForTokens(_amount, _token);

        uint256 _amountReceived = _withdraw(_token, _strategy, _from, _to, _shares, _receiveShares);
        return _amountReceived;
    }

    /**
     * @dev Used to withdraw token from allowance of Saving Account
     * @param _to address to which token should be withdrawn
     * @param _shares amount of shares to withdraw
     * @param _token address of the token to be withdrawn
     * @param _strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)
     * @param _receiveShares boolean indicating to withdraw in liquidity share or underlying token
     * @return amount of tokens received from withdrawal
     */
    function withdrawSharesFrom(
        address _token,
        address _strategy,
        address _from,
        address _to,
        uint256 _shares,
        bool _receiveShares
    ) external override nonReentrant returns (uint256) {
        require(_shares != 0, 'SA:WSF1');
        require(_from != address(0), 'SA:WSF2');
        require(_to != address(0), 'SA:WSF3');
        require(STRATEGY_REGISTRY.isValidStrategy(_strategy), 'SA:WSF4');

        uint256 _amount = IYield(_strategy).getTokensForShares(_shares, _token);

        _spendAllowance(_token, _from, msg.sender, _amount);

        uint256 _amountReceived = _withdraw(_token, _strategy, _from, _to, _shares, _receiveShares);
        return _amountReceived;
    }

    function _withdraw(
        address _token,
        address _strategy,
        address _from,
        address _to,
        uint256 _shares,
        bool _receiveShares
    ) private returns (uint256) {
        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(_shares, 'SA:IW1');
        uint256 _amountReceived;
        IYield _strategyContract = IYield(_strategy);
        if (_receiveShares) {
            address _sharesToken = _strategyContract.liquidityToken(_token);
            require(_sharesToken != address(0), 'SA:IW2');
            _amountReceived = _strategyContract.unlockShares(_sharesToken, _to, _shares);
        } else {
            _amountReceived = _strategyContract.unlockTokens(_token, _to, _shares);
        }
        emit Withdrawn(_from, _to, _shares, _token, _strategy, _receiveShares);
        return _amountReceived;
    }

    /**
     * @notice used to withdraw a token from all strategies
     * @param _token address of token which is to be withdrawn
     * @return total amount of base tokens withdrawn
     */
    function withdrawAll(address _token) external override nonReentrant returns (uint256) {
        address[] memory _strategyList = STRATEGY_REGISTRY.getStrategies();
        uint256 _tokenReceived;

        for (uint256 i; i < _strategyList.length; ++i) {
            uint256 _shares = balanceInShares[msg.sender][_token][_strategyList[i]];
            if (_shares == 0) continue;

            delete balanceInShares[msg.sender][_token][_strategyList[i]];
            uint256 _amount = IYield(_strategyList[i]).unlockTokens(_token, msg.sender, _shares);
            _tokenReceived = _tokenReceived.add(_amount);
        }

        if (_tokenReceived == 0) return 0;

        emit WithdrawnAll(msg.sender, _tokenReceived, _token);

        return _tokenReceived;
    }

    /**
     * @notice used to withdraw a token from specific strategies
     * @param _token address of token which is to be withdrawn
     * @param _strategy strategy from which tokens are withdrawn
     * @return total amount of base tokens withdrawn
     */
    function withdrawAll(address _token, address _strategy) external override nonReentrant returns (uint256) {
        require(STRATEGY_REGISTRY.isValidStrategy(_strategy), 'SA:WA1');
        uint256 _sharesBalance = balanceInShares[msg.sender][_token][_strategy];

        if (_sharesBalance == 0) return 0;

        delete balanceInShares[msg.sender][_token][_strategy];

        uint256 _amount = IYield(_strategy).unlockTokens(_token, msg.sender, _sharesBalance);

        emit Withdrawn(msg.sender, msg.sender, _amount, _token, _strategy, false);

        return _amount;
    }

    //-------------------------------- Withdraw end --------------------------------/

    //-------------------------------- Getter start --------------------------------/

    /**
     * @notice used to query total tokens of a token with a user
     * @param _user address of the user
     * @param _token address of token
     * @return _totalTokens total number of tokens of the token with the user
     */
    function getTotalTokens(address _user, address _token) external override returns (uint256) {
        address[] memory _strategyList = STRATEGY_REGISTRY.getStrategies();
        uint256 _totalTokens;

        for (uint256 i; i < _strategyList.length; ++i) {
            uint256 _liquidityShares = balanceInShares[_user][_token][_strategyList[i]];
            if (_liquidityShares != 0) {
                uint256 _liquidityTokens = IYield(_strategyList[i]).getTokensForShares(_liquidityShares, _token);
                _totalTokens = _totalTokens.add(_liquidityTokens);
            }
        }
        return _totalTokens;
    }

    //-------------------------------- Getter end --------------------------------/
}",4680
RealWorld_TA_101_IRepayment_RealWorld_20240812182441.log,101,IRepayment,66058,1349,67407,69.0,0.35727,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma experimental ABIEncoderV2;

interface IRepayment {
    /// @notice Event emitted when interest for the loann is partially repaid
    /// @param poolID The address of the pool to which interest was paid
    /// @param repayAmount Amount being repayed
    event InterestRepaid(address indexed poolID, uint256 repayAmount);

    /// @notice Event emitted when all interest for the pool is repaid
    /// @param poolID The address of the pool to which interest was paid
    /// @param repayAmount Amount being repayed
    event InterestRepaymentComplete(address indexed poolID, uint256 repayAmount);

    /// @notice Event emitted when pricipal is repaid
    /// @param poolID The address of the pool to which principal was paid
    /// @param repayAmount Amount being repayed
    event PrincipalRepaid(address indexed poolID, uint256 repayAmount);

    /// @notice Event emitted when Grace penalty and interest for previous period is completely repaid
    /// @param poolID The address of the pool to which repayment was made
    /// @param repayAmount Amount being repayed
    event GracePenaltyRepaid(address indexed poolID, uint256 repayAmount);

    /// @notice Event to denote changes in the configurations of the pool factory
    /// @param poolFactory updated pool factory address
    event PoolFactoryUpdated(address indexed poolFactory);

    /// @notice Event to denote changes in the configurations of the Grace Penalty Rate
    /// @param gracePenaltyRate updated gracePenaltyRate
    event GracePenaltyRateUpdated(uint256 indexed gracePenaltyRate);

    /// @notice Event to denote changes in the configurations of the Grace Period Fraction
    /// @param gracePeriodFraction updated gracePeriodFraction
    event GracePeriodFractionUpdated(uint256 indexed gracePeriodFraction);

    function initializeRepayment(
        uint64 numberOfTotalRepayments,
        uint256 repaymentInterval,
        uint256 borrowRate,
        uint256 loanStartTime,
        address lentAsset
    ) external;

    function getTotalRepaidAmount(address poolID) external view returns (uint256 amountRepaid);

    function getInterestCalculationVars(address poolID) external view returns (uint256 loanDurationCovered, uint256 interestPerSecond);

    function getCurrentLoanInterval(address poolID) external view returns (uint256 scaledCurrentInterval);

    function didBorrowerDefault(address _poolID) external view returns (bool isBorrowerDefaulter);

    function getGracePeriodFraction() external view returns (uint256 gracePeriod);

    function getNextInstalmentDeadline(address _poolID) external view returns (uint256 nextInstalmentDeadlineTimestamp);
}",570
RealWorld_TA_101_FluxAggregator_RealWorld_20240812140252.log,101,FluxAggregator,37191,3218,40409,82.0,0.250315,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

contract FluxAggregator {
    uint256 public version = 3;
    uint8 public decimals;
    string public description;

    int256 public value = 1;
    uint80 latestRoundId = 5;

    function setValue(int256 newVal) public {
        value = newVal;
    }

    function getRoundData(uint80)
        external
        view
        returns (
            uint80,
            int256,
            uint256,
            uint256,
            uint80
        )
    {
        return (0, value, 0, 0, 0);
    }

    function latestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        return (0, value, 0, 0, 0);
    }
}",202
RealWorld_TA_101_IPooledCreditLineDeclarations_RealWorld_20240812182159.log,101,IPooledCreditLineDeclarations,97205,1943,99148,76.0,0.524885,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import './IPooledCreditLineEnums.sol';

interface IPooledCreditLineDeclarations is IPooledCreditLineEnums {
    /**
     * @notice Struct containing various parameters needed to initialize a pooled credit line
     * @param collateralRatio Ratio of collateral value to debt above which liquidations can happen
     * @param duration time for which pooled credit line will stay active
     * @param lenderVerifier verifier with which lender should be verified
     * @param defaultGracePeriod time given after duration of pooled credit line ends as grace period   
        only after which liquidations can happen
     * @param gracePenaltyRate Extra interest rate levied for repayments during grace period
     * @param collectionPeriod time for which lenders can lend to pooled credit line until borrow limit is reached
     * @param minBorrowAmount min amount of borrow tokens below which pooled credit line will be cancelled
     * @param borrowLimit Max amount of borrow tokens requested by borrower
     * @param borrowRate Interest rate at which tokens can be borrowed from pooled credit line
     * @param collateralAsset address of token which is used as collateral
     * @param borrowAssetStrategy address of strategy into which borrow tokens are deposited
     * @param collateralAssetStrategy address  of strategy into which collateral tokens are depositeds
     * @param borrowAsset address of token that is borrowed
     * @param borrowerVerifier verifier with which borrower needs to be verified
     * @param areTokensTransferable flag that represents if the pooled credit line tokens which represents 
        borrower share are transferable
     */
    struct Request {
        uint256 collateralRatio;
        uint256 duration;
        address lenderVerifier;
        uint256 defaultGracePeriod;
        uint256 gracePenaltyRate;
        uint256 collectionPeriod;
        uint256 minBorrowAmount;
        uint128 borrowLimit;
        uint128 borrowRate;
        address collateralAsset;
        address borrowAssetStrategy;
        address collateralAssetStrategy;
        address borrowAsset;
        address borrowerVerifier;
        bool areTokensTransferable;
    }

    /**
    * @notice Struct to store all the variables for a pooled credit line
    * @param status represents the status of pooled credit line
    * @param principal total principal borrowed in pooled credit line
    * @param totalInterestRepaid total interest repaid in the pooled credit line
    * @param lastPrincipalUpdateTime timestamp when principal was last updated. Principal is
             updated on borrow or repay
    * @param interestAccruedTillLastPrincipalUpdate interest accrued till last time
             principal was updated
     */
    struct PooledCreditLineVariables {
        PooledCreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    /**
    * @notice Struct to store all the constants for a pooled credit line
    * @param borrowLimit max amount of borrowAsset that can be borrowed in aggregate at any point
    * @param borrowRate Rate of interest (multiplied by SCALING_FACTOR) for eg 8.25% becomes 8.25 / 1e2 * 1e18
    * @param idealCollateralRatio ratio of collateral to debt below which collateral is
             liquidated (multiplied by SCALING_FACTOR)
    * @param borrower address of the borrower of credit line
    * @param borrowAsset address of asset borrowed in credit line
    * @param collateralAsset address of asset collateralized in credit line
    * @param startsAt timestamp at which pooled credit line starts
    * @param endsAt timestamp at which pooled credit line ends
    * @param defaultsAt timestamp at which pooled credit line defaults after grace period completes
    * @param borrowAssetStrategy strategy into which lent tokens are deposited
    * @param collateralAssetStrategy address of the strategy into which collateral is deposited
    * @param gracePenaltyRate rate at which penalty is levied during grace period (multiplied by SCALING_FACTOR)
     */
    struct PooledCreditLineConstants {
        uint128 borrowLimit;
        uint128 borrowRate;
        uint256 idealCollateralRatio;
        address borrower;
        address borrowAsset;
        address collateralAsset;
        uint256 startsAt;
        uint256 endsAt;
        uint256 defaultsAt;
        address borrowAssetStrategy;
        address collateralAssetStrategy;
        uint256 gracePenaltyRate;
    }
}",942
RealWorld_TA_101_Math_RealWorld_20240812135759.log,101,Math,22522,1137,23659,61.0,0.13535,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

library Math {
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }
}",51
RealWorld_TA_101_IStrategyRegistry_RealWorld_20240812181554.log,101,IStrategyRegistry,49441,1981,51422,75.0,0.286825,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface IStrategyRegistry {
    /**
     * @notice emitted when a strategy is added to registry
     * @param strategy address of the stratgy added
     */
    event StrategyAdded(address indexed strategy);

    /**
     * @notice emitted when a strategy is removed to registry
     * @param strategy address of the stratgy removed
     */
    event StrategyRemoved(address indexed strategy);

    /**
     * @notice emitted when a maximum number of approved strategies is updated
     * @param maxStrategies updated number of maximum approved strategies
     */
    event MaxStrategiesUpdated(uint256 maxStrategies);

    function registry(address _strategy) external view returns (uint256);

    function isValidStrategy(address strategy) external view returns (bool validStrategy);

    function getStrategies() external view returns (address[] memory strategies);

    /**
     * @dev Add strategies to invest in. Please ensure that number of strategies are less than maxStrategies.
     * @param strategy address of the owner of the savings account contract
     **/
    function addStrategy(address strategy) external;

    /**
     * @dev Remove strategy to invest in.
     * @param strategyIndex Index of the strategy to remove
     * @param strategyAddress Address of the strategy to remove
     **/
    function removeStrategy(uint256 strategyIndex, address strategyAddress) external;

    /**
     * @dev Update strategy to invest in.
     * @param _strategyIndex Index of the strategy to remove
     * @param _oldStrategy Strategy that is to be removed
     * @param _newStrategy Updated strategy
     **/
    function updateStrategy(
        uint256 _strategyIndex,
        address _oldStrategy,
        address _newStrategy
    ) external;
}",371
RealWorld_TA_101_NoYield_RealWorld_20240812174130.log,101,NoYield,161949,3272,165221,122.0,0.875185,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';

import '../interfaces/IYield.sol';

/**
 * @title Yield contract
 * @notice Implements the functions to lock/unlock tokens into available exchanges
 * @author Sublime
 **/
contract NoYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuardUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    //-------------------------------- Constants start --------------------------------/

    // address of treasury where tokens are sent in case of emergencies
    address public immutable TREASURY;

    /**
     * @notice stores the address of savings account contract
     **/
    address public immutable SAVINGS_ACCOUNT;

    //-------------------------------- Constants end --------------------------------/

    //-------------------------------- Global Variables start --------------------------------/

    mapping(address => bool) public tokenWhitelist;

    //-------------------------------- Global Variables end --------------------------------/

    //-------------------------------- Events start --------------------------------/

    /**
     * @notice emitted when all tokens are withdrawn, in case of emergencies
     * @param asset address of the token being withdrawn
     * @param withdrawTo address of the wallet to which tokens are withdrawn
     * @param tokensReceived amount of tokens received
     */
    event EmergencyWithdraw(address indexed asset, address indexed withdrawTo, uint256 tokensReceived);

    /**
     * @notice emitted when a token is whitelisted to be deposited
     * @param asset address of the token to be whitelisted
     */
    event TokenWhitelisted(address indexed asset);

    /**
     * @notice emitted when a token is removed from whitelist
     * @param asset address of the token being removed from whitelist
     */
    event TokenWhitelistRemoved(address indexed asset);

    //-------------------------------- Events end --------------------------------/

    //-------------------------------- Modifier start --------------------------------/

    /**
     * @notice checks if contract is invoked by savings account
     **/
    modifier onlySavingsAccount() {
        require(msg.sender == SAVINGS_ACCOUNT, 'NY:OSA1');
        _;
    }

    //-------------------------------- Modifier end --------------------------------/

    //-------------------------------- Init start --------------------------------/

    /**
     * @notice constructor
     * @param _treasury address of the TREASURY where tokens are sent in case of emergencies
     * @param _savingsAccount address of the savings account contract
     **/
    constructor(address _treasury, address _savingsAccount) {
        require(_treasury != address(0), 'NY:C1');
        require(_savingsAccount != address(0), 'C1');
        TREASURY = _treasury;
        SAVINGS_ACCOUNT = _savingsAccount;
    }

    /**
     * @notice used to initialize the variables in the contract
     * @dev can only be called once
     * @param _owner address of the owner
     **/
    function initialize(address _owner) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
    }

    //-------------------------------- Init end --------------------------------/

    //-------------------------------- lock start --------------------------------/

    /**
     * @notice Used to lock tokens in the protocol
     * @dev Asset Tokens to be locked must be approved to this contract by user
     * @param user the address of user
     * @param asset the address of token to invest
     * @param amount the amount of asset
     * @return sharesReceived amount of shares received
     **/
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external override onlySavingsAccount nonReentrant returns (uint256) {
        require(amount != 0, 'NY:LT1');
        require(tokenWhitelist[asset], 'NY:LT2');
        IERC20(asset).safeTransferFrom(user, address(this), amount);
        uint256 sharesReceived = amount;
        emit LockedTokens(user, asset, sharesReceived);
        return sharesReceived;
    }

    //-------------------------------- lock end --------------------------------/

    //-------------------------------- unlock start --------------------------------/

    /**
     * @notice Used to unlock tokens from the protocol
     * @param asset the address of share token
     * @param amount the amount of asset
     * @return tokensReceived received amount of tokens received
     **/
    function unlockTokens(
        address asset,
        address to,
        uint256 amount
    ) external override onlySavingsAccount nonReentrant returns (uint256) {
        return (_unlockTokens(asset, to, amount));
    }

    /**
     * @notice Used to unlock shares
     * @param asset the address of token locked
     * @param amount the amount of shares to unlock
     * @return received amount of shares received
     **/
    function unlockShares(
        address asset,
        address to,
        uint256 amount
    ) external override onlySavingsAccount nonReentrant returns (uint256) {
        return (_unlockTokens(asset, to, amount));
    }

    function _unlockTokens(
        address asset,
        address to,
        uint256 amount
    ) private returns (uint256) {
        require(amount != 0, 'NY:IUT1');
        uint256 received = amount;
        IERC20(asset).safeTransfer(to, received);
        emit UnlockedTokens(asset, received);
        return received;
    }

    //-------------------------------- unlock end --------------------------------/

    //-------------------------------- Emergency functions start --------------------------------/

    /**
     * @notice used to withdraw all tokens of a type in case of emergencies
     * @dev only owner can withdraw
     * @param _asset address of the token being withdrawn
     * @param _amount amount to be withdraw. (if 0, it means all amount)
     */
    function emergencyWithdraw(address _asset, uint256 _amount) external onlyOwner returns (uint256) {
        uint256 received = _amount;
        if (_amount == 0) {
            received = IERC20(_asset).balanceOf(address(this));
        }
        IERC20(_asset).safeTransfer(TREASURY, received);
        emit EmergencyWithdraw(_asset, TREASURY, received);
        return received;
    }

    //-------------------------------- Emergency functions end --------------------------------/

    //-------------------------------- Emergency functions end --------------------------------/

    /**
     * @notice used to whitelist token to be deposited in noYield
     * @dev can only be called by owner
     * @param _asset address of token to whitelist
     **/
    function addTokenAddress(address _asset) external onlyOwner {
        require(!tokenWhitelist[_asset], 'NY:ATA1');
        tokenWhitelist[_asset] = true;
        emit TokenWhitelisted(_asset);
    }

    /**
     * @notice used to remove token from whitelist
     * @dev can only be called by owner
     * @param _asset address of token to remove from whitelist
     **/
    function removeTokenAddress(address _asset) external onlyOwner {
        require(tokenWhitelist[_asset], 'NY:RTA1');
        require(IERC20(_asset).balanceOf(address(this)) == 0, 'NY:RTA2');
        delete tokenWhitelist[_asset];
        emit TokenWhitelistRemoved(_asset);
    }

    //-------------------------------- Emergency functions end --------------------------------/

    //-------------------------------- utils start --------------------------------/

    /**
     * @dev Used to get amount of underlying tokens for given number of shares
     * @param shares the amount of shares
     * @return amount of underlying tokens
     **/
    function getTokensForShares(uint256 shares, address) external pure override returns (uint256) {
        return shares;
    }

    /**
     * @notice Used to get number of shares from an amount of underlying tokens
     * @param amount the amount of tokens
     * @return amount of shares for given tokens
     **/
    function getSharesForTokens(uint256 amount, address) external pure override returns (uint256) {
        return amount;
    }

    /**
     * @notice used to query liquidity token for a given asset
     * @param _asset address of the asset
     * @return address of the lqiudity token for the asset
     **/
    function liquidityToken(address _asset) external pure override returns (address) {
        return _asset;
    }

    //-------------------------------- utils end --------------------------------/
}",1743
RealWorld_TA_101_Verification.t_RealWorld_20240812163652.log,101,Verification.t,203438,3249,206687,107.0,1.08217,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import 'forge-std/Test.sol';
import 'forge-std/Vm.sol';

import '../../Verification/Verification.sol';
import '../roles/Admin.sol';
import '../roles/User.sol';

contract VerificationTest is Test {
    Verification verification;

    Admin proxyAdmin;
    Admin admin;
    Admin fakeAdmin;

    User user;
    User anotherUser;

    Admin mockVerifier;

    uint256 constant activationDelay = 1000;

    function setUp() public {
        proxyAdmin = new Admin();
        admin = new Admin();
        fakeAdmin = new Admin();
        mockVerifier = new Admin();

        user = new User();
        anotherUser = new User();

        Verification verificationImplementation = new Verification();
        SublimeProxy verificationProxy = new SublimeProxy(address(verificationImplementation), address(proxyAdmin), '');
        verification = Verification(address(verificationProxy));
        admin.initializeVerification(verification, address(admin), activationDelay);

        admin.addVerifier(address(verification), address(mockVerifier));
    }

    // Adding address(0) as verifier should fail
    function test_address_zero_verifier() public {
        try admin.addVerifier(address(verification), address(0)) {
            revert('Should not be able to add zero verifier');
        } catch Error(string memory reason) {
            assertEq(reason, 'V:AV1');
        }
    }

    // Removing non-existant verifier should fail
    function test_remove_wrong_verifier() public {
        try admin.removeVerifier(address(verification), address(21123)) {
            revert('This should be reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'V:RV1');
        }
    }

    // Adding exising verifier should fail
    function test_cannot_add_existing_verifier() public {
        try admin.addVerifier(address(verification), address(mockVerifier)) {
            revert('Should revert when tried to add verifier again');
        } catch Error(string memory reason) {
            assertEq(reason, 'V:AV2');
        }
    }

    // Adding new verifier should pass
    function test_add_new_verifier() public {
        Admin newMockVerifier = new Admin();

        admin.addVerifier(address(verification), address(newMockVerifier));
        assertTrue(verification.verifiers(address(newMockVerifier)));
    }

    // Removing verifier should pass
    function test_remove_verifier() public {
        admin.removeVerifier(address(verification), address(mockVerifier));
        bool isVerifier = verification.verifiers(address(mockVerifier));
        assertEq(isVerifier, false);
    }

    // Registering master address should pass
    function test_registerMasterAddress(bool _isMasterLinked) public {
        mockVerifier.registerMasterAddressInVerificaction(verification, address(user), _isMasterLinked);

        assertGt(verification.masterAddresses(address(user), address(mockVerifier)), 0); // activation time should be non-zero
        if (_isMasterLinked) {
            (uint64 _linkedAddressActivatesAt, address _master) = verification.linkedAddresses(address(user));
            assertGt(uint256(_linkedAddressActivatesAt), 0);
            assertEq(_master, address(user)); // here master address and linked address should be same
        }
    }

    // User should be active only after activation time has passed
    function test_is_user_is_false_immediately_after() public {
        test_registerMasterAddress(true);
        assertEq(verification.isUser(address(user), address(mockVerifier)), false);
    }

    // User should be active after activation time has passed
    function test_is_user_after_activation_delay() public {
        test_is_user_is_false_immediately_after();
        vm.warp(block.timestamp + activationDelay + 1);
        assertEq(verification.isUser(address(user), address(mockVerifier)), true);
    }

    // Registering same master address twice should fail
    function test_registerMasterAddressTwice(bool _isMasterLinked) public {
        mockVerifier.registerMasterAddressInVerificaction(verification, address(user), _isMasterLinked);

        try mockVerifier.registerMasterAddressInVerificaction(verification, address(user), _isMasterLinked) {
            revert('Should fail if tried to register twice');
        } catch Error(string memory reason) {
            assertEq(reason, 'V:RMA1');
        }
    }

    // Registering master address by an invalid user (NOT a verifier) should fail
    function test_registerMasterByNonVerifier(bool _isMasterLinked) public {
        try admin.registerMasterAddressInVerificaction(verification, address(user), _isMasterLinked) {
            revert('non verifier should not be able to registerMasterAddress');
        } catch Error(string memory reason) {
            assertEq(reason, 'V:OV1');
        }
    }

    // Any user should be able to unregister master address
    function test_admin_unregister_any_account(bool _isMasterLinked) public {
        test_registerMasterAddress(_isMasterLinked);
        admin.unregisterMasterAddressInVerification(verification, address(user), address(mockVerifier));

        assertEq(verification.masterAddresses(address(user), address(mockVerifier)), uint256(0));
    }

    // Only admin should be able to unregister master address
    function test_non_admin_unregister_any_account(bool _isMasterLinked) public {
        test_registerMasterAddress(_isMasterLinked);
        try fakeAdmin.unregisterMasterAddressInVerification(verification, address(user), address(mockVerifier)) {
            revert('Should revert as admin is not calling this function');
        } catch Error(string memory reason) {
            assertEq(reason, 'V:UMA1');
        }
    }

    // Valid verifier should be able to unregister master addresses
    function test_verifier_unregister_any_account(bool _isMasterLinked, address thisArgumentCanBeAnything) public {
        test_registerMasterAddress(_isMasterLinked);

        mockVerifier.unregisterMasterAddressInVerification(verification, address(user), thisArgumentCanBeAnything);
        assertEq(verification.masterAddresses(address(user), address(mockVerifier)), uint256(0));
    }

    // Requesting address link should pass
    function test_requestAddressLinking() public {
        test_registerMasterAddress(false);
        vm.warp(block.timestamp + 1 hours);

        // user = master, anotherUser = linkedAddress
        user.requestAddressLinkingInVerifier(verification, address(anotherUser));
        assertEq(verification.pendingLinkAddresses(address(anotherUser), address(user)), true);
    }

    // Requesting address link for existing master address should fail
    function test_requestExistingAddressLinking() public {
        test_registerMasterAddress(true);
        vm.warp(block.timestamp + 1 hours);

        // user = master, anotherUser = linkedAddress
        try user.requestAddressLinkingInVerifier(verification, address(user)) {
            revert('Should revert when tried to link existing address');
        } catch Error(string memory reason) {
            assertEq(reason, 'V:RAL1');
        }
    }

    // Cancelling address link request should pass
    function test_cancelAddressLinking() public {
        test_requestAddressLinking();
        user.cancelAddressLinkingRequestInVerification(verification, address(anotherUser));
        assertEq(verification.pendingLinkAddresses(address(anotherUser), address(user)), false);
    }

    // Cancelling address link request for linked addresses should fail
    function test_cancelAddressLinkingWhenNotPendfing() public {
        try user.cancelAddressLinkingRequestInVerification(verification, address(anotherUser)) {
            revert('Should revert when tried to cancel when no request is there');
        } catch Error(string memory reason) {
            assertEq(reason, 'V:CALR1');
        }
    }

    // linking addresses to master address should pass
    function test_linkAddress() public {
        test_requestAddressLinking();
        anotherUser.linkAddressInVerification(verification, address(user));
        (, address _master) = verification.linkedAddresses(address(anotherUser));
        assertEq(_master, address(user));
        vm.warp(block.timestamp + activationDelay);
        assertEq(verification.isUser(address(anotherUser), address(mockVerifier)), true);
    }

    // Unlinking addresses from master address should pass
    function test_unlinkAddress() public {
        test_linkAddress();
        user.unlinkAddressInVerification(verification, address(anotherUser));
        assertEq(verification.isUser(address(anotherUser), address(mockVerifier)), false);
    }

    // Unlinking same address from master address more than once should fail
    function test_unlinkAddressMultipleTimes() public {
        test_unlinkAddress();
        try user.unlinkAddressInVerification(verification, address(anotherUser)) {
            revert(""Can't unlink multiple times"");
        } catch Error(string memory reason) {
            assertEq(reason, 'V:UA1');
        }
    }

    // linking master address to address(0) should fail
    function test_linking_address_to_zero() public {
        try anotherUser.linkAddressInVerification(verification, address(0)) {
            revert('Should Revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'V:LA1');
        }
    }

    // linking same address to same master address multiple times should fail
    function test_linkAddress_multiple_times_fails() public {
        test_requestAddressLinking();
        anotherUser.linkAddressInVerification(verification, address(user));

        try anotherUser.linkAddressInVerification(verification, address(user)) {
            revert('Should Revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'V:LA2');
        }
    }

    // Linking address without requesting first should fail
    function test_linkAddress_without_request() public {
        try anotherUser.linkAddressInVerification(verification, address(user)) {
            revert('Should Revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'V:LA3');
        }
    }

    // Updating activation delay should pass
    function test_updateActivationDelay(uint256 _activationDelay) public {
        admin.updateActivationDelayInVerification(verification, _activationDelay);
        uint256 newActivationDelay = verification.activationDelay();
        assertEq(newActivationDelay, _activationDelay);
    }

    // Updating activation delay with invalid owner should fail
    function test_updateActivationDelay_invalidOwner(uint256 _activationDelay) public {
        try fakeAdmin.updateActivationDelayInVerification(verification, _activationDelay) {
            revert('Only owner can call this function');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }
}",2185
RealWorld_TA_101_MaliciousLender_RealWorld_20240812154806.log,101,MaliciousLender,32769,4421,37190,115.0,0.252265,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import './PCLUser.t.sol';

contract MaliciousLender is PCLUser {
    constructor(address _pclAddress, address _lpAddress) PCLUser(_pclAddress, _lpAddress) {}

    function onERC1155Received(
        address,
        address,
        uint256 id,
        uint256,
        bytes calldata
    ) external override returns (bytes4) {
        // any code can be executed here
        ILenderPool(msg.sender).start(id);
        return bytes4(keccak256('onERC1155Received(address,address,uint256,uint256,bytes)'));
    }
}",149
RealWorld_TA_101_PCLClosedStage.t_RealWorld_20240812151021.log,101,PCLClosedStage.t,76401,3630,80031,99.0,0.454605,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLClosedStage.t.sol';

contract PCLClosedStageCollateralCompoundBorrowCompound is PCLClosedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        // Now we assert that we are in the ACTIVE state
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), 2);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // And borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(requestId, currentDebt);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
}",682
RealWorld_TA_101_PCLExpiredStage.t_RealWorld_20240812154624.log,101,PCLExpiredStage.t,80160,3930,84090,100.0,0.4794,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../../PCLStageTests/PCLExpiredStage.t.sol';

contract PCLExpiredStageZeroCollateralBorrowCompound is PCLExpiredStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(requestId, _requiredCollateral, false);
        }
        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }
}",718
RealWorld_TA_101_PCLNotCreatedStage.t_RealWorld_20240812152945.log,101,PCLNotCreatedStage.t,53139,2687,55826,91.0,0.319435,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLStageTests/PCLNotCreatedStage.t.sol';

contract PCLNotCreatedStageZeroCollateral is PCLNotCreatedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public virtual override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * (10**ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);

        // Create a few lenders
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount + 1), request.borrowAsset);

        notCreatedRequestId = requestId + 1;
        assertTrue(pcl.getStatusAndUpdate(notCreatedRequestId) == PooledCreditLineStatus.NOT_CREATED, 'Not Created');
    }
}",402
RealWorld_TA_101_creditLine.NotCreatedStage.t_RealWorld_20240812165152.log,101,creditLine.NotCreatedStage.t,766242,68,766310,105.0,3.83257,"pragma solidity 0.7.6;
pragma abicoder v2;

import './Helpers/CLParent.sol';
import '../../SavingsAccount/SavingsAccount.sol';
import '../../PriceOracle.sol';

import '@openzeppelin/contracts/math/SafeMath.sol';

contract CreditLine_NotCreatedStageTests is CLParent {
    using SafeMath for uint256;

    CreditLine cl;
    SavingsAccount savingsAccount;
    PriceOracle priceOracle;

    uint256 tokensToLiquidate;
    uint256 totalCollateralTokens;
    uint256 currentDebt;
    uint256 _ratioOfPrices;
    uint256 _decimals;
    uint256 collateralToLiquidate;

    function setUp() public virtual {
        CLSetUp();

        cl = CreditLine(creditLineAddress);
        savingsAccount = SavingsAccount(savingsAccountAddress);
        priceOracle = PriceOracle(priceOracleAddress);

        (_ratioOfPrices, _decimals) = priceOracle.getLatestPrice(address(usdc), address(borrowAsset));

        requestData.requestTo = address(lender);
        // Borrow Asset equivalent of 1,000,000,000 in USD
        requestData.borrowLimit = uint128(uint256(CLConstants.maxBorrowLimit / 1e6).mul(_ratioOfPrices).div(10**_decimals));
        requestData.borrowRate = CLConstants.maxBorrowRate / 1e18;
        requestData.autoLiquidation = false;
        requestData.collateralRatio = (350 * CLConstants.maxCollteralRatio) / 1e11;
        requestData.borrowAsset = address(borrowAsset);
        requestData.borrowAssetStrategy = noYieldAddress;
        requestData.collateralAsset = address(collateralAsset);
        requestData.collateralStrategy = noYieldAddress;
        requestData.requestAsLender = false;
    }

    //----------------------- setUp, failing tests-----------------------//

    function test_setup_invalidUSDC() public {
        try
            admin.deployCLContracts(
                address(0),
                priceOracleAddress,
                savingsAccountAddress,
                strategyRegistryAddress,
                protocolFeeCollectorAddress
            )
        {
            revert('Should fail when address(0) is used for usdc');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:CON1');
        }
    }

    function test_setup_invalidOracle() public {
        try
            admin.deployCLContracts(address(usdc), address(0), savingsAccountAddress, strategyRegistryAddress, protocolFeeCollectorAddress)
        {
            revert('Should fail when address(0) is used for price oracle');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:CON2');
        }
    }

    function test_setup_invalidSavingsAccount() public {
        try admin.deployCLContracts(address(usdc), priceOracleAddress, address(0), strategyRegistryAddress, protocolFeeCollectorAddress) {
            revert('Should fail when address(0) is used for savings account');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:CON3');
        }
    }

    function test_setup_invalidStrategyRegistry() public {
        try admin.deployCLContracts(address(usdc), priceOracleAddress, savingsAccountAddress, address(0), protocolFeeCollectorAddress) {
            revert('Should fail when address(0) is used for strategy registry');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:CON4');
        }
    }

    //----------------------- NOT_CREATED stage, Credit line is not requested yet-----------------------//

    //----------------------- NOT_CREATED stage, failing tests-----------------------//

    // Cannot call accept function in NOT_CREATED stage
    function test_notCreated_accept() public {
        try lender.acceptRequest(creditLineAddress, 10) {
            revert('REVERT: Cannot accpet non-existant credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:A1');
        }
    }

    // Cannot call deposit collateral function in NOT_CREATED stage
    function test_notCreated_depositCollateral() public {
        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // _fromSavingsAccount = true
        // Adding tokens to borrower and setting allowance for creditline contract
        savingsAccount_depositHelper(address(borrower), address(collateralAsset), requestData.collateralStrategy, amount);

        try borrower.addCollateral(creditLineAddress, 11, amount, true) {
            revert('REVERT: Cannot add collateral to non-existant credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:DC2');
        }

        // _fromSavingsAccount = false
        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(creditLineAddress, address(collateralAsset), amount);

        try borrower.addCollateral(creditLineAddress, 11, amount, false) {
            revert('REVERT: Cannot add collateral to non-existant credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:DC2');
        }
    }

    // Cannot call withdraw collateral function in NOT_CREATED stage
    function test_notCreated_withdrawCollateral() public {
        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // _toSavingsAccount = true
        try borrower.withdrawCollateral(creditLineAddress, 12, amount, true) {
            revert('REVERT: Cannot withdraw collateral from non-existant credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLB1');
        }

        // _toSavingsAccount = false
        try borrower.withdrawCollateral(creditLineAddress, 12, amount, false) {
            revert('REVERT: Cannot withdraw collateral from non-existant credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLB1');
        }
    }

    // Cannot call withdraw all collateral function in NOT_CREATED stage
    function test_notCreated_withdrawAllCollateral() public {
        // _toSavingsAccount = true
        try borrower.withdrawAllCollateral(creditLineAddress, 13, true) {
            revert('REVERT: Cannot withdraw collateral from non-existant credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLB1');
        }

        // _toSavingsAccount = false
        try borrower.withdrawAllCollateral(creditLineAddress, 13, false) {
            revert('REVERT: Cannot withdraw collateral from non-existant credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLB1');
        }
    }

    // Cannot update borrow limit function in NOT_CREATED stage
    function test_notCreated_updateBorrowLimit(uint128 _newBorrowLimit) public {
        uint128 newBorrowLimit = scaleToRange128(_newBorrowLimit, 1, type(uint128).max);
        try lender.updateBorrowLimit(creditLineAddress, 14, newBorrowLimit) {
            revert('REVERT: Cannot update borrow limit for non-existant credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLL1');
        }
    }

    // Cannot borrow in NOT_CREATED stage
    function test_notCreated_borrow() public {
        uint256 amount = 1_000 * 10**ERC20(address(borrowAsset)).decimals();
        try borrower.borrow(creditLineAddress, 15, amount) {
            revert('REVERT: Cannot borrow from non-existant credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLB1');
        }
    }

    // Cannot repay in NOT_CREATED stage
    function test_notCreated_repay() public {
        uint256 amount = 1_000 * 10**ERC20(address(borrowAsset)).decimals();
        try borrower.repay(creditLineAddress, 16, amount) {
            revert('REVERT: Cannot repay non-existant credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:REP2');
        }
    }

    // Cannot liquidate in NOT_CREATED stage
    function test_notCreated_liquidate() public {
        // _toSavingsAccount = true
        try lender.liquidate(creditLineAddress, 17, true) {
            revert('REVERT: Cannot liquidate non-existant credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:L1');
        }

        // _toSavingsAccount = false
        try lender.liquidate(creditLineAddress, 17, false) {
            revert('REVERT: Cannot liquidate non-existant credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:L1');
        }
    }

    // Cannot close credit line in NOT_CREATED stage
    function test_notCreated_close() public {
        try borrower.close(creditLineAddress, 18) {
            revert('REVERT: Cannot close non-existant credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:C1');
        }
    }

    // Cannot cancel credit line in NOT_CREATED stage
    function test_notCreated_cancel() public {
        try borrower.cancelRequest(creditLineAddress, 19) {
            revert('REVERT: Cannot cancel non-existant credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:CP1');
        }
    }

    //----------------------- NOT_CREATED stage, passing tests-----------------------//

    // Requesting a credit line in the NOT_CREATED stage should pass
    function test_notCreated_request() public {
        uint256 creditLineId = borrower.createRequest(creditLineAddress, requestData);
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);
    }

    //----------------------- NOT_CREATED stage, Credit line is cancelled-----------------------//

    //----------------------- NOT_CREATED/CANCELLED stage, failing tests-----------------------//

    // Cannot call accept function for cancelled credit line
    function test_cancelled_accept() public {
        // Requesting and cancelling the creditline
        uint256 creditLineId = assert_creditLineRequestedAndCancelled();

        // accept the credit line
        try lender.acceptRequest(creditLineAddress, creditLineId) {
            revert('REVERT: Cannot accpet cancelled credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:A1');
        }
    }

    // Cannot deposit collateral to cancelled credit line
    function test_cancelled_depositCollateral() public {
        // Requesting and cancelling the creditline
        uint256 creditLineId = assert_creditLineRequestedAndCancelled();

        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // _fromSavingsAccount = true
        savingsAccount_depositHelper(address(borrower), address(collateralAsset), requestData.collateralStrategy, amount);
        // deposit collateral to the credit line
        try borrower.addCollateral(creditLineAddress, creditLineId, amount, true) {
            revert('REVERT: Cannot add collateral to cancelled credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:DC2');
        }

        // _fromSavingsAccount = false
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(creditLineAddress, address(collateralAsset), amount);
        // deposit collateral to the credit line
        try borrower.addCollateral(creditLineAddress, creditLineId, amount, false) {
            revert('REVERT: Cannot add collateral to cancelled credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:DC2');
        }
    }

    // Cannot withdraw collateral from cancelled credit line
    function test_cancelled_withdrawCollateral() public {
        // Requesting and cancelling the creditline
        uint256 creditLineId = assert_creditLineRequestedAndCancelled();

        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // withdraw collateral from the credit line

        // _toSavingsAccount = true
        try borrower.withdrawCollateral(creditLineAddress, creditLineId, amount, true) {
            revert('REVERT: Cannot withdraw collateral from cancelled credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLB1');
        }

        // _toSavingsAccount = false
        try borrower.withdrawCollateral(creditLineAddress, creditLineId, amount, false) {
            revert('REVERT: Cannot withdraw collateral from cancelled credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLB1');
        }
    }

    // Cannot withdraw collateral from cancelled credit line
    function test_cancelled_withdrawAllCollateral() public {
        // Requesting and cancelling the creditline
        uint256 creditLineId = assert_creditLineRequestedAndCancelled();

        // withdraw all collateral from the credit line

        // _toSavingsAccount = true
        try borrower.withdrawAllCollateral(creditLineAddress, creditLineId, true) {
            revert('REVERT: Cannot withdraw collateral from cancelled credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLB1');
        }

        // _toSavingsAccount = false
        try borrower.withdrawAllCollateral(creditLineAddress, creditLineId, false) {
            revert('REVERT: Cannot withdraw collateral from cancelled credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLB1');
        }
    }

    // Cannot update Borrow Limit for cancelled credit line
    function test_cancelled_updateBorrowLimit(uint128 _newBorrowLimit) public {
        // Requesting and cancelling the creditline
        uint256 creditLineId = assert_creditLineRequestedAndCancelled();

        // update borrow limit of the credit line
        uint128 newBorrowLimit = scaleToRange128(_newBorrowLimit, 1, type(uint128).max);
        try lender.updateBorrowLimit(creditLineAddress, creditLineId, newBorrowLimit) {
            revert('REVERT: Cannot update borrow limit for cancelled credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLL1');
        }
    }

    // Cannot borrow from cancelled credit line
    function test_cancelled_borrow() public {
        // Requesting and cancelling the creditline
        uint256 creditLineId = assert_creditLineRequestedAndCancelled();

        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // borrow from the credit line
        try borrower.borrow(creditLineAddress, creditLineId, amount) {
            revert('REVERT: Cannot borrow from cancelled credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLB1');
        }
    }

    // Cannot repay for cancelled credit line
    function test_cancelled_repay() public {
        // Requesting and cancelling the creditline
        uint256 creditLineId = assert_creditLineRequestedAndCancelled();

        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // repay the credit line
        try borrower.repay(creditLineAddress, creditLineId, amount) {
            revert('REVERT: Cannot repay cancelled credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:REP2');
        }
    }

    // Cannot liquidate cancelled credit line
    function test_cancelled_liquidate() public {
        // Requesting and cancelling the creditline
        uint256 creditLineId = assert_creditLineRequestedAndCancelled();

        // liquidate the credit line

        // _toSavingsAccount = true
        try lender.liquidate(creditLineAddress, creditLineId, true) {
            revert('REVERT: Cannot liquidate cancelled credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:L1');
        }

        // _toSavingsAccount = false
        try lender.liquidate(creditLineAddress, creditLineId, false) {
            revert('REVERT: Cannot liquidate cancelled credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:L1');
        }
    }

    // Cannot close cancelled credit line
    function test_cancelled_close() public {
        // Requesting and cancelling the creditline
        uint256 creditLineId = assert_creditLineRequestedAndCancelled();

        // close the credit line
        try borrower.close(creditLineAddress, creditLineId) {
            revert('REVERT: Cannot close cancelled credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:C1');
        }
    }

    // Cannot cancel cancelled credit line
    function test_cancelled_cancel() public {
        // Requesting and cancelling the creditline
        uint256 creditLineId = assert_creditLineRequestedAndCancelled();

        // cancel the credit line
        try borrower.cancelRequest(creditLineAddress, creditLineId) {
            revert('REVERT: Cannot cancel cancelled credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:CP1');
        }
    }

    function assert_creditLineRequestedAndCancelled() public returns (uint256) {
        // request a credit line
        uint256 creditLineId = borrower.createRequest(creditLineAddress, requestData);
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);

        // cancel the credit line
        borrower.cancelRequest(address(cl), creditLineId);

        // check status of credit line
        uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
        assertEq(status, 0); // Checking if creditLine status is updated to NOT_CREATED

        return creditLineId;
    }

    //----------------------- NOT_CREATED stage, Credit line is liquidated-----------------------//

    //----------------------- NOT_CREATED/LIQUIDATED stage, failing tests-----------------------//

    // Cannot accept liquidated credit line
    function test_liquidated_accept() public {
        // Go to Active stage
        uint256 creditLineId = goToActiveStage();

        //Liquidate the credit line
        assert_creditLineLiquidate(address(lender), creditLineId, false);

        // accept the credit line
        try lender.acceptRequest(creditLineAddress, creditLineId) {
            revert('REVERT: Cannot accpet liquidated credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:A1');
        }
    }

    // Cannot deposit collateral to liquidated credit line
    function test_liquidated_depositCollateral() public {
        // Go to Active stage
        uint256 creditLineId = goToActiveStage();

        //Liquidate the credit line
        assert_creditLineLiquidate(address(lender), creditLineId, false);

        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // _fromSavingsAccount = true
        savingsAccount_depositHelper(address(borrower), address(collateralAsset), requestData.collateralStrategy, amount);
        // deposit collateral to the credit line
        try borrower.addCollateral(creditLineAddress, creditLineId, amount, true) {
            revert('REVERT: Cannot add collateral to liquidated credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:DC2');
        }

        // _fromSavingsAccount = false
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(creditLineAddress, address(collateralAsset), amount);
        // deposit collateral to the credit line
        try borrower.addCollateral(creditLineAddress, creditLineId, amount, false) {
            revert('REVERT: Cannot add collateral to liquidated credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:DC2');
        }
    }

    // Cannot withdraw collateral from liquidated credit line
    function test_liquidated_withdrawCollateral() public {
        // Go to Active stage
        uint256 creditLineId = goToActiveStage();

        //Liquidate the credit line
        assert_creditLineLiquidate(address(lender), creditLineId, true);

        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // withdraw collateral from the credit line

        // _toSavingsAccount = true
        try borrower.withdrawCollateral(creditLineAddress, creditLineId, amount, true) {
            revert('REVERT: Cannot withdraw collateral from liquidated credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLB1');
        }

        // _toSavingsAccount = false
        try borrower.withdrawCollateral(creditLineAddress, creditLineId, amount, false) {
            revert('REVERT: Cannot withdraw collateral from liquidated credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLB1');
        }
    }

    // Cannot withdraw collateral from liquidated credit line
    function test_liquidated_withdrawAllCollateral() public {
        // Go to Active stage
        uint256 creditLineId = goToActiveStage();

        //Liquidate the credit line
        assert_creditLineLiquidate(address(lender), creditLineId, false);

        // withdraw all collateral from the credit line

        // _toSavingsAccount = true
        try borrower.withdrawAllCollateral(creditLineAddress, creditLineId, true) {
            revert('REVERT: Cannot withdraw collateral from liquidated credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLB1');
        }

        // _toSavingsAccount = false
        try borrower.withdrawAllCollateral(creditLineAddress, creditLineId, false) {
            revert('REVERT: Cannot withdraw collateral from liquidated credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLB1');
        }
    }

    // Cannot update borrow limit for liquidated credit line
    function test_liquidated_updateBorrowLimit(uint128 _newBorrowLimit) public {
        // Go to Active stage
        uint256 creditLineId = goToActiveStage();

        //Liquidate the credit line
        assert_creditLineLiquidate(address(lender), creditLineId, false);

        // update borrow limit of the credit line
        uint128 newBorrowLimit = scaleToRange128(_newBorrowLimit, 1, type(uint128).max);
        try lender.updateBorrowLimit(creditLineAddress, creditLineId, newBorrowLimit) {
            revert('REVERT: Cannot update borrow limit for liquidated credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLL1');
        }
    }

    // Cannot borrow from liquidated credit line
    function test_liquidated_borrow() public {
        // Go to Active stage
        uint256 creditLineId = goToActiveStage();

        //Liquidate the credit line
        assert_creditLineLiquidate(address(lender), creditLineId, true);

        uint256 amount = 1_000 * 10**ERC20(address(borrowAsset)).decimals();

        // borrow from the credit line
        try borrower.borrow(creditLineAddress, creditLineId, amount) {
            revert('REVERT: Cannot borrow from liquidated credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLB1');
        }
    }

    // Cannot repay to liquidated credit line
    function test_liquidated_repay() public {
        // Go to Active stage
        uint256 creditLineId = goToActiveStage();

        //Liquidate the credit line
        assert_creditLineLiquidate(address(lender), creditLineId, false);

        uint256 amount = 1_000 * 10**ERC20(address(borrowAsset)).decimals();

        // repay the credit line
        try borrower.repay(creditLineAddress, creditLineId, amount) {
            revert('REVERT: Cannot repay liquidated credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:REP2');
        }
    }

    // Cannot liquidate liquidated credit line
    function test_liquidated_liquidate() public {
        // Go to Active stage
        uint256 creditLineId = goToActiveStage();

        //Liquidate the credit line
        assert_creditLineLiquidate(address(lender), creditLineId, true);

        // liquidate the credit line

        // _toSavingsAccount = true
        try lender.liquidate(creditLineAddress, creditLineId, true) {
            revert('REVERT: Cannot liquidate liquidated credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:L1');
        }

        // _toSavingsAccount = false
        try lender.liquidate(creditLineAddress, creditLineId, false) {
            revert('REVERT: Cannot liquidate liquidated credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:L1');
        }
    }

    // Cannot close liquidated credit line
    function test_liquidated_close() public {
        // Go to Active stage
        uint256 creditLineId = goToActiveStage();

        //Liquidate the credit line
        assert_creditLineLiquidate(address(lender), creditLineId, true);

        // close the credit line
        try borrower.close(creditLineAddress, creditLineId) {
            revert('REVERT: Cannot close liquidated credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:C1');
        }
    }

    // Cannot cancel liquidated credit line
    function test_liquidated_cancel() public {
        // Go to Active stage
        uint256 creditLineId = goToActiveStage();

        //Liquidate the credit line
        assert_creditLineLiquidate(address(lender), creditLineId, false);

        // cancel the credit line
        try borrower.cancelRequest(creditLineAddress, creditLineId) {
            revert('REVERT: Cannot cancel liquidated credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:CP1');
        }
    }

    //----------------------- NOT_CREATED stage, Credit line is closed-----------------------//

    //----------------------- NOT_CREATED/CLOSED stage, failing tests-----------------------//

    // Cannot accept closed credit line
    function test_closed_accept() public {
        // Go to Active stage
        uint256 creditLineId = goToActiveStage();

        //repay and close the credit line
        assert_creditLineRepayAndClose(address(borrower), creditLineId, address(borrowAsset));

        // accept the credit line
        try lender.acceptRequest(creditLineAddress, creditLineId) {
            revert('REVERT: Cannot accpet closed credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:A1');
        }
    }

    // Cannot deposit collateral to closed credit line
    function test_closed_depositCollateral() public {
        // Go to Active stage
        uint256 creditLineId = goToActiveStage();

        //repay and close the credit line
        assert_creditLineRepayAndClose(address(borrower), creditLineId, address(borrowAsset));

        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // _fromSavingsAccount = true
        savingsAccount_depositHelper(address(borrower), address(collateralAsset), requestData.collateralStrategy, amount);
        // deposit collateral to the credit line
        try borrower.addCollateral(creditLineAddress, creditLineId, amount, true) {
            revert('REVERT: Cannot add collateral to closed credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:DC2');
        }

        // _fromSavingsAccount = false
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(creditLineAddress, address(collateralAsset), amount);
        // deposit collateral to the credit line
        try borrower.addCollateral(creditLineAddress, creditLineId, amount, false) {
            revert('REVERT: Cannot add collateral to closed credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:DC2');
        }
    }

    // Cannot withdraw collateral from closed credit line
    function test_closed_withdrawCollateral() public {
        // Go to Active stage
        uint256 creditLineId = goToActiveStage();

        //repay and close the credit line
        assert_creditLineRepayAndClose(address(borrower), creditLineId, address(borrowAsset));

        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // withdraw collateral from the credit line

        // _toSavingsAccount = true
        try borrower.withdrawCollateral(creditLineAddress, creditLineId, amount, true) {
            revert('REVERT: Cannot withdraw collateral from closed credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLB1');
        }

        // _toSavingsAccount = false
        try borrower.withdrawCollateral(creditLineAddress, creditLineId, amount, false) {
            revert('REVERT: Cannot withdraw collateral from closed credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLB1');
        }
    }

    // Cannot withdraw collateral from closed credit line
    function test_closed_withdrawAllCollateral() public {
        // Go to Active stage
        uint256 creditLineId = goToActiveStage();

        //repay and close the credit line
        assert_creditLineRepayAndClose(address(borrower), creditLineId, address(borrowAsset));

        // withdraw all collateral from the credit line

        // _toSavingsAccount = true
        try borrower.withdrawAllCollateral(creditLineAddress, creditLineId, true) {
            revert('REVERT: Cannot withdraw collateral from closed credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLB1');
        }

        // _toSavingsAccount = false
        try borrower.withdrawAllCollateral(creditLineAddress, creditLineId, false) {
            revert('REVERT: Cannot withdraw collateral from closed credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLB1');
        }
    }

    // Cannot update borrow limit for closed credit line
    function test_closed_updateBorrowLimit(uint128 _newBorrowLimit) public {
        // Go to Active stage
        uint256 creditLineId = goToActiveStage();

        //repay and close the credit line
        assert_creditLineRepayAndClose(address(borrower), creditLineId, address(borrowAsset));

        // update borrow limit of the credit line
        uint128 newBorrowLimit = scaleToRange128(_newBorrowLimit, 1, type(uint128).max);
        try lender.updateBorrowLimit(creditLineAddress, creditLineId, newBorrowLimit) {
            revert('REVERT: Cannot update borrow limit for closed credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLL1');
        }
    }

    // Cannot borrow from closed credit line
    function test_closed_borrow() public {
        // Go to Active stage
        uint256 creditLineId = goToActiveStage();

        //repay and close the credit line
        assert_creditLineRepayAndClose(address(borrower), creditLineId, address(borrowAsset));

        uint256 amount = 1_000 * 10**ERC20(address(borrowAsset)).decimals();

        // borrow from the credit line
        try borrower.borrow(creditLineAddress, creditLineId, amount) {
            revert('REVERT: Cannot borrow from closed credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:OCLB1');
        }
    }

    // Cannot repay to closed credit line
    function test_closed_repay() public {
        // Go to Active stage
        uint256 creditLineId = goToActiveStage();

        //repay and close the credit line
        assert_creditLineRepayAndClose(address(borrower), creditLineId, address(borrowAsset));

        uint256 amount = 1_000 * 10**ERC20(address(borrowAsset)).decimals();

        // repay the credit line
        try borrower.repay(creditLineAddress, creditLineId, amount) {
            revert('REVERT: Cannot repay closed credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:REP2');
        }
    }

    // Cannot liquidate closed credit line
    function test_closed_liquidate() public {
        // Go to Active stage
        uint256 creditLineId = goToActiveStage();

        //repay and close the credit line
        assert_creditLineRepayAndClose(address(borrower), creditLineId, address(borrowAsset));

        // liquidate the credit line

        // _toSavingsAccount = true
        try lender.liquidate(creditLineAddress, creditLineId, true) {
            revert('REVERT: Cannot liquidate closed credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:L1');
        }

        // _toSavingsAccount = false
        try lender.liquidate(creditLineAddress, creditLineId, false) {
            revert('REVERT: Cannot liquidate closed credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:L1');
        }
    }

    // Cannot close closed credit line
    function test_closed_close() public {
        // Go to Active stage
        uint256 creditLineId = goToActiveStage();

        //repay and close the credit line
        assert_creditLineRepayAndClose(address(borrower), creditLineId, address(borrowAsset));

        // close the credit line
        try borrower.close(creditLineAddress, creditLineId) {
            revert('REVERT: Cannot close closed credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:C1');
        }
    }

    // Cannot cancel closed credit line
    function test_closed_cancel() public {
        // Go to Active stage
        uint256 creditLineId = goToActiveStage();

        //repay and close the credit line
        assert_creditLineRepayAndClose(address(borrower), creditLineId, address(borrowAsset));

        // cancel the credit line
        try borrower.cancelRequest(creditLineAddress, creditLineId) {
            revert('REVERT: Cannot cancel closed credit line');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:CP1');
        }
    }

    //----------------------- Assert helper functions -----------------------//

    function assert_creditlineConstantsAndStatus(
        uint256 _creditLineId,
        address _requestBy,
        CLConstants.RequestParams memory requestData
    ) public {
        getCreditlineConstants(_creditLineId);

        if (requestData.requestAsLender) {
            assertEq(constantsCheck.lender, _requestBy);
            assertEq(constantsCheck.borrower, requestData.requestTo);
        } else {
            assertEq(constantsCheck.lender, requestData.requestTo);
            assertEq(constantsCheck.borrower, _requestBy);
        }

        assertEq(constantsCheck.borrowLimit, requestData.borrowLimit);
        assertEq(constantsCheck.idealCollateralRatio, requestData.collateralRatio);
        assertEq(constantsCheck.borrowRate, requestData.borrowRate);
        assertEq(constantsCheck.borrowAsset, requestData.borrowAsset);
        assertEq(constantsCheck.borrowAssetStrategy, requestData.borrowAssetStrategy);
        assertEq(constantsCheck.collateralAsset, requestData.collateralAsset);
        assertEq(constantsCheck.collateralStrategy, requestData.collateralStrategy);

        uint256 status = uint256(cl.getCreditLineStatus(_creditLineId));
        assertEq(status, 1); // Checking if creditLine status is updated to REQUESTED
    }

    function assert_creditLineLiquidate(
        address _user,
        uint256 _creditLineId,
        bool _fromSavingsAccount
    ) public {
        uint256 currentBalance;
        uint256 balanceAfter;
        uint256 balanceDiff;
        uint256 amount = 1 * 10**(ERC20(address(collateralAsset)).decimals());
        address borrowAssetStrategy = requestData.borrowAssetStrategy;
        address collateralStrategy = requestData.collateralStrategy;

        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(creditLineAddress, address(collateralAsset), amount);

        borrower.addCollateral(creditLineAddress, _creditLineId, amount, false);

        uint256 borrowable = cl.calculateBorrowableAmount(_creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(creditLineAddress, _creditLineId, borrowable);

        if (!isForked) {
            borrowAssetMockAggregator.updateAnswer(9795040576);
        } else {
            setCurrentCollRatio();
        }

        tokensToLiquidate = cl.borrowTokensToLiquidate(_creditLineId);
        totalCollateralTokens = cl.calculateTotalCollateralTokens(_creditLineId);
        currentDebt = cl.calculateCurrentDebt(_creditLineId);
        (_ratioOfPrices, _decimals) = PriceOracle(priceOracleAddress).getLatestPrice(address(collateralAsset), address(borrowAsset));
        collateralToLiquidate = currentDebt.mul(10**_decimals).div(_ratioOfPrices);
        if (collateralToLiquidate > totalCollateralTokens) {
            collateralToLiquidate = totalCollateralTokens;
        }

        CLUser user = CLUser(_user);

        admin.transferToken(address(borrowAsset), address(user), tokensToLiquidate);
        user.setAllowance(creditLineAddress, address(borrowAsset), tokensToLiquidate);

        if (_fromSavingsAccount) {
            currentBalance = savingsAccount.balanceInShares(address(user), address(collateralAsset), collateralStrategy);
            user.liquidate(creditLineAddress, _creditLineId, _fromSavingsAccount);
            balanceAfter = savingsAccount.balanceInShares(address(user), address(collateralAsset), collateralStrategy);
            balanceDiff = balanceAfter.sub(currentBalance);
            uint256 collateralShares = IYield(collateralStrategy).getSharesForTokens(collateralToLiquidate, address(collateralAsset));
            assertEq(balanceDiff, collateralShares);
        } else {
            currentBalance = collateralAsset.balanceOf(address(user));
            user.liquidate(creditLineAddress, _creditLineId, _fromSavingsAccount);
            balanceAfter = collateralAsset.balanceOf(address(user));
            balanceDiff = balanceAfter.sub(currentBalance);
            assertApproxEqAbs(balanceDiff, collateralToLiquidate, 1);
        }

        uint256 status = uint256(cl.getCreditLineStatus(_creditLineId));
        assertEq(status, 0); // Credit line variables are deleted
    }

    function assert_creditLineRepayAndClose(
        address _user,
        uint256 _creditLineId,
        address _asset
    ) public {
        // initialize the user
        CLUser user = CLUser(_user);
        uint256 amount = 1 * 10**(ERC20(address(collateralAsset)).decimals());
        address borrowAssetStrategy = requestData.borrowAssetStrategy;

        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(creditLineAddress, address(collateralAsset), amount);

        borrower.addCollateral(creditLineAddress, _creditLineId, amount, false);

        uint256 borrowable = cl.calculateBorrowableAmount(_creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(creditLineAddress, _creditLineId, borrowable);

        _increaseBlock(block.timestamp + 10000 days);

        currentDebt = cl.calculateCurrentDebt(_creditLineId);

        // add balance to user
        admin.transferToken(_asset, _user, currentDebt);
        user.setAllowance(creditLineAddress, _asset, currentDebt);

        // getting balance of the user before repayment
        uint256 balanceBefore = IERC20(_asset).balanceOf(_user);

        // repay the credit line
        user.repay(creditLineAddress, _creditLineId, currentDebt);

        // getting the balance after repayment
        uint256 balanceAfter = IERC20(_asset).balanceOf(_user);

        // assert: balance change for user should be equal to amount repaid
        assertEq(balanceBefore.sub(balanceAfter), currentDebt);

        // checking the variable updates after repayment
        (
            ,
            uint256 principal,
            uint256 totalInterestRepaid,
            uint256 lastPrincipalUpdateTime,
            uint256 interestAccruedTillLastPrincipalUpdate
        ) = cl.creditLineVariables(_creditLineId);

        // if total debt is repaid, credit line is reset
        assertEq(principal, 0);
        assertEq(totalInterestRepaid, 0);
        assertEq(lastPrincipalUpdateTime, 0);
        assertEq(interestAccruedTillLastPrincipalUpdate, 0);

        user.close(creditLineAddress, _creditLineId);

        uint256 status = uint256(cl.getCreditLineStatus(_creditLineId));
        assertEq(status, 0); // Credit Line variable are deleted
    }

    function setCurrentCollRatio() public {
        vm.mockCall(
            priceOracleAddress,
            abi.encodeWithSelector(IPriceOracle.getLatestPrice.selector, address(collateralAsset), address(borrowAsset)),
            abi.encode(1000000, 8) // price, decimals
        );
    }
}",9002
RealWorld_TA_101_creditLine.PriceOracle.ActiveStage.t_RealWorld_20240812171357.log,101,creditLine.PriceOracle.ActiveStage.t,1844794,43,1844837,326.0,9.22483,"pragma solidity 0.7.6;
pragma abicoder v2;

import '../Helpers/CLParent.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../PriceOracle.sol';

import '@openzeppelin/contracts/math/SafeMath.sol';

contract CreditLine_PriceOracle_ActiveStageTests is CLParent {
    using SafeMath for uint256;

    uint256 creditLineId;
    uint256 protocolFee;
    uint256 constant SCALING_FACTOR = 1e18;
    address borrowAssetStrategy;
    address collateralStrategy;

    CreditLine creditLine;
    SavingsAccount savingsAccount;
    PriceOracle priceOracle;

    // Token deployment variables
    MockToken public testAsset;
    MockV3Aggregator public testAssetMockAggregator;
    address public testCTokenAddress;

    function setUp() public {
        CLSetUp();

        // setting up test asset for price fluctuation tests
        testAsset = new MockToken('TestAsset', 'MT2', 8, 1e40, address(admin));
        testAssetMockAggregator = new MockV3Aggregator(8, 295040576);
        testCTokenAddress = admin.deployMockCToken(address(testAsset), compoundYieldAddress, noYieldAddress);
        admin.transferOwnership(address(testAsset), testCTokenAddress);
        admin.setChainlinkFeedAddress(
            priceOracleAddress,
            address(testAsset),
            address(testAssetMockAggregator),
            Constants.CHAINLINK_HEARTBEAT
        );

        creditLine = CreditLine(creditLineAddress);
        savingsAccount = SavingsAccount(savingsAccountAddress);
        priceOracle = PriceOracle(priceOracleAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = priceOracle.getLatestPrice(address(usdc), address(borrowAsset));

        requestData.requestTo = address(lender);
        // Borrow Asset equivalent of 1,000,000,000 in USD
        requestData.borrowLimit = uint128(uint256(CLConstants.maxBorrowLimit / 1e6).mul(_ratioOfPrices).div(10**_decimals));
        requestData.borrowRate = CLConstants.maxBorrowRate / 1e18;
        requestData.autoLiquidation = false;
        requestData.collateralRatio = CLConstants.maxCollteralRatio / 1e12;
        requestData.borrowAsset = address(borrowAsset);
        requestData.borrowAssetStrategy = noYieldAddress;
        requestData.collateralAsset = address(collateralAsset);
        requestData.collateralStrategy = noYieldAddress;
        requestData.requestAsLender = false;

        creditLineId = goToActiveStage();

        // Setting global parameters
        protocolFee = creditLine.protocolFeeFraction();
        borrowAssetStrategy = requestData.borrowAssetStrategy;
        collateralStrategy = requestData.collateralStrategy;
    }

    //----------------------- Price oracle variations on Deposit collateral function -----------------------//

    //----------------------- passing tests -----------------------//

    // Zero asset prices should not affect deposit collateral function
    function test_depositCollateral_POZero1(uint256 _amount) public {
        uint256 amount = scaleToRange256(_amount, 1, collateralAsset.totalSupply());

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        // Altering price oracle results
        setAggregatorPrice(0, 0);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);
    }

    // Zero asset prices should not affect deposit collateral function
    function test_depositCollateral_POZero2(uint256 _amount) public {
        uint256 amount = scaleToRange256(_amount, 1, collateralAsset.totalSupply());

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        // Altering price oracle results
        setAggregatorPrice(195040576, 0);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);
    }

    // Zero asset prices should not affect deposit collateral function
    function test_depositCollateral_POZero3(uint256 _amount) public {
        uint256 amount = scaleToRange256(_amount, 1, collateralAsset.totalSupply());

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        // Altering price oracle results
        setAggregatorPrice(0, 12876423400040030304304);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);
    }

    // Any change in price should not affect the depositCollateral funtion
    function test_depositCollateral_fuzzPrices(
        uint128 borrowAssetPrice,
        uint128 collateralAssetPrice,
        uint256 _amount
    ) public {
        uint256 amount = scaleToRange256(_amount, 1, collateralAsset.totalSupply());

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        // Altering price oracle results
        setAggregatorPrice(borrowAssetPrice, collateralAssetPrice);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);
    }

    // Any change in ratio of prices should not affect the depositCollateral funtion
    function test_depositCollateral_POFluctuations1(uint256 _amount) public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //
        requestData.collateralAsset = address(testAsset);
        uint256 cLId = goToActiveStage();

        uint256 amount = scaleToRange256(_amount, 1, testAsset.totalSupply());

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(testAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(testAsset), amount);

        // switching asset prices
        // ratio of prices becomes inverse of original
        setAggregatorPrice(295040576, 195040576);

        borrower.addCollateral(address(creditLine), cLId, amount, false);
        assert_creditLineDeposit(cLId, amount);
    }

    // Prices going down to half should not affect the depositCollateral funtion
    function test_depositCollateral_POFluctuations2(uint256 _amount) public {
        // Initial prices //
        // collateral Asset: 12876423400040030304304 //
        // borrow Asset: 195040576 //

        uint256 amount = scaleToRange256(_amount, 1, collateralAsset.totalSupply());

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        // setting asset prices to half their initial value
        setAggregatorPrice(195040576 / 2, 12876423400040030304304 / 2);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);
    }

    // Ratio_of_prices = 1, should not affect the depositCollateral funtion
    function test_depositCollateral_POFluctuations3(uint256 _amount) public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //
        requestData.collateralAsset = address(testAsset);
        uint256 cLId = goToActiveStage();

        uint256 amount = scaleToRange256(_amount, 1, testAsset.totalSupply());

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(testAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(testAsset), amount);

        // setting asset prices to same values
        setAggregatorPrice(195040576, 195040576);

        borrower.addCollateral(address(creditLine), cLId, amount, false);
        assert_creditLineDeposit(cLId, amount);
    }

    //----------------------- Price oracle variations on Borrow function -----------------------//

    //----------------------- failing tests -----------------------//

    // Borrow should fail when both asset prices go to zero
    function test_borrow_POZero1(uint256 _borrowAmount) public {
        uint256 amount = 10_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        // Altering price oracle results
        setAggregatorPrice(0, 0);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        assertEq(borrowable, 0); // Borrowable amount goes to zero

        uint256 borrowAmount = scaleToRange256(_borrowAmount, 1, ERC20(address(borrowAsset)).totalSupply());

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowAmount);

        try borrower.borrow(address(creditLine), creditLineId, borrowAmount) {
            revert('Both asset prices are zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:B2');
        }
    }

    // Borrow should fail when either asset prices go to zero
    function test_borrow_POZero2(uint256 _borrowAmount) public {
        uint256 amount = 10_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        // Altering price oracle results
        setAggregatorPrice(195040576, 0);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        assertEq(borrowable, 0); // Borrowable amount goes to zero

        uint256 borrowAmount = scaleToRange256(_borrowAmount, 1, ERC20(address(borrowAsset)).totalSupply());

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowAmount);

        try borrower.borrow(address(creditLine), creditLineId, borrowAmount) {
            revert('Collateral asset prie is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:B2');
        }
    }

    // Borrow should fail when either asset prices go to zero
    function test_borrow_POZero3(uint256 _borrowAmount) public {
        uint256 amount = 10_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        // Altering price oracle results
        setAggregatorPrice(0, 12876423400040030304304);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        assertEq(borrowable, 0); // Borrowable amount goes to zero

        uint256 borrowAmount = scaleToRange256(_borrowAmount, 1, ERC20(address(borrowAsset)).totalSupply());

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowAmount);

        try borrower.borrow(address(creditLine), creditLineId, borrowAmount) {
            revert('Borrow asset price is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:B2');
        }
    }

    //----------------------- passing tests -----------------------//

    // Any change in price should not affect the borrow funtion, except zero values
    function test_borrow_fuzzPrices(
        uint128 _borrowAssetPrice,
        uint128 _collateralAssetPrice,
        uint256 _borrowAmount
    ) public {
        uint256 amount = 10_000 * 10**ERC20(address(collateralAsset)).decimals();
        uint256 borrowAssetPrice = scaleToRange256(_borrowAssetPrice, 1, type(uint128).max);
        uint256 collateralAssetPrice = scaleToRange256(_collateralAssetPrice, 1, type(uint128).max);

        // RatioOfPrice will not go beyond 1e30 in practical scenarios
        // Limiting RatioOfPrice.mul(1e18) <= 1e30
        if (collateralAssetPrice.div(borrowAssetPrice) <= 1e12) {
            // Adding tokens to borrower and setting allowance for creditline contract
            admin.transferToken(address(collateralAsset), address(borrower), amount);
            borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

            borrower.addCollateral(address(creditLine), creditLineId, amount, false);
            assert_creditLineDeposit(creditLineId, amount);

            // Altering price oracle results
            setAggregatorPrice(borrowAssetPrice, collateralAssetPrice);

            uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);
            if (borrowable > 0) {
                uint256 borrowAmount = scaleToRange256(_borrowAmount, 1, borrowable);

                // Adding tokens to lender and depositing to lender's savings Account
                savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowAmount);

                borrower.borrow(address(creditLine), creditLineId, borrowAmount);
                assert_creditLineBorrow(creditLineId, borrowAmount);
            }
        }
    }

    // Ratio_of_prices = 0, should not affect the borrow function
    function test_borrow_POFluctuations1(uint256 _borrowAmount) public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //
        requestData.collateralAsset = address(testAsset);
        uint256 cLId = goToActiveStage();

        uint256 amount = 10_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(testAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(testAsset), amount);

        borrower.addCollateral(address(creditLine), cLId, amount, false);
        assert_creditLineDeposit(cLId, amount);

        // setting asset prices to invert Ratio of prices
        setAggregatorPrice(295040576, 195040576);

        uint256 borrowable = creditLine.calculateBorrowableAmount(cLId);

        uint256 borrowAmount = scaleToRange256(_borrowAmount, 1, borrowable);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowAmount);

        borrower.borrow(address(creditLine), cLId, borrowAmount);
        assert_creditLineBorrow(cLId, borrowAmount);
    }

    // Ratio_of_prices = 1, should not affect the borrow funtion
    function test_borrow_POFluctuations2(uint256 _borrowAmount) public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //
        requestData.collateralAsset = address(testAsset);
        uint256 cLId = goToActiveStage();

        uint256 amount = 10_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(testAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(testAsset), amount);

        borrower.addCollateral(address(creditLine), cLId, amount, false);
        assert_creditLineDeposit(cLId, amount);

        // setting asset prices to same values
        setAggregatorPrice(195040576, 195040576);

        uint256 borrowable = creditLine.calculateBorrowableAmount(cLId);

        uint256 borrowAmount = scaleToRange256(_borrowAmount, 1, borrowable);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowAmount);

        borrower.borrow(address(creditLine), cLId, borrowAmount);
        assert_creditLineBorrow(cLId, borrowAmount);
    }

    // Prices going down to half should not affect the depositCollateral funtion
    function test_borrow_POFluctuations3(uint256 _borrowAmount) public {
        // Initial prices //
        // collateral Asset: 12876423400040030304304 //
        // borrow Asset: 195040576 //

        uint256 amount = 10_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        // setting asset prices to half their initial value
        setAggregatorPrice(195040576 / 2, 12876423400040030304304 / 2);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        uint256 borrowAmount = scaleToRange256(_borrowAmount, 1, borrowable);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowAmount);

        borrower.borrow(address(creditLine), creditLineId, borrowAmount);
        assert_creditLineBorrow(creditLineId, borrowAmount);
    }

    //----------------------- Price oracle variations on calculate borrowable Amount function -----------------------//

    // Inverted Ratio_of_prices should not affect the calculate borrowable Amount function
    function test_calculateBorrowableAmount_POFluctuations1(uint256 _amount) public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //
        requestData.collateralAsset = address(testAsset);
        uint256 cLId = goToActiveStage();

        uint256 amount = scaleToRange256(_amount, 1, requestData.borrowLimit - 1);

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(testAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(testAsset), amount);

        borrower.addCollateral(address(creditLine), cLId, amount, false);
        assert_creditLineDeposit(cLId, amount);

        // setting asset prices to invert Ratio of prices
        setAggregatorPrice(295040576, 195040576);

        uint256 totalCollateral = creditLine.calculateTotalCollateralTokens(cLId);
        assertEq(totalCollateral, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(cLId);
        uint256 calculatedBorrowable = amount.mul(195040576).div(295040576);
        assertApproxEqRel(borrowable, calculatedBorrowable, 1e14);
    }

    // Ratio_of_prices = 1, should not affect the calculate borrowable Amount funtion
    function test_calculateBorrowableAmount_POFluctuations2(uint256 _amount) public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //
        requestData.collateralAsset = address(testAsset);
        uint256 cLId = goToActiveStage();

        uint256 amount = scaleToRange256(_amount, 1, requestData.borrowLimit - 1);

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(testAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(testAsset), amount);

        borrower.addCollateral(address(creditLine), cLId, amount, false);
        assert_creditLineDeposit(cLId, amount);

        // setting asset prices to same values
        setAggregatorPrice(195040576, 195040576);

        uint256 totalCollateral = creditLine.calculateTotalCollateralTokens(cLId);
        assertEq(totalCollateral, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(cLId);
        assertEq(borrowable, amount);
    }

    //----------------------- Price oracle variations on Withdrawing collateral function -----------------------//

    //----------------------- failing tests -----------------------//

    // withdraw collateral should fail when both asset prices become zero
    function test_withdrawCollateral_POZero1() public {
        uint256 amount = 10_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);
        assert_creditLineBorrow(creditLineId, borrowable);

        // Altering price oracle results
        setAggregatorPrice(0, 0);

        try borrower.withdrawCollateral(creditLineAddress, creditLineId, amount, false) {
            revert('Both asset prices are zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'SafeMath: division by zero');
        }
    }

    // withdraw collateral should fail when either asset prices becomes zero
    function test_withdrawCollateral_POZero2() public {
        uint256 amount = 10_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);
        assert_creditLineBorrow(creditLineId, borrowable);

        // Altering price oracle results
        setAggregatorPrice(195040576, 0);

        try borrower.withdrawCollateral(creditLineAddress, creditLineId, amount, false) {
            revert('Collateral asset price is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'SafeMath: division by zero');
        }
    }

    // withdraw collateral should fail when either asset prices becomes zero
    function test_withdrawCollateral_POZero3() public {
        uint256 amount = 10_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);
        assert_creditLineBorrow(creditLineId, borrowable);

        // Altering price oracle results
        setAggregatorPrice(0, 12876423400040030304304);

        try borrower.withdrawCollateral(creditLineAddress, creditLineId, amount, false) {
            revert('Borrow asset price is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'SafeMath: division by zero');
        }
    }

    //----------------------- passing tests -----------------------//

    // Any change in price should not affect the withdraw Collateral funtion
    function test_withdrawCollateral_fuzzPrices(
        uint128 borrowAssetPrice,
        uint128 collateralAssetPrice,
        uint256 _withdrawAmount
    ) public {
        uint256 amount = 10_000 * 10**ERC20(address(collateralAsset)).decimals();
        uint256 withdrawAmount = scaleToRange256(_withdrawAmount, 1, collateralAsset.totalSupply());

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        if (borrowable > 0) {
            // Adding tokens to lender and depositing to lender's savings Account
            savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

            borrower.borrow(address(creditLine), creditLineId, borrowable);
            assert_creditLineBorrow(creditLineId, borrowable);

            // Altering price oracle results
            setAggregatorPrice(borrowAssetPrice, collateralAssetPrice);

            uint256 balanceBorrower = collateralAsset.balanceOf(address(borrower));
            try borrower.withdrawCollateral(creditLineAddress, creditLineId, withdrawAmount, false) {
                uint256 balanceBorrowerAfter = collateralAsset.balanceOf(address(borrower));
                assertEq(withdrawAmount, balanceBorrowerAfter.sub(balanceBorrower));
            } catch Error(string memory reason) {
                if (compareStrings(reason, 'SafeMath: division by zero')) {
                    emit log_string('Zero Price Oracle');
                } else if (compareStrings(reason, 'CL:WC3')) {
                    emit log_string('amount > WithdrawableCollateral');
                } else {
                    revert(reason);
                }
            }
        }
    }

    // ratio_of_price = inverse, should not affect withdraw collateral function
    function test_withdrawCollateral_POFluctuations1(uint256 _withdrawAmount) public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //
        requestData.collateralAsset = address(testAsset);
        uint256 cLId = goToActiveStage();

        uint256 amount = 1_000 * 10**testAsset.decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(testAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(testAsset), amount);

        borrower.addCollateral(address(creditLine), cLId, amount, false);
        assert_creditLineDeposit(cLId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(cLId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), cLId, borrowable);
        assert_creditLineBorrow(cLId, borrowable);

        // setting asset prices to invert Ratio of prices
        setAggregatorPrice(295040576, 195040576);

        uint256 withdrawable = creditLine.withdrawableCollateral(cLId);
        if (withdrawable > 0) {
            uint256 wthdrawAmount = scaleToRange256(_withdrawAmount, 1, withdrawable);

            uint256 balanceBorrower = testAsset.balanceOf(address(borrower));
            borrower.withdrawCollateral(creditLineAddress, cLId, wthdrawAmount, false);
            uint256 balanceBorrowerAfter = testAsset.balanceOf(address(borrower));
            assertEq(wthdrawAmount, balanceBorrowerAfter.sub(balanceBorrower));
        }
    }

    // Prices going down to half should not affect the withdraw Collateral funtion
    function test_withdrawCollateral_POFluctuations2(uint256 _withdrawAmount) public {
        // Initial prices //
        // collateral Asset: 12876423400040030304304 //
        // borrow Asset: 195040576 //

        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);
        assert_creditLineBorrow(creditLineId, borrowable);

        // setting asset prices to half their initial value
        setAggregatorPrice(195040576 / 2, 12876423400040030304304 / 2);

        uint256 withdrawable = creditLine.withdrawableCollateral(creditLineId);
        if (withdrawable > 0) {
            uint256 wthdrawAmount = scaleToRange256(_withdrawAmount, 1, withdrawable);

            uint256 balanceBorrower = collateralAsset.balanceOf(address(borrower));
            borrower.withdrawCollateral(creditLineAddress, creditLineId, wthdrawAmount, false);
            uint256 balanceBorrowerAfter = collateralAsset.balanceOf(address(borrower));
            assertEq(wthdrawAmount, balanceBorrowerAfter.sub(balanceBorrower));
        }
    }

    // Ratio_of_prices = 1, should not affect the withdraw Collateral funtion
    function test_withdrawCollateral_POFluctuations3(uint256 _withdrawAmount) public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //
        requestData.collateralAsset = address(testAsset);
        uint256 cLId = goToActiveStage();

        uint256 amount = 1_000 * 10**testAsset.decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(testAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(testAsset), amount);

        borrower.addCollateral(address(creditLine), cLId, amount, false);
        assert_creditLineDeposit(cLId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(cLId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), cLId, borrowable);
        assert_creditLineBorrow(cLId, borrowable);

        // setting asset prices to same values
        setAggregatorPrice(195040576, 195040576);

        uint256 withdrawable = creditLine.withdrawableCollateral(cLId);
        if (withdrawable > 0) {
            uint256 wthdrawAmount = scaleToRange256(_withdrawAmount, 1, withdrawable);

            uint256 balanceBorrower = testAsset.balanceOf(address(borrower));
            borrower.withdrawCollateral(creditLineAddress, cLId, wthdrawAmount, false);
            uint256 balanceBorrowerAfter = testAsset.balanceOf(address(borrower));
            assertEq(wthdrawAmount, balanceBorrowerAfter.sub(balanceBorrower));
        }
    }

    //----------------------- Price oracle variations on Withdrawable collateral function -----------------------//

    // ratio_of_price = inverse, should  not affect withdraw collateral function
    function test_withdrawableCollateral_POFluctuations1() public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //
        requestData.collateralAsset = address(testAsset);
        uint256 cLId = goToActiveStage();

        uint256 amount = 1_000 * 10**testAsset.decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(testAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(testAsset), amount);

        borrower.addCollateral(address(creditLine), cLId, amount, false);
        assert_creditLineDeposit(cLId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(cLId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), cLId, borrowable);
        assert_creditLineBorrow(cLId, borrowable);

        // setting asset prices to invert Ratio of prices
        setAggregatorPrice(295040576, 195040576);

        uint256 withdrawable = creditLine.withdrawableCollateral(cLId);
        uint256 collateralNeeded = borrowable.mul(295040576).div(195040576);

        if (amount > collateralNeeded) {
            assertEq(withdrawable, amount.sub(collateralNeeded));
        } else {
            assertEq(withdrawable, 0);
        }
    }

    // Ratio_of_prices = 1, should not affect the withdraw Collateral funtion
    function test_withdrawableCollateral_POFluctuations2() public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //
        requestData.collateralAsset = address(testAsset);
        uint256 cLId = goToActiveStage();

        uint256 amount = 1_000 * 10**testAsset.decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(testAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(testAsset), amount);

        borrower.addCollateral(address(creditLine), cLId, amount, false);
        assert_creditLineDeposit(cLId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(cLId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), cLId, borrowable);
        assert_creditLineBorrow(cLId, borrowable);

        // setting asset prices to same values
        setAggregatorPrice(195040576, 195040576);

        uint256 withdrawable = creditLine.withdrawableCollateral(cLId);

        if (amount > borrowable) {
            assertEq(withdrawable, amount.sub(borrowable));
        } else {
            assertEq(withdrawable, 0);
        }
    }

    //----------------------- Price oracle variations on Withdrawing All collateral function -----------------------//

    //----------------------- failing tests -----------------------//

    // withdraw all collateral fails when both asset prices become zero
    function test_withdrawAllCollateral_POZero1() public {
        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);
        assert_creditLineBorrow(creditLineId, borrowable);

        // Altering price oracle results
        setAggregatorPrice(0, 0);

        try borrower.withdrawAllCollateral(creditLineAddress, creditLineId, false) {
            revert('Both asset prices are zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'SafeMath: division by zero');
        }
    }

    // withdraw all collateral fails when either asset prices becomes zero
    function test_withdrawAllCollateral_POZero2() public {
        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);
        assert_creditLineBorrow(creditLineId, borrowable);

        // Altering price oracle results
        setAggregatorPrice(195040576, 0);

        try borrower.withdrawAllCollateral(creditLineAddress, creditLineId, false) {
            revert('Collateral asset price is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'SafeMath: division by zero');
        }
    }

    // withdraw all collateral fails when either asset prices becomes zero
    function test_withdrawAllCollateral_POZero3() public {
        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);
        assert_creditLineBorrow(creditLineId, borrowable);

        // Altering price oracle results
        setAggregatorPrice(0, 12876423400040030304304);

        try borrower.withdrawAllCollateral(creditLineAddress, creditLineId, false) {
            revert('Borrow asset price is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'SafeMath: division by zero');
        }
    }

    //----------------------- passing tests -----------------------//

    // Any change in price should not affect the withdraw all collateral funtion, except zero values
    function test_withdrawAllCollateral_fuzzPrices(uint128 borrowAssetPrice, uint128 collateralAssetPrice) public {
        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();
        uint256 _withdrawAmount;

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        if (borrowable > 0) {
            // Adding tokens to lender and depositing to lender's savings Account
            savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

            borrower.borrow(address(creditLine), creditLineId, borrowable);
            assert_creditLineBorrow(creditLineId, borrowable);

            // Altering price oracle results
            setAggregatorPrice(borrowAssetPrice, collateralAssetPrice);

            try creditLine.withdrawableCollateral(creditLineId) {
                _withdrawAmount = creditLine.withdrawableCollateral(creditLineId);
            } catch Error(string memory reason) {
                assertEq(reason, 'SafeMath: division by zero');
            }

            uint256 balanceBorrower = collateralAsset.balanceOf(address(borrower));
            try borrower.withdrawAllCollateral(creditLineAddress, creditLineId, false) {
                uint256 balanceBorrowerAfter = collateralAsset.balanceOf(address(borrower));
                assertEq(_withdrawAmount, balanceBorrowerAfter.sub(balanceBorrower));
            } catch Error(string memory reason) {
                if (compareStrings(reason, 'SafeMath: division by zero')) {
                    emit log_string('Zero Price Oracle');
                } else if (compareStrings(reason, 'SA:WS1')) {
                    emit log_string('amount=0');
                } else {
                    revert(reason);
                }
            }
        }
    }

    // Inverting ratio of prices should not affect withdraw all collateral function
    function test_withdrawAllCollateral_POFluctuations1() public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //
        requestData.collateralAsset = address(testAsset);
        uint256 cLId = goToActiveStage();

        uint256 amount = 1_000 * 10**testAsset.decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(testAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(testAsset), amount);

        borrower.addCollateral(address(creditLine), cLId, amount, false);
        assert_creditLineDeposit(cLId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(cLId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), cLId, borrowable);
        assert_creditLineBorrow(cLId, borrowable);

        // setting asset prices to invert Ratio of prices
        setAggregatorPrice(295040576, 195040576);

        uint256 withdrawAmount = creditLine.withdrawableCollateral(cLId);
        if (withdrawAmount > 0) {
            uint256 balanceBorrower = testAsset.balanceOf(address(borrower));
            borrower.withdrawAllCollateral(creditLineAddress, cLId, false);
            uint256 balanceBorrowerAfter = testAsset.balanceOf(address(borrower));
            assertEq(withdrawAmount, balanceBorrowerAfter.sub(balanceBorrower));
        }
    }

    // Prices going down to half should not affect the withdraw all collateral funtion
    function test_withdrawAllCollateral_POFluctuations2() public {
        // Initial prices //
        // collateral Asset: 12876423400040030304304 //
        // borrow Asset: 195040576 //

        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);
        assert_creditLineBorrow(creditLineId, borrowable);

        // setting asset prices to half their initial value
        setAggregatorPrice(195040576 / 2, 12876423400040030304304 / 2);

        uint256 _withdrawAmount = creditLine.withdrawableCollateral(creditLineId);
        uint256 balanceBorrower = collateralAsset.balanceOf(address(borrower));
        borrower.withdrawAllCollateral(creditLineAddress, creditLineId, false);
        uint256 balanceBorrowerAfter = collateralAsset.balanceOf(address(borrower));
        assertEq(_withdrawAmount, balanceBorrowerAfter.sub(balanceBorrower));
    }

    // Ratio_of_prices = 1, should not affect the withdraw all collateral funtion
    function test_withdrawAllCollateral_POFluctuations3() public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //
        requestData.collateralAsset = address(testAsset);
        uint256 cLId = goToActiveStage();

        uint256 amount = 1_000 * 10**testAsset.decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(testAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(testAsset), amount);

        borrower.addCollateral(address(creditLine), cLId, amount, false);
        assert_creditLineDeposit(cLId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(cLId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), cLId, borrowable);
        assert_creditLineBorrow(cLId, borrowable);

        // setting asset prices to same values
        setAggregatorPrice(195040576, 195040576);

        uint256 withdrawAmount = creditLine.withdrawableCollateral(cLId);
        if (withdrawAmount > 0) {
            uint256 balanceBorrower = testAsset.balanceOf(address(borrower));
            borrower.withdrawAllCollateral(creditLineAddress, cLId, false);
            uint256 balanceBorrowerAfter = testAsset.balanceOf(address(borrower));
            assertEq(withdrawAmount, balanceBorrowerAfter.sub(balanceBorrower));
        }
    }

    //----------------------- Price oracle variations on liquidate function -----------------------//

    //----------------------- failing tests -----------------------//

    // liquidate function should fail when both asset prices become zero
    function test_liquidate_POZero1() public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);
        assert_creditLineBorrow(creditLineId, borrowable);

        // Altering price oracle results
        setAggregatorPrice(0, 0);

        try lender.liquidate(creditLineAddress, creditLineId, false) {
            revert('Both asset prices are zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'SafeMath: division by zero');
        }
    }

    // liquidate function should fail when either asset prices becomes zero
    function test_liquidate_POZero2() public {
        uint256 amount = 100 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);
        assert_creditLineBorrow(creditLineId, borrowable);

        // Altering price oracle results
        setAggregatorPrice(195040576, 0);

        try lender.liquidate(creditLineAddress, creditLineId, false) {
            revert('Collateral asset price is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'SafeMath: division by zero');
        }
    }

    // liquidate function should fail when either asset prices becomes zero
    function test_liquidate_POZero3() public {
        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);
        assert_creditLineBorrow(creditLineId, borrowable);

        // Altering price oracle results
        setAggregatorPrice(0, 12876423400040030304304);

        try lender.liquidate(creditLineAddress, creditLineId, false) {
            revert('Borrow asset price is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'SafeMath: division by zero');
        }
    }

    //----------------------- passing tests -----------------------//

    // Any change in price should not affect the liquidate funtion, except zero values
    function test_liquidate_fuzzPrices(uint128 _borrowAssetPrice, uint128 _collateralAssetPrice) public {
        uint256 amount = 10_000 * 10**ERC20(address(collateralAsset)).decimals();
        uint256 borrowAssetPrice = scaleToRange256(_borrowAssetPrice, 1, type(uint128).max);
        uint256 collateralAssetPrice = scaleToRange256(_collateralAssetPrice, 1, type(uint128).max);

        // RatioOfPrice will not go beyond 1e30 in practical scenarios
        // Limiting RatioOfPrice.mul(1e18) <= 1e30
        if (collateralAssetPrice.div(borrowAssetPrice) <= 1e12) {
            // Adding tokens to borrower and setting allowance for creditline contract
            admin.transferToken(address(collateralAsset), address(borrower), amount);
            borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

            borrower.addCollateral(address(creditLine), creditLineId, amount, false);
            assert_creditLineDeposit(creditLineId, amount);

            uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);
            if (borrowable > 0) {
                // Adding tokens to lender and depositing to lender's savings Account
                savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

                borrower.borrow(address(creditLine), creditLineId, borrowable);
                assert_creditLineBorrow(creditLineId, borrowable);

                // Altering price oracle results
                setAggregatorPrice(borrowAssetPrice, collateralAssetPrice);

                uint256 lenderBalance = collateralAsset.balanceOf(address(lender));
                try lender.liquidate(creditLineAddress, creditLineId, false) {
                    uint256 lenderBalanceAfter = collateralAsset.balanceOf(address(lender));
                    assertEq(amount, lenderBalanceAfter.sub(lenderBalance));

                    uint256 status = uint256(creditLine.getCreditLineStatus(creditLineId));
                    assertEq(status, 0); // Credit line variables are deleted
                } catch Error(string memory reason) {
                    if (compareStrings(reason, 'SafeMath: division by zero')) {
                        emit log_string('Zero Price Oracle');
                    } else if (compareStrings(reason, 'CL:L3')) {
                        emit log_string('Collateral Ratio is not disturbed');
                    } else {
                        revert(reason);
                    }
                }
            }
        }
    }

    // Inverted ratio of prices should not affect the liquidate funtion
    function test_liquidate_POFluctuations1() public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //
        requestData.collateralAsset = address(testAsset);
        uint256 cLId = goToActiveStage();

        uint256 amount = 1_000 * 10**testAsset.decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(testAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(testAsset), amount);

        borrower.addCollateral(address(creditLine), cLId, amount, false);
        assert_creditLineDeposit(cLId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(cLId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), cLId, borrowable);
        assert_creditLineBorrow(cLId, borrowable);

        // setting asset prices to same values
        setAggregatorPrice(295040576, 195040576);

        uint256 lenderBalance = testAsset.balanceOf(address(lender));
        try lender.liquidate(creditLineAddress, cLId, false) {
            uint256 lenderBalanceAfter = testAsset.balanceOf(address(lender));
            assertEq(amount, lenderBalanceAfter.sub(lenderBalance));

            uint256 status = uint256(creditLine.getCreditLineStatus(cLId));
            assertEq(status, 0); // Credit line variables are deleted
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:L3');
        }
    }

    // Prices going down to half should not affect the liquidate funtion
    function test_liquidate_POFluctuations2() public {
        // Initial prices //
        // collateral Asset: 12876423400040030304304 //
        // borrow Asset: 195040576 //

        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);
        assert_creditLineBorrow(creditLineId, borrowable);

        // setting asset prices to half their initial value
        setAggregatorPrice(195040576 / 2, 12876423400040030304304 / 2);

        try lender.liquidate(creditLineAddress, creditLineId, false) {
            uint256 status = uint256(creditLine.getCreditLineStatus(creditLineId));
            assertEq(status, 0); // Credit line variables are deleted
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:L3');
        }
    }

    // Ratio_of_prices = 1, should not affect the liquidate funtion
    function test_liquidate_POFluctuations3() public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //
        requestData.collateralAsset = address(testAsset);
        uint256 cLId = goToActiveStage();

        uint256 amount = 1_000 * 10**testAsset.decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(testAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(testAsset), amount);

        borrower.addCollateral(address(creditLine), cLId, amount, false);
        assert_creditLineDeposit(cLId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(cLId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), cLId, borrowable);
        assert_creditLineBorrow(cLId, borrowable);

        // setting asset prices to same values
        setAggregatorPrice(195040576, 195040576);

        uint256 lenderBalance = testAsset.balanceOf(address(lender));
        try lender.liquidate(creditLineAddress, cLId, false) {
            uint256 lenderBalanceAfter = testAsset.balanceOf(address(lender));
            assertEq(amount, lenderBalanceAfter.sub(lenderBalance));

            uint256 status = uint256(creditLine.getCreditLineStatus(cLId));
            assertEq(status, 0); // Credit line variables are deleted
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:L3');
        }
    }

    //----------------------- Price oracle variations on borrowTokensToLiquidate function -----------------------//

    function test_borrowTokensToLiquidate_POFluctuations1() public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //
        requestData.collateralAsset = address(testAsset);
        uint256 cLId = goToActiveStage();

        uint256 amount = 1_000 * 10**testAsset.decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(testAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(testAsset), amount);

        borrower.addCollateral(address(creditLine), cLId, amount, false);
        assert_creditLineDeposit(cLId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(cLId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), cLId, borrowable);
        assert_creditLineBorrow(cLId, borrowable);

        // setting asset prices to same values
        setAggregatorPrice(295040576, 195040576);

        uint256 borrowTokensToLiquidate = creditLine.borrowTokensToLiquidate(cLId);
        uint256 equivalentCollateral = borrowable.mul(295040576).div(195040576);

        if (equivalentCollateral > amount) {
            uint256 tokensToLiquidate = amount
                .mul(uint256(SCALING_FACTOR).sub(CLConstants.liquidatorRewardFraction))
                .div(SCALING_FACTOR)
                .mul(195040576)
                .div(295040576);
            assertEq(borrowTokensToLiquidate, tokensToLiquidate);
        } else {
            uint256 tokensToLiquidate = equivalentCollateral
                .mul(uint256(SCALING_FACTOR).sub(CLConstants.liquidatorRewardFraction))
                .div(SCALING_FACTOR)
                .mul(195040576)
                .div(295040576);
            assertEq(borrowTokensToLiquidate, tokensToLiquidate);
        }
    }

    function test_borrowTokensToLiquidate_POFluctuations2() public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //
        requestData.collateralAsset = address(testAsset);
        uint256 cLId = goToActiveStage();

        uint256 amount = 1_000 * 10**testAsset.decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(testAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(testAsset), amount);

        borrower.addCollateral(address(creditLine), cLId, amount, false);
        assert_creditLineDeposit(cLId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(cLId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), cLId, borrowable);
        assert_creditLineBorrow(cLId, borrowable);

        // setting asset prices to same values
        setAggregatorPrice(195040576, 195040576);

        uint256 borrowTokensToLiquidate = creditLine.borrowTokensToLiquidate(cLId);
        if (borrowable > amount) {
            uint256 tokensToLiquidate = amount.mul(uint256(SCALING_FACTOR).sub(CLConstants.liquidatorRewardFraction)).div(SCALING_FACTOR);
            assertEq(borrowTokensToLiquidate, tokensToLiquidate);
        } else {
            uint256 tokensToLiquidate = borrowable.mul(uint256(SCALING_FACTOR).sub(CLConstants.liquidatorRewardFraction)).div(
                SCALING_FACTOR
            );
            assertEq(borrowTokensToLiquidate, tokensToLiquidate);
        }
    }

    //----------------------- Price oracle variations on currentCollateralRatio function -----------------------//

    function test_currentCollateralRatio_POFluctuations1() public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //
        requestData.collateralAsset = address(testAsset);
        uint256 cLId = goToActiveStage();

        uint256 amount = 1_000 * 10**testAsset.decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(testAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(testAsset), amount);

        borrower.addCollateral(address(creditLine), cLId, amount, false);
        assert_creditLineDeposit(cLId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(cLId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), cLId, borrowable);
        assert_creditLineBorrow(cLId, borrowable);

        // setting asset prices to same values
        setAggregatorPrice(295040576, 195040576);

        (uint256 collateralRatio, uint256 totalCollateral) = creditLine.calculateCurrentCollateralRatio(cLId);
        uint256 calculatedCR = amount.mul(195040576).div(295040576).mul(1e18).div(borrowable);
        assertEq(totalCollateral, amount);
        assertEq(collateralRatio, calculatedCR);
    }

    function test_currentCollateralRatio_POFluctuations2() public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //
        requestData.collateralAsset = address(testAsset);
        uint256 cLId = goToActiveStage();

        uint256 amount = 1_000 * 10**testAsset.decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(testAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(testAsset), amount);

        borrower.addCollateral(address(creditLine), cLId, amount, false);
        assert_creditLineDeposit(cLId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(cLId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), cLId, borrowable);
        assert_creditLineBorrow(cLId, borrowable);

        // setting asset prices to same values
        setAggregatorPrice(195040576, 195040576);

        (uint256 collateralRatio, uint256 totalCollateral) = creditLine.calculateCurrentCollateralRatio(cLId);
        uint256 calculatedCR = amount.mul(1e18).div(borrowable);
        assertEq(totalCollateral, amount);
        assertEq(collateralRatio, calculatedCR);
    }

    //----------------------- Price oracle variations on repay function -----------------------//

    //----------------------- passing tests -----------------------//

    // Repay function should not fail if both asset prices become zero
    function test_repay_POZero1(uint256 _repayAmount) public {
        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);
        assert_creditLineBorrow(creditLineId, borrowable);

        _increaseBlock(block.timestamp + 10 days); // time travel by 10 days

        // Altering price oracle results
        setAggregatorPrice(0, 0);

        uint256 debt = creditLine.calculateCurrentDebt(creditLineId);
        uint256 repayAmount = scaleToRange256(_repayAmount, 1, debt);

        // add balance to user
        admin.transferToken(address(borrowAsset), address(borrower), repayAmount);
        borrower.setAllowance(address(creditLine), address(borrowAsset), repayAmount);

        // getting balance of the user before repayment
        uint256 balanceBefore = IERC20(borrowAsset).balanceOf(address(borrower));

        // repay the credit line
        borrower.repay(address(creditLine), creditLineId, repayAmount);

        // getting the balance after repayment
        uint256 balanceAfter = IERC20(borrowAsset).balanceOf(address(borrower));

        // assert: balance change for user should be equal to amount repaid
        uint256 balanceDiff = balanceBefore.sub(balanceAfter);
        assertEq(balanceDiff, repayAmount);
    }

    // Repay function should not fail if either asset prices becomes zero
    function test_repay_POZero2(uint256 _repayAmount) public {
        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);
        assert_creditLineBorrow(creditLineId, borrowable);

        _increaseBlock(block.timestamp + 10 days); // time travel by 10 days

        // Altering price oracle results
        setAggregatorPrice(195040576, 0);

        uint256 debt = creditLine.calculateCurrentDebt(creditLineId);
        uint256 repayAmount = scaleToRange256(_repayAmount, 1, debt);

        // add balance to user
        admin.transferToken(address(borrowAsset), address(borrower), repayAmount);
        borrower.setAllowance(address(creditLine), address(borrowAsset), repayAmount);

        // getting balance of the user before repayment
        uint256 balanceBefore = IERC20(borrowAsset).balanceOf(address(borrower));

        // repay the credit line
        borrower.repay(address(creditLine), creditLineId, repayAmount);

        // getting the balance after repayment
        uint256 balanceAfter = IERC20(borrowAsset).balanceOf(address(borrower));

        // assert: balance change for user should be equal to amount repaid
        uint256 balanceDiff = balanceBefore.sub(balanceAfter);
        assertEq(balanceDiff, repayAmount);
    }

    // Repay function should not fail if either asset prices becomes zero
    function test_repay_POZero3(uint256 _repayAmount) public {
        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);
        assert_creditLineBorrow(creditLineId, borrowable);

        _increaseBlock(block.timestamp + 10 days); // time travel by 10 days

        // Altering price oracle results
        setAggregatorPrice(0, 12876423400040030304304);

        uint256 debt = creditLine.calculateCurrentDebt(creditLineId);
        uint256 repayAmount = scaleToRange256(_repayAmount, 1, debt);

        // add balance to user
        admin.transferToken(address(borrowAsset), address(borrower), repayAmount);
        borrower.setAllowance(address(creditLine), address(borrowAsset), repayAmount);

        // getting balance of the user before repayment
        uint256 balanceBefore = IERC20(borrowAsset).balanceOf(address(borrower));

        // repay the credit line
        borrower.repay(address(creditLine), creditLineId, repayAmount);

        // getting the balance after repayment
        uint256 balanceAfter = IERC20(borrowAsset).balanceOf(address(borrower));

        // assert: balance change for user should be equal to amount repaid
        uint256 balanceDiff = balanceBefore.sub(balanceAfter);
        assertEq(balanceDiff, repayAmount);
    }

    // Any change in price should not affect the repay funtion
    function test_repay_fuzzPrices(
        uint128 borrowAssetPrice,
        uint128 collateralAssetPrice,
        uint256 _repayAmount
    ) public {
        uint256 amount = 10_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        if (borrowable > 0) {
            // Adding tokens to lender and depositing to lender's savings Account
            savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

            borrower.borrow(address(creditLine), creditLineId, borrowable);
            assert_creditLineBorrow(creditLineId, borrowable);

            _increaseBlock(block.timestamp + 10 days); // time travel by 10 days

            // Altering price oracle results
            setAggregatorPrice(borrowAssetPrice, collateralAssetPrice);

            uint256 debt = creditLine.calculateCurrentDebt(creditLineId);
            uint256 repayAmount = scaleToRange256(_repayAmount, 1, debt);

            // add balance to user
            admin.transferToken(address(borrowAsset), address(borrower), repayAmount);
            borrower.setAllowance(address(creditLine), address(borrowAsset), repayAmount);

            // getting balance of the user before repayment
            uint256 balanceBefore = IERC20(borrowAsset).balanceOf(address(borrower));

            // repay the credit line
            borrower.repay(address(creditLine), creditLineId, repayAmount);

            // getting the balance after repayment
            uint256 balanceAfter = IERC20(borrowAsset).balanceOf(address(borrower));

            // assert: balance change for user should be equal to amount repaid
            uint256 balanceDiff = balanceBefore.sub(balanceAfter);
            assertEq(balanceDiff, repayAmount);
        }
    }

    // Inverted ratio of prices should not affect the repay funtion
    function test_repay_POFluctuations1(uint256 _repayAmount) public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //
        requestData.collateralAsset = address(testAsset);
        uint256 cLId = goToActiveStage();

        uint256 amount = 1_000 * 10**testAsset.decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(testAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(testAsset), amount);

        borrower.addCollateral(address(creditLine), cLId, amount, false);
        assert_creditLineDeposit(cLId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(cLId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), cLId, borrowable);
        assert_creditLineBorrow(cLId, borrowable);

        _increaseBlock(block.timestamp + 10 days); // time travel by 10 days

        // setting asset prices to same values
        setAggregatorPrice(295040576, 195040576);

        uint256 debt = creditLine.calculateCurrentDebt(creditLineId);
        if (debt > 0) {
            uint256 repayAmount = scaleToRange256(_repayAmount, 1, debt);

            // add balance to user
            admin.transferToken(address(borrowAsset), address(borrower), repayAmount);
            borrower.setAllowance(address(creditLine), address(borrowAsset), repayAmount);

            // getting balance of the user before repayment
            uint256 balanceBefore = IERC20(borrowAsset).balanceOf(address(borrower));

            // repay the credit line
            borrower.repay(address(creditLine), cLId, repayAmount);

            // getting the balance after repayment
            uint256 balanceAfter = IERC20(borrowAsset).balanceOf(address(borrower));

            // assert: balance change for user should be equal to amount repaid
            uint256 balanceDiff = balanceBefore.sub(balanceAfter);
            assertEq(balanceDiff, repayAmount);
        }
    }

    // Prices going down to half should not affect the repay funtion
    function test_repay_POFluctuations2(uint256 _repayAmount) public {
        // Initial prices //
        // collateral Asset: 12876423400040030304304 //
        // borrow Asset: 195040576 //

        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);
        assert_creditLineBorrow(creditLineId, borrowable);

        _increaseBlock(block.timestamp + 10 days); // time travel by 10 days

        // setting asset prices to half their initial value
        setAggregatorPrice(195040576 / 2, 12876423400040030304304 / 2);

        uint256 debt = creditLine.calculateCurrentDebt(creditLineId);
        if (debt > 0) {
            uint256 repayAmount = scaleToRange256(_repayAmount, 1, debt);

            // add balance to user
            admin.transferToken(address(borrowAsset), address(borrower), repayAmount);
            borrower.setAllowance(address(creditLine), address(borrowAsset), repayAmount);

            // getting balance of the user before repayment
            uint256 balanceBefore = IERC20(borrowAsset).balanceOf(address(borrower));

            // repay the credit line
            borrower.repay(address(creditLine), creditLineId, repayAmount);

            // getting the balance after repayment
            uint256 balanceAfter = IERC20(borrowAsset).balanceOf(address(borrower));

            // assert: balance change for user should be equal to amount repaid
            uint256 balanceDiff = balanceBefore.sub(balanceAfter);
            assertEq(balanceDiff, repayAmount);
        }
    }

    // Ratio_of_prices = 1, should not affect the repay funtion
    function test_repay_POFluctuations3(uint256 _repayAmount) public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //
        requestData.collateralAsset = address(testAsset);
        uint256 cLId = goToActiveStage();

        uint256 amount = 1_000 * 10**testAsset.decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(testAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(testAsset), amount);

        borrower.addCollateral(address(creditLine), cLId, amount, false);
        assert_creditLineDeposit(cLId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(cLId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), cLId, borrowable);
        assert_creditLineBorrow(cLId, borrowable);

        _increaseBlock(block.timestamp + 10 days); // time travel by 10 days

        // setting asset prices to same values
        setAggregatorPrice(195040576, 195040576);

        uint256 debt = creditLine.calculateCurrentDebt(creditLineId);
        if (debt > 0) {
            uint256 repayAmount = scaleToRange256(_repayAmount, 1, debt);

            // add balance to user
            admin.transferToken(address(borrowAsset), address(borrower), repayAmount);
            borrower.setAllowance(address(creditLine), address(borrowAsset), repayAmount);

            // getting balance of the user before repayment
            uint256 balanceBefore = IERC20(borrowAsset).balanceOf(address(borrower));

            // repay the credit line
            borrower.repay(address(creditLine), cLId, repayAmount);

            // getting the balance after repayment
            uint256 balanceAfter = IERC20(borrowAsset).balanceOf(address(borrower));

            // assert: balance change for user should be equal to amount repaid
            uint256 balanceDiff = balanceBefore.sub(balanceAfter);
            assertEq(balanceDiff, repayAmount);
        }
    }

    //----------------------- Price oracle variations on close function -----------------------//

    //----------------------- failing tests -----------------------//

    // Close function should fail if both asset prices become zero
    function test_close_POZero1() public {
        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);
        assert_creditLineBorrow(creditLineId, borrowable);

        _increaseBlock(block.timestamp + 10 days); // time travel by 10 days

        uint256 debt = creditLine.calculateCurrentDebt(creditLineId);

        // add balance to user
        admin.transferToken(address(borrowAsset), address(borrower), debt);
        borrower.setAllowance(address(creditLine), address(borrowAsset), debt);

        // getting balance of the user before repayment
        uint256 balanceBefore = IERC20(borrowAsset).balanceOf(address(borrower));

        // repay the credit line
        borrower.repay(address(creditLine), creditLineId, debt);

        // getting the balance after repayment
        uint256 balanceAfter = IERC20(borrowAsset).balanceOf(address(borrower));

        // assert: balance change for user should be equal to amount repaid
        uint256 balanceDiff = balanceBefore.sub(balanceAfter);
        assertEq(balanceDiff, debt);

        // Altering price oracle results
        setAggregatorPrice(0, 0);

        try borrower.close(address(creditLine), creditLineId) {
            revert('Both prices are zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'SafeMath: division by zero');
        }
    }

    // Close function should fail if either prices becomes zero
    function test_close_POZero2() public {
        uint256 amount = 10_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);
        assert_creditLineBorrow(creditLineId, borrowable);

        _increaseBlock(block.timestamp + 10 days); // time travel by 10 days

        uint256 debt = creditLine.calculateCurrentDebt(creditLineId);

        // add balance to user
        admin.transferToken(address(borrowAsset), address(borrower), debt);
        borrower.setAllowance(address(creditLine), address(borrowAsset), debt);

        // getting balance of the user before repayment
        uint256 balanceBefore = IERC20(borrowAsset).balanceOf(address(borrower));

        // repay the credit line
        borrower.repay(address(creditLine), creditLineId, debt);

        // getting the balance after repayment
        uint256 balanceAfter = IERC20(borrowAsset).balanceOf(address(borrower));

        // assert: balance change for user should be equal to amount repaid
        uint256 balanceDiff = balanceBefore.sub(balanceAfter);
        assertEq(balanceDiff, debt);

        // Altering price oracle results
        setAggregatorPrice(195040576, 0);

        try borrower.close(address(creditLine), creditLineId) {
            revert('Collateral price is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'SafeMath: division by zero');
        }
    }

    // Close function should fail if either prices becomes zero
    function test_close_POZero3() public {
        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);
        assert_creditLineBorrow(creditLineId, borrowable);

        _increaseBlock(block.timestamp + 10 days); // time travel by 10 days

        uint256 debt = creditLine.calculateCurrentDebt(creditLineId);

        // add balance to user
        admin.transferToken(address(borrowAsset), address(borrower), debt);
        borrower.setAllowance(address(creditLine), address(borrowAsset), debt);

        // getting balance of the user before repayment
        uint256 balanceBefore = IERC20(borrowAsset).balanceOf(address(borrower));

        // repay the credit line
        borrower.repay(address(creditLine), creditLineId, debt);

        // getting the balance after repayment
        uint256 balanceAfter = IERC20(borrowAsset).balanceOf(address(borrower));

        // assert: balance change for user should be equal to amount repaid
        uint256 balanceDiff = balanceBefore.sub(balanceAfter);
        assertEq(balanceDiff, debt);

        // Altering price oracle results
        setAggregatorPrice(0, 12876423400040030304304);

        try borrower.close(address(creditLine), creditLineId) {
            revert('Borrow asset price is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'SafeMath: division by zero');
        }
    }

    //----------------------- passing tests -----------------------//

    // Any change in price should not affect the close funtion
    function test_close_fuzzPrices(uint128 borrowAssetPrice, uint128 collateralAssetPrice) public {
        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);
        if (borrowable > 0) {
            // Adding tokens to lender and depositing to lender's savings Account
            savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

            borrower.borrow(address(creditLine), creditLineId, borrowable);
            assert_creditLineBorrow(creditLineId, borrowable);

            _increaseBlock(block.timestamp + 10 days); // time travel by 10 days

            uint256 debt = creditLine.calculateCurrentDebt(creditLineId);

            // add balance to user
            admin.transferToken(address(borrowAsset), address(borrower), debt);
            borrower.setAllowance(address(creditLine), address(borrowAsset), debt);

            // getting balance of the user before repayment
            uint256 balanceBefore = IERC20(borrowAsset).balanceOf(address(borrower));

            // repay the credit line
            borrower.repay(address(creditLine), creditLineId, debt);

            // getting the balance after repayment
            uint256 balanceAfter = IERC20(borrowAsset).balanceOf(address(borrower));

            // assert: balance change for user should be equal to amount repaid
            uint256 balanceDiff = balanceBefore.sub(balanceAfter);
            assertEq(balanceDiff, debt);

            // Altering price oracle results
            setAggregatorPrice(borrowAssetPrice, collateralAssetPrice);

            try borrower.close(address(creditLine), creditLineId) {
                uint256 status = uint256(creditLine.getCreditLineStatus(creditLineId));
                assertEq(status, 0); // Credit Line variable are deleted
            } catch Error(string memory reason) {
                assertEq(reason, 'SafeMath: division by zero');
            }
        }
    }

    // Inverted ratio of prices should not affect the close funtion
    function test_close_POFluctuations1() public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //
        requestData.collateralAsset = address(testAsset);
        uint256 cLId = goToActiveStage();

        uint256 amount = 1_000 * 10**testAsset.decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(testAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(testAsset), amount);

        borrower.addCollateral(address(creditLine), cLId, amount, false);
        assert_creditLineDeposit(cLId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(cLId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), cLId, borrowable);
        assert_creditLineBorrow(cLId, borrowable);

        _increaseBlock(block.timestamp + 10 days); // time travel by 10 days

        uint256 debt = creditLine.calculateCurrentDebt(cLId);

        // add balance to user
        admin.transferToken(address(borrowAsset), address(borrower), debt);
        borrower.setAllowance(address(creditLine), address(borrowAsset), debt);

        // getting balance of the user before repayment
        uint256 balanceBefore = IERC20(borrowAsset).balanceOf(address(borrower));

        // repay the credit line
        borrower.repay(address(creditLine), cLId, debt);

        // getting the balance after repayment
        uint256 balanceAfter = IERC20(borrowAsset).balanceOf(address(borrower));

        // assert: balance change for user should be equal to amount repaid
        uint256 balanceDiff = balanceBefore.sub(balanceAfter);
        assertEq(balanceDiff, debt);

        // setting asset prices to invert Ratio of prices
        setAggregatorPrice(295040576, 195040576);

        borrower.close(address(creditLine), cLId);

        uint256 status = uint256(creditLine.getCreditLineStatus(cLId));
        assertEq(status, 0); // Credit Line variable are deleted
    }

    // Prices going down to half should not affect the depositCollateral funtion
    function test_close_POFluctuations2() public {
        // Initial prices //
        // collateral Asset: 12876423400040030304304 //
        // borrow Asset: 195040576 //

        uint256 amount = 1_000 * 10**ERC20(address(collateralAsset)).decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(collateralAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(collateralAsset), amount);

        borrower.addCollateral(address(creditLine), creditLineId, amount, false);
        assert_creditLineDeposit(creditLineId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(creditLineId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), creditLineId, borrowable);
        assert_creditLineBorrow(creditLineId, borrowable);

        _increaseBlock(block.timestamp + 10 days); // time travel by 10 days

        uint256 debt = creditLine.calculateCurrentDebt(creditLineId);

        // add balance to user
        admin.transferToken(address(borrowAsset), address(borrower), debt);
        borrower.setAllowance(address(creditLine), address(borrowAsset), debt);

        // getting balance of the user before repayment
        uint256 balanceBefore = IERC20(borrowAsset).balanceOf(address(borrower));

        // repay the credit line
        borrower.repay(address(creditLine), creditLineId, debt);

        // getting the balance after repayment
        uint256 balanceAfter = IERC20(borrowAsset).balanceOf(address(borrower));

        // assert: balance change for user should be equal to amount repaid
        uint256 balanceDiff = balanceBefore.sub(balanceAfter);
        assertEq(balanceDiff, debt);

        // setting asset prices to half their initial value
        setAggregatorPrice(195040576 / 2, 12876423400040030304304 / 2);

        borrower.close(address(creditLine), creditLineId);

        uint256 status = uint256(creditLine.getCreditLineStatus(creditLineId));
        assertEq(status, 0); // Credit Line variable are deleted
    }

    // Ratio_of_prices = 1, should not affect the depositCollateral funtion
    function test_close_POFluctuations3() public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //
        requestData.collateralAsset = address(testAsset);
        uint256 cLId = goToActiveStage();

        uint256 amount = 1_000 * 10**testAsset.decimals();

        // Adding tokens to borrower and setting allowance for creditline contract
        admin.transferToken(address(testAsset), address(borrower), amount);
        borrower.setAllowance(address(creditLine), address(testAsset), amount);

        borrower.addCollateral(address(creditLine), cLId, amount, false);
        assert_creditLineDeposit(cLId, amount);

        uint256 borrowable = creditLine.calculateBorrowableAmount(cLId);

        // Adding tokens to lender and depositing to lender's savings Account
        savingsAccount_depositHelper(address(lender), address(borrowAsset), borrowAssetStrategy, borrowable);

        borrower.borrow(address(creditLine), cLId, borrowable);
        assert_creditLineBorrow(cLId, borrowable);

        _increaseBlock(block.timestamp + 10 days); // time travel by 10 days

        uint256 debt = creditLine.calculateCurrentDebt(cLId);

        // add balance to user
        admin.transferToken(address(borrowAsset), address(borrower), debt);
        borrower.setAllowance(address(creditLine), address(borrowAsset), debt);

        // getting balance of the user before repayment
        uint256 balanceBefore = IERC20(borrowAsset).balanceOf(address(borrower));

        // repay the credit line
        borrower.repay(address(creditLine), cLId, debt);

        // getting the balance after repayment
        uint256 balanceAfter = IERC20(borrowAsset).balanceOf(address(borrower));

        // assert: balance change for user should be equal to amount repaid
        uint256 balanceDiff = balanceBefore.sub(balanceAfter);
        assertEq(balanceDiff, debt);

        // setting asset prices to invert Ratio of prices
        setAggregatorPrice(295040576, 195040576);

        borrower.close(address(creditLine), cLId);

        uint256 status = uint256(creditLine.getCreditLineStatus(cLId));
        assertEq(status, 0); // Credit Line variable are deleted
    }

    //----------------------- Assert/helper functions -----------------------//

    function assert_creditlineConstants(
        uint256 _creditLineId,
        address _requestBy,
        CLConstants.RequestParams memory requestData
    ) public {
        getCreditlineConstants(_creditLineId);

        if (requestData.requestAsLender) {
            assertEq(constantsCheck.lender, _requestBy);
            assertEq(constantsCheck.borrower, requestData.requestTo);
        } else {
            assertEq(constantsCheck.lender, requestData.requestTo);
            assertEq(constantsCheck.borrower, _requestBy);
        }

        assertEq(constantsCheck.borrowLimit, requestData.borrowLimit);
        assertEq(constantsCheck.idealCollateralRatio, requestData.collateralRatio);
        assertEq(constantsCheck.borrowRate, requestData.borrowRate);
        assertEq(constantsCheck.borrowAsset, requestData.borrowAsset);
        assertEq(constantsCheck.borrowAssetStrategy, requestData.borrowAssetStrategy);
        assertEq(constantsCheck.collateralAsset, requestData.collateralAsset);
        assertEq(constantsCheck.collateralStrategy, requestData.collateralStrategy);
    }

    function setAggregatorPrice(uint256 borrowAssetPrice, uint256 collateralPrice) public {
        if (borrowAssetPrice == 0 || collateralPrice == 0) {
            vm.mockCall(
                priceOracleAddress,
                abi.encodeWithSelector(IPriceOracle.getLatestPrice.selector, address(collateralAsset), address(borrowAsset)),
                abi.encode(0, 0) // price, decimals
            );
        } else {
            vm.mockCall(
                priceOracleAddress,
                abi.encodeWithSelector(IPriceOracle.getLatestPrice.selector, address(collateralAsset), address(borrowAsset)),
                abi.encode(collateralPrice.mul(1e18).div(borrowAssetPrice), 18) // price, decimals
            );

            vm.mockCall(
                priceOracleAddress,
                abi.encodeWithSelector(IPriceOracle.getLatestPrice.selector, address(testAsset), address(borrowAsset)),
                abi.encode(collateralPrice.mul(1e18).div(borrowAssetPrice), 18) // price, decimals
            );
        }
    }

    function assert_creditLineDeposit(uint256 _creditLineId, uint256 _amount) public {
        // assert the received shares and deposited amount equivalent shares are equal
        uint256 sharesReceived = creditLine.collateralShareInStrategy(_creditLineId);
        uint256 sharesOfAmount = IYield(collateralStrategy).getSharesForTokens(_amount, address(collateralAsset));

        assertEq(sharesReceived, sharesOfAmount);
    }

    function assert_creditLineBorrow(uint256 _creditLineId, uint256 _borrowAmount) public {
        // Checking balances
        uint256 protocolFeeAmount = _borrowAmount.mul(protocolFee).div(SCALING_FACTOR);
        uint256 expectedAmount = _borrowAmount.sub(protocolFeeAmount);

        uint256 borrowerBalance = borrowAsset.balanceOf(address(borrower));
        assertEq(expectedAmount, borrowerBalance);

        uint256 lenderBalance = borrowAsset.balanceOf(address(lender));
        assertEq(lenderBalance, 0);

        uint256 lenderBalanceSA = savingsAccount.balanceInShares(address(lender), address(borrowAsset), borrowAssetStrategy);
        assertEq(lenderBalanceSA, 0);

        uint256 feeCollectorBalance = borrowAsset.balanceOf(protocolFeeCollectorAddress);
        assertEq(feeCollectorBalance, protocolFeeAmount);

        // Variable updates
        (, uint256 principal, , uint256 lastPrincipalUpdateTime, ) = creditLine.creditLineVariables(_creditLineId);

        assertEq(principal, _borrowAmount);
        assertEq(lastPrincipalUpdateTime, block.timestamp);
    }
}",22120
RealWorld_TA_101_creditLine.Compound.HelperFunctions.t_RealWorld_20240812170518.log,101,creditLine.Compound.HelperFunctions.t,28618,2107,30725,71.0,0.18523,"pragma solidity 0.7.6;
pragma abicoder v2;

import '../creditLine.HelperFunctions.t.sol';

contract CreditLine_Compound_HelperFunctionTests is CreditLine_HelperFunctionTests {
    function setUp() public override {
        super.setUp();

        requestData.borrowAssetStrategy = compoundYieldAddress;
        requestData.collateralStrategy = compoundYieldAddress;

        creditLineId = goToActiveStage();

        // Setting global parameters
        borrowAssetStrategy = requestData.borrowAssetStrategy;
        collateralStrategy = requestData.collateralStrategy;
    }
}",111
RealWorld_TA_101_PCLRequestedStage.t_RealWorld_20240812153618.log,101,PCLRequestedStage.t,47044,2691,49735,83.0,0.28904,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLStageTests/PCLRequestedStage.t.sol';

contract PCLRequestedStageZeroCollateral is PCLRequestedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED, '!REQUESTED');
    }
}",328
RealWorld_TA_101_PCLLiquidatedState.t_RealWorld_20240812142553.log,101,PCLLiquidatedState.t,615859,4971,620830,153.0,3.178715,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    address lender_0;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        uint256 _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: A liquidated PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start a liquidated PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral cannot be deposited
    function test_collateralCannotBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        try borrower.depositCollateral(requestId, _minimumCollateralRequired, false) {
            revert('Collateral cannot be deposited');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        console.log(_withdrawableCollateral);
        assertApproxEqAbs(_withdrawableCollateral, 0, 2);
    }

    // Test 4: Collateral can or cannot be withdrawn
    function test_collateralCanOrCannotBeWithdrawn() public {
        helper_exchangeRateChanges();

        uint256 _tokens = (pcl.depositedCollateralInShares(requestId) * ICToken(collateralCTokenAddress).exchangeRateCurrent()) / 1e18;
        if (_tokens > 0) {
            uint256 _borrowerBalanceBefore = collateralAsset.balanceOf(address(borrower));
            borrower.withdrawCollateral(requestId, 1, false);
            uint256 _borrowerBalanceAfter = collateralAsset.balanceOf(address(borrower));
            assertGe(_borrowerBalanceAfter, _borrowerBalanceBefore);
        } else {
            try borrower.withdrawCollateral(requestId, 1, false) {
                revert('Collateral cannot be withdrawn');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:WC1');
            }
        }
    }

    // Test 5: All Collateral can or cannot be withdrawn
    function test_allCollateralCanOrCannotBeWithdrawn() public {
        helper_exchangeRateChanges();

        uint256 _tokens = (pcl.depositedCollateralInShares(requestId) * ICToken(collateralCTokenAddress).exchangeRateCurrent()) / 1e18;
        if (_tokens > 0) {
            uint256 _borrowerBalanceBefore = collateralAsset.balanceOf(address(borrower));
            borrower.withdrawCollateral(requestId, 1, false);
            uint256 _borrowerBalanceAfter = collateralAsset.balanceOf(address(borrower));
            assertGe(_borrowerBalanceAfter, _borrowerBalanceBefore);
        } else {
            try borrower.withdrawAllCollateral(requestId, false) {
                revert('All Collateral cannot be withdrawn');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:WAC1');
            }
        }
    }

    // Test 6: A liquidated PCL cannot be closed
    function test_pclCannotBeClosed() public {
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('PCL cannot be closed');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens remains zero if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensRemainsZeroIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);

        assertApproxEqAbs(_collateralTokens, 0, 2);
    }

    // Test 8.1: Collateral tokens may revert if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensMayRevertIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        uint256 _shares = pcl.depositedCollateralInShares(requestId);
        if (_shares > 0) {
            try pcl.calculateTotalCollateralTokens(requestId) {
                revert('Total collateral tokens should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'CY:GTFS1');
            }
        } else {
            uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
            assertEq(_collateralTokens, 0);
        }
    }

    // Test 9: Collateral ratio remains zero if collateral CToken exchange rate increases steeply
    function test_collateralRatioRemainsZeroIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, 1e9);
    }

    // Test 9.1: Collateral ratio remains zero if borrow CToken exchange rate increases steeply
    function test_collateralRatioRemainsZeroIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, 1e9);
    }

    // Test 9.2: Collateral ratio remains zero if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemainsZeroIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, 1e9);
    }

    // Test 9.3: Collateral ratio may revert if collateral CToken exchange rate decreases to zero
    function test_collateralRatioMayRevertIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _shares = pcl.depositedCollateralInShares(requestId);
        if (_shares > 0) {
            try pcl.calculateCurrentCollateralRatio(requestId) {
                revert('Collateral ratio should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'CY:GTFS1');
            }
        } else {
            uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);

            assertLt(_collateralRatio, 1e9);
        }
    }

    // Test 9.4: Collateral ratio remains zero if collateral CToken exchange rate increases very slowly
    function test_collateralRatioRemainsZeroIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, 1e9);
    }

    // Test 10: A liquidated PCL cannot be cancelled
    function test_pclCannotBeCancelled() public {
        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('PCL cannot be cancelled');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate
    function test_adminCanTerminatePCL() public {
        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        admin.terminate(requestId);
        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt(_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate, 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        helper_exchangeRateChanges();

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower cannot repay
    function test_borrowerCannotRepay() public {
        helper_exchangeRateChanges();

        try borrower.repay(requestId, 1) {
            revert('Borrower cannot repay');
        } catch Error(string memory reason) {
            console.log(reason);
            assertEq(reason, 'PCL:REP2');
        }
    }

    // Test 14: A liquidated PCL cannot be liquidated
    function test_lendersCannotLiquidate(bool _withdraw) public {
        helper_exchangeRateChanges();

        // lender_0 tries to liquidate the PCL
        try PCLUser(lender_0).liquidate(requestId, _withdraw) {
            revert('Cannot liquidate a liquidated PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L2');
        }
    }

    // Test 15: Lenders can withdraw liquidated collateral tokens
    function test_lendersCanWithdrawLiquidation() public {
        helper_exchangeRateChanges();

        uint256 _userPoolTokenBalance = lp.balanceOf(address(lender_0), requestId);
        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, lender_0);

        uint256 _userBorrowTokenBalanceBefore = IERC20(request.borrowAsset).balanceOf(address(lender_0));
        uint256 _userCollateralTokenBalanceBefore = IERC20(request.collateralAsset).balanceOf(address(lender_0));
        PCLUser(lender_0).withdrawTokensAfterLiquidation(requestId);
        uint256 _userBorrowTokenBalanceAfter = IERC20(request.borrowAsset).balanceOf(address(lender_0));
        uint256 _userCollateralTokenBalanceAfter = IERC20(request.collateralAsset).balanceOf(address(lender_0));

        assertGt(_userPoolTokenBalance + _lenderInterestOwed, _userBorrowTokenBalanceAfter - _userBorrowTokenBalanceBefore);
        assertGt(_userCollateralTokenBalanceAfter - _userCollateralTokenBalanceBefore, 0);

        _userPoolTokenBalance = lp.balanceOf(address(lender_0), requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, lender_0);
        assertEq(_userPoolTokenBalance, 0);
        assertEq(_lenderInterestOwed, 0);
    }

    // Test 16: Lenders cannot withdraw liquidity
    function test_lendersCannotWithdrawLiquidity() public {
        helper_exchangeRateChanges();

        try PCLUser(lender_0).withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }
    }

    // Test 17: Pool token transfers should be possible in a liquidated PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in a liquidated PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInLiquidatedState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR1, 1e9);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = lp.calculatePrincipalWithdrawable(_id, address(_lender));
        assertLt(_principalWithdrawable, lp.balanceOf(address(_lender), requestId));

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertApproxEqAbs(_withdrawableCollateral, 0, 2);

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertApproxEqAbs(_totalCollateral, 0, 2);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helperFunctionalitiesInLiquidatedState(requestId);
    }
}",7240
RealWorld_TA_101_creditLine.PriceOracle.NotCreatedStage.t_RealWorld_20240812171210.log,101,creditLine.PriceOracle.NotCreatedStage.t,160075,3206,163281,105.0,0.864495,"pragma solidity 0.7.6;
pragma abicoder v2;

import '../Helpers/CLParent.sol';
import '../../../PriceOracle.sol';

import '@openzeppelin/contracts/math/SafeMath.sol';

contract CreditLine_PriceOracle_NotCreatedStageTests is CLParent {
    using SafeMath for uint256;

    CreditLine cl;
    PriceOracle priceOracle;

    function setUp() public {
        CLSetUp();

        cl = CreditLine(creditLineAddress);
        priceOracle = PriceOracle(priceOracleAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = priceOracle.getLatestPrice(address(usdc), address(borrowAsset));

        requestData.requestTo = address(lender);
        // Borrow Asset equivalent of 1,000 in USD
        requestData.borrowLimit = uint128(uint256(CLConstants.maxBorrowLimit / 1e12).mul(_ratioOfPrices).div(10**_decimals));
        requestData.borrowRate = CLConstants.maxBorrowRate / 1e18;
        requestData.autoLiquidation = false;
        requestData.collateralRatio = (CLConstants.maxCollteralRatio / 1e12) * 200;
        requestData.borrowAsset = address(borrowAsset);
        requestData.borrowAssetStrategy = noYieldAddress;
        requestData.collateralAsset = address(collateralAsset);
        requestData.collateralStrategy = noYieldAddress;
        requestData.requestAsLender = false;
    }

    //----------------------- Request function with asset price variation, failing tests -----------------------//

    // Request should fail if both asset prices are zero
    function test_request_POZero1() public {
        // setting both asset prices to zero
        setAggregatorPrice(0, 0);

        try borrower.createRequest(creditLineAddress, requestData) {
            revert('Both prices are zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:ILB1');
        }
    }

    // Request should fail if borrow asset price goes to zero
    function test_request_POZero2() public {
        // setting borrow asset price to zero
        setAggregatorPrice(0, 1000000);

        try borrower.createRequest(creditLineAddress, requestData) {
            revert('Borrow asset price is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:ILB1');
        }
    }

    // Request should fail if usdc asset price goes to zero
    function test_request_POZero3() public {
        // setting collateral asset price to zero
        setAggregatorPrice(195040576, 0);

        try borrower.createRequest(creditLineAddress, requestData) {
            revert('USDC asset price is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:ILB1');
        }
    }

    //----------------------- Request function with asset price variation, passing tests -----------------------//

    function test_fuzzPrices(uint128 _borrowAssetPrice, uint128 _USDCAssetPrice) public {
        uint256 borrowAssetPrice = scaleToRange256(_borrowAssetPrice, 1, type(uint128).max);
        uint256 USDCAssetPrice = scaleToRange256(_USDCAssetPrice, 1, type(uint128).max);

        // RatioOfPrice will not go beyond 1e30 in practical scenarios
        // Limiting RatioOfPrice.mul(1e18) <= 1e30
        if (USDCAssetPrice.div(borrowAssetPrice) <= 1e12) {
            // setting asset prices
            setAggregatorPrice(borrowAssetPrice, USDCAssetPrice);

            try borrower.createRequest(creditLineAddress, requestData) {
                assert_creditlineConstantsAndStatus(1, address(borrower), requestData);
            } catch Error(string memory reason) {
                assertEq(reason, 'CL:ILB1');
            }
        }
    }

    // Change in prices should not affect request function
    // Prices switched between collateral and borrow asset
    function test_request_POFluctuations1() public {
        // Initial prices //
        // test Asset: 295040576 //
        // usdc Asset: 1000000 //
        requestData.borrowLimit = CLConstants.maxBorrowLimit / 1e3;

        // switching asset prices
        // ratio of prices becomes inverse of original
        setAggregatorPrice(1000000, 295040576);

        uint256 creditLineId = borrower.createRequest(creditLineAddress, requestData);
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);
    }

    // Change in prices should not affect request function
    // Price fall to half of their value
    function test_request_POFluctuations2() public {
        // Initial prices //
        // usdc Asset: 1000000 //
        // borrow Asset: 195040576 //
        requestData.borrowLimit = CLConstants.maxBorrowLimit / 1e3;

        // setting asset prices to halves
        setAggregatorPrice(195040576 / 2, 1000000 / 2);

        uint256 creditLineId = borrower.createRequest(creditLineAddress, requestData);
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);
    }

    // Change in prices should not affect request function
    // Both prices become same value
    function test_request_POFluctuations3() public {
        // Initial prices //
        // usdc Asset: 1000000 //
        // borrow Asset: 195040576 //
        requestData.borrowLimit = CLConstants.maxBorrowLimit / 1e3;

        // setting asset prices to same prices
        // ratio of prices become 1
        setAggregatorPrice(195040576, 195040576);

        uint256 creditLineId = borrower.createRequest(creditLineAddress, requestData);
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);
    }

    //----------------------- Assert/helper functions -----------------------//

    function assert_creditlineConstantsAndStatus(
        uint256 _creditLineId,
        address _requestBy,
        CLConstants.RequestParams memory requestData
    ) public {
        getCreditlineConstants(_creditLineId);

        if (requestData.requestAsLender) {
            assertEq(constantsCheck.lender, _requestBy);
            assertEq(constantsCheck.borrower, requestData.requestTo);
        } else {
            assertEq(constantsCheck.lender, requestData.requestTo);
            assertEq(constantsCheck.borrower, _requestBy);
        }

        assertEq(constantsCheck.borrowLimit, requestData.borrowLimit);
        assertEq(constantsCheck.idealCollateralRatio, requestData.collateralRatio);
        assertEq(constantsCheck.borrowRate, requestData.borrowRate);
        assertEq(constantsCheck.borrowAsset, requestData.borrowAsset);
        assertEq(constantsCheck.borrowAssetStrategy, requestData.borrowAssetStrategy);
        assertEq(constantsCheck.collateralAsset, requestData.collateralAsset);
        assertEq(constantsCheck.collateralStrategy, requestData.collateralStrategy);

        uint256 status = uint256(cl.getCreditLineStatus(_creditLineId));
        assertEq(status, 1); // Checking if creditLine status is updated to REQUESTED
    }

    function setAggregatorPrice(uint256 borrowAssetPrice, uint256 usdcPrice) public {
        if (borrowAssetPrice == 0 || usdcPrice == 0) {
            vm.mockCall(
                priceOracleAddress,
                abi.encodeWithSelector(IPriceOracle.getLatestPrice.selector, address(borrowAsset), address(usdc)),
                abi.encode(0, 0) // price, decimals
            );
        } else {
            vm.mockCall(
                priceOracleAddress,
                abi.encodeWithSelector(IPriceOracle.getLatestPrice.selector, address(borrowAsset), address(usdc)),
                abi.encode(borrowAssetPrice.mul(1e18).div(usdcPrice), 18) // price, decimals
            );
        }
    }
}",1648
RealWorld_TA_101_PoolFactory_RealWorld_20240812175616.log,101,PoolFactory,575623,5829,581452,192.0,2.994695,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IStrategyRegistry.sol';
import '../interfaces/IPriceOracle.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import './MinimumBeaconProxy2.sol';

/**
 * @title Pool Factory contract with methods for handling different pools
 * @notice Implements the functions related to Pool (CRUD)
 * @author Sublime
 */
contract PoolFactory is Initializable, ReentrancyGuardUpgradeable, OwnableUpgradeable, IPoolFactory {
    using SafeMath for uint256;

    //-------------------------------- Constants start --------------------------------/

    // Factor to multiply variables to maintain precision
    uint256 constant SCALING_FACTOR = 1e18;

    /**
     * @notice address of the usdc token contract
     */
    address public immutable usdcAsset;

    //-------------------------------- Constants end --------------------------------/

    //-------------------------------- Component addresses start --------------------------------/

    /**
     * @notice address of the contract storing the user registry
     */
    address public override userRegistry;

    /**
     * @notice address of the contract storing the strategy registry
     */
    address public strategyRegistry;
    /**
     * @notice address of the latest implementation of the repayment logic
     */
    address public override repaymentImpl;

    /**
     * @notice address of the latest implementation of the price oracle logic
     */
    address public override priceOracle;

    /**
     * @notice address of the savings account used
     */
    address public override savingsAccount;

    /**
     * @notice Contract Address of no yield
     */
    address public override noStrategyAddress;

    /**
     * @notice Address of the beacon for pool contract logic
     */
    address public beacon;

    //-------------------------------- Component addresses end --------------------------------/

    //-------------------------------- Protocol vars start --------------------------------/

    /**
     * @notice the time interval for the lenders to make contributions to pool
     */
    uint256 public override collectionPeriod;

    /**
     * @notice the time interval for the borrower to withdraw the loan from pool
     */
    uint256 public override loanWithdrawalDuration;

    /**
     * @notice the time interval for the active stage of the margin call
     */
    uint256 public override marginCallDuration;

    /**
     * @notice Fraction of the requested amount for pool below which pool is cancelled
     */
    uint256 public override minBorrowFraction;

    /**
     * @notice the fraction used for calculating the liquidator reward
     */
    uint256 public override liquidatorRewardFraction;

    /**
     * @notice the fraction used for calculating the penalty when the pool is cancelled
     */
    uint256 public override poolCancelPenaltyMultiple;

    /**
     * @notice Fraction of borrowed amount that is deducted as protocol fee (scaled by SCALING_FACTOR)
     */
    uint256 public protocolFeeFraction;

    /**
     * @notice address to which protocol fee is transfered
     */
    address public protocolFeeCollector;

    //-------------------------------- Protocol vars end --------------------------------/

    //-------------------------------- State vars start --------------------------------/
    /*
     * @notice Used to mark assets supported for borrowing
     */
    mapping(address => uint256) public isBorrowToken;

    /*
     * @notice Used to mark supported collateral assets
     */
    mapping(address => uint256) public isCollateralToken;

    /**
     * @notice Used to keep track of valid pool addresses
     */
    mapping(address => uint256) public override poolRegistry;

    //-------------------------------- State vars end --------------------------------/

    //-------------------------------- Limits start --------------------------------/

    /*
     * @notice Used to define limits for the Pool parameters
     * @param min the minimum threshold for the parameter
     * @param max the maximum threshold for the parameter
     */
    struct Limits {
        uint256 min;
        uint256 max;
    }

    /*
     * @notice Used to set the min/max borrow amount for Pools
     */
    Limits public poolSizeLimit;

    /*
     * @notice Used to set the min/max collateral ratio for Pools
     */
    Limits public idealCollateralRatioLimit;

    /*
     * @notice Used to set the min/max borrow rates (interest rate provided by borrower) for Pools
     */
    Limits public borrowRateLimit;

    /*
     * @notice used to set the min/max repayment interval for Pools
     */
    Limits public repaymentIntervalLimit;

    /*
     * @notice used to set the min/max number of repayment intervals for Pools
     */
    Limits public noOfRepaymentIntervalsLimit;

    //-------------------------------- Limits end --------------------------------/

    //-------------------------------- Modifiers start --------------------------------/

    /**
     * @notice functions affected by this modifier can only be invoked by the Pool
     */
    modifier onlyPool() {
        require(poolRegistry[msg.sender] != 0, 'PF:OP1');
        _;
    }

    /**
     * @notice functions affected by this modifier can only be invoked by the borrow of the Pool
     */
    modifier onlyVerifiedUser(address _verifier) {
        require(IVerification(userRegistry).isUser(msg.sender, _verifier), 'PF:OB1');
        _;
    }

    //-------------------------------- Modifiers start --------------------------------/

    //-------------------------------- Init start --------------------------------/

    constructor(address _usdcAsset) {
        require(_usdcAsset != address(0), 'PF:C1');
        usdcAsset = _usdcAsset;
    }

    /**
     * @notice used to initialize the pool factory
     * @dev initializer can only be run once
     * @param _admin address of admin
     * @param _collectionPeriod period for which lenders can lend for pool
     * @param _loanWithdrawalDuration period for which lent tokens can be withdrawn after pool starts
     * @param _marginCallDuration duration of margin call before which collateral ratio has to be maintained
     * @param _liquidatorRewardFraction fraction of liquidation amount which is given to liquidator as reward multiplied by SCALING_FACTOR(10**18)
     * @param _poolCancelPenaltyMultiple multiple of borrow rate of pool as penality for cancellation of pool multiplied by SCALING_FACTOR(10**18)
     * @param _minBorrowFraction amountCollected/amountRequested for a pool, if less than fraction by pool start time then pool can be cancelled without penality multiplied by SCALING_FACTOR(10**18)
     * @param _protocolFeeFraction fraction of amount borrowed in pool which is collected as protocol fee
     * @param _protocolFeeCollector address where protocol fee is collected
     * @param _noStrategy address of the no strategy address
     */
    function initialize(
        address _admin,
        uint256 _collectionPeriod,
        uint256 _loanWithdrawalDuration,
        uint256 _marginCallDuration,
        uint256 _liquidatorRewardFraction,
        uint256 _poolCancelPenaltyMultiple,
        uint256 _minBorrowFraction,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        address _noStrategy,
        address _beacon
    ) external initializer {
        {
            OwnableUpgradeable.__Ownable_init();
            OwnableUpgradeable.transferOwnership(_admin);
        }
        _updateCollectionPeriod(_collectionPeriod);
        _updateLoanWithdrawalDuration(_loanWithdrawalDuration);
        _updateMarginCallDuration(_marginCallDuration);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
        _updatePoolCancelPenaltyMultiple(_poolCancelPenaltyMultiple);
        _updateMinBorrowFraction(_minBorrowFraction);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateNoStrategy(_noStrategy);
        beacon = _beacon;
        __ReentrancyGuard_init();
    }

    /**
     * @notice used to setImplementation addresses
     * @dev used to set some of the contracts pool factory interacts with. only admin can invoke
     * @param _repaymentImpl address of the implementation address of repayments
     * @param _userRegistry address of the user registry where users are verified
     * @param _strategyRegistry address of the startegy registry where strategies are whitelisted
     * @param _priceOracle address of the price oracle
     * @param _savingsAccount address of the savings account contract
     */
    function setImplementations(
        address _repaymentImpl,
        address _userRegistry,
        address _strategyRegistry,
        address _priceOracle,
        address _savingsAccount
    ) external onlyOwner {
        _updateRepaymentImpl(_repaymentImpl);
        _updateSavingsAccount(_savingsAccount);
        _updateUserRegistry(_userRegistry);
        _updateStrategyRegistry(_strategyRegistry);
        _updatePriceoracle(_priceOracle);
    }

    //-------------------------------- Init end --------------------------------/

    //-------------------------------- Create pool start --------------------------------/

    /**
     * @notice invoked when a new borrow pool is created. deploys a new pool for every borrow request
     * @param _poolSize loan amount requested
     * @param _borrowRate interest rate provided by the borrower
     * @param _borrowToken borrow asset requested
     * @param _collateralToken collateral asset requested
     * @param _idealCollateralRatio ideal pool collateral ratio set by the borrower
     * @param _repaymentInterval interval between the last dates of two repayment cycles
     * @param _noOfRepaymentIntervals number of repayments to be made during the duration of the loan
     * @param _poolSavingsStrategy savings strategy selected for the pool collateral
     * @param _collateralAmount collateral amount deposited
     * @param _transferFromSavingsAccount if true, initial collateral is transferred from borrower's savings account, if false, borrower transfers initial collateral deposit from wallet
     * @param _salt random and unique initial seed
     * @param _borrowerVerifier verifier with which borrower needs to be verified
     * @param _lenderVerifier verifier with which lender needs to be verified
     */
    function createPool(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint64 _repaymentInterval,
        uint64 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        bytes32 _salt,
        address _borrowerVerifier,
        address _lenderVerifier
    ) external onlyVerifiedUser(_borrowerVerifier) nonReentrant {
        require(_borrowToken != _collateralToken, 'PF:CP1');
        require(isBorrowToken[_borrowToken] != 0, 'PF:CP2');
        require(isCollateralToken[_collateralToken] != 0, 'PF:CP3');
        require(IPriceOracle(priceOracle).doesFeedExist(_collateralToken, _borrowToken), 'PF:CP4');
        require(IStrategyRegistry(strategyRegistry).registry(_poolSavingsStrategy) != 0, 'PF:CP5');
        _limitPoolSizeInUSD(_borrowToken, _poolSize);

        require(isWithinLimits(_idealCollateralRatio, idealCollateralRatioLimit.min, idealCollateralRatioLimit.max), 'PF:CP6');
        require(isWithinLimits(_borrowRate, borrowRateLimit.min, borrowRateLimit.max), 'PF:CP7');
        require(isWithinLimits(_noOfRepaymentIntervals, noOfRepaymentIntervalsLimit.min, noOfRepaymentIntervalsLimit.max), 'PF:CP8');
        require(isWithinLimits(_repaymentInterval, repaymentIntervalLimit.min, repaymentIntervalLimit.max), 'PF:CP9');
        _createPool(
            _poolSize,
            _borrowRate,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _salt,
            _lenderVerifier
        );
    }

    // @dev These functions are used to avoid stack too deep
    function _createPool(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint64 _repaymentInterval,
        uint64 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        bytes32 _salt,
        address _lenderVerifier
    ) private {
        _salt = keccak256(abi.encode(msg.sender, _salt));
        address addr = _create(_salt);
        _initPool(
            addr,
            _poolSize,
            _borrowRate,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _lenderVerifier
        );
        poolRegistry[addr] = 1;
        emit PoolCreated(addr, msg.sender);
    }

    function _create(bytes32 _salt) private returns (address) {
        address addr;
        bytes memory beaconProxyByteCode = abi.encodePacked(type(MinimumBeaconProxy).creationCode, abi.encode(beacon));

        assembly {
            addr := create2(callvalue(), add(beaconProxyByteCode, 0x20), mload(beaconProxyByteCode), _salt)
            if iszero(extcodesize(addr)) {
                revert(0, 0)
            }
        }
        return addr;
    }

    function _initPool(
        address _pool,
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint64 _repaymentInterval,
        uint64 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier
    ) private {
        IPool pool = IPool(_pool);
        pool.initialize(
            _poolSize,
            _borrowRate,
            msg.sender,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _lenderVerifier,
            loanWithdrawalDuration,
            collectionPeriod
        );
    }

    //-------------------------------- Create pool end --------------------------------/

    //-------------------------------- Limits checks start --------------------------------/

    function _limitPoolSizeInUSD(address _borrowToken, uint256 _poolsize) private view {
        (uint256 RatioOfPrices, uint256 decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowToken, usdcAsset);
        uint256 _poolsizeInUSD = _poolsize.mul(RatioOfPrices).div(10**decimals);
        require(isWithinLimits(_poolsizeInUSD, poolSizeLimit.min, poolSizeLimit.max), 'PF:ILPU1');
    }

    /**
     * @notice invoked to check if pool parameters are within thresholds
     * @dev min or max = 0 is considered as no limit set
     * @param _value supplied value of the parameter
     * @param _min minimum threshold of the parameter
     * @param _max maximum threshold of the parameter
     */
    function isWithinLimits(
        uint256 _value,
        uint256 _min,
        uint256 _max
    ) private pure returns (bool) {
        return (_value >= _min && _value <= _max);
    }

    //-------------------------------- Limits checks end --------------------------------/

    //-------------------------------- Limits setters start --------------------------------/

    /**
     * @notice used to update the thresholds of the pool size of the Pool
     * @dev pool size limits are in lowest units of USDC value
     * @param _min updated value of the minimum threshold value of the pool size
     * @param _max updated value of the maximum threshold value of the pool size
     */
    function updatePoolSizeLimit(uint256 _min, uint256 _max) external onlyOwner {
        require(_min <= _max, 'PF:UPSL1');
        require(!(poolSizeLimit.min == _min && poolSizeLimit.max == _max), 'PF:UPSL2');
        poolSizeLimit = Limits(_min, _max);
        emit LimitsUpdated('PoolSize', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the collateral ratio of the Pool
     * @param _min updated value of the minimum threshold value of the collateral ratio
     * @param _max updated value of the maximum threshold value of the collateral ratio
     */
    function updateidealCollateralRatioLimit(uint256 _min, uint256 _max) external onlyOwner {
        require(_min <= _max, 'PF:UICRL1');
        require(!(idealCollateralRatioLimit.min == _min && idealCollateralRatioLimit.max == _max), 'PF:UICRL2');
        idealCollateralRatioLimit = Limits(_min, _max);
        emit LimitsUpdated('CollateralRatio', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the borrow rate of the Pool
     * @param _min updated value of the minimum threshold value of the borrow rate
     * @param _max updated value of the maximum threshold value of the borrow rate
     */
    function updateBorrowRateLimit(uint256 _min, uint256 _max) external onlyOwner {
        require(_min <= _max, 'PF:UBRL1');
        require(!(borrowRateLimit.min == _min && borrowRateLimit.max == _max), 'PF:UBRL2');
        borrowRateLimit = Limits(_min, _max);
        emit LimitsUpdated('BorrowRate', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the repayment interval of the Pool
     * @param _min updated value of the minimum threshold value of the repayment interval
     * @param _max updated value of the maximum threshold value of the repayment interval
     */
    function updateRepaymentIntervalLimit(uint256 _min, uint256 _max) external onlyOwner {
        require(_min <= _max, 'PF:URIL1');
        require(!(repaymentIntervalLimit.min == _min && repaymentIntervalLimit.max == _max), 'PF:URIL2');
        repaymentIntervalLimit = Limits(_min, _max);
        emit LimitsUpdated('RepaymentInterval', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the number of repayment intervals of the Pool
     * @param _min updated value of the minimum threshold value of the number of repayment intervals
     * @param _max updated value of the maximum threshold value of the number of repayment intervals
     */
    function updateNoOfRepaymentIntervalsLimit(uint256 _min, uint256 _max) external onlyOwner {
        require(_min <= _max, 'PF:UNRIL1');
        require(!(noOfRepaymentIntervalsLimit.min == _min && noOfRepaymentIntervalsLimit.max == _max), 'PF:UNRIL2');
        noOfRepaymentIntervalsLimit = Limits(_min, _max);
        emit LimitsUpdated('NoOfRepaymentIntervals', _min, _max);
    }

    //-------------------------------- Limits setters end --------------------------------/

    //-------------------------------- Global var setters start --------------------------------/

    /**
     * @notice used to update the list of supported borrow tokens
     * @param _borrowToken address of the borrow asset
     * @param _isSupported true if _borrowToken is a valid borrow asset, false if _borrowToken is an invalid borrow asset
     */
    function updateSupportedBorrowTokens(address _borrowToken, bool _isSupported) external onlyOwner {
        _updateSupportedBorrowTokens(_borrowToken, _isSupported);
    }

    function _updateSupportedBorrowTokens(address _borrowToken, bool _isSupported) private {
        if (_isSupported) {
            isBorrowToken[_borrowToken] = 1;
        } else {
            delete isBorrowToken[_borrowToken];
        }
        emit BorrowTokenUpdated(_borrowToken, _isSupported);
    }

    /**
     * @notice used to update the list of supported Collateral tokens
     * @param _collateralToken address of the Collateral asset
     * @param _isSupported true if _collateralToken is a valid Collateral asset, false if _collateralToken is an invalid Collateral asset
     */
    function updateSupportedCollateralTokens(address _collateralToken, bool _isSupported) external onlyOwner {
        _updateSupportedCollateralTokens(_collateralToken, _isSupported);
    }

    function _updateSupportedCollateralTokens(address _collateralToken, bool _isSupported) private {
        if (_isSupported) {
            isCollateralToken[_collateralToken] = 1;
        } else {
            delete isCollateralToken[_collateralToken];
        }
        emit CollateralTokenUpdated(_collateralToken, _isSupported);
    }

    /**
     * @notice used to update the user registry
     * @param _userRegistry address of the contract storing the user registry
     */
    function updateUserRegistry(address _userRegistry) external onlyOwner {
        require(userRegistry != _userRegistry, 'PF:UUR1');
        _updateUserRegistry(_userRegistry);
    }

    function _updateUserRegistry(address _userRegistry) private {
        require(_userRegistry != address(0), 'PF:IUUR1');
        userRegistry = _userRegistry;
        emit UserRegistryUpdated(_userRegistry);
    }

    /**
     * @notice used to update the strategy registry
     * @param _strategyRegistry address of the contract storing the strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        require(strategyRegistry != _strategyRegistry, 'PF:USR1');
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) private {
        require(_strategyRegistry != address(0), 'PF:IUSR1');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the implementation of the repayment logic
     * @param _repaymentImpl address of the updated repayment.sol contract
     */
    function updateRepaymentImpl(address _repaymentImpl) external onlyOwner {
        require(repaymentImpl == _repaymentImpl, 'PF:URI1');
        _updateRepaymentImpl(_repaymentImpl);
    }

    function _updateRepaymentImpl(address _repaymentImpl) private {
        require(_repaymentImpl != address(0), 'PF:IURI1');
        repaymentImpl = _repaymentImpl;
        emit RepaymentImplUpdated(_repaymentImpl);
    }

    /**
     * @notice used to update contract address of nostrategy contract
     * @param _noStrategy address of the updated noYield.sol contract
     */
    function updateNoStrategy(address _noStrategy) external onlyOwner {
        require(noStrategyAddress != _noStrategy, 'PF:UNS1');
        _updateNoStrategy(_noStrategy);
    }

    function _updateNoStrategy(address _noStrategy) private {
        require(_noStrategy != address(0), 'PF:IUNS1');
        noStrategyAddress = _noStrategy;
        emit NoStrategyUpdated(_noStrategy);
    }

    /**
     * @notice used to update the implementation of the price oracle logic
     * @param _priceOracle address of the updated price oracle contract
     */
    function updatePriceoracle(address _priceOracle) external onlyOwner {
        require(priceOracle != _priceOracle, 'PF:UPO1');
        _updatePriceoracle(_priceOracle);
    }

    function _updatePriceoracle(address _priceOracle) private {
        require(_priceOracle != address(0), 'PF:IUPO1');
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account contract
     * @param _savingsAccount address of the updated savings account contract
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        require(savingsAccount != _savingsAccount, 'PF:USA1');
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) private {
        require(_savingsAccount != address(0), 'PF:IUSA1');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the collection period of the Pool
     * @param _collectionPeriod updated value of the collection period
     */
    function updateCollectionPeriod(uint256 _collectionPeriod) external onlyOwner {
        require(collectionPeriod != _collectionPeriod, 'PF:UCP1');
        _updateCollectionPeriod(_collectionPeriod);
    }

    function _updateCollectionPeriod(uint256 _collectionPeriod) private {
        require(_collectionPeriod != 0, 'PF:IUCP1');
        collectionPeriod = _collectionPeriod;
        emit CollectionPeriodUpdated(_collectionPeriod);
    }

    /**
     * @notice used to update the loan withdrawal duration by owner
     * @param _loanWithdrawalDuration updated value of loanWithdrawalDuration
     */
    function updateLoanWithdrawalDuration(uint256 _loanWithdrawalDuration) external onlyOwner {
        require(loanWithdrawalDuration != _loanWithdrawalDuration, 'PF:ULWD1');
        _updateLoanWithdrawalDuration(_loanWithdrawalDuration);
    }

    function _updateLoanWithdrawalDuration(uint256 _loanWithdrawalDuration) private {
        require(_loanWithdrawalDuration != 0, 'PF:IULWD1');
        loanWithdrawalDuration = _loanWithdrawalDuration;
        emit LoanWithdrawalDurationUpdated(_loanWithdrawalDuration);
    }

    /**
     * @notice used to update the active stage of the margin call of the Pool
     * @param _marginCallDuration updated value of the margin call duration
     */
    function updateMarginCallDuration(uint256 _marginCallDuration) external onlyOwner {
        require(marginCallDuration != _marginCallDuration, 'PF:UMCD1');
        _updateMarginCallDuration(_marginCallDuration);
    }

    function _updateMarginCallDuration(uint256 _marginCallDuration) private {
        require(_marginCallDuration != 0, 'PF:IUMCD1');
        marginCallDuration = _marginCallDuration;
        emit MarginCallDurationUpdated(_marginCallDuration);
    }

    /**
     * @notice used to update the min borrow fraction by owner
     * @param _minBorrowFraction updated value of min borrow fraction multiplied by SCALING_FACTOR(10**18)
     */
    function updateMinBorrowFraction(uint256 _minBorrowFraction) external onlyOwner {
        require(minBorrowFraction != _minBorrowFraction, 'PF:UMBF1');
        _updateMinBorrowFraction(_minBorrowFraction);
    }

    function _updateMinBorrowFraction(uint256 _minBorrowFraction) private {
        require(_minBorrowFraction <= SCALING_FACTOR, 'PF:IUMBF1');
        minBorrowFraction = _minBorrowFraction;
        emit MinBorrowFractionUpdated(_minBorrowFraction);
    }

    /**
     * @notice used to update the reward fraction for liquidation of the Pool
     * @param _liquidatorRewardFraction updated value of the reward fraction for liquidation multiplied by SCALING_FACTOR(10**18)
     */
    function updateLiquidatorRewardFraction(uint256 _liquidatorRewardFraction) external onlyOwner {
        require(liquidatorRewardFraction != _liquidatorRewardFraction, 'PF:ULRF1');
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _liquidatorRewardFraction) private {
        require(_liquidatorRewardFraction <= SCALING_FACTOR, 'PF:IULRF1');
        liquidatorRewardFraction = _liquidatorRewardFraction;
        emit LiquidatorRewardFractionUpdated(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the pool cancel penalty multiple
     * @param _poolCancelPenaltyMultiple updated value of the pool cancel penalty multiple multiplied by SCALING_FACTOR(10**18)
     */
    function updatePoolCancelPenaltyMultiple(uint256 _poolCancelPenaltyMultiple) external onlyOwner {
        require(poolCancelPenaltyMultiple != _poolCancelPenaltyMultiple, 'PF:UPCPM1');
        _updatePoolCancelPenaltyMultiple(_poolCancelPenaltyMultiple);
    }

    function _updatePoolCancelPenaltyMultiple(uint256 _poolCancelPenaltyMultiple) private {
        poolCancelPenaltyMultiple = _poolCancelPenaltyMultiple;
        emit PoolCancelPenaltyMultipleUpdated(_poolCancelPenaltyMultiple);
    }

    /**
     * @notice used to update the fraction of borrowed amount charged as protocol fee
     * @param _protocolFee updated value of protocol fee fraction multiplied by SCALING_FACTOR(10**18)
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        require(protocolFeeFraction != _protocolFee, 'PF:UPFF1');
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) private {
        require(_protocolFee <= SCALING_FACTOR, 'PF:IUPFF1');
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the address in which protocol fee is collected
     * @param _protocolFeeCollector updated address of protocol fee collector
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        require(protocolFeeCollector != _protocolFeeCollector, 'PF:UPFC1');
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) private {
        require(_protocolFeeCollector != address(0), 'PF:IUPFC1');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    //-------------------------------- Global var setters start --------------------------------/

    //-------------------------------- getters start --------------------------------/

    /**
     * @notice used to query protocol fee fraction and address of the collector
     * @return protocolFee Fraction multiplied by SCALING_FACTOR(10**18)
     * @return address of protocol fee collector
     */
    function getProtocolFeeData() external view override returns (uint256, address) {
        return (protocolFeeFraction, protocolFeeCollector);
    }

    /**
     * @notice returns the owner of the pool
     */
    function owner() public view override(IPoolFactory, OwnableUpgradeable) returns (address) {
        return OwnableUpgradeable.owner();
    }

    function preComputeAddress(address creator, bytes32 salt) external view returns (address predicted) {
        salt = keccak256(abi.encode(creator, salt));

        bytes memory beaconProxyByteCode = abi.encodePacked(type(MinimumBeaconProxy).creationCode, abi.encode(beacon));

        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(beaconProxyByteCode)));

        return address(uint160(uint256(hash)));
    }

    //-------------------------------- getters start --------------------------------/
}",6740
RealWorld_TA_101_PCLLifecycleTestLowBorrowRate.t_RealWorld_20240812152530.log,101,PCLLifecycleTestLowBorrowRate.t,29510,2431,31941,76.0,0.19617,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import './PCLLifecycleTest.t.sol';

contract PCLLifecycleTestLowBorrowRate is PCLLifecycleTest {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        super.setUp();
        request.borrowRate = uint128(PCLConstants.minBorrowRate);
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
    }
}",125
RealWorld_TA_101_CompoundUser_RealWorld_20240812162620.log,101,CompoundUser,44312,3144,47456,92.0,0.28444,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';

import '../../interfaces/Invest/ICToken.sol';
import '../../interfaces/Invest/ICEther.sol';
import '../../interfaces/Invest/IComptroller.sol';

contract CompoundUser {
    using SafeERC20 for IERC20;

    function mintCETH(address _cTokenAddress, uint256 _amount) public {
        ICEther(_cTokenAddress).mint{value: _amount}();
    }

    function mint(address _cTokenAddress, uint256 _amount) public returns (uint256) {
        return ICToken(_cTokenAddress).mint(_amount);
    }

    function borrow(address _cTokenAddress, uint256 _amount) public returns (uint256) {
        return ICToken(_cTokenAddress).borrow(_amount);
    }

    function repayBorrow(address _cTokenAddress, uint256 _amount) public returns (uint256) {
        return ICToken(_cTokenAddress).repayBorrow(_amount);
    }

    function setAllowance(
        address approvedAddress,
        address token,
        uint256 amount
    ) public {
        IERC20(token).approve(approvedAddress, amount);
    }

    function enterMarkets(address _comptroller, address[] calldata cTokens) public {
        IComptroller(_comptroller).enterMarkets(cTokens);
    }

    receive() external payable {}
}",312
RealWorld_TA_101_twitterVerifier.t_RealWorld_20240812163234.log,101,twitterVerifier.t,411062,3542,414604,141.0,2.12615,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import 'forge-std/Test.sol';
import '../../Verification/twitterVerifier.sol';
import '../../Verification/Verification.sol';
import '../../SublimeProxy.sol';

import '../roles/Admin.sol';
import '../roles/User.sol';
import '@openzeppelin/contracts/cryptography/ECDSA.sol';

contract TwitterVerifierTests is Test {
    TwitterVerifier twitterVerifier;
    Verification verification;

    Admin proxyAdmin;
    Admin admin;
    Admin fakeAdmin;
    User user;
    User anotherUser;

    uint256 constant activationDelay = 1;
    uint256 constant signValidity = 365 days;
    uint256 constant signerPrivateKey = 0xb57992e36fcf5e1bf95840b39f83a5c57936bb391b50acad27e53b05bf751f71;
    uint256 constant newSignerPrivateKey = 0xc903396ee8a81ce8729bc48c2e71034e516a11e9b1c516addb602a55cd88e555;

    string constant verifierName = 'sublime';
    string constant verifierVersion = 'v1';

    bytes32 _TYPE_HASH = keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');
    bytes32 _HASHED_NAME;
    bytes32 _HASHED_VERSION;

    function setUp() public {
        proxyAdmin = new Admin();
        admin = new Admin();
        fakeAdmin = new Admin();
        user = new User();
        anotherUser = new User();

        Verification verificationImplementation = new Verification();
        SublimeProxy verificationProxy = new SublimeProxy(address(verificationImplementation), address(proxyAdmin), '');
        verification = Verification(address(verificationProxy));
        admin.initializeVerification(verification, address(admin), activationDelay);

        TwitterVerifier twitterVerifierImplementation = new TwitterVerifier(address(verification));
        SublimeProxy twitterVerifierProxy = new SublimeProxy(address(twitterVerifierImplementation), address(proxyAdmin), '');
        twitterVerifier = TwitterVerifier(address(twitterVerifierProxy));
        admin.initializeTwitterVerifier(
            twitterVerifier,
            address(admin),
            vm.addr(signerPrivateKey),
            signValidity,
            verifierName,
            verifierVersion
        );

        admin.addVerifier(address(verification), address(twitterVerifier));

        bytes32 hashedName = keccak256(bytes(verifierName));
        bytes32 hashedVersion = keccak256(bytes(verifierVersion));
        _HASHED_NAME = hashedName;
        _HASHED_VERSION = hashedVersion;

        _TYPE_HASH = keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');
    }

    function test_check_address_generation() public {
        log_named_address('signer address', vm.addr(signerPrivateKey));
    }

    // Test signer and signer private key equivalency
    function test_sign_message_and_recover() public {
        bytes32 digest = keccak256((abi.encode('some random value')));
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPrivateKey, digest);
        address signer = ECDSA.recover(digest, v, r, s);
        assertEq(signer, vm.addr(signerPrivateKey));
    }

    // Valid signature generation check
    function test_generateSignatures() public {
        string memory _twitterId = 'sudosym';
        string memory _tweetId = 'r tweet id';
        // bool _isMasterLinked = true;

        address _user = 0xe33896558027811799165C5A85B7c9C318a0e7c4;

        address twitterVerifierCustomAddress = 0xB980BDa08dB45156E5fE727057f54f85AfB6eE3C;

        uint256 _timestamp = 1655312381 + 1 days;
        bytes32 digest = _calculateDigest(_twitterId, _tweetId, _user, _timestamp);
        bytes32 hash = _hashTypedDataV4_withContractAddress(digest, twitterVerifierCustomAddress);

        (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(signerPrivateKey, hash);

        log_named_bytes32('digest', digest);
        log_named_bytes32('eip712-digest', hash);
        log_named_uint('timestamp', _timestamp);
        log_named_uint('v', _v);
        log_named_bytes32('_r', _r);
        log_named_bytes32('_s', _s);

        log_named_bytes32('keccak256(bytes(_twitterId))', keccak256(bytes(_twitterId)));
    }

    // Registering a new user should pass
    function test_registerUser(
        string memory _twitterId,
        string memory _tweetId,
        bool _isMasterLinked
    ) public {
        if (bytes(_twitterId).length <= 2 || bytes(_tweetId).length <= 2) return;

        uint256 _timestamp = block.timestamp + 1 minutes;
        bytes32 digest = _calculateDigest(_twitterId, _tweetId, address(user), _timestamp);
        bytes32 hash = _hashTypedDataV4(digest);

        (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(signerPrivateKey, hash);
        user.registerUserUsingTwitterVerifier(twitterVerifier, _isMasterLinked, _v, _r, _s, _twitterId, _tweetId, _timestamp);

        vm.warp(block.timestamp + 1 minutes);

        assertEq(twitterVerifier.twitterIdMap(_twitterId), address(user));
        assertEq(twitterVerifier.usedTweetIds(_tweetId), address(user));

        if (_isMasterLinked) {
            assertEq(verification.isUser(address(user), address(twitterVerifier)), true);
        } else {
            assertEq(verification.isUser(address(user), address(twitterVerifier)), false);
        }
    }

    // Registering a new user after the sign validity has passed should fail
    function test_registerUser_fail_after_validity(
        string memory _twitterId,
        string memory _tweetId,
        bool _isMasterLinked
    ) public {
        if (bytes(_twitterId).length <= 2 || bytes(_tweetId).length <= 2) return;

        uint256 _timestamp = block.timestamp + 1 minutes;
        bytes32 digest = _calculateDigest(_twitterId, _tweetId, address(user), _timestamp);
        bytes32 hash = _hashTypedDataV4(digest);

        (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(signerPrivateKey, hash);

        vm.warp(block.timestamp + 1 minutes + twitterVerifier.signValidity());
        try user.registerUserUsingTwitterVerifier(twitterVerifier, _isMasterLinked, _v, _r, _s, _twitterId, _tweetId, _timestamp) {
            revert('Should revert after sign validity has expired');
        } catch Error(string memory reason) {
            assertEq(reason, 'TV:RS4');
        }
    }

    // Registering a new user with zero length tweet id should fail
    function test_cannot_register_if_tweet_id_is_zero_length(string memory _twitterId, bool _isMasterLinked) public {
        if (bytes(_twitterId).length <= 2) return;

        uint256 _timestamp = block.timestamp + 1 minutes;
        bytes32 digest = _calculateDigest(_twitterId, '', address(user), _timestamp);
        bytes32 hash = _hashTypedDataV4(digest);

        (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(signerPrivateKey, hash);
        try user.registerUserUsingTwitterVerifier(twitterVerifier, _isMasterLinked, _v, _r, _s, _twitterId, '', _timestamp) {
            revert('Should revert as tweet id length is 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'TV:RS8');
        }
    }

    // Registering a user with invalid signer address should fail
    function test_ec_recover(
        string memory _twitterId,
        string memory _tweetId,
        bytes calldata randomBytes
    ) public {
        if (bytes(_twitterId).length <= 2 || bytes(_tweetId).length <= 2) return;
        bytes32 wrongHash;
        uint256 _timestamp = block.timestamp + 1 minutes;

        {
            bytes32 digest = _calculateDigest(_twitterId, _tweetId, address(user), _timestamp);
            bytes32 hash = _hashTypedDataV4(digest);

            wrongHash = keccak256(abi.encode(randomBytes, hash));
        }

        (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(signerPrivateKey, wrongHash);
        try user.registerUserUsingTwitterVerifier(twitterVerifier, true, _v, _r, _s, _twitterId, _tweetId, _timestamp) {
            revert('signer should be address 0');
        } catch Error(string memory reason) {
            bool result = keccak256(abi.encode(reason)) == keccak256(abi.encode('TV:RS6')) ||
                keccak256(abi.encode(reason)) == keccak256(abi.encode('TV:RS7'));
            assertEq(result, true);
        }
    }

    // Registering a user with a used tweet should fail
    function test_cannot_reuse_the_tweet(
        string calldata _twitterId,
        string calldata _tweetId,
        bool _isMasterLinked
    ) public {
        if (bytes(_twitterId).length <= 2 || bytes(_tweetId).length <= 2) return;

        test_unregisterUser(_twitterId, _tweetId, _isMasterLinked);

        try
            user.registerUserUsingTwitterVerifier(
                twitterVerifier,
                _isMasterLinked,
                uint8(0),
                bytes32(0),
                bytes32(0),
                _twitterId,
                _tweetId,
                block.timestamp + 365 days
            )
        {
            revert('Should Revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'TV:RS3');
        }
    }

    // Registering user with zero length twitter id should fail
    function test_cannot_register_if_twitter_id_is_zero_length(string memory _tweetId, bool _isMasterLinked) public {
        if (bytes(_tweetId).length <= 2) return;

        uint256 _timestamp = block.timestamp + 1 minutes;
        bytes32 digest = _calculateDigest('', _tweetId, address(user), _timestamp);
        bytes32 hash = _hashTypedDataV4(digest);

        (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(signerPrivateKey, hash);
        try user.registerUserUsingTwitterVerifier(twitterVerifier, _isMasterLinked, _v, _r, _s, '', _tweetId, _timestamp) {
            revert('Should revert as twitter id length is 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'TV:RS9');
        }
    }

    // Registering an already registered user should fail
    function test_cannot_register_if_already_registered(
        string memory _twitterId,
        string memory _tweetId,
        bool _isMasterLinked
    ) public {
        if (bytes(_twitterId).length <= 2 || bytes(_tweetId).length <= 2) return;

        uint256 _timestamp = block.timestamp + 1 minutes;
        bytes32 digest = _calculateDigest(_twitterId, _tweetId, address(user), _timestamp);
        bytes32 hash = _hashTypedDataV4(digest);

        (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(signerPrivateKey, hash);
        user.registerUserUsingTwitterVerifier(twitterVerifier, _isMasterLinked, _v, _r, _s, _twitterId, _tweetId, _timestamp);

        try user.registerUserUsingTwitterVerifier(twitterVerifier, _isMasterLinked, _v, _r, _s, _twitterId, _tweetId, _timestamp) {
            revert('Should revert if tried to register multiple times');
        } catch Error(string memory reason) {
            assertEq(reason, 'TV:RS1');
        }
    }

    // Updating signer with the current signer address should fail
    function test_update_signer_same_address() public {
        try admin.updateSignerInTwitterVerifier(twitterVerifier, twitterVerifier.signerAddress()) {
            revert('Using same address to update signer should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'TV:IUSA1');
        }
    }

    // Updating signer with the zero address should fail
    function test_update_signer_zero_address() public {
        try admin.updateSignerInTwitterVerifier(twitterVerifier, address(0)) {
            revert('Using zero address to update signer should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'TV:IUSA2');
        }
    }

    // Updating a signer address should pass
    function test_update_signer() public {
        admin.updateSignerInTwitterVerifier(twitterVerifier, vm.addr(newSignerPrivateKey));
        assertEq(twitterVerifier.signerAddress(), vm.addr(newSignerPrivateKey));
    }

    // Updating sign validity with same value as current sign validity should fail
    function test_update_signValidity_same_value() public {
        try admin.updateSignValidityInTwitterVerifier(twitterVerifier, twitterVerifier.signValidity()) {
            revert('Using same value to update sign validity should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'TV:IUSV1');
        }
    }

    // Updating sign validity with zero value should fail
    function test_update_signValidity_zero_value() public {
        try admin.updateSignValidityInTwitterVerifier(twitterVerifier, 0) {
            revert('Using zero value to update sign validity should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'TV:IUSV2');
        }
    }

    // Updating sign validity by invalid owner should fail
    function test_update_signValidity_invalid_owner() public {
        try proxyAdmin.updateSignValidityInTwitterVerifier(twitterVerifier, 11267) {
            revert('Using zero value to update sign validity should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'TransparentUpgradeableProxy: admin cannot fallback to proxy target');
        }

        try fakeAdmin.updateSignValidityInTwitterVerifier(twitterVerifier, 11267) {
            revert('Using zero value to update sign validity should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    // Updating the sign validity should pass
    function test_update_signValidity(uint256 newSignValidity) public {
        if (newSignValidity == 0 || twitterVerifier.signValidity() == newSignValidity) return;

        admin.updateSignValidityInTwitterVerifier(twitterVerifier, newSignValidity);
        assertEq(twitterVerifier.signValidity(), newSignValidity);
    }

    // Registering user with already used twitter id should fail
    function test_cannot_register_if_twitterId_is_already_used(
        string memory _twitterId,
        string memory _tweetId,
        bool _isMasterLinked
    ) public {
        if (bytes(_twitterId).length <= 2 || bytes(_tweetId).length <= 2) return;

        uint256 _timestamp = block.timestamp + 1 minutes;
        bytes32 digest = _calculateDigest(_twitterId, _tweetId, address(user), _timestamp);
        bytes32 hash = _hashTypedDataV4(digest);

        (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(signerPrivateKey, hash);

        user.registerUserUsingTwitterVerifier(twitterVerifier, _isMasterLinked, _v, _r, _s, _twitterId, _tweetId, _timestamp);

        try anotherUser.registerUserUsingTwitterVerifier(twitterVerifier, _isMasterLinked, _v, _r, _s, _twitterId, _tweetId, _timestamp) {
            revert('Should revert if same twitter id used again');
        } catch Error(string memory reason) {
            assertEq(reason, 'TV:RS2');
        }
    }

    // Unregistering a registered user should pass
    function test_unregisterUser(
        string memory _twitterId,
        string memory _tweetId,
        bool _isMasterLinked
    ) public {
        if (bytes(_twitterId).length <= 2 || bytes(_tweetId).length <= 2) return;
        test_registerUser(_twitterId, _tweetId, _isMasterLinked);

        user.unregisterUserFromTwitterVerifier(twitterVerifier);
        assertEq(verification.masterAddresses(address(user), address(twitterVerifier)), 0);
        assertEq(twitterVerifier.twitterIdMap(_twitterId), address(0));
        assertEq(twitterVerifier.usedTweetIds(_tweetId), address(user));
    }

    // Unregistering a non-existant user should fail
    function test_unregisterUserWhenNotRegistered() public {
        try user.unregisterUserFromTwitterVerifier(twitterVerifier) {
            revert('Should revert if user was not registered');
        } catch Error(string memory reason) {
            assertEq(reason, 'TV:IUU1');
        }
    }

    // Unregistering a user by Admin should pass
    function test_unregister_by_admin(
        string memory _twitterId,
        string memory _tweetId,
        bool _isMasterLinked
    ) public {
        if (bytes(_twitterId).length <= 2 || bytes(_tweetId).length <= 2) return;
        test_registerUser(_twitterId, _tweetId, _isMasterLinked);

        admin.unregisterUserByAdminInTwitterVerifier(twitterVerifier, address(user));
        assertEq(verification.masterAddresses(address(user), address(twitterVerifier)), 0);
        assertEq(twitterVerifier.twitterIdMap(_twitterId), address(0));
        assertEq(twitterVerifier.usedTweetIds(_tweetId), address(user));
    }

    // Registering user with black listed digest should fail
    function test_registering_with_black_listed_digest(
        string memory _twitterId,
        string memory _tweetId,
        bool _isMasterLinked
    ) public {
        if (bytes(_twitterId).length <= 2 || bytes(_tweetId).length <= 2) return;

        uint256 _timestamp = block.timestamp + 1 minutes;
        bytes32 digest = _calculateDigest(_twitterId, _tweetId, address(user), _timestamp);
        bytes32 hash = _hashTypedDataV4(digest);

        admin.blacklistDigestInTwitterVerifier(twitterVerifier, digest);

        (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(signerPrivateKey, hash);
        try user.registerUserUsingTwitterVerifier(twitterVerifier, _isMasterLinked, _v, _r, _s, _twitterId, _tweetId, _timestamp) {
            revert('Should revert as digest is blacklisted');
        } catch Error(string memory reason) {
            assertEq(reason, 'TV:RS5');
        }
    }

    function _calculateDigest(
        string memory _twitterId,
        string memory _tweetId,
        address _msgSender,
        uint256 _timestamp
    ) internal pure returns (bytes32) {
        bytes32 digest = keccak256(
            abi.encode(
                keccak256('set(string twitterId,string tweetId,address userAddr,uint256 timestamp)'),
                keccak256(bytes(_twitterId)),
                keccak256(bytes(_tweetId)),
                _msgSender,
                _timestamp
            )
        );

        return digest;
    }

    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {
        return keccak256(abi.encodePacked('\x19\x01', _domainSeparatorV4(), structHash));
    }

    function _domainSeparatorV4() internal view returns (bytes32) {
        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());
    }

    function _buildDomainSeparator(
        bytes32 typeHash,
        bytes32 name,
        bytes32 version
    ) private view returns (bytes32) {
        return keccak256(abi.encode(typeHash, name, version, _getChainId(), address(twitterVerifier)));
    }

    function _getChainId() private view returns (uint256 chainId) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        // solhint-disable-next-line no-inline-assembly
        assembly {
            chainId := chainid()
        }
    }

    function _EIP712NameHash() internal view virtual returns (bytes32) {
        return _HASHED_NAME;
    }

    function _EIP712VersionHash() internal view virtual returns (bytes32) {
        return _HASHED_VERSION;
    }

    // --------------- only for testing ------------- //
    function _hashTypedDataV4_withContractAddress(bytes32 structHash, address contractAddress) internal virtual returns (bytes32) {
        return keccak256(abi.encodePacked('\x19\x01', _domainSeparatorV4_withContractAddress(contractAddress), structHash));
    }

    function _domainSeparatorV4_withContractAddress(address contractAddress) internal view returns (bytes32) {
        return _buildDomainSeparator_withContractAddress(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), contractAddress);
    }

    function _buildDomainSeparator_withContractAddress(
        bytes32 typeHash,
        bytes32 name,
        bytes32 version,
        address contractAddress
    ) private view returns (bytes32) {
        return keccak256(abi.encode(typeHash, name, version, _getChainId(), contractAddress));
    }
}",4631
RealWorld_TA_101_PCLLiquidatedStateCompoundYield.t_RealWorld_20240812161153.log,101,PCLLiquidatedStateCompoundYield.t,96734,4489,101223,103.0,0.57345,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLLiquidatedState.t.sol';
import '../../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStatePriceOracleCompoundYield is PCLLiquidatedStatePriceOracle {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        // Now we assert that we are in the ACTIVE state
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), 2);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 200);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }
}",918
RealWorld_TA_101_PCLExpiredStage.t_RealWorld_20240812151835.log,101,PCLExpiredStage.t,78793,3732,82525,104.0,0.468605,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLExpiredStage.t.sol';

contract PCLExpiredStageCollateralNoYieldBorrowCompound is PCLExpiredStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }
}",705
RealWorld_TA_101_IProxyUpgrade_RealWorld_20240812172305.log,101,IProxyUpgrade,21069,1537,22606,68.0,0.136085,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface ProxyUpgrade {
    function upgradeTo(address newImplementation) external;
}",31
RealWorld_TA_101_creditLine.PriceOracle.RequestedStage.t_RealWorld_20240812171001.log,101,creditLine.PriceOracle.RequestedStage.t,302677,4100,306777,126.0,1.595385,"pragma solidity 0.7.6;
pragma abicoder v2;

import '../Helpers/CLParent.sol';
import '../Helpers/CLConstants.sol';
import '../../../PriceOracle.sol';

import '@openzeppelin/contracts/math/SafeMath.sol';

contract CreditLine_PriceOracle_RequestedStageTests is CLParent {
    using SafeMath for uint256;

    CreditLine cl;
    PriceOracle priceOracle;

    uint256 creditLineId;

    function setUp() public {
        CLSetUp();

        cl = CreditLine(creditLineAddress);
        priceOracle = PriceOracle(priceOracleAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = priceOracle.getLatestPrice(address(usdc), address(borrowAsset));

        requestData.requestTo = address(lender);
        // Borrow Asset equivalent of 1,000,000,000 in USD
        requestData.borrowLimit = uint128(uint256(CLConstants.maxBorrowLimit / 1e6).mul(_ratioOfPrices).div(10**_decimals));
        requestData.borrowRate = CLConstants.maxBorrowRate / 1e18;
        requestData.autoLiquidation = false;
        requestData.collateralRatio = (CLConstants.maxCollteralRatio / 1e12) * 200;
        requestData.borrowAsset = address(borrowAsset);
        requestData.borrowAssetStrategy = noYieldAddress;
        requestData.collateralAsset = address(collateralAsset);
        requestData.collateralStrategy = noYieldAddress;
        requestData.requestAsLender = false;

        creditLineId = borrower.createRequest(creditLineAddress, requestData);
        assert_creditlineConstantsAndStatus(creditLineId, address(borrower), requestData);
    }

    //----------------------- Accept function with asset price variation, passing tests -----------------------//

    // Any change in price should not affect the accept funtion
    function test_accept_fuzzPrices(uint128 borrowAssetPrice, uint128 collateralAssetPrice) public {
        // setting asset prices
        setAggregatorPrice(borrowAssetPrice, collateralAssetPrice);

        lender.acceptRequest(creditLineAddress, creditLineId);

        uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
        assertEq(status, 2); // Checking if creditLine status is updated to ACTIVE
    }

    // (0,0) price should not affect the accept funtion
    function test_accept_POZero1() public {
        // setting both asset prices to zero
        setAggregatorPrice(0, 0);

        lender.acceptRequest(creditLineAddress, creditLineId);

        uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
        assertEq(status, 2); // Checking if creditLine status is updated to ACTIVE
    }

    // Zero asset price should not affect the accept funtion
    function test_accept_POZero2() public {
        // setting borrow asset price to zero
        setAggregatorPrice(0, 1000000);

        lender.acceptRequest(creditLineAddress, creditLineId);

        uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
        assertEq(status, 2); // Checking if creditLine status is updated to ACTIVE
    }

    // Zero asset price should not affect the accept funtion
    function test_accept_POZero3() public {
        // setting collateral asset price to zero
        setAggregatorPrice(195040576, 0);

        lender.acceptRequest(creditLineAddress, creditLineId);

        uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
        assertEq(status, 2); // Checking if creditLine status is updated to ACTIVE
    }

    // Any change in ratio of prices should not affect the accept funtion
    function test_accept_POFluctuations1() public {
        // Initial prices //
        // usdc Asset: 1000000 //
        // borrow Asset: 195040576 //

        // switching asset prices
        // ratio of prices becomes inverse of original
        setAggregatorPrice(1000000, 195040576);

        lender.acceptRequest(creditLineAddress, creditLineId);

        uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
        assertEq(status, 2); // Checking if creditLine status is updated to ACTIVE
    }

    // Price going down by half should not affect the accept funtion
    function test_accept_POFluctuations2() public {
        // Initial prices //
        // usdc Asset: 1000000 //
        // borrow Asset: 195040576 //

        // setting asset prices to half their original value
        setAggregatorPrice(195040576 / 2, 1000000 / 2);

        lender.acceptRequest(creditLineAddress, creditLineId);

        uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
        assertEq(status, 2); // Checking if creditLine status is updated to ACTIVE
    }

    // Raio_of_price = 1, should not affect the accept funtion
    function test_accept_POFluctuations3() public {
        // Initial prices //
        // usdc Asset: 1000000 //
        // borrow Asset: 195040576 //

        // setting asset prices to same prices
        // ratio of prices become 1
        setAggregatorPrice(195040576, 195040576);

        lender.acceptRequest(creditLineAddress, creditLineId);

        uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
        assertEq(status, 2); // Checking if creditLine status is updated to ACTIVE
    }

    //----------------------- Cancel function with asset price variation, passing tests -----------------------//

    // Any change in price should not affect the cancel funtion
    function test_cancel_fuzzPrices(uint128 borrowAssetPrice, uint128 collateralAssetPrice) public {
        // setting asset prices
        setAggregatorPrice(borrowAssetPrice, collateralAssetPrice);

        lender.cancelRequest(creditLineAddress, creditLineId);

        uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
        assertEq(status, 0); // Checking if creditLine status is updated to ACTIVE
    }

    // (0,0) price should not affect the cancel funtion
    function test_cancel_POZero1() public {
        // setting both asset prices to zero
        setAggregatorPrice(0, 0);

        lender.cancelRequest(creditLineAddress, creditLineId);

        uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
        assertEq(status, 0); // Checking if creditLine status is updated to ACTIVE
    }

    // Zero asset price should not affect the cancel funtion
    function test_cancel_POZero2() public {
        // setting borrow asset price to zero
        setAggregatorPrice(0, 1000000);

        lender.cancelRequest(creditLineAddress, creditLineId);

        uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
        assertEq(status, 0); // Checking if creditLine status is updated to ACTIVE
    }

    // Zero asset price should not affect the cancel funtion
    function test_cancel_POZero3() public {
        // setting collateral asset price to zero
        setAggregatorPrice(195040576, 0);

        lender.cancelRequest(creditLineAddress, creditLineId);

        uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
        assertEq(status, 0); // Checking if creditLine status is updated to ACTIVE
    }

    // Any change in ratio of prices should not affect the cancel funtion
    function test_cancel_POFluctuations1() public {
        // Initial prices //
        // usdc Asset: 1000000 //
        // borrow Asset: 195040576 //

        // switching asset prices
        // ratio of prices becomes inverse of original
        setAggregatorPrice(1000000, 195040576);

        lender.cancelRequest(creditLineAddress, creditLineId);

        uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
        assertEq(status, 0); // Checking if creditLine status is updated to ACTIVE
    }

    // Prices going down to half should not affect the cancel funtion
    function test_cancel_POFluctuations2() public {
        // Initial prices //
        // usdc Asset: 1000000 //
        // borrow Asset: 195040576 //

        // setting asset prices to half their initial value
        setAggregatorPrice(195040576 / 2, 1000000 / 2);

        lender.cancelRequest(creditLineAddress, creditLineId);

        uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
        assertEq(status, 0); // Checking if creditLine status is updated to ACTIVE
    }

    // Ratio_of_prices = 1, should not affect the cancel funtion
    function test_cancel_POFluctuations3() public {
        // Initial prices //
        // test Asset: 295040576 //
        // borrow Asset: 195040576 //

        // setting asset prices to same prices
        // ratio of prices become 1
        setAggregatorPrice(195040576, 195040576);

        lender.cancelRequest(creditLineAddress, creditLineId);

        uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
        assertEq(status, 0); // Checking if creditLine status is updated to ACTIVE
    }

    //----------------------- updateBorrowLimit function with asset price variation, failing tests -----------------------//

    // (0,0) price should fail the updateBorrowLimit funtion
    function test_updateBorrowLimit_POZero1() public {
        // setting both asset prices to zero
        setAggregatorPrice(0, 0);

        try lender.updateBorrowLimit(creditLineAddress, creditLineId, 1e13) {
            revert('Both asset prices are zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:ILB1');
        }
    }

    // Zero asset price should fail for the updateBorrowLimit funtion
    function test_updateBorrowLimit_POZero2() public {
        // setting borrow asset price to zero
        setAggregatorPrice(0, 1000000);

        try lender.updateBorrowLimit(creditLineAddress, creditLineId, 1e13) {
            revert('Borrow asset price is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:ILB1');
        }
    }

    // Zero collateral asset price should pass for the updateBorrowLimit funtion
    function test_updateBorrowLimit_POZero3() public {
        // setting collateral asset price to zero
        setAggregatorPrice(195040576, 0);

        try lender.updateBorrowLimit(creditLineAddress, creditLineId, 1e13) {
            revert('USDC asset price is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'CL:ILB1');
        }
    }

    //----------------------- updateBorrowLimit function with asset price variation, passing tests -----------------------//

    // Any change in price should not affect the updateBorrowLimit funtion, except zero values
    function test_updateBorrowLimit_fuzzPrices(uint128 borrowAssetPrice, uint128 collateralAssetPrice) public {
        // setting asset prices
        setAggregatorPrice(borrowAssetPrice, collateralAssetPrice);

        try lender.updateBorrowLimit(creditLineAddress, creditLineId, 1e13) {
            assert_creditlineBorrowLimit(creditLineId, 1e13);
        } catch Error(string memory reason) {
            if (compareStrings(reason, 'PO:GLP1')) {
                emit log_string('PO:GLP1');
            } else if (compareStrings(reason, 'CL:ILB1')) {
                emit log_string('CL:ILB1');
            } else {
                revert(reason);
            }
        }
    }

    // Any change in ratio of prices should not affect the updateBorrowLimit funtion
    function test_updateBorrowLimit_POFluctuations1() public {
        // Initial prices //
        // usdc Asset: 1000000 //
        // borrow Asset: 195040576 //

        // switching asset prices
        // ratio of prices becomes inverse of original
        setAggregatorPrice(1000000, 195040576);

        lender.updateBorrowLimit(creditLineAddress, creditLineId, 1e13);

        assert_creditlineBorrowLimit(creditLineId, 1e13);
    }

    // Prices going down to half should not affect the updateBorrowLimit funtion
    function test_updateBorrowLimit_POFluctuations2() public {
        // Initial prices //
        // usdc Asset: 1000000 //
        // borrow Asset: 195040576 //

        // setting asset prices to half their initial value
        setAggregatorPrice(195040576 / 2, 1000000 / 2);

        lender.updateBorrowLimit(creditLineAddress, creditLineId, 1e9);

        assert_creditlineBorrowLimit(creditLineId, 1e9);
    }

    // Ratio_of_prices = 1, should not affect the updateBorrowLimit funtion
    function test_updateBorrowLimit_POFluctuations3() public {
        // Initial prices //
        // usdc Asset: 1000000 //
        // borrow Asset: 195040576 //

        // setting asset prices to same prices
        // ratio of prices become 1
        setAggregatorPrice(195040576, 195040576);

        lender.updateBorrowLimit(creditLineAddress, creditLineId, 1e13);

        assert_creditlineBorrowLimit(creditLineId, 1e13);
    }

    //----------------------- Assert/helper functions -----------------------//

    function assert_creditlineConstantsAndStatus(
        uint256 _creditLineId,
        address _requestBy,
        CLConstants.RequestParams memory requestData
    ) public {
        getCreditlineConstants(_creditLineId);

        if (requestData.requestAsLender) {
            assertEq(constantsCheck.lender, _requestBy);
            assertEq(constantsCheck.borrower, requestData.requestTo);
        } else {
            assertEq(constantsCheck.lender, requestData.requestTo);
            assertEq(constantsCheck.borrower, _requestBy);
        }

        assertEq(constantsCheck.borrowLimit, requestData.borrowLimit);
        assertEq(constantsCheck.idealCollateralRatio, requestData.collateralRatio);
        assertEq(constantsCheck.borrowRate, requestData.borrowRate);
        assertEq(constantsCheck.borrowAsset, requestData.borrowAsset);
        assertEq(constantsCheck.borrowAssetStrategy, requestData.borrowAssetStrategy);
        assertEq(constantsCheck.collateralAsset, requestData.collateralAsset);
        assertEq(constantsCheck.collateralStrategy, requestData.collateralStrategy);

        uint256 status = uint256(cl.getCreditLineStatus(creditLineId));
        assertEq(status, 1); // Checking if creditLine status is updated to REQUESTED
    }

    function setAggregatorPrice(uint256 borrowAssetPrice, uint256 usdcPrice) public {
        if (borrowAssetPrice == 0 || usdcPrice == 0) {
            vm.mockCall(
                priceOracleAddress,
                abi.encodeWithSelector(IPriceOracle.getLatestPrice.selector, address(borrowAsset), address(usdc)),
                abi.encode(0, 0) // price, decimals
            );
        } else {
            vm.mockCall(
                priceOracleAddress,
                abi.encodeWithSelector(IPriceOracle.getLatestPrice.selector, address(borrowAsset), address(usdc)),
                abi.encode(borrowAssetPrice.mul(1e18).div(usdcPrice), 18) // price, decimals
            );
        }
    }

    function assert_creditlineBorrowLimit(uint256 _creditLineId, uint256 _newBorrowLimit) public {
        getCreditlineConstants(_creditLineId);

        assertEq(constantsCheck.borrowLimit, _newBorrowLimit);
    }
}",3381
RealWorld_TA_101_PCLExpiredStage.t_RealWorld_20240812151202.log,101,PCLExpiredStage.t,78264,3307,81571,108.0,0.45746,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLExpiredStage.t.sol';

contract PCLExpiredStageCollateralCompoundBorrowCompound is PCLExpiredStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }
}",703
RealWorld_TA_101_IYield_RealWorld_20240812181214.log,101,IYield,69933,1433,71366,69.0,0.378325,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface IYield {
    /**
     * @dev emitted when tokens are locked
     * @param user the address of user, tokens locked for
     * @param investedTo the address of contract to invest in
     * @param lpTokensReceived the amount of shares received
     **/
    event LockedTokens(address indexed user, address indexed investedTo, uint256 lpTokensReceived);

    /**
     * @dev emitted when tokens are unlocked/redeemed
     * @param investedTo the address of contract invested in
     * @param collateralReceived the amount of underlying asset received
     **/
    event UnlockedTokens(address indexed investedTo, uint256 collateralReceived);

    /**
     * @notice emitted when a shares are unlocked from yield
     * @param asset address of the base token for which shares are being withdrawn
     * @param sharesReleased amount of shares unlocked
     */
    event UnlockedShares(address indexed asset, uint256 sharesReleased);

    /**
     * @notice emitted when savings account address is updated
     * @param savingsAccount updated address of the savings account contract
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @dev Used to get liquidity token address from asset address
     * @param asset the address of underlying token
     * @return tokenAddress address of liquidity token
     **/
    function liquidityToken(address asset) external view returns (address tokenAddress);

    /**
     * @dev Used to lock tokens in available protocol
     * @param user the address of user locking tokens
     * @param asset the address of token to invest
     * @param amount the amount of asset
     * @return sharesReceived amount of shares received
     **/
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external returns (uint256 sharesReceived);

    /**
     * @dev Used to unlock tokens from available protocol
     * @param asset the address of underlying token
     * @param to the address to which tokens are transferred after unlock
     * @param amount the amount of liquidity shares to unlock
     * @return tokensReceived amount of tokens received
     **/
    function unlockTokens(
        address asset,
        address to,
        uint256 amount
    ) external returns (uint256 tokensReceived);

    function unlockShares(
        address asset,
        address to,
        uint256 amount
    ) external returns (uint256 received);

    /**
     * @dev Used to get amount of underlying tokens for current number of shares
     * @param shares the amount of shares
     * @param asset the address of token locked
     * @return amount amount of underlying tokens
     **/
    function getTokensForShares(uint256 shares, address asset) external returns (uint256 amount);

    function getSharesForTokens(uint256 amount, address asset) external returns (uint256 shares);
}",610
RealWorld_TA_101_Repayments_RealWorld_20240812175931.log,101,Repayments,451785,4966,456751,152.0,2.358245,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IRepayment.sol';

/**
 * @title Repayments contract
 * @dev For accuracy considering base itself as (SCALING_FACTOR)
 * @notice Implements the functions related to repayments (payments that
 * have to made by the borrower back to the pool)
 * @author Sublime
 */
contract Repayments is Initializable, IRepayment, ReentrancyGuardUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    //-------------------------------- Constants start --------------------------------/

    // Max value of uint256
    uint256 constant HIGH_AMOUNT = 2**128;

    // Number of seconds in a year. Year is of exactly 365 days for simplicity
    uint256 constant YEAR_IN_SECONDS = 365 days;

    // Factor to multiply variables to maintain precision
    uint256 constant SCALING_FACTOR = 1e18;

    //-------------------------------- Constants end --------------------------------/

    //-------------------------------- Global vars start --------------------------------/

    // Address of the pool factory contract
    IPoolFactory poolFactory;

    /**
     * @notice Penalty interest rate applied during grace period
     * @dev multiplied by SCALING_FACTOR to maintain precision
     */
    uint128 public gracePenaltyRate;

    /**
     * @notice Fraction of repayment interval for which grace period is allowed
     * @dev multiplied by SCALING_FACTOR to maintain precision
     */
    uint128 public gracePeriodFraction;

    //-------------------------------- Global vars end --------------------------------/

    //-------------------------------- State vars start --------------------------------/

    /**
     * @notice Struct that is used to store variables related to repayment for a pool
     * @param repaidAmount amount of tokens repaid as interest by borrower
     * @param loanDurationCovered duration for which repayments are made based on total repayments by borrower. 
                                Scaled by SCALING_FACTOR to maintain precision
     */
    struct RepaymentVariables {
        uint256 repaidAmount;
        uint256 loanDurationCovered;
    }

    /**
     * @notice Struct that is used to store constants related to repayment for a pool
     * @param numberOfTotalRepayments number of intervals before which repayments for pool should be completed
     * @param repayAsset address of token in which interest is repaid
     * @param gracePenaltyRate Penalty interest rate applied during grace period. Scaled by SCALING_FACTOR
     * @param gracePeriodFraction Fraction of repayment interval for which grace period is allowed. Scaled by SCALING_FACTOR
     * @param borrowRate The rate at which lending took place. Scaled by SCALING_FACTOR
     * @param repaymentInterval Intervals after which repayment will be due. Scaled by SCALING_FACTOR
     * @param loanDuration Duration of the total loan. Scaled by SCALING_FACTOR
     * @param loanStartTime The starting time of the loan. Scaled by SCALING_FACTOR
     */
    struct RepaymentConstants {
        uint64 numberOfTotalRepayments; // using it to check if RepaymentDetails Exists as repayment Interval!=0 in any case
        address repayAsset;
        uint128 gracePenaltyRate;
        uint128 gracePeriodFraction;
        uint256 borrowRate;
        uint256 repaymentInterval;
        uint256 loanDuration;
        uint256 loanStartTime;
    }

    /**
     * @notice used to maintain the variables related to repayment against a pool
     */
    mapping(address => RepaymentVariables) public repayVariables;

    /**
     * @notice used to maintain the constants related to repayment against a pool
     */
    mapping(address => RepaymentConstants) public repayConstants;

    //-------------------------------- State vars end --------------------------------/

    //-------------------------------- Modifiers start --------------------------------/

    /// @notice determines if the pool is active or not based on whether repayments have been started by the
    ///borrower for this particular pool or not
    /// @param _poolID address of the pool for which we want to test statu
    modifier isPoolInitialized(address _poolID) {
        require(repayConstants[_poolID].numberOfTotalRepayments != 0, 'R:IPI1');
        _;
    }

    /// @notice modifier used to determine whether the current pool is valid or not
    /// @dev poolRegistry from IPoolFactory interface returns a bool
    modifier onlyValidPool() {
        require(poolFactory.poolRegistry(msg.sender) != 0, 'R:OVP1');
        _;
    }

    /**
     * @notice modifier used to check if msg.sender is the owner
     */
    modifier onlyOwner() {
        require(msg.sender == poolFactory.owner(), 'R:OO1');
        _;
    }

    //-------------------------------- Modifiers end --------------------------------/

    //-------------------------------- Global var setters start --------------------------------/

    /**
     * @notice used to update pool factory address
     * @param _poolFactory address of pool factory contract
     */
    function updatePoolFactory(address _poolFactory) external onlyOwner {
        require(address(poolFactory) != _poolFactory, 'R:UPF1');
        _updatePoolFactory(_poolFactory);
    }

    function _updatePoolFactory(address _poolFactory) private {
        require(_poolFactory != address(0), 'R:IUPF1');
        poolFactory = IPoolFactory(_poolFactory);
        emit PoolFactoryUpdated(_poolFactory);
    }

    /**
     * @notice used to update grace period as a fraction of repayment interval
     * @param _gracePeriodFraction updated value of gracePeriodFraction multiplied by SCALING_FACTOR
     */
    function updateGracePeriodFraction(uint128 _gracePeriodFraction) external onlyOwner {
        require(gracePeriodFraction != _gracePeriodFraction, 'R:UGPF1');
        _updateGracePeriodFraction(_gracePeriodFraction);
    }

    function _updateGracePeriodFraction(uint128 _gracePeriodFraction) private {
        gracePeriodFraction = _gracePeriodFraction;
        emit GracePeriodFractionUpdated(_gracePeriodFraction);
    }

    /**
     * @notice used to update grace penality rate
     * @param _gracePenaltyRate value of grace penality rate multiplied by SCALING_FACTOR
     */
    function updateGracePenaltyRate(uint128 _gracePenaltyRate) external onlyOwner {
        require(gracePenaltyRate != _gracePenaltyRate, 'R:UGPR1');
        _updateGracePenaltyRate(_gracePenaltyRate);
    }

    function _updateGracePenaltyRate(uint128 _gracePenaltyRate) private {
        gracePenaltyRate = _gracePenaltyRate;
        emit GracePenaltyRateUpdated(_gracePenaltyRate);
    }

    //-------------------------------- Global var setters end --------------------------------/

    //-------------------------------- Init start --------------------------------/

    /// @notice Initializes the contract (similar to a constructor)
    /// @dev Since we cannot use constructors when using OpenZeppelin Upgrades, we use the initialize function
    ///and the initializer modifier makes sure that this function is called only once
    /// @param _poolFactory The address of the pool factory
    /// @param _gracePenaltyRate The penalty rate levied in the grace period
    /// @param _gracePeriodFraction The fraction of repayment interval that will be allowed as grace period
    function initialize(
        address _poolFactory,
        uint128 _gracePenaltyRate,
        uint128 _gracePeriodFraction
    ) external initializer {
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();

        _updatePoolFactory(_poolFactory);
        _updateGracePenaltyRate(_gracePenaltyRate);
        _updateGracePeriodFraction(_gracePeriodFraction);
    }

    /// @notice For a valid pool, the repayment schedule is being initialized here
    /// @dev Imported from RepaymentStorage.sol repayConstants is a mapping(address => repayConstants)
    /// @param numberOfTotalRepayments The total number of repayments that will be required from the borrower
    /// @param repaymentInterval Intervals after which repayment will be due
    /// @param borrowRate The rate at which lending took place
    /// @param loanStartTime The starting time of the loan
    /// @param lentAsset The address of the asset that was lent (basically a ERC20 token address)
    function initializeRepayment(
        uint64 numberOfTotalRepayments,
        uint256 repaymentInterval,
        uint256 borrowRate,
        uint256 loanStartTime,
        address lentAsset
    ) external override onlyValidPool {
        RepaymentConstants storage _repaymentConstants = repayConstants[msg.sender];
        _repaymentConstants.gracePenaltyRate = gracePenaltyRate;
        _repaymentConstants.gracePeriodFraction = gracePeriodFraction;
        _repaymentConstants.numberOfTotalRepayments = numberOfTotalRepayments;
        _repaymentConstants.loanDuration = repaymentInterval.mul(numberOfTotalRepayments).mul(SCALING_FACTOR);
        _repaymentConstants.repaymentInterval = repaymentInterval.mul(SCALING_FACTOR);
        _repaymentConstants.borrowRate = borrowRate;
        _repaymentConstants.loanStartTime = loanStartTime.mul(SCALING_FACTOR);
        _repaymentConstants.repayAsset = lentAsset;
    }

    //-------------------------------- Init end --------------------------------/

    //-------------------------------- Repay start --------------------------------/

    /// @notice Used to for your overdues, grace penalty and interest
    /// @dev (SCALING_FACTOR) is included to maintain the accuracy of the arithmetic operations
    /// @param _poolID address of the pool
    /// @param _amount amount repaid by the borrower
    function repay(address _poolID, uint256 _amount) external nonReentrant isPoolInitialized(_poolID) {
        address _asset = repayConstants[_poolID].repayAsset;
        uint256 _amountRepaid = _repay(_poolID, _amount, false);

        IERC20(_asset).safeTransferFrom(msg.sender, _poolID, _amountRepaid);
    }

    function _repayGracePenalty(address _poolID) private returns (uint256) {
        uint256 _nextInstalmentDeadline = getNextInstalmentDeadline(_poolID);
        bool _isBorrowerLate = _isGracePenaltyApplicable(_poolID, _nextInstalmentDeadline);

        if (_isBorrowerLate) {
            uint256 _interestDue = _getInterestDueTillInstalmentDeadline(_poolID, _nextInstalmentDeadline);
            uint256 _penalty = uint256(repayConstants[_poolID].gracePenaltyRate).mul(_interestDue).div(SCALING_FACTOR);
            emit GracePenaltyRepaid(_poolID, _penalty);
            return _penalty;
        } else {
            return 0;
        }
    }

    function _repayInterest(
        address _poolID,
        uint256 _amount,
        bool _isLastRepayment
    ) private returns (uint256) {
        uint256 _interestLeft = getInterestLeft(_poolID);
        require((_amount < _interestLeft) != _isLastRepayment, 'R:IRI1');

        if (_amount < _interestLeft) {
            uint256 _newDurationRepaid = getRepaidDuration(_poolID, _amount);
            repayVariables[_poolID].loanDurationCovered = repayVariables[_poolID].loanDurationCovered.add(_newDurationRepaid);
            emit InterestRepaid(_poolID, _amount);
            return _amount;
        } else {
            repayVariables[_poolID].loanDurationCovered = repayConstants[_poolID].loanDuration; // full interest repaid
            emit InterestRepaymentComplete(_poolID, _interestLeft);
            return _interestLeft;
        }
    }

    function _updateRepaidAmount(address _poolID, uint256 _repaidAmount) private returns (uint256) {
        repayVariables[_poolID].repaidAmount = repayVariables[_poolID].repaidAmount.add(_repaidAmount);
        return _repaidAmount;
    }

    function _repay(
        address _poolID,
        uint256 _amount,
        bool _isLastRepayment
    ) private returns (uint256) {
        IPool _pool = IPool(_poolID);
        uint256 _loanStatus = _pool.getLoanStatus();
        require(_loanStatus == uint256(IPool.LoanStatus.ACTIVE), 'R:IR1');

        // pay off grace penality
        uint256 _gracePenaltyDue = _repayGracePenalty(_poolID);

        // pay interest
        uint256 _interestRepaid = _repayInterest(_poolID, _amount, _isLastRepayment);

        return _updateRepaidAmount(_poolID, _gracePenaltyDue.add(_interestRepaid));
    }

    /// @notice Used to pay off the principal of the loan, once the overdues and interests are repaid
    /// @dev (SCALING_FACTOR) is included to maintain the accuracy of the arithmetic operations
    /// @param _poolID address of the pool
    function repayPrincipal(address _poolID) external nonReentrant isPoolInitialized(_poolID) {
        address _asset = repayConstants[_poolID].repayAsset;
        uint256 _interestToRepay = _repay(_poolID, HIGH_AMOUNT, true);
        IPool _pool = IPool(_poolID);

        require(repayConstants[_poolID].loanDuration == repayVariables[_poolID].loanDurationCovered, 'R:RP1');

        uint256 _amount = _pool.totalSupply();
        uint256 _amountToPay = _amount.add(_interestToRepay);
        IERC20(_asset).safeTransferFrom(msg.sender, _poolID, _amountToPay);
        emit PrincipalRepaid(_poolID, _amount);

        _pool.closeLoan();
    }

    //-------------------------------- Repay end --------------------------------/

    //-------------------------------- Utils start --------------------------------/

    /**
     * @notice returns SCALED UP interest per second for the specific pool
     * @param _poolID address of the pool
     * @return SCALED UP interest per second
     */

    function getInterestPerSecond(address _poolID) public view returns (uint256) {
        uint256 _activePrincipal = IPool(_poolID).totalSupply();
        // we are not multiplying by SCALING_FACTOR becuase borrowRate is already scaled up
        uint256 _interestPerSecond = _activePrincipal.mul(repayConstants[_poolID].borrowRate).div(YEAR_IN_SECONDS);
        return _interestPerSecond;
    }

    /**
     * @notice returns interest for specific scaled up time
     * @param _poolID address of the pool
     * @param _scaledUpTime scaled time for which interest is calculated
     * @return interest per second
     */
    function getInterest(address _poolID, uint256 _scaledUpTime) public view returns (uint256) {
        uint256 _activePrincipal = IPool(_poolID).totalSupply();
        uint256 _borrowRate = repayConstants[_poolID].borrowRate;
        return _activePrincipal.mul(_borrowRate).div(SCALING_FACTOR).mul(_scaledUpTime).div(YEAR_IN_SECONDS).div(SCALING_FACTOR);
    }

    /**
     * @notice returns scaled up duration for which specified amount can repay interest for a specific pool
     * @param _poolID address of the pool
     * @param _amount scaled up amount
     * @return Scaled up (by SCALING_FACTOR) duration for which _amount can repay interest for the Pool
     */
    function getRepaidDuration(address _poolID, uint256 _amount) public view returns (uint256) {
        uint256 _activePrincipal = IPool(_poolID).totalSupply();
        return
            _amount.mul(YEAR_IN_SECONDS).mul(SCALING_FACTOR).div(_activePrincipal).mul(SCALING_FACTOR).div(
                repayConstants[_poolID].borrowRate
            );
    }

    /// @notice This function determines the number of completed instalments
    /// @param _poolID The address of the pool for which we want the completed instalments
    /// @return scaled instalments completed
    function getInstalmentsCompleted(address _poolID) public view returns (uint256) {
        uint256 _repaymentInterval = repayConstants[_poolID].repaymentInterval;
        uint256 _loanDurationCovered = repayVariables[_poolID].loanDurationCovered;
        uint256 _instalmentsCompleted = _loanDurationCovered.div(_repaymentInterval).mul(SCALING_FACTOR); // dividing exponents, returns whole number rounded down

        return _instalmentsCompleted;
    }

    /// @notice This function determines the interest that is due for the borrower till the current instalment deadline
    /// @param _poolID The address of the pool for which we want the interest
    /// @return scaled interest due till instalment deadline
    function getInterestDueTillInstalmentDeadline(address _poolID) external view returns (uint256) {
        uint256 _nextInstalmentDeadline = getNextInstalmentDeadline(_poolID);
        return _getInterestDueTillInstalmentDeadline(_poolID, _nextInstalmentDeadline);
    }

    function _getInterestDueTillInstalmentDeadline(address _poolID, uint256 _nextInstalmentDeadline) private view returns (uint256) {
        uint256 _loanDurationCovered = repayVariables[_poolID].loanDurationCovered;
        uint256 _interestDueTillInstalmentDeadline = getInterest(
            _poolID,
            _nextInstalmentDeadline.sub(repayConstants[_poolID].loanStartTime).sub(_loanDurationCovered)
        );
        return _interestDueTillInstalmentDeadline;
    }

    /// @notice This function determines the timestamp of the next instalment deadline
    /// @param _poolID The address of the pool for which we want the next instalment deadline
    /// @return timestamp before which next instalment ends
    function getNextInstalmentDeadline(address _poolID) public view override returns (uint256) {
        uint256 _instalmentsCompleted = getInstalmentsCompleted(_poolID);
        if (_instalmentsCompleted == uint256(repayConstants[_poolID].numberOfTotalRepayments).mul(SCALING_FACTOR)) {
            revert('R:GNID1');
        }

        uint256 _repaymentInterval = repayConstants[_poolID].repaymentInterval;
        uint256 _loanStartTime = repayConstants[_poolID].loanStartTime;
        uint256 _nextInstalmentDeadline = ((_instalmentsCompleted.add(SCALING_FACTOR)).mul(_repaymentInterval).div(SCALING_FACTOR)).add(
            _loanStartTime
        );
        return _nextInstalmentDeadline;
    }

    /// @notice This function determine the current instalment interval
    /// @param _poolID The address of the pool for which we want the current instalment interval
    /// @return scaled instalment interval
    function getCurrentInstalmentInterval(address _poolID) external view returns (uint256) {
        uint256 _instalmentsCompleted = getInstalmentsCompleted(_poolID);
        return _instalmentsCompleted.add(SCALING_FACTOR);
    }

    /// @notice This function determines the current (loan) interval
    /// @dev adding SCALING_FACTOR to add 1. Considering base itself as (SCALING_FACTOR)
    /// @param _poolID The address of the pool for which we want the current loan interval
    /// @return scaled current loan interval
    function getCurrentLoanInterval(address _poolID) external view override returns (uint256) {
        uint256 _loanStartTime = repayConstants[_poolID].loanStartTime;
        uint256 _currentTime = block.timestamp.mul(SCALING_FACTOR);
        uint256 _repaymentInterval = repayConstants[_poolID].repaymentInterval;
        uint256 _currentInterval = ((_currentTime.sub(_loanStartTime)).mul(SCALING_FACTOR).div(_repaymentInterval)).add(SCALING_FACTOR);

        return _currentInterval;
    }

    /// @notice Check if grace penalty is applicable or not
    /// @dev (SCALING_FACTOR) is included to maintain the accuracy of the arithmetic operations
    /// @param _poolID address of the pool for which we want to inquire if grace penalty is applicable or not
    /// @return boolean value indicating if applicable or not
    function isGracePenaltyApplicable(address _poolID) external view returns (bool) {
        uint256 _nextInstalmentDeadline = getNextInstalmentDeadline(_poolID);

        return _isGracePenaltyApplicable(_poolID, _nextInstalmentDeadline);
    }

    function _isGracePenaltyApplicable(address _poolID, uint256 _nextInstalmentDeadline) private view returns (bool) {
        uint256 _repaymentInterval = repayConstants[_poolID].repaymentInterval;
        uint256 _currentTime = block.timestamp.mul(SCALING_FACTOR);
        uint256 _gracePeriodFraction = repayConstants[_poolID].gracePeriodFraction;
        uint256 _gracePeriodDeadline = _nextInstalmentDeadline.add(_gracePeriodFraction.mul(_repaymentInterval).div(SCALING_FACTOR));

        require(_currentTime <= _gracePeriodDeadline, 'R:IGPA1');

        if (_currentTime <= _nextInstalmentDeadline) return false;
        else return true;
    }

    /// @notice Checks if the borrower has defaulted
    /// @dev (SCALING_FACTOR) is included to maintain the accuracy of the arithmetic operations
    /// @param _poolID address of the pool from which borrower borrowed
    /// @return bool indicating whether the borrower has defaulted
    function didBorrowerDefault(address _poolID) external view override returns (bool) {
        uint256 _repaymentInterval = repayConstants[_poolID].repaymentInterval;
        uint256 _currentTime = block.timestamp.mul(SCALING_FACTOR);
        uint256 _gracePeriodFraction = repayConstants[_poolID].gracePeriodFraction;
        uint256 _nextInstalmentDeadline = getNextInstalmentDeadline(_poolID);
        uint256 _gracePeriodDeadline = _nextInstalmentDeadline.add(_gracePeriodFraction.mul(_repaymentInterval).div(SCALING_FACTOR));
        if (_currentTime > _gracePeriodDeadline) return true;
        else return false;
    }

    /// @notice Determines entire interest remaining to be paid for the loan issued to the borrower
    /// @dev (SCALING_FACTOR) is included to maintain the accuracy of the arithmetic operations
    /// @param _poolID address of the pool for which we want to calculate remaining interest
    /// @return interest remaining
    function getInterestLeft(address _poolID) public view returns (uint256) {
        uint256 _loanDurationLeft = repayConstants[_poolID].loanDuration.sub(repayVariables[_poolID].loanDurationCovered);
        uint256 _interestLeft = getInterest(_poolID, _loanDurationLeft);
        return _interestLeft;
    }

    /// @notice Returns the total amount that has been repaid by the borrower till now
    /// @param _poolID address of the pool
    /// @return total amount repaid
    function getTotalRepaidAmount(address _poolID) external view override returns (uint256) {
        return repayVariables[_poolID].repaidAmount;
    }

    /// @notice Returns the loanDurationCovered till now and the interest per second which will help in interest calculation
    /// @param _poolID address of the pool for which we want to calculate interest
    /// @return Loan Duration Covered and the interest per second
    function getInterestCalculationVars(address _poolID) external view override returns (uint256, uint256) {
        uint256 _interestPerSecond = getInterestPerSecond(_poolID);
        return (repayVariables[_poolID].loanDurationCovered, _interestPerSecond);
    }

    /// @notice Returns the fraction of repayment interval decided as the grace period fraction
    /// @return grace period fraction
    function getGracePeriodFraction() external view override returns (uint256) {
        return gracePeriodFraction;
    }
    //-------------------------------- Utils end --------------------------------/
}",5174
RealWorld_TA_101_MockAdminVerifier_RealWorld_20240812140725.log,101,MockAdminVerifier,81176,3131,84307,83.0,0.4685,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/drafts/EIP712Upgradeable.sol';
import '@openzeppelin/contracts/cryptography/ECDSA.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IVerifier.sol';

contract MockAdminVerifier is Initializable, IVerifier, OwnableUpgradeable, EIP712Upgradeable {
    /**
     * @notice stores the verification contract instance
     */
    IVerification public verification;

    /**
     * @notice emitted when verification contract address is updated
     * @param verification address of the updated verification contract
     */
    event VerificationUpdated(address indexed verification);
    /**
     * @notice emitted when Signer address is updated
     * @param signerAddress address of the updated verification contract
     */
    event SignerUpdated(address indexed signerAddress);

    /// @notice Initializes the variables of the contract
    /// @dev Contract follows proxy pattern and this function is used to initialize the variables for the contract in the proxy
    /// @param _admin Admin of the verification contract who can add verifiers and remove masterAddresses deemed invalid
    /// @param _verification Verification contract address
    /// @param _name name of the verifier (used in domain seperator)
    /// @param _version version of the verifier (used in domain seperator)
    function initialize(
        address _admin,
        address _verification,
        string memory _name,
        string memory _version
    ) external initializer {
        super.__Ownable_init();
        super.transferOwnership(_admin);
        _updateVerification(_verification);
        __EIP712_init(_name, _version);
    }

    /**
     * @notice used to register user
     * @dev only owner can register users
     */

    function registerSelf() external {
        require(!verification.isUser(msg.sender, address(this)), 'User already exists');
        verification.registerMasterAddress(msg.sender, true); // true because we'll always link address here

        emit UserRegistered(msg.sender, true, 'none');
    }

    function registerUserViaOwner(address _user) external onlyOwner {
        require(!verification.isUser(_user, address(this)), 'User already exists');
        verification.registerMasterAddress(_user, true); // true because we'll always link address here

        emit UserRegistered(_user, true, 'none');
    }

    /**
     * @notice used to unregister self
     * @dev users themselves can unregister themself
     */
    function unregisterSelf() external {
        require(verification.isUser(msg.sender, address(this)), 'User does not exist');
        verification.unregisterMasterAddress(msg.sender, address(this));

        emit UserUnregistered(msg.sender);
    }

    /**
     * @notice used to unregister user
     * @dev owners can unregister users
     */
    function unregisterUser(address _user) external onlyOwner {
        require(verification.isUser(_user, address(this)), 'User does not exist');
        verification.unregisterMasterAddress(_user, address(this));
        emit UserUnregistered(_user);
    }

    /**
     * @notice used to update verification contract address
     * @dev only owner can update
     * @param _verification address of the verification contract
     */
    function updateVerification(address _verification) external onlyOwner {
        _updateVerification(_verification);
    }

    function _updateVerification(address _verification) internal {
        verification = IVerification(_verification);
        emit VerificationUpdated(_verification);
    }
}",742
RealWorld_TA_101_PCLConstants.t_RealWorld_20240812162141.log,101,PCLConstants.t,62986,1524,64510,75.0,0.34541,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';

library PCLConstants {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 public constant maxCollateralRatio = (10**18) * 200;
    uint256 public constant minCollateralRatio = (10**16);

    uint256 public constant maxDuration = 7500 days; // in days
    uint256 public constant minDuration = 1 days; // in days

    uint256 public constant maxDefaultGraceDuration = 3650 days; // in days
    uint256 public constant minDefaultGraceDuration = 1 days; // in days

    uint256 public constant maxGracePenaltyRate = 10e18 - 1;
    uint256 public constant minGracePenaltyRate = 1;

    uint256 public constant maxCollectionPeriod = 7500 days; // in days
    uint256 public constant minCollectionPeriod = 1 days; // in days

    uint256 public constant maxBorrowLimit = 1e15; // ($1,000,000,000)
    uint256 public constant minBorrowLimit = 1e10; //($10000)

    uint128 public constant maxBorrowRate = (10**18) * 200;
    uint128 public constant minBorrowRate = 10**16;

    address public constant hevmAddress = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;

    uint256 public constant maxStrategies = 10;

    uint256 public constant protocolFeeFraction = 10e16;

    uint256 public constant startFeeFraction = 1e16;

    uint32 public constant uniswapPriceAveragingPeriod = 10;

    // Random addresses used as borrower/lender verifiers addresses
    address public constant _borrowerVerifier = 0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF;
    address public constant _lenderVerifier = 0xDEADbEEfDeAdBeeFdeAdbeefDEADbEEFDeaDBeeC;
}",562
RealWorld_TA_101_PCLERC1155HooksTest.t_RealWorld_20240812142200.log,101,PCLERC1155HooksTest.t,152486,4634,157120,109.0,0.85511,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../SublimeProxy.sol';
import '../../PooledCreditLine/PooledCreditLine.sol';
import '../../PooledCreditLine/LenderPool.sol';
import '../../PriceOracle.sol';
import '../../interfaces/IPriceOracle.sol';
import '../../SavingsAccount/SavingsAccount.sol';
import '../../yield/StrategyRegistry.sol';
import '../../yield/NoYield.sol';
import '../../yield/CompoundYield.sol';
import '../../mocks/MockV3Aggregator.sol';
import '../../mocks/MockToken.sol';
import '../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../interfaces/ISavingsAccount.sol';
import './Helpers/PCLParent.t.sol';

contract MaliciousLenderStart is PCLUser {
    constructor(address _pclAddress, address _lpAddress) PCLUser(_pclAddress, _lpAddress) {}

    function onERC1155Received(
        address,
        address,
        uint256 id,
        uint256,
        bytes calldata
    ) external override returns (bytes4) {
        // any code can be executed here
        LenderPool(msg.sender).start(id);
        return bytes4(keccak256('onERC1155Received(address,address,uint256,uint256,bytes)'));
    }
}

contract MaliciousLenderLiquidate is PCLUser {
    constructor(address _pclAddress, address _lpAddress) PCLUser(_pclAddress, _lpAddress) {}

    function onERC1155Received(
        address,
        address,
        uint256 id,
        uint256,
        bytes calldata
    ) external override returns (bytes4) {
        // any code can be executed here
        LenderPool(msg.sender).liquidate(id, true);
        return bytes4(keccak256('onERC1155Received(address,address,uint256,uint256,bytes)'));
    }
}

contract MaliciousLenderWithdrawInterest is PCLUser {
    constructor(address _pclAddress, address _lpAddress) PCLUser(_pclAddress, _lpAddress) {}

    function onERC1155Received(
        address,
        address,
        uint256 id,
        uint256,
        bytes calldata
    ) external override returns (bytes4) {
        // any code can be executed here
        LenderPool(msg.sender).withdrawInterest(id);
        return bytes4(keccak256('onERC1155Received(address,address,uint256,uint256,bytes)'));
    }
}

contract PCLERC1155HooksTest is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;
    }

    function test_lendERC1155Hook() public {
        requestId = borrower.createRequest(request);
        PCLUser _pooledCreditLineLender = new MaliciousLenderStart(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    function test_withdrawInterestERC1155Hook() public {
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _requiredCollateral);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowableAmount);

        _increaseBlock(block.timestamp + request.duration.div(2));

        PCLUser _pooledCreditLineLender = new MaliciousLenderWithdrawInterest(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.transferLPTokens(address(_pooledCreditLineLender), requestId, lp.balanceOf(address(_lender), requestId)) {
            revert('should throw LP:WI1');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_liquidateERC1155Hook() public {
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _requiredCollateral);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowableAmount);

        PCLUser _pooledCreditLineLender = new MaliciousLenderLiquidate(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        _increaseBlock(block.timestamp + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        _lender.transferLPTokens(address(_pooledCreditLineLender), requestId, lp.balanceOf(address(_lender), requestId));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }
}",1599
RealWorld_TA_101_MockTwitterVerifier_RealWorld_20240812140542.log,101,MockTwitterVerifier,147593,3461,151054,101.0,0.807185,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/drafts/EIP712Upgradeable.sol';
import '@openzeppelin/contracts/cryptography/ECDSA.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IVerifier.sol';

contract MockTwitterVerifier is Initializable, IVerifier, OwnableUpgradeable, EIP712Upgradeable {
    /**
     * @notice stores the verification contract instance
     */
    IVerification public verification;
    /**
     * @notice Structure for the user data
     */
    struct UserStructData {
        string twitterId;
        string tweetId;
    }

    /**
     * @notice stores the user metadata against their address
     */
    mapping(address => UserStructData) public userData;
    /**
     * @notice stores the user address against twitterId
     */
    mapping(string => address) public twitterIdMap;
    mapping(bytes32 => address) private hashAddressMap;
    /**
     * @notice stores the signer address
     */
    address public signerAddress;

    /**
     * @notice emitted when verification contract address is updated
     * @param verification address of the updated verification contract
     */
    event VerificationUpdated(address indexed verification);
    /**
     * @notice emitted when Signer address is updated
     * @param signerAddress address of the updated verification contract
     */
    event SignerUpdated(address indexed signerAddress);

    /// @notice Initializes the variables of the contract
    /// @dev Contract follows proxy pattern and this function is used to initialize the variables for the contract in the proxy
    /// @param _admin Admin of the verification contract who can add verifiers and remove masterAddresses deemed invalid
    /// @param _verification Verification contract address
    /// @param _signerAddress Address of the signer bot verifying users and signing off-chain messages
    /// @param _name name of the verifier (used in domain seperator)
    /// @param _version version of the verifier (used in domain seperator)
    function initialize(
        address _admin,
        address _verification,
        address _signerAddress,
        string memory _name,
        string memory _version
    ) external initializer {
        super.__Ownable_init();
        super.transferOwnership(_admin);
        _updateVerification(_verification);
        _updateSignerAddress(_signerAddress);
        __EIP712_init(_name, _version);
    }

    /**
     * @notice used to register user
     * @dev only owner can register users
     * @param _v int v
     * @param _r part signed message hash
     * @param _s part signed message hash
     * @param _timestamp timestamp for the signed message
     * @param _twitterId metadata related to user :  here ""twitterId""
     * @param _tweetId metadata related to user :  here ""tweetId""
     * @param _isMasterLinked should master address be linked to itself
     */

    function registerSelf(
        bool _isMasterLinked,
        uint8 _v,
        bytes32 _r,
        bytes32 _s,
        string memory _twitterId,
        string memory _tweetId,
        uint256 _timestamp
    ) external {
        require(bytes(userData[msg.sender].twitterId).length == 0, 'User already exists');
        require(twitterIdMap[_twitterId] == address(0), 'Signed message already used');
        require(block.timestamp < _timestamp + 86400, 'Signed transaction expired');

        bytes32 digest = keccak256(
            abi.encode(
                keccak256('set(string twitterId,string tweetId,address userAddr,uint256 timestamp)'),
                keccak256(bytes(_twitterId)),
                keccak256(bytes(_tweetId)),
                msg.sender,
                _timestamp
            )
        );
        require(hashAddressMap[digest] == address(0), 'Hash Already Used');

        bytes32 hash = _hashTypedDataV4(digest);
        address signer = ECDSA.recover(hash, _v, _r, _s);
        require(signer == signerAddress, 'Invalid signature');

        verification.registerMasterAddress(msg.sender, _isMasterLinked);
        userData[msg.sender] = UserStructData(_twitterId, _tweetId);
        twitterIdMap[_twitterId] = msg.sender;
        hashAddressMap[digest] = msg.sender;
        emit UserRegistered(msg.sender, _isMasterLinked, _twitterId);
    }

    function registerUserViaOwner(
        bool _isMasterLinked,
        address _user,
        string memory _twitterId,
        string memory _tweetId
    ) external onlyOwner {
        bytes32 digest = keccak256(
            abi.encode(
                keccak256('set(string twitterId,string tweetId,address userAddr,uint256 timestamp)'),
                keccak256(bytes(_twitterId)),
                keccak256(bytes(_tweetId)),
                _user,
                block.timestamp
            )
        );

        require(hashAddressMap[digest] == address(0), 'Hash Already Used');

        verification.registerMasterAddress(_user, _isMasterLinked);
        userData[_user] = UserStructData(_twitterId, _tweetId);
        twitterIdMap[_twitterId] = _user;
        hashAddressMap[digest] = _user;
        emit UserRegistered(_user, _isMasterLinked, _twitterId);
    }

    /**
     * @notice used to unregister self
     * @dev users themselves can unregister themself
     */
    function unregisterSelf() external {
        string memory _userdata = userData[msg.sender].twitterId;
        require(bytes(_userdata).length != 0, 'User doesnt exists');
        delete twitterIdMap[_userdata];
        delete userData[msg.sender];
        verification.unregisterMasterAddress(msg.sender, address(this));
        emit UserUnregistered(msg.sender);
    }

    /**
     * @notice used to unregister user
     * @dev owners can unregister users
     */
    function unregisterUser(address _user) external onlyOwner {
        string memory _userdata = userData[_user].twitterId;
        require(bytes(_userdata).length != 0, 'User does not exists');
        delete twitterIdMap[_userdata];
        delete userData[_user];
        verification.unregisterMasterAddress(_user, address(this));
        emit UserUnregistered(_user);
    }

    /**
     * @notice used to update verification contract address
     * @dev only owner can update
     * @param _verification address of the verification contract
     */
    function updateVerification(address _verification) external onlyOwner {
        _updateVerification(_verification);
    }

    function _updateVerification(address _verification) internal {
        verification = IVerification(_verification);
        emit VerificationUpdated(_verification);
    }

    /**
     * @notice used to update signer address
     * @dev only owner can update
     * @param _signerAddress address of the verification contract
     */
    function updateSignerAddress(address _signerAddress) external onlyOwner {
        _updateSignerAddress(_signerAddress);
    }

    function _updateSignerAddress(address _signerAddress) internal {
        signerAddress = _signerAddress;
        emit SignerUpdated(signerAddress);
    }
}",1524
RealWorld_TA_102_MockRateLimitedMinter_RealWorld_20240812170007.log,102,MockRateLimitedMinter,33159,3086,36245,94.0,0.227515,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""../volt/minter/RateLimitedMinter.sol"";

contract MockRateLimitedMinter is RateLimitedMinter {
    constructor(
        address _core,
        uint256 _feiLimitPerSecond,
        uint256 _mintingBufferCap,
        bool _doPartialMint
    )
        CoreRef(_core)
        RateLimitedMinter(_feiLimitPerSecond, _mintingBufferCap, _doPartialMint)
    {}

    function setDoPartialMint(bool _doPartialMint) public {
        doPartialAction = _doPartialMint;
    }

    function mint(address to, uint256 amount) public {
        _mintVolt(to, amount);
    }
}",168
RealWorld_TA_102_NonCustodialPSM_RealWorld_20240812173131.log,102,NonCustodialPSM,345766,4416,350182,134.0,1.81715,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {Decimal} from ""../external/Decimal.sol"";
import {Constants} from ""../Constants.sol"";
import {OracleRef} from ""./../refs/OracleRef.sol"";
import {TribeRoles} from ""./../core/TribeRoles.sol"";
import {RateLimited} from ""./../utils/RateLimited.sol"";
import {IPCVDeposit, PCVDeposit} from ""./../pcv/PCVDeposit.sol"";
import {INonCustodialPSM} from ""./INonCustodialPSM.sol"";
import {GlobalRateLimitedMinter} from ""./../utils/GlobalRateLimitedMinter.sol"";
import {Math} from ""@openzeppelin/contracts/utils/math/Math.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeCast} from ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import {ReentrancyGuard} from ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/// @notice Peg Stability Module that holds no funds.
/// On a mint, it transfers all proceeds to a PCV Deposit
/// When funds are needed for a redemption, they are simply pulled from the PCV Deposit
contract NonCustodialPSM is
    OracleRef,
    RateLimited,
    ReentrancyGuard,
    INonCustodialPSM
{
    using Decimal for Decimal.D256;
    using SafeCast for *;
    using SafeERC20 for IERC20;

    /// @notice the fee in basis points for selling an asset into VOLT
    uint256 public override mintFeeBasisPoints;

    /// @notice the fee in basis points for buying the asset for VOLT
    uint256 public override redeemFeeBasisPoints;

    /// @notice the PCV deposit target to deposit and withdraw from
    IPCVDeposit public override pcvDeposit;

    /// @notice the token this PSM will exchange for VOLT
    /// Must be a stable token pegged to $1
    IERC20 public immutable override underlyingToken;

    /// @notice Rate Limited Minter contract that will be called when VOLT needs to be minted
    GlobalRateLimitedMinter public override rateLimitedMinter;

    /// @notice the max mint and redeem fee in basis points
    /// Governance cannot change the maximum fee
    uint256 public immutable override MAX_FEE = 300;

    /// @notice boolean switch that indicates whether redeeming is paused
    bool public redeemPaused;

    /// @notice boolean switch that indicates whether minting is paused
    bool public mintPaused;

    /// @notice struct for passing constructor parameters related to OracleRef
    struct OracleParams {
        address coreAddress;
        address oracleAddress;
        address backupOracle;
        int256 decimalsNormalizer;
    }

    /// @notice struct for passing constructor parameters related to MultiRateLimited
    struct RateLimitedParams {
        uint256 maxRateLimitPerSecond;
        uint256 rateLimitPerSecond;
        uint256 bufferCap;
    }

    /// @notice struct for passing constructor parameters related to the non custodial PSM
    struct PSMParams {
        uint256 mintFeeBasisPoints;
        uint256 redeemFeeBasisPoints;
        IERC20 underlyingToken;
        IPCVDeposit pcvDeposit;
        GlobalRateLimitedMinter rateLimitedMinter;
    }

    /// @notice construct the non custodial PSM. Structs are used to prevent stack too deep errors
    /// @param params oracle ref constructor data
    /// @param rateLimitedParams rate limited constructor data
    /// @param psmParams non custodial PSM constructor data
    constructor(
        OracleParams memory params,
        RateLimitedParams memory rateLimitedParams,
        PSMParams memory psmParams
    )
        OracleRef(
            params.coreAddress,
            params.oracleAddress,
            params.backupOracle,
            params.decimalsNormalizer,
            true /// hardcode doInvert to true to allow swaps to work correctly
        )
        /// rate limited replenishable passes false as the last param as there can be no partial actions
        RateLimited(
            rateLimitedParams.maxRateLimitPerSecond,
            rateLimitedParams.rateLimitPerSecond,
            rateLimitedParams.bufferCap,
            false
        )
    {
        underlyingToken = psmParams.underlyingToken;

        _setGlobalRateLimitedMinter(psmParams.rateLimitedMinter);
        _setMintFee(psmParams.mintFeeBasisPoints);
        _setRedeemFee(psmParams.redeemFeeBasisPoints);
        _setPCVDeposit(psmParams.pcvDeposit);
    }

    // ----------- Mint & Redeem pausing modifiers -----------

    /// @notice modifier that allows execution when redemptions are not paused
    modifier whileRedemptionsNotPaused() {
        require(!redeemPaused, ""PegStabilityModule: Redeem paused"");
        _;
    }

    /// @notice modifier that allows execution when minting is not paused
    modifier whileMintingNotPaused() {
        require(!mintPaused, ""PegStabilityModule: Minting paused"");
        _;
    }

    // ----------- Governor & Guardian only pausing api -----------

    /// @notice set secondary pausable methods to paused
    function pauseRedeem() external onlyGuardianOrGovernor {
        redeemPaused = true;
        emit RedemptionsPaused(msg.sender);
    }

    /// @notice set secondary pausable methods to unpaused
    function unpauseRedeem() external onlyGuardianOrGovernor {
        redeemPaused = false;
        emit RedemptionsUnpaused(msg.sender);
    }

    /// @notice set secondary pausable methods to paused
    function pauseMint() external onlyGuardianOrGovernor {
        mintPaused = true;
        emit MintingPaused(msg.sender);
    }

    /// @notice set secondary pausable methods to unpaused
    function unpauseMint() external onlyGuardianOrGovernor {
        mintPaused = false;
        emit MintingUnpaused(msg.sender);
    }

    // ----------- Governor, psm admin and parameter admin only state changing api -----------

    /// @notice set the mint fee vs oracle price in basis point terms
    /// @param newMintFeeBasisPoints the new fee in basis points for minting
    function setMintFee(uint256 newMintFeeBasisPoints)
        external
        override
        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PARAMETER_ADMIN)
    {
        _setMintFee(newMintFeeBasisPoints);
    }

    /// @notice set the redemption fee vs oracle price in basis point terms
    /// @param newRedeemFeeBasisPoints the new fee in basis points for redemptions
    function setRedeemFee(uint256 newRedeemFeeBasisPoints)
        external
        override
        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PARAMETER_ADMIN)
    {
        _setRedeemFee(newRedeemFeeBasisPoints);
    }

    /// @notice set the target for sending all PCV
    /// @param newTarget new PCV Deposit target for this PSM
    function setPCVDeposit(IPCVDeposit newTarget)
        external
        override
        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PSM_ADMIN_ROLE)
    {
        _setPCVDeposit(newTarget);
    }

    /// @notice set the target to call for VOLT minting
    /// @param newMinter new Global Rate Limited Minter for this PSM
    function setGlobalRateLimitedMinter(GlobalRateLimitedMinter newMinter)
        external
        override
        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PSM_ADMIN_ROLE)
    {
        _setGlobalRateLimitedMinter(newMinter);
    }

    // ----------- PCV Controller only state changing api -----------

    /// @notice withdraw ERC20 from the contract
    /// @param token address of the ERC20 to send
    /// @param to address destination of the ERC20
    /// @param amount quantity of ERC20 to send
    function withdrawERC20(
        address token,
        address to,
        uint256 amount
    ) external override onlyPCVController {
        IERC20(token).safeTransfer(to, amount);
        emit WithdrawERC20(msg.sender, token, to, amount);
    }

    // ----------- Public State Changing API -----------

    /// @notice function to redeem VOLT for an underlying asset
    /// We do not burn VOLT; this allows the contract's balance of VOLT to be used before the buffer is used
    /// In practice, this helps prevent artificial cycling of mint-burn cycles and prevents DOS attacks.
    /// This function will deplete the buffer based on the amount of VOLT that is being redeemed.
    /// @param to the destination address for proceeds
    /// @param amountVoltIn the amount of VOLT to sell
    /// @param minAmountOut the minimum amount out otherwise the TX will fail
    function redeem(
        address to,
        uint256 amountVoltIn,
        uint256 minAmountOut
    )
        external
        virtual
        override
        nonReentrant
        whenNotPaused
        whileRedemptionsNotPaused
        returns (uint256 amountOut)
    {
        _depleteBuffer(amountVoltIn); /// deplete buffer first to save gas on buffer exhaustion sad path

        updateOracle();

        amountOut = _getRedeemAmountOut(amountVoltIn);
        require(
            amountOut >= minAmountOut,
            ""PegStabilityModule: Redeem not enough out""
        );

        IERC20(volt()).safeTransferFrom(
            msg.sender,
            address(this),
            amountVoltIn
        );

        pcvDeposit.withdraw(to, amountOut);

        emit Redeem(to, amountVoltIn, amountOut);
    }

    /// @notice function to buy VOLT for an underlying asset that is pegged to $1
    /// We first transfer any contract-owned VOLT, then mint the remaining if necessary
    /// This function will replenish the buffer based on the amount of VOLT that is being sent out.
    /// @param to the destination address for proceeds
    /// @param amountIn the amount of external asset to sell to the PSM
    /// @param minVoltAmountOut the minimum amount of VOLT out otherwise the TX will fail
    function mint(
        address to,
        uint256 amountIn,
        uint256 minVoltAmountOut
    )
        external
        virtual
        override
        nonReentrant
        whenNotPaused
        whileMintingNotPaused
        returns (uint256 amountVoltOut)
    {
        updateOracle();

        amountVoltOut = _getMintAmountOut(amountIn);
        require(
            amountVoltOut >= minVoltAmountOut,
            ""PegStabilityModule: Mint not enough out""
        );

        underlyingToken.safeTransferFrom(
            msg.sender,
            address(pcvDeposit),
            amountIn
        );

        uint256 amountFeiToTransfer = Math.min(
            volt().balanceOf(address(this)),
            amountVoltOut
        );
        uint256 amountFeiToMint = amountVoltOut - amountFeiToTransfer;

        if (amountFeiToTransfer != 0) {
            IERC20(volt()).safeTransfer(to, amountFeiToTransfer);
        }

        if (amountFeiToMint != 0) {
            rateLimitedMinter.mintVolt(to, amountFeiToMint);
        }

        _replenishBuffer(amountVoltOut);

        emit Mint(to, amountIn, amountVoltOut);
    }

    // ----------- Public View-Only API ----------

    /// @notice calculate the amount of VOLT out for a given `amountIn` of underlying
    /// First get oracle price of token
    /// Then figure out how many dollars that amount in is worth by multiplying price * amount.
    /// ensure decimals are normalized if on underlying they are not 18
    /// @param amountIn the amount of external asset to sell to the PSM
    /// @return amountVoltOut the amount of VOLT received for the amountIn of external asset
    function getMintAmountOut(uint256 amountIn)
        public
        view
        override
        returns (uint256 amountVoltOut)
    {
        amountVoltOut = _getMintAmountOut(amountIn);
    }

    /// @notice calculate the amount of underlying out for a given `amountVoltIn` of VOLT
    /// First get oracle price of token
    /// Then figure out how many dollars that amount in is worth by multiplying price * amount.
    /// ensure decimals are normalized if on underlying they are not 18
    /// @param amountVoltIn the amount of VOLT to redeem
    /// @return amountTokenOut the amount of the external asset received in exchange for the amount of VOLT redeemed
    function getRedeemAmountOut(uint256 amountVoltIn)
        public
        view
        override
        returns (uint256 amountTokenOut)
    {
        amountTokenOut = _getRedeemAmountOut(amountVoltIn);
    }

    /// @notice getter to return the maximum amount of VOLT that could be purchased at once
    /// @return the maximum amount of VOLT available for purchase at once through this PSM
    function getMaxMintAmountOut() external view override returns (uint256) {
        return
            volt().balanceOf(address(this)) +
            rateLimitedMinter.individualBuffer(address(this));
    }

    // ----------- Internal Methods -----------

    /// @notice helper function to get mint amount out based on current market prices
    /// @dev will revert if price is outside of bounds and price bound PSM is being used
    /// @param amountIn the amount of stable asset in
    /// @return amountVoltOut the amount of VOLT received for the amountIn of stable assets
    function _getMintAmountOut(uint256 amountIn)
        internal
        view
        virtual
        returns (uint256 amountVoltOut)
    {
        Decimal.D256 memory price = readOracle();
        _validatePriceRange(price);

        Decimal.D256 memory adjustedAmountIn = price.mul(amountIn);

        amountVoltOut = adjustedAmountIn
            .mul(Constants.BASIS_POINTS_GRANULARITY - mintFeeBasisPoints)
            .div(Constants.BASIS_POINTS_GRANULARITY)
            .asUint256();
    }

    /// @notice helper function to get redeem amount out based on current market prices
    /// @dev will revert if price is outside of bounds and price bound PSM is being used
    /// @param amountVoltIn the amount of VOLT to redeem
    /// @return amountTokenOut the amount of the external asset received in exchange for the amount of VOLT redeemed
    function _getRedeemAmountOut(uint256 amountVoltIn)
        internal
        view
        virtual
        returns (uint256 amountTokenOut)
    {
        Decimal.D256 memory price = readOracle();
        _validatePriceRange(price);

        /// get amount of VOLT being provided being redeemed after fees
        Decimal.D256 memory adjustedAmountIn = Decimal.from(
            (amountVoltIn *
                (Constants.BASIS_POINTS_GRANULARITY - redeemFeeBasisPoints)) /
                Constants.BASIS_POINTS_GRANULARITY
        );

        /// now turn the VOLT into the underlying token amounts
        /// amount VOLT in / VOLT you receive for $1 = how much stable token to pay out
        amountTokenOut = adjustedAmountIn.div(price).asUint256();
    }

    // ----------- Helper methods to change state -----------

    /// @notice set the global rate limited minter this PSM calls to mint VOLT
    /// @param newMinter the new minter contract that this PSM will reference
    function _setGlobalRateLimitedMinter(GlobalRateLimitedMinter newMinter)
        internal
    {
        require(
            address(newMinter) != address(0),
            ""PegStabilityModule: Invalid new GlobalRateLimitedMinter""
        );
        GlobalRateLimitedMinter oldMinter = rateLimitedMinter;
        rateLimitedMinter = newMinter;

        emit GlobalRateLimitedMinterUpdate(oldMinter, newMinter);
    }

    /// @notice set the mint fee vs oracle price in basis point terms
    /// @param newMintFeeBasisPoints the new fee for minting in basis points
    function _setMintFee(uint256 newMintFeeBasisPoints) internal {
        require(
            newMintFeeBasisPoints <= MAX_FEE,
            ""PegStabilityModule: Mint fee exceeds max fee""
        );
        uint256 _oldMintFee = mintFeeBasisPoints;
        mintFeeBasisPoints = newMintFeeBasisPoints;

        emit MintFeeUpdate(_oldMintFee, newMintFeeBasisPoints);
    }

    /// @notice internal helper function to set the redemption fee
    /// @param newRedeemFeeBasisPoints the new fee for redemptions in basis points
    function _setRedeemFee(uint256 newRedeemFeeBasisPoints) internal {
        require(
            newRedeemFeeBasisPoints <= MAX_FEE,
            ""PegStabilityModule: Redeem fee exceeds max fee""
        );
        uint256 _oldRedeemFee = redeemFeeBasisPoints;
        redeemFeeBasisPoints = newRedeemFeeBasisPoints;

        emit RedeemFeeUpdate(_oldRedeemFee, newRedeemFeeBasisPoints);
    }

    /// @notice helper function to set the PCV deposit
    /// @param newPCVDeposit the new PCV deposit that this PSM will pull assets from and deposit assets into
    function _setPCVDeposit(IPCVDeposit newPCVDeposit) internal {
        require(
            address(newPCVDeposit) != address(0),
            ""PegStabilityModule: Invalid new PCVDeposit""
        );
        require(
            newPCVDeposit.balanceReportedIn() == address(underlyingToken),
            ""PegStabilityModule: Underlying token mismatch""
        );
        IPCVDeposit oldTarget = pcvDeposit;
        pcvDeposit = newPCVDeposit;

        emit PCVDepositUpdate(oldTarget, newPCVDeposit);
    }

    // ----------- Hooks -----------

    /// @notice overriden function in the price bound PSM
    function _validatePriceRange(Decimal.D256 memory price)
        internal
        view
        virtual
    {}
}",3992
RealWorld_TA_102_DSTest_RealWorld_20240812165053.log,102,DSTest,340480,1538,342018,93.0,1.73316,"// SPDX-License-Identifier: GPL-3.0-or-later

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity >=0.4.23;

contract DSTest {
    event log(string);
    event logs(bytes);

    event log_address(address);
    event log_bytes32(bytes32);
    event log_int(int256);
    event log_uint(uint256);
    event log_bytes(bytes);
    event log_string(string);

    event log_named_address(string key, address val);
    event log_named_bytes32(string key, bytes32 val);
    event log_named_decimal_int(string key, int256 val, uint256 decimals);
    event log_named_decimal_uint(string key, uint256 val, uint256 decimals);
    event log_named_int(string key, int256 val);
    event log_named_uint(string key, uint256 val);
    event log_named_bytes(string key, bytes val);
    event log_named_string(string key, string val);

    bool public IS_TEST = true;
    bool public failed;

    address constant HEVM_ADDRESS =
        address(bytes20(uint160(uint256(keccak256(""hevm cheat code"")))));

    modifier mayRevert() {
        _;
    }
    modifier testopts(string memory) {
        _;
    }

    function fail() internal {
        failed = true;
    }

    modifier logs_gas() {
        uint256 startGas = gasleft();
        _;
        uint256 endGas = gasleft();
        emit log_named_uint(""gas"", startGas - endGas);
    }

    function assertTrue(bool condition) internal {
        if (!condition) {
            emit log(""Error: Assertion Failed"");
            fail();
        }
    }

    function assertTrue(bool condition, string memory err) internal {
        if (!condition) {
            emit log_named_string(""Error"", err);
            assertTrue(condition);
        }
    }

    function assertEq(address a, address b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [address]"");
            emit log_named_address(""  Expected"", b);
            emit log_named_address(""    Actual"", a);
            fail();
        }
    }

    function assertEq(
        address a,
        address b,
        string memory err
    ) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }

    function assertEq(bytes32 a, bytes32 b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [bytes32]"");
            emit log_named_bytes32(""  Expected"", b);
            emit log_named_bytes32(""    Actual"", a);
            fail();
        }
    }

    function assertEq(
        bytes32 a,
        bytes32 b,
        string memory err
    ) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }

    function assertEq32(bytes32 a, bytes32 b) internal {
        assertEq(a, b);
    }

    function assertEq32(
        bytes32 a,
        bytes32 b,
        string memory err
    ) internal {
        assertEq(a, b, err);
    }

    function assertEq(int256 a, int256 b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [int]"");
            emit log_named_int(""  Expected"", b);
            emit log_named_int(""    Actual"", a);
            fail();
        }
    }

    function assertEq(
        int256 a,
        int256 b,
        string memory err
    ) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }

    function assertEq(uint256 a, uint256 b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [uint]"");
            emit log_named_uint(""  Expected"", b);
            emit log_named_uint(""    Actual"", a);
            fail();
        }
    }

    function assertEq(
        uint256 a,
        uint256 b,
        string memory err
    ) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }

    function assertEqDecimal(
        int256 a,
        int256 b,
        uint256 decimals
    ) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Expected"", b, decimals);
            emit log_named_decimal_int(""    Actual"", a, decimals);
            fail();
        }
    }

    function assertEqDecimal(
        int256 a,
        int256 b,
        uint256 decimals,
        string memory err
    ) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEqDecimal(a, b, decimals);
        }
    }

    function assertEqDecimal(
        uint256 a,
        uint256 b,
        uint256 decimals
    ) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Expected"", b, decimals);
            emit log_named_decimal_uint(""    Actual"", a, decimals);
            fail();
        }
    }

    function assertEqDecimal(
        uint256 a,
        uint256 b,
        uint256 decimals,
        string memory err
    ) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEqDecimal(a, b, decimals);
        }
    }

    function assertGt(uint256 a, uint256 b) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }

    function assertGt(
        uint256 a,
        uint256 b,
        string memory err
    ) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGt(a, b);
        }
    }

    function assertGt(int256 a, int256 b) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }

    function assertGt(
        int256 a,
        int256 b,
        string memory err
    ) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGt(a, b);
        }
    }

    function assertGtDecimal(
        int256 a,
        int256 b,
        uint256 decimals
    ) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }

    function assertGtDecimal(
        int256 a,
        int256 b,
        uint256 decimals,
        string memory err
    ) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGtDecimal(a, b, decimals);
        }
    }

    function assertGtDecimal(
        uint256 a,
        uint256 b,
        uint256 decimals
    ) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }

    function assertGtDecimal(
        uint256 a,
        uint256 b,
        uint256 decimals,
        string memory err
    ) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGtDecimal(a, b, decimals);
        }
    }

    function assertGe(uint256 a, uint256 b) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }

    function assertGe(
        uint256 a,
        uint256 b,
        string memory err
    ) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGe(a, b);
        }
    }

    function assertGe(int256 a, int256 b) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }

    function assertGe(
        int256 a,
        int256 b,
        string memory err
    ) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGe(a, b);
        }
    }

    function assertGeDecimal(
        int256 a,
        int256 b,
        uint256 decimals
    ) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }

    function assertGeDecimal(
        int256 a,
        int256 b,
        uint256 decimals,
        string memory err
    ) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGeDecimal(a, b, decimals);
        }
    }

    function assertGeDecimal(
        uint256 a,
        uint256 b,
        uint256 decimals
    ) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }

    function assertGeDecimal(
        uint256 a,
        uint256 b,
        uint256 decimals,
        string memory err
    ) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGeDecimal(a, b, decimals);
        }
    }

    function assertLt(uint256 a, uint256 b) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }

    function assertLt(
        uint256 a,
        uint256 b,
        string memory err
    ) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLt(a, b);
        }
    }

    function assertLt(int256 a, int256 b) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }

    function assertLt(
        int256 a,
        int256 b,
        string memory err
    ) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLt(a, b);
        }
    }

    function assertLtDecimal(
        int256 a,
        int256 b,
        uint256 decimals
    ) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }

    function assertLtDecimal(
        int256 a,
        int256 b,
        uint256 decimals,
        string memory err
    ) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLtDecimal(a, b, decimals);
        }
    }

    function assertLtDecimal(
        uint256 a,
        uint256 b,
        uint256 decimals
    ) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }

    function assertLtDecimal(
        uint256 a,
        uint256 b,
        uint256 decimals,
        string memory err
    ) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLtDecimal(a, b, decimals);
        }
    }

    function assertLe(uint256 a, uint256 b) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }

    function assertLe(
        uint256 a,
        uint256 b,
        string memory err
    ) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertLe(a, b);
        }
    }

    function assertLe(int256 a, int256 b) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }

    function assertLe(
        int256 a,
        int256 b,
        string memory err
    ) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertLe(a, b);
        }
    }

    function assertLeDecimal(
        int256 a,
        int256 b,
        uint256 decimals
    ) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }

    function assertLeDecimal(
        int256 a,
        int256 b,
        uint256 decimals,
        string memory err
    ) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertLeDecimal(a, b, decimals);
        }
    }

    function assertLeDecimal(
        uint256 a,
        uint256 b,
        uint256 decimals
    ) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }

    function assertLeDecimal(
        uint256 a,
        uint256 b,
        uint256 decimals,
        string memory err
    ) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertGeDecimal(a, b, decimals);
        }
    }

    function assertEq(string memory a, string memory b) internal {
        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
            emit log(""Error: a == b not satisfied [string]"");
            emit log_named_string(""  Value a"", a);
            emit log_named_string(""  Value b"", b);
            fail();
        }
    }

    function assertEq(
        string memory a,
        string memory b,
        string memory err
    ) internal {
        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }

    function checkEq0(bytes memory a, bytes memory b)
        internal
        pure
        returns (bool ok)
    {
        ok = true;
        if (a.length == b.length) {
            for (uint256 i = 0; i < a.length; i++) {
                if (a[i] != b[i]) {
                    ok = false;
                }
            }
        } else {
            ok = false;
        }
    }

    function assertEq0(bytes memory a, bytes memory b) internal {
        if (!checkEq0(a, b)) {
            emit log(""Error: a == b not satisfied [bytes]"");
            emit log_named_bytes(""  Expected"", a);
            emit log_named_bytes(""    Actual"", b);
            fail();
        }
    }

    function assertEq0(
        bytes memory a,
        bytes memory b,
        string memory err
    ) internal {
        if (!checkEq0(a, b)) {
            emit log_named_string(""Error"", err);
            assertEq0(a, b);
        }
    }
}",3849
RealWorld_TA_102_IPCVDepositBalances_RealWorld_20240812173654.log,102,IPCVDepositBalances,31219,1240,32459,68.0,0.180895,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

/// @title a PCV Deposit interface for only balance getters
/// @author Fei Protocol
interface IPCVDepositBalances {
    // ----------- Getters -----------

    /// @notice gets the effective balance of ""balanceReportedIn"" token if the deposit were fully withdrawn
    function balance() external view returns (uint256);

    /// @notice gets the token address in which this deposit returns its balance
    function balanceReportedIn() external view returns (address);

    /// @notice gets the resistant token balance and protocol owned fei of this deposit
    function resistantBalanceAndVolt() external view returns (uint256, uint256);
}",156
RealWorld_TA_102_IntegrationTestVoltDeployment.t_RealWorld_20240812165413.log,102,IntegrationTestVoltDeployment.t,230507,3967,234474,123.0,1.231875,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import {Vm} from ""./../unit/utils/Vm.sol"";
import {ICore} from ""../../core/ICore.sol"";
import {DSTest} from ""../unit/utils/DSTest.sol"";
import {StdLib} from ""../unit/utils/StdLib.sol"";
import {MockERC20} from ""../../mock/MockERC20.sol"";
import {IVolt, Volt} from ""../../volt/Volt.sol"";
import {OraclePassThrough} from ""../../oracle/OraclePassThrough.sol"";
import {ScalingPriceOracle} from ""../../oracle/ScalingPriceOracle.sol"";
import {MockScalingPriceOracle} from ""../../mock/MockScalingPriceOracle.sol"";
import {ERC20CompoundPCVDeposit} from ""../../pcv/compound/ERC20CompoundPCVDeposit.sol"";
import {getCore, getAddresses, FeiTestAddresses} from ""./../unit/utils/Fixtures.sol"";
import {NonCustodialPSM, GlobalRateLimitedMinter} from ""./../../peg/NonCustodialPSM.sol"";

// Create Core
// Global Rate Limited Minter
// Oracle System
// - Scaling Price Oracle
// - Oracle Pass Through

contract IntegrationTestVoltDeployment is DSTest, StdLib {
    GlobalRateLimitedMinter private rateLimitedMinter;
    NonCustodialPSM private psm;
    ICore private core;
    ICore private feiCore = ICore(0x8d5ED43dCa8C2F7dFB20CF7b53CC7E593635d7b9);
    IVolt private volt;
    IVolt private fei = IVolt(0x956F47F50A910163D8BF957Cf5846D573E7f87CA);

    /// ------------ Minting and RateLimited System Params ------------

    uint256 public constant mintAmount = 10_000_000e18;
    uint256 public constant bufferCap = 10_000_000e18;
    uint256 public constant individualMaxBufferCap = 5_000_000e18;
    uint256 public constant rps = 10_000e18;

    /// ------------ Oracle System Params ------------

    /// @notice prices during test will increase 1% monthly
    int256 public constant monthlyChangeRateBasisPoints = 100;
    uint256 public constant maxDeviationThresholdBasisPoints = 1_000;

    /// @notice chainlink job id on mainnet
    bytes32 public immutable jobId =
        0x3666376662346162636564623438356162323765623762623339636166383237;
    /// @notice chainlink oracle address on mainnet
    address public immutable oracleAddress =
        0x049Bd8C3adC3fE7d3Fc2a44541d955A537c2A484;

    /// @notice live FEI PCV Deposit
    ERC20CompoundPCVDeposit public immutable rariFEIPCVDeposit =
        ERC20CompoundPCVDeposit(0x81DCB06eA4db474D1506Ca6275Ff7D870bA3A1Be);

    /// @notice fei DAO timelock address
    address public immutable feiDAOTimelock =
        0xd51dbA7a94e1adEa403553A8235C302cEbF41a3c;

    /// @notice Oracle Pass Through contract
    OraclePassThrough public oracle;

    Vm public constant vm = Vm(HEVM_ADDRESS);
    FeiTestAddresses public addresses = getAddresses();

    function setUp() public {
        core = getCore();
        volt = core.volt();
        MockScalingPriceOracle mockScalingPriceOracle = new MockScalingPriceOracle(
                oracleAddress,
                jobId,
                10e18,
                101,
                100
            );

        oracle = new OraclePassThrough(
            ScalingPriceOracle(address(mockScalingPriceOracle))
        );

        rateLimitedMinter = new GlobalRateLimitedMinter(
            address(core),
            rps,
            rps,
            rps,
            individualMaxBufferCap,
            bufferCap
        );

        NonCustodialPSM.OracleParams memory oracleParams = NonCustodialPSM
            .OracleParams({
                coreAddress: address(core),
                oracleAddress: address(oracle),
                backupOracle: address(0),
                decimalsNormalizer: 0
            });

        NonCustodialPSM.RateLimitedParams
            memory multiRateLimitedParams = NonCustodialPSM.RateLimitedParams({
                maxRateLimitPerSecond: rps,
                rateLimitPerSecond: rps,
                bufferCap: bufferCap
            });

        NonCustodialPSM.PSMParams memory psmParams = NonCustodialPSM.PSMParams({
            mintFeeBasisPoints: 0,
            redeemFeeBasisPoints: 0,
            underlyingToken: fei,
            pcvDeposit: rariFEIPCVDeposit,
            rateLimitedMinter: rateLimitedMinter
        });

        /// create PSM
        psm = new NonCustodialPSM(
            oracleParams,
            multiRateLimitedParams,
            psmParams
        );

        vm.prank(feiDAOTimelock);
        feiCore.grantPCVController(address(psm));
        vm.prank(feiDAOTimelock);
        fei.mint(address(this), mintAmount);

        vm.startPrank(addresses.governorAddress);

        /// grant the PSM the PCV Controller role
        core.grantMinter(addresses.governorAddress);
        core.grantMinter(address(rateLimitedMinter));
        core.grantPCVController(address(psm));
        core.grantPCVController(addresses.governorAddress);
        rateLimitedMinter.addAddress(
            address(this),
            uint112(rps),
            uint112(bufferCap)
        );
        rateLimitedMinter.addAddress(
            address(psm),
            uint112(rps),
            uint112(bufferCap)
        );

        /// mint VOLT to the user
        volt.mint(address(this), mintAmount);

        vm.stopPrank();
    }

    /// @notice PSM is set up correctly and view functions are working
    function testGetMintAmountOut() public {
        uint256 amountFeiIn = 100;
        assertEq(psm.getMintAmountOut(amountFeiIn), amountFeiIn);
    }

    /// @notice PSM is set up correctly and view functions are working
    function testGetMintAmountOutMintAmount() public {
        assertEq(psm.getMintAmountOut(mintAmount), mintAmount);
    }

    /// @notice PSM is set up correctly and view functions are working
    function testGetMintAmountOutAfterTime() public {
        /// assert that for 101 stables you get 100 VOLT after volt price increases 1%
        uint256 amountFeiIn = 101_000;
        uint256 expectedAmountVoltOut = 99999; /// subtract 1 for precision loss from doInvert

        /// advance the full time period to get the full 1% price increase
        vm.warp(28 days + block.timestamp);

        assertEq(psm.getMintAmountOut(amountFeiIn), expectedAmountVoltOut);
    }

    /// @notice PSM is set up correctly and view functions are working
    function testGetRedeemAmountOut() public {
        uint256 amountFeiIn = 100;
        assertEq(psm.getRedeemAmountOut(amountFeiIn), amountFeiIn);
    }

    /// @notice PSM is set up correctly and view functions are working
    function testGetRedeemAmountOutAfterTime() public {
        uint256 amountVoltIn = 100_000;
        uint256 expectedAmountStableOut = 101_000;

        /// advance the full time period to get the full 1% price increase
        vm.warp(28 days + block.timestamp);

        assertEq(psm.getRedeemAmountOut(amountVoltIn), expectedAmountStableOut);
    }

    /// this test uses FEI as the underlying asset and hooks into a FEI PCV Deposit
    function testSwap() public {
        rariFEIPCVDeposit.deposit(); // get env cleaned up and ready for testing
        uint256 startingUserVoltBalance = volt.balanceOf(address(this));
        uint256 startingPCVDepositFeiBalance = rariFEIPCVDeposit.balance();

        fei.approve(address(psm), mintAmount);
        psm.mint(address(this), mintAmount, mintAmount);
        rariFEIPCVDeposit.deposit();

        uint256 endingUserVoltBalance = volt.balanceOf(address(this));
        uint256 endingPCVDepositFeiBalance = rariFEIPCVDeposit.balance();

        assertEq(endingUserVoltBalance - startingUserVoltBalance, mintAmount);
        assertEq(
            endingPCVDepositFeiBalance - startingPCVDepositFeiBalance,
            mintAmount - 1 /// goes down by 1 because of cToken pricing rounding down
        );
    }

    /// this test uses FEI as the underlying asset and hooks into a FEI PCV Deposit
    function testMintAfterPriceIncrease() public {
        uint256 amountFeiIn = 101_000;
        uint256 amountVoltOut = 99_999;

        rariFEIPCVDeposit.deposit(); // get env cleaned up and ready for testing
        vm.warp(28 days + block.timestamp);

        uint256 startingUserVoltBalance = volt.balanceOf(address(this));
        uint256 startingPCVDepositFeiBalance = rariFEIPCVDeposit.balance();

        fei.approve(address(psm), amountFeiIn);
        psm.mint(address(this), amountFeiIn, amountVoltOut);
        rariFEIPCVDeposit.deposit();

        uint256 endingUserVoltBalance = volt.balanceOf(address(this));
        uint256 endingPCVDepositFeiBalance = rariFEIPCVDeposit.balance();

        assertEq(
            endingUserVoltBalance - startingUserVoltBalance,
            amountVoltOut
        );
        assertEq(
            endingPCVDepositFeiBalance - startingPCVDepositFeiBalance,
            amountFeiIn - 1
        );
    }

    /// this test uses FEI as the underlying asset and hooks into a FEI PCV Deposit
    function testRedeemAfterPriceIncrease() public {
        uint256 amountVoltIn = 100_000;
        uint256 amountFeiOut = 101_000;

        rariFEIPCVDeposit.deposit(); // get env cleaned up and ready for testing
        vm.warp(28 days + block.timestamp);

        uint256 startingUserVoltBalance = volt.balanceOf(address(this));
        uint256 startingPCVDepositFeiBalance = rariFEIPCVDeposit.balance();

        volt.approve(address(psm), amountVoltIn);
        psm.redeem(address(this), amountVoltIn, amountFeiOut);
        rariFEIPCVDeposit.deposit();

        uint256 endingUserVoltBalance = volt.balanceOf(address(this));
        uint256 endingPCVDepositFeiBalance = rariFEIPCVDeposit.balance();

        assertEq(startingUserVoltBalance - endingUserVoltBalance, amountVoltIn);
        assertEq(
            startingPCVDepositFeiBalance - endingPCVDepositFeiBalance,
            amountFeiOut - 1
        );
    }

    function testGlobalRateLimitedMint() public {
        uint256 voltAvailableToMint = rateLimitedMinter.individualBuffer(
            address(this)
        );
        uint256 startingVolt = volt.balanceOf(address(this));

        rateLimitedMinter.mintMaxAllowableVolt(address(this));

        uint256 endingVolt = volt.balanceOf(address(this));

        assertEq(endingVolt, voltAvailableToMint + startingVolt);
    }
}",2536
RealWorld_TA_102_ForceEth_RealWorld_20240812170453.log,102,ForceEth,24797,3062,27859,86.0,0.185225,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

contract ForceEth {
    constructor() payable {}

    receive() external payable {}

    function forceEth(address to) public {
        selfdestruct(payable(to));
    }
}",58
RealWorld_TA_102_NonCustodialPSM.t_RealWorld_20240812164147.log,102,NonCustodialPSM.t,399655,4400,404055,138.0,2.086275,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {ERC20, IERC20} from ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import {MockPCVDepositV2} from ""../../../mock/MockPCVDepositV2.sol"";
import {IPCVDeposit} from ""../../../pcv/IPCVDeposit.sol"";
import {MockERC20} from ""../../../mock/MockERC20.sol"";
import {OraclePassThrough} from ""../../../oracle/OraclePassThrough.sol"";
import {ScalingPriceOracle} from ""../../../oracle/ScalingPriceOracle.sol"";
import {MockScalingPriceOracle} from ""../../../mock/MockScalingPriceOracle.sol"";
import {ICore} from ""../../../core/ICore.sol"";
import {Core} from ""../../../core/Core.sol"";
import {IVolt, Volt} from ""../../../volt/Volt.sol"";
import {NonCustodialPSM, GlobalRateLimitedMinter} from ""./../../../peg/NonCustodialPSM.sol"";
import {Vm} from ""./../utils/Vm.sol"";
import {DSTest} from ""./../utils/DSTest.sol"";
import {getCore, getAddresses, FeiTestAddresses} from ""./../utils/Fixtures.sol"";

contract NonCustodialPSMTest is DSTest {
    GlobalRateLimitedMinter private rateLimitedMinter;
    NonCustodialPSM private psm;
    ICore private core;
    IVolt private volt;

    /// ------------ Minting and RateLimited System Params ------------

    uint256 public constant mintAmount = 10_000_000e18;
    uint256 public constant bufferCap = 10_000_000e18;
    uint256 public constant individualMaxBufferCap = 5_000_000e18;
    uint256 public constant rps = 10_000e18;

    /// ------------ Oracle System Params ------------

    /// @notice prices during test will increase 1% monthly
    int256 public constant monthlyChangeRateBasisPoints = 100;
    uint256 public constant maxDeviationThresholdBasisPoints = 1_000;

    MockERC20 public underlyingToken;
    MockPCVDepositV2 public pcvDeposit;
    OraclePassThrough public oracle;

    Vm public constant vm = Vm(HEVM_ADDRESS);
    FeiTestAddresses public addresses = getAddresses();

    function setUp() public {
        core = getCore();

        volt = core.volt();
        MockScalingPriceOracle mockScalingPriceOracle = new MockScalingPriceOracle(
                address(0),
                keccak256(abi.encodePacked(""test"")),
                10e18,
                101,
                100
            );

        oracle = new OraclePassThrough(
            ScalingPriceOracle(address(mockScalingPriceOracle))
        );
        underlyingToken = new MockERC20();
        pcvDeposit = new MockPCVDepositV2(
            address(core),
            address(underlyingToken),
            0,
            0
        );

        rateLimitedMinter = new GlobalRateLimitedMinter(
            address(core),
            rps,
            rps,
            rps,
            individualMaxBufferCap,
            bufferCap
        );

        NonCustodialPSM.OracleParams memory oracleParams = NonCustodialPSM
            .OracleParams({
                coreAddress: address(core),
                oracleAddress: address(oracle),
                backupOracle: address(0),
                decimalsNormalizer: 0
            });

        NonCustodialPSM.RateLimitedParams
            memory multiRateLimitedParams = NonCustodialPSM.RateLimitedParams({
                maxRateLimitPerSecond: rps,
                rateLimitPerSecond: rps,
                bufferCap: bufferCap
            });

        NonCustodialPSM.PSMParams memory PSMParams = NonCustodialPSM.PSMParams({
            mintFeeBasisPoints: 0,
            redeemFeeBasisPoints: 0,
            underlyingToken: underlyingToken,
            pcvDeposit: pcvDeposit,
            rateLimitedMinter: rateLimitedMinter
        });

        /// create PSM
        psm = new NonCustodialPSM(
            oracleParams,
            multiRateLimitedParams,
            PSMParams
        );

        vm.startPrank(addresses.governorAddress);

        /// grant the PSM the PCV Controller role
        core.grantMinter(addresses.governorAddress);
        core.grantMinter(address(rateLimitedMinter));
        core.grantPCVController(address(psm));
        core.grantPCVController(addresses.governorAddress);
        rateLimitedMinter.addAddress(
            address(psm),
            uint112(rps),
            uint112(bufferCap)
        );

        /// mint FEI to the user
        volt.mint(address(this), mintAmount);

        vm.stopPrank();

        /// mint the PSM and user some stable coins
        underlyingToken.mint(address(pcvDeposit), mintAmount);
        underlyingToken.mint(address(this), mintAmount);

        /// invest all excess tokens in the PCV deposit
        pcvDeposit.deposit();
    }

    /// @notice PSM is set up correctly, all state variables and balances are correct
    function testPSMSetup() public {
        uint256 startingPSMUnderlyingBalance = underlyingToken.balanceOf(
            address(psm)
        );
        uint256 startingUserFEIBalance = volt.balanceOf(address(this));

        assertEq(startingPSMUnderlyingBalance, 0);
        assertEq(startingUserFEIBalance, mintAmount);

        assertTrue(core.isPCVController(address(psm)));
        assertTrue(core.isMinter(address(rateLimitedMinter)));
    }

    /// @notice PSM is set up correctly and view functions are working
    function testGetRedeemAmountOut() public {
        uint256 amountFeiIn = 100;
        assertEq(psm.getRedeemAmountOut(amountFeiIn), amountFeiIn);
    }

    /// @notice PSM is set up correctly and view functions are working
    function testGetMaxMintAmountOut() public {
        assertEq(psm.getMaxMintAmountOut(), bufferCap);

        vm.startPrank(addresses.governorAddress);
        volt.mint(address(psm), mintAmount);
        vm.stopPrank();

        assertEq(psm.getMaxMintAmountOut(), bufferCap + mintAmount);
    }

    /// @notice PSM is set up correctly and view functions are working
    function testGetMintAmountOut() public {
        uint256 amountFeiIn = 100;
        assertEq(psm.getMintAmountOut(amountFeiIn), amountFeiIn);
    }

    /// @notice PSM is set up correctly and view functions are working
    function testGetRedeemAmountOutAfterTime() public {
        uint256 amountVoltIn = 100_000;
        uint256 expectedAmountStableOut = 101_000;

        /// advance the full time period to get the full 1% price increase
        vm.warp(28 days + block.timestamp);

        assertEq(psm.getRedeemAmountOut(amountVoltIn), expectedAmountStableOut);
    }

    /// @notice PSM is set up correctly and view functions are working
    function testGetMintAmountOutAfterTime() public {
        /// assert that for 101 stables you get 100 VOLT after volt price increases 1%
        uint256 amountStableIn = 101_000;
        uint256 expectedAmountVoltOut = 99999; /// subtract 1 for precision loss from doInvert

        /// advance the full time period to get the full 1% price increase
        vm.warp(28 days + block.timestamp);

        assertEq(psm.getMintAmountOut(amountStableIn), expectedAmountVoltOut);
    }

    /// @notice pcv deposit receives underlying token on mint
    function testSwapUnderlyingForFeiAfterPriceIncrease() public {
        uint256 amountStableIn = 101_000;
        uint256 amountVoltOut = 99999; /// subtract 1 for precision loss from doInvert

        vm.warp(28 days + block.timestamp);

        underlyingToken.approve(address(psm), amountStableIn);
        psm.mint(address(this), amountStableIn, amountVoltOut);

        uint256 endingUserFEIBalance = volt.balanceOf(address(this));
        uint256 endingPSMUnderlyingBalance = underlyingToken.balanceOf(
            address(psm)
        );
        uint256 endingPCVDepositUnderlyingBalance = underlyingToken.balanceOf(
            address(pcvDeposit)
        );

        assertEq(
            endingPCVDepositUnderlyingBalance,
            mintAmount + amountStableIn
        );
        assertEq(endingPSMUnderlyingBalance, 0);
        assertEq(endingUserFEIBalance, mintAmount + amountVoltOut);
    }

    /// @notice pcv deposit receives underlying token on mint
    function testSwapUnderlyingForFei() public {
        underlyingToken.approve(address(psm), mintAmount);
        psm.mint(address(this), mintAmount, mintAmount);

        uint256 endingUserFEIBalance = volt.balanceOf(address(this));
        uint256 endingPSMUnderlyingBalance = underlyingToken.balanceOf(
            address(psm)
        );
        uint256 endingPCVDepositUnderlyingBalance = underlyingToken.balanceOf(
            address(pcvDeposit)
        );

        assertEq(endingPCVDepositUnderlyingBalance, mintAmount * 2);
        assertEq(endingPSMUnderlyingBalance, 0);
        assertEq(endingUserFEIBalance, mintAmount * 2);
    }

    /// @notice pcv deposit gets depleted on redeem
    function testSwapFeiForUnderlying() public {
        volt.approve(address(psm), mintAmount);
        psm.redeem(address(this), mintAmount, mintAmount);

        uint256 endingUserFEIBalance = volt.balanceOf(address(this));
        uint256 endingUserUnderlyingBalance = underlyingToken.balanceOf(
            address(this)
        );
        uint256 endingPSMUnderlyingBalance = underlyingToken.balanceOf(
            address(psm)
        );
        uint256 endingPCVDepositUnderlyingBalance = underlyingToken.balanceOf(
            address(pcvDeposit)
        );

        assertEq(endingPSMUnderlyingBalance, 0);
        assertEq(endingUserFEIBalance, 0);
        assertEq(endingUserUnderlyingBalance, mintAmount * 2);
        assertEq(endingPCVDepositUnderlyingBalance, 0);
    }

    /// @notice pcv deposit gets depleted on redeem
    function testSwapVoltForUnderlyingAfterPriceIncrease() public {
        uint256 amountVoltIn = 100_000;
        uint256 amountStableOut = 101_000;

        vm.warp(28 days + block.timestamp);

        volt.approve(address(psm), amountVoltIn);
        psm.redeem(address(this), amountVoltIn, amountStableOut);

        uint256 endingUserFEIBalance = volt.balanceOf(address(this));
        uint256 endingUserUnderlyingBalance = underlyingToken.balanceOf(
            address(this)
        );
        uint256 endingPSMUnderlyingBalance = underlyingToken.balanceOf(
            address(psm)
        );
        uint256 endingPCVDepositUnderlyingBalance = underlyingToken.balanceOf(
            address(pcvDeposit)
        );

        assertEq(endingPSMUnderlyingBalance, 0);
        assertEq(endingUserFEIBalance, mintAmount - amountVoltIn);
        assertEq(endingUserUnderlyingBalance, mintAmount + amountStableOut);
        assertEq(
            endingPCVDepositUnderlyingBalance,
            mintAmount - amountStableOut
        );
    }

    /// @notice pcv deposit gets depleted on redeem
    function testUnderlyingBufferDepletion() public {
        uint256 bufferStart = psm.buffer();

        volt.approve(address(psm), mintAmount);
        psm.redeem(address(this), mintAmount, mintAmount);

        uint256 bufferEnd = psm.buffer();
        uint256 endingUserFEIBalance = volt.balanceOf(address(this));
        uint256 endingUserUnderlyingBalance = underlyingToken.balanceOf(
            address(this)
        );
        uint256 endingPSMUnderlyingBalance = underlyingToken.balanceOf(
            address(psm)
        );
        uint256 endingPCVDepositUnderlyingBalance = underlyingToken.balanceOf(
            address(pcvDeposit)
        );

        assertEq(endingPSMUnderlyingBalance, 0);
        assertEq(endingUserFEIBalance, 0);
        assertEq(endingUserUnderlyingBalance, mintAmount * 2);
        assertEq(endingPCVDepositUnderlyingBalance, 0);
        assertEq(bufferStart, bufferCap);
        assertEq(bufferEnd, bufferCap - mintAmount);
    }

    /// @notice global rate limited minter buffer on the PSM gets depleted on mint
    function testFeiBufferDepletion() public {
        uint256 bufferStart = rateLimitedMinter.individualBuffer(address(psm));

        underlyingToken.approve(address(psm), mintAmount);
        psm.mint(address(this), mintAmount, mintAmount);

        uint256 bufferEnd = rateLimitedMinter.individualBuffer(address(psm));
        uint256 endingUserFEIBalance = volt.balanceOf(address(this));
        uint256 endingPSMUnderlyingBalance = underlyingToken.balanceOf(
            address(psm)
        );
        uint256 endingPCVDepositUnderlyingBalance = underlyingToken.balanceOf(
            address(pcvDeposit)
        );

        assertEq(endingPCVDepositUnderlyingBalance, mintAmount * 2);
        assertEq(endingPSMUnderlyingBalance, 0);
        assertEq(endingUserFEIBalance, mintAmount * 2);

        assertEq(bufferStart, bufferCap);
        assertEq(bufferEnd, bufferCap - mintAmount);
    }

    /// @notice replenishable rate limited minter buffer on the PSM gets increased on mint
    function testBufferReplenishment() public {
        /// drain buffer
        volt.approve(address(psm), mintAmount);
        psm.redeem(address(this), mintAmount, mintAmount);

        uint256 bufferStart = psm.bufferStored();

        underlyingToken.approve(address(psm), mintAmount);
        psm.mint(address(this), mintAmount, mintAmount);

        uint256 bufferEnd = psm.bufferStored();

        assertEq(bufferEnd - bufferStart, mintAmount);
    }

    /// @notice redeem fails without approval
    function testSwapFeiForUnderlyingFailsWithoutApproval() public {
        vm.expectRevert(bytes(""ERC20: transfer amount exceeds allowance""));

        psm.redeem(address(this), mintAmount, mintAmount);
    }

    /// @notice mint fails without approval
    function testSwapUnderlyingForFeiFailsWithoutApproval() public {
        vm.expectRevert(bytes(""ERC20: transfer amount exceeds allowance""));

        psm.mint(address(this), mintAmount, mintAmount);
    }

    /// @notice withdraw erc20 fails without correct permissions
    function testERC20WithdrawFailure() public {
        vm.expectRevert(bytes(""CoreRef: Caller is not a PCV controller""));

        psm.withdrawERC20(address(underlyingToken), address(this), 100);
    }

    /// @notice withdraw erc20 succeeds with correct permissions
    function testERC20WithdrawSuccess() public {
        vm.startPrank(addresses.governorAddress);

        core.grantPCVController(address(this));
        underlyingToken.mint(address(psm), mintAmount);

        vm.stopPrank();

        uint256 startingBalance = underlyingToken.balanceOf(address(this));
        psm.withdrawERC20(address(underlyingToken), address(this), mintAmount);
        uint256 endingBalance = underlyingToken.balanceOf(address(this));

        assertEq(endingBalance - startingBalance, mintAmount);
    }

    /// @notice set global rate limited minter fails when caller is not governor
    function testSetGlobalRateLimitedMinterFailure() public {
        vm.expectRevert(bytes(""UNAUTHORIZED""));

        psm.setGlobalRateLimitedMinter(GlobalRateLimitedMinter(address(this)));
    }

    /// @notice set global rate limited minter fails when caller is governor and new address is 0
    function testSetGlobalRateLimitedMinterFailureZeroAddress() public {
        vm.startPrank(addresses.governorAddress);

        vm.expectRevert(
            bytes(""PegStabilityModule: Invalid new GlobalRateLimitedMinter"")
        );
        psm.setGlobalRateLimitedMinter(GlobalRateLimitedMinter(address(0)));

        vm.stopPrank();
    }

    /// @notice set global rate limited minter succeeds when caller is governor
    function testSetGlobalRateLimitedMinterSuccess() public {
        vm.startPrank(addresses.governorAddress);

        psm.setGlobalRateLimitedMinter(GlobalRateLimitedMinter(address(this)));

        assertEq(address(psm.rateLimitedMinter()), address(this));

        vm.stopPrank();
    }

    /// @notice set global rate limited minter fails when caller is governor and new address is 0
    function testSetPCVDepositFailureZeroAddress() public {
        vm.startPrank(addresses.governorAddress);

        vm.expectRevert(bytes(""PegStabilityModule: Invalid new PCVDeposit""));
        psm.setPCVDeposit(IPCVDeposit(address(0)));

        vm.stopPrank();
    }

    /// @notice set PCV deposit fails when caller is governor and new address is 0
    function testSetPCVDepositFailureNonGovernor() public {
        vm.expectRevert(bytes(""UNAUTHORIZED""));
        psm.setPCVDeposit(IPCVDeposit(address(0)));
    }

    /// @notice set PCV deposit fails when caller is governor and new address is 0
    function testSetPCVDepositFailureUnderlyingTokenMismatch() public {
        vm.startPrank(addresses.governorAddress);

        MockPCVDepositV2 newPCVDeposit = new MockPCVDepositV2(
            address(core),
            address(volt),
            0,
            0
        );

        vm.expectRevert(bytes(""PegStabilityModule: Underlying token mismatch""));

        psm.setPCVDeposit(IPCVDeposit(address(newPCVDeposit)));

        vm.stopPrank();
    }

    /// @notice set PCV Deposit succeeds when caller is governor and underlying tokens match
    function testSetPCVDepositSuccess() public {
        vm.startPrank(addresses.governorAddress);

        MockPCVDepositV2 newPCVDeposit = new MockPCVDepositV2(
            address(core),
            address(underlyingToken),
            0,
            0
        );

        psm.setPCVDeposit(IPCVDeposit(address(newPCVDeposit)));

        vm.stopPrank();

        assertEq(address(newPCVDeposit), address(psm.pcvDeposit()));
    }

    /// @notice set mint fee succeeds
    function testSetMintFeeSuccess() public {
        vm.startPrank(addresses.governorAddress);
        psm.setMintFee(100);
        vm.stopPrank();

        assertEq(psm.mintFeeBasisPoints(), 100);
    }

    /// @notice set mint fee fails unauthorized
    function testSetMintFeeFailsWithoutCorrectRoles() public {
        vm.expectRevert(bytes(""UNAUTHORIZED""));

        psm.setMintFee(100);
    }

    /// @notice set redeem fee succeeds
    function testSetRedeemFeeSuccess() public {
        vm.startPrank(addresses.governorAddress);
        psm.setRedeemFee(100);
        vm.stopPrank();

        assertEq(psm.redeemFeeBasisPoints(), 100);
    }

    /// @notice set redeem fee fails unauthorized
    function testSetRedeemFeeFailsWithoutCorrectRoles() public {
        vm.expectRevert(bytes(""UNAUTHORIZED""));

        psm.setRedeemFee(100);
    }

    /// @notice redeem fails when paused
    function testRedeemFailsWhenPaused() public {
        vm.startPrank(addresses.governorAddress);
        psm.pauseRedeem();
        vm.stopPrank();

        vm.expectRevert(bytes(""PegStabilityModule: Redeem paused""));
        psm.redeem(address(this), 100, 100);
    }

    /// @notice mint fails when paused
    function testMintFailsWhenPaused() public {
        vm.startPrank(addresses.governorAddress);
        psm.pauseMint();
        vm.stopPrank();

        vm.expectRevert(bytes(""PegStabilityModule: Minting paused""));
        psm.mint(address(this), 100, 100);
    }

    /// @notice redeem fails when price has not increased enough to get minAmountOut
    function testRedeemFailsWhenScalingPriceOracleIncreases() public {
        vm.warp(28 days + block.timestamp);

        vm.expectRevert(bytes(""PegStabilityModule: Redeem not enough out""));
        psm.redeem(address(this), 100_000, 101_001);

        assertEq(oracle.getCurrentOraclePrice(), (1 ether * 101) / 100);
    }

    /// @notice mint fails when price has not increased enough to get minAmountVoltOut
    function testMintFailsWhenScalingPriceOracleIncreases() public {
        vm.warp(28 days + block.timestamp);

        vm.expectRevert(bytes(""PegStabilityModule: Mint not enough out""));
        psm.mint(address(this), 101_000, 100_001);

        assertEq(oracle.getCurrentOraclePrice(), (1 ether * 101) / 100);
        /// subtract 1 for precision loss due to doInvert
        assertEq(psm.getMintAmountOut(101_000), 100_000 - 1);
    }
}",4619
RealWorld_TA_102_TribeRoles_RealWorld_20240812163606.log,102,TribeRoles,85542,1408,86950,75.0,0.45587,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

/**
 @title Tribe DAO ACL Roles
 @notice Holds a complete list of all roles which can be held by contracts inside Tribe DAO.
         Roles are broken up into 3 categories:
         * Major Roles - the most powerful roles in the Tribe DAO which should be carefully managed.
         * Admin Roles - roles with management capability over critical functionality. Should only be held by automated or optimistic mechanisms
         * Minor Roles - operational roles. May be held or managed by shorter optimistic timelocks or trusted multisigs.
 */
library TribeRoles {
    /*///////////////////////////////////////////////////////////////
                                 Major Roles
    //////////////////////////////////////////////////////////////*/

    /// @notice the ultimate role of Tribe. Controls all other roles and protocol functionality.
    bytes32 internal constant GOVERNOR = keccak256(""GOVERN_ROLE"");

    /// @notice the protector role of Tribe. Admin of pause, veto, revoke, and minor roles
    bytes32 internal constant GUARDIAN = keccak256(""GUARDIAN_ROLE"");

    /// @notice the role which can arbitrarily move PCV in any size from any contract
    bytes32 internal constant PCV_CONTROLLER = keccak256(""PCV_CONTROLLER_ROLE"");

    /// @notice can mint FEI arbitrarily
    bytes32 internal constant MINTER = keccak256(""MINTER_ROLE"");

    /*///////////////////////////////////////////////////////////////
                                 Admin Roles
    //////////////////////////////////////////////////////////////*/

    /// @notice can manage the majority of Tribe protocol parameters. Sets boundaries for MINOR_PARAM_ROLE.
    bytes32 internal constant PARAMETER_ADMIN = keccak256(""PARAMETER_ADMIN"");

    /// @notice manages the Collateralization Oracle as well as other protocol oracles.
    bytes32 internal constant ORACLE_ADMIN = keccak256(""ORACLE_ADMIN_ROLE"");

    /// @notice manages TribalChief incentives and related functionality.
    bytes32 internal constant TRIBAL_CHIEF_ADMIN =
        keccak256(""TRIBAL_CHIEF_ADMIN_ROLE"");

    /// @notice admin of PCVGuardian
    bytes32 internal constant PCV_GUARDIAN_ADMIN =
        keccak256(""PCV_GUARDIAN_ADMIN_ROLE"");

    /// @notice admin of all Minor Roles
    bytes32 internal constant MINOR_ROLE_ADMIN = keccak256(""MINOR_ROLE_ADMIN"");

    /// @notice admin of the Fuse protocol
    bytes32 internal constant FUSE_ADMIN = keccak256(""FUSE_ADMIN"");

    /// @notice capable of vetoing DAO votes or optimistic timelocks
    bytes32 internal constant VETO_ADMIN = keccak256(""VETO_ADMIN"");

    /// @notice capable of setting FEI Minters within global rate limits and caps
    bytes32 internal constant MINTER_ADMIN = keccak256(""MINTER_ADMIN"");

    /// @notice manages the constituents of Optimistic Timelocks, including Proposers and Executors
    bytes32 internal constant OPTIMISTIC_ADMIN = keccak256(""OPTIMISTIC_ADMIN"");

    /*///////////////////////////////////////////////////////////////
                                 Minor Roles
    //////////////////////////////////////////////////////////////*/

    /// @notice capable of poking existing LBP auctions to exchange tokens.
    bytes32 internal constant LBP_SWAP_ROLE = keccak256(""SWAP_ADMIN_ROLE"");

    /// @notice capable of engaging with Votium for voting incentives.
    bytes32 internal constant VOTIUM_ROLE = keccak256(""VOTIUM_ADMIN_ROLE"");

    /// @notice capable of changing parameters within non-critical ranges
    bytes32 internal constant MINOR_PARAM_ROLE = keccak256(""MINOR_PARAM_ROLE"");

    /// @notice capable of adding an address to multi rate limited
    bytes32 internal constant ADD_MINTER_ROLE = keccak256(""ADD_MINTER_ROLE"");

    /// @notice capable of changing PCV Deposit and Global Rate Limited Minter in the PSM
    bytes32 internal constant PSM_ADMIN_ROLE = keccak256(""PSM_ADMIN_ROLE"");
}",796
RealWorld_TA_102_GlobalRateLimitedMinter_RealWorld_20240812172418.log,102,GlobalRateLimitedMinter,70484,2602,73086,84.0,0.40446,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {MultiRateLimited} from ""./MultiRateLimited.sol"";
import {IGlobalRateLimitedMinter} from ""./IGlobalRateLimitedMinter.sol"";
import {CoreRef} from ""./../refs/CoreRef.sol"";
import {Math} from ""@openzeppelin/contracts/utils/math/Math.sol"";

/// @notice global contract to handle rate limited minting of VOLT on a global level
/// allows whitelisted minters to call in and specify the address to mint VOLT to within
/// that contract's limits
contract GlobalRateLimitedMinter is MultiRateLimited, IGlobalRateLimitedMinter {
    /// @param coreAddress address of the core contract
    /// @param _globalMaxRateLimitPerSecond maximum amount of VOLT that can replenish per second ever, this amount cannot be changed by governance
    /// @param _perAddressRateLimitMaximum maximum rate limit per second per address
    /// @param _maxRateLimitPerSecondPerAddress maximum rate limit per second per address in multi rate limited
    /// @param _maxBufferCap maximum buffer cap in multi rate limited contract
    /// @param _globalBufferCap maximum global buffer cap
    constructor(
        address coreAddress,
        uint256 _globalMaxRateLimitPerSecond,
        uint256 _perAddressRateLimitMaximum,
        uint256 _maxRateLimitPerSecondPerAddress,
        uint256 _maxBufferCap,
        uint256 _globalBufferCap
    )
        CoreRef(coreAddress)
        MultiRateLimited(
            _globalMaxRateLimitPerSecond,
            _perAddressRateLimitMaximum,
            _maxRateLimitPerSecondPerAddress,
            _maxBufferCap,
            _globalBufferCap
        )
    {}

    /// @notice mint VOLT to the target address and deplete the buffer
    /// pausable and depletes the msg.sender's buffer
    /// @param to the recipient address of the minted VOLT
    /// @param amount the amount of VOLT to mint
    function mintVolt(address to, uint256 amount)
        external
        virtual
        override
        whenNotPaused
    {
        _depleteIndividualBuffer(msg.sender, amount);
        _mintVolt(to, amount);
    }

    /// @notice mint VOLT to the target address and deplete the whole rate limited
    ///  minter's buffer, pausable and completely depletes the msg.sender's buffer
    /// @param to the recipient address of the minted VOLT
    /// mints all VOLT that msg.sender has in the buffer
    function mintMaxAllowableVolt(address to)
        external
        virtual
        override
        whenNotPaused
    {
        uint256 amount = Math.min(individualBuffer(msg.sender), buffer());

        _depleteIndividualBuffer(msg.sender, amount);
        _mintVolt(to, amount);
    }
}",617
RealWorld_TA_102_Volt_RealWorld_20240812174735.log,102,Volt,76779,2288,79067,100.0,0.429655,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"";
import ""../refs/CoreRef.sol"";

/// @title FEI stablecoin
/// @author Fei Protocol
contract Volt is IVolt, ERC20Burnable, CoreRef {
    // solhint-disable-next-line var-name-mixedcase
    bytes32 public DOMAIN_SEPARATOR;
    // keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    bytes32 public constant PERMIT_TYPEHASH =
        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
    mapping(address => uint256) public nonces;

    /// @notice Fei token constructor
    /// @param core Fei Core address to reference
    constructor(address core) ERC20(""VOLT"", ""VOLT"") CoreRef(core) {
        uint256 chainId;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            chainId := chainid()
        }
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256(
                    ""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""
                ),
                keccak256(bytes(name())),
                keccak256(bytes(""1"")),
                chainId,
                address(this)
            )
        );
    }

    /// @notice mint FEI tokens
    /// @param account the account to mint to
    /// @param amount the amount to mint
    function mint(address account, uint256 amount)
        external
        override
        onlyMinter
        whenNotPaused
    {
        _mint(account, amount);
        emit Minting(account, msg.sender, amount);
    }

    /// @notice burn FEI tokens from caller
    /// @param amount the amount to burn
    function burn(uint256 amount) public override(IVolt, ERC20Burnable) {
        super.burn(amount);
        emit Burning(msg.sender, msg.sender, amount);
    }

    /// @notice permit spending of FEI
    /// @param owner the FEI holder
    /// @param spender the approved operator
    /// @param value the amount approved
    /// @param deadline the deadline after which the approval is no longer valid
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external override {
        require(deadline >= block.timestamp, ""Fei: EXPIRED"");
        bytes32 digest = keccak256(
            abi.encodePacked(
                ""\x19\x01"",
                DOMAIN_SEPARATOR,
                keccak256(
                    abi.encode(
                        PERMIT_TYPEHASH,
                        owner,
                        spender,
                        value,
                        nonces[owner]++,
                        deadline
                    )
                )
            )
        );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(
            recoveredAddress != address(0) && recoveredAddress == owner,
            ""Fei: INVALID_SIGNATURE""
        );
        _approve(owner, spender, value);
    }
}",694
RealWorld_TA_102_StdLib_RealWorld_20240812165229.log,102,StdLib,251346,2643,253989,102.0,1.30959,"// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import ""./Vm.sol"";

// Wrappers around Cheatcodes to avoid footguns
abstract contract StdLib {
    // we use a custom name that is unlikely to cause collisions so this contract
    // can be inherited easily
    Vm constant vm_std_cheats =
        Vm(address(uint160(uint256(keccak256(""hevm cheat code"")))));

    // Skip forward or rewind time by the specified number of seconds
    function skip(uint256 time) public {
        vm_std_cheats.warp(block.timestamp + time);
    }

    function rewind(uint256 time) public {
        vm_std_cheats.warp(block.timestamp - time);
    }

    // Setup a prank from an address that has some ether
    function hoax(address who) public {
        vm_std_cheats.deal(who, 1 << 128);
        vm_std_cheats.prank(who);
    }

    function hoax(address who, uint256 give) public {
        vm_std_cheats.deal(who, give);
        vm_std_cheats.prank(who);
    }

    function hoax(address who, address) public {
        vm_std_cheats.deal(who, 1 << 128);
        vm_std_cheats.prank(who, who);
    }

    function hoax(
        address who,
        address,
        uint256 give
    ) public {
        vm_std_cheats.deal(who, give);
        vm_std_cheats.prank(who, who);
    }

    // Start perpetual prank from an address that has some ether
    function startHoax(address who) public {
        vm_std_cheats.deal(who, 1 << 128);
        vm_std_cheats.startPrank(who);
    }

    function startHoax(address who, uint256 give) public {
        vm_std_cheats.deal(who, give);
        vm_std_cheats.startPrank(who);
    }

    // Start perpetual prank from an address that has some ether
    // tx.origin is set to the origin parameter
    function startHoax(address who, address origin) public {
        vm_std_cheats.deal(who, 1 << 128);
        vm_std_cheats.startPrank(who, origin);
    }

    function startHoax(
        address who,
        address origin,
        uint256 give
    ) public {
        vm_std_cheats.deal(who, give);
        vm_std_cheats.startPrank(who, origin);
    }

    // Deploys a contract by fetching the contract bytecode from
    // the artifacts directory
    function deployCode(string memory what, bytes memory args)
        public
        returns (address addr)
    {
        bytes memory bytecode = abi.encodePacked(
            vm_std_cheats.getCode(what),
            args
        );
        assembly {
            addr := create(0, add(bytecode, 0x20), mload(bytecode))
        }
    }

    function deployCode(string memory what) public returns (address addr) {
        bytes memory bytecode = vm_std_cheats.getCode(what);
        assembly {
            addr := create(0, add(bytecode, 0x20), mload(bytecode))
        }
    }
}

library stdError {
    bytes public constant assertionError =
        abi.encodeWithSignature(""Panic(uint256)"", 0x01);
    bytes public constant arithmeticError =
        abi.encodeWithSignature(""Panic(uint256)"", 0x11);
    bytes public constant divisionError =
        abi.encodeWithSignature(""Panic(uint256)"", 0x12);
    bytes public constant enumConversionError =
        abi.encodeWithSignature(""Panic(uint256)"", 0x21);
    bytes public constant encodeStorageError =
        abi.encodeWithSignature(""Panic(uint256)"", 0x22);
    bytes public constant popError =
        abi.encodeWithSignature(""Panic(uint256)"", 0x31);
    bytes public constant indexOOBError =
        abi.encodeWithSignature(""Panic(uint256)"", 0x32);
    bytes public constant memOverflowError =
        abi.encodeWithSignature(""Panic(uint256)"", 0x41);
    bytes public constant zeroVarError =
        abi.encodeWithSignature(""Panic(uint256)"", 0x51);
}

struct StdStorage {
    mapping(address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;
    mapping(address => mapping(bytes4 => mapping(bytes32 => bool))) finds;
    bytes32[] _keys;
    bytes4 _sig;
    uint256 _depth;
    address _target;
    bytes32 _set;
}

library stdStorage {
    error NotFound(bytes4);
    error NotStorage(bytes4);
    error PackedSlot(bytes32);

    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);
    event WARNING_UninitedSlot(address who, uint256 slot);

    Vm constant stdstore_vm =
        Vm(address(uint160(uint256(keccak256(""hevm cheat code"")))));

    function sigs(string memory sigStr) internal pure returns (bytes4) {
        return bytes4(keccak256(bytes(sigStr)));
    }

    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against
    // slot complexity:
    //  if flat, will be bytes32(uint256(uint));
    //  if map, will be keccak256(abi.encode(key, uint(slot)));
    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));
    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);
    function find(StdStorage storage self) internal returns (uint256) {
        address who = self._target;
        bytes4 fsig = self._sig;
        uint256 field_depth = self._depth;
        bytes32[] memory ins = self._keys;

        // calldata to test against
        if (
            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]
        ) {
            return
                self.slots[who][fsig][
                    keccak256(abi.encodePacked(ins, field_depth))
                ];
        }
        bytes memory cald = abi.encodePacked(fsig, flatten(ins));
        stdstore_vm.record();
        bytes32 fdat;
        {
            (, bytes memory rdat) = who.staticcall(cald);
            fdat = bytesToBytes32(rdat, 32 * field_depth);
        }

        (bytes32[] memory reads, ) = stdstore_vm.accesses(address(who));
        if (reads.length == 1) {
            bytes32 curr = stdstore_vm.load(who, reads[0]);
            if (curr == bytes32(0)) {
                emit WARNING_UninitedSlot(who, uint256(reads[0]));
            }
            if (fdat != curr) {
                revert PackedSlot(reads[0]);
            }
            emit SlotFound(
                who,
                fsig,
                keccak256(abi.encodePacked(ins, field_depth)),
                uint256(reads[0])
            );
            self.slots[who][fsig][
                keccak256(abi.encodePacked(ins, field_depth))
            ] = uint256(reads[0]);
            self.finds[who][fsig][
                keccak256(abi.encodePacked(ins, field_depth))
            ] = true;
        } else if (reads.length > 1) {
            for (uint256 i = 0; i < reads.length; i++) {
                bytes32 prev = stdstore_vm.load(who, reads[i]);
                if (prev == bytes32(0)) {
                    emit WARNING_UninitedSlot(who, uint256(reads[i]));
                }
                // store
                stdstore_vm.store(who, reads[i], bytes32(hex""1337""));
                {
                    (, bytes memory rdat) = who.staticcall(cald);
                    fdat = bytesToBytes32(rdat, 32 * field_depth);
                }

                if (fdat == bytes32(hex""1337"")) {
                    // we found which of the slots is the actual one
                    emit SlotFound(
                        who,
                        fsig,
                        keccak256(abi.encodePacked(ins, field_depth)),
                        uint256(reads[i])
                    );
                    self.slots[who][fsig][
                        keccak256(abi.encodePacked(ins, field_depth))
                    ] = uint256(reads[i]);
                    self.finds[who][fsig][
                        keccak256(abi.encodePacked(ins, field_depth))
                    ] = true;
                    stdstore_vm.store(who, reads[i], prev);
                    break;
                }
                stdstore_vm.store(who, reads[i], prev);
            }
        } else {
            revert NotStorage(fsig);
        }

        if (
            !self.finds[who][fsig][
                keccak256(abi.encodePacked(ins, field_depth))
            ]
        ) revert NotFound(fsig);

        delete self._target;
        delete self._sig;
        delete self._keys;
        delete self._depth;

        return
            self.slots[who][fsig][
                keccak256(abi.encodePacked(ins, field_depth))
            ];
    }

    function target(StdStorage storage self, address _target)
        internal
        returns (StdStorage storage)
    {
        self._target = _target;
        return self;
    }

    function sig(StdStorage storage self, bytes4 _sig)
        internal
        returns (StdStorage storage)
    {
        self._sig = _sig;
        return self;
    }

    function sig(StdStorage storage self, string memory _sig)
        internal
        returns (StdStorage storage)
    {
        self._sig = sigs(_sig);
        return self;
    }

    function with_key(StdStorage storage self, address who)
        internal
        returns (StdStorage storage)
    {
        self._keys.push(bytes32(uint256(uint160(who))));
        return self;
    }

    function with_key(StdStorage storage self, uint256 amt)
        internal
        returns (StdStorage storage)
    {
        self._keys.push(bytes32(amt));
        return self;
    }

    function with_key(StdStorage storage self, bytes32 key)
        internal
        returns (StdStorage storage)
    {
        self._keys.push(key);
        return self;
    }

    function depth(StdStorage storage self, uint256 _depth)
        internal
        returns (StdStorage storage)
    {
        self._depth = _depth;
        return self;
    }

    function checked_write(StdStorage storage self, address who) internal {
        checked_write(self, bytes32(uint256(uint160(who))));
    }

    function checked_write(StdStorage storage self, uint256 amt) internal {
        checked_write(self, bytes32(amt));
    }

    function checked_write(StdStorage storage self, bytes32 set) internal {
        address who = self._target;
        bytes4 fsig = self._sig;
        uint256 field_depth = self._depth;
        bytes32[] memory ins = self._keys;

        bytes memory cald = abi.encodePacked(fsig, flatten(ins));
        if (
            !self.finds[who][fsig][
                keccak256(abi.encodePacked(ins, field_depth))
            ]
        ) {
            find(self);
        }
        bytes32 slot = bytes32(
            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]
        );

        bytes32 fdat;
        {
            (, bytes memory rdat) = who.staticcall(cald);
            fdat = bytesToBytes32(rdat, 32 * field_depth);
        }
        bytes32 curr = stdstore_vm.load(who, slot);

        if (fdat != curr) {
            revert PackedSlot(slot);
        }
        stdstore_vm.store(who, slot, set);
        delete self._target;
        delete self._sig;
        delete self._keys;
        delete self._depth;
    }

    function bytesToBytes32(bytes memory b, uint256 offset)
        public
        pure
        returns (bytes32)
    {
        bytes32 out;

        for (uint256 i = 0; i < 32; i++) {
            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);
        }
        return out;
    }

    function flatten(bytes32[] memory b) private pure returns (bytes memory) {
        bytes memory result = new bytes(b.length * 32);
        for (uint256 i = 0; i < b.length; i++) {
            bytes32 k = b[i];
            assembly {
                mstore(add(result, add(32, mul(32, i))), k)
            }
        }

        return result;
    }
}",2776
RealWorld_TA_102_IOracle_RealWorld_20240812171445.log,102,IOracle,28810,1781,30591,89.0,0.17967,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""../external/Decimal.sol"";

/// @title generic oracle interface for Fei Protocol
/// @author Fei Protocol
interface IOracle {
    // ----------- Events -----------

    event Update(uint256 _peg);

    // ----------- State changing API -----------

    function update() external;

    // ----------- Getters -----------

    function read() external view returns (Decimal.D256 memory, bool);

    function isOutdated() external view returns (bool);
}",115
RealWorld_TA_102_IScalingPriceOracle_RealWorld_20240812171616.log,102,IScalingPriceOracle,49002,1754,50756,80.0,0.28009,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {Decimal} from ""../external/Decimal.sol"";

/// @notice contract that receives a chainlink price feed and then linearly interpolates that rate over
/// a 1 month period into the VOLT price. Interest is compounded monthly when the rate is updated
/// @author Elliot Friedman
interface IScalingPriceOracle {
    /// @notice the time frame over which all changes in CPI data are applied
    /// 28 days was chosen as that is the shortest length of a month
    function TIMEFRAME() external view returns (uint256);

    /// @notice the maximum allowable deviation in basis points for a new chainlink oracle update
    /// only allow price changes by 20% in a month.
    /// Any change over this threshold in either direction will be rejected
    function MAXORACLEDEVIATION() external view returns (uint256);

    /// @notice get the current scaled oracle price
    /// applies the change smoothly over a 28 day period
    /// scaled by 18 decimals
    function getCurrentOraclePrice() external view returns (uint256);

    /// @notice current amount that oracle price is inflating/deflating by monthly in basis points
    function monthlyChangeRateBasisPoints() external view returns (int256);

    /// @notice oracle price. starts off at 1 scaled up by 18 decimals
    function oraclePrice() external view returns (uint256);

    /// @notice event when the monthly change rate is updated
    event CPIMonthlyChangeRateUpdate(
        int256 oldChangeRateBasisPoints,
        int256 newChangeRateBasisPoints
    );
}",358
RealWorld_TA_102_IntegrationTest.t_RealWorld_20240812165618.log,102,IntegrationTest.t,24899,1417,26316,68.0,0.152835,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import {DSTest} from ""../unit/utils/DSTest.sol"";
import {StdLib} from ""../unit/utils/StdLib.sol"";

contract IntegrationTest is DSTest, StdLib {
    function setUp() public {}

    function testPass() public {}
}",76
RealWorld_TA_102_WETH9_RealWorld_20240812175343.log,102,WETH9,71523,4246,75769,118.0,0.442535,"/**
 *Submitted for verification at Etherscan.io on 2017-12-12
 */

// Copyright (C) 2015, 2016, 2017 Dapphub

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity ^0.4.18;

contract WETH9 {
    string public name = ""Wrapped Ether"";
    string public symbol = ""WETH"";
    uint8 public decimals = 18;

    event Approval(address indexed src, address indexed guy, uint256 wad);
    event Transfer(address indexed src, address indexed dst, uint256 wad);
    event Deposit(address indexed dst, uint256 wad);
    event Withdrawal(address indexed src, uint256 wad);

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    function() public payable {
        deposit();
    }

    function init() external {
        decimals = 18;
        name = ""Wrapped Ether"";
        symbol = ""WETH"";
    }

    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
        Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 wad) public {
        require(balanceOf[msg.sender] >= wad);
        balanceOf[msg.sender] -= wad;
        msg.sender.transfer(wad);
        Withdrawal(msg.sender, wad);
    }

    function totalSupply() public view returns (uint256) {
        return this.balance;
    }

    function approve(address guy, uint256 wad) public returns (bool) {
        allowance[msg.sender][guy] = wad;
        Approval(msg.sender, guy, wad);
        return true;
    }

    function transfer(address dst, uint256 wad) public returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }

    function transferFrom(
        address src,
        address dst,
        uint256 wad
    ) public returns (bool) {
        require(balanceOf[src] >= wad);

        if (src != msg.sender && allowance[src][msg.sender] != uint256(-1)) {
            require(allowance[src][msg.sender] >= wad);
            allowance[src][msg.sender] -= wad;
        }

        balanceOf[src] -= wad;
        balanceOf[dst] += wad;

        Transfer(src, dst, wad);

        return true;
    }
}",631
RealWorld_TA_102_Timed_RealWorld_20240812172737.log,102,Timed,62020,2028,64048,90.0,0.35066,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

/// @title an abstract contract for timed events
/// @author Fei Protocol
abstract contract Timed {
    /// @notice the start timestamp of the timed period
    uint256 public startTime;

    /// @notice the duration of the timed period
    uint256 public duration;

    event DurationUpdate(uint256 oldDuration, uint256 newDuration);

    event TimerReset(uint256 startTime);

    constructor(uint256 _duration) {
        _setDuration(_duration);
    }

    modifier duringTime() {
        require(isTimeStarted(), ""Timed: time not started"");
        require(!isTimeEnded(), ""Timed: time ended"");
        _;
    }

    modifier afterTime() {
        require(isTimeEnded(), ""Timed: time not ended"");
        _;
    }

    modifier afterTimeInit() {
        require(isTimeEnded(), ""Timed: time not ended, init"");
        _;
        _initTimed();
    }

    /// @notice return true if time period has ended
    function isTimeEnded() public view returns (bool) {
        return remainingTime() == 0;
    }

    /// @notice number of seconds remaining until time is up
    /// @return remaining
    function remainingTime() public view returns (uint256) {
        return duration - timeSinceStart(); // duration always >= timeSinceStart which is on [0,d]
    }

    /// @notice number of seconds since contract was initialized
    /// @return timestamp
    /// @dev will be less than or equal to duration
    function timeSinceStart() public view returns (uint256) {
        if (!isTimeStarted()) {
            return 0; // uninitialized
        }
        uint256 _duration = duration;
        uint256 timePassed = block.timestamp - startTime; // block timestamp always >= startTime
        return timePassed > _duration ? _duration : timePassed;
    }

    function isTimeStarted() public view returns (bool) {
        return startTime != 0;
    }

    function _initTimed() internal {
        startTime = block.timestamp;

        emit TimerReset(block.timestamp);
    }

    function _setDuration(uint256 newDuration) internal {
        require(newDuration != 0, ""Timed: zero duration"");

        uint256 oldDuration = duration;
        duration = newDuration;
        emit DurationUpdate(oldDuration, newDuration);
    }
}",514
RealWorld_TA_102_MockCToken_RealWorld_20240812170621.log,102,MockCToken,57050,4879,61929,107.0,0.38283,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import ""./MockERC20.sol"";
import ""hardhat/console.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

interface CToken {
    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);

    function exchangeRateStored() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);
}

contract MockCToken is MockERC20 {
    IERC20 public token;
    bool public error;
    bool public isCEther;

    uint256 private constant EXCHANGE_RATE_SCALE = 1e18;
    uint256 public effectiveExchangeRate = 2;

    constructor(IERC20 _token, bool _isCEther) {
        token = _token;
        isCEther = _isCEther;
    }

    function setError(bool _error) external {
        error = _error;
    }

    function isCToken() external pure returns (bool) {
        return true;
    }

    function underlying() external view returns (address) {
        return address(token);
    }

    function mint() external payable {
        _mint(msg.sender, msg.value / effectiveExchangeRate);
    }

    function mint(uint256 amount) external returns (uint256) {
        token.transferFrom(msg.sender, address(this), amount);
        _mint(msg.sender, amount / effectiveExchangeRate);
        return error ? 1 : 0;
    }

    function redeemUnderlying(uint256 redeemAmount) external returns (uint256) {
        _burn(msg.sender, redeemAmount / effectiveExchangeRate);
        if (address(this).balance >= redeemAmount) {
            payable(msg.sender).transfer(redeemAmount);
        } else {
            token.transfer(msg.sender, redeemAmount);
        }
        return error ? 1 : 0;
    }

    function exchangeRateStored() external view returns (uint256) {
        return EXCHANGE_RATE_SCALE * effectiveExchangeRate; // 2:1
    }
}",430
RealWorld_TA_102_Vcon_RealWorld_20240812163723.log,102,Vcon,359729,3735,363464,119.0,1.873345,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

// Forked from Uniswap's UNI
// Reference: https://etherscan.io/address/0x1f9840a85d5af5bf1d1762f925bdaddc4201f984#code

contract Vcon {
    /// @notice EIP-20 token name for this token
    // solhint-disable-next-line const-name-snakecase
    string public constant name = ""Volt Controller"";

    /// @notice EIP-20 token symbol for this token
    // solhint-disable-next-line const-name-snakecase
    string public constant symbol = ""VCON"";

    /// @notice EIP-20 token decimals for this token
    // solhint-disable-next-line const-name-snakecase
    uint8 public constant decimals = 18;

    /// @notice Total number of tokens in circulation
    // solhint-disable-next-line const-name-snakecase
    uint256 public totalSupply = 1_000_000_000e18; // 1 billion Vcon

    /// @notice Address which may mint new tokens
    address public minter;

    /// @notice Allowance amounts on behalf of others
    mapping(address => mapping(address => uint96)) internal allowances;

    /// @notice Official record of token balances for each account
    mapping(address => uint96) internal balances;

    /// @notice A record of each accounts delegate
    mapping(address => address) public delegates;

    /// @notice A checkpoint for marking number of votes from a given block
    struct Checkpoint {
        uint32 fromBlock;
        uint96 votes;
    }

    /// @notice A record of votes checkpoints for each account, by index
    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;

    /// @notice The number of checkpoints for each account
    mapping(address => uint32) public numCheckpoints;

    /// @notice The EIP-712 typehash for the contract's domain
    bytes32 public constant DOMAIN_TYPEHASH =
        keccak256(
            ""EIP712Domain(string name,uint256 chainId,address verifyingContract)""
        );

    /// @notice The EIP-712 typehash for the delegation struct used by the contract
    bytes32 public constant DELEGATION_TYPEHASH =
        keccak256(""Delegation(address delegatee,uint256 nonce,uint256 expiry)"");

    /// @notice The EIP-712 typehash for the permit struct used by the contract
    bytes32 public constant PERMIT_TYPEHASH =
        keccak256(
            ""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)""
        );

    /// @notice A record of states for signing / validating signatures
    mapping(address => uint256) public nonces;

    /// @notice An event thats emitted when the minter address is changed
    event MinterChanged(address minter, address newMinter);

    /// @notice An event thats emitted when an account changes its delegate
    event DelegateChanged(
        address indexed delegator,
        address indexed fromDelegate,
        address indexed toDelegate
    );

    /// @notice An event thats emitted when a delegate account's vote balance changes
    event DelegateVotesChanged(
        address indexed delegate,
        uint256 previousBalance,
        uint256 newBalance
    );

    /// @notice The standard EIP-20 transfer event
    event Transfer(address indexed from, address indexed to, uint256 amount);

    /// @notice The standard EIP-20 approval event
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 amount
    );

    /**
     * @notice Construct a new Vcon token
     * @param account The initial account to grant all the tokens
     * @param minter_ The account with minting ability
     */
    constructor(address account, address minter_) {
        balances[account] = uint96(totalSupply);
        emit Transfer(address(0), account, totalSupply);
        minter = minter_;
        emit MinterChanged(address(0), minter);
    }

    /**
     * @notice Change the minter address
     * @param minter_ The address of the new minter
     */
    function setMinter(address minter_) external {
        require(
            msg.sender == minter,
            ""Vcon: only the minter can change the minter address""
        );
        emit MinterChanged(minter, minter_);
        minter = minter_;
    }

    /**
     * @notice Mint new tokens
     * @param dst The address of the destination account
     * @param rawAmount The number of tokens to be minted
     */
    function mint(address dst, uint256 rawAmount) external {
        require(msg.sender == minter, ""Vcon: only the minter can mint"");
        require(dst != address(0), ""Vcon: cannot transfer to the zero address"");

        // mint the amount
        uint96 amount = safe96(rawAmount, ""Vcon: amount exceeds 96 bits"");
        uint96 safeSupply = safe96(
            totalSupply,
            ""Vcon: totalSupply exceeds 96 bits""
        );
        totalSupply = add96(
            safeSupply,
            amount,
            ""Vcon: totalSupply exceeds 96 bits""
        );

        // transfer the amount to the recipient
        balances[dst] = add96(
            balances[dst],
            amount,
            ""Vcon: transfer amount overflows""
        );
        emit Transfer(address(0), dst, amount);

        // move delegates
        _moveDelegates(address(0), delegates[dst], amount);
    }

    /**
     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`
     * @param account The address of the account holding the funds
     * @param spender The address of the account spending the funds
     * @return The number of tokens approved
     */
    function allowance(address account, address spender)
        external
        view
        returns (uint256)
    {
        return allowances[account][spender];
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 rawAmount)
        external
        returns (bool)
    {
        uint96 amount;
        if (rawAmount == type(uint256).max) {
            amount = type(uint96).max;
        } else {
            amount = safe96(rawAmount, ""Vcon: amount exceeds 96 bits"");
        }

        allowances[msg.sender][spender] = amount;

        emit Approval(msg.sender, spender, amount);
        return true;
    }

    /**
     * @notice Triggers an approval from owner to spends
     * @param owner The address to approve from
     * @param spender The address to be approved
     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)
     * @param deadline The time at which to expire the signature
     * @param v The recovery byte of the signature
     * @param r Half of the ECDSA signature pair
     * @param s Half of the ECDSA signature pair
     */
    function permit(
        address owner,
        address spender,
        uint256 rawAmount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        uint96 amount;
        if (rawAmount == type(uint256).max) {
            amount = type(uint96).max;
        } else {
            amount = safe96(rawAmount, ""Vcon: amount exceeds 96 bits"");
        }

        bytes32 domainSeparator = keccak256(
            abi.encode(
                DOMAIN_TYPEHASH,
                keccak256(bytes(name)),
                getChainId(),
                address(this)
            )
        );
        bytes32 structHash = keccak256(
            abi.encode(
                PERMIT_TYPEHASH,
                owner,
                spender,
                rawAmount,
                nonces[owner]++,
                deadline
            )
        );
        bytes32 digest = keccak256(
            abi.encodePacked(""\x19\x01"", domainSeparator, structHash)
        );
        address signatory = ecrecover(digest, v, r, s);
        require(signatory != address(0), ""Vcon: invalid signature"");
        require(signatory == owner, ""Vcon: unauthorized"");
        require(block.timestamp <= deadline, ""Vcon: signature expired"");

        allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);
    }

    /**
     * @notice Get the number of tokens held by the `account`
     * @param account The address of the account to get the balance of
     * @return The number of tokens held
     */
    function balanceOf(address account) external view returns (uint256) {
        return balances[account];
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param rawAmount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 rawAmount) external returns (bool) {
        uint96 amount = safe96(rawAmount, ""Vcon: amount exceeds 96 bits"");
        _transferTokens(msg.sender, dst, amount);
        return true;
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param rawAmount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(
        address src,
        address dst,
        uint256 rawAmount
    ) external returns (bool) {
        address spender = msg.sender;
        uint96 spenderAllowance = allowances[src][spender];
        uint96 amount = safe96(rawAmount, ""Vcon: amount exceeds 96 bits"");

        if (spender != src && spenderAllowance != type(uint96).max) {
            uint96 newAllowance = sub96(
                spenderAllowance,
                amount,
                ""Vcon: transfer amount exceeds spender allowance""
            );
            allowances[src][spender] = newAllowance;

            emit Approval(src, spender, newAllowance);
        }

        _transferTokens(src, dst, amount);
        return true;
    }

    /**
     * @notice Delegate votes from `msg.sender` to `delegatee`
     * @param delegatee The address to delegate votes to
     */
    function delegate(address delegatee) public {
        return _delegate(msg.sender, delegatee);
    }

    /**
     * @notice Delegates votes from signatory to `delegatee`
     * @param delegatee The address to delegate votes to
     * @param nonce The contract state required to match the signature
     * @param expiry The time at which to expire the signature
     * @param v The recovery byte of the signature
     * @param r Half of the ECDSA signature pair
     * @param s Half of the ECDSA signature pair
     */
    function delegateBySig(
        address delegatee,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        bytes32 domainSeparator = keccak256(
            abi.encode(
                DOMAIN_TYPEHASH,
                keccak256(bytes(name)),
                getChainId(),
                address(this)
            )
        );
        bytes32 structHash = keccak256(
            abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry)
        );
        bytes32 digest = keccak256(
            abi.encodePacked(""\x19\x01"", domainSeparator, structHash)
        );
        address signatory = ecrecover(digest, v, r, s);
        require(signatory != address(0), ""Vcon: invalid signature"");
        require(nonce == nonces[signatory]++, ""Vcon: invalid nonce"");
        require(block.timestamp <= expiry, ""Vcon: signature expired"");
        return _delegate(signatory, delegatee);
    }

    /**
     * @notice Gets the current votes balance for `account`
     * @param account The address to get votes balance
     * @return The number of current votes for `account`
     */
    function getCurrentVotes(address account) external view returns (uint96) {
        uint32 nCheckpoints = numCheckpoints[account];
        return
            nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;
    }

    /**
     * @notice Determine the prior number of votes for an account as of a block number
     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.
     * @param account The address of the account to check
     * @param blockNumber The block number to get the vote balance at
     * @return The number of votes the account had as of the given block
     */
    function getPriorVotes(address account, uint256 blockNumber)
        public
        view
        returns (uint96)
    {
        require(blockNumber < block.number, ""Vcon: not yet determined"");

        uint32 nCheckpoints = numCheckpoints[account];
        if (nCheckpoints == 0) {
            return 0;
        }

        // First check most recent balance
        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nCheckpoints - 1].votes;
        }

        // Next check implicit zero balance
        if (checkpoints[account][0].fromBlock > blockNumber) {
            return 0;
        }

        uint32 lower = 0;
        uint32 upper = nCheckpoints - 1;
        while (upper > lower) {
            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow
            Checkpoint memory cp = checkpoints[account][center];
            if (cp.fromBlock == blockNumber) {
                return cp.votes;
            } else if (cp.fromBlock < blockNumber) {
                lower = center;
            } else {
                upper = center - 1;
            }
        }
        return checkpoints[account][lower].votes;
    }

    function _delegate(address delegator, address delegatee) internal {
        address currentDelegate = delegates[delegator];
        uint96 delegatorBalance = balances[delegator];
        delegates[delegator] = delegatee;

        emit DelegateChanged(delegator, currentDelegate, delegatee);

        _moveDelegates(currentDelegate, delegatee, delegatorBalance);
    }

    function _transferTokens(
        address src,
        address dst,
        uint96 amount
    ) internal {
        require(
            src != address(0),
            ""Vcon: cannot transfer from the zero address""
        );
        require(dst != address(0), ""Vcon: cannot transfer to the zero address"");

        balances[src] = sub96(
            balances[src],
            amount,
            ""Vcon: transfer amount exceeds balance""
        );
        balances[dst] = add96(
            balances[dst],
            amount,
            ""Vcon: transfer amount overflows""
        );
        emit Transfer(src, dst, amount);

        _moveDelegates(delegates[src], delegates[dst], amount);
    }

    function _moveDelegates(
        address srcRep,
        address dstRep,
        uint96 amount
    ) internal {
        if (srcRep != dstRep && amount > 0) {
            if (srcRep != address(0)) {
                uint32 srcRepNum = numCheckpoints[srcRep];
                uint96 srcRepOld = srcRepNum > 0
                    ? checkpoints[srcRep][srcRepNum - 1].votes
                    : 0;
                uint96 srcRepNew = sub96(
                    srcRepOld,
                    amount,
                    ""Vcon: vote amount underflows""
                );
                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);
            }

            if (dstRep != address(0)) {
                uint32 dstRepNum = numCheckpoints[dstRep];
                uint96 dstRepOld = dstRepNum > 0
                    ? checkpoints[dstRep][dstRepNum - 1].votes
                    : 0;
                uint96 dstRepNew = add96(
                    dstRepOld,
                    amount,
                    ""Vcon: vote amount overflows""
                );
                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);
            }
        }
    }

    function _writeCheckpoint(
        address delegatee,
        uint32 nCheckpoints,
        uint96 oldVotes,
        uint96 newVotes
    ) internal {
        uint32 blockNumber = safe32(
            block.number,
            ""Vcon: block number exceeds 32 bits""
        );

        if (
            nCheckpoints > 0 &&
            checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber
        ) {
            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;
        } else {
            checkpoints[delegatee][nCheckpoints] = Checkpoint(
                blockNumber,
                newVotes
            );
            numCheckpoints[delegatee] = nCheckpoints + 1;
        }

        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);
    }

    function safe32(uint256 n, string memory errorMessage)
        internal
        pure
        returns (uint32)
    {
        require(n < 2**32, errorMessage);
        return uint32(n);
    }

    function safe96(uint256 n, string memory errorMessage)
        internal
        pure
        returns (uint96)
    {
        require(n < 2**96, errorMessage);
        return uint96(n);
    }

    function add96(
        uint96 a,
        uint96 b,
        string memory errorMessage
    ) internal pure returns (uint96) {
        uint96 c = a + b;
        require(c >= a, errorMessage);
        return c;
    }

    function sub96(
        uint96 a,
        uint96 b,
        string memory errorMessage
    ) internal pure returns (uint96) {
        require(b <= a, errorMessage);
        return a - b;
    }

    function getChainId() internal view returns (uint256) {
        uint256 chainId;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            chainId := chainid()
        }
        return chainId;
    }
}",4041
RealWorld_TA_102_Core_RealWorld_20240812163342.log,102,Core,41643,1880,43523,75.0,0.245815,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {Vcon} from ""../vcon/Vcon.sol"";
import {IVolt, Volt, IERC20} from ""../volt/Volt.sol"";
import {ICore} from ""./ICore.sol"";
import {Permissions} from ""./Permissions.sol"";
import {Initializable} from ""@openzeppelin/contracts/proxy/utils/Initializable.sol"";

/// @title Source of truth for VOLT Protocol
/// @author Fei Protocol
/// @notice maintains roles, access control, Volt, Vcon, and the Vcon treasury
contract Core is ICore, Permissions, Initializable {
    /// @notice the address of the FEI contract
    IVolt public override volt;

    /// @notice the address of the Vcon contract
    IERC20 public override vcon;

    function init() external initializer {
        volt = new Volt(address(this));
        /// msg.sender already has the VOLT Minting abilities, so grant them governor as well
        _setupGovernor(msg.sender);
    }

    /// @notice governor only function to set the VCON token
    function setVcon(IERC20 _vcon) external onlyGovernor {
        vcon = _vcon;

        emit VconUpdate(_vcon);
    }
}",279
RealWorld_TA_102_ScalingPriceOracle.t_RealWorld_20240812164408.log,102,ScalingPriceOracle.t,103792,2863,106655,90.0,0.57622,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {Vm} from ""./../utils/Vm.sol"";
import {DSTest} from ""./../utils/DSTest.sol"";
import {getCore, getAddresses, FeiTestAddresses} from ""./../utils/Fixtures.sol"";
import {MockScalingPriceOracle} from ""../../../mock/MockScalingPriceOracle.sol"";
import {Decimal} from ""./../../../external/Decimal.sol"";

contract ScalingPriceOracleTest is DSTest {
    using Decimal for Decimal.D256;

    MockScalingPriceOracle private scalingPriceOracle;

    /// @notice increase price by 3.09% per month
    int256 public constant monthlyChangeRateBasisPoints = 309;

    /// @notice the current month's CPI data
    uint128 public constant currentMonth = 270000;

    /// @notice the previous month's CPI data
    uint128 public constant previousMonth = 261900;

    /// @notice address of chainlink oracle to send request
    address public immutable oracle = address(0);

    /// @notice job id that retrieves the latest CPI data
    bytes32 public immutable jobId =
        keccak256(abi.encodePacked(""Chainlink CPI-U job""));

    /// @notice fee of 10 link
    uint256 public immutable fee = 1e19;

    Vm public constant vm = Vm(HEVM_ADDRESS);
    FeiTestAddresses public addresses = getAddresses();

    function setUp() public {
        /// warp to 1 to set isTimeStarted to true
        vm.warp(1);

        scalingPriceOracle = new MockScalingPriceOracle(
            oracle,
            jobId,
            fee,
            currentMonth,
            previousMonth
        );
    }

    function testSetup() public {
        assertEq(scalingPriceOracle.oracle(), oracle);
        assertEq(scalingPriceOracle.jobId(), jobId);
        assertEq(scalingPriceOracle.fee(), fee);
        assertEq(scalingPriceOracle.currentMonth(), currentMonth);
        assertEq(scalingPriceOracle.previousMonth(), previousMonth);
        assertEq(
            scalingPriceOracle.getMonthlyAPR(),
            monthlyChangeRateBasisPoints
        );
    }

    /// positive price action from oracle -- inflation case
    function testReadGetCurrentOraclePriceAfterInterpolation() public {
        vm.warp(block.timestamp + 28 days);
        assertEq(10309e14, scalingPriceOracle.getCurrentOraclePrice());
    }

    /// negative price action from oracle -- deflation case
    function testPriceDecreaseAfterInterpolation() public {
        scalingPriceOracle = new MockScalingPriceOracle(
            oracle,
            jobId,
            fee,
            previousMonth, /// flip current and previous months so that rate is -3%
            currentMonth
        );

        vm.warp(block.timestamp + 28 days);
        assertEq(97e16, scalingPriceOracle.getCurrentOraclePrice());
    }

    function testFulfillFailureTimed() public {
        assertTrue(!scalingPriceOracle.isTimeEnded());

        vm.expectRevert(bytes(""Timed: time not ended, init""));

        scalingPriceOracle.requestCPIData();
    }

    function testFulfillMaxDeviationExceededFailureUp() public {
        vm.expectRevert(
            bytes(
                ""ScalingPriceOracle: Chainlink data outside of deviation threshold""
            )
        );

        /// this will fail as it is 21% inflation and max allowable is 20%
        scalingPriceOracle.fulfill((currentMonth * 121) / 100);
    }

    function testFulfillMaxDeviationExceededFailureDown() public {
        vm.expectRevert(
            bytes(
                ""ScalingPriceOracle: Chainlink data outside of deviation threshold""
            )
        );

        /// this will fail as it is 21% inflation and max allowable is 20%
        scalingPriceOracle.fulfill((currentMonth * 79) / 100);
    }

    function testFulfillSucceedsTwentyPercent() public {
        uint256 storedCurrentMonth = scalingPriceOracle.currentMonth();
        uint256 newCurrentMonth = (currentMonth * 120) / 100;

        /// this will succeed as max allowable is 20%
        scalingPriceOracle.fulfill(newCurrentMonth);

        assertEq(scalingPriceOracle.monthlyChangeRateBasisPoints(), 2_000);
        /// assert that all state transitions were done correctly with current and previous month
        assertEq(scalingPriceOracle.previousMonth(), storedCurrentMonth);
        assertEq(scalingPriceOracle.currentMonth(), newCurrentMonth);
    }

    function testFulfillFailureCalendar() public {
        vm.warp(block.timestamp + 1647240109);

        vm.expectRevert(
            bytes(""ScalingPriceOracle: cannot request data before the 15th"")
        );

        scalingPriceOracle.requestCPIData();
    }
}",1007
RealWorld_TA_102_OracleRef_RealWorld_20240812174424.log,102,OracleRef,125725,3641,129366,109.0,0.701445,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""./IOracleRef.sol"";
import ""./CoreRef.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";

/// @title Reference to an Oracle
/// @author Fei Protocol
/// @notice defines some utilities around interacting with the referenced oracle
abstract contract OracleRef is IOracleRef, CoreRef {
    using Decimal for Decimal.D256;
    using SafeCast for int256;

    /// @notice the oracle reference by the contract
    IOracle public override oracle;

    /// @notice the backup oracle reference by the contract
    IOracle public override backupOracle;

    /// @notice number of decimals to scale oracle price by, i.e. multiplying by 10^(decimalsNormalizer)
    int256 public override decimalsNormalizer;

    bool public override doInvert;

    /// @notice OracleRef constructor
    /// @param _core Fei Core to reference
    /// @param _oracle oracle to reference
    /// @param _backupOracle backup oracle to reference
    /// @param _decimalsNormalizer number of decimals to normalize the oracle feed if necessary
    /// @param _doInvert invert the oracle price if this flag is on
    constructor(
        address _core,
        address _oracle,
        address _backupOracle,
        int256 _decimalsNormalizer,
        bool _doInvert
    ) CoreRef(_core) {
        _setOracle(_oracle);
        if (_backupOracle != address(0) && _backupOracle != _oracle) {
            _setBackupOracle(_backupOracle);
        }
        _setDoInvert(_doInvert);
        _setDecimalsNormalizer(_decimalsNormalizer);
    }

    /// @notice sets the referenced oracle
    /// @param newOracle the new oracle to reference
    function setOracle(address newOracle) external override onlyGovernor {
        _setOracle(newOracle);
    }

    /// @notice sets the flag for whether to invert or not
    /// @param newDoInvert the new flag for whether to invert
    function setDoInvert(bool newDoInvert) external override onlyGovernor {
        _setDoInvert(newDoInvert);
    }

    /// @notice sets the new decimalsNormalizer
    /// @param newDecimalsNormalizer the new decimalsNormalizer
    function setDecimalsNormalizer(int256 newDecimalsNormalizer)
        external
        override
        onlyGovernor
    {
        _setDecimalsNormalizer(newDecimalsNormalizer);
    }

    /// @notice sets the referenced backup oracle
    /// @param newBackupOracle the new backup oracle to reference
    function setBackupOracle(address newBackupOracle)
        external
        override
        onlyGovernorOrAdmin
    {
        _setBackupOracle(newBackupOracle);
    }

    /// @notice invert a peg price
    /// @param price the peg price to invert
    /// @return the inverted peg as a Decimal
    /// @dev the inverted peg would be X per FEI
    function invert(Decimal.D256 memory price)
        public
        pure
        override
        returns (Decimal.D256 memory)
    {
        return Decimal.one().div(price);
    }

    /// @notice updates the referenced oracle
    function updateOracle() public override {
        oracle.update();
    }

    /// @notice the peg price of the referenced oracle
    /// @return the peg as a Decimal
    /// @dev the peg is defined as FEI per X with X being ETH, dollars, etc
    function readOracle() public view override returns (Decimal.D256 memory) {
        (Decimal.D256 memory _peg, bool valid) = oracle.read();
        if (!valid && address(backupOracle) != address(0)) {
            (_peg, valid) = backupOracle.read();
        }
        require(valid, ""OracleRef: oracle invalid"");

        // Scale the oracle price by token decimals delta if necessary
        uint256 scalingFactor;
        if (decimalsNormalizer < 0) {
            scalingFactor = 10**(-1 * decimalsNormalizer).toUint256();
            _peg = _peg.div(scalingFactor);
        } else {
            scalingFactor = 10**decimalsNormalizer.toUint256();
            _peg = _peg.mul(scalingFactor);
        }

        // Invert the oracle price if necessary
        if (doInvert) {
            _peg = invert(_peg);
        }
        return _peg;
    }

    function _setOracle(address newOracle) internal {
        require(newOracle != address(0), ""OracleRef: zero address"");
        address oldOracle = address(oracle);
        oracle = IOracle(newOracle);
        emit OracleUpdate(oldOracle, newOracle);
    }

    // Supports zero address if no backup
    function _setBackupOracle(address newBackupOracle) internal {
        address oldBackupOracle = address(backupOracle);
        backupOracle = IOracle(newBackupOracle);
        emit BackupOracleUpdate(oldBackupOracle, newBackupOracle);
    }

    function _setDoInvert(bool newDoInvert) internal {
        bool oldDoInvert = doInvert;
        doInvert = newDoInvert;

        if (oldDoInvert != newDoInvert) {
            _setDecimalsNormalizer(-1 * decimalsNormalizer);
        }

        emit InvertUpdate(oldDoInvert, newDoInvert);
    }

    function _setDecimalsNormalizer(int256 newDecimalsNormalizer) internal {
        int256 oldDecimalsNormalizer = decimalsNormalizer;
        decimalsNormalizer = newDecimalsNormalizer;
        emit DecimalsNormalizerUpdate(
            oldDecimalsNormalizer,
            newDecimalsNormalizer
        );
    }

    function _setDecimalsNormalizerFromToken(address token) internal {
        int256 feiDecimals = 18;
        int256 _decimalsNormalizer = feiDecimals -
            int256(uint256(IERC20Metadata(token).decimals()));

        if (doInvert) {
            _decimalsNormalizer = -1 * _decimalsNormalizer;
        }

        _setDecimalsNormalizer(_decimalsNormalizer);
    }
}",1337
RealWorld_TA_102_BokkyPooBahsDateTimeLibrary_RealWorld_20240812175825.log,102,BokkyPooBahsDateTimeLibrary,366766,1384,368150,103.0,1.86151,"// SPDX-License-Identifier: GNU Lesser General Public License 3.0
pragma solidity ^0.8.4;

// ----------------------------------------------------------------------------
// BokkyPooBah's DateTime Library v1.00
//
// A gas-efficient Solidity date and time library
//
// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary
//
// Tested date range 1970/01/01 to 2345/12/31
//
// Conventions:
// Unit      | Range         | Notes
// :-------- |:-------------:|:-----
// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC
// year      | 1970 ... 2345 |
// month     | 1 ... 12      |
// day       | 1 ... 31      |
// hour      | 0 ... 23      |
// minute    | 0 ... 59      |
// second    | 0 ... 59      |
// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday
//
//
// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018.
//
// GNU Lesser General Public License 3.0
// https://www.gnu.org/licenses/lgpl-3.0.en.html
// ----------------------------------------------------------------------------

library BokkyPooBahsDateTimeLibrary {
    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;
    uint256 constant SECONDS_PER_HOUR = 60 * 60;
    uint256 constant SECONDS_PER_MINUTE = 60;
    int256 constant OFFSET19700101 = 2440588;

    uint256 constant DOW_MON = 1;
    uint256 constant DOW_TUE = 2;
    uint256 constant DOW_WED = 3;
    uint256 constant DOW_THU = 4;
    uint256 constant DOW_FRI = 5;
    uint256 constant DOW_SAT = 6;
    uint256 constant DOW_SUN = 7;

    // ------------------------------------------------------------------------
    // Calculate the number of days from 1970/01/01 to year/month/day using
    // the date conversion algorithm from
    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php
    // and subtracting the offset 2440588 so that 1970/01/01 is day 0
    //
    // days = day
    //      - 32075
    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4
    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12
    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4
    //      - offset
    // ------------------------------------------------------------------------
    function _daysFromDate(
        uint256 year,
        uint256 month,
        uint256 day
    ) internal pure returns (uint256 _days) {
        require(year >= 1970);
        int256 _year = int256(year);
        int256 _month = int256(month);
        int256 _day = int256(day);

        int256 __days = _day -
            32075 +
            (1461 * (_year + 4800 + (_month - 14) / 12)) /
            4 +
            (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /
            12 -
            (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /
            4 -
            OFFSET19700101;

        _days = uint256(__days);
    }

    // ------------------------------------------------------------------------
    // Calculate year/month/day from the number of days since 1970/01/01 using
    // the date conversion algorithm from
    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php
    // and adding the offset 2440588 so that 1970/01/01 is day 0
    //
    // int L = days + 68569 + offset
    // int N = 4 * L / 146097
    // L = L - (146097 * N + 3) / 4
    // year = 4000 * (L + 1) / 1461001
    // L = L - 1461 * year / 4 + 31
    // month = 80 * L / 2447
    // dd = L - 2447 * month / 80
    // L = month / 11
    // month = month + 2 - 12 * L
    // year = 100 * (N - 49) + year + L
    // ------------------------------------------------------------------------
    function _daysToDate(uint256 _days)
        internal
        pure
        returns (
            uint256 year,
            uint256 month,
            uint256 day
        )
    {
        int256 __days = int256(_days);

        int256 L = __days + 68569 + OFFSET19700101;
        int256 N = (4 * L) / 146097;
        L = L - (146097 * N + 3) / 4;
        int256 _year = (4000 * (L + 1)) / 1461001;
        L = L - (1461 * _year) / 4 + 31;
        int256 _month = (80 * L) / 2447;
        int256 _day = L - (2447 * _month) / 80;
        L = _month / 11;
        _month = _month + 2 - 12 * L;
        _year = 100 * (N - 49) + _year + L;

        year = uint256(_year);
        month = uint256(_month);
        day = uint256(_day);
    }

    function timestampFromDate(
        uint256 year,
        uint256 month,
        uint256 day
    ) internal pure returns (uint256 timestamp) {
        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;
    }

    function timestampFromDateTime(
        uint256 year,
        uint256 month,
        uint256 day,
        uint256 hour,
        uint256 minute,
        uint256 second
    ) internal pure returns (uint256 timestamp) {
        timestamp =
            _daysFromDate(year, month, day) *
            SECONDS_PER_DAY +
            hour *
            SECONDS_PER_HOUR +
            minute *
            SECONDS_PER_MINUTE +
            second;
    }

    function timestampToDate(uint256 timestamp)
        internal
        pure
        returns (
            uint256 year,
            uint256 month,
            uint256 day
        )
    {
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }

    function timestampToDateTime(uint256 timestamp)
        internal
        pure
        returns (
            uint256 year,
            uint256 month,
            uint256 day,
            uint256 hour,
            uint256 minute,
            uint256 second
        )
    {
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        uint256 secs = timestamp % SECONDS_PER_DAY;
        hour = secs / SECONDS_PER_HOUR;
        secs = secs % SECONDS_PER_HOUR;
        minute = secs / SECONDS_PER_MINUTE;
        second = secs % SECONDS_PER_MINUTE;
    }

    function isValidDate(
        uint256 year,
        uint256 month,
        uint256 day
    ) internal pure returns (bool valid) {
        if (year >= 1970 && month > 0 && month <= 12) {
            uint256 daysInMonth = _getDaysInMonth(year, month);
            if (day > 0 && day <= daysInMonth) {
                valid = true;
            }
        }
    }

    function isValidDateTime(
        uint256 year,
        uint256 month,
        uint256 day,
        uint256 hour,
        uint256 minute,
        uint256 second
    ) internal pure returns (bool valid) {
        if (isValidDate(year, month, day)) {
            if (hour < 24 && minute < 60 && second < 60) {
                valid = true;
            }
        }
    }

    function isLeapYear(uint256 timestamp)
        internal
        pure
        returns (bool leapYear)
    {
        uint256 year;
        uint256 month;
        uint256 day;
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        leapYear = _isLeapYear(year);
    }

    function _isLeapYear(uint256 year) internal pure returns (bool leapYear) {
        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);
    }

    function isWeekDay(uint256 timestamp) internal pure returns (bool weekDay) {
        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;
    }

    function isWeekEnd(uint256 timestamp) internal pure returns (bool weekEnd) {
        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;
    }

    function getDaysInMonth(uint256 timestamp)
        internal
        pure
        returns (uint256 daysInMonth)
    {
        uint256 year;
        uint256 month;
        uint256 day;
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        daysInMonth = _getDaysInMonth(year, month);
    }

    function _getDaysInMonth(uint256 year, uint256 month)
        internal
        pure
        returns (uint256 daysInMonth)
    {
        if (
            month == 1 ||
            month == 3 ||
            month == 5 ||
            month == 7 ||
            month == 8 ||
            month == 10 ||
            month == 12
        ) {
            daysInMonth = 31;
        } else if (month != 2) {
            daysInMonth = 30;
        } else {
            daysInMonth = _isLeapYear(year) ? 29 : 28;
        }
    }

    // 1 = Monday, 7 = Sunday
    function getDayOfWeek(uint256 timestamp)
        internal
        pure
        returns (uint256 dayOfWeek)
    {
        uint256 _days = timestamp / SECONDS_PER_DAY;
        dayOfWeek = ((_days + 3) % 7) + 1;
    }

    function getYear(uint256 timestamp) internal pure returns (uint256 year) {
        uint256 month;
        uint256 day;
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }

    function getMonth(uint256 timestamp) internal pure returns (uint256 month) {
        uint256 year;
        uint256 day;
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }

    function getDay(uint256 timestamp) internal pure returns (uint256 day) {
        uint256 year;
        uint256 month;
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }

    function getHour(uint256 timestamp) internal pure returns (uint256 hour) {
        uint256 secs = timestamp % SECONDS_PER_DAY;
        hour = secs / SECONDS_PER_HOUR;
    }

    function getMinute(uint256 timestamp)
        internal
        pure
        returns (uint256 minute)
    {
        uint256 secs = timestamp % SECONDS_PER_HOUR;
        minute = secs / SECONDS_PER_MINUTE;
    }

    function getSecond(uint256 timestamp)
        internal
        pure
        returns (uint256 second)
    {
        second = timestamp % SECONDS_PER_MINUTE;
    }

    function addYears(uint256 timestamp, uint256 _years)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        uint256 year;
        uint256 month;
        uint256 day;
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        year += _years;
        uint256 daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp =
            _daysFromDate(year, month, day) *
            SECONDS_PER_DAY +
            (timestamp % SECONDS_PER_DAY);
        require(newTimestamp >= timestamp);
    }

    function addMonths(uint256 timestamp, uint256 _months)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        uint256 year;
        uint256 month;
        uint256 day;
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        month += _months;
        year += (month - 1) / 12;
        month = ((month - 1) % 12) + 1;
        uint256 daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp =
            _daysFromDate(year, month, day) *
            SECONDS_PER_DAY +
            (timestamp % SECONDS_PER_DAY);
        require(newTimestamp >= timestamp);
    }

    function addDays(uint256 timestamp, uint256 _days)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = timestamp + _days * SECONDS_PER_DAY;
        require(newTimestamp >= timestamp);
    }

    function addHours(uint256 timestamp, uint256 _hours)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;
        require(newTimestamp >= timestamp);
    }

    function addMinutes(uint256 timestamp, uint256 _minutes)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;
        require(newTimestamp >= timestamp);
    }

    function addSeconds(uint256 timestamp, uint256 _seconds)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = timestamp + _seconds;
        require(newTimestamp >= timestamp);
    }

    function subYears(uint256 timestamp, uint256 _years)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        uint256 year;
        uint256 month;
        uint256 day;
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        year -= _years;
        uint256 daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp =
            _daysFromDate(year, month, day) *
            SECONDS_PER_DAY +
            (timestamp % SECONDS_PER_DAY);
        require(newTimestamp <= timestamp);
    }

    function subMonths(uint256 timestamp, uint256 _months)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        uint256 year;
        uint256 month;
        uint256 day;
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        uint256 yearMonth = year * 12 + (month - 1) - _months;
        year = yearMonth / 12;
        month = (yearMonth % 12) + 1;
        uint256 daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp =
            _daysFromDate(year, month, day) *
            SECONDS_PER_DAY +
            (timestamp % SECONDS_PER_DAY);
        require(newTimestamp <= timestamp);
    }

    function subDays(uint256 timestamp, uint256 _days)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = timestamp - _days * SECONDS_PER_DAY;
        require(newTimestamp <= timestamp);
    }

    function subHours(uint256 timestamp, uint256 _hours)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;
        require(newTimestamp <= timestamp);
    }

    function subMinutes(uint256 timestamp, uint256 _minutes)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;
        require(newTimestamp <= timestamp);
    }

    function subSeconds(uint256 timestamp, uint256 _seconds)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = timestamp - _seconds;
        require(newTimestamp <= timestamp);
    }

    function diffYears(uint256 fromTimestamp, uint256 toTimestamp)
        internal
        pure
        returns (uint256 _years)
    {
        require(fromTimestamp <= toTimestamp);
        uint256 fromYear;
        uint256 fromMonth;
        uint256 fromDay;
        uint256 toYear;
        uint256 toMonth;
        uint256 toDay;
        (fromYear, fromMonth, fromDay) = _daysToDate(
            fromTimestamp / SECONDS_PER_DAY
        );
        (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);
        _years = toYear - fromYear;
    }

    function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)
        internal
        pure
        returns (uint256 _months)
    {
        require(fromTimestamp <= toTimestamp);
        uint256 fromYear;
        uint256 fromMonth;
        uint256 fromDay;
        uint256 toYear;
        uint256 toMonth;
        uint256 toDay;
        (fromYear, fromMonth, fromDay) = _daysToDate(
            fromTimestamp / SECONDS_PER_DAY
        );
        (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);
        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;
    }

    function diffDays(uint256 fromTimestamp, uint256 toTimestamp)
        internal
        pure
        returns (uint256 _days)
    {
        require(fromTimestamp <= toTimestamp);
        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;
    }

    function diffHours(uint256 fromTimestamp, uint256 toTimestamp)
        internal
        pure
        returns (uint256 _hours)
    {
        require(fromTimestamp <= toTimestamp);
        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;
    }

    function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)
        internal
        pure
        returns (uint256 _minutes)
    {
        require(fromTimestamp <= toTimestamp);
        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;
    }

    function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)
        internal
        pure
        returns (uint256 _seconds)
    {
        require(fromTimestamp <= toTimestamp);
        _seconds = toTimestamp - fromTimestamp;
    }
}",4111
RealWorld_TA_102_Volt.t_RealWorld_20240812163925.log,102,Volt.t,44076,1679,45755,67.0,0.25396,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import {IVolt} from ""../../volt/Volt.sol"";
import {Volt} from ""../../volt/Volt.sol"";
import {ICore} from ""../../core/ICore.sol"";
import {Core} from ""../../core/Core.sol"";
import {Vm} from ""./utils/Vm.sol"";
import {DSTest} from ""./utils/DSTest.sol"";
import {getCore, getAddresses, FeiTestAddresses} from ""./utils/Fixtures.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";

contract VoltTest is DSTest {
    IVolt private volt;
    ICore private core;

    Vm public constant vm = Vm(HEVM_ADDRESS);
    FeiTestAddresses public addresses = getAddresses();

    function setUp() public {
        core = getCore();

        volt = core.volt();
    }

    function testDeployedMetaData() public {
        assertEq(volt.totalSupply(), 0);
        assertTrue(core.isGovernor(addresses.governorAddress));
    }

    function testMintsVolt() public {
        uint256 mintAmount = 100;

        vm.prank(addresses.minterAddress);
        volt.mint(addresses.userAddress, mintAmount);

        assertEq(volt.balanceOf(addresses.userAddress), mintAmount);
    }
}",312
RealWorld_TA_102_Permissions_RealWorld_20240812163218.log,102,Permissions,139117,2138,141255,82.0,0.738345,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/access/AccessControlEnumerable.sol"";
import ""./IPermissions.sol"";

/// @title Access control module for Core
/// @author Fei Protocol
contract Permissions is IPermissions, AccessControlEnumerable {
    bytes32 public constant override BURNER_ROLE = keccak256(""BURNER_ROLE"");
    bytes32 public constant override MINTER_ROLE = keccak256(""MINTER_ROLE"");
    bytes32 public constant override PCV_CONTROLLER_ROLE =
        keccak256(""PCV_CONTROLLER_ROLE"");
    bytes32 public constant override GOVERN_ROLE = keccak256(""GOVERN_ROLE"");
    bytes32 public constant override GUARDIAN_ROLE = keccak256(""GUARDIAN_ROLE"");

    constructor() {
        // Appointed as a governor so guardian can have indirect access to revoke ability
        _setupGovernor(address(this));

        _setRoleAdmin(MINTER_ROLE, GOVERN_ROLE);
        _setRoleAdmin(BURNER_ROLE, GOVERN_ROLE);
        _setRoleAdmin(PCV_CONTROLLER_ROLE, GOVERN_ROLE);
        _setRoleAdmin(GOVERN_ROLE, GOVERN_ROLE);
        _setRoleAdmin(GUARDIAN_ROLE, GOVERN_ROLE);
    }

    modifier onlyGovernor() {
        require(
            isGovernor(msg.sender),
            ""Permissions: Caller is not a governor""
        );
        _;
    }

    modifier onlyGuardian() {
        require(
            isGuardian(msg.sender),
            ""Permissions: Caller is not a guardian""
        );
        _;
    }

    /// @notice creates a new role to be maintained
    /// @param role the new role id
    /// @param adminRole the admin role id for `role`
    /// @dev can also be used to update admin of existing role
    function createRole(bytes32 role, bytes32 adminRole)
        external
        override
        onlyGovernor
    {
        _setRoleAdmin(role, adminRole);
    }

    /// @notice grants minter role to address
    /// @param minter new minter
    function grantMinter(address minter) external override onlyGovernor {
        grantRole(MINTER_ROLE, minter);
    }

    /// @notice grants burner role to address
    /// @param burner new burner
    function grantBurner(address burner) external override onlyGovernor {
        grantRole(BURNER_ROLE, burner);
    }

    /// @notice grants controller role to address
    /// @param pcvController new controller
    function grantPCVController(address pcvController)
        external
        override
        onlyGovernor
    {
        grantRole(PCV_CONTROLLER_ROLE, pcvController);
    }

    /// @notice grants governor role to address
    /// @param governor new governor
    function grantGovernor(address governor) external override onlyGovernor {
        grantRole(GOVERN_ROLE, governor);
    }

    /// @notice grants guardian role to address
    /// @param guardian new guardian
    function grantGuardian(address guardian) external override onlyGovernor {
        grantRole(GUARDIAN_ROLE, guardian);
    }

    /// @notice revokes minter role from address
    /// @param minter ex minter
    function revokeMinter(address minter) external override onlyGovernor {
        revokeRole(MINTER_ROLE, minter);
    }

    /// @notice revokes burner role from address
    /// @param burner ex burner
    function revokeBurner(address burner) external override onlyGovernor {
        revokeRole(BURNER_ROLE, burner);
    }

    /// @notice revokes pcvController role from address
    /// @param pcvController ex pcvController
    function revokePCVController(address pcvController)
        external
        override
        onlyGovernor
    {
        revokeRole(PCV_CONTROLLER_ROLE, pcvController);
    }

    /// @notice revokes governor role from address
    /// @param governor ex governor
    function revokeGovernor(address governor) external override onlyGovernor {
        revokeRole(GOVERN_ROLE, governor);
    }

    /// @notice revokes guardian role from address
    /// @param guardian ex guardian
    function revokeGuardian(address guardian) external override onlyGovernor {
        revokeRole(GUARDIAN_ROLE, guardian);
    }

    /// @notice revokes a role from address
    /// @param role the role to revoke
    /// @param account the address to revoke the role from
    function revokeOverride(bytes32 role, address account)
        external
        override
        onlyGuardian
    {
        require(
            role != GOVERN_ROLE,
            ""Permissions: Guardian cannot revoke governor""
        );

        // External call because this contract is appointed as a governor and has access to revoke
        this.revokeRole(role, account);
    }

    /// @notice checks if address is a minter
    /// @param _address address to check
    /// @return true _address is a minter
    // only virtual for testing mock override
    function isMinter(address _address)
        external
        view
        virtual
        override
        returns (bool)
    {
        return hasRole(MINTER_ROLE, _address);
    }

    /// @notice checks if address is a burner
    /// @param _address address to check
    /// @return true _address is a burner
    // only virtual for testing mock override
    function isBurner(address _address)
        external
        view
        virtual
        override
        returns (bool)
    {
        return hasRole(BURNER_ROLE, _address);
    }

    /// @notice checks if address is a controller
    /// @param _address address to check
    /// @return true _address is a controller
    // only virtual for testing mock override
    function isPCVController(address _address)
        external
        view
        virtual
        override
        returns (bool)
    {
        return hasRole(PCV_CONTROLLER_ROLE, _address);
    }

    /// @notice checks if address is a governor
    /// @param _address address to check
    /// @return true _address is a governor
    // only virtual for testing mock override
    function isGovernor(address _address)
        public
        view
        virtual
        override
        returns (bool)
    {
        return hasRole(GOVERN_ROLE, _address);
    }

    /// @notice checks if address is a guardian
    /// @param _address address to check
    /// @return true _address is a guardian
    // only virtual for testing mock override
    function isGuardian(address _address)
        public
        view
        virtual
        override
        returns (bool)
    {
        return hasRole(GUARDIAN_ROLE, _address);
    }

    function _setupGovernor(address governor) internal {
        _setupRole(GOVERN_ROLE, governor);
    }
}",1463
RealWorld_TA_102_MockScalingPriceOracle_RealWorld_20240812170312.log,102,MockScalingPriceOracle,33545,3020,36565,98.0,0.228125,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {CoreRef} from ""./../refs/CoreRef.sol"";
import {ScalingPriceOracle} from ""./../oracle/ScalingPriceOracle.sol"";

/// @notice Testing contract that allows for updates without mocking chainlink calls
contract MockScalingPriceOracle is ScalingPriceOracle {
    constructor(
        address _oracle,
        bytes32 _jobid,
        uint256 _fee,
        uint128 _currentMonth,
        uint128 _previousMonth
    )
        ScalingPriceOracle(_oracle, _jobid, _fee, _currentMonth, _previousMonth)
    {}

    function fulfill(uint256 _cpiData) external {
        _updateCPIData(_cpiData);
    }
}",163
RealWorld_TA_102_MockCoreRef_RealWorld_20240812165855.log,102,MockCoreRef,30519,1406,31925,70.0,0.180715,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""../refs/CoreRef.sol"";

contract MockCoreRef is CoreRef {
    constructor(address core) CoreRef(core) {
        _setContractAdminRole(keccak256(""MOCK_CORE_REF_ADMIN""));
    }

    function testMinter() public view onlyMinter {}

    function testBurner() public view onlyBurner {}

    function testPCVController() public view onlyPCVController {}

    function testGovernor() public view onlyGovernor {}

    function testGuardian() public view onlyGuardianOrGovernor {}

    function testOnlyGovernorOrAdmin() public view onlyGovernorOrAdmin {}
}",150
RealWorld_TA_102_OraclePassThrough.t_RealWorld_20240812164540.log,102,OraclePassThrough.t,80295,2374,82669,85.0,0.448955,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {Vm} from ""./../utils/Vm.sol"";
import {DSTest} from ""./../utils/DSTest.sol"";
import {getCore, getAddresses, FeiTestAddresses} from ""./../utils/Fixtures.sol"";
import {MockScalingPriceOracle} from ""../../../mock/MockScalingPriceOracle.sol"";
import {OraclePassThrough} from ""../../../oracle/OraclePassThrough.sol"";
import {ScalingPriceOracle} from ""../../../oracle/ScalingPriceOracle.sol"";
import {Decimal} from ""./../../../external/Decimal.sol"";

contract OraclePassThroughTest is DSTest {
    using Decimal for Decimal.D256;

    MockScalingPriceOracle private scalingPriceOracle;

    OraclePassThrough private oraclePassThrough;

    /// @notice increase price by 3.09% per month
    int256 public constant monthlyChangeRateBasisPoints = 309;

    /// @notice the current month's CPI data
    uint128 public constant currentMonth = 270000;

    /// @notice the previous month's CPI data
    uint128 public constant previousMonth = 261900;

    /// @notice address of chainlink oracle to send request
    address public immutable oracle = address(0);

    /// @notice job id that retrieves the latest CPI data
    bytes32 public immutable jobId =
        keccak256(abi.encodePacked(""Chainlink CPI-U job""));

    /// @notice fee of 10 link
    uint256 public immutable fee = 1e19;

    Vm public constant vm = Vm(HEVM_ADDRESS);
    FeiTestAddresses public addresses = getAddresses();

    function setUp() public {
        /// warp to 1 to set isTimeStarted to true
        vm.warp(1);

        scalingPriceOracle = new MockScalingPriceOracle(
            oracle,
            jobId,
            fee,
            currentMonth,
            previousMonth
        );

        oraclePassThrough = new OraclePassThrough(
            ScalingPriceOracle(address(scalingPriceOracle))
        );
    }

    function testSetup() public {
        assertEq(
            address(oraclePassThrough.scalingPriceOracle()),
            address(scalingPriceOracle)
        );
        assertEq(oraclePassThrough.owner(), address(this));
    }

    function testDataPassThroughSync() public {
        assertEq(
            oraclePassThrough.getCurrentOraclePrice(),
            scalingPriceOracle.getCurrentOraclePrice()
        );

        (Decimal.D256 memory oPrice, bool oValid) = oraclePassThrough.read();
        assertEq(oPrice.value, scalingPriceOracle.getCurrentOraclePrice());
        assertTrue(oValid);
    }

    function testUpdateScalingPriceOracleFailureNotGovernor() public {
        vm.startPrank(address(0));
        vm.expectRevert(bytes(""Ownable: caller is not the owner""));

        oraclePassThrough.updateScalingPriceOracle(
            ScalingPriceOracle(address(scalingPriceOracle))
        );
        vm.stopPrank();
    }

    function testUpdateScalingPriceOracleSuccess() public {
        ScalingPriceOracle newScalingPriceOracle = ScalingPriceOracle(
            address(
                new MockScalingPriceOracle(
                    oracle,
                    jobId,
                    fee,
                    currentMonth,
                    previousMonth
                )
            )
        );

        oraclePassThrough.updateScalingPriceOracle(newScalingPriceOracle);

        /// assert that scaling price oracle was updated to new contract
        assertEq(
            address(newScalingPriceOracle),
            address(oraclePassThrough.scalingPriceOracle())
        );
    }
}",724
RealWorld_TA_102_IVoltTimedMinter_RealWorld_20240812175214.log,102,IVoltTimedMinter,38195,1945,40140,86.0,0.229875,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/// @title a Fei Timed Minter
/// @author Fei Protocol
interface IVoltTimedMinter {
    // ----------- Events -----------

    event FeiMinting(address indexed caller, uint256 feiAmount);

    event TargetUpdate(address oldTarget, address newTarget);

    event MintAmountUpdate(uint256 oldMintAmount, uint256 newMintAmount);

    // ----------- State changing api -----------

    function mint() external;

    // ----------- Governor only state changing api -----------

    function setTarget(address newTarget) external;

    // ----------- Governor or Admin only state changing api -----------

    function setFrequency(uint256 newFrequency) external;

    function setMintAmount(uint256 newMintAmount) external;

    // ----------- Getters -----------

    function mintAmount() external view returns (uint256);

    function MIN_MINT_FREQUENCY() external view returns (uint256);

    function MAX_MINT_FREQUENCY() external view returns (uint256);

    function target() external view returns (address);
}",226
RealWorld_TA_102_RateLimitedMinter_RealWorld_20240812175059.log,102,RateLimitedMinter,37309,1547,38856,73.0,0.217485,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""../../utils/RateLimited.sol"";

/// @title abstract contract for putting a rate limit on how fast a contract can mint FEI
/// @author Fei Protocol
abstract contract RateLimitedMinter is RateLimited {
    uint256 private constant MAX_FEI_LIMIT_PER_SECOND = 10_000e18; // 10000 volt/s or ~860m volt/day

    constructor(
        uint256 _feiLimitPerSecond,
        uint256 _mintingBufferCap,
        bool _doPartialMint
    )
        RateLimited(
            MAX_FEI_LIMIT_PER_SECOND,
            _feiLimitPerSecond,
            _mintingBufferCap,
            _doPartialMint
        )
    {}

    /// @notice override the FEI minting behavior to enforce a rate limit
    function _mintVolt(address to, uint256 amount) internal virtual override {
        uint256 mintAmount = _depleteBuffer(amount);
        super._mintVolt(to, mintAmount);
    }
}",228
RealWorld_TA_102_Deviation.t_RealWorld_20240812164935.log,102,Deviation.t,53229,1778,55007,75.0,0.301705,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {Vm} from ""./../utils/Vm.sol"";
import ""./../utils/DSTest.sol"";
import {Constants} from ""./../../../Constants.sol"";
import {Deviation} from ""./../../../utils/Deviation.sol"";
import {getCore, getAddresses, FeiTestAddresses} from ""./../utils/Fixtures.sol"";
import {SafeCast} from ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import {SafeMath} from ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract DeviationTest is DSTest {
    using SafeCast for *;
    using Deviation for *;

    uint256 maxDeviationThresholdBasisPoints = 10_000;

    Vm public constant vm = Vm(HEVM_ADDRESS);
    FeiTestAddresses public addresses = getAddresses();

    function testDeviation() public {
        int256 x = 275000;
        int256 y = 270000;

        int256 delta = x - y;
        uint256 absDeviation = delta.toUint256();

        uint256 basisPoints = (absDeviation *
            Constants.BASIS_POINTS_GRANULARITY) / x.toUint256();

        assertEq(
            basisPoints,
            Deviation.calculateDeviationThresholdBasisPoints(x, y)
        );
    }

    function testWithinDeviation() public {
        int256 x = 275000;
        int256 y = 270000;

        assertTrue(
            maxDeviationThresholdBasisPoints.isWithinDeviationThreshold(x, y)
        );
    }

    function testWithinDeviationFuzz(int128 x, int128 y) public view {
        maxDeviationThresholdBasisPoints.isWithinDeviationThreshold(x, y);
    }

    function testOutsideDeviation() public {
        int256 x = 275000;
        int256 y = 577500;

        assertTrue(
            !maxDeviationThresholdBasisPoints.isWithinDeviationThreshold(x, y)
        );
    }
}",434
RealWorld_TA_102_IOracleRef_RealWorld_20240812174302.log,102,IOracleRef,44368,2076,46444,80.0,0.26336,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""../oracle/IOracle.sol"";

/// @title OracleRef interface
/// @author Fei Protocol
interface IOracleRef {
    // ----------- Events -----------

    event OracleUpdate(address indexed oldOracle, address indexed newOracle);

    event InvertUpdate(bool oldDoInvert, bool newDoInvert);

    event DecimalsNormalizerUpdate(
        int256 oldDecimalsNormalizer,
        int256 newDecimalsNormalizer
    );

    event BackupOracleUpdate(
        address indexed oldBackupOracle,
        address indexed newBackupOracle
    );

    // ----------- State changing API -----------

    function updateOracle() external;

    // ----------- Governor only state changing API -----------

    function setOracle(address newOracle) external;

    function setBackupOracle(address newBackupOracle) external;

    function setDecimalsNormalizer(int256 newDecimalsNormalizer) external;

    function setDoInvert(bool newDoInvert) external;

    // ----------- Getters -----------

    function oracle() external view returns (IOracle);

    function backupOracle() external view returns (IOracle);

    function doInvert() external view returns (bool);

    function decimalsNormalizer() external view returns (int256);

    function readOracle() external view returns (Decimal.D256 memory);

    function invert(Decimal.D256 calldata price)
        external
        pure
        returns (Decimal.D256 memory);
}",309
RealWorld_TA_102_ICoreRef_RealWorld_20240812174615.log,102,ICoreRef,39302,1606,40908,77.0,0.22863,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""../core/ICore.sol"";

/// @title CoreRef interface
/// @author Fei Protocol
interface ICoreRef {
    // ----------- Events -----------

    event CoreUpdate(address indexed oldCore, address indexed newCore);

    event ContractAdminRoleUpdate(
        bytes32 indexed oldContractAdminRole,
        bytes32 indexed newContractAdminRole
    );

    // ----------- Governor only state changing api -----------

    function setContractAdminRole(bytes32 newContractAdminRole) external;

    // ----------- Governor or Guardian only state changing api -----------

    function pause() external;

    function unpause() external;

    // ----------- Getters -----------

    function core() external view returns (ICore);

    function volt() external view returns (IVolt);

    function vcon() external view returns (IERC20);

    function voltBalance() external view returns (uint256);

    function vconBalance() external view returns (uint256);

    function CONTRACT_ADMIN_ROLE() external view returns (bytes32);

    function isContractAdmin(address admin) external view returns (bool);
}",242
RealWorld_TA_102_ERC20CompoundPCVDeposit_RealWorld_20240812173805.log,102,ERC20CompoundPCVDeposit,48923,2445,51368,78.0,0.293515,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import ""./CompoundPCVDepositBase.sol"";

interface CErc20 {
    function mint(uint256 amount) external returns (uint256);

    function underlying() external returns (address);
}

/// @title ERC-20 implementation for a Compound PCV Deposit
/// @author Fei Protocol
contract ERC20CompoundPCVDeposit is CompoundPCVDepositBase {
    /// @notice the token underlying the cToken
    IERC20 public token;

    /// @notice Compound ERC20 PCV Deposit constructor
    /// @param _core Fei Core for reference
    /// @param _cToken Compound cToken to deposit
    constructor(address _core, address _cToken)
        CompoundPCVDepositBase(_core, _cToken)
    {
        token = IERC20(CErc20(_cToken).underlying());
    }

    /// @notice deposit ERC-20 tokens to Compound
    function deposit() external override whenNotPaused {
        uint256 amount = token.balanceOf(address(this));

        token.approve(address(cToken), amount);

        // Compound returns non-zero when there is an error
        require(
            CErc20(address(cToken)).mint(amount) == 0,
            ""ERC20CompoundPCVDeposit: deposit error""
        );

        emit Deposit(msg.sender, amount);
    }

    function _transferUnderlying(address to, uint256 amount) internal override {
        SafeERC20.safeTransfer(token, to, amount);
    }

    /// @notice display the related token of the balance reported
    function balanceReportedIn() public view override returns (address) {
        return address(token);
    }
}",358
RealWorld_TA_102_BokkyPooBahsDateTimeContract_RealWorld_20240812175658.log,102,BokkyPooBahsDateTimeContract,239441,1248,240689,84.0,1.222165,"// SPDX-License-Identifier: GNU Lesser General Public License 3.0
pragma solidity ^0.8.4;

// ----------------------------------------------------------------------------
// BokkyPooBah's DateTime Library v1.00 - Contract Instance
//
// A gas-efficient Solidity date and time library
//
// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary
//
// Tested date range 1970/01/01 to 2345/12/31
//
// Conventions:
// Unit      | Range         | Notes
// :-------- |:-------------:|:-----
// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC
// year      | 1970 ... 2345 |
// month     | 1 ... 12      |
// day       | 1 ... 31      |
// hour      | 0 ... 23      |
// minute    | 0 ... 59      |
// second    | 0 ... 59      |
// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday
//
//
// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018.
//
// GNU Lesser General Public License 3.0
// https://www.gnu.org/licenses/lgpl-3.0.en.html
// ----------------------------------------------------------------------------

import ""./BokkyPooBahsDateTimeLibrary.sol"";

contract BokkyPooBahsDateTimeContract {
    uint256 public constant SECONDS_PER_DAY = 24 * 60 * 60;
    uint256 public constant SECONDS_PER_HOUR = 60 * 60;
    uint256 public constant SECONDS_PER_MINUTE = 60;
    int256 public constant OFFSET19700101 = 2440588;

    uint256 public constant DOW_MON = 1;
    uint256 public constant DOW_TUE = 2;
    uint256 public constant DOW_WED = 3;
    uint256 public constant DOW_THU = 4;
    uint256 public constant DOW_FRI = 5;
    uint256 public constant DOW_SAT = 6;
    uint256 public constant DOW_SUN = 7;

    function _now() public view returns (uint256 timestamp) {
        timestamp = block.timestamp;
    }

    function _nowDateTime()
        public
        view
        returns (
            uint256 year,
            uint256 month,
            uint256 day,
            uint256 hour,
            uint256 minute,
            uint256 second
        )
    {
        (year, month, day, hour, minute, second) = BokkyPooBahsDateTimeLibrary
            .timestampToDateTime(block.timestamp);
    }

    function _daysFromDate(
        uint256 year,
        uint256 month,
        uint256 day
    ) public pure returns (uint256 _days) {
        return BokkyPooBahsDateTimeLibrary._daysFromDate(year, month, day);
    }

    function _daysToDate(uint256 _days)
        public
        pure
        returns (
            uint256 year,
            uint256 month,
            uint256 day
        )
    {
        return BokkyPooBahsDateTimeLibrary._daysToDate(_days);
    }

    function timestampFromDate(
        uint256 year,
        uint256 month,
        uint256 day
    ) public pure returns (uint256 timestamp) {
        return BokkyPooBahsDateTimeLibrary.timestampFromDate(year, month, day);
    }

    function timestampFromDateTime(
        uint256 year,
        uint256 month,
        uint256 day,
        uint256 hour,
        uint256 minute,
        uint256 second
    ) public pure returns (uint256 timestamp) {
        return
            BokkyPooBahsDateTimeLibrary.timestampFromDateTime(
                year,
                month,
                day,
                hour,
                minute,
                second
            );
    }

    function timestampToDate(uint256 timestamp)
        public
        pure
        returns (
            uint256 year,
            uint256 month,
            uint256 day
        )
    {
        (year, month, day) = BokkyPooBahsDateTimeLibrary.timestampToDate(
            timestamp
        );
    }

    function timestampToDateTime(uint256 timestamp)
        public
        pure
        returns (
            uint256 year,
            uint256 month,
            uint256 day,
            uint256 hour,
            uint256 minute,
            uint256 second
        )
    {
        (year, month, day, hour, minute, second) = BokkyPooBahsDateTimeLibrary
            .timestampToDateTime(timestamp);
    }

    function isValidDate(
        uint256 year,
        uint256 month,
        uint256 day
    ) public pure returns (bool valid) {
        valid = BokkyPooBahsDateTimeLibrary.isValidDate(year, month, day);
    }

    function isValidDateTime(
        uint256 year,
        uint256 month,
        uint256 day,
        uint256 hour,
        uint256 minute,
        uint256 second
    ) public pure returns (bool valid) {
        valid = BokkyPooBahsDateTimeLibrary.isValidDateTime(
            year,
            month,
            day,
            hour,
            minute,
            second
        );
    }

    function isLeapYear(uint256 timestamp) public pure returns (bool leapYear) {
        leapYear = BokkyPooBahsDateTimeLibrary.isLeapYear(timestamp);
    }

    function _isLeapYear(uint256 year) public pure returns (bool leapYear) {
        leapYear = BokkyPooBahsDateTimeLibrary._isLeapYear(year);
    }

    function isWeekDay(uint256 timestamp) public pure returns (bool weekDay) {
        weekDay = BokkyPooBahsDateTimeLibrary.isWeekDay(timestamp);
    }

    function isWeekEnd(uint256 timestamp) public pure returns (bool weekEnd) {
        weekEnd = BokkyPooBahsDateTimeLibrary.isWeekEnd(timestamp);
    }

    function getDaysInMonth(uint256 timestamp)
        public
        pure
        returns (uint256 daysInMonth)
    {
        daysInMonth = BokkyPooBahsDateTimeLibrary.getDaysInMonth(timestamp);
    }

    function _getDaysInMonth(uint256 year, uint256 month)
        public
        pure
        returns (uint256 daysInMonth)
    {
        daysInMonth = BokkyPooBahsDateTimeLibrary._getDaysInMonth(year, month);
    }

    function getDayOfWeek(uint256 timestamp)
        public
        pure
        returns (uint256 dayOfWeek)
    {
        dayOfWeek = BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp);
    }

    function getYear(uint256 timestamp) public pure returns (uint256 year) {
        year = BokkyPooBahsDateTimeLibrary.getYear(timestamp);
    }

    function getMonth(uint256 timestamp) public pure returns (uint256 month) {
        month = BokkyPooBahsDateTimeLibrary.getMonth(timestamp);
    }

    function getDay(uint256 timestamp) public pure returns (uint256 day) {
        day = BokkyPooBahsDateTimeLibrary.getDay(timestamp);
    }

    function getHour(uint256 timestamp) public pure returns (uint256 hour) {
        hour = BokkyPooBahsDateTimeLibrary.getHour(timestamp);
    }

    function getMinute(uint256 timestamp) public pure returns (uint256 minute) {
        minute = BokkyPooBahsDateTimeLibrary.getMinute(timestamp);
    }

    function getSecond(uint256 timestamp) public pure returns (uint256 second) {
        second = BokkyPooBahsDateTimeLibrary.getSecond(timestamp);
    }

    function addYears(uint256 timestamp, uint256 _years)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.addYears(timestamp, _years);
    }

    function addMonths(uint256 timestamp, uint256 _months)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.addMonths(
            timestamp,
            _months
        );
    }

    function addDays(uint256 timestamp, uint256 _days)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.addDays(timestamp, _days);
    }

    function addHours(uint256 timestamp, uint256 _hours)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.addHours(timestamp, _hours);
    }

    function addMinutes(uint256 timestamp, uint256 _minutes)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.addMinutes(
            timestamp,
            _minutes
        );
    }

    function addSeconds(uint256 timestamp, uint256 _seconds)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.addSeconds(
            timestamp,
            _seconds
        );
    }

    function subYears(uint256 timestamp, uint256 _years)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.subYears(timestamp, _years);
    }

    function subMonths(uint256 timestamp, uint256 _months)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.subMonths(
            timestamp,
            _months
        );
    }

    function subDays(uint256 timestamp, uint256 _days)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.subDays(timestamp, _days);
    }

    function subHours(uint256 timestamp, uint256 _hours)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.subHours(timestamp, _hours);
    }

    function subMinutes(uint256 timestamp, uint256 _minutes)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.subMinutes(
            timestamp,
            _minutes
        );
    }

    function subSeconds(uint256 timestamp, uint256 _seconds)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.subSeconds(
            timestamp,
            _seconds
        );
    }

    function diffYears(uint256 fromTimestamp, uint256 toTimestamp)
        public
        pure
        returns (uint256 _years)
    {
        _years = BokkyPooBahsDateTimeLibrary.diffYears(
            fromTimestamp,
            toTimestamp
        );
    }

    function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)
        public
        pure
        returns (uint256 _months)
    {
        _months = BokkyPooBahsDateTimeLibrary.diffMonths(
            fromTimestamp,
            toTimestamp
        );
    }

    function diffDays(uint256 fromTimestamp, uint256 toTimestamp)
        public
        pure
        returns (uint256 _days)
    {
        _days = BokkyPooBahsDateTimeLibrary.diffDays(
            fromTimestamp,
            toTimestamp
        );
    }

    function diffHours(uint256 fromTimestamp, uint256 toTimestamp)
        public
        pure
        returns (uint256 _hours)
    {
        _hours = BokkyPooBahsDateTimeLibrary.diffHours(
            fromTimestamp,
            toTimestamp
        );
    }

    function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)
        public
        pure
        returns (uint256 _minutes)
    {
        _minutes = BokkyPooBahsDateTimeLibrary.diffMinutes(
            fromTimestamp,
            toTimestamp
        );
    }

    function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)
        public
        pure
        returns (uint256 _seconds)
    {
        _seconds = BokkyPooBahsDateTimeLibrary.diffSeconds(
            fromTimestamp,
            toTimestamp
        );
    }
}",2617
RealWorld_TA_102_MockMinter_RealWorld_20240812165728.log,102,MockMinter,31310,2932,34242,85.0,0.21519,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""./../utils/GlobalRateLimitedMinter.sol"";

contract MockMinter {
    GlobalRateLimitedMinter globalRateLimitedMinter;

    constructor(GlobalRateLimitedMinter _globalRateLimitedMinter) {
        globalRateLimitedMinter = _globalRateLimitedMinter;
    }

    function mintFei(address to, uint256 amount) external {
        globalRateLimitedMinter.mintVolt(to, amount);
    }

    function mintAllFei(address to) external {
        globalRateLimitedMinter.mintMaxAllowableVolt(to);
    }
}",140
RealWorld_TA_102_IPermissionsRead_RealWorld_20240812163459.log,102,IPermissionsRead,28761,1237,29998,65.0,0.168545,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

/// @title Permissions Read interface
/// @author Fei Protocol
interface IPermissionsRead {
    // ----------- Getters -----------

    function isBurner(address _address) external view returns (bool);

    function isMinter(address _address) external view returns (bool);

    function isGovernor(address _address) external view returns (bool);

    function isGuardian(address _address) external view returns (bool);

    function isPCVController(address _address) external view returns (bool);
}",126
RealWorld_TA_102_Deviation_RealWorld_20240812172012.log,102,Deviation,44751,2230,46981,86.0,0.268355,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {Constants} from ""./../Constants.sol"";
import {SafeCast} from ""@openzeppelin/contracts/utils/math/SafeCast.sol"";

/// @title contract that determines whether or not a new value is within
/// an acceptable deviation threshold
/// @author Elliot Friedman, FEI Protocol
library Deviation {
    using SafeCast for *;

    /// @notice event that is emitted when the threshold is changed
    event DeviationThresholdUpdate(uint256 oldThreshold, uint256 newThreshold);

    /// @notice return the percent deviation between a and b in basis points terms
    function calculateDeviationThresholdBasisPoints(int256 a, int256 b)
        internal
        pure
        returns (uint256)
    {
        int256 delta = a - b;
        int256 basisPoints = (delta * Constants.BP_INT) / a;

        return (basisPoints < 0 ? basisPoints * -1 : basisPoints).toUint256();
    }

    /// @notice function to return whether or not the new price is within
    /// the acceptable deviation threshold
    function isWithinDeviationThreshold(
        uint256 maxDeviationThresholdBasisPoints,
        int256 oldValue,
        int256 newValue
    ) internal pure returns (bool) {
        return
            maxDeviationThresholdBasisPoints >=
            calculateDeviationThresholdBasisPoints(oldValue, newValue);
    }
}",312
RealWorld_TA_102_INonCustodialPSM_RealWorld_20240812172909.log,102,INonCustodialPSM,127877,2759,130636,140.0,0.694565,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {IPCVDeposit} from ""../pcv/IPCVDeposit.sol"";
import {GlobalRateLimitedMinter} from ""../utils/GlobalRateLimitedMinter.sol"";

/**
 * @title Fei Peg Stability Module
 * @author Fei Protocol
 * @notice  The Fei PSM is a contract which pulls reserve assets from PCV Deposits in order to exchange FEI at $1 of underlying assets with a fee.
 * `mint()` - buy FEI for $1 of underlying tokens
 * `redeem()` - sell FEI back for $1 of the same
 *
 *
 * The contract is a
 * OracleRef - to determine price of underlying, and
 * RateLimitedReplenishable - to stop infinite mints and related DOS issues
 *
 * Inspired by MakerDAO PSM, code written without reference
 */
interface INonCustodialPSM {
    // ----------- Public State Changing API -----------

    /// @notice mint `amountFeiOut` FEI to address `to` for `amountIn` underlying tokens
    /// @dev see getMintAmountOut() to pre-calculate amount out
    function mint(
        address to,
        uint256 amountIn,
        uint256 minAmountOut
    ) external returns (uint256 amountFeiOut);

    /// @notice redeem `amountFeiIn` FEI for `amountOut` underlying tokens and send to address `to`
    /// @dev see getRedeemAmountOut() to pre-calculate amount out
    function redeem(
        address to,
        uint256 amountFeiIn,
        uint256 minAmountOut
    ) external returns (uint256 amountOut);

    // ----------- Governor or Admin Only State Changing API -----------

    /// @notice set the mint fee vs oracle price in basis point terms
    function setMintFee(uint256 newMintFeeBasisPoints) external;

    /// @notice set the redemption fee vs oracle price in basis point terms
    function setRedeemFee(uint256 newRedeemFeeBasisPoints) external;

    /// @notice set the target for sending surplus reserves
    function setPCVDeposit(IPCVDeposit newTarget) external;

    /// @notice set the target to call for FEI minting
    function setGlobalRateLimitedMinter(GlobalRateLimitedMinter newMinter)
        external;

    /// @notice withdraw ERC20 from the contract
    function withdrawERC20(
        address token,
        address to,
        uint256 amount
    ) external;

    // ----------- Getters -----------

    /// @notice calculate the amount of FEI out for a given `amountIn` of underlying
    function getMintAmountOut(uint256 amountIn)
        external
        view
        returns (uint256 amountFeiOut);

    /// @notice calculate the amount of underlying out for a given `amountFeiIn` of FEI
    function getRedeemAmountOut(uint256 amountFeiIn)
        external
        view
        returns (uint256 amountOut);

    /// @notice the maximum mint amount out
    function getMaxMintAmountOut() external view returns (uint256);

    /// @notice the mint fee vs oracle price in basis point terms
    function mintFeeBasisPoints() external view returns (uint256);

    /// @notice the redemption fee vs oracle price in basis point terms
    function redeemFeeBasisPoints() external view returns (uint256);

    /// @notice the underlying token exchanged for FEI
    function underlyingToken() external view returns (IERC20);

    /// @notice the PCV deposit target to deposit and withdraw from
    function pcvDeposit() external view returns (IPCVDeposit);

    /// @notice Rate Limited Minter contract that will be called when FEI needs to be minted
    function rateLimitedMinter()
        external
        view
        returns (GlobalRateLimitedMinter);

    /// @notice the max mint and redeem fee in basis points
    function MAX_FEE() external view returns (uint256);

    // ----------- Events -----------

    /// @notice event emitted when a new max fee is set
    event MaxFeeUpdate(uint256 oldMaxFee, uint256 newMaxFee);

    /// @notice event emitted when a new mint fee is set
    event MintFeeUpdate(uint256 oldMintFee, uint256 newMintFee);

    /// @notice event emitted when a new redeem fee is set
    event RedeemFeeUpdate(uint256 oldRedeemFee, uint256 newRedeemFee);

    /// @notice event emitted when reservesThreshold is updated
    event ReservesThresholdUpdate(
        uint256 oldReservesThreshold,
        uint256 newReservesThreshold
    );

    /// @notice event emitted when surplus target is updated
    event PCVDepositUpdate(IPCVDeposit oldTarget, IPCVDeposit newTarget);

    /// @notice event emitted upon a redemption
    event Redeem(address to, uint256 amountFeiIn, uint256 amountAssetOut);

    /// @notice event emitted when fei gets minted
    event Mint(address to, uint256 amountIn, uint256 amountFeiOut);

    /// @notice event emitted when ERC20 tokens get withdrawn
    event WithdrawERC20(
        address indexed _caller,
        address indexed _token,
        address indexed _to,
        uint256 _amount
    );

    /// @notice event emitted when global rate limited minter is updated
    event GlobalRateLimitedMinterUpdate(
        GlobalRateLimitedMinter oldMinter,
        GlobalRateLimitedMinter newMinter
    );

    /// @notice event that is emitted when redemptions are paused
    event RedemptionsPaused(address account);

    /// @notice event that is emitted when redemptions are unpaused
    event RedemptionsUnpaused(address account);

    /// @notice event that is emitted when minting is paused
    event MintingPaused(address account);

    /// @notice event that is emitted when minting is unpaused
    event MintingUnpaused(address account);
}",1310
RealWorld_TA_102_IOraclePassThrough_RealWorld_20240812171738.log,102,IOraclePassThrough,42247,1786,44033,75.0,0.246955,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {Decimal} from ""../external/Decimal.sol"";
import {IScalingPriceOracle} from ""./IScalingPriceOracle.sol"";

/// @notice interface to get data from the Scaling Price Oracle
interface IOraclePassThrough {
    // ----------- Getters -----------

    /// @notice reference to the scaling price oracle
    function scalingPriceOracle() external view returns (IScalingPriceOracle);

    /// @notice function to get the current oracle price for the OracleRef contract
    function read()
        external
        view
        returns (Decimal.D256 memory price, bool valid);

    /// @notice function to get the current oracle price for the entire system
    function getCurrentOraclePrice() external view returns (uint256);

    // ----------- Governor only state changing api -----------

    /// @notice function to update the pointer to the scaling price oracle
    /// requires approval from both VOLT and FRAX governance to sign off on the change
    function updateScalingPriceOracle(IScalingPriceOracle newScalingPriceOracle)
        external;

    /// @notice event emitted when the scaling price oracle is updated
    event ScalingPriceOracleUpdate(
        IScalingPriceOracle oldScalingPriceOracle,
        IScalingPriceOracle newScalingPriceOracle
    );
}",275
RealWorld_TA_102_MockPCVDepositV2_RealWorld_20240812170941.log,102,MockPCVDepositV2,58128,4591,62719,115.0,0.38246,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""../refs/CoreRef.sol"";
import ""../pcv/IPCVDeposit.sol"";

contract MockPCVDepositV2 is IPCVDeposit, CoreRef {
    address public override balanceReportedIn;

    uint256 private resistantBalance;
    uint256 private resistantProtocolOwnedFei;

    constructor(
        address _core,
        address _token,
        uint256 _resistantBalance,
        uint256 _resistantProtocolOwnedFei
    ) CoreRef(_core) {
        balanceReportedIn = _token;
        resistantBalance = _resistantBalance;
        resistantProtocolOwnedFei = _resistantProtocolOwnedFei;
    }

    receive() external payable {}

    function set(uint256 _resistantBalance, uint256 _resistantProtocolOwnedFei)
        public
    {
        resistantBalance = _resistantBalance;
        resistantProtocolOwnedFei = _resistantProtocolOwnedFei;
    }

    // gets the resistant token balance and protocol owned fei of this deposit
    function resistantBalanceAndVolt()
        external
        view
        override
        returns (uint256, uint256)
    {
        return (resistantBalance, resistantProtocolOwnedFei);
    }

    // IPCVDeposit V1
    function deposit() external override {
        resistantBalance = IERC20(balanceReportedIn).balanceOf(address(this));
    }

    function withdraw(address to, uint256 amount) external override {
        IERC20(balanceReportedIn).transfer(to, amount);
        resistantBalance = IERC20(balanceReportedIn).balanceOf(address(this));
    }

    function withdrawERC20(
        address token,
        address to,
        uint256 amount
    ) external override {
        IERC20(token).transfer(to, amount);
    }

    function withdrawETH(address payable to, uint256 amount)
        external
        override
        onlyPCVController
    {
        to.transfer(amount);
    }

    function balance() external view override returns (uint256) {
        return IERC20(balanceReportedIn).balanceOf(address(this));
    }
}",451
RealWorld_TA_102_ICore_RealWorld_20240812163110.log,102,ICore,29522,1263,30785,66.0,0.17287,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {IPermissions} from ""./IPermissions.sol"";
import {IVolt, IERC20} from ""../volt/IVolt.sol"";

/// @title Core Interface
/// @author Fei Protocol
interface ICore is IPermissions {
    // ----------- Events -----------
    event VoltUpdate(IERC20 indexed _volt);
    event VconUpdate(IERC20 indexed _vcon);

    // ----------- Getters -----------

    function volt() external view returns (IVolt);

    function vcon() external view returns (IERC20);
}",135
RealWorld_TA_102_IMultiRateLimited_RealWorld_20240812172140.log,102,IMultiRateLimited,66311,1774,68085,80.0,0.367035,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

/// @title interface for putting a rate limit on how fast a contract can perform an action, e.g. Minting
/// @author Fei Protocol
interface IMultiRateLimited {
    // ----------- Events -----------

    /// @notice emitted when a buffer is eaten into
    event IndividualBufferUsed(
        address rateLimitedAddress,
        uint256 amountUsed,
        uint256 bufferRemaining
    );

    /// @notice emitted when rate limit is updated
    event IndividualRateLimitPerSecondUpdate(
        address rateLimitedAddress,
        uint256 oldRateLimitPerSecond,
        uint256 newRateLimitPerSecond
    );

    /// @notice emitted when the non gov buffer cap max is updated
    event MultiBufferCapUpdate(uint256 oldBufferCap, uint256 newBufferCap);

    /// @notice emitted when the non gov buffer rate limit per second max is updated
    event MultiMaxRateLimitPerSecondUpdate(
        uint256 oldMaxRateLimitPerSecond,
        uint256 newMaxRateLimitPerSecond
    );

    // ----------- View API -----------

    /// @notice the rate per second for each address
    function getRateLimitPerSecond(address) external view returns (uint256);

    /// @notice the last time the buffer was used by each address
    function getLastBufferUsedTime(address) external view returns (uint256);

    /// @notice the cap of the buffer that can be used at once
    function getBufferCap(address) external view returns (uint256);

    /// @notice the amount of action that can be used before hitting limit
    /// @dev replenishes at rateLimitPerSecond per second up to bufferCap
    function individualBuffer(address) external view returns (uint112);

    // ----------- Governance State Changing API -----------

    /// @notice update the non gov max rate limit per second
    function updateMaxRateLimitPerSecond(uint256 newMaxRateLimitPerSecond)
        external;

    /// @notice update the non gov max buffer cap
    function updateMaxBufferCap(uint256 newBufferCap) external;

    /// @notice add an authorized contract, its per second replenishment and buffer set to the non governor caps
    function addAddressWithCaps(address) external;

    /// @notice add an authorized contract, its per second replenishment and buffer
    function addAddress(
        address,
        uint112,
        uint112
    ) external;

    /// @notice update an authorized contract
    function updateAddress(
        address,
        uint112,
        uint112
    ) external;

    /// @notice remove an authorized contract
    function removeAddress(address) external;
}",562
RealWorld_TA_102_IVolt_RealWorld_20240812174918.log,102,IVolt,38317,2575,40892,98.0,0.243085,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/// @title FEI stablecoin interface
/// @author Fei Protocol
interface IVolt is IERC20 {
    // ----------- Events -----------

    event Minting(
        address indexed _to,
        address indexed _minter,
        uint256 _amount
    );

    event Burning(
        address indexed _to,
        address indexed _burner,
        uint256 _amount
    );

    event IncentiveContractUpdate(
        address indexed _incentivized,
        address indexed _incentiveContract
    );

    // ----------- State changing api -----------

    function burn(uint256 amount) external;

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    // ----------- Minter only state changing api -----------

    function mint(address account, uint256 amount) external;
}",231
RealWorld_TA_102_IPermissions_RealWorld_20240812162948.log,102,IPermissions,43980,1967,45947,80.0,0.25924,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""./IPermissionsRead.sol"";

/// @title Permissions interface
/// @author Fei Protocol
interface IPermissions is IAccessControl, IPermissionsRead {
    // ----------- Governor only state changing api -----------

    function createRole(bytes32 role, bytes32 adminRole) external;

    function grantMinter(address minter) external;

    function grantBurner(address burner) external;

    function grantPCVController(address pcvController) external;

    function grantGovernor(address governor) external;

    function grantGuardian(address guardian) external;

    function revokeMinter(address minter) external;

    function revokeBurner(address burner) external;

    function revokePCVController(address pcvController) external;

    function revokeGovernor(address governor) external;

    function revokeGuardian(address guardian) external;

    // ----------- Revoker only state changing api -----------

    function revokeOverride(bytes32 role, address account) external;

    // ----------- Getters -----------

    function GUARDIAN_ROLE() external view returns (bytes32);

    function GOVERN_ROLE() external view returns (bytes32);

    function BURNER_ROLE() external view returns (bytes32);

    function MINTER_ROLE() external view returns (bytes32);

    function PCV_CONTROLLER_ROLE() external view returns (bytes32);
}",302
RealWorld_TA_102_CoreRef_RealWorld_20240812174107.log,102,CoreRef,140841,3069,143910,112.0,0.765585,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""./ICoreRef.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/// @title A Reference to Core
/// @author Fei Protocol
/// @notice defines some modifiers and utilities around interacting with Core
abstract contract CoreRef is ICoreRef, Pausable {
    ICore private immutable _core;
    IVolt private immutable _volt;
    IERC20 private immutable _vcon;

    /// @notice a role used with a subset of governor permissions for this contract only
    bytes32 public override CONTRACT_ADMIN_ROLE;

    constructor(address coreAddress) {
        _core = ICore(coreAddress);

        _volt = ICore(coreAddress).volt();
        _vcon = ICore(coreAddress).vcon();

        _setContractAdminRole(ICore(coreAddress).GOVERN_ROLE());
    }

    function _initialize() internal {} // no-op for backward compatibility

    modifier ifMinterSelf() {
        if (_core.isMinter(address(this))) {
            _;
        }
    }

    modifier onlyMinter() {
        require(_core.isMinter(msg.sender), ""CoreRef: Caller is not a minter"");
        _;
    }

    modifier onlyBurner() {
        require(_core.isBurner(msg.sender), ""CoreRef: Caller is not a burner"");
        _;
    }

    modifier onlyPCVController() {
        require(
            _core.isPCVController(msg.sender),
            ""CoreRef: Caller is not a PCV controller""
        );
        _;
    }

    modifier onlyGovernorOrAdmin() {
        require(
            _core.isGovernor(msg.sender) || isContractAdmin(msg.sender),
            ""CoreRef: Caller is not a governor or contract admin""
        );
        _;
    }

    modifier onlyGovernor() {
        require(
            _core.isGovernor(msg.sender),
            ""CoreRef: Caller is not a governor""
        );
        _;
    }

    modifier onlyGuardianOrGovernor() {
        require(
            _core.isGovernor(msg.sender) || _core.isGuardian(msg.sender),
            ""CoreRef: Caller is not a guardian or governor""
        );
        _;
    }

    modifier onlyGovernorOrGuardianOrAdmin() {
        require(
            _core.isGovernor(msg.sender) ||
                _core.isGuardian(msg.sender) ||
                isContractAdmin(msg.sender),
            ""CoreRef: Caller is not governor or guardian or admin""
        );
        _;
    }

    // Named onlyTribeRole to prevent collision with OZ onlyRole modifier
    modifier onlyTribeRole(bytes32 role) {
        require(_core.hasRole(role, msg.sender), ""UNAUTHORIZED"");
        _;
    }

    // Modifiers to allow any combination of roles
    modifier hasAnyOfTwoRoles(bytes32 role1, bytes32 role2) {
        require(
            _core.hasRole(role1, msg.sender) ||
                _core.hasRole(role2, msg.sender),
            ""UNAUTHORIZED""
        );
        _;
    }

    modifier hasAnyOfThreeRoles(
        bytes32 role1,
        bytes32 role2,
        bytes32 role3
    ) {
        require(
            _core.hasRole(role1, msg.sender) ||
                _core.hasRole(role2, msg.sender) ||
                _core.hasRole(role3, msg.sender),
            ""UNAUTHORIZED""
        );
        _;
    }

    modifier hasAnyOfFourRoles(
        bytes32 role1,
        bytes32 role2,
        bytes32 role3,
        bytes32 role4
    ) {
        require(
            _core.hasRole(role1, msg.sender) ||
                _core.hasRole(role2, msg.sender) ||
                _core.hasRole(role3, msg.sender) ||
                _core.hasRole(role4, msg.sender),
            ""UNAUTHORIZED""
        );
        _;
    }

    modifier hasAnyOfFiveRoles(
        bytes32 role1,
        bytes32 role2,
        bytes32 role3,
        bytes32 role4,
        bytes32 role5
    ) {
        require(
            _core.hasRole(role1, msg.sender) ||
                _core.hasRole(role2, msg.sender) ||
                _core.hasRole(role3, msg.sender) ||
                _core.hasRole(role4, msg.sender) ||
                _core.hasRole(role5, msg.sender),
            ""UNAUTHORIZED""
        );
        _;
    }

    modifier onlyVolt() {
        require(msg.sender == address(_volt), ""CoreRef: Caller is not VOLT"");
        _;
    }

    /// @notice sets a new admin role for this contract
    function setContractAdminRole(bytes32 newContractAdminRole)
        external
        override
        onlyGovernor
    {
        _setContractAdminRole(newContractAdminRole);
    }

    /// @notice returns whether a given address has the admin role for this contract
    function isContractAdmin(address _admin)
        public
        view
        override
        returns (bool)
    {
        return _core.hasRole(CONTRACT_ADMIN_ROLE, _admin);
    }

    /// @notice set pausable methods to paused
    function pause() public override onlyGuardianOrGovernor {
        _pause();
    }

    /// @notice set pausable methods to unpaused
    function unpause() public override onlyGuardianOrGovernor {
        _unpause();
    }

    /// @notice address of the Core contract referenced
    /// @return ICore implementation address
    function core() public view override returns (ICore) {
        return _core;
    }

    /// @notice address of the Fei contract referenced by Core
    /// @return IFei implementation address
    function volt() public view override returns (IVolt) {
        return _volt;
    }

    /// @notice address of the Tribe contract referenced by Core
    /// @return IERC20 implementation address
    function vcon() public view override returns (IERC20) {
        return _vcon;
    }

    /// @notice volt balance of contract
    /// @return volt amount held
    function voltBalance() public view override returns (uint256) {
        return _volt.balanceOf(address(this));
    }

    /// @notice vcon balance of contract
    /// @return vcon amount held
    function vconBalance() public view override returns (uint256) {
        return _vcon.balanceOf(address(this));
    }

    function _burnVoltHeld() internal {
        _volt.burn(voltBalance());
    }

    function _mintVolt(address to, uint256 amount) internal virtual {
        if (amount != 0) {
            _volt.mint(to, amount);
        }
    }

    function _setContractAdminRole(bytes32 newContractAdminRole) internal {
        bytes32 oldContractAdminRole = CONTRACT_ADMIN_ROLE;
        CONTRACT_ADMIN_ROLE = newContractAdminRole;
        emit ContractAdminRoleUpdate(
            oldContractAdminRole,
            newContractAdminRole
        );
    }
}",1487
RealWorld_TA_102_IPCVDeposit_RealWorld_20240812173529.log,102,IPCVDeposit,38463,2273,40736,82.0,0.237775,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""./IPCVDepositBalances.sol"";

/// @title a PCV Deposit interface
/// @author Fei Protocol
interface IPCVDeposit is IPCVDepositBalances {
    // ----------- Events -----------
    event Deposit(address indexed _from, uint256 _amount);

    event Withdrawal(
        address indexed _caller,
        address indexed _to,
        uint256 _amount
    );

    event WithdrawERC20(
        address indexed _caller,
        address indexed _token,
        address indexed _to,
        uint256 _amount
    );

    event WithdrawETH(
        address indexed _caller,
        address indexed _to,
        uint256 _amount
    );

    // ----------- State changing api -----------

    function deposit() external;

    // ----------- PCV Controller only state changing api -----------

    function withdraw(address to, uint256 amount) external;

    function withdrawERC20(
        address token,
        address to,
        uint256 amount
    ) external;

    function withdrawETH(address payable to, uint256 amount) external;
}",236
RealWorld_TA_102_Decimal_RealWorld_20240812175544.log,102,Decimal,127412,1418,128830,71.0,0.66542,"/*
    Copyright 2019 dYdX Trading Inc.
    Copyright 2020 Empty Set Squad <emptysetsquad@protonmail.com>
    Licensed under the Apache License, Version 2.0 (the ""License"");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an ""AS IS"" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

/**
 * @title Decimal
 * @author dYdX
 *
 * Library that defines a fixed-point number with 18 decimal places.
 */
library Decimal {
    using SafeMath for uint256;

    // ============ Constants ============

    uint256 private constant BASE = 10**18;

    // ============ Structs ============

    struct D256 {
        uint256 value;
    }

    // ============ Static Functions ============

    function zero() internal pure returns (D256 memory) {
        return D256({value: 0});
    }

    function one() internal pure returns (D256 memory) {
        return D256({value: BASE});
    }

    function from(uint256 a) internal pure returns (D256 memory) {
        return D256({value: a.mul(BASE)});
    }

    function ratio(uint256 a, uint256 b) internal pure returns (D256 memory) {
        return D256({value: getPartial(a, BASE, b)});
    }

    // ============ Self Functions ============

    function add(D256 memory self, uint256 b)
        internal
        pure
        returns (D256 memory)
    {
        return D256({value: self.value.add(b.mul(BASE))});
    }

    function sub(D256 memory self, uint256 b)
        internal
        pure
        returns (D256 memory)
    {
        return D256({value: self.value.sub(b.mul(BASE))});
    }

    function sub(
        D256 memory self,
        uint256 b,
        string memory reason
    ) internal pure returns (D256 memory) {
        return D256({value: self.value.sub(b.mul(BASE), reason)});
    }

    function mul(D256 memory self, uint256 b)
        internal
        pure
        returns (D256 memory)
    {
        return D256({value: self.value.mul(b)});
    }

    function div(D256 memory self, uint256 b)
        internal
        pure
        returns (D256 memory)
    {
        return D256({value: self.value.div(b)});
    }

    function pow(D256 memory self, uint256 b)
        internal
        pure
        returns (D256 memory)
    {
        if (b == 0) {
            return from(1);
        }

        D256 memory temp = D256({value: self.value});
        for (uint256 i = 1; i < b; i++) {
            temp = mul(temp, self);
        }

        return temp;
    }

    function add(D256 memory self, D256 memory b)
        internal
        pure
        returns (D256 memory)
    {
        return D256({value: self.value.add(b.value)});
    }

    function sub(D256 memory self, D256 memory b)
        internal
        pure
        returns (D256 memory)
    {
        return D256({value: self.value.sub(b.value)});
    }

    function sub(
        D256 memory self,
        D256 memory b,
        string memory reason
    ) internal pure returns (D256 memory) {
        return D256({value: self.value.sub(b.value, reason)});
    }

    function mul(D256 memory self, D256 memory b)
        internal
        pure
        returns (D256 memory)
    {
        return D256({value: getPartial(self.value, b.value, BASE)});
    }

    function div(D256 memory self, D256 memory b)
        internal
        pure
        returns (D256 memory)
    {
        return D256({value: getPartial(self.value, BASE, b.value)});
    }

    function equals(D256 memory self, D256 memory b)
        internal
        pure
        returns (bool)
    {
        return self.value == b.value;
    }

    function greaterThan(D256 memory self, D256 memory b)
        internal
        pure
        returns (bool)
    {
        return compareTo(self, b) == 2;
    }

    function lessThan(D256 memory self, D256 memory b)
        internal
        pure
        returns (bool)
    {
        return compareTo(self, b) == 0;
    }

    function greaterThanOrEqualTo(D256 memory self, D256 memory b)
        internal
        pure
        returns (bool)
    {
        return compareTo(self, b) > 0;
    }

    function lessThanOrEqualTo(D256 memory self, D256 memory b)
        internal
        pure
        returns (bool)
    {
        return compareTo(self, b) < 2;
    }

    function isZero(D256 memory self) internal pure returns (bool) {
        return self.value == 0;
    }

    function asUint256(D256 memory self) internal pure returns (uint256) {
        return self.value.div(BASE);
    }

    // ============ Core Methods ============

    function getPartial(
        uint256 target,
        uint256 numerator,
        uint256 denominator
    ) private pure returns (uint256) {
        return target.mul(numerator).div(denominator);
    }

    function compareTo(D256 memory a, D256 memory b)
        private
        pure
        returns (uint256)
    {
        if (a.value == b.value) {
            return 1;
        }
        return a.value > b.value ? 2 : 0;
    }
}",1288
RealWorld_TA_102_MockERC20_RealWorld_20240812170143.log,102,MockERC20,33319,2707,36026,87.0,0.220735,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MockERC20 is ERC20, ERC20Burnable {
    constructor() ERC20(""MockToken"", ""MCT"") {}

    function mint(address account, uint256 amount) public returns (bool) {
        _mint(account, amount);
        return true;
    }

    function mockBurn(address account, uint256 amount) public returns (bool) {
        _burn(account, amount);
        return true;
    }

    function approveOverride(
        address owner,
        address spender,
        uint256 amount
    ) public {
        _approve(owner, spender, amount);
    }
}",178
RealWorld_TA_102_Constants_RealWorld_20240812162840.log,102,Constants,42866,1158,44024,66.0,0.23749,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import {IWETH} from ""@uniswap/v2-periphery/contracts/interfaces/IWETH.sol"";

library Constants {
    /// @notice the denominator for basis points granularity (10,000)
    uint256 public constant BASIS_POINTS_GRANULARITY = 10_000;

    /// @notice the denominator for basis points granularity (10,000) expressed as an int data type
    int256 public constant BP_INT = int256(BASIS_POINTS_GRANULARITY);

    uint256 public constant ONE_YEAR = 365.25 days;

    int256 public constant ONE_YEAR_INT = int256(ONE_YEAR);

    /// @notice WETH9 address
    IWETH public constant WETH =
        IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

    /// @notice USD stand-in address
    address public constant USD = 0x1111111111111111111111111111111111111111;

    /// @notice Wei per ETH, i.e. 10**18
    uint256 public constant ETH_GRANULARITY = 1e18;

    /// @notice number of decimals in ETH, 18
    uint256 public constant ETH_DECIMALS = 18;
}",292
RealWorld_TA_102_PCVDeposit_RealWorld_20240812173348.log,102,PCVDeposit,51361,3077,54438,98.0,0.318345,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""../refs/CoreRef.sol"";
import ""./IPCVDeposit.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

/// @title abstract contract for withdrawing ERC-20 tokens using a PCV Controller
/// @author Fei Protocol
abstract contract PCVDeposit is IPCVDeposit, CoreRef {
    using SafeERC20 for IERC20;

    /// @notice withdraw ERC20 from the contract
    /// @param token address of the ERC20 to send
    /// @param to address destination of the ERC20
    /// @param amount quantity of ERC20 to send
    function withdrawERC20(
        address token,
        address to,
        uint256 amount
    ) public virtual override onlyPCVController {
        _withdrawERC20(token, to, amount);
    }

    function _withdrawERC20(
        address token,
        address to,
        uint256 amount
    ) internal {
        IERC20(token).safeTransfer(to, amount);
        emit WithdrawERC20(msg.sender, token, to, amount);
    }

    /// @notice withdraw ETH from the contract
    /// @param to address to send ETH
    /// @param amountOut amount of ETH to send
    function withdrawETH(address payable to, uint256 amountOut)
        external
        virtual
        override
        onlyPCVController
    {
        Address.sendValue(to, amountOut);
        emit WithdrawETH(msg.sender, to, amountOut);
    }

    function balance() public view virtual override returns (uint256);

    function resistantBalanceAndVolt()
        public
        view
        virtual
        override
        returns (uint256, uint256)
    {
        return (balance(), 0);
    }
}",383
RealWorld_TA_102_OraclePassThrough_RealWorld_20240812171138.log,102,OraclePassThrough,62463,2282,64745,76.0,0.357955,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {Decimal} from ""../external/Decimal.sol"";
import {CoreRef} from ""./../refs/CoreRef.sol"";
import {IScalingPriceOracle} from ""./IScalingPriceOracle.sol"";
import {IOraclePassThrough} from ""./IOraclePassThrough.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

/// @notice contract that passes all price calls to the Scaling Price Oracle
/// The Scaling Price Oracle can be changed if there is a decision to change how data is interpolated
/// without needing all contracts in the system to be upgraded, only this contract will have to change where it points
/// @author Elliot Friedman
contract OraclePassThrough is IOraclePassThrough, Ownable {
    using Decimal for Decimal.D256;

    /// @notice reference to the scaling price oracle
    IScalingPriceOracle public override scalingPriceOracle;

    constructor(IScalingPriceOracle _scalingPriceOracle) Ownable() {
        scalingPriceOracle = _scalingPriceOracle;
    }

    /// @notice updates the oracle price
    /// @dev no-op, ScalingPriceOracle is updated automatically
    /// added for backwards compatibility with OracleRef
    function update() public {}

    // ----------- Getters -----------

    /// @notice function to get the current oracle price for the OracleRef contract
    function read()
        external
        view
        override
        returns (Decimal.D256 memory price, bool valid)
    {
        uint256 currentPrice = scalingPriceOracle.getCurrentOraclePrice();

        price = Decimal.from(currentPrice).div(1e18);
        valid = true;
    }

    /// @notice function to get the current oracle price for the entire system
    function getCurrentOraclePrice() external view override returns (uint256) {
        return scalingPriceOracle.getCurrentOraclePrice();
    }

    // ----------- Governance only state changing api -----------

    /// @notice function to update the pointer to the scaling price oracle
    /// requires approval from all parties on multisig to update
    function updateScalingPriceOracle(IScalingPriceOracle newScalingPriceOracle)
        external
        override
        onlyOwner
    {
        IScalingPriceOracle oldScalingPriceOracle = scalingPriceOracle;
        scalingPriceOracle = newScalingPriceOracle;

        emit ScalingPriceOracleUpdate(
            oldScalingPriceOracle,
            newScalingPriceOracle
        );
    }
}",508
RealWorld_TA_102_IGlobalRateLimitedMinter_RealWorld_20240812172302.log,102,IGlobalRateLimitedMinter,38922,1800,40722,74.0,0.23061,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""./IMultiRateLimited.sol"";

/// @notice global contract to handle rate limited minting of VOLT on a global level
/// allows whitelisted minters to call in and specify the address to mint VOLT to within
/// the calling contract's limits
interface IGlobalRateLimitedMinter is IMultiRateLimited {
    /// @notice function that all VOLT minters call to mint VOLT
    /// pausable and depletes the msg.sender's buffer
    /// @param to the recipient address of the minted VOLT
    /// @param amount the amount of VOLT to mint
    function mintVolt(address to, uint256 amount) external;

    /// @notice mint VOLT to the target address and deplete the whole rate limited
    ///  minter's buffer, pausable and completely depletes the msg.sender's buffer
    /// @param to the recipient address of the minted VOLT
    /// mints all VOLT that msg.sender has in the buffer
    function mintMaxAllowableVolt(address to) external;
}",246
RealWorld_TA_102_Vm_RealWorld_20240812164825.log,102,Vm,89673,1278,90951,68.0,0.473925,"// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

interface Vm {
    // Set block.timestamp (newTimestamp)
    function warp(uint256) external;

    // Set block.height (newHeight)
    function roll(uint256) external;

    // Set block.basefee (newBasefee)
    function fee(uint256) external;

    // Loads a storage slot from an address (who, slot)
    function load(address, bytes32) external returns (bytes32);

    // Stores a value to an address' storage slot, (who, slot, value)
    function store(
        address,
        bytes32,
        bytes32
    ) external;

    // Signs data, (privateKey, digest) => (v, r, s)
    function sign(uint256, bytes32)
        external
        returns (
            uint8,
            bytes32,
            bytes32
        );

    // Gets address for a given private key, (privateKey) => (address)
    function addr(uint256) external returns (address);

    // Performs a foreign function call via terminal, (stringInputs) => (result)
    function ffi(string[] calldata) external returns (bytes memory);

    // Sets the *next* call's msg.sender to be the input address
    function prank(address) external;

    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called
    function startPrank(address) external;

    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input
    function prank(address, address) external;

    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input
    function startPrank(address, address) external;

    // Resets subsequent calls' msg.sender to be `address(this)`
    function stopPrank() external;

    // Sets an address' balance, (who, newBalance)
    function deal(address, uint256) external;

    // Sets an address' code, (who, newCode)
    function etch(address, bytes calldata) external;

    // Expects an error on next call
    function expectRevert(bytes calldata) external;

    function expectRevert(bytes4) external;

    // Record all storage reads and writes
    function record() external;

    // Gets all accessed reads and write slot from a recording session, for a given address
    function accesses(address)
        external
        returns (bytes32[] memory reads, bytes32[] memory writes);

    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).
    // Call this function, then emit an event, then call a function. Internally after the call, we check if
    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)
    function expectEmit(
        bool,
        bool,
        bool,
        bool
    ) external;

    // Mocks a call to an address, returning specified data.
    // Calldata can either be strict or a partial match, e.g. if you only
    // pass a Solidity selector to the expected calldata, then the entire Solidity
    // function will be mocked.
    function mockCall(
        address,
        bytes calldata,
        bytes calldata
    ) external;

    // Clears all mocked calls
    function clearMockedCalls() external;

    // Expect a call to an address with the specified calldata.
    // Calldata can either be strict or a partial match
    function expectCall(address, bytes calldata) external;

    // Gets the code from an artifact file. Takes in the relative path to the json file
    function getCode(string calldata) external returns (bytes memory);

    // Labels an address in call traces
    function label(address, string calldata) external;

    // If the condition is false, discard this run's fuzz inputs and generate new ones
    function assume(bool) external;
}",860
RealWorld_TA_102_Fixtures_RealWorld_20240812164708.log,102,Fixtures,58808,1565,60373,74.0,0.32534,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {Core, Vcon, Volt, IERC20} from ""../../../core/Core.sol"";
import {DSTest} from ""./DSTest.sol"";
import {Vm} from ""./Vm.sol"";

struct FeiTestAddresses {
    address userAddress;
    address secondUserAddress;
    address beneficiaryAddress1;
    address beneficiaryAddress2;
    address governorAddress;
    address genesisGroup;
    address keeperAddress;
    address pcvControllerAddress;
    address minterAddress;
    address burnerAddress;
    address guardianAddress;
}

/// @dev Get a list of addresses
function getAddresses() pure returns (FeiTestAddresses memory) {
    FeiTestAddresses memory addresses = FeiTestAddresses({
        userAddress: address(0x1),
        secondUserAddress: address(0x2),
        beneficiaryAddress1: address(0x3),
        beneficiaryAddress2: address(0x4),
        governorAddress: address(0x5),
        genesisGroup: address(0x6),
        keeperAddress: address(0x7),
        pcvControllerAddress: address(0x8),
        minterAddress: address(0x9),
        burnerAddress: address(0x10),
        guardianAddress: address(0x11)
    });

    return addresses;
}

/// @dev Deploy and configure Core
function getCore() returns (Core) {
    address HEVM_ADDRESS = address(
        bytes20(uint160(uint256(keccak256(""hevm cheat code""))))
    );
    Vm vm = Vm(HEVM_ADDRESS);
    FeiTestAddresses memory addresses = getAddresses();

    // Deploy Core from Governor address
    vm.startPrank(addresses.governorAddress);
    Core core = new Core();
    core.init();
    Vcon vcon = new Vcon(addresses.governorAddress, addresses.governorAddress);

    core.setVcon(IERC20(address(vcon)));
    core.grantMinter(addresses.minterAddress);
    core.grantBurner(addresses.burnerAddress);
    core.grantPCVController(addresses.pcvControllerAddress);
    core.grantGuardian(addresses.guardianAddress);

    vm.stopPrank();
    return core;
}",485
RealWorld_TA_102_CompoundPCVDepositBase_RealWorld_20240812173925.log,102,CompoundPCVDepositBase,60010,3419,63429,99.0,0.36843,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import ""../PCVDeposit.sol"";
import ""../../refs/CoreRef.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

interface CToken {
    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);

    function exchangeRateStored() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function isCToken() external view returns (bool);

    function isCEther() external view returns (bool);
}

/// @title base class for a Compound PCV Deposit
/// @author Fei Protocol
abstract contract CompoundPCVDepositBase is PCVDeposit {
    CToken public cToken;

    uint256 private constant EXCHANGE_RATE_SCALE = 1e18;

    /// @notice Compound PCV Deposit constructor
    /// @param _core Fei Core for reference
    /// @param _cToken Compound cToken to deposit
    constructor(address _core, address _cToken) CoreRef(_core) {
        cToken = CToken(_cToken);
        require(cToken.isCToken(), ""CompoundPCVDeposit: Not a cToken"");
    }

    /// @notice withdraw tokens from the PCV allocation
    /// @param amountUnderlying of tokens withdrawn
    /// @param to the address to send PCV to
    function withdraw(address to, uint256 amountUnderlying)
        external
        override
        onlyPCVController
        whenNotPaused
    {
        require(
            cToken.redeemUnderlying(amountUnderlying) == 0,
            ""CompoundPCVDeposit: redeem error""
        );
        _transferUnderlying(to, amountUnderlying);
        emit Withdrawal(msg.sender, to, amountUnderlying);
    }

    /// @notice returns total balance of PCV in the Deposit excluding the FEI
    /// @dev returns stale values from Compound if the market hasn't been updated
    function balance() public view override returns (uint256) {
        uint256 exchangeRate = cToken.exchangeRateStored();
        return
            (cToken.balanceOf(address(this)) * exchangeRate) /
            EXCHANGE_RATE_SCALE;
    }

    function _transferUnderlying(address to, uint256 amount) internal virtual;
}",489
RealWorld_TA_102_Core.t_RealWorld_20240812164034.log,102,Core.t,43892,1490,45382,71.0,0.24926,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import {IVolt} from ""../../../volt/Volt.sol"";
import {Volt} from ""../../../volt/Volt.sol"";
import {ICore} from ""../../../core/ICore.sol"";
import {Core} from ""../../../core/Core.sol"";
import {Vm} from ""./../utils/Vm.sol"";
import {DSTest} from ""./../utils/DSTest.sol"";
import {getCore, getAddresses, FeiTestAddresses} from ""./../utils/Fixtures.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";

contract CoreTest is DSTest {
    IVolt private volt;
    Core private core;

    Vm public constant vm = Vm(HEVM_ADDRESS);
    FeiTestAddresses public addresses = getAddresses();

    function setUp() public {
        core = getCore();

        volt = core.volt();
    }

    function testGovernorSetsVcon() public {
        vm.prank(addresses.governorAddress);
        core.setVcon(IERC20(addresses.userAddress));

        assertEq(address(core.vcon()), addresses.userAddress);
    }

    function testNonGovernorFailsSettingVcon() public {
        vm.expectRevert(""Permissions: Caller is not a governor"");
        core.setVcon(IERC20(addresses.userAddress));
    }
}",314
RealWorld_TA_102_RateLimited_RealWorld_20240812171855.log,102,RateLimited,112579,1436,114015,74.0,0.591615,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""../refs/CoreRef.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

/// @title abstract contract for putting a rate limit on how fast a contract can perform an action e.g. Minting
/// @author Fei Protocol
abstract contract RateLimited is CoreRef {
    /// @notice maximum rate limit per second governance can set for this contract
    uint256 public immutable MAX_RATE_LIMIT_PER_SECOND;

    /// @notice the rate per second for this contract
    uint256 public rateLimitPerSecond;

    /// @notice the last time the buffer was used by the contract
    uint256 public lastBufferUsedTime;

    /// @notice the cap of the buffer that can be used at once
    uint256 public bufferCap;

    /// @notice a flag for whether to allow partial actions to complete if the buffer is less than amount
    bool public doPartialAction;

    /// @notice the buffer at the timestamp of lastBufferUsedTime
    uint256 public bufferStored;

    event BufferUsed(uint256 amountUsed, uint256 bufferRemaining);
    event BufferCapUpdate(uint256 oldBufferCap, uint256 newBufferCap);
    event RateLimitPerSecondUpdate(
        uint256 oldRateLimitPerSecond,
        uint256 newRateLimitPerSecond
    );

    constructor(
        uint256 _maxRateLimitPerSecond,
        uint256 _rateLimitPerSecond,
        uint256 _bufferCap,
        bool _doPartialAction
    ) {
        lastBufferUsedTime = block.timestamp;

        _setBufferCap(_bufferCap);
        bufferStored = _bufferCap;

        require(
            _rateLimitPerSecond <= _maxRateLimitPerSecond,
            ""RateLimited: rateLimitPerSecond too high""
        );
        _setRateLimitPerSecond(_rateLimitPerSecond);

        MAX_RATE_LIMIT_PER_SECOND = _maxRateLimitPerSecond;
        doPartialAction = _doPartialAction;
    }

    /// @notice set the rate limit per second
    function setRateLimitPerSecond(uint256 newRateLimitPerSecond)
        external
        virtual
        onlyGovernorOrAdmin
    {
        require(
            newRateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,
            ""RateLimited: rateLimitPerSecond too high""
        );
        _updateBufferStored();

        _setRateLimitPerSecond(newRateLimitPerSecond);
    }

    /// @notice set the buffer cap
    function setBufferCap(uint256 newBufferCap)
        external
        virtual
        onlyGovernorOrAdmin
    {
        _setBufferCap(newBufferCap);
    }

    /// @notice the amount of action used before hitting limit
    /// @dev replenishes at rateLimitPerSecond per second up to bufferCap
    function buffer() public view returns (uint256) {
        uint256 elapsed = block.timestamp - lastBufferUsedTime;
        return
            Math.min(bufferStored + (rateLimitPerSecond * elapsed), bufferCap);
    }

    /** 
        @notice the method that enforces the rate limit. Decreases buffer by ""amount"". 
        If buffer is <= amount either
        1. Does a partial mint by the amount remaining in the buffer or
        2. Reverts
        Depending on whether doPartialAction is true or false
    */
    function _depleteBuffer(uint256 amount) internal virtual returns (uint256) {
        uint256 newBuffer = buffer();

        uint256 usedAmount = amount;
        if (doPartialAction && usedAmount > newBuffer) {
            usedAmount = newBuffer;
        }

        require(newBuffer != 0, ""RateLimited: no rate limit buffer"");
        require(usedAmount <= newBuffer, ""RateLimited: rate limit hit"");

        bufferStored = newBuffer - usedAmount;

        lastBufferUsedTime = block.timestamp;

        emit BufferUsed(usedAmount, bufferStored);

        return usedAmount;
    }

    /// @notice function to replenish buffer
    /// @param amount to increase buffer by if under buffer cap
    function _replenishBuffer(uint256 amount) internal {
        uint256 newBuffer = buffer();

        uint256 _bufferCap = bufferCap; /// gas opti, save an SLOAD

        /// cannot replenish any further if already at buffer cap
        if (newBuffer == _bufferCap) {
            return;
        }

        /// ensure that bufferStored cannot be gt buffer cap
        bufferStored = Math.min(newBuffer + amount, _bufferCap);
    }

    function _setRateLimitPerSecond(uint256 newRateLimitPerSecond) internal {
        uint256 oldRateLimitPerSecond = rateLimitPerSecond;
        rateLimitPerSecond = newRateLimitPerSecond;

        emit RateLimitPerSecondUpdate(
            oldRateLimitPerSecond,
            newRateLimitPerSecond
        );
    }

    function _setBufferCap(uint256 newBufferCap) internal {
        _updateBufferStored();

        uint256 oldBufferCap = bufferCap;
        bufferCap = newBufferCap;

        emit BufferCapUpdate(oldBufferCap, newBufferCap);
    }

    function _resetBuffer() internal {
        bufferStored = bufferCap;
    }

    function _updateBufferStored() internal {
        bufferStored = buffer();
        lastBufferUsedTime = block.timestamp;
    }
}",1125
RealWorld_TA_102_MockCore_RealWorld_20240812170810.log,102,MockCore,67656,2979,70635,88.0,0.39786,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import ""./../core/Permissions.sol"";
import ""../vcon/Vcon.sol"";
import ""../volt/Volt.sol"";

import ""@openzeppelin/contracts/proxy/utils/Initializable.sol"";

/// @title Mock Source of truth for Fei Protocol
/// @author Fei Protocol
/// @notice maintains roles, access control, fei, tribe, genesisGroup, and the TRIBE treasury
contract MockCore is Permissions, Initializable {
    /// @notice the address of the FEI contract
    IVolt public volt;

    /// @notice the address of the TRIBE contract
    IERC20 public vcon;

    constructor() {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }

        require(chainId != 1, ""MockCore: cannot deploy to mainnet"");
    }

    function init(address recipient) external initializer {
        /// emulate the real core as much as possible
        _setupGovernor(msg.sender);

        Volt _volt = new Volt(address(this));
        volt = IVolt(_volt);

        /// give all VCON to the recipient
        /// grant timelock the minter role
        Vcon _vcon = new Vcon(recipient, msg.sender);
        vcon = IERC20(address(_vcon));

        _setupGovernor(msg.sender);
    }

    /// @notice checks if address is a minter
    /// @return true _address is a minter
    // only virtual for testing mock override
    function isMinter(address) external view virtual override returns (bool) {
        return true;
    }

    /// @notice checks if address is a burner
    /// @return true _address is a burner
    // only virtual for testing mock override
    function isBurner(address) external view virtual override returns (bool) {
        return true;
    }

    /// @notice checks if address is a controller
    /// @return true _address is a controller
    // only virtual for testing mock override
    function isPCVController(address)
        external
        view
        virtual
        override
        returns (bool)
    {
        return true;
    }

    /// @notice checks if address is a governor
    /// @return true _address is a governor
    // only virtual for testing mock override
    function isGovernor(address) public view virtual override returns (bool) {
        return true;
    }

    /// @notice checks if address is a guardian
    /// @return true _address is a guardian
    // only virtual for testing mock override
    function isGuardian(address) public view virtual override returns (bool) {
        return true;
    }
}",576
RealWorld_TA_102_ScalingPriceOracle_RealWorld_20240812171256.log,102,ScalingPriceOracle,179671,3404,183075,106.0,0.966435,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {Timed} from ""./../utils/Timed.sol"";
import {CoreRef} from ""./../refs/CoreRef.sol"";
import {Decimal} from ""../external/Decimal.sol"";
import {Constants} from ""./../Constants.sol"";
import {Deviation} from ""./../utils/Deviation.sol"";
import {IScalingPriceOracle} from ""./IScalingPriceOracle.sol"";
import {BokkyPooBahsDateTimeContract} from ""./../external/calendar/BokkyPooBahsDateTimeContract.sol"";
import {Math} from ""@openzeppelin/contracts/utils/math/Math.sol"";
import {SafeCast} from ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import {ERC20, IERC20} from ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import {ChainlinkClient, Chainlink} from ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";

/// @notice contract that receives a chainlink price feed and then linearly interpolates that rate over
/// a 28 day period into the VOLT price. Interest is compounded monthly when the rate is updated
/// @author Elliot Friedman
contract ScalingPriceOracle is
    Timed,
    ChainlinkClient,
    IScalingPriceOracle,
    BokkyPooBahsDateTimeContract
{
    using SafeCast for *;
    using Deviation for *;
    using Decimal for Decimal.D256;
    using Chainlink for Chainlink.Request;

    /// ---------- Mutable Price Variables ----------

    /// @notice current amount that oracle price is inflating/deflating by monthly in basis points
    int256 public override monthlyChangeRateBasisPoints;

    /// @notice oracle price. starts off at 1e18 and compounds monthly
    uint256 public override oraclePrice = 1e18;

    /// ---------- Mutable CPI Variables Packed Into Single Storage Slot to Save an SSTORE & SLOAD ----------

    /// @notice the current month's CPI data
    uint128 public currentMonth;

    /// @notice the previous month's CPI data
    uint128 public previousMonth;

    /// ---------- Immutable Variables ----------

    /// @notice the time frame over which all changes in CPI data are applied
    /// 28 days was chosen as that is the shortest length of a month
    uint256 public constant override TIMEFRAME = 28 days;

    /// @notice the maximum allowable deviation in basis points for a new chainlink oracle update
    /// only allow price changes by 20% in a month.
    /// Any change over this threshold in either direction will be rejected
    uint256 public constant override MAXORACLEDEVIATION = 2_000;

    /// @notice address of chainlink oracle to send request
    address public immutable oracle;

    /// @notice job id that retrieves the latest CPI data
    bytes32 public immutable jobId;

    /// @notice amount in LINK paid to node operator for each request
    uint256 public immutable fee;

    /// @param _oracle address of chainlink data provider
    /// @param _jobid job id
    /// @param _fee maximum fee paid to chainlink data provider
    /// @param _currentMonth current month's inflation data
    /// @param _previousMonth previous month's inflation data
    constructor(
        address _oracle,
        bytes32 _jobid,
        uint256 _fee,
        uint128 _currentMonth,
        uint128 _previousMonth
    ) Timed(TIMEFRAME) {
        uint256 chainId;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            chainId := chainid()
        }

        if (chainId == 1 || chainId == 42) {
            setPublicChainlinkToken();
        }

        oracle = _oracle;
        jobId = _jobid;
        fee = _fee;

        currentMonth = _currentMonth;
        previousMonth = _previousMonth;

        _initTimed();

        /// calculate new monthly CPI-U rate in basis points based on current and previous month
        int256 aprBasisPoints = getMonthlyAPR();

        /// store data and apply the change rate over the next month to the VOLT price
        _oracleUpdateChangeRate(aprBasisPoints);
    }

    // ----------- Getters -----------

    /// @notice get the current scaled oracle price
    /// applies the change smoothly over a 28 day period
    /// scaled by 18 decimals
    // prettier-ignore
    function getCurrentOraclePrice() public view override returns (uint256) {
        int256 oraclePriceInt = oraclePrice.toInt256();

        int256 timeDelta = Math.min(block.timestamp - startTime, TIMEFRAME).toInt256();
        int256 pricePercentageChange = oraclePriceInt * monthlyChangeRateBasisPoints / Constants.BP_INT;
        int256 priceDelta = pricePercentageChange * timeDelta / TIMEFRAME.toInt256();

        return (oraclePriceInt + priceDelta).toUint256();
    }

    /// @notice get APR from chainlink data by measuring (current month - previous month) / previous month
    /// @return percentageChange percentage change in basis points over past month
    function getMonthlyAPR() public view returns (int256 percentageChange) {
        int256 delta = int128(currentMonth) - int128(previousMonth);
        percentageChange = (delta * Constants.BP_INT) / int128(previousMonth);
    }

    /// ------------- Public API To Request Chainlink Data -------------

    /// @notice Create a Chainlink request to retrieve API response, find the target
    /// data, then multiply by 1000 (to remove decimal places from data).
    /// @return requestId for this request
    /// only allows 1 request per month after the 14th day
    /// callable by anyone after time period and 14th day of the month
    function requestCPIData()
        external
        afterTimeInit
        returns (bytes32 requestId)
    {
        require(
            getDay(block.timestamp) > 14,
            ""ScalingPriceOracle: cannot request data before the 15th""
        );

        Chainlink.Request memory request = buildChainlinkRequest(
            jobId,
            address(this),
            this.fulfill.selector
        );

        return sendChainlinkRequestTo(oracle, request, fee);
    }

    /// ------------- Chainlink Node Operator API -------------

    /// @notice Receive the response in the form of uint256
    /// @param _requestId of the chainlink request
    /// @param _cpiData latest CPI data from BLS
    /// called by the chainlink oracle
    function fulfill(bytes32 _requestId, uint256 _cpiData)
        external
        recordChainlinkFulfillment(_requestId)
    {
        _updateCPIData(_cpiData);
    }

    // ----------- Internal state changing api -----------

    /// @notice helper function to store and validate new chainlink data
    /// @param _cpiData latest CPI data from BLS
    /// update will fail if new values exceed deviation threshold of 20% monthly
    function _updateCPIData(uint256 _cpiData) internal {
        require(
            MAXORACLEDEVIATION.isWithinDeviationThreshold(
                currentMonth.toInt256(),
                _cpiData.toInt256()
            ),
            ""ScalingPriceOracle: Chainlink data outside of deviation threshold""
        );

        /// store CPI data, removes stale data
        _addNewMonth(uint128(_cpiData));

        /// calculate new monthly CPI-U rate in basis points
        int256 aprBasisPoints = getMonthlyAPR();

        /// pass data to VOLT Price Oracle
        _oracleUpdateChangeRate(aprBasisPoints);
    }

    /// @notice function for chainlink oracle to be able to call in and change the rate
    /// @param newChangeRateBasisPoints the new monthly interest rate applied to the chainlink oracle price
    ///
    /// function effects:
    ///   compounds interest accumulated over period
    ///   set new change rate in basis points for next period
    function _oracleUpdateChangeRate(int256 newChangeRateBasisPoints) internal {
        /// compound the interest with the current rate
        oraclePrice = getCurrentOraclePrice();

        int256 currentChangeRateBasisPoints = monthlyChangeRateBasisPoints; /// save 1 SSLOAD

        /// emit even if there isn't an update
        emit CPIMonthlyChangeRateUpdate(
            currentChangeRateBasisPoints,
            newChangeRateBasisPoints
        );

        /// if the oracle change rate is the same as last time, save an SSTORE
        if (newChangeRateBasisPoints == currentChangeRateBasisPoints) {
            return;
        }

        monthlyChangeRateBasisPoints = newChangeRateBasisPoints;
    }

    /// @notice this is the only method needed as we will be storing the most recent 2 months of data
    /// @param newMonth the new month to store
    function _addNewMonth(uint128 newMonth) internal {
        previousMonth = currentMonth;

        currentMonth = newMonth;
    }
}",1922
RealWorld_TA_102_MultiRateLimited_RealWorld_20240812172544.log,102,MultiRateLimited,240708,2902,243610,111.0,1.26158,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {CoreRef} from ""../refs/CoreRef.sol"";
import {TribeRoles} from ""./../core/TribeRoles.sol"";
import {RateLimited} from ""./RateLimited.sol"";
import {IMultiRateLimited} from ""./IMultiRateLimited.sol"";
import {Math} from ""@openzeppelin/contracts/utils/math/Math.sol"";
import {SafeCast} from ""@openzeppelin/contracts/utils/math/SafeCast.sol"";

/// @title abstract contract for putting a rate limit on how fast an address can perform an action e.g. Minting
/// there are two buffers, one buffer which is each individual addresses's current buffer,
/// and then there is a global buffer which is the buffer that each individual address must respect as well
/// @author Elliot Friedman, Fei Protocol
/// this contract was made abstract so that other contracts that already construct an instance of CoreRef
/// do not collide with this one
abstract contract MultiRateLimited is RateLimited, IMultiRateLimited {
    using SafeCast for *;

    /// @notice the struct containing all information per rate limited address
    struct RateLimitData {
        uint32 lastBufferUsedTime;
        uint112 bufferCap;
        uint112 bufferStored;
        uint112 rateLimitPerSecond;
    }

    /// @notice rate limited address information
    mapping(address => RateLimitData) public rateLimitPerAddress;

    /// @notice max rate limit per second allowable by non governor per contract
    uint256 public individualMaxRateLimitPerSecond;

    /// @notice max buffer cap allowable by non governor per contract
    uint256 public individualMaxBufferCap;

    /// @param _maxRateLimitPerSecond maximum amount of fei that can replenish per second ever, this amount cannot be changed by governance
    /// @param _rateLimitPerSecond maximum rate limit per second per address
    /// @param _individualMaxRateLimitPerSecond maximum rate limit per second per address in multi rate limited
    /// @param _individualMaxBufferCap maximum buffer cap in multi rate limited
    /// @param _globalBufferCap maximum global buffer cap
    constructor(
        uint256 _maxRateLimitPerSecond,
        uint256 _rateLimitPerSecond,
        uint256 _individualMaxRateLimitPerSecond,
        uint256 _individualMaxBufferCap,
        uint256 _globalBufferCap
    )
        RateLimited(
            _maxRateLimitPerSecond,
            _rateLimitPerSecond,
            _globalBufferCap,
            false
        )
    {
        require(
            _individualMaxBufferCap < _globalBufferCap,
            ""MultiRateLimited: max buffer cap invalid""
        );

        individualMaxRateLimitPerSecond = _individualMaxRateLimitPerSecond;
        individualMaxBufferCap = _individualMaxBufferCap;
    }

    modifier addressIsRegistered(address rateLimitedAddress) {
        require(
            rateLimitPerAddress[rateLimitedAddress].lastBufferUsedTime != 0,
            ""MultiRateLimited: rate limit address does not exist""
        );
        _;
    }

    // ----------- Governor and Admin only state changing api -----------

    /// @notice update the ADD_MINTER_ROLE rate limit per second
    /// @param newRateLimitPerSecond new maximum rate limit per second for add minter role
    function updateMaxRateLimitPerSecond(uint256 newRateLimitPerSecond)
        external
        virtual
        override
        onlyGovernor
    {
        require(
            newRateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,
            ""MultiRateLimited: exceeds global max rate limit per second""
        );

        uint256 oldMaxRateLimitPerSecond = individualMaxRateLimitPerSecond;
        individualMaxRateLimitPerSecond = newRateLimitPerSecond;

        emit MultiMaxRateLimitPerSecondUpdate(
            oldMaxRateLimitPerSecond,
            newRateLimitPerSecond
        );
    }

    /// @notice update the ADD_MINTER_ROLE max buffer cap
    /// @param newBufferCap new buffer cap for ADD_MINTER_ROLE added addresses
    function updateMaxBufferCap(uint256 newBufferCap)
        external
        virtual
        override
        onlyGovernor
    {
        require(
            newBufferCap <= bufferCap,
            ""MultiRateLimited: exceeds global buffer cap""
        );

        uint256 oldBufferCap = individualMaxBufferCap;
        individualMaxBufferCap = newBufferCap;

        emit MultiBufferCapUpdate(oldBufferCap, newBufferCap);
    }

    /// @notice add an authorized rateLimitedAddress contract
    /// @param rateLimitedAddress the new address to add as a rateLimitedAddress
    /// @param _rateLimitPerSecond the rate limit per second for this rateLimitedAddress
    /// @param _bufferCap  the buffer cap for this rateLimitedAddress
    function addAddress(
        address rateLimitedAddress,
        uint112 _rateLimitPerSecond,
        uint112 _bufferCap
    ) external virtual override onlyGovernor {
        _addAddress(rateLimitedAddress, _rateLimitPerSecond, _bufferCap);
    }

    /// @notice add an authorized rateLimitedAddress contract
    /// @param rateLimitedAddress the address whose buffer and rate limit per second will be set
    /// @param _rateLimitPerSecond the new rate limit per second for this rateLimitedAddress
    /// @param _bufferCap  the new buffer cap for this rateLimitedAddress
    function updateAddress(
        address rateLimitedAddress,
        uint112 _rateLimitPerSecond,
        uint112 _bufferCap
    )
        external
        virtual
        override
        addressIsRegistered(rateLimitedAddress)
        hasAnyOfTwoRoles(TribeRoles.ADD_MINTER_ROLE, TribeRoles.GOVERNOR)
    {
        if (core().hasRole(TribeRoles.ADD_MINTER_ROLE, msg.sender)) {
            require(
                _rateLimitPerSecond <= individualMaxRateLimitPerSecond,
                ""MultiRateLimited: rate limit per second exceeds non governor allowable amount""
            );
            require(
                _bufferCap <= individualMaxBufferCap,
                ""MultiRateLimited: max buffer cap exceeds non governor allowable amount""
            );
        }
        require(
            _bufferCap <= bufferCap,
            ""MultiRateLimited: buffercap too high""
        );

        _updateAddress(rateLimitedAddress, _rateLimitPerSecond, _bufferCap);
    }

    /// @notice add an authorized rateLimitedAddress contract
    /// @param rateLimitedAddress the new address to add as a rateLimitedAddress
    /// gives the newly added contract the maximum allowable rate limit per second and buffer cap
    function addAddressWithCaps(address rateLimitedAddress)
        external
        virtual
        override
        onlyTribeRole(TribeRoles.ADD_MINTER_ROLE)
    {
        _addAddress(
            rateLimitedAddress,
            uint112(individualMaxRateLimitPerSecond),
            uint112(individualMaxBufferCap)
        );
    }

    /// @notice remove an authorized rateLimitedAddress contract
    /// @param rateLimitedAddress the address to remove from the whitelist of addresses
    function removeAddress(address rateLimitedAddress)
        external
        virtual
        override
        addressIsRegistered(rateLimitedAddress)
        onlyGuardianOrGovernor
    {
        uint256 oldRateLimitPerSecond = rateLimitPerAddress[rateLimitedAddress]
            .rateLimitPerSecond;

        delete rateLimitPerAddress[rateLimitedAddress];

        emit IndividualRateLimitPerSecondUpdate(
            rateLimitedAddress,
            oldRateLimitPerSecond,
            0
        );
    }

    // ----------- Getters -----------

    /// @notice the amount of action used before hitting limit
    /// @dev replenishes at rateLimitPerSecond per second up to bufferCap
    /// @param rateLimitedAddress the address whose buffer will be returned
    /// @return the buffer of the specified rate limited address
    function individualBuffer(address rateLimitedAddress)
        public
        view
        override
        returns (uint112)
    {
        RateLimitData memory rateLimitData = rateLimitPerAddress[
            rateLimitedAddress
        ];

        uint256 elapsed = block.timestamp - rateLimitData.lastBufferUsedTime;
        return
            uint112(
                Math.min(
                    rateLimitData.bufferStored +
                        (rateLimitData.rateLimitPerSecond * elapsed),
                    rateLimitData.bufferCap
                )
            );
    }

    /// @notice the rate per second for each address
    function getRateLimitPerSecond(address limiter)
        external
        view
        override
        returns (uint256)
    {
        return rateLimitPerAddress[limiter].rateLimitPerSecond;
    }

    /// @notice the last time the buffer was used by each address
    function getLastBufferUsedTime(address limiter)
        external
        view
        override
        returns (uint256)
    {
        return rateLimitPerAddress[limiter].lastBufferUsedTime;
    }

    /// @notice the cap of the buffer that can be used at once
    function getBufferCap(address limiter)
        external
        view
        override
        returns (uint256)
    {
        return rateLimitPerAddress[limiter].bufferCap;
    }

    // ----------- Helper Methods -----------

    function _updateAddress(
        address rateLimitedAddress,
        uint112 _rateLimitPerSecond,
        uint112 _bufferCap
    ) internal {
        RateLimitData storage rateLimitData = rateLimitPerAddress[
            rateLimitedAddress
        ];

        require(
            rateLimitData.lastBufferUsedTime != 0,
            ""MultiRateLimited: rate limit address does not exist""
        );
        require(
            _rateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,
            ""MultiRateLimited: rateLimitPerSecond too high""
        );

        uint112 oldRateLimitPerSecond = rateLimitData.rateLimitPerSecond;

        rateLimitData.lastBufferUsedTime = block.timestamp.toUint32();
        rateLimitData.bufferCap = _bufferCap;
        rateLimitData.rateLimitPerSecond = _rateLimitPerSecond;
        rateLimitData.bufferStored = _bufferCap;

        emit IndividualRateLimitPerSecondUpdate(
            rateLimitedAddress,
            oldRateLimitPerSecond,
            _rateLimitPerSecond
        );
    }

    /// @param rateLimitedAddress the new address to add as a rateLimitedAddress
    /// @param _rateLimitPerSecond the rate limit per second for this rateLimitedAddress
    /// @param _bufferCap  the buffer cap for this rateLimitedAddress
    function _addAddress(
        address rateLimitedAddress,
        uint112 _rateLimitPerSecond,
        uint112 _bufferCap
    ) internal {
        require(
            _bufferCap <= bufferCap,
            ""MultiRateLimited: new buffercap too high""
        );
        require(
            rateLimitPerAddress[rateLimitedAddress].lastBufferUsedTime == 0,
            ""MultiRateLimited: address already added""
        );
        require(
            _rateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,
            ""MultiRateLimited: rateLimitPerSecond too high""
        );

        RateLimitData memory rateLimitData = RateLimitData({
            lastBufferUsedTime: block.timestamp.toUint32(),
            bufferCap: _bufferCap,
            rateLimitPerSecond: _rateLimitPerSecond,
            bufferStored: _bufferCap
        });

        rateLimitPerAddress[rateLimitedAddress] = rateLimitData;

        emit IndividualRateLimitPerSecondUpdate(
            rateLimitedAddress,
            0,
            _rateLimitPerSecond
        );
    }

    /// @notice the method that enforces the rate limit. Decreases buffer by ""amount"".
    /// @param rateLimitedAddress the address whose buffer will be depleted
    /// @param amount the amount to remove from the rateLimitedAddress's buffer
    function _depleteIndividualBuffer(
        address rateLimitedAddress,
        uint256 amount
    ) internal returns (uint256) {
        _depleteBuffer(amount);

        uint256 newBuffer = individualBuffer(rateLimitedAddress);

        require(newBuffer != 0, ""MultiRateLimited: no rate limit buffer"");
        require(amount <= newBuffer, ""MultiRateLimited: rate limit hit"");

        rateLimitPerAddress[rateLimitedAddress].bufferStored = uint112(
            newBuffer - amount
        );

        rateLimitPerAddress[rateLimitedAddress].lastBufferUsedTime = block
            .timestamp
            .toUint32();

        emit IndividualBufferUsed(
            rateLimitedAddress,
            amount,
            newBuffer - amount
        );

        return amount;
    }
}",2643
RealWorld_TA_103_IAnyswapRouter_RealWorld_20240812184224.log,103,IAnyswapRouter,28757,1683,30440,87.0,0.177445,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IAnyswapRouter {
    function anySwapOutUnderlying(
        address token,
        address to,
        uint256 amount,
        uint256 toChainID
    ) external;

    function anySwapOut(
        address token,
        address to,
        uint256 amount,
        uint256 toChainID
    ) external;

    function anySwapOutNative(
        address token,
        address to,
        uint256 toChainID
    ) external payable;

    function wNATIVE() external returns (address);
}",124
RealWorld_TA_103_ICBridge_RealWorld_20240812184504.log,103,ICBridge,31206,1900,33106,76.0,0.19403,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface ICBridge {
    function send(
        address _receiver,
        address _token,
        uint256 _amount,
        uint64 _dstChinId,
        uint64 _nonce,
        uint32 _maxSlippage
    ) external;

    function sendNative(
        address _receiver,
        uint256 _amount,
        uint64 _dstChinId,
        uint64 _nonce,
        uint32 _maxSlippage
    ) external;

    function relay(
        bytes calldata _relayRequest,
        bytes[] calldata _sigs,
        address[] calldata _signers,
        uint256[] calldata _powers
    ) external;
}",157
RealWorld_TA_103_WithdrawFacet_RealWorld_20240812182527.log,103,WithdrawFacet,46960,3260,50220,91.0,0.3,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { LibDiamond } from ""../Libraries/LibDiamond.sol"";

contract WithdrawFacet {
    using SafeERC20 for IERC20;
    address private constant NATIVE_ASSET = address(0);

    event LogWithdraw(address indexed _assetAddress, address _from, uint256 amount);

    /**
     * @dev Withdraw asset.
     * @param _assetAddress Asset to be withdrawn.
     * @param _to address to withdraw to.
     * @param _amount amount of asset to withdraw.
     */
    function withdraw(
        address _assetAddress,
        address _to,
        uint256 _amount
    ) public {
        LibDiamond.enforceIsContractOwner();
        address sendTo = (_to == address(0)) ? msg.sender : _to;
        uint256 assetBalance;
        if (_assetAddress == NATIVE_ASSET) {
            address self = address(this); // workaround for a possible solidity bug
            assert(_amount <= self.balance);
            payable(sendTo).transfer(_amount);
        } else {
            assetBalance = IERC20(_assetAddress).balanceOf(address(this));
            assert(_amount <= assetBalance);
            IERC20(_assetAddress).safeTransfer(sendTo, _amount);
        }
        emit LogWithdraw(sendTo, _assetAddress, _amount);
    }
}",335
RealWorld_TA_103_Swapper_RealWorld_20240812182700.log,103,Swapper,35723,3403,39126,86.0,0.246675,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { ILiFi } from ""../Interfaces/ILiFi.sol"";
import { LibSwap } from ""../Libraries/LibSwap.sol"";
import { LibStorage } from ""../Libraries/LibStorage.sol"";

contract Swapper is ILiFi {
    /* ========== Storage ========== */
    LibStorage internal ls;

    function _executeSwaps(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) internal {
        // Swap
        for (uint8 i; i < _swapData.length; i++) {
            require(
                ls.dexWhitelist[_swapData[i].approveTo] == true && ls.dexWhitelist[_swapData[i].callTo] == true,
                ""Contract call not allowed!""
            );

            LibSwap.swap(_lifiData.transactionId, _swapData[i]);
        }
    }
}",194
RealWorld_TA_103_CBridgeFacet_RealWorld_20240812182222.log,103,CBridgeFacet,139146,3640,142786,105.0,0.76853,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { LibAsset, IERC20 } from ""../Libraries/LibAsset.sol"";
import { ILiFi } from ""../Interfaces/ILiFi.sol"";
import { ICBridge } from ""../Interfaces/ICBridge.sol"";
import { LibDiamond } from ""../Libraries/LibDiamond.sol"";
import ""./Swapper.sol"";

/**
 * @title CBridge Facet
 * @author Li.Finance (https://li.finance)
 * @notice Provides functionality for bridging through CBridge
 */
contract CBridgeFacet is ILiFi, Swapper {
    /* ========== Storage ========== */

    bytes32 internal constant NAMESPACE = keccak256(""com.lifi.facets.cbridge2"");
    struct Storage {
        address cBridge;
        uint64 cBridgeChainId;
    }

    /* ========== Types ========== */

    struct CBridgeData {
        address receiver;
        address token;
        uint256 amount;
        uint64 dstChainId;
        uint64 nonce;
        uint32 maxSlippage;
    }

    /* ========== Init ========== */

    /**
     * @notice Initializes local variables for the CBridge facet
     * @param _cBridge address of the canonical CBridge router contract
     * @param _chainId chainId of this deployed contract
     */
    function initCbridge(address _cBridge, uint64 _chainId) external {
        Storage storage s = getStorage();
        LibDiamond.enforceIsContractOwner();
        s.cBridge = _cBridge;
        s.cBridgeChainId = _chainId;
        emit Inited(s.cBridge, s.cBridgeChainId);
    }

    /* ========== Public Bridge Functions ========== */

    /**
     * @notice Bridges tokens via CBridge
     * @param _lifiData data used purely for tracking and analytics
     * @param _cBridgeData data specific to CBridge
     */
    function startBridgeTokensViaCBridge(LiFiData memory _lifiData, CBridgeData calldata _cBridgeData) public payable {
        if (_cBridgeData.token != address(0)) {
            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);

            LibAsset.transferFromERC20(_cBridgeData.token, msg.sender, address(this), _cBridgeData.amount);

            require(
                LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance == _cBridgeData.amount,
                ""ERR_INVALID_AMOUNT""
            );
        } else {
            require(msg.value >= _cBridgeData.amount, ""ERR_INVALID_AMOUNT"");
        }

        _startBridge(_cBridgeData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /**
     * @notice Performs a swap before bridging via CBridge
     * @param _lifiData data used purely for tracking and analytics
     * @param _swapData an array of swap related data for performing swaps before bridging
     * @param _cBridgeData data specific to CBridge
     */
    function swapAndStartBridgeTokensViaCBridge(
        LiFiData memory _lifiData,
        LibSwap.SwapData[] calldata _swapData,
        CBridgeData memory _cBridgeData
    ) public payable {
        if (_cBridgeData.token != address(0)) {
            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);

            // Swap
            _executeSwaps(_lifiData, _swapData);

            uint256 _postSwapBalance = LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance;

            require(_postSwapBalance > 0, ""ERR_INVALID_AMOUNT"");

            _cBridgeData.amount = _postSwapBalance;
        } else {
            uint256 _fromBalance = address(this).balance;

            // Swap
            _executeSwaps(_lifiData, _swapData);

            uint256 _postSwapBalance = address(this).balance - _fromBalance;

            require(_postSwapBalance > 0, ""ERR_INVALID_AMOUNT"");

            _cBridgeData.amount = _postSwapBalance;
        }

        _startBridge(_cBridgeData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /* ========== Internal Functions ========== */

    /*
     * @dev Conatains the business logic for the bridge via CBridge
     * @param _cBridgeData data specific to CBridge
     */
    function _startBridge(CBridgeData memory _cBridgeData) internal {
        Storage storage s = getStorage();
        address bridge = _bridge();

        // Do CBridge stuff
        require(s.cBridgeChainId != _cBridgeData.dstChainId, ""Cannot bridge to the same network."");

        if (LibAsset.isNativeAsset(_cBridgeData.token)) {
            ICBridge(bridge).sendNative(
                _cBridgeData.receiver,
                _cBridgeData.amount,
                _cBridgeData.dstChainId,
                _cBridgeData.nonce,
                _cBridgeData.maxSlippage
            );
        } else {
            // Give CBridge approval to bridge tokens
            LibAsset.approveERC20(IERC20(_cBridgeData.token), bridge, _cBridgeData.amount);
            // solhint-disable check-send-result
            ICBridge(bridge).send(
                _cBridgeData.receiver,
                _cBridgeData.token,
                _cBridgeData.amount,
                _cBridgeData.dstChainId,
                _cBridgeData.nonce,
                _cBridgeData.maxSlippage
            );
        }
    }

    /*
     * @dev Public view function for the CBridge router address
     * @returns the router address
     */
    function _bridge() internal view returns (address) {
        Storage storage s = getStorage();
        return s.cBridge;
    }

    /**
     * @dev fetch local storage
     */
    function getStorage() internal pure returns (Storage storage s) {
        bytes32 namespace = NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}",1422
RealWorld_TA_103_IHopBridge_RealWorld_20240812184806.log,103,IHopBridge,31141,1614,32755,77.0,0.187985,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IHopBridge {
    struct BridgeConfig {
        address token;
        address bridge;
        address ammWrapper;
    }

    function sendToL2(
        uint256 chainId,
        address recipient,
        uint256 amount,
        uint256 amountOutMin,
        uint256 deadline,
        address relayer,
        uint256 relayerFee
    ) external payable;

    function swapAndSend(
        uint256 chainId,
        address recipient,
        uint256 amount,
        uint256 bonderFee,
        uint256 amountOutMin,
        uint256 deadline,
        uint256 destinationAmountOutMin,
        uint256 destinationDeadline
    ) external payable;
}",153
RealWorld_TA_103_DexManagerFacet_RealWorld_20240812181858.log,103,DexManagerFacet,75801,3675,79476,93.0,0.452505,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""../Libraries/LibStorage.sol"";
import ""../Libraries/LibDiamond.sol"";

/**
 * @title Optics Router Facet
 * @author Li.Finance (https://li.finance)
 * @notice Facet contract for managing approved DEXs to be used in swaps.
 */
contract DexManagerFacet {
    LibStorage internal s;

    /// @notice Register the address of a DEX contract to be approved for swapping.
    /// @param _dex The address of the DEX contract to be approved.
    function addDex(address _dex) external {
        LibDiamond.enforceIsContractOwner();

        if (s.dexWhitelist[_dex] == true) {
            return;
        }

        s.dexWhitelist[_dex] = true;
        s.dexs.push(_dex);
    }

    /// @notice Batch register the addresss of DEX contracts to be approved for swapping.
    /// @param _dexs The addresses of the DEX contracts to be approved.
    function batchAddDex(address[] calldata _dexs) external {
        LibDiamond.enforceIsContractOwner();

        for (uint256 i; i < _dexs.length; i++) {
            if (s.dexWhitelist[_dexs[i]] == true) {
                continue;
            }
            s.dexWhitelist[_dexs[i]] = true;
            s.dexs.push(_dexs[i]);
        }
    }

    /// @notice Unregister the address of a DEX contract approved for swapping.
    /// @param _dex The address of the DEX contract to be unregistered.
    function removeDex(address _dex) external {
        LibDiamond.enforceIsContractOwner();

        if (s.dexWhitelist[_dex] == false) {
            return;
        }

        s.dexWhitelist[_dex] = false;
        for (uint256 i; i < s.dexs.length; i++) {
            if (s.dexs[i] == _dex) {
                _removeDex(i);
                return;
            }
        }
    }

    /// @notice Batch unregister the addresses of DEX contracts approved for swapping.
    /// @param _dexs The addresses of the DEX contracts to be unregistered.
    function batchRemoveDex(address[] calldata _dexs) external {
        LibDiamond.enforceIsContractOwner();

        for (uint256 i; i < _dexs.length; i++) {
            if (s.dexWhitelist[_dexs[i]] == false) {
                continue;
            }
            s.dexWhitelist[_dexs[i]] = false;
            for (uint256 j; j < s.dexs.length; j++) {
                if (s.dexs[j] == _dexs[i]) {
                    _removeDex(j);
                    return;
                }
            }
        }
    }

    function approvedDexs() external view returns (address[] memory) {
        return s.dexs;
    }

    function _removeDex(uint256 index) private {
        // Move the last element into the place to delete
        s.dexs[index] = s.dexs[s.dexs.length - 1];
        // Remove the last element
        s.dexs.pop();
    }
}",684
RealWorld_TA_103_ITransactionManager_RealWorld_20240812184622.log,103,ITransactionManager,157943,2728,160671,102.0,0.844275,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.7;

interface ITransactionManager {
    // Structs

    // Holds all data that is constant between sending and
    // receiving chains. The hash of this is what gets signed
    // to ensure the signature can be used on both chains.
    struct InvariantTransactionData {
        address receivingChainTxManagerAddress;
        address user;
        address router;
        address initiator; // msg.sender of sending side
        address sendingAssetId;
        address receivingAssetId;
        address sendingChainFallback; // funds sent here on cancel
        address receivingAddress;
        address callTo;
        uint256 sendingChainId;
        uint256 receivingChainId;
        bytes32 callDataHash; // hashed to prevent free option
        bytes32 transactionId;
    }

    // Holds all data that varies between sending and receiving
    // chains. The hash of this is stored onchain to ensure the
    // information passed in is valid.
    struct VariantTransactionData {
        uint256 amount;
        uint256 expiry;
        uint256 preparedBlockNumber;
    }

    // All Transaction data, constant and variable
    struct TransactionData {
        address receivingChainTxManagerAddress;
        address user;
        address router;
        address initiator; // msg.sender of sending side
        address sendingAssetId;
        address receivingAssetId;
        address sendingChainFallback;
        address receivingAddress;
        address callTo;
        bytes32 callDataHash;
        bytes32 transactionId;
        uint256 sendingChainId;
        uint256 receivingChainId;
        uint256 amount;
        uint256 expiry;
        uint256 preparedBlockNumber; // Needed for removal of active blocks on fulfill/cancel
    }

    // The structure of the signed data for fulfill
    struct SignedFulfillData {
        bytes32 transactionId;
        uint256 relayerFee;
        string functionIdentifier; // ""fulfill"" or ""cancel""
        uint256 receivingChainId; // For domain separation
        address receivingChainTxManagerAddress; // For domain separation
    }

    // The structure of the signed data for cancellation
    struct SignedCancelData {
        bytes32 transactionId;
        string functionIdentifier;
        uint256 receivingChainId;
        address receivingChainTxManagerAddress; // For domain separation
    }

    /**
     * Arguments for calling prepare()
     * @param invariantData The data for a crosschain transaction that will
     *                      not change between sending and receiving chains.
     *                      The hash of this data is used as the key to store
     *                      the inforamtion that does change between chains
     *                      (amount,expiry,preparedBlock) for verification
     * @param amount The amount of the transaction on this chain
     * @param expiry The block.timestamp when the transaction will no longer be
     *               fulfillable and is freely cancellable on this chain
     * @param encryptedCallData The calldata to be executed when the tx is
     *                          fulfilled. Used in the function to allow the user
     *                          to reconstruct the tx from events. Hash is stored
     *                          onchain to prevent shenanigans.
     * @param encodedBid The encoded bid that was accepted by the user for this
     *                   crosschain transfer. It is supplied as a param to the
     *                   function but is only used in event emission
     * @param bidSignature The signature of the bidder on the encoded bid for
     *                     this transaction. Only used within the function for
     *                     event emission. The validity of the bid and
     *                     bidSignature are enforced offchain
     * @param encodedMeta The meta for the function
     */
    struct PrepareArgs {
        InvariantTransactionData invariantData;
        uint256 amount;
        uint256 expiry;
        bytes encryptedCallData;
        bytes encodedBid;
        bytes bidSignature;
        bytes encodedMeta;
    }

    /**
     * @param txData All of the data (invariant and variant) for a crosschain
     *               transaction. The variant data provided is checked against
     *               what was stored when the `prepare` function was called.
     * @param relayerFee The fee that should go to the relayer when they are
     *                   calling the function on the receiving chain for the user
     * @param signature The users signature on the transaction id + fee that
     *                  can be used by the router to unlock the transaction on
     *                  the sending chain
     * @param callData The calldata to be sent to and executed by the
     *                 `FulfillHelper`
     * @param encodedMeta The meta for the function
     */
    struct FulfillArgs {
        TransactionData txData;
        uint256 relayerFee;
        bytes signature;
        bytes callData;
        bytes encodedMeta;
    }

    /**
     * Arguments for calling cancel()
     * @param txData All of the data (invariant and variant) for a crosschain
     *               transaction. The variant data provided is checked against
     *               what was stored when the `prepare` function was called.
     * @param signature The user's signature that allows a transaction to be
     *                  cancelled by a relayer
     * @param encodedMeta The meta for the function
     */
    struct CancelArgs {
        TransactionData txData;
        bytes signature;
        bytes encodedMeta;
    }

    // Adding/removing asset events
    event RouterAdded(address indexed addedRouter, address indexed caller);

    event RouterRemoved(address indexed removedRouter, address indexed caller);

    // Adding/removing router events
    event AssetAdded(address indexed addedAssetId, address indexed caller);

    event AssetRemoved(address indexed removedAssetId, address indexed caller);

    // Liquidity events
    event LiquidityAdded(address indexed router, address indexed assetId, uint256 amount, address caller);

    event LiquidityRemoved(address indexed router, address indexed assetId, uint256 amount, address recipient);

    // Transaction events
    event TransactionPrepared(
        address indexed user,
        address indexed router,
        bytes32 indexed transactionId,
        TransactionData txData,
        address caller,
        PrepareArgs args
    );

    event TransactionFulfilled(
        address indexed user,
        address indexed router,
        bytes32 indexed transactionId,
        FulfillArgs args,
        bool success,
        bool isContract,
        bytes returnData,
        address caller
    );

    event TransactionCancelled(
        address indexed user,
        address indexed router,
        bytes32 indexed transactionId,
        CancelArgs args,
        address caller
    );

    // Getters
    function getChainId() external view returns (uint256);

    function getStoredChainId() external view returns (uint256);

    // Owner only methods
    function addRouter(address router) external;

    function removeRouter(address router) external;

    function addAssetId(address assetId) external;

    function removeAssetId(address assetId) external;

    // Router only methods
    function addLiquidityFor(
        uint256 amount,
        address assetId,
        address router
    ) external payable;

    function addLiquidity(uint256 amount, address assetId) external payable;

    function removeLiquidity(
        uint256 amount,
        address assetId,
        address payable recipient
    ) external;

    // Methods for crosschain transfers
    // called in the following order (in happy case)
    // 1. prepare by user on sending chain
    // 2. prepare by router on receiving chain
    // 3. fulfill by user on receiving chain
    // 4. fulfill by router on sending chain
    function prepare(PrepareArgs calldata args) external payable returns (TransactionData memory);

    function fulfill(FulfillArgs calldata args) external returns (TransactionData memory);

    function cancel(CancelArgs calldata args) external returns (TransactionData memory);
}",1660
RealWorld_TA_103_OwnershipFacet_RealWorld_20240812181551.log,103,OwnershipFacet,27624,1679,29303,73.0,0.1717,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { LibDiamond } from ""../Libraries/LibDiamond.sol"";
import { IERC173 } from ""../Interfaces/IERC173.sol"";

contract OwnershipFacet is IERC173 {
    function transferOwnership(address _newOwner) external override {
        LibDiamond.enforceIsContractOwner();
        LibDiamond.setContractOwner(_newOwner);
    }

    function owner() external view override returns (address owner_) {
        owner_ = LibDiamond.contractOwner();
    }
}",112
RealWorld_TA_103_LibAsset_RealWorld_20240812183436.log,103,LibAsset,119507,2550,122057,93.0,0.648535,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.7;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/**
 * @title LibAsset
 * @author Connext <support@connext.network>
 * @notice This library contains helpers for dealing with onchain transfers
 *         of assets, including accounting for the native asset `assetId`
 *         conventions and any noncompliant ERC20 transfers
 */
library LibAsset {
    uint256 private constant MAX_INT = 2**256 - 1;

    /**
     * @dev All native assets use the empty address for their asset id
     *      by convention
     */
    address internal constant NATIVE_ASSETID = address(0);

    /**
     * @notice Determines whether the given assetId is the native asset
     * @param assetId The asset identifier to evaluate
     * @return Boolean indicating if the asset is the native asset
     */
    function isNativeAsset(address assetId) internal pure returns (bool) {
        return assetId == NATIVE_ASSETID;
    }

    /**
     * @notice Gets the balance of the inheriting contract for the given asset
     * @param assetId The asset identifier to get the balance of
     * @return Balance held by contracts using this library
     */
    function getOwnBalance(address assetId) internal view returns (uint256) {
        return isNativeAsset(assetId) ? address(this).balance : IERC20(assetId).balanceOf(address(this));
    }

    /**
     * @notice Transfers ether from the inheriting contract to a given
     *         recipient
     * @param recipient Address to send ether to
     * @param amount Amount to send to given recipient
     */
    function transferNativeAsset(address payable recipient, uint256 amount) internal {
        // solhint-disable-next-line avoid-low-level-calls
        (bool success, ) = recipient.call{ value: amount }("""");
        require(success, ""#TNA:028"");
    }

    /**
     * @notice Gives approval for another address to spend tokens
     * @param assetId Token address to transfer
     * @param spender Address to give spend approval to
     * @param amount Amount to approve for spending
     */
    function approveERC20(
        IERC20 assetId,
        address spender,
        uint256 amount
    ) internal {
        if (isNativeAsset(address(assetId))) return;
        uint256 allowance = assetId.allowance(address(this), spender);
        if (allowance < amount) {
            if (allowance > 0) SafeERC20.safeApprove(IERC20(assetId), spender, 0);
            SafeERC20.safeApprove(IERC20(assetId), spender, MAX_INT);
        }
    }

    /**
     * @notice Transfers tokens from the inheriting contract to a given
     *         recipient
     * @param assetId Token address to transfer
     * @param recipient Address to send ether to
     * @param amount Amount to send to given recipient
     */
    function transferERC20(
        address assetId,
        address recipient,
        uint256 amount
    ) internal {
        SafeERC20.safeTransfer(IERC20(assetId), recipient, amount);
    }

    /**
     * @notice Transfers tokens from a sender to a given recipient
     * @param assetId Token address to transfer
     * @param from Address of sender/owner
     * @param to Address of recipient/spender
     * @param amount Amount to transfer from owner to spender
     */
    function transferFromERC20(
        address assetId,
        address from,
        address to,
        uint256 amount
    ) internal {
        SafeERC20.safeTransferFrom(IERC20(assetId), from, to, amount);
    }

    /**
     * @notice Increases the allowance of a token to a spender
     * @param assetId Token address of asset to increase allowance of
     * @param spender Account whos allowance is increased
     * @param amount Amount to increase allowance by
     */
    function increaseERC20Allowance(
        address assetId,
        address spender,
        uint256 amount
    ) internal {
        require(!isNativeAsset(assetId), ""#IA:034"");
        SafeERC20.safeIncreaseAllowance(IERC20(assetId), spender, amount);
    }

    /**
     * @notice Decreases the allowance of a token to a spender
     * @param assetId Token address of asset to decrease allowance of
     * @param spender Account whos allowance is decreased
     * @param amount Amount to decrease allowance by
     */
    function decreaseERC20Allowance(
        address assetId,
        address spender,
        uint256 amount
    ) internal {
        require(!isNativeAsset(assetId), ""#DA:034"");
        SafeERC20.safeDecreaseAllowance(IERC20(assetId), spender, amount);
    }

    /**
     * @notice Wrapper function to transfer a given asset (native or erc20) to
     *         some recipient. Should handle all non-compliant return value
     *         tokens as well by using the SafeERC20 contract by open zeppelin.
     * @param assetId Asset id for transfer (address(0) for native asset,
     *                token address for erc20s)
     * @param recipient Address to send asset to
     * @param amount Amount to send to given recipient
     */
    function transferAsset(
        address assetId,
        address payable recipient,
        uint256 amount
    ) internal {
        isNativeAsset(assetId) ? transferNativeAsset(recipient, amount) : transferERC20(assetId, recipient, amount);
    }
}",1217
RealWorld_TA_103_IERC165_RealWorld_20240812185045.log,103,IERC165,29131,1268,30399,69.0,0.171015,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IERC165 {
    /// @notice Query if a contract implements an interface
    /// @param interfaceId The interface identifier, as specified in ERC-165
    /// @dev Interface identification is specified in ERC-165. This function
    ///  uses less than 30,000 gas.
    /// @return `true` if the contract implements `interfaceID` and
    ///  `interfaceID` is not 0xffffffff, `false` otherwise
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}",129
RealWorld_TA_103_LiFiDiamond_RealWorld_20240812181131.log,103,LiFiDiamond,63404,2450,65854,83.0,0.36602,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { LibDiamond } from ""./Libraries/LibDiamond.sol"";
import { IDiamondCut } from ""./Interfaces/IDiamondCut.sol"";

contract LiFiDiamond {
    constructor(address _contractOwner, address _diamondCutFacet) payable {
        LibDiamond.setContractOwner(_contractOwner);

        // Add the diamondCut external function from the diamondCutFacet
        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);
        bytes4[] memory functionSelectors = new bytes4[](1);
        functionSelectors[0] = IDiamondCut.diamondCut.selector;
        cut[0] = IDiamondCut.FacetCut({
            facetAddress: _diamondCutFacet,
            action: IDiamondCut.FacetCutAction.Add,
            functionSelectors: functionSelectors
        });
        LibDiamond.diamondCut(cut, address(0), """");
    }

    // Find facet for function that is called and execute the
    // function if a facet is found and return any value.
    // solhint-disable-next-line no-complex-fallback
    fallback() external payable {
        LibDiamond.DiamondStorage storage ds;
        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;

        // get diamond storage
        // solhint-disable-next-line no-inline-assembly
        assembly {
            ds.slot := position
        }

        // get facet from function selector
        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;
        require(facet != address(0), ""Diamond: Function does not exist"");

        // Execute external function from facet using delegatecall and return any value.
        // solhint-disable-next-line no-inline-assembly
        assembly {
            // copy function selector and any arguments
            calldatacopy(0, 0, calldatasize())
            // execute function call using the facet
            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)
            // get any return value
            returndatacopy(0, 0, returndatasize())
            // return any return value or error back to the caller
            switch result
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }

    // Able to receive ether
    // solhint-disable-next-line no-empty-blocks
    receive() external payable {}
}",532
RealWorld_TA_103_HopFacet_RealWorld_20240812182034.log,103,HopFacet,141005,3735,144740,105.0,0.779725,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { ILiFi } from ""../Interfaces/ILiFi.sol"";
import { IHopBridge } from ""../Interfaces/IHopBridge.sol"";
import { LibAsset, IERC20 } from ""../Libraries/LibAsset.sol"";
import { LibDiamond } from ""../Libraries/LibDiamond.sol"";
import ""./Swapper.sol"";

/**
 * @title Hop Facet
 * @author Li.Finance (https://li.finance)
 * @notice Provides functionality for bridging through Hop
 */
contract HopFacet is ILiFi, Swapper {
    /* ========== Storage ========== */

    bytes32 internal constant NAMESPACE = keccak256(""com.lifi.facets.hop"");
    struct Storage {
        mapping(string => IHopBridge.BridgeConfig) hopBridges;
        uint256 hopChainId;
    }

    /* ========== Types ========== */

    struct HopData {
        string asset;
        address recipient;
        uint256 chainId;
        uint256 amount;
        uint256 bonderFee;
        uint256 amountOutMin;
        uint256 deadline;
        uint256 destinationAmountOutMin;
        uint256 destinationDeadline;
    }

    /* ========== Init ========== */

    function initHop(
        string[] memory _tokens,
        IHopBridge.BridgeConfig[] memory _bridgeConfigs,
        uint256 _chainId
    ) external {
        Storage storage s = getStorage();
        LibDiamond.enforceIsContractOwner();

        for (uint8 i; i < _tokens.length; i++) {
            s.hopBridges[_tokens[i]] = _bridgeConfigs[i];
        }
        s.hopChainId = _chainId;
    }

    /* ========== Public Bridge Functions ========== */

    /**
     * @notice Bridges tokens via Hop Protocol
     * @param _lifiData data used purely for tracking and analytics
     * @param _hopData data specific to Hop Protocol
     */
    function startBridgeTokensViaHop(LiFiData memory _lifiData, HopData calldata _hopData) public payable {
        address sendingAssetId = _bridge(_hopData.asset).token;

        if (sendingAssetId == address(0)) require(msg.value == _hopData.amount, ""ERR_INVALID_AMOUNT"");
        else {
            uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);
            LibAsset.transferFromERC20(sendingAssetId, msg.sender, address(this), _hopData.amount);
            require(
                LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance == _hopData.amount,
                ""ERR_INVALID_AMOUNT""
            );
        }

        _startBridge(_hopData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /**
     * @notice Performs a swap before bridging via Hop Protocol
     * @param _lifiData data used purely for tracking and analytics
     * @param _swapData an array of swap related data for performing swaps before bridging
     * @param _hopData data specific to Hop Protocol
     */
    function swapAndStartBridgeTokensViaHop(
        LiFiData memory _lifiData,
        LibSwap.SwapData[] calldata _swapData,
        HopData memory _hopData
    ) public payable {
        address sendingAssetId = _bridge(_hopData.asset).token;

        uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);

        // Swap
        _executeSwaps(_lifiData, _swapData);

        uint256 _postSwapBalance = LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance;

        require(_postSwapBalance > 0, ""ERR_INVALID_AMOUNT"");

        _hopData.amount = _postSwapBalance;

        _startBridge(_hopData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /* ========== Internal Functions ========== */

    /**
     * @dev Conatains the business logic for the bridge via Hop Protocol
     * @param _hopData data specific to Hop Protocol
     */
    function _startBridge(HopData memory _hopData) internal {
        Storage storage s = getStorage();
        address sendingAssetId = _bridge(_hopData.asset).token;

        address bridge;
        if (s.hopChainId == 1) {
            bridge = _bridge(_hopData.asset).bridge;
        } else {
            bridge = _bridge(_hopData.asset).ammWrapper;
        }

        // Do HOP stuff
        require(s.hopChainId != _hopData.chainId, ""Cannot bridge to the same network."");

        // Give Hop approval to bridge tokens
        LibAsset.approveERC20(IERC20(sendingAssetId), bridge, _hopData.amount);

        uint256 value = LibAsset.isNativeAsset(address(sendingAssetId)) ? _hopData.amount : 0;

        if (s.hopChainId == 1) {
            // Ethereum L1
            IHopBridge(bridge).sendToL2{ value: value }(
                _hopData.chainId,
                _hopData.recipient,
                _hopData.amount,
                _hopData.destinationAmountOutMin,
                _hopData.destinationDeadline,
                address(0),
                0
            );
        } else {
            // L2
            // solhint-disable-next-line check-send-result
            IHopBridge(bridge).swapAndSend{ value: value }(
                _hopData.chainId,
                _hopData.recipient,
                _hopData.amount,
                _hopData.bonderFee,
                _hopData.amountOutMin,
                _hopData.deadline,
                _hopData.destinationAmountOutMin,
                _hopData.destinationDeadline
            );
        }
    }

    function _bridge(string memory _asset) internal view returns (IHopBridge.BridgeConfig memory) {
        Storage storage s = getStorage();
        return s.hopBridges[_asset];
    }

    function getStorage() internal pure returns (Storage storage s) {
        bytes32 namespace = NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}",1438
RealWorld_TA_103_DiamondLoupeFacet_RealWorld_20240812182409.log,103,DiamondLoupeFacet,67234,1227,68461,75.0,0.36071,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { LibDiamond } from ""../Libraries/LibDiamond.sol"";
import { IDiamondLoupe } from ""../Interfaces/IDiamondLoupe.sol"";
import { IERC165 } from ""../Interfaces/IERC165.sol"";

contract DiamondLoupeFacet is IDiamondLoupe, IERC165 {
    // Diamond Loupe Functions
    ////////////////////////////////////////////////////////////////////
    /// These functions are expected to be called frequently by tools.
    //
    // struct Facet {
    //     address facetAddress;
    //     bytes4[] functionSelectors;
    // }

    /// @notice Gets all facets and their selectors.
    /// @return facets_ Facet
    function facets() external view override returns (Facet[] memory facets_) {
        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
        uint256 numFacets = ds.facetAddresses.length;
        facets_ = new Facet[](numFacets);
        for (uint256 i; i < numFacets; i++) {
            address facetAddress_ = ds.facetAddresses[i];
            facets_[i].facetAddress = facetAddress_;
            facets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress_].functionSelectors;
        }
    }

    /// @notice Gets all the function selectors provided by a facet.
    /// @param _facet The facet address.
    /// @return facetFunctionSelectors_
    function facetFunctionSelectors(address _facet)
        external
        view
        override
        returns (bytes4[] memory facetFunctionSelectors_)
    {
        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
        facetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;
    }

    /// @notice Get all the facet addresses used by a diamond.
    /// @return facetAddresses_
    function facetAddresses() external view override returns (address[] memory facetAddresses_) {
        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
        facetAddresses_ = ds.facetAddresses;
    }

    /// @notice Gets the facet that supports the given selector.
    /// @dev If facet is not found return address(0).
    /// @param _functionSelector The function selector.
    /// @return facetAddress_ The facet address.
    function facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {
        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
        facetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;
    }

    // This implements ERC-165.
    function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {
        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
        return ds.supportedInterfaces[_interfaceId];
    }
}",590
RealWorld_TA_103_IAnyswapToken_RealWorld_20240812183953.log,103,IAnyswapToken,21245,1355,22600,75.0,0.133325,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IAnyswapToken {
    function underlying() external returns (address);
}",33
RealWorld_TA_103_LibBytes_RealWorld_20240812183611.log,103,LibBytes,366412,2637,369049,117.0,1.8848,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

library LibBytes {
    // solhint-disable no-inline-assembly

    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {
        bytes memory tempBytes;

        assembly {
            // Get a location of some free memory and store it in tempBytes as
            // Solidity does for memory variables.
            tempBytes := mload(0x40)

            // Store the length of the first bytes array at the beginning of
            // the memory for tempBytes.
            let length := mload(_preBytes)
            mstore(tempBytes, length)

            // Maintain a memory counter for the current write location in the
            // temp bytes array by adding the 32 bytes for the array length to
            // the starting location.
            let mc := add(tempBytes, 0x20)
            // Stop copying when the memory counter reaches the length of the
            // first bytes array.
            let end := add(mc, length)

            for {
                // Initialize a copy counter to the start of the _preBytes data,
                // 32 bytes into its memory.
                let cc := add(_preBytes, 0x20)
            } lt(mc, end) {
                // Increase both counters by 32 bytes each iteration.
                mc := add(mc, 0x20)
                cc := add(cc, 0x20)
            } {
                // Write the _preBytes data into the tempBytes memory 32 bytes
                // at a time.
                mstore(mc, mload(cc))
            }

            // Add the length of _postBytes to the current length of tempBytes
            // and store it as the new length in the first 32 bytes of the
            // tempBytes memory.
            length := mload(_postBytes)
            mstore(tempBytes, add(length, mload(tempBytes)))

            // Move the memory counter back from a multiple of 0x20 to the
            // actual end of the _preBytes data.
            mc := end
            // Stop copying when the memory counter reaches the new combined
            // length of the arrays.
            end := add(mc, length)

            for {
                let cc := add(_postBytes, 0x20)
            } lt(mc, end) {
                mc := add(mc, 0x20)
                cc := add(cc, 0x20)
            } {
                mstore(mc, mload(cc))
            }

            // Update the free-memory pointer by padding our last write location
            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the
            // next 32 byte block, then round down to the nearest multiple of
            // 32. If the sum of the length of the two arrays is zero then add
            // one before rounding down to leave a blank 32 bytes (the length block with 0).
            mstore(
                0x40,
                and(
                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),
                    not(31) // Round down to the nearest 32 bytes.
                )
            )
        }

        return tempBytes;
    }

    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {
        assembly {
            // Read the first 32 bytes of _preBytes storage, which is the length
            // of the array. (We don't need to use the offset into the slot
            // because arrays use the entire slot.)
            let fslot := sload(_preBytes.slot)
            // Arrays of 31 bytes or less have an even value in their slot,
            // while longer arrays have an odd value. The actual length is
            // the slot divided by two for odd values, and the lowest order
            // byte divided by two for even values.
            // If the slot is even, bitwise and the slot with 255 and divide by
            // two to get the length. If the slot is odd, bitwise and the slot
            // with -1 and divide by two.
            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)
            let mlength := mload(_postBytes)
            let newlength := add(slength, mlength)
            // slength can contain both the length and contents of the array
            // if length < 32 bytes so let's prepare for that
            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage
            switch add(lt(slength, 32), lt(newlength, 32))
            case 2 {
                // Since the new array still fits in the slot, we just need to
                // update the contents of the slot.
                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length
                sstore(
                    _preBytes.slot,
                    // all the modifications to the slot are inside this
                    // next block
                    add(
                        // we can just add to the slot contents because the
                        // bytes we want to change are the LSBs
                        fslot,
                        add(
                            mul(
                                div(
                                    // load the bytes from memory
                                    mload(add(_postBytes, 0x20)),
                                    // zero all bytes to the right
                                    exp(0x100, sub(32, mlength))
                                ),
                                // and now shift left the number of bytes to
                                // leave space for the length in the slot
                                exp(0x100, sub(32, newlength))
                            ),
                            // increase length by the double of the memory
                            // bytes length
                            mul(mlength, 2)
                        )
                    )
                )
            }
            case 1 {
                // The stored value fits in the slot, but the combined value
                // will exceed it.
                // get the keccak hash to get the contents of the array
                mstore(0x0, _preBytes.slot)
                let sc := add(keccak256(0x0, 0x20), div(slength, 32))

                // save new length
                sstore(_preBytes.slot, add(mul(newlength, 2), 1))

                // The contents of the _postBytes array start 32 bytes into
                // the structure. Our first read should obtain the `submod`
                // bytes that can fit into the unused space in the last word
                // of the stored array. To get this, we read 32 bytes starting
                // from `submod`, so the data we read overlaps with the array
                // contents by `submod` bytes. Masking the lowest-order
                // `submod` bytes allows us to add that value directly to the
                // stored value.

                let submod := sub(32, slength)
                let mc := add(_postBytes, submod)
                let end := add(_postBytes, mlength)
                let mask := sub(exp(0x100, submod), 1)

                sstore(
                    sc,
                    add(
                        and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00),
                        and(mload(mc), mask)
                    )
                )

                for {
                    mc := add(mc, 0x20)
                    sc := add(sc, 1)
                } lt(mc, end) {
                    sc := add(sc, 1)
                    mc := add(mc, 0x20)
                } {
                    sstore(sc, mload(mc))
                }

                mask := exp(0x100, sub(mc, end))

                sstore(sc, mul(div(mload(mc), mask), mask))
            }
            default {
                // get the keccak hash to get the contents of the array
                mstore(0x0, _preBytes.slot)
                // Start copying to the last used word of the stored array.
                let sc := add(keccak256(0x0, 0x20), div(slength, 32))

                // save new length
                sstore(_preBytes.slot, add(mul(newlength, 2), 1))

                // Copy over the first `submod` bytes of the new data as in
                // case 1 above.
                let slengthmod := mod(slength, 32)
                let submod := sub(32, slengthmod)
                let mc := add(_postBytes, submod)
                let end := add(_postBytes, mlength)
                let mask := sub(exp(0x100, submod), 1)

                sstore(sc, add(sload(sc), and(mload(mc), mask)))

                for {
                    sc := add(sc, 1)
                    mc := add(mc, 0x20)
                } lt(mc, end) {
                    sc := add(sc, 1)
                    mc := add(mc, 0x20)
                } {
                    sstore(sc, mload(mc))
                }

                mask := exp(0x100, sub(mc, end))

                sstore(sc, mul(div(mload(mc), mask), mask))
            }
        }
    }

    function slice(
        bytes memory _bytes,
        uint256 _start,
        uint256 _length
    ) internal pure returns (bytes memory) {
        require(_length + 31 >= _length, ""slice_overflow"");
        require(_bytes.length >= _start + _length, ""slice_outOfBounds"");

        bytes memory tempBytes;

        assembly {
            switch iszero(_length)
            case 0 {
                // Get a location of some free memory and store it in tempBytes as
                // Solidity does for memory variables.
                tempBytes := mload(0x40)

                // The first word of the slice result is potentially a partial
                // word read from the original array. To read it, we calculate
                // the length of that partial word and start copying that many
                // bytes into the array. The first word we copy will start with
                // data we don't care about, but the last `lengthmod` bytes will
                // land at the beginning of the contents of the new array. When
                // we're done copying, we overwrite the full first word with
                // the actual length of the slice.
                let lengthmod := and(_length, 31)

                // The multiplication in the next line is necessary
                // because when slicing multiples of 32 bytes (lengthmod == 0)
                // the following copy loop was copying the origin's length
                // and then ending prematurely not copying everything it should.
                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))
                let end := add(mc, _length)

                for {
                    // The multiplication in the next line has the same exact purpose
                    // as the one above.
                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)
                } lt(mc, end) {
                    mc := add(mc, 0x20)
                    cc := add(cc, 0x20)
                } {
                    mstore(mc, mload(cc))
                }

                mstore(tempBytes, _length)

                //update free-memory pointer
                //allocating the array padded to 32 bytes like the compiler does now
                mstore(0x40, and(add(mc, 31), not(31)))
            }
            //if we want a zero-length slice let's just return a zero-length array
            default {
                tempBytes := mload(0x40)
                //zero out the 32 bytes slice we are about to return
                //we need to do it because Solidity does not garbage collect
                mstore(tempBytes, 0)

                mstore(0x40, add(tempBytes, 0x20))
            }
        }

        return tempBytes;
    }

    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {
        require(_bytes.length >= _start + 20, ""toAddress_outOfBounds"");
        address tempAddress;

        assembly {
            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)
        }

        return tempAddress;
    }

    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {
        require(_bytes.length >= _start + 1, ""toUint8_outOfBounds"");
        uint8 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x1), _start))
        }

        return tempUint;
    }

    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {
        require(_bytes.length >= _start + 2, ""toUint16_outOfBounds"");
        uint16 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x2), _start))
        }

        return tempUint;
    }

    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {
        require(_bytes.length >= _start + 4, ""toUint32_outOfBounds"");
        uint32 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x4), _start))
        }

        return tempUint;
    }

    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {
        require(_bytes.length >= _start + 8, ""toUint64_outOfBounds"");
        uint64 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x8), _start))
        }

        return tempUint;
    }

    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {
        require(_bytes.length >= _start + 12, ""toUint96_outOfBounds"");
        uint96 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0xc), _start))
        }

        return tempUint;
    }

    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {
        require(_bytes.length >= _start + 16, ""toUint128_outOfBounds"");
        uint128 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x10), _start))
        }

        return tempUint;
    }

    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {
        require(_bytes.length >= _start + 32, ""toUint256_outOfBounds"");
        uint256 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x20), _start))
        }

        return tempUint;
    }

    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {
        require(_bytes.length >= _start + 32, ""toBytes32_outOfBounds"");
        bytes32 tempBytes32;

        assembly {
            tempBytes32 := mload(add(add(_bytes, 0x20), _start))
        }

        return tempBytes32;
    }

    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {
        bool success = true;

        assembly {
            let length := mload(_preBytes)

            // if lengths don't match the arrays are not equal
            switch eq(length, mload(_postBytes))
            case 1 {
                // cb is a circuit breaker in the for loop since there's
                //  no said feature for inline assembly loops
                // cb = 1 - don't breaker
                // cb = 0 - break
                let cb := 1

                let mc := add(_preBytes, 0x20)
                let end := add(mc, length)

                for {
                    let cc := add(_postBytes, 0x20)
                    // the next line is the loop condition:
                    // while(uint256(mc < end) + cb == 2)
                } eq(add(lt(mc, end), cb), 2) {
                    mc := add(mc, 0x20)
                    cc := add(cc, 0x20)
                } {
                    // if any of these checks fails then arrays are not equal
                    if iszero(eq(mload(mc), mload(cc))) {
                        // unsuccess:
                        success := 0
                        cb := 0
                    }
                }
            }
            default {
                // unsuccess:
                success := 0
            }
        }

        return success;
    }

    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {
        bool success = true;

        assembly {
            // we know _preBytes_offset is 0
            let fslot := sload(_preBytes.slot)
            // Decode the length of the stored array like in concatStorage().
            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)
            let mlength := mload(_postBytes)

            // if lengths don't match the arrays are not equal
            switch eq(slength, mlength)
            case 1 {
                // slength can contain both the length and contents of the array
                // if length < 32 bytes so let's prepare for that
                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage
                if iszero(iszero(slength)) {
                    switch lt(slength, 32)
                    case 1 {
                        // blank the last byte which is the length
                        fslot := mul(div(fslot, 0x100), 0x100)

                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {
                            // unsuccess:
                            success := 0
                        }
                    }
                    default {
                        // cb is a circuit breaker in the for loop since there's
                        //  no said feature for inline assembly loops
                        // cb = 1 - don't breaker
                        // cb = 0 - break
                        let cb := 1

                        // get the keccak hash to get the contents of the array
                        mstore(0x0, _preBytes.slot)
                        let sc := keccak256(0x0, 0x20)

                        let mc := add(_postBytes, 0x20)
                        let end := add(mc, mlength)

                        // the next line is the loop condition:
                        // while(uint256(mc < end) + cb == 2)
                        // solhint-disable-next-line no-empty-blocks
                        for {

                        } eq(add(lt(mc, end), cb), 2) {
                            sc := add(sc, 1)
                            mc := add(mc, 0x20)
                        } {
                            if iszero(eq(sload(sc), mload(mc))) {
                                // unsuccess:
                                success := 0
                                cb := 0
                            }
                        }
                    }
                }
            }
            default {
                // unsuccess:
                success := 0
            }
        }

        return success;
    }
}",4136
RealWorld_TA_103_LibSwap_RealWorld_20240812183811.log,103,LibSwap,56327,3081,59408,100.0,0.343255,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { LibAsset, IERC20 } from ""./LibAsset.sol"";
import { LibUtil } from ""./LibUtil.sol"";

library LibSwap {
    uint256 private constant MAX_INT = 2**256 - 1;

    struct SwapData {
        address callTo;
        address approveTo;
        address sendingAssetId;
        address receivingAssetId;
        uint256 fromAmount;
        bytes callData;
    }

    event AssetSwapped(
        bytes32 transactionId,
        address dex,
        address fromAssetId,
        address toAssetId,
        uint256 fromAmount,
        uint256 toAmount,
        uint256 timestamp
    );

    function swap(bytes32 transactionId, SwapData calldata _swapData) internal {
        uint256 fromAmount = _swapData.fromAmount;
        uint256 toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId);
        address fromAssetId = _swapData.sendingAssetId;
        if (!LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {
            LibAsset.transferFromERC20(fromAssetId, msg.sender, address(this), fromAmount);
        }

        if (!LibAsset.isNativeAsset(fromAssetId)) {
            LibAsset.approveERC20(IERC20(fromAssetId), _swapData.approveTo, fromAmount);
        }

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData);
        if (!success) {
            string memory reason = LibUtil.getRevertMsg(res);
            revert(reason);
        }

        toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount;
        emit AssetSwapped(
            transactionId,
            _swapData.callTo,
            _swapData.sendingAssetId,
            _swapData.receivingAssetId,
            fromAmount,
            toAmount,
            block.timestamp
        );
    }
}",439
RealWorld_TA_103_AnyswapFacet_RealWorld_20240812182828.log,103,AnyswapFacet,140561,2857,143418,94.0,0.759945,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { ILiFi } from ""../Interfaces/ILiFi.sol"";
import { IAnyswapRouter } from ""../Interfaces/IAnyswapRouter.sol"";
import { LibDiamond } from ""../Libraries/LibDiamond.sol"";
import { LibAsset, IERC20 } from ""../Libraries/LibAsset.sol"";
import { IAnyswapToken } from ""../Interfaces/IAnyswapToken.sol"";
import { LibDiamond } from ""../Libraries/LibDiamond.sol"";
import ""./Swapper.sol"";

/**
 * @title Anyswap Facet
 * @author Li.Finance (https://li.finance)
 * @notice Provides functionality for bridging through Multichain (Prev. AnySwap)
 */
contract AnyswapFacet is ILiFi, Swapper {
    /* ========== Types ========== */

    struct AnyswapData {
        address token;
        address router;
        uint256 amount;
        address recipient;
        uint256 toChainId;
    }

    /* ========== Public Bridge Functions ========== */

    /**
     * @notice Bridges tokens via Anyswap
     * @param _lifiData data used purely for tracking and analytics
     * @param _anyswapData data specific to Anyswap
     */
    function startBridgeTokensViaAnyswap(LiFiData memory _lifiData, AnyswapData calldata _anyswapData) public payable {
        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();
        if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {
            if (underlyingToken == address(0)) {
                underlyingToken = _anyswapData.token;
            }

            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);
            LibAsset.transferFromERC20(underlyingToken, msg.sender, address(this), _anyswapData.amount);

            require(
                LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount,
                ""ERR_INVALID_AMOUNT""
            );
        } else {
            require(msg.value == _anyswapData.amount, ""ERR_INVALID_AMOUNT"");
        }

        _startBridge(_anyswapData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /**
     * @notice Performs a swap before bridging via Anyswap
     * @param _lifiData data used purely for tracking and analytics
     * @param _swapData an array of swap related data for performing swaps before bridging
     * @param _anyswapData data specific to Anyswap
     */
    function swapAndStartBridgeTokensViaAnyswap(
        LiFiData memory _lifiData,
        LibSwap.SwapData[] calldata _swapData,
        AnyswapData memory _anyswapData
    ) public payable {
        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();
        if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {
            if (underlyingToken == address(0)) {
                underlyingToken = _anyswapData.token;
            }

            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);

            // Swap
            _executeSwaps(_lifiData, _swapData);

            uint256 _postSwapBalance = LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance;

            require(_postSwapBalance > 0, ""ERR_INVALID_AMOUNT"");

            _anyswapData.amount = _postSwapBalance;
        } else {
            uint256 _fromBalance = address(this).balance;

            // Swap
            _executeSwaps(_lifiData, _swapData);

            require(address(this).balance - _fromBalance >= _anyswapData.amount, ""ERR_INVALID_AMOUNT"");

            uint256 _postSwapBalance = address(this).balance - _fromBalance;

            require(_postSwapBalance > 0, ""ERR_INVALID_AMOUNT"");

            _anyswapData.amount = _postSwapBalance;
        }

        _startBridge(_anyswapData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /* ========== Internal Functions ========== */

    /**
     * @dev Conatains the business logic for the bridge via Anyswap
     * @param _anyswapData data specific to Anyswap
     */
    function _startBridge(AnyswapData memory _anyswapData) internal {
        // Check chain id
        require(block.chainid != _anyswapData.toChainId, ""Cannot bridge to the same network."");
        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();

        if (underlyingToken == IAnyswapRouter(_anyswapData.router).wNATIVE()) {
            IAnyswapRouter(_anyswapData.router).anySwapOutNative{ value: _anyswapData.amount }(
                _anyswapData.token,
                _anyswapData.recipient,
                _anyswapData.toChainId
            );
            return;
        }

        if (_anyswapData.token != address(0)) {
            // Has underlying token?
            if (underlyingToken != address(0)) {
                // Give Anyswap approval to bridge tokens
                LibAsset.approveERC20(IERC20(underlyingToken), _anyswapData.router, _anyswapData.amount);

                IAnyswapRouter(_anyswapData.router).anySwapOutUnderlying(
                    _anyswapData.token,
                    _anyswapData.recipient,
                    _anyswapData.amount,
                    _anyswapData.toChainId
                );
            } else {
                // Give Anyswap approval to bridge tokens
                LibAsset.approveERC20(IERC20(_anyswapData.token), _anyswapData.router, _anyswapData.amount);

                IAnyswapRouter(_anyswapData.router).anySwapOut(
                    _anyswapData.token,
                    _anyswapData.recipient,
                    _anyswapData.amount,
                    _anyswapData.toChainId
                );
            }
        }
    }
}",1495
RealWorld_TA_103_IERC173_RealWorld_20240812185156.log,103,IERC173,34016,1961,35977,86.0,0.2093,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

/// @title ERC-173 Contract Ownership Standard
///  Note: the ERC-165 identifier for this interface is 0x7f5828d0
/* is ERC165 */
interface IERC173 {
    /// @dev This emits when ownership of a contract changes.
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /// @notice Get the address of the owner
    /// @return owner_ The address of the owner.
    function owner() external view returns (address owner_);

    /// @notice Set the address of the new owner of the contract
    /// @dev Set _newOwner to address(0) to renounce any ownership.
    /// @param _newOwner The address of the new owner of the contract
    function transferOwnership(address _newOwner) external;
}",184
RealWorld_TA_103_IDiamondCut_RealWorld_20240812184353.log,103,IDiamondCut,37407,1480,38887,69.0,0.216635,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IDiamondCut {
    enum FacetCutAction {
        Add,
        Replace,
        Remove
    }
    // Add=0, Replace=1, Remove=2

    struct FacetCut {
        address facetAddress;
        FacetCutAction action;
        bytes4[] functionSelectors;
    }

    /// @notice Add/replace/remove any number of functions and optionally execute
    ///         a function with delegatecall
    /// @param _diamondCut Contains the facet addresses and function selectors
    /// @param _init The address of the contract or facet to execute _calldata
    /// @param _calldata A function call, including function selector and arguments
    ///                  _calldata is executed with delegatecall on _init
    function diamondCut(
        FacetCut[] calldata _diamondCut,
        address _init,
        bytes calldata _calldata
    ) external;

    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);
}",226
RealWorld_TA_103_IDiamondLoupe_RealWorld_20240812184925.log,103,IDiamondLoupe,41303,1275,42578,78.0,0.232015,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

// A loupe is a small magnifying glass used to look at diamonds.
// These functions look at diamonds
interface IDiamondLoupe {
    /// These functions are expected to be called frequently
    /// by tools.

    struct Facet {
        address facetAddress;
        bytes4[] functionSelectors;
    }

    /// @notice Gets all facet addresses and their four byte function selectors.
    /// @return facets_ Facet
    function facets() external view returns (Facet[] memory facets_);

    /// @notice Gets all the function selectors supported by a specific facet.
    /// @param _facet The facet address.
    /// @return facetFunctionSelectors_
    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);

    /// @notice Get all the facet addresses used by a diamond.
    /// @return facetAddresses_
    function facetAddresses() external view returns (address[] memory facetAddresses_);

    /// @notice Gets the facet that supports the given selector.
    /// @dev If facet is not found return address(0).
    /// @param _functionSelector The function selector.
    /// @return facetAddress_ The facet address.
    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);
}",276
RealWorld_TA_103_LibUtil_RealWorld_20240812183311.log,103,LibUtil,30506,1214,31720,82.0,0.17681,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""./LibBytes.sol"";

library LibUtil {
    using LibBytes for bytes;

    function getRevertMsg(bytes memory _res) internal pure returns (string memory) {
        // If the _res length is less than 68, then the transaction failed silently (without a revert message)
        if (_res.length < 68) return ""Transaction reverted silently"";
        bytes memory revertData = _res.slice(4, _res.length - 4); // Remove the selector which is the first 4 bytes
        return abi.decode(revertData, (string)); // All that remains is the revert string
    }
}",145
RealWorld_TA_103_DiamondCutFacet_RealWorld_20240812181434.log,103,DiamondCutFacet,35756,1987,37743,74.0,0.21852,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { IDiamondCut } from ""../Interfaces/IDiamondCut.sol"";
import { LibDiamond } from ""../Libraries/LibDiamond.sol"";

contract DiamondCutFacet is IDiamondCut {
    /// @notice Add/replace/remove any number of functions and optionally execute
    ///         a function with delegatecall
    /// @param _diamondCut Contains the facet addresses and function selectors
    /// @param _init The address of the contract or facet to execute _calldata
    /// @param _calldata A function call, including function selector and arguments
    ///                  _calldata is executed with delegatecall on _init
    function diamondCut(
        FacetCut[] calldata _diamondCut,
        address _init,
        bytes calldata _calldata
    ) external override {
        LibDiamond.enforceIsContractOwner();
        LibDiamond.diamondCut(_diamondCut, _init, _calldata);
    }
}",209
RealWorld_TA_103_LibDiamond_RealWorld_20240812183114.log,103,LibDiamond,200791,3406,204197,114.0,1.072075,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { IDiamondCut } from ""../Interfaces/IDiamondCut.sol"";

library LibDiamond {
    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(""diamond.standard.diamond.storage"");

    struct FacetAddressAndPosition {
        address facetAddress;
        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array
    }

    struct FacetFunctionSelectors {
        bytes4[] functionSelectors;
        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array
    }

    struct DiamondStorage {
        // maps function selector to the facet address and
        // the position of the selector in the facetFunctionSelectors.selectors array
        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;
        // maps facet addresses to function selectors
        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;
        // facet addresses
        address[] facetAddresses;
        // Used to query if a contract implements an interface.
        // Used to implement ERC-165.
        mapping(bytes4 => bool) supportedInterfaces;
        // owner of the contract
        address contractOwner;
    }

    function diamondStorage() internal pure returns (DiamondStorage storage ds) {
        bytes32 position = DIAMOND_STORAGE_POSITION;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            ds.slot := position
        }
    }

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function setContractOwner(address _newOwner) internal {
        DiamondStorage storage ds = diamondStorage();
        address previousOwner = ds.contractOwner;
        ds.contractOwner = _newOwner;
        emit OwnershipTransferred(previousOwner, _newOwner);
    }

    function contractOwner() internal view returns (address contractOwner_) {
        contractOwner_ = diamondStorage().contractOwner;
    }

    function enforceIsContractOwner() internal view {
        require(msg.sender == diamondStorage().contractOwner, ""LibDiamond: Must be contract owner"");
    }

    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);

    // Internal function version of diamondCut
    function diamondCut(
        IDiamondCut.FacetCut[] memory _diamondCut,
        address _init,
        bytes memory _calldata
    ) internal {
        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {
            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;
            if (action == IDiamondCut.FacetCutAction.Add) {
                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);
            } else if (action == IDiamondCut.FacetCutAction.Replace) {
                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);
            } else if (action == IDiamondCut.FacetCutAction.Remove) {
                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);
            } else {
                revert(""LibDiamondCut: Incorrect FacetCutAction"");
            }
        }
        emit DiamondCut(_diamondCut, _init, _calldata);
        initializeDiamondCut(_init, _calldata);
    }

    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
        require(_functionSelectors.length > 0, ""LibDiamondCut: No selectors in facet to cut"");
        DiamondStorage storage ds = diamondStorage();
        require(_facetAddress != address(0), ""LibDiamondCut: Add facet can't be address(0)"");
        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);
        // add new facet address if it does not exist
        if (selectorPosition == 0) {
            addFacet(ds, _facetAddress);
        }
        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {
            bytes4 selector = _functionSelectors[selectorIndex];
            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;
            require(oldFacetAddress == address(0), ""LibDiamondCut: Can't add function that already exists"");
            addFunction(ds, selector, selectorPosition, _facetAddress);
            selectorPosition++;
        }
    }

    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
        require(_functionSelectors.length > 0, ""LibDiamondCut: No selectors in facet to cut"");
        DiamondStorage storage ds = diamondStorage();
        require(_facetAddress != address(0), ""LibDiamondCut: Add facet can't be address(0)"");
        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);
        // add new facet address if it does not exist
        if (selectorPosition == 0) {
            addFacet(ds, _facetAddress);
        }
        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {
            bytes4 selector = _functionSelectors[selectorIndex];
            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;
            require(oldFacetAddress != _facetAddress, ""LibDiamondCut: Can't replace function with same function"");
            removeFunction(ds, oldFacetAddress, selector);
            addFunction(ds, selector, selectorPosition, _facetAddress);
            selectorPosition++;
        }
    }

    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
        require(_functionSelectors.length > 0, ""LibDiamondCut: No selectors in facet to cut"");
        DiamondStorage storage ds = diamondStorage();
        // if function does not exist then do nothing and return
        require(_facetAddress == address(0), ""LibDiamondCut: Remove facet address must be address(0)"");
        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {
            bytes4 selector = _functionSelectors[selectorIndex];
            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;
            removeFunction(ds, oldFacetAddress, selector);
        }
    }

    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {
        enforceHasContractCode(_facetAddress, ""LibDiamondCut: New facet has no code"");
        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;
        ds.facetAddresses.push(_facetAddress);
    }

    function addFunction(
        DiamondStorage storage ds,
        bytes4 _selector,
        uint96 _selectorPosition,
        address _facetAddress
    ) internal {
        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;
        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);
        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;
    }

    function removeFunction(
        DiamondStorage storage ds,
        address _facetAddress,
        bytes4 _selector
    ) internal {
        require(_facetAddress != address(0), ""LibDiamondCut: Can't remove function that doesn't exist"");
        // an immutable function is a function defined directly in a diamond
        require(_facetAddress != address(this), ""LibDiamondCut: Can't remove immutable function"");
        // replace selector with last selector, then delete last selector
        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;
        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;
        // if not the same then replace _selector with lastSelector
        if (selectorPosition != lastSelectorPosition) {
            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];
            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;
            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);
        }
        // delete the last selector
        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();
        delete ds.selectorToFacetAndPosition[_selector];

        // if no more selectors for facet address then delete the facet address
        if (lastSelectorPosition == 0) {
            // replace facet address with last facet address and delete last facet address
            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;
            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;
            if (facetAddressPosition != lastFacetAddressPosition) {
                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];
                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;
                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;
            }
            ds.facetAddresses.pop();
            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;
        }
    }

    function initializeDiamondCut(address _init, bytes memory _calldata) internal {
        if (_init == address(0)) {
            require(_calldata.length == 0, ""LibDiamondCut: _init is address(0) but_calldata is not empty"");
        } else {
            require(_calldata.length > 0, ""LibDiamondCut: _calldata is empty but _init is not address(0)"");
            if (_init != address(this)) {
                enforceHasContractCode(_init, ""LibDiamondCut: _init address has no code"");
            }
            // solhint-disable-next-line avoid-low-level-calls
            (bool success, bytes memory error) = _init.delegatecall(_calldata);
            if (!success) {
                if (error.length > 0) {
                    // bubble up the error
                    revert(string(error));
                } else {
                    revert(""LibDiamondCut: _init function reverted"");
                }
            }
        }
    }

    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {
        uint256 contractSize;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            contractSize := extcodesize(_contract)
        }
        require(contractSize > 0, _errorMessage);
    }
}",2168
RealWorld_TA_103_GenericSwapFacet_RealWorld_20240812181256.log,103,GenericSwapFacet,50685,2916,53601,96.0,0.311745,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { ILiFi } from ""../Interfaces/ILiFi.sol"";
import { LibAsset, IERC20 } from ""../Libraries/LibAsset.sol"";
import ""./Swapper.sol"";

/**
 * @title Generic Swap Facet
 * @author Li.Finance (https://li.finance)
 * @notice Provides functionality for swapping through ANY DEX
 * @dev Uses calldata to execute arbitrary methods on DEXs
 */
contract GenericSwapFacet is ILiFi, Swapper {
    /* ========== Public Functions ========== */

    /**
     * @notice Performs a swap and that's it
     * @param _lifiData data used purely for tracking and analytics
     * @param _swapData an array of swap related data for performing swaps before bridging
     */
    function swapTokensGeneric(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) public payable {
        uint256 receivingAssetIdBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId);

        // Swap
        _executeSwaps(_lifiData, _swapData);

        uint256 postSwapBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId) - receivingAssetIdBalance;

        LibAsset.transferAsset(_lifiData.receivingAssetId, payable(msg.sender), postSwapBalance);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }
}",379
RealWorld_TA_103_ILiFi_RealWorld_20240812184111.log,103,ILiFi,45123,1326,46449,70.0,0.252135,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface ILiFi {
    /* ========== Structs ========== */

    struct LiFiData {
        bytes32 transactionId;
        string integrator;
        address referrer;
        address sendingAssetId;
        address receivingAssetId;
        address receiver;
        uint256 destinationChainId;
        uint256 amount;
    }

    /* ========== Events ========== */

    event LiFiTransferStarted(
        bytes32 indexed transactionId,
        string integrator,
        address referrer,
        address sendingAssetId,
        address receivingAssetId,
        address receiver,
        uint256 amount,
        uint256 destinationChainId,
        uint256 timestamp
    );

    event LiFiTransferCompleted(
        bytes32 indexed transactionId,
        address receivingAssetId,
        address receiver,
        uint256 amount,
        uint256 timestamp
    );

    event LiFiTransferConfirmed(
        bytes32 indexed transactionId,
        string integrator,
        address referrer,
        address sendingAssetId,
        address receivingAssetId,
        address receiver,
        uint256 amount,
        uint256 destinationChainId,
        uint256 timestamp
    );
    event LiFiTransferRefunded(
        bytes32 indexed transactionId,
        string integrator,
        address referrer,
        address sendingAssetId,
        address receivingAssetId,
        address receiver,
        uint256 amount,
        uint256 destinationChainId,
        uint256 timestamp
    );
    event Inited(address indexed bridge, uint64 chainId);
}",314
RealWorld_TA_103_NXTPFacet_RealWorld_20240812181706.log,103,NXTPFacet,166201,3958,170159,109.0,0.910165,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { ITransactionManager } from ""../Interfaces/ITransactionManager.sol"";
import { ILiFi } from ""../Interfaces/ILiFi.sol"";
import { LibAsset, IERC20 } from ""../Libraries/LibAsset.sol"";
import { LibDiamond } from ""../Libraries/LibDiamond.sol"";
import ""./Swapper.sol"";

/**
 * @title NXTP (Connext) Facet
 * @author Li.Finance (https://li.finance)
 * @notice Provides functionality for bridging through NXTP (Connext)
 */
contract NXTPFacet is ILiFi, Swapper {
    /* ========== Storage ========== */

    bytes32 internal constant NAMESPACE = keccak256(""com.lifi.facets.nxtp"");
    struct Storage {
        ITransactionManager nxtpTxManager;
    }

    /* ========== Events ========== */

    event NXTPBridgeStarted(
        bytes32 indexed lifiTransactionId,
        bytes32 nxtpTransactionId,
        ITransactionManager.TransactionData txData
    );

    /* ========== Init ========== */

    function initNXTP(ITransactionManager _txMgrAddr) external {
        Storage storage s = getStorage();
        LibDiamond.enforceIsContractOwner();
        s.nxtpTxManager = _txMgrAddr;
    }

    /* ========== Public Bridge Functions ========== */

    /**
     * @notice This function starts a cross-chain transaction using the NXTP protocol
     * @param _lifiData data used purely for tracking and analytics
     * @param _nxtpData data needed to complete an NXTP cross-chain transaction
     */
    function startBridgeTokensViaNXTP(LiFiData memory _lifiData, ITransactionManager.PrepareArgs memory _nxtpData)
        public
        payable
    {
        // Ensure sender has enough to complete the bridge transaction
        address sendingAssetId = _nxtpData.invariantData.sendingAssetId;
        if (sendingAssetId == address(0)) require(msg.value == _nxtpData.amount, ""ERR_INVALID_AMOUNT"");
        else {
            uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);
            LibAsset.transferFromERC20(sendingAssetId, msg.sender, address(this), _nxtpData.amount);
            require(
                LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance == _nxtpData.amount,
                ""ERR_INVALID_AMOUNT""
            );
        }

        // Start the bridge process
        _startBridge(_lifiData.transactionId, _nxtpData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /**
     * @notice This function performs a swap or multiple swaps and then starts a cross-chain transaction
     *         using the NXTP protocol.
     * @param _lifiData data used purely for tracking and analytics
     * @param _swapData array of data needed for swaps
     * @param _nxtpData data needed to complete an NXTP cross-chain transaction
     */
    function swapAndStartBridgeTokensViaNXTP(
        LiFiData memory _lifiData,
        LibSwap.SwapData[] calldata _swapData,
        ITransactionManager.PrepareArgs memory _nxtpData
    ) public payable {
        address sendingAssetId = _nxtpData.invariantData.sendingAssetId;
        uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);

        // Swap
        _executeSwaps(_lifiData, _swapData);

        uint256 _postSwapBalance = LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance;

        require(_postSwapBalance > 0, ""ERR_INVALID_AMOUNT"");

        _nxtpData.amount = _postSwapBalance;

        _startBridge(_lifiData.transactionId, _nxtpData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /**
     * @notice Completes a cross-chain transaction on the receiving chain using the NXTP protocol.
     * @param _lifiData data used purely for tracking and analytics
     * @param assetId token received on the receiving chain
     * @param receiver address that will receive the tokens
     * @param amount number of tokens received
     */
    function completeBridgeTokensViaNXTP(
        LiFiData memory _lifiData,
        address assetId,
        address receiver,
        uint256 amount
    ) public payable {
        if (LibAsset.isNativeAsset(assetId)) {
            require(msg.value == amount, ""INVALID_ETH_AMOUNT"");
        } else {
            require(msg.value == 0, ""ETH_WITH_ERC"");
            LibAsset.transferFromERC20(assetId, msg.sender, address(this), amount);
        }

        LibAsset.transferAsset(assetId, payable(receiver), amount);

        emit LiFiTransferCompleted(_lifiData.transactionId, assetId, receiver, amount, block.timestamp);
    }

    /**
     * @notice Performs a swap before completing a cross-chain transaction
     *         on the receiving chain using the NXTP protocol.
     * @param _lifiData data used purely for tracking and analytics
     * @param _swapData array of data needed for swaps
     * @param finalAssetId token received on the receiving chain
     * @param receiver address that will receive the tokens
     */
    function swapAndCompleteBridgeTokensViaNXTP(
        LiFiData memory _lifiData,
        LibSwap.SwapData[] calldata _swapData,
        address finalAssetId,
        address receiver
    ) public payable {
        uint256 startingBalance = LibAsset.getOwnBalance(finalAssetId);

        // Swap
        _executeSwaps(_lifiData, _swapData);

        uint256 postSwapBalance = LibAsset.getOwnBalance(finalAssetId);

        uint256 finalBalance;

        if (postSwapBalance > startingBalance) {
            finalBalance = postSwapBalance - startingBalance;
            LibAsset.transferAsset(finalAssetId, payable(receiver), finalBalance);
        }

        emit LiFiTransferCompleted(_lifiData.transactionId, finalAssetId, receiver, finalBalance, block.timestamp);
    }

    /* ========== Internal Functions ========== */

    function _startBridge(bytes32 _transactionId, ITransactionManager.PrepareArgs memory _nxtpData) internal {
        Storage storage s = getStorage();
        IERC20 sendingAssetId = IERC20(_nxtpData.invariantData.sendingAssetId);

        // Give Connext approval to bridge tokens
        LibAsset.approveERC20(IERC20(sendingAssetId), address(s.nxtpTxManager), _nxtpData.amount);

        uint256 value = LibAsset.isNativeAsset(address(sendingAssetId)) ? _nxtpData.amount : 0;

        // Initiate bridge transaction on sending chain
        ITransactionManager.TransactionData memory result = s.nxtpTxManager.prepare{ value: value }(_nxtpData);

        emit NXTPBridgeStarted(_transactionId, result.transactionId, result);
    }

    function getStorage() internal pure returns (Storage storage s) {
        bytes32 namespace = NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }

    /* ========== Getter Functions ========== */

    /**
     * @notice show the NXTP transaction manager contract address
     */
    function getNXTPTransactionManager() external view returns (address) {
        Storage storage s = getStorage();
        return address(s.nxtpTxManager);
    }
}",1721
RealWorld_TA_103_LibStorage_RealWorld_20240812183004.log,103,LibStorage,21554,1184,22738,68.0,0.13145,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

struct LibStorage {
    mapping(address => bool) dexWhitelist;
    address[] dexs;
}",37
RealWorld_TA_104_ERC721Claimable_RealWorld_20240812191945.log,104,ERC721Claimable,73306,2415,75721,96.0,0.41483,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import {MerkleProof} from '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';

abstract contract ERC721Claimable {
  bytes32 private _merkleRoot;
  mapping(address => uint256) private _claimedAmount;

  // ---------------- MODIFIER ----------------

  modifier onlyValidRoot(bytes32 root) {
    require(root != bytes32(0), 'ERC721Claimable: Not valid root');
    _;
  }

  modifier onlyClaimableSet() {
    require(claimableSet(), 'ERC721Claimable: No claimable');
    _;
  }

  modifier onlyNotClaimableSet() {
    require(!claimableSet(), 'ERC721Claimable: Claimable is already set');
    _;
  }

  // ---------------- VIEW ----------------

  function claimableSet() public view returns (bool) {
    return getMerkleRoot() != bytes32(0);
  }

  function verifyProof(
    bytes32[] memory proof,
    bytes32 root,
    bytes32 leaf
  ) public pure returns (bool) {
    return MerkleProof.verify(proof, root, leaf);
  }

  function processProof(bytes32[] memory proof, bytes32 leaf)
    public
    pure
    returns (bytes32)
  {
    return MerkleProof.processProof(proof, leaf);
  }

  /**
   * @notice Verifies whether an address can claim tokens
   * @dev 
   * @param who Claimer address
   * @param claimableAmount Amount airdropped to claimer
   * @param claimedAmount Amount of tokens claimer wants to claim
   * @param merkleProof Proof
   */
  function canClaim(
    address who,
    uint256 claimableAmount,
    uint256 claimedAmount,
    bytes32[] calldata merkleProof
  ) public view returns (bool) {
    require(
      verifyProof(merkleProof, getMerkleRoot(), getNode(who, claimableAmount)),
      'ERC721Claimable: Invalid proof'
    );

    return _claimedAmount[who] + claimedAmount <= claimableAmount;
  }

  function getMerkleRoot() public view returns (bytes32) {
    return _merkleRoot;
  }

  // ---------------- INTERNAL ----------------

  function _setMerkelRoot(bytes32 root) internal {
    _merkleRoot = root;
  }

  function _claim(address claimer, uint256 claimedAmount) internal {
    _claimedAmount[claimer] += claimedAmount;
  }

  // ---------------- PRIVATE ----------------

  /**
   * @dev get Node hash of given data.
   * @param who {address} Membership contract address
   * @param claimableAmount {uint256} token id which claiming person owns
   * @return {bytes32} node hash
   */
  function getNode(address who, uint256 claimableAmount)
    private
    pure
    returns (bytes32)
  {
    return keccak256(abi.encodePacked(who, claimableAmount));
  }
}",653
RealWorld_TA_104_ISplitter_RealWorld_20240812194133.log,104,ISplitter,21604,1750,23354,78.0,0.14302,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

interface ISplitter {
    function incrementWindow(uint256 royaltyAmount) external returns (bool);
}",36
RealWorld_TA_104_Splitter_RealWorld_20240812194253.log,104,Splitter,201057,5616,206673,154.0,1.117605,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {SplitStorage} from ""./SplitStorage.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/**
 * @title Splitter
 * Building on the work from the Uniswap team at Uniswap and Mirror.xyz Team
 */
contract Splitter is SplitStorage {
    /**** Mutable variables ****/
    uint256 public constant PERCENTAGE_SCALE = 10e5;
    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;

    // The TransferETH event is emitted after each eth transfer in the split is attempted.
    event TransferETH(
        // The account to which the transfer was attempted.
        address account,
        // The amount for transfer that was attempted.
        uint256 amount,
        // Whether or not the transfer succeeded.
        bool success
    );

    // Emits when a window is incremented.
    event WindowIncremented(uint256 currentWindow, uint256 fundsAvailable);

    /**
     * @dev Claim the funds from the all windows.
     * @param percentageAllocation {uint256} percentage of allocation to be claimed
     * @param merkleProof {bytes32} The Merkle proof of the allocation
     */
    function claimForAllWindows(
        uint256 percentageAllocation,
        bytes32[] calldata merkleProof
    ) external {
        // Make sure that the user has this allocation granted.
        require(
            verifyProof(
                merkleProof,
                merkleRoot,
                getNode(msg.sender, percentageAllocation)
            ),
            ""Invalid proof""
        );

        uint256 amount = 0;
        for (uint256 i = 0; i < currentWindow; i++) {
            if (!isClaimed(msg.sender, i)) {
                setClaimed(msg.sender, i);

                amount += scaleAmountByPercentage(
                    balanceForWindow[i],
                    percentageAllocation
                );
            }
        }

        transferSplitAsset(msg.sender, amount);
    }

    /**
     * @dev get Node hash of given data.
     * @param who {address} whitelisted user address
     * @param percentageAllocation {uint256} percentage of allocation
     * @return {bytes32} node hash
     */
    function getNode(
        address who,
        uint256 percentageAllocation
    ) private pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(
                    who,
                    percentageAllocation
                )
            );
    }

    /**
     * @dev get scaled amount from given amount and percentage.
     * @param amount {uint256} amount
     * @param scaledPercent {uint256} scaled percentage
     * @return scaledAmount {uint256} scaled amount
     */
    function scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)
        public
        pure
        returns (uint256 scaledAmount)
    {
        /*
            Example:
                If there is 100 ETH in the account, and someone has 
                an allocation of 2%, we call this with 100 as the amount, and 200
                as the scaled percent.

                To find out the amount we use, for example: (100 * 200) / (100 * 100)
                which returns 2 -- i.e. 2% of the 100 ETH balance.
         */
        scaledAmount = (amount * scaledPercent) / (10000);
    }

    /**
     * @dev claim for the given window.
     * @param window {uint256} Window to claim
     * @param scaledPercentageAllocation {uint256} percentage of allocation to be claimed
     * @param merkleProof {bytes32} The Merkle proof of the allocation
     */
    function claim(
        uint256 window,
        uint256 scaledPercentageAllocation,
        bytes32[] calldata merkleProof
    ) external {
        require(currentWindow > window, ""cannot claim for a future window"");
        require(
            !isClaimed(msg.sender, window),
            ""NFT has already claimed the given window""
        );

        setClaimed(msg.sender, window);

        require(
            verifyProof(
                merkleProof,
                merkleRoot,
                getNode(msg.sender, scaledPercentageAllocation)
            ),
            ""Invalid proof""
        );

        transferSplitAsset(
            msg.sender,
            // The absolute amount that's claimable.
            scaleAmountByPercentage(
                balanceForWindow[window],
                scaledPercentageAllocation
            )
        );
    }

    /**
     * @dev Function which handles increment window and puts amount to current window
     * @param royaltyAmount {uint256} Amount needs to be added in window.
     * @return {bool} Whether or not the window was incremented.
     */
    function incrementWindow(uint256 royaltyAmount) public returns (bool) {
        uint256 wethBalance;

        require(
            IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),
            ""Royalty Vault not supported""
        );
        require(
            IRoyaltyVault(msg.sender).getSplitter() == address(this),
            ""Unauthorised to increment window""
        );

        wethBalance = IERC20(splitAsset).balanceOf(address(this));
        require(wethBalance >= royaltyAmount, ""Insufficient funds"");

        require(royaltyAmount > 0, ""No additional funds for window"");
        balanceForWindow.push(royaltyAmount);
        currentWindow += 1;
        emit WindowIncremented(currentWindow, royaltyAmount);
        return true;
    }

    /**
     * @dev Function checks if the given window and tokenId has been claimed.
     * @param who {address} whitelisted user address
     * @param window {uint256} Window to check
     * @return {bool} Whether or not the window has been claimed.
     */
    function isClaimed(
        address who,
        uint256 window
    ) public view returns (bool) {
        return claimed[getClaimHash(who, window)];
    }

    /**** Private Functions ****/

    /**
     * @dev Function checks if the given window and tokenId has been claimed.
     * @param who {address} whitelisted user address
     * @param window {uint256} Window to check
     */
    function setClaimed(
        address who,
        uint256 window
    ) private {
        claimed[getClaimHash(who, window)] = true;
    }

    /**
     * @dev Function which returns the hash of the given window, tokenId and membershipContract.
     * @param who {address} whitelisted user address
     * @param window {uint256} Window to check
     * @return {bytes32} Hash of the given window, tokenId and membershipContract.
     */
    function getClaimHash(
        address who,
        uint256 window
    ) private pure returns (bytes32) {
        return keccak256(abi.encodePacked(who, window));
    }

    /**
     * @dev Function to convert output amount from percentages.
     * @param amount {uint256} Amount for which percentage is to be calculated.
     * @param percent {uint256} Percentage
     * @return {uint256} Output amount.
     */
    function amountFromPercent(uint256 amount, uint32 percent)
        private
        pure
        returns (uint256)
    {
        // Solidity 0.8.0 lets us do this without SafeMath.
        return (amount * percent) / 100;
    }

    /**
     * @dev Function to transfer split asset to the given address.
     * @param to {address} Address to transfer the split asset to.
     * @param value {uint256} Amount to transfer.
     */
    function transferSplitAsset(address to, uint256 value)
        private
        returns (bool didSucceed)
    {
        // Try to transfer ETH to the given recipient.
        didSucceed = IERC20(splitAsset).transfer(to, value);
        require(didSucceed, ""Failed to transfer ETH"");

        emit TransferETH(to, value, didSucceed);
    }

    /**
     * @dev transfer given amount of ETH in contract to the given address.
     * @param to {address} Address to transfer asset
     * @param value {uint256} Amount to transfer
     * @return {bool} Whether or not the transfer was successful.
     */
    function attemptETHTransfer(address to, uint256 value)
        private
        returns (bool)
    {
        // Here increase the gas limit a reasonable amount above the default, and try
        // to send ETH to the recipient.
        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.
        (bool success, ) = to.call{value: value, gas: 30000}("""");
        return success;
    }

    // From https://github.com/protofire/zeppelin-solidity/blob/master/contracts/MerkleProof.sol
    /**
     * @dev Function to verify the given proof.
     * @param proof {bytes32[]} Proof to verify
     * @param root {bytes32} Root of the Merkle tree
     * @param leaf {bytes32} Leaf to verify
     * @return {bool} Whether or not the proof is valid.
     */
    function verifyProof(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) private pure returns (bool) {
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash <= proofElement) {
                // Hash(current computed hash + current element of the proof)
                computedHash = keccak256(
                    abi.encodePacked(computedHash, proofElement)
                );
            } else {
                // Hash(current element of the proof + current computed hash)
                computedHash = keccak256(
                    abi.encodePacked(proofElement, computedHash)
                );
            }
        }

        // Check if the computed hash (root) is equal to the provided root
        return computedHash == root;
    }
}",2162
RealWorld_TA_104_Collection_RealWorld_20240812192704.log,104,Collection,24353,1355,25708,75.0,0.148865,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

struct Collection {
    bool isForSale;
    uint256 maxSupply;
    uint256 mintFee;
    string baseURI;
    string name;
    string symbol;
    string id;
    bytes32 claimsMerkleRoot;
    address payableToken;
}",71
RealWorld_TA_104_CoreProxy_RealWorld_20240812190530.log,104,CoreProxy,37391,1908,39299,80.0,0.225115,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

import {ICoreFactory} from ""../interfaces/ICoreFactory.sol"";

contract CoreProxy is Ownable {
    address private immutable _implement;

    constructor(address _imp) {
        _implement = _imp;
    }

    fallback() external {
        address _impl = implement();
        assembly {
            let ptr := mload(0x40)
            calldatacopy(ptr, 0, calldatasize())
            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)
            let size := returndatasize()
            returndatacopy(ptr, 0, size)

            switch result
            case 0 {
                revert(ptr, size)
            }
            default {
                return(ptr, size)
            }
        }
    }

    function implement() public view returns (address) {
        return _implement;
    }
}",219
RealWorld_TA_104_CoreCollection_RealWorld_20240812191013.log,104,CoreCollection,226300,17304,243604,316.0,1.47758,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {ERC721} from ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import {ERC721Enumerable} from ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

import {ERC721Payable} from ""./ERC721Payable.sol"";
import {ERC721Claimable} from ""./ERC721Claimable.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";

contract CoreCollection is
    Ownable,
    ERC721Claimable,
    ERC721Enumerable,
    ERC721Payable
{
    bool public initialized;
    string private _name;
    string private _symbol;
    string private _baseUri;
    uint256 public maxSupply;
    uint256 public startingIndex;
    uint256 public startingIndexBlock;
    string public HASHED_PROOF = """";

    event ClaimInitialized(bytes32 root);
    event NewCollectionMeta(string name, string symbol);
    event NewClaim(address claimedBy, address to, uint256 tokenId);
    event StartingIndexSet(uint256 index);
    event RoyaltyVaultInitialized(address royaltyVault);
    event NewHashedProof(string proof);
    event NewWithdrawal(address to, uint256 amount);

    constructor() ERC721("""", """") {}

    // ----------------- MODIFIER -----------------

    modifier onlyInitialized() {
        require(initialized, ""CoreCollection: Not initialized"");
        _;
    }

    modifier onlyUnInitialized() {
        require(!initialized, ""CoreCollection: Already initialized"");
        _;
    }

    modifier onlyValidSupply(uint256 _maxSupply) {
        require(
            _maxSupply > 0,
            ""CoreCollection: Max supply should be greater than 0""
        );
        _;
    }

    modifier tokenExists(uint256 _tokenId) {
        require(_exists(_tokenId), ""CoreCollection: Invalid token id"");
        _;
    }

    // ----------------- EXTERNAL -----------------

    /**
     * @notice Initializes the collection
     * @dev This method is being called from the CoreFactory contract
     * @param _collectionName Name of the collection
     * @param _collectionSymbol Symbol of the collection
     * @param _collectionURI Base URI for the collection
     * @param _maxSupply The maximum number of tokens that can be minted
     * @param _mintFee The price of a token in this collection
     * @param _payableToken The address of the ERC20 this collection uses to settle transactions
     * @param _isForSale Whether or not tokens from this collection can be purchased. If false, tokens can only be claimed
     * @param _splitFactory base URI for the collection
     */
    function initialize(
        string memory _collectionName,
        string memory _collectionSymbol,
        string memory _collectionURI,
        uint256 _maxSupply,
        uint256 _mintFee,
        address _payableToken,
        bool _isForSale,
        address _splitFactory
    ) external onlyOwner onlyValidSupply(_maxSupply) {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        _baseUri = _collectionURI;
        maxSupply = _maxSupply;
        mintFee = _mintFee;
        payableToken = IERC20(_payableToken);
        isForSale = _isForSale;
        splitFactory = _splitFactory;
        initialized = true;
    }

    /**
     * @notice Allows the collection owner to airdrop tokens
     * @dev The Merkle tree defines for each address how much token can be claimed
     * @dev This method can only be called once
     * @param _root A Merkle root
     */
    function initializeClaims(bytes32 _root)
        external
        onlyOwner
        onlyNotClaimableSet
        onlyValidRoot(_root)
    {
        _setMerkelRoot(_root);
        emit ClaimInitialized(_root);
    }

    /**
     * @notice Allows the collection owner to change the collection's name and symbol
     * @dev This function is only callable by the collection's owner
     * @param _collectionName A collection name
     * @param _collectionSymbol A collection symbol
     */
    function setCollectionMeta(
        string memory _collectionName,
        string memory _collectionSymbol
    ) external onlyOwner {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        emit NewCollectionMeta(_collectionName, _collectionSymbol);
    }

    /**
     * @notice This function is called to mint tokens from this ERC721 collection
     * @dev The collection must be initialized first
     * @param to Token recipient
     * @param isClaim Whether the user want claim a token that has been airdropped to him or want to purchase the token
     * @param claimableAmount The amount of tokens the user has been airdropped
     * @param amount The amount of tokens the user wants to mint
     * @param merkleProof A merkle proof. Needed to verify if the user can claim a token
     */
    function mintToken(
        address to,
        bool isClaim,
        uint256 claimableAmount,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external onlyInitialized {
        require(amount > 0, ""CoreCollection: Amount should be greater than 0"");
        require(
            totalSupply() + amount <= maxSupply,
            ""CoreCollection: Over Max Supply""
        );

        if (isClaim) {
            require(claimableSet(), ""CoreCollection: No claimable"");
            require(
                canClaim(msg.sender, claimableAmount, amount, merkleProof),
                ""CoreCollection: Can't claim""
            );
            _claim(msg.sender, amount);
        } else {
            require(isForSale, ""CoreCollection: Not for sale"");
            if (mintFee > 0) {
                _handlePayment(mintFee * amount);
            }
        }

        batchMint(to, amount, isClaim);
    }

    /**
     * @notice Allows the contract owner to withdraw the funds generated by the token sales
     * @dev If a royalty vault isn't set, tokens are kept within this contract and can be withdrawn by the token owner
     */
    function withdraw() external onlyOwner {
        uint256 amount = payableToken.balanceOf(address(this));
        payableToken.transferFrom(address(this), msg.sender, amount);
        emit NewWithdrawal(msg.sender, amount);
    }

    /**
     * @notice Set royalty vault address for collection
     * @dev All revenue (Primary sales + royalties from secondardy sales) 
     * from the collection are transferred to the vault when the vault is initialized
     * @param _royaltyVault The address of the royalty vault
     */
    function setRoyaltyVault(address _royaltyVault)
        external
        onlyVaultUninitialized
    {
        require(
            msg.sender == splitFactory || msg.sender == owner(),
            ""CoreCollection: Only Split Factory or owner can initialize vault.""
        );
        royaltyVault = _royaltyVault;
        emit RoyaltyVaultInitialized(_royaltyVault);
    }

    /**
     * @notice Set a provenance hash
     * @dev This hash is used to verify the minting ordering of a collection ( la BAYC)
     * This hash is generated off-chain
     * @param _proof The SHA256 generated hash
     */
    function setHashedProof(string calldata _proof) external onlyOwner {
        require(
            bytes(HASHED_PROOF).length == 0,
            ""CoreCollection: Hashed Proof is set""
        );

        HASHED_PROOF = _proof;
        emit NewHashedProof(_proof);
    }

    // ----------------- PUBLIC -----------------

    /**
     * @notice Set the mint starting index
     * @dev The starting index can only be generated once
     */
    function setStartingIndex() public {
        require(
            startingIndex == 0,
            ""CoreCollection: Starting index is already set""
        );

        startingIndex =
            (uint256(
                keccak256(abi.encodePacked(""CoreCollection"", block.number))
            ) % maxSupply) +
            1;
        startingIndexBlock = uint256(block.number);
        emit StartingIndexSet(startingIndex);
    }

    // ---------------- VIEW ----------------

    function name() public view override returns (string memory) {
        return _name;
    }

    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    function baseURI() public view returns (string memory) {
        return _baseUri;
    }

    function _baseURI() internal view override returns (string memory) {
        return _baseUri;
    }

    // ---------------- PRIVATE ----------------

    /**
     * @notice Mint token
     * @dev A starting index is calculated at the time of first mint
     * returns a tokenId
     * @param _to Token recipient
     */
    function mint(address _to) private returns (uint256 tokenId) {
        if (startingIndex == 0) {
            setStartingIndex();
        }
        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;
        _mint(_to, tokenId);
    }

    /**
     * @notice Mint tokens in batch
     * @param _to Token recipient
     * @param _amount Number of tokens to include in batch
     * @param _isClaim Whether the batch mint is an airdrop or not
     */
    function batchMint(
        address _to,
        uint256 _amount,
        bool _isClaim
    ) private {
        for (uint256 i = 0; i < _amount; i++) {
            uint256 tokenId = mint(_to);
            if (_isClaim) {
                emit NewClaim(msg.sender, _to, tokenId);
            }
        }
    }

    // ---------------- INTERNAL ----------------

    /**
     * @notice This hook transfers tokens sitting in the royalty vault to the split contract
     * @dev The split contract is a contract that allows a team to share revenue together
     * @param _from Transfer sender
     * @param _to Transfer recipient
     * @param _tokenId TokenId of token being transferred
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _tokenId
    ) internal virtual override {
        super._beforeTokenTransfer(_from, _to, _tokenId);

        if (
            royaltyVault != address(0) &&
            IRoyaltyVault(royaltyVault).getVaultBalance() > 0
        ) {
            IRoyaltyVault(royaltyVault).sendToSplitter();
        }
    }
}",2331
RealWorld_TA_104_ERC721Payable_RealWorld_20240812191806.log,104,ERC721Payable,47897,2288,50185,97.0,0.285245,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';

abstract contract ERC721Payable {
  uint256 public mintFee;
  IERC20 public payableToken;
  bool public isForSale;
  address public royaltyVault;
  address public splitFactory;
  event NewPayment(
    address from,
    address to,
    uint256 amount,
    bool royaltyVaultPayment
  );

  // ---------------- MODIFIER ----------------

  modifier onlyVaultUninitialized() {
    require(
      !royaltyVaultInitialized(),
      'CoreCollection: Royalty Vault already initialized'
    );
    _;
  }

  modifier onlyVaultInitialized() {
    require(
      royaltyVaultInitialized(),
      'CoreCollection: Royalty Vault not initialized'
    );
    _;
  }

  // ---------------- VIEW ----------------

  function royaltyVaultInitialized() public view returns (bool) {
    return royaltyVault != address(0);
  }

  // ---------------- INTERNAL ----------------

  /**
   * @notice Handles the transfer of ERC20 tokens when a token gets minted
   * @dev Tokens are transferred to the Royalty Vault if the vault is set
   * Otherwise, tokens get transferred to the ERC721 collection contract
   * @param _amount The amount of ERC20 to be transferred
   */
  function _handlePayment(uint256 _amount) internal {
    address recipient = royaltyVaultInitialized()
      ? royaltyVault
      : address(this);
    payableToken.transferFrom(msg.sender, recipient, _amount);
    emit NewPayment(msg.sender, recipient, _amount, royaltyVaultInitialized());
  }
}",351
RealWorld_TA_104_ProxyVault_RealWorld_20240812193435.log,104,ProxyVault,50486,3609,54095,101.0,0.32461,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {VaultStorage} from ""./VaultStorage.sol"";
import {IVaultFactory} from ""../interfaces/IVaultFactory.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

contract ProxyVault is VaultStorage, Ownable {
    address internal royaltyVault;

    /**
     *  @dev This is the constructor of the ProxyVault contract.
     *  It is called when the ProxyVault is created.
     *  It sets the variable royaltyVault to the address of the RoyaltyVault contract.
     */
    constructor() {
        royaltyVault = IVaultFactory(msg.sender).royaltyVault();
        splitterProxy = IVaultFactory(msg.sender).splitterProxy();
        royaltyAsset = IVaultFactory(msg.sender).royaltyAsset();
        platformFee = IVaultFactory(msg.sender).platformFee();
        platformFeeRecipient = IVaultFactory(msg.sender).platformFeeRecipient();
    }

    /**
     *  @dev This function is called when the ProxyVault is called, it points to the RoyaltyVault contract.
     */

    fallback() external payable {
        address _impl = royaltyVault;
        assembly {
            let ptr := mload(0x40)
            calldatacopy(ptr, 0, calldatasize())
            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)
            let size := returndatasize()
            returndatacopy(ptr, 0, size)

            switch result
            case 0 {
                revert(ptr, size)
            }
            default {
                return(ptr, size)
            }
        }
    }

    receive() external payable {}
}",360
RealWorld_TA_104_MockSplitter_RealWorld_20240812192123.log,104,MockSplitter,22683,2691,25374,85.0,0.167235,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {Splitter} from ""@chestrnft/splits/contracts/Splitter.sol"";

contract MockSplitter is Splitter {}",44
RealWorld_TA_104_CoreFactory_RealWorld_20240812190828.log,104,CoreFactory,105965,3187,109152,102.0,0.593565,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import {CoreProxy} from './CoreProxy.sol';
import './utils/structs/Collection.sol';
import {CoreCollection} from './CoreCollection.sol';
import {ICoreCollection} from '../interfaces/ICoreCollection.sol';

contract CoreFactory {
  struct Project {
    string id;
    address creator;
  }

  event NewProject(string id, address creator);
  event NewCollection(
    string collectionId,
    address collection,
    string projectId
  );

  address public immutable collection;
  address public immutable splitFactory;
  mapping(string => Project) public projects;
  mapping(string => address) public collections;

  constructor(address _collection, address _splitFactory) {
    collection = _collection;
    splitFactory = _splitFactory;
  }

  // ---------------- MODIFIER ----------------

  modifier onlyAvailableProject(string memory _projectId) {
    require(
      projects[_projectId].creator == address(0),
      'CoreFactory: Unavailable project id'
    );
    _;
  }

  modifier onlyProjectOwner(string memory _projectId) {
    require(
      projects[_projectId].creator == msg.sender,
      'CoreFactory: Not an owner of the project'
    );
    _;
  }

  modifier onlyAvailableCollection(string memory _collectionId) {
    require(
      collections[_collectionId] == address(0),
      'CoreFactory: Unavailable collection id'
    );
    _;
  }

  // ---------------- EXTERNAL ----------------

  /**
   * @notice Allows to create a project as well as deploy its collection(s)
   * For adding a collection to a project, use the addCollection() method.
   * @dev Projects have unique identifiers.
   * Collections are deployed using a proxy pattern. This is mainly for gas optimization purposes
   * and to support future contract upgrades.
   * Collections ownership are transferred to the caller.
   * @param _projectId Project id which is a unique identifier
   * @param _collections An array of Collection that needs to be deployed
   */
  function createProject(
    string memory _projectId,
    Collection[] memory _collections
  ) external onlyAvailableProject(_projectId) {
    require(
      _collections.length > 0,
      'CoreFactory: should have more at least one collection'
    );

    for (uint256 i; i < _collections.length; i++) {
      Collection memory _collection = _collections[i];
      address coreCollection = _createCollection(_collection);

      if (_collection.claimsMerkleRoot != bytes32(0)) {
        ICoreCollection(coreCollection).initializeClaims(
          _collection.claimsMerkleRoot
        );
      }

      emit NewCollection(_collection.id, coreCollection, _projectId);

      ICoreCollection(coreCollection).transferOwnership(msg.sender);
    }
    Project memory project;
    project.id = _projectId;
    project.creator = msg.sender;
    projects[_projectId] = project;

    emit NewProject(_projectId, msg.sender);
  }

  /**
   * @notice Allows to add a collection to a project
   * @dev Can only be called by project creator
   * Collection's ownership is transferred to the caller
   * @param _projectId Project id which is a unique identifier
   * @param _collection Collection that needs to be deployed
   */
  function addCollection(
    string memory _projectId,
    Collection memory _collection
  ) external onlyProjectOwner(_projectId) returns (address) {
    address coreCollection = _createCollection(_collection);

    if (_collection.claimsMerkleRoot != bytes32(0)) {
      ICoreCollection(coreCollection).initializeClaims(
        _collection.claimsMerkleRoot
      );
    }

    emit NewCollection(_collection.id, coreCollection, _projectId);

    ICoreCollection(coreCollection).transferOwnership(msg.sender);
    return coreCollection;
  }

  // ---------------- VIEW ----------------

  function getProject(string memory _projectId)
    external
    view
    returns (Project memory)
  {
    return projects[_projectId];
  }

  // ---------------- PRIVATE ----------------

  /**
   * @notice Instanciates/Deploys a collection
   * @param _collection Collection that needs to be deployed
   */
  function _createCollection(Collection memory _collection)
    private
    onlyAvailableCollection(_collection.id)
    returns (address)
  {
    address coreCollection = address(
      new CoreProxy{salt: keccak256(abi.encodePacked(_collection.id))}(
        collection
      )
    );

    ICoreCollection(coreCollection).initialize(
      _collection.name,
      _collection.symbol,
      _collection.baseURI,
      _collection.maxSupply,
      _collection.mintFee,
      _collection.payableToken,
      _collection.isForSale,
      splitFactory
    );

    collections[_collection.id] = coreCollection;
    return coreCollection;
  }
}",1022
RealWorld_TA_104_IRoyaltyVault_RealWorld_20240812193844.log,104,IRoyaltyVault,27552,1776,29328,88.0,0.17328,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

interface IRoyaltyVault {
    function getSplitter() external view returns (address);

    function getVaultBalance() external view returns (uint256);

    function sendToSplitter() external;

    function setPlatformFee(uint256 _platformFee) external;

    function setPlatformFeeRecipient(address _platformFeeRecipient) external;

    function supportsInterface(bytes4 _interfaceId)
        external
        view
        returns (bool);
}",105
RealWorld_TA_104_MockRoyaltyVault_RealWorld_20240812192251.log,104,MockRoyaltyVault,22976,2323,25299,86.0,0.16134,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {RoyaltyVault} from ""@chestrnft/royalty-vault/contracts/RoyaltyVault.sol"";

contract MockRoyaltyVault is RoyaltyVault {}",51
RealWorld_TA_104_ICoreFactory_RealWorld_20240812192821.log,104,ICoreFactory,22171,1304,23475,75.0,0.136935,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

interface ICoreFactory {
    function collection() external view returns (address);
    function splitFactory() external view returns (address);
}",45
RealWorld_TA_104_CoreMultiSig_RealWorld_20240812190652.log,104,CoreMultiSig,33508,2855,36363,94.0,0.22464,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import {MultiSigWallet} from ""./MultiSigWallet.sol"";

contract CoreMultiSig is MultiSigWallet {
    using SafeERC20 for IERC20;

    constructor(address[] memory _owners, uint256 _required)
        MultiSigWallet(_owners, _required)
    {}

    function withdraw(
        address token,
        address to,
        uint256 amount
    ) external onlyWallet {
        require(IERC20(token).balanceOf(address(this)) >= amount);
        IERC20(token).safeTransfer(to, amount);
    }
}",175
RealWorld_TA_104_MockRoyaltyVault_RealWorld_20240812195016.log,104,MockRoyaltyVault,23013,2255,25268,80.0,0.160165,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {RoyaltyVault} from ""@chestrnft/royalty-vault/contracts/RoyaltyVault.sol"";

contract MockRoyaltyVault is RoyaltyVault {}",51
RealWorld_TA_104_MyNFT_RealWorld_20240812195423.log,104,MyNFT,30647,1737,32384,84.0,0.187975,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/utils/Counters.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyNFT is ERC721, Ownable {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;

    constructor() ERC721(""MyNFT"", ""NFT"") {}

    function mintNFT(address recipient) public onlyOwner returns (uint256) {
        _tokenIds.increment();

        uint256 newItemId = _tokenIds.current();
        _mint(recipient, newItemId);

        return newItemId;
    }
}",153
RealWorld_TA_104_MockERC20_RealWorld_20240812192419.log,104,MockERC20,25447,1529,26976,80.0,0.157815,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MockERC20 is ERC20 {
    uint256 public constant MAX_SUPPLY = 1000000000 * 10**18;

    constructor() ERC20(""TestToken"", ""tT"") {
        _mint(msg.sender, MAX_SUPPLY);
    }
}",87
RealWorld_TA_104_ICoreCollection_RealWorld_20240812195720.log,104,ICoreCollection,22881,1822,24703,78.0,0.150845,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

interface ICoreCollection {
    function setRoyaltyVault(address _royaltyVault) external;
    function owner() external view returns (address);
}",46
RealWorld_TA_104_MockSplitFactory_RealWorld_20240812192542.log,104,MockSplitFactory,24390,1674,26064,79.0,0.15543,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {SplitFactory} from ""@chestrnft/splits/contracts/SplitFactory.sol"";

contract MockSplitFactory is SplitFactory {
    constructor(address _splitter, address _royaltyVault)
        SplitFactory(_splitter, _royaltyVault)
    {}
}",72
RealWorld_TA_104_SplitStorage_RealWorld_20240812194859.log,104,SplitStorage,26413,1725,28138,75.0,0.166565,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

/**
 * @title SplitStorage
 * @author MirrorXYZ
 */
contract SplitStorage {
    bytes32 public merkleRoot;
    uint256 public currentWindow;
    address internal splitAsset;
    address internal _splitter;
    uint256[] public balanceForWindow;
    mapping(bytes32 => bool) internal claimed;
    uint256 internal depositedInWindow;
}",90
RealWorld_TA_104_IWETH_RealWorld_20240812195840.log,104,IWETH,21810,1121,22931,71.0,0.13147,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

interface IWETH {
    function deposit() external payable;

    function transfer(address to, uint256 value) external returns (bool);
}",43
RealWorld_TA_104_VaultStorage_RealWorld_20240812193619.log,104,VaultStorage,22512,1444,23956,72.0,0.14144,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

contract VaultStorage {
    address public splitterProxy;
    address public royaltyAsset;
    uint256 public platformFee;
    address public platformFeeRecipient;
}",47
RealWorld_TA_104_MockCollection_RealWorld_20240812195549.log,104,MockCollection,27649,2364,30013,89.0,0.185525,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {ICoreCollection} from ""../../interfaces/ICoreCollection.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

contract MockCollection is Ownable {
    address royaltyVault;

    /**
     * @dev Set the address of the RoyaltyVaultProxy contract
     */
    function setRoyaltyVault(address _royaltyVault) external {
        royaltyVault = _royaltyVault;
    }
}",106
RealWorld_TA_104_SplitFactory_RealWorld_20240812194529.log,104,SplitFactory,119715,3180,122895,111.0,0.662175,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';
import {ProxyVault} from '@chestrnft/royalty-vault/contracts/ProxyVault.sol';
import {SplitProxy} from './SplitProxy.sol';
import {IRoyaltyVault} from '@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol';
import {ICoreCollection} from '../interfaces/ICoreCollection.sol';

contract SplitFactory is Ownable {
  /**** Immutable storage ****/

  address public immutable splitter;
  address public immutable royaltyVault;

  /**** Mmutable storage ****/
  // Gets set within the block, and then deleted.

  bytes32 public merkleRoot;
  address public splitAsset;
  address public royaltyAsset;
  address public splitterProxy;
  uint256 public platformFee;
  address public platformFeeRecipient;

  mapping(string => address) public splits;

  /**** Events ****/

  event SplitCreated(address indexed splitter, string splitId);

  event VaultCreated(
    address indexed vault,
    address indexed splitter,
    uint256 platformFee,
    address platformFeeRecipient
  );

  event VaultAssignedToCollection(
    address indexed vault,
    address indexed splitter,
    address indexed collectionContract
  );

  // ---------------- MODIFIER ----------------

  modifier onlyAvailableSplit(string memory _splitId) {
    require(
      splits[_splitId] == address(0),
      'SplitFactory : Split ID already in use'
    );
    _;
  }

  /**
   * @dev Constructor
   * @param _splitter The address of the Splitter contract.
   */
  constructor(address _splitter, address _royaltyVault) {
    splitter = _splitter;
    royaltyVault = _royaltyVault;
    platformFee = 500; // 5%
    platformFeeRecipient = 0x70388C130222eae55a0527a2367486bF5D12d6e7;
  }

  // ---------------- EXTERNAL ----------------

  /**
   * @dev Deploys a new SplitProxy and initializes collection's royalty vault.
   * @param _merkleRoot The merkle root of the asset.
   * @param _splitAsset The address of the asset to split.
   * @param _collectionContract The address of the collection contract.
   * @param _splitId The split identifier.
   */
  function createSplit(
    bytes32 _merkleRoot,
    address _splitAsset,
    address _collectionContract,
    string memory _splitId
  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {
    require(
      ICoreCollection(_collectionContract).owner() == msg.sender,
      'Transaction sender is not collection owner'
    );
    merkleRoot = _merkleRoot;
    splitAsset = _splitAsset;
    royaltyAsset = _splitAsset;

    splitProxy = createSplitProxy(_splitId);
    address vault = createVaultProxy(splitProxy);

    ICoreCollection(_collectionContract).setRoyaltyVault(vault);
    emit VaultAssignedToCollection(vault, splitter, _collectionContract);
  }

  /**
   * @dev Deploys a new SplitProxy.
   * @param _merkleRoot The merkle root of the asset.
   * @param _splitAsset The address of the asset to split.
   * @param _splitId The split identifier.
   */
  function createSplit(
    bytes32 _merkleRoot,
    address _splitAsset,
    string memory _splitId
  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {
    merkleRoot = _merkleRoot;
    splitAsset = _splitAsset;
    royaltyAsset = _splitAsset;

    splitProxy = createSplitProxy(_splitId);
    createVaultProxy(splitProxy);
  }

  /**
   * @dev Set Platform fee for collection contract.
   * @param _platformFee Platform fee in scaled percentage. (5% = 200)
   * @param _vault vault address.
   */
  function setPlatformFee(address _vault, uint256 _platformFee)
    external
    onlyOwner
  {
    IRoyaltyVault(_vault).setPlatformFee(_platformFee);
  }

  /**
   * @dev Set Platform fee recipient for collection contract.
   * @param _vault vault address.
   * @param _platformFeeRecipient Platform fee recipient.
   */
  function setPlatformFeeRecipient(
    address _vault,
    address _platformFeeRecipient
  ) external onlyOwner {
    require(_vault != address(0), 'Invalid vault');
    require(
      _platformFeeRecipient != address(0),
      'Invalid platform fee recipient'
    );
    IRoyaltyVault(_vault).setPlatformFeeRecipient(_platformFeeRecipient);
  }

  // ---------------- PRIVATE ----------------

  /**
   * @dev Creates a new SplitProxy.
   */
  function createSplitProxy(string memory _splitId)
    private
    returns (address splitProxy)
  {
    splitProxy = address(
      new SplitProxy{salt: keccak256(abi.encode(merkleRoot))}()
    );

    splits[_splitId] = splitProxy;

    emit SplitCreated(splitProxy, _splitId);

    delete merkleRoot;
    delete splitAsset;
  }

  function createVaultProxy(address splitProxy)
    private
    returns (address vault)
  {
    splitterProxy = splitProxy;
    vault = address(new ProxyVault{salt: keccak256(abi.encode(splitProxy))}());
    delete splitterProxy;
    delete royaltyAsset;
    emit VaultCreated(vault, splitProxy, platformFee, platformFeeRecipient);
  }
}",1197
RealWorld_TA_104_RoyaltyVault_RealWorld_20240812193300.log,104,RoyaltyVault,80889,3106,83995,93.0,0.466565,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {IRoyaltyVault} from ""../interfaces/IRoyaltyVault.sol"";
import {VaultStorage} from ""./VaultStorage.sol"";
import {ISplitter} from ""../interfaces/ISplitter.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {ERC165} from ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

contract RoyaltyVault is VaultStorage, IRoyaltyVault, ERC165, Ownable {
    /**** Events ****/
    event RoyaltySentToSplitter(address indexed splitter, uint256 amount);
    event FeeSentToPlatform(
        address indexed platformFeeRecipient,
        uint256 amount
    );
    event NewRoyaltyVaultPlatformFee(uint256 platformFee);
    event NewRoyaltyVaultPlatformFeeRecipient(address recipient);

    /**
     * @dev Getting royaltyAsset balance of Vault.
     */
    function getVaultBalance() public view override returns (uint256) {
        return IERC20(royaltyAsset).balanceOf(address(this));
    }

    /**
     * @dev Send accumulated royalty to splitter.
     */
    function sendToSplitter() external override {
        uint256 balanceOfVault = getVaultBalance();

        require(
            balanceOfVault > 0,
            ""Vault does not have enough royalty Asset to send""
        );
        require(splitterProxy != address(0), ""Splitter is not set"");

        uint256 platformShare = (balanceOfVault * platformFee) / 10000;
        uint256 splitterShare = balanceOfVault - platformShare;

        require(
            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,
            ""Failed to transfer royalty Asset to splitter""
        );
        require(
            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,
            ""Failed to increment splitter window""
        );
        require(
            IERC20(royaltyAsset).transfer(
                platformFeeRecipient,
                platformShare
            ) == true,
            ""Failed to transfer royalty Asset to platform fee recipient""
        );

        emit RoyaltySentToSplitter(splitterProxy, splitterShare);
        emit FeeSentToPlatform(platformFeeRecipient, platformShare);
    }

    /**
     * @dev Set Platform fee for collection contract.
     * @param _platformFee Platform fee in scaled percentage.
     */
    function setPlatformFee(uint256 _platformFee) external override onlyOwner {
        platformFee = _platformFee;
        emit NewRoyaltyVaultPlatformFee(_platformFee);
    }

    /**
     * @dev Set Platform fee recipient for collection.
     * @param _platformFeeRecipient Platform fee recipient address
     */
    function setPlatformFeeRecipient(address _platformFeeRecipient)
        external
        override
        onlyOwner
    {
        platformFeeRecipient = _platformFeeRecipient;
        emit NewRoyaltyVaultPlatformFeeRecipient(_platformFeeRecipient);
    }

    /**
     * @dev Get Splitter address of proxyVault.
     */
    function getSplitter() public view override returns (address) {
        return splitterProxy;
    }

    /**
     * @dev Checks for support of IRoyaltyVault.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(IRoyaltyVault, ERC165)
        returns (bool)
    {
        return interfaceId == type(IRoyaltyVault).interfaceId;
    }
}",751
RealWorld_TA_104_ICoreCollection_RealWorld_20240812192938.log,104,ICoreCollection,26822,2439,29261,88.0,0.18289,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

interface ICoreCollection {
    function transferOwnership(address) external;

    function initialize(
        string memory,
        string memory,
        string memory,
        uint256,
        uint256,
        address,
        bool,
        address
    ) external;

    function setRoyaltyVault(address _royaltyVault) external;

    function initializeClaims(bytes32 root) external;
}",93
RealWorld_TA_104_IVaultFactory_RealWorld_20240812194014.log,104,IVaultFactory,24700,1399,26099,77.0,0.15148,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

interface IVaultFactory {
    function royaltyVault() external returns (address);
    function splitterProxy() external returns (address);
    function royaltyAsset() external returns (address);
    function platformFee() external returns (uint256);
    function platformFeeRecipient() external returns (address);
}",74
RealWorld_TA_104_MultiSigWallet_RealWorld_20240812191532.log,104,MultiSigWallet,245164,4437,249601,151.0,1.31456,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

contract MultiSigWallet {
    /*
     *  Events
     */
    event Confirmation(address indexed sender, uint256 indexed transactionId);
    event Revocation(address indexed sender, uint256 indexed transactionId);
    event Submission(uint256 indexed transactionId);
    event Execution(uint256 indexed transactionId);
    event ExecutionFailure(uint256 indexed transactionId);
    event OwnerAddition(address indexed owner);
    event OwnerRemoval(address indexed owner);
    event RequirementChange(uint256 required);

    /*
     *  Constants
     */
    uint256 public constant MAX_OWNER_COUNT = 50;

    /*
     *  Storage
     */
    mapping(uint256 => Transaction) public transactions;
    mapping(uint256 => mapping(address => bool)) public confirmations;
    mapping(address => bool) public isOwner;
    address[] public owners;
    uint256 public required;
    uint256 public transactionCount;

    struct Transaction {
        address destination;
        uint256 value;
        bytes data;
        bool executed;
    }

    /*
     *  Modifiers
     */
    modifier onlyWallet() {
        require(msg.sender == address(this));
        _;
    }

    modifier ownerDoesNotExist(address owner) {
        require(!isOwner[owner]);
        _;
    }

    modifier ownerExists(address owner) {
        require(isOwner[owner]);
        _;
    }

    modifier transactionExists(uint256 transactionId) {
        require(transactions[transactionId].destination != address(0));
        _;
    }

    modifier confirmed(uint256 transactionId, address owner) {
        require(confirmations[transactionId][owner]);
        _;
    }

    modifier notConfirmed(uint256 transactionId, address owner) {
        require(!confirmations[transactionId][owner]);
        _;
    }

    modifier notExecuted(uint256 transactionId) {
        require(!transactions[transactionId].executed);
        _;
    }

    modifier notNull(address _address) {
        require(_address != address(0));
        _;
    }

    modifier validRequirement(uint256 ownerCount, uint256 _required) {
        require(
            ownerCount <= MAX_OWNER_COUNT &&
                _required <= ownerCount &&
                _required != 0 &&
                ownerCount != 0
        );
        _;
    }

    /// @dev Contract constructor sets initial owners and required number of confirmations.
    /// @param _owners List of initial owners.
    /// @param _required Number of required confirmations.
    constructor(address[] memory _owners, uint256 _required)
        validRequirement(_owners.length, _required)
    {
        for (uint256 i = 0; i < _owners.length; i++) {
            require(!isOwner[_owners[i]] && _owners[i] != address(0));
            isOwner[_owners[i]] = true;
        }
        owners = _owners;
        required = _required;
    }

    /*
     * Public functions
     */
    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.
    /// @param owner Address of new owner.
    function addOwner(address owner)
        public
        onlyWallet
        ownerDoesNotExist(owner)
        notNull(owner)
        validRequirement(owners.length + 1, required)
    {
        isOwner[owner] = true;
        owners.push(owner);
        emit OwnerAddition(owner);
    }

    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.
    /// @param owner Address of owner.
    function removeOwner(address owner) public onlyWallet ownerExists(owner) {
        isOwner[owner] = false;
        for (uint256 i = 0; i < owners.length - 1; i++)
            if (owners[i] == owner) {
                owners[i] = owners[owners.length - 1];
                break;
            }

        owners.pop();
        if (required > owners.length) changeRequirement(owners.length);
        emit OwnerRemoval(owner);
    }

    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.
    /// @param owner Address of owner to be replaced.
    /// @param newOwner Address of new owner.
    function replaceOwner(address owner, address newOwner)
        public
        onlyWallet
        ownerExists(owner)
        ownerDoesNotExist(newOwner)
    {
        for (uint256 i = 0; i < owners.length; i++)
            if (owners[i] == owner) {
                owners[i] = newOwner;
                break;
            }
        isOwner[owner] = false;
        isOwner[newOwner] = true;
        emit OwnerRemoval(owner);
        emit OwnerAddition(newOwner);
    }

    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.
    /// @param _required Number of required confirmations.
    function changeRequirement(uint256 _required)
        public
        onlyWallet
        validRequirement(owners.length, _required)
    {
        required = _required;
        emit RequirementChange(_required);
    }

    /// @dev Allows an owner to submit and confirm a transaction.
    /// @param destination Transaction target address.
    /// @param value Transaction ether value.
    /// @param data Transaction data payload.
    /// @return Returns transaction ID.
    function submitTransaction(
        address destination,
        uint256 value,
        bytes calldata data
    ) public returns (uint256) {
        uint256 transactionId = addTransaction(destination, value, data);
        confirmTransaction(transactionId);

        return transactionId;
    }

    /// @dev Allows an owner to confirm a transaction.
    /// @param transactionId Transaction ID.
    function confirmTransaction(uint256 transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        emit Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }

    /// @dev Allows an owner to revoke a confirmation for a transaction.
    /// @param transactionId Transaction ID.
    function revokeConfirmation(uint256 transactionId)
        public
        ownerExists(msg.sender)
        confirmed(transactionId, msg.sender)
        notExecuted(transactionId)
    {
        confirmations[transactionId][msg.sender] = false;
        emit Revocation(msg.sender, transactionId);
    }

    /// @dev Allows anyone to execute a confirmed transaction.
    /// @param transactionId Transaction ID.
    function executeTransaction(uint256 transactionId)
        public
        ownerExists(msg.sender)
        confirmed(transactionId, msg.sender)
        notExecuted(transactionId)
    {
        if (isConfirmed(transactionId)) {
            Transaction storage txn = transactions[transactionId];
            txn.executed = true;
            if (
                external_call(
                    txn.destination,
                    txn.value,
                    txn.data.length,
                    txn.data
                )
            ) emit Execution(transactionId);
            else {
                emit ExecutionFailure(transactionId);
                txn.executed = false;
            }
        }
    }

    // call has been separated into its own function in order to take advantage
    // of the Solidity's code generator to produce a loop that copies tx.data into memory.
    function external_call(
        address destination,
        uint256 value,
        uint256 dataLength,
        bytes memory data
    ) private returns (bool) {
        bool result;
        assembly {
            let x := mload(0x40) // ""Allocate"" memory for output (0x40 is where ""free memory"" pointer is stored by convention)
            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that
            result := call(
                sub(gas(), 34710), // 34710 is the value that solidity is currently emitting
                // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +
                // callNewAccountGas (25000, in case the destination address does not exist and needs creating)
                destination,
                value,
                d,
                dataLength, // Size of the input (in bytes) - this is what fixes the padding problem
                x,
                0 // Output is ignored, therefore the output size is zero
            )
        }
        return result;
    }

    /// @dev Returns the confirmation status of a transaction.
    /// @param transactionId Transaction ID.
    /// @return Confirmation status.
    function isConfirmed(uint256 transactionId) public view returns (bool) {
        uint256 count = 0;
        for (uint256 i = 0; i < owners.length; i++) {
            if (confirmations[transactionId][owners[i]]) count++;
            if (count == required) return true;
        }

        return false;
    }

    /*
     * Internal functions
     */
    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.
    /// @param destination Transaction target address.
    /// @param value Transaction ether value.
    /// @param data Transaction data payload.
    /// @return Returns transaction ID.
    function addTransaction(
        address destination,
        uint256 value,
        bytes calldata data
    ) internal notNull(destination) returns (uint256) {
        uint256 transactionId = transactionCount;
        transactions[transactionId] = Transaction({
            destination: destination,
            value: value,
            data: data,
            executed: false
        });
        transactionCount++;
        emit Submission(transactionId);

        return transactionId;
    }

    /*
     * Web3 call functions
     */
    /// @dev Returns number of confirmations of a transaction.
    /// @param transactionId Transaction ID.
    /// @return Number of confirmations.
    function getConfirmationCount(uint256 transactionId)
        public
        view
        returns (uint256)
    {
        uint256 count;
        for (uint256 i = 0; i < owners.length; i++)
            if (confirmations[transactionId][owners[i]]) count++;

        return count;
    }

    /// @dev Returns total number of transactions after filers are applied.
    /// @param pending Include pending transactions.
    /// @param executed Include executed transactions.
    /// @return Total number of transactions after filters are applied.
    function getTransactionCount(bool pending, bool executed)
        public
        view
        returns (uint256)
    {
        uint256 count;
        for (uint256 i = 0; i < transactionCount; i++)
            if (
                (pending && !transactions[i].executed) ||
                (executed && transactions[i].executed)
            ) count++;

        return count;
    }

    /// @dev Returns list of owners.
    /// @return List of owner addresses.
    function getOwners() public view returns (address[] memory) {
        return owners;
    }

    /// @dev Returns array with owner addresses, which confirmed transaction.
    /// @param transactionId Transaction ID.
    /// @return Returns array of owner addresses.
    function getConfirmations(uint256 transactionId)
        public
        view
        returns (address[] memory)
    {
        address[] memory _confirmations;
        address[] memory confirmationsTemp = new address[](owners.length);
        uint256 count = 0;
        uint256 i;
        for (i = 0; i < owners.length; i++)
            if (confirmations[transactionId][owners[i]]) {
                confirmationsTemp[count] = owners[i];
                count++;
            }
        _confirmations = new address[](count);
        for (i = 0; i < count; i++) _confirmations[i] = confirmationsTemp[i];

        return _confirmations;
    }

    /// @dev Returns list of transaction IDs in defined range.
    /// @param from Index start position of transaction array.
    /// @param to Index end position of transaction array.
    /// @param pending Include pending transactions.
    /// @param executed Include executed transactions.
    /// @return Returns array of transaction IDs.
    function getTransactionIds(
        uint256 from,
        uint256 to,
        bool pending,
        bool executed
    ) public view returns (uint256[] memory) {
        uint256[] memory _transactionIds;
        uint256[] memory transactionIdsTemp = new uint256[](transactionCount);
        uint256 count = 0;
        uint256 i;
        for (i = 0; i < transactionCount; i++)
            if (
                (pending && !transactions[i].executed) ||
                (executed && transactions[i].executed)
            ) {
                transactionIdsTemp[count] = i;
                count++;
            }
        _transactionIds = new uint256[](to - from);
        for (i = from; i < to; i++)
            _transactionIds[i - from] = transactionIdsTemp[i];

        return _transactionIds;
    }
}",2706
RealWorld_TA_104_SplitProxy_RealWorld_20240812194723.log,104,SplitProxy,44711,3269,47980,94.0,0.288935,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {SplitStorage} from ""./SplitStorage.sol"";

interface ISplitFactory {
    function splitter() external returns (address);

    function splitAsset() external returns (address);

    function merkleRoot() external returns (bytes32);
}

/**
 * @title SplitProxy
 */
contract SplitProxy is SplitStorage {
    constructor() {
        _splitter = ISplitFactory(msg.sender).splitter();
        splitAsset = ISplitFactory(msg.sender).splitAsset();
        merkleRoot = ISplitFactory(msg.sender).merkleRoot();
    }

    fallback() external payable {
        address _impl = splitter();
        assembly {
            let ptr := mload(0x40)
            calldatacopy(ptr, 0, calldatasize())
            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)
            let size := returndatasize()
            returndatacopy(ptr, 0, size)

            switch result
            case 0 {
                revert(ptr, size)
            }
            default {
                return(ptr, size)
            }
        }
    }

    /**
     * @dev Returns the address of the splitter contract.
     * @return address
     */
    function splitter() public view returns (address) {
        return _splitter;
    }

    receive() external payable {}
}",295
RealWorld_TA_104_RoyaltyVaultFactory_RealWorld_20240812193108.log,104,RoyaltyVaultFactory,63178,2879,66057,110.0,0.37347,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.4;

import {ProxyVault} from ""./ProxyVault.sol"";
import {IRoyaltyVault} from ""../interfaces/IRoyaltyVault.sol"";

contract RoyaltyVaultFactory {
    /**** Immutable data ****/
    address public immutable royaltyVault;

    /**** Mutable data ****/
    address public royaltyAsset;
    address public splitterProxy;
    uint256 public platformFee;
    address public platformFeeRecipient;

    /**** Events ****/

    event VaultCreated(address vault);

    /**
     * @dev Constructor
     * @param _royaltyVault address of the RoyaltyVault logic contract
     */
    constructor(address _royaltyVault) {
        royaltyVault = _royaltyVault;
        platformFee = 500; // 5%
        platformFeeRecipient = 0x70388C130222eae55a0527a2367486bF5D12d6e7;
    }

    /**
     * @dev Create RoyaltyVault
     * @param _splitter address of the splitter contract.
     * @param _royaltyAsset address of the assets which will be splitted.
     */

    function createVault(address _splitter, address _royaltyAsset)
        external
        returns (address vault)
    {
        splitterProxy = _splitter;
        royaltyAsset = _royaltyAsset;

        vault = address(
            new ProxyVault{salt: keccak256(abi.encode(_splitter))}()
        );

        delete splitterProxy;
        delete royaltyAsset;
    }

    /**
     * @dev Set Platform fee for collection contract.
     * @param _platformFee Platform fee in scaled percentage. (5% = 200)
     * @param _vault vault address.
     */
    function setPlatformFee(address _vault, uint256 _platformFee) external {
        IRoyaltyVault(_vault).setPlatformFee(_platformFee);
    }

    /**
     * @dev Set Platform fee recipient for collection contract.
     * @param _vault vault address.
     * @param _platformFeeRecipient Platform fee recipient.
     */
    function setPlatformFeeRecipient(
        address _vault,
        address _platformFeeRecipient
    ) external {
        require(_vault != address(0), ""Invalid vault"");
        require(
            _platformFeeRecipient != address(0),
            ""Invalid platform fee recipient""
        );
        IRoyaltyVault(_vault).setPlatformFeeRecipient(_platformFeeRecipient);
    }
}",519
RealWorld_TA_104_ProxyVault_RealWorld_20240812195138.log,104,ProxyVault,22643,2534,25177,85.0,0.163895,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {ProxyVault} from ""@chestrnft/royalty-vault/contracts/ProxyVault.sol"";

contract MockProxyVault is ProxyVault {}",47
RealWorld_TA_96_MsgValueCallee_RealWorld_20240811221715.log,96,MsgValueCallee,25723,2404,28127,73.0,0.176695,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {SafeCast} from '@timeswap-labs/timeswap-v1-core/contracts/libraries/SafeCast.sol';
import {MsgValue} from '../libraries/MsgValue.sol';
contract MsgValueCallee{
    function getUint112() payable public{
        MsgValue.getUint112();
    }
}",80
RealWorld_TA_96_TestToken_RealWorld_20240811221935.log,96,TestToken,24478,1319,25797,84.0,0.14877,"// SPDX-License-Identifier: MIT
pragma solidity >=0.8.1;

import '@openzeppelin/contracts/token/ERC20/ERC20.sol';

contract TestToken is ERC20 {
    constructor(
        string memory name_,
        string memory symbol_,
        uint256 amount
    ) ERC20(name_, symbol_) {
        _mint(msg.sender, amount);
    }
}",77
RealWorld_TA_96_IPay_RealWorld_20240811231415.log,96,IPay,39516,1321,40837,65.0,0.224,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';

interface IPay {
    struct Repay {
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address collateralTo;
        uint256[] ids;
        uint112[] maxAssetsIn;
        uint256 deadline;
    }

    struct RepayETHAsset {
        IERC20 collateral;
        uint256 maturity;
        address collateralTo;
        uint256[] ids;
        uint112[] maxAssetsIn;
        uint256 deadline;
    }

    struct RepayETHCollateral {
        IERC20 asset;
        uint256 maturity;
        address payable collateralTo;
        uint256[] ids;
        uint112[] maxAssetsIn;
        uint256 deadline;
    }

    struct _Repay {
        IFactory factory;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address from;
        address collateralTo;
        uint256[] ids;
        uint112[] maxAssetsIn;
        uint256 deadline;
    }
}",265
RealWorld_TA_96_MintMathCallee_RealWorld_20240811221333.log,96,MintMathCallee,46070,1724,47794,66.0,0.26483,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {MintMath} from '../libraries/MintMath.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';

contract MintMathCallee {
    function givenNew(
        uint256 maturity,
        uint112 assetIn,
        uint112 debtIn,
        uint112 collateralIn
    )
        public
        view
        returns (
            uint256,
            uint112,
            uint112
        )
    {
        return MintMath.givenNew(maturity, assetIn, debtIn, collateralIn);
    }

    function givenAsset(
        IPair pair,
        uint256 maturity,
        uint112 assetIn
    )
        public
        view
        returns (
            uint256,
            uint112,
            uint112
        )
    {
        return MintMath.givenAsset(pair, maturity, assetIn);
    }

    function givenDebt(
        IPair pair,
        uint256 maturity,
        uint112 debtIn
    )
        public
        view
        returns (
            uint256,
            uint112,
            uint112
        )
    {
        return MintMath.givenDebt(pair, maturity, debtIn);
    }

    function givenCollateral(
        IPair pair,
        uint256 maturity,
        uint112 collateralIn
    )
        public
        view
        returns (
            uint256,
            uint112,
            uint112
        )
    {
        return MintMath.givenCollateral(pair, maturity, collateralIn);
    }
}",333
RealWorld_TA_96_SquareRoot_RealWorld_20240811223057.log,96,SquareRoot,31613,1659,33272,74.0,0.191245,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

library SquareRoot {
    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)
    function sqrt(uint256 x) internal pure returns (uint256 y) {
        uint256 z = (x + 1) / 2;
        y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
    }

    function sqrtUp(uint256 x) internal pure returns (uint256 y) {
        y = sqrt(x);
        if (x % y != 0) y++;
    }
}",154
RealWorld_TA_96_SafeTransferCallee_RealWorld_20240811221101.log,96,SafeTransferCallee,31163,2138,33301,77.0,0.198575,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {SafeTransfer} from '../libraries/SafeTransfer.sol';

contract SafeTransferCallee{
    function safeTransfer(IERC20 token, IPair to, uint256 amount) public  {
        return SafeTransfer.safeTransfer(token, to, amount);
    }
    function safeTransferFrom( IERC20 token,
        address from,
        IPair to,
        uint256 amount) public{
            return SafeTransfer.safeTransferFrom(token, from, to, amount);
        }
}",161
RealWorld_TA_96_SafeTransfer_RealWorld_20240811225034.log,96,SafeTransfer,32570,1564,34134,72.0,0.19413,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';

library SafeTransfer {
    using SafeERC20 for IERC20;

    function safeTransfer(
        IERC20 token,
        IPair to,
        uint256 amount
    ) internal {
        token.safeTransfer(address(to), amount);
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        IPair to,
        uint256 amount
    ) internal {
        token.safeTransferFrom(from, address(to), amount);
    }
}",182
RealWorld_TA_96_Withdraw_RealWorld_20240811224156.log,96,Withdraw,88381,3204,91585,79.0,0.505985,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IConvenience} from '../interfaces/IConvenience.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';
import {IWETH} from '../interfaces/IWETH.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IWithdraw} from '../interfaces/IWithdraw.sol';
import {ETH} from './ETH.sol';

library Withdraw {
    function collect(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IFactory factory,
        IWithdraw.Collect calldata params
    ) external returns (IPair.Tokens memory tokensOut) {
        tokensOut = _collect(
            natives,
            IWithdraw._Collect(
                factory,
                params.asset,
                params.collateral,
                params.maturity,
                params.assetTo,
                params.collateralTo,
                params.claimsIn
            )
        );
    }

    function collectETHAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IFactory factory,
        IWETH weth,
        IWithdraw.CollectETHAsset calldata params
    ) external returns (IPair.Tokens memory tokensOut) {
        tokensOut = _collect(
            natives,
            IWithdraw._Collect(
                factory,
                weth,
                params.collateral,
                params.maturity,
                address(this),
                params.collateralTo,
                params.claimsIn
            )
        );

        if (tokensOut.asset != 0) {
            weth.withdraw(tokensOut.asset);
            ETH.transfer(params.assetTo, tokensOut.asset);
        }
    }

    function collectETHCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IFactory factory,
        IWETH weth,
        IWithdraw.CollectETHCollateral calldata params
    ) external returns (IPair.Tokens memory tokensOut) {
        tokensOut = _collect(
            natives,
            IWithdraw._Collect(
                factory,
                params.asset,
                weth,
                params.maturity,
                params.assetTo,
                address(this),
                params.claimsIn
            )
        );

        if (tokensOut.collateral != 0) {
            weth.withdraw(tokensOut.collateral);
            ETH.transfer(params.collateralTo, tokensOut.collateral);
        }
    }

    function _collect(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IWithdraw._Collect memory params
    ) private returns (IPair.Tokens memory tokensOut) {
        IPair pair = params.factory.getPair(params.asset, params.collateral);
        require(address(pair) != address(0), 'E501');

        IConvenience.Native memory native = natives[params.asset][params.collateral][params.maturity];
        require(address(native.liquidity) != address(0), 'E502');

        tokensOut = pair.withdraw(
            IPair.WithdrawParam(params.maturity, params.assetTo, params.collateralTo, params.claimsIn)
        );

        if (params.claimsIn.bondInterest != 0) native.bondInterest.burn(msg.sender, params.claimsIn.bondInterest);
        if (params.claimsIn.bondPrincipal != 0) native.bondPrincipal.burn(msg.sender, params.claimsIn.bondPrincipal);
        if (params.claimsIn.insuranceInterest != 0)
            native.insuranceInterest.burn(msg.sender, params.claimsIn.insuranceInterest);
        if (params.claimsIn.insurancePrincipal != 0)
            native.insurancePrincipal.burn(msg.sender, params.claimsIn.insurancePrincipal);
    }
}",842
RealWorld_TA_96_Pay_RealWorld_20240811224609.log,96,Pay,99307,4692,103999,94.0,0.590375,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IConvenience} from '../interfaces/IConvenience.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';
import {IWETH} from '../interfaces/IWETH.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IPay} from '../interfaces/IPay.sol';
import {IDue} from '../interfaces/IDue.sol';
import {PayMath} from './PayMath.sol';
import {MsgValue} from './MsgValue.sol';
import {ETH} from './ETH.sol';

library Pay {
    using PayMath for IPair;

    function pay(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IFactory factory,
        IPay.Repay memory params
    ) external returns (uint128 assetIn, uint128 collateralOut) {
        (assetIn, collateralOut) = _pay(
            natives,
            IPay._Repay(
                factory,
                params.asset,
                params.collateral,
                params.maturity,
                msg.sender,
                params.collateralTo,
                params.ids,
                params.maxAssetsIn,
                params.deadline
            )
        );
    }

    function payETHAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IFactory factory,
        IWETH weth,
        IPay.RepayETHAsset memory params
    ) external returns (uint128 assetIn, uint128 collateralOut) {
        uint128 maxAssetIn = MsgValue.getUint112();

        (assetIn, collateralOut) = _pay(
            natives,
            IPay._Repay(
                factory,
                weth,
                params.collateral,
                params.maturity,
                address(this),
                params.collateralTo,
                params.ids,
                params.maxAssetsIn,
                params.deadline
            )
        );

        if (maxAssetIn > assetIn) {
            uint256 excess = maxAssetIn;
            unchecked {
                excess -= assetIn;
            }
            ETH.transfer(payable(msg.sender), excess);
        }
    }

    function payETHCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IFactory factory,
        IWETH weth,
        IPay.RepayETHCollateral memory params
    ) external returns (uint128 assetIn, uint128 collateralOut) {
        (assetIn, collateralOut) = _pay(
            natives,
            IPay._Repay(
                factory,
                params.asset,
                weth,
                params.maturity,
                msg.sender,
                address(this),
                params.ids,
                params.maxAssetsIn,
                params.deadline
            )
        );

        if (collateralOut != 0) {
            weth.withdraw(collateralOut);
            ETH.transfer(params.collateralTo, collateralOut);
        }
    }

    function _pay(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IPay._Repay memory params
    ) private returns (uint128 assetIn, uint128 collateralOut) {
        require(params.deadline >= block.timestamp, 'E504');
        require(params.maturity > block.timestamp, 'E508');
        require(params.ids.length == params.maxAssetsIn.length, '520');

        IPair pair = params.factory.getPair(params.asset, params.collateral);
        require(address(pair) != address(0), 'E501');

        IDue collateralizedDebt = natives[params.asset][params.collateral][params.maturity].collateralizedDebt;
        require(address(collateralizedDebt) != address(0), 'E502');

        (uint112[] memory assetsIn, uint112[] memory collateralsOut) = pair.givenMaxAssetsIn(
            params.maturity,
            collateralizedDebt,
            params.ids,
            params.maxAssetsIn
        );

        (assetIn, collateralOut) = pair.pay(
            IPair.PayParam(
                params.maturity,
                params.collateralTo,
                address(this),
                params.ids,
                assetsIn,
                collateralsOut,
                bytes(abi.encode(params.asset, params.collateral, params.from, params.maturity))
            )
        );
    }
}",960
RealWorld_TA_96_ILiquidity_RealWorld_20240811231152.log,96,ILiquidity,30954,1839,32793,70.0,0.19155,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC20Permit} from './IERC20Permit.sol';
import {IConvenience} from './IConvenience.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';

/// @author Ricsson W. Ngo
interface ILiquidity is IERC20Permit {
    // VIEW

    function convenience() external returns (IConvenience);

    function pair() external returns (IPair);

    function maturity() external returns (uint256);

    // UPDATE

    function mint(address to, uint256 amount) external;

    function burn(address from, uint256 amount) external;
}",155
RealWorld_TA_96_ITimeswapBorrowCallback_RealWorld_20240811215637.log,96,ITimeswapBorrowCallback,33933,1259,35192,74.0,0.194845,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

/// @title Callback for ITimeswapPair#borrow
/// @notice Any contract that calls ITimeswapPair#borrow must implement this interface
interface ITimeswapBorrowCallback {
    /// @notice Called to `msg.sender` after initiating a borrow from ITimeswapPair#borrow.
    /// @dev In the implementation you must pay the collateral token owed for the borrow transaction.
    /// The caller of this method must be checked to be a TimeswapPair deployed by the canonical TimeswapFactory.
    /// @param collateralIn The amount of asset tokens owed due to the pool for the borrow transaction
    /// @param data Any data passed through by the caller via the ITimeswapPair#borrow call
    function timeswapBorrowCallback(
        uint112 collateralIn,
        bytes calldata data
    ) external;
}",187
RealWorld_TA_96_IWETH_RealWorld_20240811231853.log,96,IWETH,25165,1393,26558,67.0,0.153685,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';

/// @title WETH9 Interface
/// @author Ricsson W. Ngo
interface IWETH is IERC20 {
    /* ===== UPDATE ===== */

    function deposit() external payable;

    function withdraw(uint256 amount) external;
}",88
RealWorld_TA_96_TimeswapFactory_RealWorld_20240811213813.log,96,TimeswapFactory,67010,2363,69373,81.0,0.38231,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IFactory} from './interfaces/IFactory.sol';
import {IPair} from './interfaces/IPair.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {TimeswapPair} from './TimeswapPair.sol';

/// @title Timeswap Factory
/// @author Timeswap Labs
/// @notice It is recommended to use Timeswap Convenience to interact with this contract.
/// @notice All error messages are coded and can be found in the documentation.
contract TimeswapFactory is IFactory {
    /* ===== MODEL ===== */

    /// @inheritdoc IFactory
    address public override owner;
    /// @inheritdoc IFactory
    address public override pendingOwner;
    /// @inheritdoc IFactory
    uint16 public immutable override fee;
    /// @inheritdoc IFactory
    uint16 public immutable override protocolFee;

    /// @inheritdoc IFactory
    mapping(IERC20 => mapping(IERC20 => IPair)) public override getPair;

    /* ===== INIT ===== */

    /// @param _owner The chosen owner address.
    /// @param _fee The chosen fee rate.
    /// @param _protocolFee The chosen protocol fee rate.
    constructor(
        address _owner,
        uint16 _fee,
        uint16 _protocolFee
    ) {
        require(_owner != address(0), 'E101');
        owner = _owner;
        fee = _fee;
        protocolFee = _protocolFee;
    }

    /* ===== UPDATE ===== */

    /// @inheritdoc IFactory
    function createPair(IERC20 asset, IERC20 collateral) external override returns (IPair pair) {
        require(asset != collateral, 'E103');
        require(asset != IERC20(address(0)) && collateral != IERC20(address(0)), 'E101');
        require(getPair[asset][collateral] == IPair(address(0)), 'E104');

        pair = new TimeswapPair{salt: keccak256(abi.encode(asset, collateral))}(asset, collateral, fee, protocolFee);

        getPair[asset][collateral] = pair;

        emit CreatePair(asset, collateral, pair);
    }

    /// @inheritdoc IFactory
    function setOwner(address _pendingOwner) external override {
        require(msg.sender == owner, 'E102');
        require(_pendingOwner != address(0), 'E101');
        pendingOwner = _pendingOwner;

        emit SetOwner(_pendingOwner);
    }

    /// @inheritdoc IFactory
    function acceptOwner() external override {
        require(msg.sender == pendingOwner, 'E102');
        owner = msg.sender;
        pendingOwner = address(0);

        emit AcceptOwner(msg.sender);
    }
}",581
RealWorld_TA_96_IPair_RealWorld_20240811215449.log,96,IPair,348784,3151,351935,106.0,1.80694,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IFactory} from './IFactory.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';

interface IPair {
    /* ===== STRUCT ===== */

    struct Tokens {
        uint128 asset;
        uint128 collateral;
    }

    struct Claims {
        uint112 bondPrincipal;
        uint112 bondInterest;
        uint112 insurancePrincipal;
        uint112 insuranceInterest;
    }

    struct Due {
        uint112 debt;
        uint112 collateral;
        uint32 startBlock;
    }

    struct State {
        Tokens reserves;
        uint256 feeStored;
        uint256 totalLiquidity;
        Claims totalClaims;
        uint120 totalDebtCreated;
        uint112 x;
        uint112 y;
        uint112 z;
    }

    struct Pool {
        State state;
        mapping(address => uint256) liquidities;
        mapping(address => Claims) claims;
        mapping(address => Due[]) dues;
    }

    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param liquidityTo The address of the receiver of liquidity balance.
    /// @param dueTo The addres of the receiver of collateralized debt balance.
    /// @param xIncrease The increase in the X state.
    /// @param yIncrease The increase in the Y state.
    /// @param zIncrease The increase in the Z state.
    /// @param data The data for callback.
    struct MintParam {
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint112 xIncrease;
        uint112 yIncrease;
        uint112 zIncrease;
        bytes data;
    }

    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param assetTo The address of the receiver of asset ERC20.
    /// @param collateralTo The addres of the receiver of collateral ERC20.
    /// @param liquidityIn The amount of liquidity balance burnt by the msg.sender.
    struct BurnParam {
        uint256 maturity;
        address assetTo;
        address collateralTo;
        uint256 liquidityIn;
    }

    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param bondTo The address of the receiver of bond balance.
    /// @param insuranceTo The addres of the receiver of insurance balance.
    /// @param xIncrease The increase in x state and the amount of asset ERC20 sent.
    /// @param yDecrease The decrease in y state.
    /// @param zDecrease The decrease in z state.
    /// @param data The data for callback.
    struct LendParam {
        uint256 maturity;
        address bondTo;
        address insuranceTo;
        uint112 xIncrease;
        uint112 yDecrease;
        uint112 zDecrease;
        bytes data;
    }

    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param assetTo The address of the receiver of asset ERC20.
    /// @param collateralTo The addres of the receiver of collateral ERC20.
    /// @param claimsIn The amount of bond balance and insurance balance burnt by the msg.sender.
    struct WithdrawParam {
        uint256 maturity;
        address assetTo;
        address collateralTo;
        Claims claimsIn;
    }

    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param assetTo The address of the receiver of asset ERC20.
    /// @param dueTo The address of the receiver of collateralized debt.
    /// @param xDecrease The decrease in x state and amount of asset ERC20 received by assetTo.
    /// @param yIncrease The increase in y state.
    /// @param zIncrease The increase in z state.
    /// @param data The data for callback.
    struct BorrowParam {
        uint256 maturity;
        address assetTo;
        address dueTo;
        uint112 xDecrease;
        uint112 yIncrease;
        uint112 zIncrease;
        bytes data;
    }

    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param to The address of the receiver of collateral ERC20.
    /// @param owner The addres of the owner of collateralized debt.
    /// @param ids The array indexes of collateralized debts.
    /// @param assetsIn The amount of asset ERC20 paid per collateralized debts.
    /// @param collateralsOut The amount of collateral ERC20 withdrawn per collaterlaized debts.
    /// @param data The data for callback.
    struct PayParam {
        uint256 maturity;
        address to;
        address owner;
        uint256[] ids;
        uint112[] assetsIn;
        uint112[] collateralsOut;
        bytes data;
    }

    /* ===== EVENT ===== */

    /// @dev Emits when the state gets updated.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param x The new x state of the pool.
    /// @param y The new y state of the pool.
    /// @param z The new z state of the pool.
    event Sync(uint256 indexed maturity, uint112 x, uint112 y, uint112 z);

    /// @dev Emits when mint function is called.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param sender The address of the caller.
    /// @param liquidityTo The address of the receiver of liquidity balance.
    /// @param dueTo The address of the receiver of collateralized debt balance.
    /// @param assetIn The increase in the X state.
    /// @param liquidityOut The amount of liquidity balance received by liquidityTo.
    /// @param id The array index of the collateralized debt received by dueTo.
    /// @param dueOut The collateralized debt received by dueTo.
    /// @param feeIn The amount of fee asset ERC20 deposited.
    event Mint(
        uint256 maturity,
        address indexed sender,
        address indexed liquidityTo,
        address indexed dueTo,
        uint256 assetIn,
        uint256 liquidityOut,
        uint256 id,
        Due dueOut,
        uint256 feeIn
    );

    /// @dev Emits when burn function is called.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param sender The address of the caller.
    /// @param assetTo The address of the receiver of asset ERC20.
    /// @param collateralTo The addres of the receiver of collateral ERC20.
    /// @param liquidityIn The amount of liquidity balance burnt by the sender.
    /// @param assetOut The amount of asset ERC20 received.
    /// @param collateralOut The amount of collateral ERC20 received.
    /// @param feeOut The amount of fee asset ERC20 received.
    event Burn(
        uint256 maturity,
        address indexed sender,
        address indexed assetTo,
        address indexed collateralTo,
        uint256 liquidityIn,
        uint256 assetOut,
        uint128 collateralOut,
        uint256 feeOut
    );

    /// @dev Emits when lend function is called.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param sender The address of the caller.
    /// @param bondTo The address of the receiver of bond balance.
    /// @param insuranceTo The addres of the receiver of insurance balance.
    /// @param assetIn The increase in X state.
    /// @param claimsOut The amount of bond balance and insurance balance received.
    /// @param feeIn The amount of fee paid by lender.
    /// @param protocolFeeIn The amount of protocol fee paid by lender.
    event Lend(
        uint256 maturity,
        address indexed sender,
        address indexed bondTo,
        address indexed insuranceTo,
        uint256 assetIn,
        Claims claimsOut,
        uint256 feeIn,
        uint256 protocolFeeIn
    );

    /// @dev Emits when withdraw function is called.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param sender The address of the caller.
    /// @param assetTo The address of the receiver of asset ERC20.
    /// @param collateralTo The address of the receiver of collateral ERC20.
    /// @param claimsIn The amount of bond balance and insurance balance burnt by the sender.
    /// @param tokensOut The amount of asset ERC20 and collateral ERC20 received.
    event Withdraw(
        uint256 maturity,
        address indexed sender,
        address indexed assetTo,
        address indexed collateralTo,
        Claims claimsIn,
        Tokens tokensOut
    );

    /// @dev Emits when borrow function is called.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param sender The address of the caller.
    /// @param assetTo The address of the receiver of asset ERC20.
    /// @param dueTo The address of the receiver of collateralized debt.
    /// @param assetOut The amount of asset ERC20 received by assetTo.
    /// @param id The array index of the collateralized debt received by dueTo.
    /// @param dueOut The collateralized debt received by dueTo.
    /// @param feeIn The amount of fee paid by lender.
    /// @param protocolFeeIn The amount of protocol fee paid by lender.
    event Borrow(
        uint256 maturity,
        address indexed sender,
        address indexed assetTo,
        address indexed dueTo,
        uint256 assetOut,
        uint256 id,
        Due dueOut,
        uint256 feeIn,
        uint256 protocolFeeIn
    );

    /// @dev Emits when pay function is called.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param sender The address of the caller.
    /// @param to The address of the receiver of collateral ERC20.
    /// @param owner The address of the owner of collateralized debt.
    /// @param ids The array indexes of collateralized debts.
    /// @param assetsIn The amount of asset ERC20 paid per collateralized debts.
    /// @param collateralsOut The amount of collateral ERC20 withdrawn per collaterelized debts.
    /// @param assetIn The total amount of asset ERC20 paid.
    /// @param collateralOut The total amount of collateral ERC20 received.
    event Pay(
        uint256 maturity,
        address indexed sender,
        address indexed to,
        address indexed owner,
        uint256[] ids,
        uint112[] assetsIn,
        uint112[] collateralsOut,
        uint128 assetIn,
        uint128 collateralOut
    );

    /// @dev Emits when collectProtocolFee function is called
    /// @param sender The address of the caller.
    /// @param to The address of the receiver of asset ERC20.
    /// @param protocolFeeOut The amount of protocol fee asset ERC20 received.
    event CollectProtocolFee(
        address indexed sender,
        address indexed to,
        uint256 protocolFeeOut
    );

    /* ===== VIEW ===== */

    /// @dev Return the address of the factory contract that deployed this contract.
    /// @return The address of the factory contract.
    function factory() external view returns (IFactory);

    /// @dev Return the address of the ERC20 being lent and borrowed.
    /// @return The address of the asset ERC20.
    function asset() external view returns (IERC20);

    /// @dev Return the address of the ERC20 as collateral.
    /// @return The address of the collateral ERC20.
    function collateral() external view returns (IERC20);

    //// @dev Return the fee per second earned by liquidity providers.
    //// @return The transaction fee following the UQ0.40 format.
    function fee() external view returns (uint16);

    /// @dev Return the protocol fee per second earned by the owner.
    /// @return The protocol fee per second following the UQ0.40 format.
    function protocolFee() external view returns (uint16);

    /// @dev Return the fee stored of the Pool given maturity.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @return The fee in asset ERC20 stored in the Pool.
    function feeStored(uint256 maturity) external view returns (uint256);

    /// @dev Return the protocol fee stored.
    /// @return The protocol fee in asset ERC20 stored.
    function protocolFeeStored() external view returns (uint256);

    /// @dev Returns the Constant Product state of a Pool.
    /// @dev The Y state follows the UQ80.32 format.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @return x The x state.
    /// @return y The y state.
    /// @return z The z state.
    function constantProduct(uint256 maturity)
        external
        view
        returns (
            uint112 x,
            uint112 y,
            uint112 z
        );

    /// @dev Returns the asset ERC20 and collateral ERC20 balances of a Pool.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @return The asset ERC20 and collateral ERC20 locked.
    function totalReserves(uint256 maturity) external view returns (Tokens memory);

    /// @dev Returns the total liquidity supply of a Pool.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @return The total liquidity supply.
    function totalLiquidity(uint256 maturity) external view returns (uint256);

    /// @dev Returns the liquidity balance of a user in a Pool.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param owner The address of the user.
    /// @return The liquidity balance.
    function liquidityOf(uint256 maturity, address owner) external view returns (uint256);

    /// @dev Returns the total claims of a Pool.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @return The total claims.
    function totalClaims(uint256 maturity) external view returns (Claims memory);

    /// @dev Returms the claims of a user in a Pool.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param owner The address of the user.
    /// @return The claims balance.
    function claimsOf(uint256 maturity, address owner) external view returns (Claims memory);

    /// @dev Returns the total debt created.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @return The total asset ERC20 debt created.
    function totalDebtCreated(uint256 maturity) external view returns (uint120);

    /// @dev Returns the number of dues owned by owner.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param owner The address of the user.
    function totalDuesOf(uint256 maturity, address owner) external view returns (uint256);

    /// @dev Returns a collateralized debt of a user in a Pool.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param owner The address of the user.
    /// @param id The index of the collateralized debt
    /// @return The collateralized debt balance.
    function dueOf(uint256 maturity, address owner, uint256 id) external view returns (Due memory);

    /* ===== UPDATE ===== */

    /// @dev Add liquidity into a Pool by a liquidity provider.
    /// @dev Liquidity providers can be thought as making both lending and borrowing positions.
    /// @dev Must be called by a contract implementing the ITimeswapMintCallback interface.
    /// @param param The mint parameter found in the MintParam struct.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return liquidityOut The amount of liquidity balance received by liquidityTo.
    /// @return id The array index of the collateralized debt received by dueTo.
    /// @return dueOut The collateralized debt received by dueTo.
    function mint(MintParam calldata param)
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            Due memory dueOut
        );

    /// @dev Remove liquidity from a Pool by a liquidity provider.
    /// @dev Can only be called after the maturity of the Pool.
    /// @param param The burn parameter found in the BurnParam struct.
    /// @return assetOut The amount of asset ERC20 received.
    /// @return collateralOut The amount of collateral ERC20 received.
    function burn(BurnParam calldata param) 
        external 
        returns (
            uint256 assetOut,
            uint128 collateralOut 
        );

    /// @dev Lend asset ERC20 into the Pool.
    /// @dev Must be called by a contract implementing the ITimeswapLendCallback interface.
    /// @param param The lend parameter found in the LendParam struct.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return claimsOut The amount of bond balance and insurance balance received.
    function lend(LendParam calldata param) 
        external 
        returns (
            uint256 assetIn,
            Claims memory claimsOut
        );

    /// @dev Withdraw asset ERC20 and/or collateral ERC20 for lenders.
    /// @dev Can only be called after the maturity of the Pool.
    /// @param param The withdraw parameter found in the WithdrawParam struct.
    /// @return tokensOut The amount of asset ERC20 and collateral ERC20 received.
    function withdraw(WithdrawParam calldata param)
        external 
        returns (
            Tokens memory tokensOut
        );

    /// @dev Borrow asset ERC20 from the Pool.
    /// @dev Must be called by a contract implementing the ITimeswapBorrowCallback interface.
    /// @param param The borrow parameter found in the BorrowParam struct.
    /// @return assetOut The amount of asset ERC20 received.
    /// @return id The array index of the collateralized debt received by dueTo.
    /// @return dueOut The collateralized debt received by dueTo.
    function borrow(BorrowParam calldata param)
        external 
        returns (
            uint256 assetOut,
            uint256 id, 
            Due memory dueOut
        );

    /// @dev Pay asset ERC20 into the Pool to repay debt for borrowers.
    /// @dev If there are asset paid, must be called by a contract implementing the ITimeswapPayCallback interface.
    /// @param param The pay parameter found in the PayParam struct.
    /// @return assetIn The total amount of asset ERC20 paid.
    /// @return collateralOut The total amount of collateral ERC20 received.
    function pay(PayParam calldata param)
        external 
        returns (
            uint128 assetIn, 
            uint128 collateralOut
        );

    /// @dev Collect the stored protocol fee.
    /// @dev Can only be called by the owner.
    /// @param to The receiver of the protocol fee.
    /// @return protocolFeeOut The total amount of protocol fee asset ERC20 received.
    function collectProtocolFee(address to) external returns (uint256 protocolFeeOut);
}",3960
RealWorld_TA_96_WETH9_RealWorld_20240811222101.log,96,WETH9,55219,2758,57977,88.0,0.331255,"pragma solidity >= 0.8.1;

contract WETH9 {
    string public name     = ""Wrapped Ether"";
    string public symbol   = ""WETH"";
    uint8  public decimals = 18;

    event  Approval(address indexed src, address indexed guy, uint wad);
    event  Transfer(address indexed src, address indexed dst, uint wad);
    event  Deposit(address indexed dst, uint wad);
    event  Withdrawal(address indexed src, uint wad);

    mapping (address => uint)                       public  balanceOf;
    mapping (address => mapping (address => uint))  public  allowance;

    receive() external payable {
        deposit();
    }
    fallback() external payable {
        deposit();
    }
    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
    function withdraw(uint wad) public {
        require(balanceOf[msg.sender] >= wad);
        balanceOf[msg.sender] -= wad;
        payable(msg.sender).transfer(wad);
        emit Withdrawal(msg.sender, wad);
    }

    function totalSupply() public view returns (uint) {
        return address(this).balance;
    }

    function approve(address guy, uint wad) public returns (bool) {
        allowance[msg.sender][guy] = wad;
        emit Approval(msg.sender, guy, wad);
        return true;
    }

    function transfer(address dst, uint wad) public returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }

    function transferFrom(address src, address dst, uint wad)
        public
        returns (bool)
    {
        require(balanceOf[src] >= wad);

        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {
            require(allowance[src][msg.sender] >= wad);
            allowance[src][msg.sender] -= wad;
        }

        balanceOf[src] -= wad;
        balanceOf[dst] += wad;

        emit Transfer(src, dst, wad);

        return true;
    }
}",447
RealWorld_TA_96_TimeswapPairCallee_RealWorld_20240811221553.log,96,TimeswapPairCallee,117855,2508,120363,80.0,0.639435,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {ITimeswapBorrowCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapBorrowCallback.sol';
import {ITimeswapLendCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapLendCallback.sol';
import {ITimeswapMintCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapMintCallback.sol';
import {ITimeswapPayCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapPayCallback.sol';

contract TimeswapPairCallee {
    IPair public immutable pairContract;
    IFactory public immutable factoryContract;

    constructor(address pair) {
        pairContract = IPair(pair);
        factoryContract = IPair(pair).factory();
    }

    struct PairCalleeInfo {
        IERC20 asset;
        IERC20 collateral;
        address from;
    }
    struct PairCalleeInfoMint {
        IERC20 asset;
        IERC20 collateral;
        address assetFrom;
        address collateralFrom;
    }

    function getData(address from) public view returns (bytes memory data) {
        data = abi.encode(PairCalleeInfo(pairContract.asset(), pairContract.collateral(), from));
    }

    function getDataMint(address from) public view returns (bytes memory data) {
        data = abi.encode(PairCalleeInfoMint(pairContract.asset(), pairContract.collateral(), from, from));
    }

    function mint(
        uint256 maturity,
        address liquidityTo,
        uint112 xIncrease,
        uint112 yIncrease,
        uint112 zIncrease
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        return
            pairContract.mint(
                IPair.MintParam(
                    maturity,
                    liquidityTo,
                    address(this),
                    xIncrease,
                    yIncrease,
                    zIncrease,
                    getDataMint(msg.sender)
                )
            );
    }

    function lend(
        uint256 maturity,
        address bondTo,
        address insuranceTo,
        uint112 xIncrease,
        uint112 yDecrease,
        uint112 zDecrease
    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        return
            pairContract.lend(
                IPair.LendParam(maturity, bondTo, insuranceTo, xIncrease, yDecrease, zDecrease, getData(msg.sender))
            );
    }

    function borrow(
        uint256 maturity,
        address assetTo,
        address dueTo,
        uint112 xDecrease,
        uint112 yIncrease,
        uint112 zIncrease
    )
        external
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        return
            pairContract.borrow(
                IPair.BorrowParam(maturity, assetTo, dueTo, xDecrease, yIncrease, zIncrease, getData(msg.sender))
            );
    }

    function pay(
        uint256 maturity,
        address to,
        address owner,
        uint256[] memory ids,
        uint112[] memory assetsIn,
        uint112[] memory collateralsOut
    ) external returns (uint128 assetIn, uint128 collateralOut) {
        return
            pairContract.pay(IPair.PayParam(maturity, to, owner, ids, assetsIn, collateralsOut, getData(msg.sender)));
    }

    function timeswapMintCallback(
        uint256 assetIn,
        uint112 collateralIn,
        bytes calldata data
    ) external {
        (IERC20 asset, IERC20 collateral, address assetFrom, address collateralFrom) = abi.decode(
            data,
            (IERC20, IERC20, address, address)
        );
        IPair pair = factoryContract.getPair(asset, collateral);

        require(msg.sender == address(pair), 'Invalid sender');
        asset.transferFrom(assetFrom, address(pair), assetIn);
        collateral.transferFrom(collateralFrom, address(pair), collateralIn);
    }

    function timeswapLendCallback(uint256 assetIn, bytes calldata data) external {
        (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address));
        IPair pair = factoryContract.getPair(asset, collateral);

        require(msg.sender == address(pair), 'Invalid sender');
        asset.transferFrom(from, address(pair), assetIn);
    }

    function timeswapBorrowCallback(uint112 collateralIn, bytes calldata data) external {
        (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address));
        IPair pair = factoryContract.getPair(asset, collateral);

        require(msg.sender == address(pair), 'Invalid sender');
        collateral.transferFrom(from, address(pair), collateralIn);
    }

    function timeswapPayCallback(uint128 assetIn, bytes calldata data) external {
        (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address));
        IPair pair = factoryContract.getPair(asset, collateral);
        asset.transferFrom(from, address(pair), assetIn);
    }
}",1218
RealWorld_TA_96_TimeswapConvenience_RealWorld_20240811220134.log,96,TimeswapConvenience,400303,2985,403288,113.0,2.061215,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IConvenience} from './interfaces/IConvenience.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';
import {IWETH} from './interfaces/IWETH.sol';
import {IDue} from './interfaces/IDue.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {ITimeswapMintCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapMintCallback.sol';
import {ITimeswapLendCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapLendCallback.sol';
import {ITimeswapBorrowCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapBorrowCallback.sol';
import {ITimeswapPayCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapPayCallback.sol';
import {Mint} from './libraries/Mint.sol';
import {Burn} from './libraries/Burn.sol';
import {Lend} from './libraries/Lend.sol';
import {Withdraw} from './libraries/Withdraw.sol';
import {Borrow} from './libraries/Borrow.sol';
import {Pay} from './libraries/Pay.sol';
import {DeployNative} from './libraries/DeployNative.sol';
import {SafeTransfer} from './libraries/SafeTransfer.sol';

/// @title Timeswap Convenience
/// @author Timeswap Labs
/// @notice It is recommnded to use this contract to interact with Timeswap Core contract.
/// @notice All error messages are abbreviated and can be found in the documentation.
contract TimeswapConvenience is IConvenience {
    using SafeTransfer for IERC20;
    using Mint for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));
    using Burn for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));
    using Lend for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));
    using Withdraw for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));
    using Borrow for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));
    using Pay for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));
    using DeployNative for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));

    /* ===== MODEL ===== */

    /// @inheritdoc IConvenience
    IFactory public immutable override factory;
    /// @inheritdoc IConvenience
    IWETH public immutable override weth;

    /// @dev Stores the addresses of the Liquidty, Bond, Insurance, Collateralized Debt token contracts.
    mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native))) private natives;

    /* ===== VIEW ===== */

    /// @inheritdoc IConvenience
    function getNative(
        IERC20 asset,
        IERC20 collateral,
        uint256 maturity
    ) external view override returns (Native memory) {
        return natives[asset][collateral][maturity];
    }

    /* ===== INIT ===== */

    /// @dev Initializes the Convenience contract.
    /// @param _factory The address of factory contract used by this contract.
    /// @param _weth The address of the Wrapped ETH contract.
    constructor(IFactory _factory, IWETH _weth) {
        require(address(_factory) != address(0), 'E601');
        require(address(_weth) != address(0), 'E601');
        require(address(_factory) != address(_weth), 'E612');

        factory = _factory;
        weth = _weth;
    }

    /* ===== UPDATE ===== */

    receive() external payable {
        require(msg.sender == address(weth));
    }

    /// @inheritdoc IConvenience
    function deployPair(DeployPair calldata params) external override {
        factory.createPair(params.asset, params.collateral);
    }

    /// @inheritdoc IConvenience
    function deployNatives(DeployNatives calldata params) external override {
        natives.deploy(this, factory, params);
    }

    /// @inheritdoc IConvenience
    function newLiquidity(NewLiquidity calldata params)
        external
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.newLiquidity(this, factory, params);
    }

    /// @inheritdoc IConvenience
    function newLiquidityETHAsset(NewLiquidityETHAsset calldata params)
        external
        payable
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.newLiquidityETHAsset(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function newLiquidityETHCollateral(NewLiquidityETHCollateral calldata params)
        external
        payable
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.newLiquidityETHCollateral(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function liquidityGivenAsset(LiquidityGivenAsset calldata params)
        external
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.liquidityGivenAsset(this, factory, params);
    }

    /// @inheritdoc IConvenience
    function liquidityGivenAssetETHAsset(LiquidityGivenAssetETHAsset calldata params)
        external
        payable
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.liquidityGivenAssetETHAsset(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function liquidityGivenAssetETHCollateral(LiquidityGivenAssetETHCollateral calldata params)
        external
        payable
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.liquidityGivenAssetETHCollateral(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function liquidityGivenDebt(LiquidityGivenDebt calldata params)
        external
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.liquidityGivenDebt(this, factory, params);
    }

    /// @inheritdoc IConvenience
    function liquidityGivenDebtETHAsset(LiquidityGivenDebtETHAsset calldata params)
        external
        payable
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.liquidityGivenDebtETHAsset(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function liquidityGivenDebtETHCollateral(LiquidityGivenDebtETHCollateral calldata params)
        external
        payable
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.liquidityGivenDebtETHCollateral(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function liquidityGivenCollateral(LiquidityGivenCollateral calldata params)
        external
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.liquidityGivenCollateral(this, factory, params);
    }

    /// @inheritdoc IConvenience
    function liquidityGivenCollateralETHAsset(LiquidityGivenCollateralETHAsset calldata params)
        external
        payable
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.liquidityGivenCollateralETHAsset(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function liquidityGivenCollateralETHCollateral(LiquidityGivenCollateralETHCollateral calldata params)
        external
        payable
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.liquidityGivenCollateralETHCollateral(
            this,
            factory,
            weth,
            params
        );
    }

    /// @inheritdoc IConvenience
    function removeLiquidity(RemoveLiquidity calldata params)
        external
        override
        returns (uint256 assetOut, uint128 collateralOut)
    {
        (assetOut, collateralOut) = natives.removeLiquidity(factory, params);
    }

    /// @inheritdoc IConvenience
    function removeLiquidityETHAsset(RemoveLiquidityETHAsset calldata params)
        external
        override
        returns (uint256 assetOut, uint128 collateralOut)
    {
        (assetOut, collateralOut) = natives.removeLiquidityETHAsset(factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function removeLiquidityETHCollateral(RemoveLiquidityETHCollateral calldata params)
        external
        override
        returns (uint256 assetOut, uint128 collateralOut)
    {
        (assetOut, collateralOut) = natives.removeLiquidityETHCollateral(factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function lendGivenBond(LendGivenBond calldata params)
        external
        override
        returns (uint256 assetIn, IPair.Claims memory claimsOut)
    {
        (assetIn, claimsOut) = natives.lendGivenBond(this, factory, params);
    }

    /// @inheritdoc IConvenience
    function lendGivenBondETHAsset(LendGivenBondETHAsset calldata params)
        external
        payable
        override
        returns (uint256 assetIn, IPair.Claims memory claimsOut)
    {
        (assetIn, claimsOut) = natives.lendGivenBondETHAsset(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function lendGivenBondETHCollateral(LendGivenBondETHCollateral calldata params)
        external
        payable
        override
        returns (uint256 assetIn, IPair.Claims memory claimsOut)
    {
        (assetIn, claimsOut) = natives.lendGivenBondETHCollateral(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function lendGivenInsurance(LendGivenInsurance calldata params)
        external
        override
        returns (uint256 assetIn, IPair.Claims memory claimsOut)
    {
        (assetIn, claimsOut) = natives.lendGivenInsurance(this, factory, params);
    }

    /// @inheritdoc IConvenience
    function lendGivenInsuranceETHAsset(LendGivenInsuranceETHAsset calldata params)
        external
        payable
        override
        returns (uint256 assetIn, IPair.Claims memory claimsOut)
    {
        (assetIn, claimsOut) = natives.lendGivenInsuranceETHAsset(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function lendGivenInsuranceETHCollateral(LendGivenInsuranceETHCollateral calldata params)
        external
        override
        returns (uint256 assetIn, IPair.Claims memory claimsOut)
    {
        (assetIn, claimsOut) = natives.lendGivenInsuranceETHCollateral(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function lendGivenPercent(LendGivenPercent calldata params)
        external
        override
        returns (uint256 assetIn, IPair.Claims memory claimsOut)
    {
        (assetIn, claimsOut) = natives.lendGivenPercent(this, factory, params);
    }

    /// @inheritdoc IConvenience
    function lendGivenPercentETHAsset(LendGivenPercentETHAsset calldata params)
        external
        payable
        override
        returns (uint256 assetIn, IPair.Claims memory claimsOut)
    {
        (assetIn, claimsOut) = natives.lendGivenPercentETHAsset(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function lendGivenPercentETHCollateral(LendGivenPercentETHCollateral calldata params)
        external
        override
        returns (uint256 assetIn, IPair.Claims memory claimsOut)
    {
        (assetIn, claimsOut) = natives.lendGivenPercentETHCollateral(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function collect(Collect calldata params) external override returns (IPair.Tokens memory tokensOut) {
        tokensOut = natives.collect(factory, params);
    }

    /// @inheritdoc IConvenience
    function collectETHAsset(CollectETHAsset calldata params)
        external
        override
        returns (IPair.Tokens memory tokensOut)
    {
        tokensOut = natives.collectETHAsset(factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function collectETHCollateral(CollectETHCollateral calldata params)
        external
        override
        returns (IPair.Tokens memory tokensOut)
    {
        tokensOut = natives.collectETHCollateral(factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function borrowGivenDebt(BorrowGivenDebt calldata params)
        external
        override
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = natives.borrowGivenDebt(this, factory, params);
    }

    /// @inheritdoc IConvenience
    function borrowGivenDebtETHAsset(BorrowGivenDebtETHAsset calldata params)
        external
        override
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = natives.borrowGivenDebtETHAsset(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function borrowGivenDebtETHCollateral(BorrowGivenDebtETHCollateral calldata params)
        external
        payable
        override
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = natives.borrowGivenDebtETHCollateral(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function borrowGivenCollateral(BorrowGivenCollateral calldata params)
        external
        override
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = natives.borrowGivenCollateral(this, factory, params);
    }

    /// @inheritdoc IConvenience
    function borrowGivenCollateralETHAsset(BorrowGivenCollateralETHAsset calldata params)
        external
        override
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = natives.borrowGivenCollateralETHAsset(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function borrowGivenCollateralETHCollateral(BorrowGivenCollateralETHCollateral calldata params)
        external
        payable
        override
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = natives.borrowGivenCollateralETHCollateral(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function borrowGivenPercent(BorrowGivenPercent calldata params)
        external
        override
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = natives.borrowGivenPercent(this, factory, params);
    }

    /// @inheritdoc IConvenience
    function borrowGivenPercentETHAsset(BorrowGivenPercentETHAsset calldata params)
        external
        override
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = natives.borrowGivenPercentETHAsset(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function borrowGivenPercentETHCollateral(BorrowGivenPercentETHCollateral calldata params)
        external
        payable
        override
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = natives.borrowGivenPercentETHCollateral(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function repay(Repay memory params) external override returns (uint128 assetIn, uint128 collateralOut) {
        (assetIn, collateralOut) = natives.pay(factory, params);
    }

    /// @inheritdoc IConvenience
    function repayETHAsset(RepayETHAsset memory params)
        external
        payable
        override
        returns (uint128 assetIn, uint128 collateralOut)
    {
        (assetIn, collateralOut) = natives.payETHAsset(factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function repayETHCollateral(RepayETHCollateral memory params)
        external
        override
        returns (uint128 assetIn, uint128 collateralOut)
    {
        (assetIn, collateralOut) = natives.payETHCollateral(factory, weth, params);
    }

    /// @inheritdoc ITimeswapMintCallback
    function timeswapMintCallback(
        uint256 assetIn,
        uint112 collateralIn,
        bytes calldata data
    ) external override {
        (IERC20 asset, IERC20 collateral, address assetFrom, address collateralFrom) = abi.decode(
            data,
            (IERC20, IERC20, address, address)
        );
        IPair pair = factory.getPair(asset, collateral);

        require(msg.sender == address(pair), 'E701');

        IWETH _weth = weth;

        if (assetFrom == address(this)) {
            _weth.deposit{value: assetIn}();
            asset.safeTransfer(pair, assetIn);
        } else {
            asset.safeTransferFrom(assetFrom, pair, assetIn);
        }

        if (collateralFrom == address(this)) {
            _weth.deposit{value: collateralIn}();
            collateral.safeTransfer(pair, collateralIn);
        } else {
            collateral.safeTransferFrom(collateralFrom, pair, collateralIn);
        }
    }

    /// @inheritdoc ITimeswapLendCallback
    function timeswapLendCallback(uint256 assetIn, bytes calldata data) external override {
        (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address));
        IPair pair = factory.getPair(asset, collateral);

        require(msg.sender == address(pair), 'E701');

        if (from == address(this)) {
            weth.deposit{value: assetIn}();
            asset.safeTransfer(pair, assetIn);
        } else {
            asset.safeTransferFrom(from, pair, assetIn);
        }
    }

    /// @inheritdoc ITimeswapBorrowCallback
    function timeswapBorrowCallback(uint112 collateralIn, bytes calldata data) external override {
        (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address));
        IPair pair = factory.getPair(asset, collateral);
        require(msg.sender == address(pair), 'E701');
        if (from == address(this)) {
            weth.deposit{value: collateralIn}();
            collateral.safeTransfer(pair, collateralIn);
        } else {
            collateral.safeTransferFrom(from, pair, collateralIn);
        }
    }

    /// @inheritdoc ITimeswapPayCallback
    function timeswapPayCallback(uint128 assetIn, bytes calldata data) external override {
        (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address));

        IPair pair = factory.getPair(asset, collateral);
        require(msg.sender == address(pair), 'E701');

        if (from == address(this)) {
            weth.deposit{value: assetIn}();
            asset.safeTransfer(pair, assetIn);
        } else {
            asset.safeTransferFrom(from, pair, assetIn);
        }
    }
}",4769
RealWorld_TA_96_ITimeswapPayCallback_RealWorld_20240811220025.log,96,ITimeswapPayCallback,33672,1252,34924,67.0,0.1934,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

/// @title Callback for ITimeswapPair#pay
/// @notice Any contract that calls ITimeswapPair#pay must implement this interface
interface ITimeswapPayCallback {
    /// @notice Called to `msg.sender` after initiating a pay from ITimeswapPair#pay.
    /// @dev In the implementation you must pay the asset token owed for the pay transaction.
    /// The caller of this method must be checked to be a TimeswapPair deployed by the canonical TimeswapFactory.
    /// @param assetIn The amount of asset tokens owed due to the pool for the pay transaction
    /// @param data Any data passed through by the caller via the ITimeswapPair#pay call
    function timeswapPayCallback(
        uint128 assetIn,
        bytes calldata data
    ) external;
}",185
RealWorld_TA_96_IWithdraw_RealWorld_20240811232341.log,96,IWithdraw,38467,1289,39756,81.0,0.218115,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';

interface IWithdraw {
    struct Collect {
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address assetTo;
        address collateralTo;
        IPair.Claims claimsIn;
    }

    struct CollectETHAsset {
        IERC20 collateral;
        uint256 maturity;
        address payable assetTo;
        address collateralTo;
        IPair.Claims claimsIn;
    }

    struct CollectETHCollateral {
        IERC20 asset;
        uint256 maturity;
        address assetTo;
        address payable collateralTo;
        IPair.Claims claimsIn;
    }

    struct _Collect {
        IFactory factory;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address assetTo;
        address collateralTo;
        IPair.Claims claimsIn;
    }
}",254
RealWorld_TA_96_NFTSVG_RealWorld_20240811224745.log,96,NFTSVG,870025,68,870093,99.0,4.351485,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

library NFTSVG {
    struct SVGParams {
        string tokenId;
        string svgTitle;
        string assetInfo;
        string collateralInfo;
        string debtRequired;
        string collateralLocked;
        string maturityDate;
        string maturityTimestampString;
        string tokenColors;
        bool isMatured;
    }

    function constructSVG(SVGParams memory params) public pure returns (string memory) {
        string memory colorScheme = params.isMatured
            ? '.G{stop-color:#3C3C3C}.H{fill:#959595}.I{stop-color:#000000}.J{stop-color:#FFFFFF}'
            : '.G{stop-color:#20087E}.H{fill:#5457D7}.I{stop-color:#61F6FF}.J{stop-color:#3C43FF}';

        string memory svg = string(
            abi.encodePacked(
                '<svg width=""290"" height=""500"" xmlns=""http://www.w3.org/2000/svg"" xmlns:xlink=""http://www.w3.org/1999/xlink""><style type=""text/css"" ><![CDATA[.B{fill-rule:evenodd}',
                params.tokenColors,
                colorScheme,
                ']]></style><g clip-path=""url(#mainclip)""><rect width=""290"" height=""500"" fill=""url(\'#background\')""/><rect y=""409"" width=""290"" height=""90"" fill=""#141330"" fill-opacity=""0.4""/><rect y=""408"" width=""290"" height=""2"" fill=""url(#divider)""/></g><text y=""70px"" x=""145"" fill=""white"" font-family=""arial"" font-weight=""500"" font-size=""24px"" text-anchor=""middle"">'
            )
        );

        svg = string(
            abi.encodePacked(
                svg,
                params.svgTitle,
                '</text><text y=""95px"" x=""145"" fill=""white"" font-family=""arial"" font-weight=""400"" font-size=""12px"" text-anchor=""middle"">',
                params.maturityDate,
                '</text>'
            )
        );

        if (!params.isMatured) {
            string memory maturityInfo = string(abi.encodePacked('MATURITY: ', params.maturityTimestampString));
            svg = string(
                abi.encodePacked(
                    svg,
                    '<text y=""115px"" x=""145"" fill=""white"" font-family=""arial"" font-weight=""300"" font-size=""10px"" text-anchor=""middle"" opacity=""50%"">',
                    maturityInfo,
                    '</text>'
                )
            );
        } else {
            svg = string(
                abi.encodePacked(
                    svg,
                    '<rect width=""74"" height=""22"" rx=""13"" y=""110"" x=""107"" text-anchor=""middle"" fill=""#FFFFFF"" /><text y=""125px"" x=""145"" fill=""black"" font-family=""arial"" font-weight=""600"" font-size=""10px"" letter-spacing=""1"" text-anchor=""middle"">MATURED</text>'
                )
            );
        }

        svg = string(
            abi.encodePacked(
                svg,
                '<text text-rendering=""optimizeSpeed""><textPath startOffset=""-100%"" fill=""white"" font-family=""\'Courier New\', monospace"" font-size=""10px"" xlink:href=""#text-path-a"">',
                params.assetInfo,
                '<animate additive=""sum"" attributeName=""startOffset"" from=""0%"" to=""100%"" begin=""0s"" dur=""30s"" repeatCount=""indefinite"" /></textPath><textPath startOffset=""0%"" fill=""white"" font-family=""\'Courier New\', monospace"" font-size=""10px"" xlink:href=""#text-path-a"">',
                params.assetInfo,
                '<animate additive=""sum"" attributeName=""startOffset"" from=""0%"" to=""100%"" begin=""0s"" dur=""30s"" repeatCount=""indefinite"" /></textPath><textPath startOffset=""50%"" fill=""white"" font-family=""\'Courier New\', monospace"" font-size=""10px"" xlink:href=""#text-path-a"">'
            )
        );
        svg = string(
            abi.encodePacked(
                svg,
                params.collateralInfo,
                '<animate additive=""sum"" attributeName=""startOffset"" from=""0%"" to=""100%"" begin=""0s"" dur=""30s"" repeatCount=""indefinite"" /></textPath><textPath startOffset=""-50%"" fill=""white"" font-family=""\'Courier New\', monospace"" font-size=""10px"" xlink:href=""#text-path-a"">',
                params.collateralInfo,
                '<animate additive=""sum"" attributeName=""startOffset"" from=""0%"" to=""100%"" begin=""0s"" dur=""30s"" repeatCount=""indefinite"" /></textPath></text><text y=""435px"" x=""12"" fill=""white"" font-family=""arial"" font-weight=""400"" font-size=""13px"" opacity=""60%"">ID:</text><text y=""435px"" x=""278"" fill=""white"" font-family=""arial"" font-weight=""500"" font-size=""13px"" text-anchor=""end"">'
            )
        );
        svg = string(
            abi.encodePacked(
                svg,
                params.tokenId,
                '</text><text y=""460px"" x=""12"" fill=""white"" font-family=""arial"" font-weight=""400"" font-size=""13px"" opacity=""60%"">Debt required:</text><text y=""460px"" x=""278"" fill=""white"" font-family=""arial"" font-weight=""500"" font-size=""13px"" text-anchor=""end"">',
                params.debtRequired,
                '</text><text y=""484px"" x=""12"" fill=""white"" font-family=""arial"" font-weight=""400"" font-size=""13px"" opacity=""60%"">Collateral locked:</text><text y=""484px"" x=""278"" fill=""white"" font-family=""arial"" font-weight=""500"" font-size=""13px"" text-anchor=""end"">',
                params.collateralLocked,
                '</text><g filter=""url(#filter0_f)""><path d=""M253 319.5C253 346.838 204.871 369 145.5 369C86.1294 369 38 346.838 38 319.5C38 292.162 86.1294 270 145.5 270C204.871 270 253 292.162 253 319.5Z"" class=""H""/></g>'
            )
        );
        svg = string(
            abi.encodePacked(
                svg,
                '<path d=""M144.235 272.663h4.147v11.255h-4.147zm62.092 19.456l2.074 2.089-16.76 5.627-2.074-2.089zm-26.564-14.565l3.591 1.206-9.676 9.747-3.591-1.206zm37.046 34.903v2.412h-19.353v-2.412zm-33.454 36.11l-3.591 1.206-9.676-9.747 3.591-1.206zm25.046-15.448l-2.074 2.089-16.76-5.627 2.074-2.089zm-64.165 10.289h4.147v11.255h-4.147zm-43.258-15.916l2.074 2.089-16.76 5.627-2.074-2.089zm17.962 11.328l3.591 1.206-9.676 9.747-3.591-1.206zm-25.778-26.157v2.412H73.809v-2.412zm28.915-26.253l-3.591 1.206-9.676-9.747 3.591-1.206zm-20.434 10.881l-2.074 2.089-16.76-5.627 2.074-2.089z"" fill=""#6fa4d4""/><path d=""M198.383 344.249C211.892 336.376 220 325.646 220 314s-8.108-22.376-21.617-30.249C184.898 275.893 166.204 271 145.5 271s-39.398 4.893-52.883 12.751C79.108 291.624 71 302.354 71 314s8.108 22.376 21.617 30.249C106.102 352.107 124.796 357 145.5 357s39.398-4.893 52.883-12.751zM145.5 358c41.698 0 75.5-19.699 75.5-44s-33.802-44-75.5-44S70 289.699 70 314s33.803 44 75.5 44zm56.402-10.206C216.307 339.026 225 327.049 225 314s-8.693-25.026-23.098-33.794C187.516 271.449 167.577 266 145.5 266s-42.016 5.449-56.402 14.206C74.694 288.974 66 300.951 66 314s8.694 25.026 23.098 33.794C103.484 356.551 123.423 362 145.5 362s42.016-5.449 56.402-14.206zM145.5 363c44.459 0 80.5-21.938 80.5-49s-36.041-49-80.5-49S65 286.938 65 314s36.041 49 80.5 49z"" fill-rule=""evenodd"" fill=""#6fa4d5""/><path d=""M189.764 303.604c0 14.364-19.951 26.008-44.562 26.008-24.343 0-44.127-11.392-44.555-25.54v6.92.363c0 14.38 19.951 26.022 44.562 26.022s44.562-11.642 44.562-26.022v-.363-7.574h-.008l.001.186z"" fill=""#7fc2e2""/><path d=""M145.202 326.408c21.834 0 39.533-10.256 39.533-22.906s-17.699-22.906-39.533-22.906-39.533 10.255-39.533 22.906 17.7 22.906 39.533 22.906z"" fill=""#020136""/><path d=""M189.764 303.604c0 14.364-19.951 26.008-44.562 26.008s-44.562-11.644-44.562-26.008 19.951-26.008 44.562-26.008 44.562 11.644 44.562 26.008zm-5.029-.102c0 12.65-17.699 22.906-39.533 22.906s-39.533-10.255-39.533-22.906 17.699-22.906 39.533-22.906 39.533 10.256 39.533 22.906z"" fill=""#4f95b8"" class=""B""/><path d=""M184.753 303.84v-5.406c0-18.859-10.806-36.185-28.114-45.047l-3.987-2.053a2.31 2.31 0 0 1-.975-.848 2.46 2.46 0 0 1-.39-1.259 2.47 2.47 0 0 1 .316-1.282c.216-.384.536-.699.924-.908l6.693-3.887c15.85-9.252 25.533-25.798 25.533-43.637V184h-78.996v15.095c0 18.065 9.925 34.782 26.098 43.959l6.772 3.846a2.34 2.34 0 0 1 .937.911c.223.39.334.839.321 1.293s-.15.894-.395 1.27-.588.671-.988.851l-4.105 2.053c-17.598 8.772-28.64 26.249-28.64 45.32v4.948c-.624 6.062 3.212 12.255 11.581 16.901 15.515 8.616 40.595 8.664 56.011.096 8.238-4.584 12.008-10.688 11.404-16.703h0z"" fill=""#fff"" fill-opacity="".3""/><path d=""M154.382 238.266c3.037-5.261 3.007-10.965-.062-12.737l2.734 1.579c3.069 1.772 3.098 7.476.061 12.737s-7.992 8.088-11.061 6.316l-2.734-1.579c3.069 1.772 8.025-1.055 11.062-6.315v-.001z"" class=""D""/><path d=""M154.382 238.266c3.037-5.261 3.007-10.965-.062-12.737s-8.024 1.055-11.061 6.316-3.008 10.965.061 12.737 8.025-1.055 11.062-6.315v-.001zm-1.402-.809c2.27-3.932 2.252-8.2-.045-9.526s-6.004.792-8.274 4.724-2.247 8.192.051 9.519 5.998-.784 8.268-4.716v-.001z"" class=""B C""/><path d=""M152.935 227.929c2.297 1.326 2.315 5.595.045 9.526s-5.971 6.042-8.268 4.716-2.321-5.587-.051-9.519 5.975-6.051 8.273-4.724l.001.001z"" class=""D""/><path d=""M148.854 232.173l1.827-2.157c.303-.364.664-.269.607.154l-.349 2.545c-.021.163.023.302.121.349l1.488.806c.241.139.107.695-.237.951l-2.028 1.534a.91.91 0 0 0-.316.438l-.91 2.656c-.155.449-.597.692-.75.437l-.938-1.578c-.031-.052-.08-.09-.139-.107s-.121-.01-.174.019l-2.043.841c-.35.139-.475-.274-.238-.686l1.458-2.525a.81.81 0 0 0 .118-.492l-.345-2.136a.8.8 0 0 1 .142-.539.81.81 0 0 1 .457-.318l1.85.033a.56.56 0 0 0 .223-.071.57.57 0 0 0 .176-.155v.001z"" class=""C""/><path d=""M166.548 230.55c4.318-4.272 5.796-9.782 3.303-12.302l2.221 2.245c2.492 2.519 1.014 8.029-3.304 12.301s-9.844 5.691-12.336 3.171l-2.221-2.245c2.492 2.52 8.018 1.102 12.337-3.17z"" class=""D""/><path d=""M166.548 230.549c4.318-4.272 5.796-9.782 3.303-12.302s-8.017-1.101-12.336 3.171-5.797 9.782-3.304 12.301 8.018 1.102 12.337-3.17zm-1.139-1.151c3.228-3.193 4.338-7.314 2.472-9.2s-6-.821-9.227 2.371-4.33 7.308-2.464 9.194 5.993.827 9.22-2.366l-.001.001z"" class=""B C""/><path d=""M167.881 220.199c1.866 1.886.755 6.008-2.472 9.2s-7.354 4.252-9.22 2.366-.763-6.002 2.464-9.194 7.36-4.258 9.227-2.371l.001-.001z"" class=""D""/><path d=""M162.824 223.215l2.332-1.599c.388-.271.711-.084.545.308l-1.008 2.363c-.064.152-.057.298.024.369l1.222 1.17c.196.198-.08.699-.48.854l-2.361.944c-.172.067-.318.186-.421.339l-1.579 2.321c-.268.392-.758.51-.839.224l-.488-1.77c-.015-.059-.052-.109-.104-.141s-.115-.04-.174-.026l-2.193.271c-.375.042-.386-.39-.048-.725l2.072-2.05a.81.81 0 0 0 .244-.443l.231-2.151a.81.81 0 0 1 .28-.483c.148-.123.333-.188.524-.186l1.776.52c.078.013.158.01.234-.009a.56.56 0 0 0 .211-.103v.003z"" class=""C""/><path d=""M131.352 236.907c4.692 3.858 10.325 4.762 12.576 2.024l-2.005 2.439c-2.251 2.738-7.883 1.832-12.575-2.025s-6.67-9.208-4.419-11.946l2.005-2.439c-2.251 2.738-.274 8.089 4.419 11.947h-.001z"" class=""D""/><path d=""M131.352 236.907c4.692 3.858 10.325 4.762 12.576 2.024s.273-8.088-4.419-11.946-10.324-4.763-12.575-2.025-.274 8.089 4.419 11.947h-.001zm1.028-1.251c3.507 2.883 7.721 3.564 9.405 1.515s.202-6.052-3.305-8.935-7.714-3.558-9.399-1.508-.208 6.046 3.299 8.929v-.001z"" class=""B C""/><path d=""M141.785 237.172c-1.685 2.049-5.898 1.368-9.405-1.515s-4.983-6.879-3.299-8.929 5.892-1.374 9.399 1.509 4.991 6.885 3.305 8.935z"" class=""D""/><path d=""M138.267 232.451l1.829 2.156c.309.359.156.699-.251.574l-2.454-.76c-.157-.048-.302-.026-.364.062l-1.039 1.335c-.177.215-.703-.008-.899-.39l-1.181-2.252c-.084-.164-.217-.298-.381-.384l-2.471-1.333c-.417-.227-.585-.702-.309-.812l1.71-.667c.057-.021.103-.064.128-.12s.03-.117.009-.174l-.495-2.153c-.08-.368.349-.424.716-.122l2.252 1.851a.81.81 0 0 0 .466.197l2.164.009a.81.81 0 0 1 .509.228c.138.134.221.312.239.503l-.336 1.82a.59.59 0 0 0 .033.232c.026.074.069.142.124.2h.001z"" class=""C""/><path d=""M119.071 225.508c3.876 4.677 9.235 6.633 11.964 4.372l-2.431 2.015c-2.729 2.261-8.087.305-11.963-4.373s-4.803-10.306-2.074-12.567l2.431-2.015c-2.729 2.261-1.802 7.89 2.073 12.568z"" class=""D""/><path d=""M119.071 225.508c3.876 4.677 9.235 6.633 11.964 4.372s1.802-7.89-2.074-12.567-9.234-6.634-11.963-4.373-1.802 7.89 2.073 12.568zm1.247-1.033c2.897 3.496 6.905 4.964 8.947 3.271s1.346-5.904-1.551-9.4-6.9-4.956-8.942-3.263-1.351 5.896 1.546 9.392h0z"" class=""B C""/><path d=""M129.265 227.745c-2.043 1.693-6.051.225-8.947-3.271s-3.589-7.699-1.546-9.392 6.045-.233 8.942 3.263 3.595 7.707 1.551 9.4h0z"" class=""D""/><path d=""M126.705 222.444l1.387 2.463c.235.411.021.716-.355.516l-2.265-1.212c-.145-.077-.292-.083-.369-.008l-1.273 1.114c-.214.177-.689-.141-.809-.553l-.733-2.435a.9.9 0 0 0-.301-.449l-2.173-1.777c-.367-.302-.441-.8-.149-.856l1.806-.331c.06-.01.114-.043.15-.092s.05-.111.041-.171l-.078-2.208c-.009-.377.423-.35.726.016l1.86 2.245a.81.81 0 0 0 .42.282l2.123.419c.186.049.347.163.456.32s.158.349.139.539l-.674 1.723c-.02.077-.023.156-.012.234s.041.152.084.219l-.001.002z"" class=""C""/><path d=""M140.196 225.21c5.607 2.338 11.261 1.576 12.624-1.695l-1.215 2.914c-1.364 3.271-7.017 4.031-12.624 1.694s-9.046-6.888-7.682-10.16l1.215-2.914c-1.364 3.271 2.075 7.823 7.682 10.161h0z"" class=""D""/><path d=""M140.196 225.211c5.607 2.337 11.261 1.576 12.624-1.695s-2.075-7.822-7.682-10.16-11.26-1.577-12.624 1.694 2.075 7.823 7.682 10.161h0zm.623-1.494c4.19 1.747 8.421 1.182 9.442-1.266s-1.555-5.853-5.746-7.599-8.413-1.178-9.434 1.271 1.547 5.848 5.737 7.595l.001-.001z"" class=""B C""/><path d=""M150.261 222.449c-1.021 2.449-5.252 3.013-9.442 1.266s-6.758-5.146-5.737-7.595 5.243-3.018 9.434-1.271 6.767 5.15 5.746 7.6h-.001z"" class=""D""/><path d=""M145.528 218.948l2.374 1.535c.4.254.352.624-.074.622l-2.569-.019c-.165 0-.297.062-.331.164l-.609 1.579c-.107.257-.675.196-.973-.114l-1.781-1.815a.9.9 0 0 0-.475-.257l-2.751-.562c-.465-.097-.763-.503-.53-.688l1.445-1.133c.048-.037.079-.091.088-.151s-.006-.121-.041-.17l-1.096-1.919c-.183-.329.211-.507.65-.324l2.691 1.122c.157.071.334.09.503.054l2.074-.616c.187-.043.383-.017.553.072a.81.81 0 0 1 .374.412l.205 1.839c.018.077.052.149.099.213a.57.57 0 0 0 .176.155h0l-.002.001z"" class=""C""/><path d=""M147.623 266.948c3.037-5.26 3.007-10.965-.062-12.737l2.734 1.579c3.069 1.772 3.098 7.476.061 12.737s-7.992 8.087-11.061 6.315l-2.734-1.579c3.069 1.772 8.025-1.054 11.062-6.315h0z"" class=""F""/><path d=""M147.623 266.948c3.037-5.26 3.007-10.965-.062-12.737s-8.024 1.055-11.061 6.315-3.008 10.965.061 12.737 8.025-1.054 11.062-6.315zm-1.402-.809c2.27-3.932 2.252-8.2-.045-9.526s-6.004.791-8.274 4.723-2.247 8.192.051 9.519 5.998-.785 8.268-4.716h0z"" class=""B E""/><path d=""M146.176 256.612c2.297 1.327 2.315 5.595.045 9.527s-5.971 6.042-8.268 4.716-2.321-5.587-.051-9.519 5.975-6.051 8.273-4.724h.001z"" class=""F""/><path d=""M142.095 260.856l1.827-2.157c.303-.364.664-.269.607.153l-.349 2.546c-.021.163.023.302.121.349l1.488.806c.241.139.107.695-.237.951l-2.028 1.534c-.148.11-.258.263-.316.438l-.91 2.656c-.155.449-.597.692-.75.437l-.938-1.578c-.031-.052-.08-.091-.139-.107a.23.23 0 0 0-.174.02l-2.043.84c-.35.14-.475-.274-.238-.686l1.458-2.525a.81.81 0 0 0 .118-.492l-.345-2.136c-.019-.191.032-.381.142-.539a.81.81 0 0 1 .457-.318l1.85.034c.078-.009.154-.033.223-.071s.129-.091.176-.155h0z"" class=""E""/><use xlink:href=""#B"" class=""F""/><path d=""M124 306.844c6.075 0 11-2.879 11-6.423S130.075 294 124 294s-11 2.877-11 6.421 4.926 6.423 11 6.423zm0-1.619c4.54 0 8.228-2.15 8.228-4.803s-3.688-4.803-8.228-4.803-8.218 2.151-8.218 4.803 3.678 4.803 8.218 4.803z"" class=""B E""/><use xlink:href=""#C"" class=""F""/><use xlink:href=""#D"" class=""E""/><use xlink:href=""#B"" x=""6"" y=""9"" class=""F""/><path d=""M130 315.844c6.075 0 11-2.879 11-6.423S136.075 303 130 303s-11 2.877-11 6.421 4.926 6.423 11 6.423zm0-1.619c4.54 0 8.228-2.15 8.228-4.803s-3.688-4.803-8.228-4.803-8.218 2.151-8.218 4.803 3.678 4.803 8.218 4.803z"" class=""B E""/><use xlink:href=""#C"" x=""6"" y=""9"" class=""F""/><use xlink:href=""#D"" x=""6"" y=""9"" class=""E""/><use xlink:href=""#B"" x=""29"" y=""12"" class=""F""/><path d=""M153 318.844c6.075 0 11-2.879 11-6.423S159.075 306 153 306s-11 2.877-11 6.421 4.926 6.423 11 6.423zm0-1.619c4.54 0 8.228-2.15 8.228-4.803s-3.688-4.803-8.228-4.803-8.218 2.151-8.218 4.803 3.678 4.803 8.218 4.803z"" class=""B E""/><use xlink:href=""#C"" x=""29"" y=""12"" class=""F""/><use xlink:href=""#D"" x=""29"" y=""12"" class=""E""/><use xlink:href=""#E"" class=""F""/><path d=""M165 304.844c6.074 0 11-2.879 11-6.423S171.074 292 165 292s-11 2.877-11 6.421 4.926 6.423 11 6.423zm0-1.619c4.54 0 8.227-2.15 8.227-4.803s-3.687-4.803-8.227-4.803-8.218 2.151-8.218 4.803 3.678 4.803 8.218 4.803z"" class=""B E""/><use xlink:href=""#F"" class=""F""/><path d=""M167.512 297.01l2.781.504c.467.081.565.44.171.603l-2.378.97c-.152.064-.251.172-.242.28l.045 1.691c0 .278-.548.44-.942.27l-2.342-.99c-.17-.073-.357-.092-.538-.054l-2.755.539c-.466.09-.898-.17-.754-.431l.898-1.601c.03-.053.038-.115.023-.174a.23.23 0 0 0-.104-.141l-1.75-1.349c-.295-.233 0-.549.476-.549h2.915c.173.005.343-.045.485-.143l1.678-1.367a.8.8 0 0 1 .537-.147.81.81 0 0 1 .504.237l.897 1.619c.046.064.105.118.172.158a.56.56 0 0 0 .223.075h0z"" class=""E""/><use xlink:href=""#E"" x=""-6"" y=""7"" class=""F""/><path d=""M159 311.844c6.074 0 11-2.879 11-6.423S165.074 299 159 299s-11 2.877-11 6.421 4.926 6.423 11 6.423zm0-1.619c4.54 0 8.227-2.15 8.227-4.803s-3.687-4.803-8.227-4.803-8.218 2.151-8.218 4.803 3.678 4.803 8.218 4.803z"" class=""B E""/><use xlink:href=""#F"" x=""-6"" y=""7"" class=""F""/><path d=""M161.512 304.01l2.781.504c.467.081.565.44.171.603l-2.378.97c-.152.064-.251.172-.242.28l.045 1.691c0 .278-.548.44-.942.27l-2.342-.99c-.17-.073-.357-.092-.538-.054l-2.755.539c-.466.09-.898-.17-.754-.431l.898-1.601c.03-.053.038-.115.023-.174s-.052-.11-.103-.141l-1.75-1.349c-.296-.233 0-.549.476-.549h2.915c.173.005.343-.045.485-.143l1.678-1.367a.8.8 0 0 1 .537-.147.81.81 0 0 1 .504.237l.897 1.619c.046.064.105.118.172.158a.56.56 0 0 0 .223.075h-.001z"" class=""E""/><path d=""M189.764 174.008c0 14.364-19.951 26.008-44.562 26.008-24.343 0-44.127-11.392-44.555-25.54v6.928.356c0 14.38 19.951 26.022 44.562 26.022s44.562-11.641 44.562-26.022v-.356-7.581h-.008l.001.185z"" fill=""#2f2be1"" class=""B""/><path d=""M144.5 194c19.054 0 34.5-8.954 34.5-20s-15.446-20-34.5-20-34.5 8.954-34.5 20 15.446 20 34.5 20z"" fill=""#232277""/><path d=""M189.764 174.008c0 14.364-19.951 26.008-44.562 26.008s-44.562-11.644-44.562-26.008S120.591 148 145.202 148s44.562 11.644 44.562 26.008zM179 174c0 11.046-15.446 20-34.5 20s-34.5-8.954-34.5-20 15.446-20 34.5-20 34.5 8.954 34.5 20z"" fill=""#504df7"" class=""B""/><path d=""M155.683 172.788l-12.188 3.486c-1.635.467-3.657-.207-3.774-1.258l-.864-7.836c-.103-.91.257-1.804 1.034-2.582l.602-.601c.55-.55 1.813-.725 2.816-.39l15.507 5.168c1.007.336 1.373 1.053.823 1.604l-.601.601c-.778.777-1.939 1.404-3.355 1.808z"" fill=""#7b78ff""/><path d=""M133.955 172.081l12.187-3.485c1.635-.467 3.657.207 3.774 1.258l.865 7.835c.103.91-.258 1.805-1.036 2.583l-.601.601c-.55.55-1.813.725-2.817.39l-15.507-5.168c-1.006-.336-1.373-1.054-.823-1.604l.602-.601c.777-.777 1.939-1.404 3.356-1.809z"" fill=""#9fd2eb""/><path d=""M149.915 169.853c-.116-1.051-2.138-1.725-3.773-1.258l-6.91 1.977.492 4.444c.117 1.051 2.139 1.725 3.774 1.258l6.91-1.977-.493-4.444z"" fill=""#11429f""/><defs><filter id=""filter0_f"" x=""-32"" y=""200"" width=""355"" height=""239"" filterUnits=""userSpaceOnUse"" color-interpolation-filters=""sRGB""><feFlood flood-opacity=""0"" result=""BackgroundImageFix""/><feBlend mode=""normal"" in=""SourceGraphic"" in2=""BackgroundImageFix"" result=""shape""/><feGaussianBlur stdDeviation=""35"" result=""effect1_foregroundBlur""/></filter><linearGradient id=""background"" x1=""273.47"" y1=""-13.2813"" x2=""415.619"" y2=""339.655"" gradientUnits=""userSpaceOnUse""><stop stop-color=""#0B0B16""/><stop offset=""1"" class=""G""/></linearGradient><linearGradient id=""divider"" x1=""1.47345e-06"" y1=""409"" x2=""298.995"" y2=""410.864"" gradientUnits=""userSpaceOnUse""><stop class=""I""/><stop offset=""0.5"" class=""J""/><stop offset=""1"" class=""I""/></linearGradient><clipPath id=""mainclip""><rect width=""290"" height=""500"" rx=""20"" fill=""white""/></clipPath><path id=""text-path-a"" d=""M40 10 h228 a12,12 0 0 1 12 12 v364 a12,12 0 0 1 -12 12 h-246 a12 12 0 0 1 -12 -12 v-364 a12 12 0 0 1 12 -12 z"" /><path id=""B"" d=""M124 306.844c6.075 0 11-2.879 11-6.423v3.158c0 3.544-4.925 6.421-11 6.421s-11-2.877-11-6.421v-3.158c0 3.544 4.926 6.423 11 6.423z""/><path id=""C"" d=""M132.227 300.422c0 2.653-3.688 4.803-8.228 4.803s-8.218-2.15-8.218-4.803 3.678-4.803 8.218-4.803 8.228 2.15 8.228 4.803z""/><path id=""D"" d=""M126.512 299.01l2.782.504c.466.081.565.44.171.603l-2.379.97c-.152.064-.25.172-.242.28l.046 1.691c0 .278-.548.44-.942.27l-2.342-.99c-.169-.073-.357-.092-.538-.054l-2.755.539c-.466.09-.898-.17-.754-.431l.898-1.601c.03-.053.038-.115.023-.174s-.052-.11-.103-.141l-1.75-1.349c-.296-.233 0-.549.476-.549h2.915c.173.005.342-.045.485-.143l1.677-1.367a.8.8 0 0 1 .538-.147.81.81 0 0 1 .504.237l.897 1.619a.57.57 0 0 0 .395.233h-.002z""/><path id=""E"" d=""M165 304.844c6.074 0 11-2.879 11-6.423v3.158c0 3.544-4.926 6.421-11 6.421s-11-2.877-11-6.421v-3.158c0 3.544 4.926 6.423 11 6.423z""/><path id=""F"" d=""M173.227 298.422c0 2.653-3.687 4.803-8.227 4.803s-8.218-2.15-8.218-4.803 3.678-4.803 8.218-4.803 8.227 2.15 8.227 4.803z""/></defs></svg>'
            )
        );

        return svg;
    }
}",10052
RealWorld_TA_96_SafeBalance_RealWorld_20240811214213.log,96,SafeBalance,29544,1481,31025,70.0,0.17734,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {Address} from '@openzeppelin/contracts/utils/Address.sol';

library SafeBalance {
    using Address for address;

    function safeBalance(
        IERC20 token
    ) internal view returns (uint256) {
        bytes memory data =
            address(token).functionStaticCall(
                abi.encodeWithSelector(IERC20.balanceOf.selector, address(this)),
                ""balanceOf Call to IERC20 token not successful""
            );
        return abi.decode(data, (uint256));
    }
}",142
RealWorld_TA_96_Lend_RealWorld_20240811222804.log,96,Lend,249934,3419,253353,103.0,1.31805,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IConvenience} from '../interfaces/IConvenience.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';
import {IWETH} from '../interfaces/IWETH.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {ILend} from '../interfaces/ILend.sol';
import {LendMath} from './LendMath.sol';
import {Deploy} from './Deploy.sol';
import {MsgValue} from './MsgValue.sol';

library Lend {
    using LendMath for IPair;
    using Deploy for IConvenience.Native;

    function lendGivenBond(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        ILend.LendGivenBond calldata params
    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        (assetIn, claimsOut) = _lendGivenBond(
            natives,
            ILend._LendGivenBond(
                convenience,
                factory,
                params.asset,
                params.collateral,
                params.maturity,
                msg.sender,
                params.bondTo,
                params.insuranceTo,
                params.assetIn,
                params.bondOut,
                params.minInsurance,
                params.deadline
            )
        );
    }

    function lendGivenBondETHAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        ILend.LendGivenBondETHAsset calldata params
    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        uint112 assetInETH = MsgValue.getUint112();

        (assetIn, claimsOut) = _lendGivenBond(
            natives,
            ILend._LendGivenBond(
                convenience,
                factory,
                weth,
                params.collateral,
                params.maturity,
                address(this),
                params.bondTo,
                params.insuranceTo,
                assetInETH,
                params.bondOut,
                params.minInsurance,
                params.deadline
            )
        );
    }

    function lendGivenBondETHCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        ILend.LendGivenBondETHCollateral calldata params
    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        (assetIn, claimsOut) = _lendGivenBond(
            natives,
            ILend._LendGivenBond(
                convenience,
                factory,
                params.asset,
                weth,
                params.maturity,
                msg.sender,
                params.bondTo,
                params.insuranceTo,
                params.assetIn,
                params.bondOut,
                params.minInsurance,
                params.deadline
            )
        );
    }

    function lendGivenInsurance(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        ILend.LendGivenInsurance calldata params
    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        (assetIn, claimsOut) = _lendGivenInsurance(
            natives,
            ILend._LendGivenInsurance(
                convenience,
                factory,
                params.asset,
                params.collateral,
                params.maturity,
                msg.sender,
                params.bondTo,
                params.insuranceTo,
                params.assetIn,
                params.insuranceOut,
                params.minBond,
                params.deadline
            )
        );
    }

    function lendGivenInsuranceETHAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        ILend.LendGivenInsuranceETHAsset calldata params
    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        uint112 assetInETH = MsgValue.getUint112();

        (assetIn, claimsOut) = _lendGivenInsurance(
            natives,
            ILend._LendGivenInsurance(
                convenience,
                factory,
                weth,
                params.collateral,
                params.maturity,
                address(this),
                params.bondTo,
                params.insuranceTo,
                assetInETH,
                params.insuranceOut,
                params.minBond,
                params.deadline
            )
        );
    }

    function lendGivenInsuranceETHCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        ILend.LendGivenInsuranceETHCollateral calldata params
    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        (assetIn, claimsOut) = _lendGivenInsurance(
            natives,
            ILend._LendGivenInsurance(
                convenience,
                factory,
                params.asset,
                weth,
                params.maturity,
                msg.sender,
                params.bondTo,
                params.insuranceTo,
                params.assetIn,
                params.insuranceOut,
                params.minBond,
                params.deadline
            )
        );
    }

    function lendGivenPercent(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        ILend.LendGivenPercent calldata params
    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        (assetIn, claimsOut) = _lendGivenPercent(
            natives,
            ILend._LendGivenPercent(
                convenience,
                factory,
                params.asset,
                params.collateral,
                params.maturity,
                msg.sender,
                params.bondTo,
                params.insuranceTo,
                params.assetIn,
                params.percent,
                params.minBond,
                params.minInsurance,
                params.deadline
            )
        );
    }

    function lendGivenPercentETHAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        ILend.LendGivenPercentETHAsset calldata params
    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        uint112 assetInETH = MsgValue.getUint112();

        (assetIn, claimsOut) = _lendGivenPercent(
            natives,
            ILend._LendGivenPercent(
                convenience,
                factory,
                weth,
                params.collateral,
                params.maturity,
                address(this),
                params.bondTo,
                params.insuranceTo,
                assetInETH,
                params.percent,
                params.minBond,
                params.minInsurance,
                params.deadline
            )
        );
    }

    function lendGivenPercentETHCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        ILend.LendGivenPercentETHCollateral calldata params
    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        (assetIn, claimsOut) = _lendGivenPercent(
            natives,
            ILend._LendGivenPercent(
                convenience,
                factory,
                params.asset,
                weth,
                params.maturity,
                msg.sender,
                params.bondTo,
                params.insuranceTo,
                params.assetIn,
                params.percent,
                params.minBond,
                params.minInsurance,
                params.deadline
            )
        );
    }

    function _lendGivenBond(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        ILend._LendGivenBond memory params
    ) private returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        require(params.bondOut > params.assetIn, 'E517');

        IPair pair = params.factory.getPair(params.asset, params.collateral);
        require(address(pair) != address(0), 'E501');
        (uint112 xIncrease, uint112 yDecrease, uint112 zDecrease) = pair.givenBond(
            params.maturity,
            params.assetIn,
            params.bondOut
        );

        (assetIn, claimsOut) = _lend(
            natives,
            ILend._Lend(
                params.convenience,
                pair,
                params.asset,
                params.collateral,
                params.maturity,
                params.from,
                params.bondTo,
                params.insuranceTo,
                xIncrease,
                yDecrease,
                zDecrease,
                params.deadline
            )
        );

        require(uint128(claimsOut.insuranceInterest) + claimsOut.insurancePrincipal >= params.minInsurance, 'E515');
    }

    function _lendGivenInsurance(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        ILend._LendGivenInsurance memory params
    ) private returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        IPair pair = params.factory.getPair(params.asset, params.collateral);
        require(address(pair) != address(0), 'E501');

        (uint112 xIncrease, uint112 yDecrease, uint112 zDecrease) = pair.givenInsurance(
            params.maturity,
            params.assetIn,
            params.insuranceOut
        );

        (assetIn, claimsOut) = _lend(
            natives,
            ILend._Lend(
                params.convenience,
                pair,
                params.asset,
                params.collateral,
                params.maturity,
                params.from,
                params.bondTo,
                params.insuranceTo,
                xIncrease,
                yDecrease,
                zDecrease,
                params.deadline
            )
        );

        require(uint128(claimsOut.bondInterest) + claimsOut.bondPrincipal >= params.minBond, 'E514');
    }

    function _lendGivenPercent(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        ILend._LendGivenPercent memory params
    ) private returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        require(params.percent <= 0x100000000, 'E505');

        IPair pair = params.factory.getPair(params.asset, params.collateral);
        require(address(pair) != address(0), 'E501');

        (uint112 xIncrease, uint112 yDecrease, uint112 zDecrease) = pair.givenPercent(
            params.maturity,
            params.assetIn,
            params.percent
        );

        (assetIn, claimsOut) = _lend(
            natives,
            ILend._Lend(
                params.convenience,
                pair,
                params.asset,
                params.collateral,
                params.maturity,
                params.from,
                params.bondTo,
                params.insuranceTo,
                xIncrease,
                yDecrease,
                zDecrease,
                params.deadline
            )
        );

        require(uint128(claimsOut.bondInterest) + claimsOut.bondPrincipal >= params.minBond, 'E514');
        require(uint128(claimsOut.insuranceInterest) + claimsOut.insurancePrincipal >= params.minInsurance, 'E515');
    }

    function _lend(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        ILend._Lend memory params
    ) private returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        require(params.deadline >= block.timestamp, 'E504');
        require(params.maturity > block.timestamp, 'E508');

        IConvenience.Native storage native = natives[params.asset][params.collateral][params.maturity];
        if (address(native.liquidity) == address(0))
            native.deploy(params.convenience, params.pair, params.asset, params.collateral, params.maturity);

        (assetIn, claimsOut) = params.pair.lend(
            IPair.LendParam(
                params.maturity,
                address(this),
                address(this),
                params.xIncrease,
                params.yDecrease,
                params.zDecrease,
                bytes(abi.encode(params.asset, params.collateral, params.from))
            )
        );

        native.bondInterest.mint(params.bondTo, claimsOut.bondInterest);
        native.bondPrincipal.mint(params.bondTo, claimsOut.bondPrincipal);
        native.insuranceInterest.mint(params.insuranceTo, claimsOut.insuranceInterest);
        native.insurancePrincipal.mint(params.insuranceTo, claimsOut.insurancePrincipal);
    }
}",2799
RealWorld_TA_96_TimeswapMath_RealWorld_20240811222639.log,96,TimeswapMath,21866,2477,24343,82.0,0.15887,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;
import '@timeswap-labs/timeswap-v1-core/contracts/libraries/TimeswapMath.sol';",38
RealWorld_TA_96_IMint_RealWorld_20240811232220.log,96,IMint,116414,2124,118538,79.0,0.62455,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IConvenience} from './IConvenience.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';

interface IMint {
    struct NewLiquidity {
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint112 assetIn;
        uint112 debtIn;
        uint112 collateralIn;
        uint256 deadline;
    }

    struct NewLiquidityETHAsset {
        IERC20 collateral;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint112 debtIn;
        uint112 collateralIn;
        uint256 deadline;
    }

    struct NewLiquidityETHCollateral {
        IERC20 asset;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint112 assetIn;
        uint112 debtIn;
        uint256 deadline;
    }

    struct _NewLiquidity {
        IConvenience convenience;
        IFactory factory;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address assetFrom;
        address collateralFrom;
        address liquidityTo;
        address dueTo;
        uint112 assetIn;
        uint112 debtIn;
        uint112 collateralIn;
        uint256 deadline;
    }

    struct LiquidityGivenAsset {
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint112 assetIn;
        uint256 minLiquidity;
        uint112 maxDebt;
        uint112 maxCollateral;
        uint256 deadline;
    }

    struct LiquidityGivenAssetETHAsset {
        IERC20 collateral;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint256 minLiquidity;
        uint112 maxDebt;
        uint112 maxCollateral;
        uint256 deadline;
    }

    struct LiquidityGivenAssetETHCollateral {
        IERC20 asset;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint112 assetIn;
        uint256 minLiquidity;
        uint112 maxDebt;
        uint256 deadline;
    }

    struct _LiquidityGivenAsset {
        IConvenience convenience;
        IFactory factory;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address assetFrom;
        address collateralFrom;
        address liquidityTo;
        address dueTo;
        uint112 assetIn;
        uint256 minLiquidity;
        uint112 maxDebt;
        uint112 maxCollateral;
        uint256 deadline;
    }

    struct LiquidityGivenDebt {
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint112 debtIn;
        uint256 minLiquidity;
        uint112 maxAsset;
        uint112 maxCollateral;
        uint256 deadline;
    }

    struct LiquidityGivenDebtETHAsset {
        IERC20 collateral;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint112 debtIn;
        uint256 minLiquidity;
        uint112 maxCollateral;
        uint256 deadline;
    }

    struct LiquidityGivenDebtETHCollateral {
        IERC20 asset;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint112 debtIn;
        uint256 minLiquidity;
        uint112 maxAsset;
        uint256 deadline;
    }

    struct _LiquidityGivenDebt {
        IConvenience convenience;
        IFactory factory;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address assetFrom;
        address collateralFrom;
        address liquidityTo;
        address dueTo;
        uint112 debtIn;
        uint256 minLiquidity;
        uint112 maxAsset;
        uint112 maxCollateral;
        uint256 deadline;
    }

    struct LiquidityGivenCollateral {
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint112 collateralIn;
        uint256 minLiquidity;
        uint112 maxAsset;
        uint112 maxDebt;
        uint256 deadline;
    }

    struct LiquidityGivenCollateralETHAsset {
        IERC20 collateral;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint112 collateralIn;
        uint256 minLiquidity;
        uint112 maxDebt;
        uint256 deadline;
    }

    struct LiquidityGivenCollateralETHCollateral {
        IERC20 asset;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint256 minLiquidity;
        uint112 maxAsset;
        uint112 maxDebt;
        uint256 deadline;
    }

    struct _LiquidityGivenCollateral {
        IConvenience convenience;
        IFactory factory;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address assetFrom;
        address collateralFrom;
        address liquidityTo;
        address dueTo;
        uint112 collateralIn;
        uint256 minLiquidity;
        uint112 maxAsset;
        uint112 maxDebt;
        uint256 deadline;
    }

    struct _Mint {
        IConvenience convenience;
        IPair pair;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address assetFrom;
        address collateralFrom;
        address liquidityTo;
        address dueTo;
        uint112 xIncrease;
        uint112 yIncrease;
        uint112 zIncrease;
        uint256 deadline;
    }
}",1262
RealWorld_TA_96_TestToken_RealWorld_20240811214107.log,96,TestToken,24474,1550,26024,63.0,0.15337,"// SPDX-License-Identifier: MIT
pragma solidity >=0.8.1;

import '@openzeppelin/contracts/token/ERC20/ERC20.sol';

contract TestToken is ERC20 {
    constructor(
        string memory name_,
        string memory symbol_,
        uint256 amount
    ) ERC20(name_, symbol_) {
        _mint(msg.sender, amount);
    }
}",77
RealWorld_TA_96_NFTTokenURIScaffold_RealWorld_20240811223538.log,96,NFTTokenURIScaffold,245850,2632,248482,93.0,1.28189,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {SafeMetadata} from './SafeMetadata.sol';
import {Strings} from '@openzeppelin/contracts/utils/Strings.sol';
import {DateTime} from './DateTime.sol';
import './Base64.sol';
import {NFTSVG} from './NFTSVG.sol';

library NFTTokenURIScaffold {
    using SafeMetadata for IERC20;
    using Strings for uint256;

    function tokenURI(
        uint256 id,
        IPair pair,
        IPair.Due memory due,
        uint256 maturity
    ) public view returns (string memory) {
        string memory uri = constructTokenSVG(
            address(pair.asset()),
            address(pair.collateral()),
            id.toString(),
            weiToPrecisionString(due.debt, pair.asset().safeDecimals()),
            weiToPrecisionString(due.collateral, pair.collateral().safeDecimals()),
            getReadableDateString(maturity),
            maturity
        );

        string memory description = string(
            abi.encodePacked(
                'This collateralized debt position represents a debt of ',
                weiToPrecisionString(due.debt, pair.asset().safeDecimals()),
                ' ',
                pair.asset().safeSymbol(),
                ' borrowed against a collateral of ',
                weiToPrecisionString(due.collateral, pair.collateral().safeDecimals()),
                ' ',
                pair.collateral().safeSymbol(),
                '. This position will expire on ',
                maturity.toString(),
                ' unix epoch time.\\nThe owner of this NFT has the option to pay the debt before maturity time to claim the locked collateral. In case the owner choose to default on the debt payment, the collateral will be forfeited'
            )
        );
        description = string(
            abi.encodePacked(
                description,
                '\\n\\nAsset Address: ',
                addressToString(address(pair.asset())),
                '\\nCollateral Address: ',
                addressToString(address(pair.collateral())),
                '\\nDebt Required: ',
                weiToPrecisionLongString(due.debt, pair.asset().safeDecimals()),
                ' ',
                IERC20(pair.asset()).safeSymbol(),
                '\\nCollateral Locked: ',
                weiToPrecisionLongString(due.collateral, pair.collateral().safeDecimals()),
                ' ',
                IERC20(pair.collateral()).safeSymbol()
            )
        );

        string memory name = 'Timeswap Collateralized Debt';

        return (constructTokenURI(name, description, uri));
    }

    function constructTokenURI(
        string memory name,
        string memory description,
        string memory imageSVG
    ) internal pure returns (string memory) {
        return
            string(
                abi.encodePacked(
                    'data:application/json;base64,',
                    Base64.encode(
                        bytes(
                            abi.encodePacked(
                                '{""name"":""',
                                name,
                                '"", ""description"":""',
                                description,
                                '"", ""image"": ""',
                                'data:image/svg+xml;base64,',
                                Base64.encode(bytes(imageSVG)),
                                '""}'
                            )
                        )
                    )
                )
            );
    }

    function constructTokenSVG(
        address asset,
        address collateral,
        string memory tokenId,
        string memory assetAmount,
        string memory collateralAmount,
        string memory maturityDate,
        uint256 maturityTimestamp
    ) internal view returns (string memory) {
        NFTSVG.SVGParams memory params = NFTSVG.SVGParams({
            tokenId: tokenId,
            svgTitle: string(
                abi.encodePacked(
                    parseSymbol(IERC20(asset).safeSymbol()),
                    '/',
                    parseSymbol(IERC20(collateral).safeSymbol())
                )
            ),
            assetInfo: string(abi.encodePacked(parseSymbol(IERC20(asset).safeSymbol()), ': ', addressToString(asset))),
            collateralInfo: string(
                abi.encodePacked(parseSymbol(IERC20(collateral).safeSymbol()), ': ', addressToString(collateral))
            ),
            debtRequired: string(abi.encodePacked(assetAmount, ' ', parseSymbol(IERC20(asset).safeSymbol()))),
            collateralLocked: string(
                abi.encodePacked(collateralAmount, ' ', parseSymbol(IERC20(collateral).safeSymbol()))
            ),
            maturityDate: maturityDate,
            isMatured: block.timestamp > maturityTimestamp,
            maturityTimestampString: maturityTimestamp.toString(),
            tokenColors: getSVGCData(asset, collateral)
        });

        return NFTSVG.constructSVG(params);
    }

    function weiToPrecisionLongString(uint256 weiAmt, uint256 decimal) public pure returns (string memory) {
        if (decimal == 0) {
            return string(abi.encodePacked(weiAmt.toString(), '.00'));
        }

        uint256 significantDigits = weiAmt / (10**decimal);
        uint256 precisionDigits = weiAmt % (10**(decimal));

        if (precisionDigits == 0) {
            return string(abi.encodePacked(significantDigits.toString(), '.00'));
        }

        string memory precisionDigitsString = toStringTrimmed(precisionDigits);
        uint256 lengthDiff = decimal - bytes(precisionDigits.toString()).length;
        for (uint256 i; i < lengthDiff; i++) {
            precisionDigitsString = string(abi.encodePacked('0', precisionDigitsString));
        }

        return string(abi.encodePacked(significantDigits.toString(), '.', precisionDigitsString));
    }

    function weiToPrecisionString(uint256 weiAmt, uint256 decimal) public pure returns (string memory) {
        if (decimal == 0) {
            return string(abi.encodePacked(weiAmt.toString(), '.00'));
        }

        uint256 significantDigits = weiAmt / (10**decimal);
        if (significantDigits > 1e9) {
            string memory weiAmtString = weiAmt.toString();
            uint256 len = bytes(weiAmtString).length - 9;
            weiAmt = weiAmt / (10**len);
            return string(abi.encodePacked(weiAmt.toString(), '...'));
        }
        uint256 precisionDigits = weiAmt % (10**(decimal));
        precisionDigits = precisionDigits / (10**(decimal - 4));

        if (precisionDigits == 0) {
            return string(abi.encodePacked(significantDigits.toString(), '.00'));
        }

        string memory precisionDigitsString = toStringTrimmed(precisionDigits);
        uint256 lengthDiff = 4 - bytes(precisionDigits.toString()).length;
        for (uint256 i; i < lengthDiff; i++) {
            precisionDigitsString = string(abi.encodePacked('0', precisionDigitsString));
        }

        return string(abi.encodePacked(significantDigits.toString(), '.', precisionDigitsString));
    }

    function toStringTrimmed(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return '0';
        }
        uint256 temp = value;
        uint256 digits;
        uint256 flag;
        while (temp != 0) {
            if (flag == 0 && temp % 10 == 0) {
                temp /= 10;
                continue;
            } else if (flag == 0 && temp % 10 != 0) {
                flag++;
                digits++;
            } else {
                digits++;
            }

            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        flag = 0;
        while (value != 0) {
            if (flag == 0 && value % 10 == 0) {
                value /= 10;
                continue;
            } else if (flag == 0 && value % 10 != 0) {
                flag++;
                digits -= 1;
                buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            } else {
                digits -= 1;
                buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            }

            value /= 10;
        }
        return string(buffer);
    }

    function addressToString(address _addr) public pure returns (string memory) {
        bytes memory data = abi.encodePacked(_addr);
        bytes memory alphabet = '0123456789abcdef';

        bytes memory str = new bytes(2 + data.length * 2);
        str[0] = '0';
        str[1] = 'x';
        for (uint256 i; i < data.length; i++) {
            str[2 + i * 2] = alphabet[uint256(uint8(data[i] >> 4))];
            str[3 + i * 2] = alphabet[uint256(uint8(data[i] & 0x0f))];
        }
        return string(str);
    }

    function getSlice(
        uint256 begin,
        uint256 end,
        string memory text
    ) public pure returns (string memory) {
        bytes memory a = new bytes(end - begin + 1);
        for (uint256 i; i <= end - begin; i++) {
            a[i] = bytes(text)[i + begin - 1];
        }
        return string(a);
    }

    function parseSymbol(string memory symbol) public pure returns (string memory) {
        if (bytes(symbol).length > 5) {
            return getSlice(1, 5, symbol);
        }
        return symbol;
    }

    function getMonthString(uint256 _month) public pure returns (string memory) {
        string[12] memory months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        return months[_month];
    }

    function getReadableDateString(uint256 timestamp) public pure returns (string memory) {
        (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second) = DateTime
            .timestampToDateTime(timestamp);

        string memory result = string(
            abi.encodePacked(
                day.toString(),
                ' ',
                getMonthString(month - 1),
                ' ',
                year.toString(),
                ', ',
                padWithZero(hour),
                ':',
                padWithZero(minute),
                ':',
                padWithZero(second),
                ' UTC'
            )
        );
        return result;
    }

    function padWithZero(uint256 value) public pure returns (string memory) {
        if (value < 10) {
            return string(abi.encodePacked('0', value.toString()));
        }
        return value.toString();
    }

    function getLightColor(address token) public pure returns (string memory) {
        string[15] memory lightColors = [
            'F7BAF7',
            'F7C8BA',
            'FAE2BE',
            'BAE1F7',
            'EBF7BA',
            'CEF7BA',
            'CED2EF',
            'CABAF7',
            'BAF7E5',
            'BACFF7',
            'F7BAE3',
            'F7E9BA',
            'E0BAF7',
            'F7BACF',
            'FFFFFF'
        ];
        uint160 tokenValue = uint160(token) % 15;
        return (lightColors[tokenValue]);
    }

    function getDarkColor(address token) public pure returns (string memory) {
        string[15] memory darkColors = [
            'DF51EC',
            'EC7651',
            'ECAE51',
            '51B4EC',
            'A4C327',
            '59C327',
            '5160EC',
            '7951EC',
            '27C394',
            '5185EC',
            'EC51B8',
            'F4CB3A',
            'B151EC',
            'EC5184',
            'C5C0C2'
        ];
        uint160 tokenValue = uint160(token) % 15;
        return (darkColors[tokenValue]);
    }

    function getSVGCData(address asset, address collateral) public pure returns (string memory) {
        string memory token0LightColor = string(abi.encodePacked('.C{fill:#', getLightColor(asset), '}'));
        string memory token0DarkColor = string(abi.encodePacked('.D{fill:#', getDarkColor(asset), '}'));
        string memory token1LightColor = string(abi.encodePacked('.E{fill:#', getLightColor(collateral), '}'));
        string memory token1DarkColor = string(abi.encodePacked('.F{fill:#', getDarkColor(collateral), '}'));

        return string(abi.encodePacked(token0LightColor, token0DarkColor, token1LightColor, token1DarkColor));
    }
}",2712
RealWorld_TA_96_TimeswapMath_RealWorld_20240811215139.log,96,TimeswapMath,272397,4267,276664,113.0,1.447325,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from '../interfaces/IPair.sol';
import {Math} from './Math.sol';
import {FullMath} from './FullMath.sol';
import {ConstantProduct} from './ConstantProduct.sol';
import {SafeCast} from './SafeCast.sol';
import {BlockNumber} from './BlockNumber.sol';

library TimeswapMath {
    using Math for uint256;
    using FullMath for uint256;
    using ConstantProduct for IPair.State;
    using SafeCast for uint256;

    uint256 private constant BASE = 0x10000000000;

    function mint(
        uint256 maturity,
        IPair.State memory state,
        uint112 xIncrease, 
        uint112 yIncrease, 
        uint112 zIncrease
    ) 
        external 
        view 
        returns(
            uint256 liquidityOut,
            IPair.Due memory dueOut,
            uint256 feeStoredIncrease
        )
    {
        if (state.totalLiquidity == 0) {
            liquidityOut = xIncrease;
            liquidityOut <<= 16;
        } else {
            uint256 fromX = state.totalLiquidity.mulDiv(xIncrease, state.x);
            uint256 fromY = state.totalLiquidity.mulDiv(yIncrease, state.y);
            uint256 fromZ = state.totalLiquidity.mulDiv(zIncrease, state.z);

            require(fromY <= fromX,'E214');
            require(fromZ <= fromX, 'E215');

            liquidityOut = fromY <= fromZ ? fromY : fromZ;

            feeStoredIncrease = state.feeStored.mulDivUp(liquidityOut, state.totalLiquidity);
        }

        uint256 _debtIn = maturity;
        _debtIn -= block.timestamp;
        _debtIn *= yIncrease;
        _debtIn = _debtIn.shiftRightUp(32);
        _debtIn += xIncrease;
        dueOut.debt = _debtIn.toUint112();

        uint256 _collateralIn = maturity;
        _collateralIn -= block.timestamp; 
        _collateralIn *= zIncrease;
        _collateralIn = _collateralIn.shiftRightUp(25); 
        _collateralIn += zIncrease; 
        dueOut.collateral = _collateralIn.toUint112();

        dueOut.startBlock = BlockNumber.get();
    }

    function burn(
        IPair.State memory state,
        uint256 liquidityIn
    )
        external
        pure
        returns (
            uint128 assetOut,
            uint128 collateralOut,
            uint256 feeOut
        )
    {
        uint256 totalAsset = state.reserves.asset;
        uint256 totalCollateral = state.reserves.collateral;
        uint256 totalBond = state.totalClaims.bondPrincipal;
        totalBond += state.totalClaims.bondInterest;

        if (totalAsset >= totalBond) {
            uint256 _assetOut = totalAsset;
            unchecked { _assetOut -= totalBond; }
            _assetOut = _assetOut.mulDiv(liquidityIn, state.totalLiquidity);
            assetOut = _assetOut.toUint128();

            uint256 _collateralOut = totalCollateral;
            _collateralOut = _collateralOut.mulDiv(liquidityIn, state.totalLiquidity);
            collateralOut = _collateralOut.toUint128();
        } else {
            uint256 deficit = totalBond;
            unchecked { deficit -= totalAsset; }

            uint256 totalInsurance = state.totalClaims.insurancePrincipal;
            totalInsurance += state.totalClaims.insuranceInterest;

            if (totalCollateral * totalBond > deficit * totalInsurance) {
                uint256 _collateralOut = totalCollateral;
                uint256 subtrahend = deficit;
                subtrahend *= totalInsurance;
                subtrahend = subtrahend.divUp(totalBond);
                _collateralOut -= subtrahend;
                _collateralOut = _collateralOut.mulDiv(liquidityIn, state.totalLiquidity);
                collateralOut = _collateralOut.toUint128();
            }
        }

        feeOut = state.feeStored.mulDiv(liquidityIn, state.totalLiquidity);
    }

    function lend(
        uint256 maturity,
        IPair.State memory state,
        uint112 xIncrease,
        uint112 yDecrease,
        uint112 zDecrease,
        uint16 fee,
        uint16 protocolFee
    )
        external
        view
        returns (
            IPair.Claims memory claimsOut,
            uint256 feeStoredIncrease,
            uint256 protocolFeeStoredIncrease
        ) 
    {   
        lendCheck(state, xIncrease, yDecrease, zDecrease);

        claimsOut.bondPrincipal = xIncrease;
        claimsOut.bondInterest = getBondInterest(maturity, yDecrease);
        claimsOut.insurancePrincipal = getInsurancePrincipal(state, xIncrease);
        claimsOut.insuranceInterest = getInsuranceInterest(maturity, zDecrease);

        (feeStoredIncrease, protocolFeeStoredIncrease) = lendGetFees(
            maturity,
            xIncrease,
            fee,
            protocolFee
        );
    }

    function lendCheck(
        IPair.State memory state,
        uint112 xIncrease,
        uint112 yDecrease,
        uint112 zDecrease
    ) private pure {
        uint112 xReserve = state.x + xIncrease;
        uint112 yReserve = state.y - yDecrease;
        uint112 zReserve = state.z - zDecrease;
        state.checkConstantProduct(xReserve, yReserve, zReserve);
    }

    function getBondInterest(
        uint256 maturity,
        uint112 yDecrease
    ) private view returns (uint112 bondInterestOut) {
        uint256 _bondInterestOut = maturity;
        _bondInterestOut -= block.timestamp;
        _bondInterestOut *= yDecrease;
        _bondInterestOut >>= 32;
        bondInterestOut = _bondInterestOut.toUint112();
    }

    function getInsurancePrincipal(
        IPair.State memory state,
        uint112 xIncrease
    ) private pure returns (uint112 insurancePrincipalOut) {
        uint256 _insurancePrincipalOut = state.z;
        _insurancePrincipalOut *= xIncrease;
        uint256 denominator = state.x;
        denominator += xIncrease;
        _insurancePrincipalOut /= denominator;
        insurancePrincipalOut = _insurancePrincipalOut.toUint112();
    }

    function getInsuranceInterest(
        uint256 maturity,
        uint112 zDecrease
    ) private view returns (uint112 insuranceInterestOut) {
        uint256 _insuranceInterestOut = maturity;
        _insuranceInterestOut -= block.timestamp;
        _insuranceInterestOut *= zDecrease;
        _insuranceInterestOut >>= 25;
        insuranceInterestOut = _insuranceInterestOut.toUint112();
    }

    function lendGetFees(
        uint256 maturity,
        uint112 xIncrease,
        uint16 fee,
        uint16 protocolFee
    ) private view returns (
        uint256 feeStoredIncrease,
        uint256 protocolFeeStoredIncrease
        )
    {
        uint256 totalFee = fee;
        totalFee += protocolFee;

        uint256 numerator = maturity;
        numerator -= block.timestamp;
        numerator *= totalFee;
        numerator += BASE;

        uint256 adjusted = xIncrease;
        adjusted *= numerator;
        adjusted = adjusted.divUp(BASE);
        uint256 totalFeeStoredIncrease = adjusted;
        unchecked { totalFeeStoredIncrease -= xIncrease; }

        feeStoredIncrease = totalFeeStoredIncrease;
        feeStoredIncrease *= fee;
        feeStoredIncrease /= totalFee;
        protocolFeeStoredIncrease = totalFeeStoredIncrease;
        unchecked { protocolFeeStoredIncrease -= feeStoredIncrease; }
    }

    function withdraw(
        IPair.State memory state,
        IPair.Claims memory claimsIn
    ) external pure returns (IPair.Tokens memory tokensOut) {
        uint256 totalAsset = state.reserves.asset;
        uint256 totalBondPrincipal = state.totalClaims.bondPrincipal;
        uint256 totalBondInterest = state.totalClaims.bondInterest;
        uint256 totalBond = totalBondPrincipal;
        totalBond += totalBondInterest;

        if (totalAsset >= totalBond) {
            tokensOut.asset = claimsIn.bondPrincipal;
            tokensOut.asset += claimsIn.bondInterest;
        } else {
            if (totalAsset >= totalBondPrincipal) {
                uint256 remaining = totalAsset;
                unchecked { remaining -= totalBondPrincipal; }
                uint256 _assetOut = claimsIn.bondInterest;
                _assetOut *= remaining;
                _assetOut /= totalBondInterest;
                _assetOut += claimsIn.bondPrincipal;
                tokensOut.asset = _assetOut.toUint128();
            } else {
                uint256 _assetOut = claimsIn.bondPrincipal;
                _assetOut *= totalAsset;
                _assetOut /= totalBondPrincipal;
                tokensOut.asset = _assetOut.toUint128();
            }
            
            uint256 deficit = totalBond;
            unchecked { deficit -= totalAsset; }

            uint256 totalInsurancePrincipal = state.totalClaims.insurancePrincipal;
            totalInsurancePrincipal *= deficit;
            uint256 totalInsuranceInterest = state.totalClaims.insuranceInterest;
            totalInsuranceInterest *= deficit;
            uint256 totalInsurance = totalInsurancePrincipal;
            totalInsurance += totalInsuranceInterest;

            uint256 totalCollateral = state.reserves.collateral;
            totalCollateral *= totalBond;

            if (totalCollateral >= totalInsurance) {
                uint256 _collateralOut = claimsIn.insurancePrincipal;
                _collateralOut += claimsIn.insuranceInterest;
                _collateralOut *= deficit;
                _collateralOut /= totalBond;
                tokensOut.collateral = _collateralOut.toUint128();
            } else if (totalCollateral >= totalInsurancePrincipal) {
                uint256 remaining = totalCollateral;
                unchecked { remaining -= totalInsurancePrincipal; }
                uint256 _collateralOut = claimsIn.insuranceInterest;
                _collateralOut *= deficit;
                uint256 denominator = totalInsuranceInterest;
                denominator *= totalBond;
                _collateralOut = _collateralOut.mulDiv(remaining, denominator);
                uint256 addend = claimsIn.insurancePrincipal;
                addend *= deficit;
                addend /= totalBond;
                _collateralOut += addend;
                tokensOut.collateral = _collateralOut.toUint128();
            } else {
                uint256 _collateralOut = claimsIn.insurancePrincipal;
                _collateralOut *= deficit;
                uint256 denominator = totalInsurancePrincipal;
                denominator *= totalBond;
                _collateralOut = _collateralOut.mulDiv(totalCollateral, denominator);
                tokensOut.collateral = _collateralOut.toUint128();
            }
        }
    }

    function borrow(
        uint256 maturity,
        IPair.State memory state,
        uint112 xDecrease,
        uint112 yIncrease,
        uint112 zIncrease,
        uint16 fee,
        uint16 protocolFee
    )
        external
        view
        returns (
            IPair.Due memory dueOut,
            uint256 feeStoredIncrease,
            uint256 protocolFeeStoredIncrease
        )
    {
        borrowCheck(state, xDecrease, yIncrease, zIncrease);

        dueOut.debt = getDebt(maturity, xDecrease, yIncrease);
        dueOut.collateral = getCollateral(maturity, state, xDecrease, zIncrease);
        dueOut.startBlock = BlockNumber.get();

        (feeStoredIncrease, protocolFeeStoredIncrease) = borrowGetFees(
            maturity,
            xDecrease,
            fee,
            protocolFee
        );
    }

    function borrowCheck(
        IPair.State memory state,
        uint112 xDecrease,
        uint112 yIncrease,
        uint112 zIncrease
    ) private pure {
        uint112 xReserve = state.x - xDecrease;
        uint112 yReserve = state.y + yIncrease;
        uint112 zReserve = state.z + zIncrease;
        state.checkConstantProduct(xReserve, yReserve, zReserve);

        uint256 yMax = xDecrease;
        yMax *= state.y;
        yMax = yMax.divUp(xReserve);
        require(yIncrease <= yMax, 'E214');

        uint256 zMax = xDecrease;
        zMax *= state.z;
        zMax = zMax.divUp(xReserve);
        require(zIncrease <= zMax, 'E215');
    }

    function getDebt(
        uint256 maturity,
        uint112 xDecrease,
        uint112 yIncrease
    ) private view returns (uint112 debtIn) {
        uint256 _debtIn = maturity;
        _debtIn -= block.timestamp;
        _debtIn *= yIncrease;
        _debtIn = _debtIn.shiftRightUp(32);
        _debtIn += xDecrease;
        debtIn = _debtIn.toUint112();
    }

    function getCollateral(
        uint256 maturity,
        IPair.State memory state,
        uint112 xDecrease,
        uint112 zIncrease
    ) private view returns (uint112 collateralIn) {
        uint256 _collateralIn = maturity;
        _collateralIn -= block.timestamp;
        _collateralIn *= zIncrease;
        _collateralIn = _collateralIn.shiftRightUp(25);
        uint256 minimum = state.z;
        minimum *= xDecrease;
        uint256 denominator = state.x;
        denominator -= xDecrease;
        minimum = minimum.divUp(denominator);
        _collateralIn += minimum;
        collateralIn = _collateralIn.toUint112();
    }

    function borrowGetFees(
        uint256 maturity,
        uint112 xDecrease,
        uint16 fee,
        uint16 protocolFee
    ) private view returns (
            uint256 feeStoredIncrease,
            uint256 protocolFeeStoredIncrease
        )
    {

        uint256 totalFee = fee;
        totalFee += protocolFee;

        uint256 denominator = maturity;
        denominator -= block.timestamp;
        denominator *= totalFee;
        denominator += BASE;

        uint256 adjusted = xDecrease;
        adjusted *= BASE;
        adjusted /= denominator;
        uint256 totalFeeStoredIncrease = xDecrease;
        unchecked { totalFeeStoredIncrease -= adjusted; }

        feeStoredIncrease = totalFeeStoredIncrease;
        feeStoredIncrease *= fee;
        feeStoredIncrease /= totalFee;
        protocolFeeStoredIncrease = totalFeeStoredIncrease;
        unchecked { protocolFeeStoredIncrease -= feeStoredIncrease; }
    }
}",3075
RealWorld_TA_96_Math_RealWorld_20240811214432.log,96,Math,25937,1959,27896,68.0,0.168865,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

library Math {
    function divUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = x / y;
        if (x % y != 0) z++;
    }

    function shiftRightUp(uint256 x, uint8 y) internal pure returns (uint256 z) {
        z = x >> y;
        if (x != z << y) z++;
    }

}",104
RealWorld_TA_96_TimeswapFactory_RealWorld_20240811222520.log,96,TimeswapFactory,21581,2759,24340,77.0,0.163085,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;
import '@timeswap-labs/timeswap-v1-core/contracts/TimeswapFactory.sol';",36
RealWorld_TA_96_LendMath_RealWorld_20240811225148.log,96,LendMath,146405,3498,149903,94.0,0.801985,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {Math} from '@timeswap-labs/timeswap-v1-core/contracts/libraries/Math.sol';
import {SquareRoot} from './SquareRoot.sol';
import {FullMath} from '@timeswap-labs/timeswap-v1-core/contracts/libraries/FullMath.sol';
import {ConstantProduct} from './ConstantProduct.sol';
import {SafeCast} from '@timeswap-labs/timeswap-v1-core/contracts/libraries/SafeCast.sol';

library LendMath {
    using Math for uint256;
    using SquareRoot for uint256;
    using FullMath for uint256;
    using ConstantProduct for IPair;
    using ConstantProduct for ConstantProduct.CP;
    using SafeCast for uint256;

    uint256 private constant BASE = 0x10000000000;

    function givenBond(
        IPair pair,
        uint256 maturity,
        uint112 assetIn,
        uint128 bondOut
    )
        internal
        view
        returns (
            uint112 xIncrease,
            uint112 yDecrease,
            uint112 zDecrease
        )
    {
        ConstantProduct.CP memory cp = pair.get(maturity);

        xIncrease = getX(pair, maturity, assetIn);

        uint256 xReserve = cp.x;
        xReserve += xIncrease;

        uint256 _yDecrease = bondOut;
        _yDecrease -= xIncrease;
        _yDecrease <<= 32;
        uint256 denominator = maturity;
        denominator -= block.timestamp;
        _yDecrease = _yDecrease.divUp(denominator);
        yDecrease = _yDecrease.toUint112();

        uint256 yReserve = cp.y;
        yReserve -= _yDecrease;

        uint256 zReserve = cp.x;
        zReserve *= cp.y;
        denominator = xReserve;
        denominator *= yReserve;
        zReserve = zReserve.mulDivUp(cp.z, denominator);

        uint256 _zDecrease = cp.z;
        _zDecrease -= zReserve;
        zDecrease = _zDecrease.toUint112();
    }

    function givenInsurance(
        IPair pair,
        uint256 maturity,
        uint112 assetIn,
        uint128 insuranceOut
    )
        internal
        view
        returns (
            uint112 xIncrease,
            uint112 yDecrease,
            uint112 zDecrease
        )
    {
        ConstantProduct.CP memory cp = pair.get(maturity);

        xIncrease = getX(pair, maturity, assetIn);

        uint256 xReserve = cp.x;
        xReserve += xIncrease;

        uint256 _zDecrease = insuranceOut;
        _zDecrease *= xReserve;
        uint256 subtrahend = cp.z;
        subtrahend *= xIncrease;
        _zDecrease -= subtrahend;
        _zDecrease <<= 25;
        uint256 denominator = maturity;
        denominator -= block.timestamp;
        denominator *= xReserve;
        _zDecrease = _zDecrease.divUp(denominator);
        zDecrease = _zDecrease.toUint112();

        uint256 zReserve = cp.z;
        zReserve -= _zDecrease;

        uint256 yReserve = cp.x;
        yReserve *= cp.z;
        denominator = xReserve;
        denominator *= zReserve;
        yReserve = yReserve.mulDivUp(cp.y, denominator);

        uint256 _yDecrease = cp.y;
        _yDecrease -= yReserve;
        yDecrease = _yDecrease.toUint112();
    }

    function givenPercent(
        IPair pair,
        uint256 maturity,
        uint112 assetIn,
        uint40 percent
    )
        internal
        view
        returns (
            uint112 xIncrease,
            uint112 yDecrease,
            uint112 zDecrease
        )
    {
        ConstantProduct.CP memory cp = pair.get(maturity);

        xIncrease = getX(pair, maturity, assetIn);

        uint256 xReserve = cp.x;
        xReserve += xIncrease;

        if (percent <= 0x80000000) {
            uint256 yMid = cp.y;
            uint256 subtrahend = cp.y;
            subtrahend *= cp.y;
            subtrahend = subtrahend.mulDivUp(cp.x, xReserve);
            subtrahend = subtrahend.sqrtUp();
            yMid -= subtrahend;

            uint256 _yDecrease = yMid;
            _yDecrease *= percent;
            _yDecrease >>= 31;
            yDecrease = _yDecrease.toUint112();

            uint256 yReserve = cp.y;
            yReserve -= _yDecrease;

            uint256 zReserve = cp.x;
            zReserve *= cp.y;
            uint256 denominator = xReserve;
            denominator *= yReserve;
            zReserve = zReserve.mulDivUp(cp.z, denominator);

            uint256 _zDecrease = cp.z;
            _zDecrease -= zReserve;
            zDecrease = _zDecrease.toUint112();
        } else {
            percent = 0x100000000 - percent;

            uint256 zMid = cp.z;
            uint256 subtrahend = cp.z;
            subtrahend *= cp.z;
            subtrahend = subtrahend.mulDivUp(cp.x, xReserve);
            subtrahend = subtrahend.sqrtUp();
            zMid -= subtrahend;

            uint256 _zDecrease = zMid;
            _zDecrease *= percent;
            _zDecrease >>= 31;
            zDecrease = _zDecrease.toUint112();

            uint256 zReserve = cp.z;
            zReserve -= _zDecrease;

            uint256 yReserve = cp.x;
            yReserve *= cp.z;
            uint256 denominator = xReserve;
            denominator *= zReserve;
            yReserve = yReserve.mulDivUp(cp.y, denominator);

            uint256 _yDecrease = cp.y;
            _yDecrease -= yReserve;
            yDecrease = _yDecrease.toUint112();
        }
    }

    function getX(
        IPair pair,
        uint256 maturity,
        uint112 assetIn
    ) private view returns (uint112 xIncrease) {
        // uint256 duration = maturity;
        // duration -= block.timestamp;

        uint256 totalFee = pair.fee();
        totalFee += pair.protocolFee();

        uint256 denominator = maturity;
        denominator -= block.timestamp;
        denominator *= totalFee;
        denominator += BASE;

        uint256 _xIncrease = assetIn;
        _xIncrease *= BASE;
        _xIncrease /= denominator;
        xIncrease = _xIncrease.toUint112();

        // uint256 denominator = duration;
        // denominator *= pair.fee();
        // denominator += BASE;

        // uint256 _xIncrease = assetIn;
        // _xIncrease *= BASE;
        // _xIncrease /= denominator;

        // denominator = duration;
        // denominator *= pair.protocolFee();
        // denominator += BASE;

        // _xIncrease *= BASE;
        // _xIncrease /= denominator;
        // xIncrease = _xIncrease.toUint112();
    }
}",1598
RealWorld_TA_96_SafeMetadata_RealWorld_20240811224927.log,96,SafeMetadata,52014,1457,53471,65.0,0.28921,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IERC20Metadata} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';

library SafeMetadata {
    function safeName(IERC20 token) internal view returns (string memory) {
        (bool success, bytes memory data) = address(token).staticcall(
            abi.encodeWithSelector(IERC20Metadata.name.selector)
        );
        return success ? returnDataToString(data) : 'Token';
    }

    function safeSymbol(IERC20 token) internal view returns (string memory) {
        (bool success, bytes memory data) = address(token).staticcall(
            abi.encodeWithSelector(IERC20Metadata.symbol.selector)
        );
        return success ? returnDataToString(data) : 'TKN';
    }

    function safeDecimals(IERC20 token) internal view returns (uint8) {
        (bool success, bytes memory data) = address(token).staticcall(
            abi.encodeWithSelector(IERC20Metadata.decimals.selector)
        );
        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;
    }

    function returnDataToString(bytes memory data) private pure returns (string memory) {
        if (data.length >= 64) {
            return abi.decode(data, (string));
        } else if (data.length == 32) {
            uint8 i = 0;
            while (i < 32 && data[i] != 0) {
                i++;
            }
            bytes memory bytesArray = new bytes(i);
            for (i = 0; i < 32 && data[i] != 0; i++) {
                bytesArray[i] = data[i];
            }
            return string(bytesArray);
        } else {
            return '???';
        }
    }
}",408
RealWorld_TA_96_MintMath_RealWorld_20240811225324.log,96,MintMath,100037,3793,103830,83.0,0.576045,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {Math} from '@timeswap-labs/timeswap-v1-core/contracts/libraries/Math.sol';
import {ConstantProduct} from './ConstantProduct.sol';
import {SafeCast} from '@timeswap-labs/timeswap-v1-core/contracts/libraries/SafeCast.sol';
library MintMath {
    using Math for uint256;
    using ConstantProduct for IPair;
    using SafeCast for uint256;

    function givenNew(
        uint256 maturity,
        uint112 assetIn,
        uint112 debtIn,
        uint112 collateralIn
    )
        internal
        view
        returns (
            uint112 xIncrease,
            uint112 yIncrease,
            uint112 zIncrease
        )
    {
        xIncrease = assetIn;
        uint256 duration = maturity;
        duration -= block.timestamp;
        uint256 _yIncrease = debtIn;
        _yIncrease -= assetIn;
        _yIncrease <<= 32;
        _yIncrease /= duration;
        yIncrease = _yIncrease.toUint112();
        uint256 _zIncrease = collateralIn;
        _zIncrease <<= 25;
        uint256 denominator = duration;
        denominator += 0x2000000;
        _zIncrease /= denominator;
        zIncrease = _zIncrease.toUint112();
    }

    function givenAsset(
        IPair pair,
        uint256 maturity,
        uint112 assetIn
    )
        internal
        view
        returns (
            uint112 xIncrease,
            uint112 yIncrease,
            uint112 zIncrease
        )
    {
        ConstantProduct.CP memory cp = pair.get(maturity);

        uint256 _xIncrease = assetIn;
        _xIncrease *= cp.x;
        uint256 denominator = cp.x;
        denominator += pair.feeStored(maturity);
        _xIncrease /= denominator;
        xIncrease = _xIncrease.toUint112();

        uint256 _yIncrease = cp.y;
        _yIncrease *= assetIn;
        _yIncrease /= cp.x;
        yIncrease = _yIncrease.toUint112();

        uint256 _zIncrease = cp.z;
        _zIncrease *= assetIn;
        _zIncrease /= cp.x;
        zIncrease = _zIncrease.toUint112();
    }

    function givenDebt(
        IPair pair,
        uint256 maturity,
        uint112 debtIn
    )
        internal
        view
        returns (
            uint112 xIncrease,
            uint112 yIncrease,
            uint112 zIncrease
        )
    {
        ConstantProduct.CP memory cp = pair.get(maturity);

        uint256 _yIncrease = debtIn;
        _yIncrease *= cp.y;
        _yIncrease <<= 32;
        uint256 denominator = maturity;
        denominator -= block.timestamp;
        denominator *= cp.y;
        uint256 addend = cp.x;
        addend <<= 32;
        denominator += addend;
        _yIncrease /= denominator;
        yIncrease = _yIncrease.toUint112();

        uint256 _xIncrease = cp.x;
        _xIncrease *= _yIncrease;
        _xIncrease = _xIncrease.divUp(cp.y);
        xIncrease = _xIncrease.toUint112();

        uint256 _zIncrease = cp.z;
        _zIncrease *= _yIncrease;
        _zIncrease /= cp.y;
        zIncrease = _zIncrease.toUint112();
    }

    function givenCollateral(
        IPair pair,
        uint256 maturity,
        uint112 collateralIn
    )
        internal
        view
        returns (
            uint112 xIncrease,
            uint112 yIncrease,
            uint112 zIncrease
        )
    {
        ConstantProduct.CP memory cp = pair.get(maturity);

        uint256 _zIncrease = collateralIn;
        _zIncrease <<= 25;
        uint256 denominator = maturity;
        denominator -= block.timestamp;
        denominator += 0x2000000;
        _zIncrease /= denominator;
        zIncrease = _zIncrease.toUint112();

        uint256 _xIncrease = cp.x;
        _xIncrease *= _zIncrease;
        _xIncrease = _xIncrease.divUp(cp.z);
        xIncrease = _xIncrease.toUint112();

        uint256 _yIncrease = cp.y;
        _yIncrease *= _zIncrease;
        _yIncrease /= cp.z;
        yIncrease = _yIncrease.toUint112();
    }
}",951
RealWorld_TA_96_Liquidity_RealWorld_20240811220553.log,96,Liquidity,60396,2205,62601,72.0,0.34608,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {ILiquidity} from './interfaces/ILiquidity.sol';
import {IConvenience} from './interfaces/IConvenience.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {ERC20Permit} from './base/ERC20Permit.sol';
import {SafeMetadata} from './libraries/SafeMetadata.sol';
import {Strings} from '@openzeppelin/contracts/utils/Strings.sol';

contract Liquidity is ILiquidity, ERC20Permit {
    using SafeMetadata for IERC20;
    using Strings for uint256;

    IConvenience public immutable override convenience;
    IPair public immutable override pair;
    uint256 public immutable override maturity;

    uint8 public constant override decimals = 18;

    function name() external view override returns (string memory) {
        string memory assetName = pair.asset().safeName();
        string memory collateralName = pair.collateral().safeName();
        return
            string(
                abi.encodePacked('Timeswap Liquidity - ', assetName, ' - ', collateralName, ' - ', maturity.toString())
            );
    }

    function symbol() external view override returns (string memory) {
        string memory assetSymbol = pair.asset().safeSymbol();
        string memory collateralSymbol = pair.collateral().safeSymbol();
        return string(abi.encodePacked('TS-LIQ-', assetSymbol, '-', collateralSymbol, '-', maturity.toString()));
    }

    function totalSupply() external view override returns (uint256) {
        return pair.liquidityOf(maturity, address(this));
    }

    constructor(
        IConvenience _convenience,
        IPair _pair,
        uint256 _maturity
    ) ERC20Permit('Timeswap Liquidity') {
        convenience = _convenience;
        pair = _pair;
        maturity = _maturity;
    }

    modifier onlyConvenience() {
        require(msg.sender == address(convenience), 'E403');
        _;
    }

    function mint(address to, uint256 amount) external override onlyConvenience {
        _mint(to, amount);
    }

    function burn(address from, uint256 amount) external override onlyConvenience {
        _burn(from, amount);
    }
}",506
RealWorld_TA_96_MaticTestToken_RealWorld_20240811222231.log,96,MaticTestToken,59777,3278,63055,85.0,0.364445,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

contract MaticTestToken {
    // MODEL

    string public constant name = 'Matic TEST TOKEN';
    string public constant symbol = 'MATIC';
    uint8 public immutable decimals = 18;

    address private constant ZERO = address(type(uint160).min);

    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    // EVENT

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    // UPDATE

    function approve(address _spender, uint256 _value) external returns (bool) {
        _approve(msg.sender, _spender, _value);
        return true;
    }

    function transfer(address _to, uint256 _value) external returns (bool) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(
        address _from,
        address _to,
        uint256 _value
    ) external returns (bool) {
        if (msg.sender != _from && allowance[_from][msg.sender] != type(uint256).max) {
            allowance[_from][msg.sender] -= _value;

            emit Approval(_from, msg.sender, allowance[_from][msg.sender]);
        }
        _transfer(_from, _to, _value);
        return true;
    }

    function mint(address _to, uint256 _value) external {
        totalSupply += _value;
        balanceOf[_to] += _value;
        emit Transfer(ZERO, _to, _value);
    }

    // HELPER

    function _approve(
        address _owner,
        address _spender,
        uint256 _value
    ) private {
        allowance[_owner][_spender] = _value;
        emit Approval(_owner, _spender, _value);
    }

    function _transfer(
        address _from,
        address _to,
        uint256 _value
    ) private {
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
    }
}",479
RealWorld_TA_96_Mint_RealWorld_20240811223342.log,96,Mint,379286,3655,382941,114.0,1.96953,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IConvenience} from '../interfaces/IConvenience.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';
import {IWETH} from '../interfaces/IWETH.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IMint} from '../interfaces/IMint.sol';
import {MintMath} from './MintMath.sol';
import {Deploy} from './Deploy.sol';
import {MsgValue} from './MsgValue.sol';
import {ETH} from './ETH.sol';

library Mint {
    using MintMath for IPair;
    using Deploy for IConvenience.Native;

    function newLiquidity(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IMint.NewLiquidity calldata params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = _newLiquidity(
            natives,
            IMint._NewLiquidity(
                convenience,
                factory,
                params.asset,
                params.collateral,
                params.maturity,
                msg.sender,
                msg.sender,
                params.liquidityTo,
                params.dueTo,
                params.assetIn,
                params.debtIn,
                params.collateralIn,
                params.deadline
            )
        );
    }

    function newLiquidityETHAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        IMint.NewLiquidityETHAsset calldata params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        uint112 assetInETH = MsgValue.getUint112();

        (assetIn, liquidityOut, id, dueOut) = _newLiquidity(
            natives,
            IMint._NewLiquidity(
                convenience,
                factory,
                weth,
                params.collateral,
                params.maturity,
                address(this),
                msg.sender,
                params.liquidityTo,
                params.dueTo,
                assetInETH,
                params.debtIn,
                params.collateralIn,
                params.deadline
            )
        );
    }

    function newLiquidityETHCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        IMint.NewLiquidityETHCollateral calldata params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        uint112 collateralIn = MsgValue.getUint112();

        (assetIn, liquidityOut, id, dueOut) = _newLiquidity(
            natives,
            IMint._NewLiquidity(
                convenience,
                factory,
                params.asset,
                weth,
                params.maturity,
                msg.sender,
                address(this),
                params.liquidityTo,
                params.dueTo,
                params.assetIn,
                params.debtIn,
                collateralIn,
                params.deadline
            )
        );
    }

    function liquidityGivenAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IMint.LiquidityGivenAsset calldata params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = _liquidityGivenAsset(
            natives,
            IMint._LiquidityGivenAsset(
                convenience,
                factory,
                params.asset,
                params.collateral,
                params.maturity,
                msg.sender,
                msg.sender,
                params.liquidityTo,
                params.dueTo,
                params.assetIn,
                params.minLiquidity,
                params.maxDebt,
                params.maxCollateral,
                params.deadline
            )
        );
    }

    function liquidityGivenAssetETHAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        IMint.LiquidityGivenAssetETHAsset calldata params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        uint112 assetInETH = MsgValue.getUint112();

        (assetIn, liquidityOut, id, dueOut) = _liquidityGivenAsset(
            natives,
            IMint._LiquidityGivenAsset(
                convenience,
                factory,
                weth,
                params.collateral,
                params.maturity,
                address(this),
                msg.sender,
                params.liquidityTo,
                params.dueTo,
                assetInETH,
                params.minLiquidity,
                params.maxDebt,
                params.maxCollateral,
                params.deadline
            )
        );
    }

    function liquidityGivenAssetETHCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        IMint.LiquidityGivenAssetETHCollateral calldata params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        uint112 maxCollateral = MsgValue.getUint112();

        (assetIn, liquidityOut, id, dueOut) = _liquidityGivenAsset(
            natives,
            IMint._LiquidityGivenAsset(
                convenience,
                factory,
                params.asset,
                weth,
                params.maturity,
                msg.sender,
                address(this),
                params.liquidityTo,
                params.dueTo,
                params.assetIn,
                params.minLiquidity,
                params.maxDebt,
                maxCollateral,
                params.deadline
            )
        );

        if (maxCollateral > dueOut.collateral) {
            uint256 excess = maxCollateral;
            unchecked {
                excess -= dueOut.collateral;
            }
            ETH.transfer(payable(msg.sender), excess);
        }
    }

    function liquidityGivenDebt(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IMint.LiquidityGivenDebt memory params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = _liquidityGivenDebt(
            natives,
            IMint._LiquidityGivenDebt(
                convenience,
                factory,
                params.asset,
                params.collateral,
                params.maturity,
                msg.sender,
                msg.sender,
                params.liquidityTo,
                params.dueTo,
                params.debtIn,
                params.minLiquidity,
                params.maxAsset,
                params.maxCollateral,
                params.deadline
            )
        );
    }

    function liquidityGivenDebtETHAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        IMint.LiquidityGivenDebtETHAsset memory params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        uint112 maxAsset = MsgValue.getUint112();

        (assetIn, liquidityOut, id, dueOut) = _liquidityGivenDebt(
            natives,
            IMint._LiquidityGivenDebt(
                convenience,
                factory,
                weth,
                params.collateral,
                params.maturity,
                msg.sender,
                msg.sender,
                params.liquidityTo,
                params.dueTo,
                params.debtIn,
                params.minLiquidity,
                maxAsset,
                params.maxCollateral,
                params.deadline
            )
        );

        if (maxAsset > assetIn) {
            uint256 excess = maxAsset;
            unchecked {
                excess -= assetIn;
            }
            ETH.transfer(payable(msg.sender), excess);
        }
    }

    function liquidityGivenDebtETHCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        IMint.LiquidityGivenDebtETHCollateral memory params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        uint112 maxCollateral = MsgValue.getUint112();

        (assetIn, liquidityOut, id, dueOut) = _liquidityGivenDebt(
            natives,
            IMint._LiquidityGivenDebt(
                convenience,
                factory,
                params.asset,
                weth,
                params.maturity,
                msg.sender,
                msg.sender,
                params.liquidityTo,
                params.dueTo,
                params.debtIn,
                params.minLiquidity,
                params.maxAsset,
                maxCollateral,
                params.deadline
            )
        );

        if (maxCollateral > dueOut.collateral) {
            uint256 excess = maxCollateral;
            unchecked {
                excess -= dueOut.collateral;
            }
            ETH.transfer(payable(msg.sender), excess);
        }
    }

    function liquidityGivenCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IMint.LiquidityGivenCollateral memory params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = _liquidityGivenCollateral(
            natives,
            IMint._LiquidityGivenCollateral(
                convenience,
                factory,
                params.asset,
                params.collateral,
                params.maturity,
                msg.sender,
                msg.sender,
                params.liquidityTo,
                params.dueTo,
                params.collateralIn,
                params.minLiquidity,
                params.maxAsset,
                params.maxDebt,
                params.deadline
            )
        );
    }

    function liquidityGivenCollateralETHAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        IMint.LiquidityGivenCollateralETHAsset memory params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        uint112 maxAsset = MsgValue.getUint112();

        (assetIn, liquidityOut, id, dueOut) = _liquidityGivenCollateral(
            natives,
            IMint._LiquidityGivenCollateral(
                convenience,
                factory,
                weth,
                params.collateral,
                params.maturity,
                msg.sender,
                msg.sender,
                params.liquidityTo,
                params.dueTo,
                params.collateralIn,
                params.minLiquidity,
                maxAsset,
                params.maxDebt,
                params.deadline
            )
        );

        if (maxAsset > assetIn) {
            uint256 excess = maxAsset;
            unchecked {
                excess -= assetIn;
            }
            ETH.transfer(payable(msg.sender), excess);
        }
    }

    function liquidityGivenCollateralETHCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        IMint.LiquidityGivenCollateralETHCollateral memory params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        uint112 collateralIn = MsgValue.getUint112();

        (assetIn, liquidityOut, id, dueOut) = _liquidityGivenCollateral(
            natives,
            IMint._LiquidityGivenCollateral(
                convenience,
                factory,
                params.asset,
                weth,
                params.maturity,
                msg.sender,
                msg.sender,
                params.liquidityTo,
                params.dueTo,
                collateralIn,
                params.minLiquidity,
                params.maxAsset,
                params.maxDebt,
                params.deadline
            )
        );
    }

    function _newLiquidity(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IMint._NewLiquidity memory params
    )
        private
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        require(params.debtIn > params.assetIn, 'E516');
        require(params.maturity > block.timestamp, 'E508');
        IPair pair = params.factory.getPair(params.asset, params.collateral);
        if (address(pair) == address(0)) pair = params.factory.createPair(params.asset, params.collateral);

        require(pair.totalLiquidity(params.maturity) == 0, 'E506');

        (uint112 xIncrease, uint112 yIncrease, uint112 zIncrease) = MintMath.givenNew(
            params.maturity,
            params.assetIn,
            params.debtIn,
            params.collateralIn
        );

        (assetIn, liquidityOut, id, dueOut) = _mint(
            natives,
            IMint._Mint(
                params.convenience,
                pair,
                params.asset,
                params.collateral,
                params.maturity,
                params.assetFrom,
                params.collateralFrom,
                params.liquidityTo,
                params.dueTo,
                xIncrease,
                yIncrease,
                zIncrease,
                params.deadline
            )
        );
    }

    function _liquidityGivenAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IMint._LiquidityGivenAsset memory params
    )
        private
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        IPair pair = params.factory.getPair(params.asset, params.collateral);
        if(address(pair)==address(0)){pair=params.factory.createPair(params.asset,params.collateral);}
        require(pair.totalLiquidity(params.maturity) != 0, 'E507');

        (uint112 xIncrease, uint112 yIncrease, uint112 zIncrease) = pair.givenAsset(params.maturity, params.assetIn);

        (assetIn, liquidityOut, id, dueOut) = _mint(
            natives,
            IMint._Mint(
                params.convenience,
                pair,
                params.asset,
                params.collateral,
                params.maturity,
                params.assetFrom,
                params.collateralFrom,
                params.liquidityTo,
                params.dueTo,
                xIncrease,
                yIncrease,
                zIncrease,
                params.deadline
            )
        );

        require(liquidityOut >= params.minLiquidity, 'E511');
        require(dueOut.debt <= params.maxDebt, 'E512');
        require(dueOut.collateral <= params.maxCollateral, 'E513');
    }

    function _liquidityGivenDebt(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IMint._LiquidityGivenDebt memory params
    )
        private
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        IPair pair = params.factory.getPair(params.asset, params.collateral);
        require(address(pair) != address(0), 'E501');
        require(pair.totalLiquidity(params.maturity) != 0, 'E507');

        (uint112 xIncrease, uint112 yIncrease, uint112 zIncrease) = pair.givenDebt(params.maturity, params.debtIn);

        (assetIn, liquidityOut, id, dueOut) = _mint(
            natives,
            IMint._Mint(
                params.convenience,
                pair,
                params.asset,
                params.collateral,
                params.maturity,
                params.assetFrom,
                params.collateralFrom,
                params.liquidityTo,
                params.dueTo,
                xIncrease,
                yIncrease,
                zIncrease,
                params.deadline
            )
        );

        require(liquidityOut >= params.minLiquidity, 'E511');
        require(xIncrease <= params.maxAsset, 'E519');
        require(dueOut.collateral <= params.maxCollateral, 'E513');
    }

    function _liquidityGivenCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IMint._LiquidityGivenCollateral memory params
    )
        private
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        IPair pair = params.factory.getPair(params.asset, params.collateral);
        require(address(pair) != address(0), 'E501');
        require(pair.totalLiquidity(params.maturity) != 0, 'E507');

        (uint112 xIncrease, uint112 yIncrease, uint112 zIncrease) = pair.givenCollateral(
            params.maturity,
            params.collateralIn
        );
        (assetIn, liquidityOut, id, dueOut) = _mint(
            natives,
            IMint._Mint(
                params.convenience,
                pair,
                params.asset,
                params.collateral,
                params.maturity,
                params.assetFrom,
                params.collateralFrom,
                params.liquidityTo,
                params.dueTo,
                xIncrease,
                yIncrease,
                zIncrease,
                params.deadline
            )
        );
        require(liquidityOut >= params.minLiquidity, 'E511');
        require(xIncrease <= params.maxAsset, 'E519');
        require(dueOut.debt <= params.maxDebt, 'E512');
    }

    function _mint(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IMint._Mint memory params
    )
        private
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        require(params.deadline >= block.timestamp, 'E504');
        require(params.maturity > block.timestamp, 'E508');
        IConvenience.Native storage native = natives[params.asset][params.collateral][params.maturity];
        if (address(native.liquidity) == address(0))
            native.deploy(params.convenience, params.pair, params.asset, params.collateral, params.maturity);
        (assetIn, liquidityOut, id, dueOut) = params.pair.mint(
            IPair.MintParam(
                params.maturity,
                address(this),
                address(this),
                params.xIncrease,
                params.yIncrease,
                params.zIncrease,
                bytes(abi.encode(params.asset, params.collateral, params.assetFrom, params.collateralFrom))
            )
        );
        native.liquidity.mint(params.liquidityTo, liquidityOut);
        native.collateralizedDebt.mint(params.dueTo, id);
 
    }
}",4444
RealWorld_TA_96_TimeswapPairCallee_RealWorld_20240811213937.log,96,TimeswapPairCallee,115845,3157,119002,88.0,0.642365,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from '../interfaces/IPair.sol';
import {IFactory} from '../interfaces/IFactory.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {ITimeswapBorrowCallback} from '../interfaces/callback/ITimeswapBorrowCallback.sol';
import {ITimeswapLendCallback} from '../interfaces/callback/ITimeswapLendCallback.sol';
import {ITimeswapMintCallback} from '../interfaces/callback/ITimeswapMintCallback.sol';
import {ITimeswapPayCallback} from '../interfaces/callback/ITimeswapPayCallback.sol';



contract TimeswapPairCallee {
    IPair public immutable  pairContract;
    IFactory public immutable  factoryContract;

    constructor(address pair) {
        pairContract = IPair(pair);
        factoryContract = IPair(pair).factory();
    }
    
    struct PairCalleeInfo {
        IERC20 asset;
        IERC20 collateral;
        address from;
    }
    struct PairCalleeInfoMint {
        IERC20 asset;
        IERC20 collateral;
        address assetFrom;
        address collateralFrom;
    }

    function getData(address from) public view returns (bytes memory data) {
        data = abi.encode(PairCalleeInfo(pairContract.asset(),pairContract.collateral(),from));
    }

    function getDataMint(address from) public view returns (bytes memory data){
        data =  abi.encode(PairCalleeInfoMint(pairContract.asset(),pairContract.collateral(),from,from));
    }

    function mint(
        uint256 maturity,
        address liquidityTo,
        uint112 xIncrease,
        uint112 yIncrease,
        uint112 zIncrease
    )
        external 
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {   
        return pairContract.mint(
            IPair.MintParam(
                maturity,
                liquidityTo,
                address(this),
                xIncrease,
                yIncrease,
                zIncrease,
                getDataMint(msg.sender)
            )
        );
    }

    function lend(
        uint256 maturity,
        address bondTo,
        address insuranceTo,
        uint112 xIncrease,
        uint112 yDecrease,
        uint112 zDecrease
    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut){
        return pairContract.lend(
            IPair.LendParam(
                maturity,
                bondTo,
                insuranceTo,
                xIncrease,
                yDecrease,
                zDecrease,
                getData(msg.sender)
            )
        );
    }

    function borrow(
        uint256 maturity,
        address assetTo,
        address dueTo,
        uint112 xDecrease,
        uint112 yIncrease,
        uint112 zIncrease
    ) external returns (uint256 assetOut, uint256 id, IPair.Due memory dueOut){
        return pairContract.borrow(
            IPair.BorrowParam(
                maturity,
                assetTo,
                dueTo,
                xDecrease,
                yIncrease,
                zIncrease,
                getData(msg.sender)
            )
        );
    }

    function pay(
        uint256 maturity,
        address to,
        address owner,
        uint256[] memory ids,
        uint112[] memory assetsIn,
        uint112[] memory collateralsOut
    ) external returns (uint128 assetIn, uint128 collateralOut){
        return pairContract.pay(
            IPair.PayParam(
                maturity,
                to,
                owner,
                ids,
                assetsIn,
                collateralsOut,
                getData(msg.sender)
            )
        );
    }

    function timeswapMintCallback(
        uint256 assetIn,
        uint112 collateralIn,
        bytes calldata data
    ) external {
        (IERC20 asset, IERC20 collateral, address assetFrom, address collateralFrom) = abi.decode(
            data,
            (IERC20, IERC20, address, address)
        );
        IPair pair = factoryContract.getPair(asset, collateral);

        require(msg.sender == address(pair), 'Invalid sender');
        asset.transferFrom(assetFrom, address(pair), assetIn);
        collateral.transferFrom(collateralFrom, address(pair), collateralIn);
    }

    function timeswapLendCallback(uint256 assetIn, bytes calldata data) external {
        (IERC20 asset, IERC20 collateral, address from) = abi.decode(
            data,
            (IERC20, IERC20, address)
        );
        IPair pair = factoryContract.getPair(asset, collateral);

        require(msg.sender == address(pair), 'Invalid sender');
        asset.transferFrom(from, address(pair), assetIn);
    }

    function timeswapBorrowCallback(uint112 collateralIn, bytes calldata data) external {
        (IERC20 asset, IERC20 collateral, address from) = abi.decode(
            data,
            (IERC20, IERC20, address)
        );
        IPair pair = factoryContract.getPair(asset, collateral);

        require(msg.sender == address(pair), 'Invalid sender');
        collateral.transferFrom(from, address(pair), collateralIn);
    }
    
    function timeswapPayCallback(
        uint128 assetIn,
        bytes calldata data
    ) external {
        (IERC20 asset, IERC20 collateral, address from) = abi.decode(
            data,
            (IERC20, IERC20, address)
        );
        IPair pair = factoryContract.getPair(asset, collateral);
        asset.transferFrom(from, address(pair), assetIn);
        
    }
}",1183
RealWorld_TA_96_ITimeswapLendCallback_RealWorld_20240811215753.log,96,ITimeswapLendCallback,34140,1300,35440,72.0,0.1967,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

/// @title Callback for ITimeswapPair#lend
/// @notice Any contract that calls ITimeswapPair#lend must implement this interface
interface ITimeswapLendCallback {
    /// @notice Called to `msg.sender` after initiating a lend from ITimeswapPair#lend.
    /// @dev In the implementation you must pay the asset token owed for the lend transaction.
    /// The caller of this method must be checked to be a TimeswapPair deployed by the canonical TimeswapFactory.
    /// @param assetIn The amount of asset tokens owed due to the pool for the lend transaction
    /// @param data Any data passed through by the caller via the ITimeswapPair#lend call
    function timeswapLendCallback(
        uint256 assetIn,
        bytes calldata data
    ) external;
}",191
RealWorld_TA_96_TimeswapPair_RealWorld_20240811213606.log,96,TimeswapPair,337584,4473,342057,124.0,1.77738,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from './interfaces/IPair.sol';
import {IFactory} from './interfaces/IFactory.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {TimeswapMath} from './libraries/TimeswapMath.sol';
import {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import {Array} from './libraries/Array.sol';
import {Callback} from './libraries/Callback.sol';
import {BlockNumber} from './libraries/BlockNumber.sol';

/// @title Timeswap Pair
/// @author Timeswap Labs
/// @notice It is recommended to use Timeswap Convenience to interact with this contract.
/// @notice All error messages are coded and can be found in the documentation.
contract TimeswapPair is IPair {
    using SafeERC20 for IERC20;
    using Array for Due[];

    /* ===== MODEL ===== */

    /// @inheritdoc IPair
    IFactory public immutable override factory;
    /// @inheritdoc IPair
    IERC20 public immutable override asset;
    /// @inheritdoc IPair
    IERC20 public immutable override collateral;
    /// @inheritdoc IPair
    uint16 public immutable override fee;
    /// @inheritdoc IPair
    uint16 public immutable override protocolFee;

    /// @inheritdoc IPair
    uint256 public override protocolFeeStored;

    /// @dev Stores the individual states of each Pool.
    mapping(uint256 => Pool) private pools;

    /// @dev Stores the access state for reentrancy guard.
    uint256 private locked = 1;

    /* ===== VIEW =====*/

    /// @inheritdoc IPair
    function feeStored(uint256 maturity)
        external
        view
        override
        returns (uint256) 
    {
        return pools[maturity].state.feeStored;
    }

    /// @inheritdoc IPair
    function constantProduct(uint256 maturity)
        external
        view
        override
        returns (uint112, uint112, uint112)
    {
        State storage state = pools[maturity].state;
        return (state.x, state.y, state.z);
    }

    /// @inheritdoc IPair
    function totalReserves(uint256 maturity) external view override returns (Tokens memory) {
        return pools[maturity].state.reserves;
    }

    /// @inheritdoc IPair
    function totalLiquidity(uint256 maturity) external view override returns (uint256) {
        return pools[maturity].state.totalLiquidity;
    }

    /// @inheritdoc IPair
    function liquidityOf(uint256 maturity, address owner) external view override returns (uint256) {
        return pools[maturity].liquidities[owner];
    }

    /// @inheritdoc IPair
    function totalClaims(uint256 maturity) external view override returns (Claims memory) {
        return pools[maturity].state.totalClaims;
    }

    /// @inheritdoc IPair
    function claimsOf(uint256 maturity, address owner) external view override returns (Claims memory) {
        return pools[maturity].claims[owner];
    }

    /// @inheritdoc IPair
    function totalDebtCreated(uint256 maturity) external view override returns (uint120) {
        return pools[maturity].state.totalDebtCreated;
    }

    /// @inheritdoc IPair
    function totalDuesOf(uint256 maturity, address owner) external view override returns (uint256) {
        return pools[maturity].dues[owner].length;
    }

    /// @inheritdoc IPair
    function dueOf(uint256 maturity, address owner, uint256 id) external view override returns (Due memory) {
        return pools[maturity].dues[owner][id];
    }

    /* ===== INIT ===== */

    /// @dev Initializes the Pair contract.
    /// @dev Called by the Timeswap factory contract.
    /// @param _asset The address of the ERC20 being lent and borrowed.
    /// @param _collateral The address of the ERC20 as the collateral.
    /// @param _fee The chosen fee rate.
    /// @param _protocolFee The chosen protocol fee rate.
    constructor(
        IERC20 _asset,
        IERC20 _collateral,
        uint16 _fee,
        uint16 _protocolFee
    ) {
        factory = IFactory(msg.sender);
        asset = _asset;
        collateral = _collateral;
        fee = _fee;
        protocolFee = _protocolFee;
    }

    /* ===== MODIFIER ===== */

    /// @dev The modifier for reentrancy guard.
    modifier lock() {
        require(locked == 1, 'E211');
        locked = 2;
        _;
        locked = 1;
    }

    /* ===== UPDATE ===== */

    /// @inheritdoc IPair
    function mint(MintParam calldata param)
        external
        override
        lock
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            Due memory dueOut
        )
    {   
        require(block.timestamp < param.maturity, 'E202');
        unchecked { require(param.maturity - block.timestamp < 0x100000000, 'E208'); }
        require(param.liquidityTo != address(0), 'E201');
        require(param.dueTo != address(0), 'E201');
        require(param.liquidityTo != address(this), 'E204');
        require(param.dueTo != address(this), 'E204');
        require(param.xIncrease != 0, 'E205');
        require(param.yIncrease != 0, 'E205');
        require(param.zIncrease != 0, 'E205');
        
        Pool storage pool = pools[param.maturity];

        uint256 feeStoredIncrease;
        (liquidityOut, dueOut, feeStoredIncrease) = TimeswapMath.mint(
            param.maturity,
            pool.state,
            param.xIncrease,
            param.yIncrease,
            param.zIncrease
        );

        require(liquidityOut != 0, 'E212');
        pool.state.totalLiquidity += liquidityOut;
        pool.liquidities[param.liquidityTo] += liquidityOut;

        pool.state.feeStored += feeStoredIncrease;


        id = pool.dues[param.dueTo].insert(dueOut);

        pool.state.reserves.asset += param.xIncrease;
        pool.state.reserves.collateral += dueOut.collateral;
        pool.state.totalDebtCreated += dueOut.debt;

        pool.state.x += param.xIncrease;
        pool.state.y += param.yIncrease;
        pool.state.z += param.zIncrease;

        assetIn = param.xIncrease;
        assetIn += feeStoredIncrease;
        Callback.mint(asset, collateral, assetIn, dueOut.collateral, param.data);

        emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);
        emit Mint(
            param.maturity, 
            msg.sender, 
            param.liquidityTo, 
            param.dueTo, 
            assetIn, 
            liquidityOut, 
            id, 
            dueOut,
            feeStoredIncrease
        );
    }

    /// @inheritdoc IPair
    function burn(BurnParam calldata param) 
        external 
        override 
        lock 
        returns (
            uint256 assetOut, 
            uint128 collateralOut
        ) 
    {
        require(block.timestamp >= param.maturity, 'E203');
        require(param.assetTo != address(0), 'E201');
        require(param.collateralTo != address(0), 'E201');
        require(param.assetTo != address(this), 'E204');
        require(param.collateralTo != address(this), 'E204');
        require(param.liquidityIn != 0, 'E205');

        Pool storage pool = pools[param.maturity];
        require(pool.state.totalLiquidity > 0, 'E206');

        uint128 _assetOut;
        uint256 feeOut;
        (_assetOut, collateralOut, feeOut) = TimeswapMath.burn(
            pool.state,
            param.liquidityIn
        );

        pool.state.totalLiquidity -= param.liquidityIn;

        pool.liquidities[msg.sender] -= param.liquidityIn;

        assetOut = _assetOut;
        assetOut += feeOut;

        if (assetOut != 0) {
            pool.state.reserves.asset -= _assetOut;
            pool.state.feeStored -= feeOut;
            asset.safeTransfer(param.assetTo, assetOut);
        }
        if (collateralOut != 0) {
            pool.state.reserves.collateral -= collateralOut;
            collateral.safeTransfer(param.collateralTo, collateralOut);
        }

        emit Burn(
            param.maturity,
            msg.sender, 
            param.assetTo, 
            param.collateralTo, 
            param.liquidityIn, 
            assetOut, 
            collateralOut,
            feeOut
        );
    }

    /// @inheritdoc IPair
    function lend(LendParam calldata param) 
        external 
        override 
        lock 
        returns (
            uint256 assetIn,
            Claims memory claimsOut
        ) 
    {
        require(block.timestamp < param.maturity, 'E202');
        require(param.bondTo != address(0), 'E201');
        require(param.insuranceTo != address(0), 'E201');
        require(param.bondTo != address(this), 'E204');
        require(param.insuranceTo != address(this), 'E204');
        require(param.xIncrease != 0, 'E205');

        Pool storage pool = pools[param.maturity];
        require(pool.state.totalLiquidity != 0, 'E206');

        uint256 feeStoredIncrease;
        uint256 protocolFeeStoredIncrease;
        (claimsOut, feeStoredIncrease, protocolFeeStoredIncrease) = TimeswapMath.lend(
            param.maturity,
            pool.state,
            param.xIncrease,
            param.yDecrease,
            param.zDecrease,
            fee,
            protocolFee
        );

        pool.state.feeStored += feeStoredIncrease;
        protocolFeeStored += protocolFeeStoredIncrease;

        pool.state.totalClaims.bondPrincipal += claimsOut.bondPrincipal;
        pool.state.totalClaims.bondInterest += claimsOut.bondInterest;
        pool.state.totalClaims.insurancePrincipal += claimsOut.insurancePrincipal;
        pool.state.totalClaims.insuranceInterest += claimsOut.insuranceInterest;

        pool.claims[param.bondTo].bondPrincipal += claimsOut.bondPrincipal;
        pool.claims[param.bondTo].bondInterest += claimsOut.bondInterest;
        pool.claims[param.insuranceTo].insurancePrincipal += claimsOut.insurancePrincipal;
        pool.claims[param.insuranceTo].insuranceInterest += claimsOut.insuranceInterest;

        pool.state.reserves.asset += param.xIncrease;

        pool.state.x += param.xIncrease;
        pool.state.y -= param.yDecrease;
        pool.state.z -= param.zDecrease;

        assetIn = param.xIncrease;
        assetIn += feeStoredIncrease;
        assetIn += protocolFeeStoredIncrease;

        Callback.lend(asset, assetIn, param.data);

        emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);
        emit Lend(
            param.maturity,
            msg.sender, 
            param.bondTo, 
            param.insuranceTo, 
            assetIn, 
            claimsOut,
            feeStoredIncrease,
            protocolFeeStoredIncrease
        );
    }

    /// @inheritdoc IPair
    function withdraw(WithdrawParam calldata param)
        external 
        override 
        lock 
        returns (
            Tokens memory tokensOut
        ) 
    {
        require(block.timestamp >= param.maturity, 'E203');
        require(param.assetTo != address(0), 'E201');
        require(param.collateralTo != address(0), 'E201');
        require(param.assetTo != address(this), 'E204');
        require(param.collateralTo != address(this), 'E204');
        require(
            param.claimsIn.bondPrincipal != 0 || 
            param.claimsIn.bondInterest != 0 ||
            param.claimsIn.insurancePrincipal != 0 ||
            param.claimsIn.insuranceInterest != 0, 
            'E205'
        );

        Pool storage pool = pools[param.maturity];

        tokensOut = TimeswapMath.withdraw(pool.state, param.claimsIn);

        pool.state.totalClaims.bondPrincipal -= param.claimsIn.bondPrincipal;
        pool.state.totalClaims.bondInterest -= param.claimsIn.bondInterest;
        pool.state.totalClaims.insurancePrincipal -= param.claimsIn.insurancePrincipal;
        pool.state.totalClaims.insuranceInterest -= param.claimsIn.insuranceInterest;

        Claims storage sender = pool.claims[msg.sender];

        sender.bondPrincipal -= param.claimsIn.bondPrincipal;
        sender.bondInterest -= param.claimsIn.bondInterest;
        sender.insurancePrincipal -= param.claimsIn.insurancePrincipal;
        sender.insuranceInterest -= param.claimsIn.insuranceInterest;

        if (tokensOut.asset != 0) {
            pool.state.reserves.asset -= tokensOut.asset;
            asset.safeTransfer(param.assetTo, tokensOut.asset);
        }
        if (tokensOut.collateral != 0) {
            pool.state.reserves.collateral -= tokensOut.collateral;
            collateral.safeTransfer(param.collateralTo, tokensOut.collateral);
        }

        emit Withdraw(
            param.maturity,
            msg.sender, 
            param.assetTo, 
            param.collateralTo, 
            param.claimsIn, 
            tokensOut
        );
    }

    /// @inheritdoc IPair
    function borrow(BorrowParam calldata param)
        external 
        override 
        lock 
        returns (
            uint256 assetOut,
            uint256 id, 
            Due memory dueOut
        ) 
    {
        require(block.timestamp < param.maturity, 'E202');
        require(param.assetTo != address(0), 'E201');
        require(param.dueTo != address(0), 'E201');
        require(param.assetTo != address(this), 'E204');
        require(param.dueTo != address(this), 'E204');
        require(param.xDecrease != 0, 'E205');

        Pool storage pool = pools[param.maturity];
        require(pool.state.totalLiquidity != 0, 'E206');

        uint256 feeStoredIncrease;
        uint256 protocolFeeStoredIncrease;
        (dueOut, feeStoredIncrease, protocolFeeStoredIncrease) = TimeswapMath.borrow(
            param.maturity,
            pool.state,
            param.xDecrease,
            param.yIncrease,
            param.zIncrease,
            fee,
            protocolFee
        );

        pool.state.feeStored += feeStoredIncrease;
        protocolFeeStored += protocolFeeStoredIncrease;

        id = pool.dues[param.dueTo].insert(dueOut);

        pool.state.reserves.asset -= param.xDecrease;
        pool.state.reserves.collateral += dueOut.collateral;
        pool.state.totalDebtCreated += dueOut.debt;

        pool.state.x -= param.xDecrease;
        pool.state.y += param.yIncrease;
        pool.state.z += param.zIncrease;

        assetOut = param.xDecrease;
        assetOut -= feeStoredIncrease;
        assetOut -= protocolFeeStoredIncrease;

        asset.safeTransfer(param.assetTo, assetOut);

        Callback.borrow(collateral, dueOut.collateral, param.data);

        emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);
        emit Borrow(
            param.maturity, 
            msg.sender, 
            param.assetTo, 
            param.dueTo, 
            assetOut, 
            id, 
            dueOut,
            feeStoredIncrease,
            protocolFeeStoredIncrease
        );
    }

    /// @inheritdoc IPair
    function pay(PayParam calldata param)
        external 
        override 
        lock 
        returns (
            uint128 assetIn, 
            uint128 collateralOut
        ) 
    {
        require(block.timestamp < param.maturity, 'E202');
        require(param.owner != address(0), 'E201');
        require(param.to != address(0), 'E201');
        require(param.to != address(this), 'E204');
        require(param.ids.length == param.assetsIn.length, 'E205');
        require(param.ids.length == param.collateralsOut.length, 'E205');

        Pool storage pool = pools[param.maturity];

        Due[] storage dues = pool.dues[param.owner];
        require(dues.length >= param.ids.length, 'E205');

        for (uint256 i; i < param.ids.length;) {
            Due storage due = dues[param.ids[i]];
            require(due.startBlock != BlockNumber.get(), 'E207');
            if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');
            require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');
            due.debt -= param.assetsIn[i];
            due.collateral -= param.collateralsOut[i];
            assetIn += param.assetsIn[i];
            collateralOut += param.collateralsOut[i];
            unchecked { ++i; }
        }

        pool.state.reserves.asset += assetIn;
        pool.state.reserves.collateral -= collateralOut;

        if (collateralOut != 0) collateral.safeTransfer(param.to, collateralOut);

        if (assetIn != 0) Callback.pay(asset, assetIn, param.data);

        emit Pay(
            param.maturity, 
            msg.sender, 
            param.to, 
            param.owner, 
            param.ids, 
            param.assetsIn, 
            param.collateralsOut, 
            assetIn, 
            collateralOut
        );
    }

    /// @inheritdoc IPair
    function collectProtocolFee(address to) external override lock returns (uint256 protocolFeeOut) {
        require(msg.sender == factory.owner(), 'E216');

        protocolFeeOut = protocolFeeStored;
        protocolFeeStored = 0;

        asset.safeTransfer(to, protocolFeeOut);

        emit CollectProtocolFee(msg.sender, to, protocolFeeOut);
    }
}",3829
RealWorld_TA_96_SafeCast_RealWorld_20240811214816.log,96,SafeCast,33206,1245,34451,66.0,0.19093,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

library SafeCast {
    function modUint32(uint256 x) internal pure returns (uint32 y) {
        y = uint32(x % 0x100000000);
    }
    
    function toUint112(uint256 x) internal pure returns (uint112 y) {
        require(x <= type(uint112).max);
        y = uint112(x);
    }

    function toUint128(uint256 x) internal pure returns (uint128 y) {
        require(x <= type(uint128).max);
        y = uint128(x);
    }

    function truncateUint112(uint256 x) internal pure returns (uint112 y) {
        if (x > type(uint112).max) return y = type(uint112).max;
        y = uint112(x);
    }
}",177
RealWorld_TA_96_MsgValue_RealWorld_20240811230051.log,96,MsgValue,30231,3985,34216,88.0,0.230855,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {ETH} from './ETH.sol';
import {SafeCast} from '@timeswap-labs/timeswap-v1-core/contracts/libraries/SafeCast.sol';

library MsgValue {
    using SafeCast for uint256;

    function getUint112() internal returns (uint112 value) {
        value = msg.value.truncateUint112();
        unchecked {
            if (msg.value > value) ETH.transfer(payable(msg.sender), msg.value - value);
        }
    }
}",116
RealWorld_TA_96_InsurancePrincipal_RealWorld_20240811220821.log,96,InsurancePrincipal,62270,2145,64415,81.0,0.35425,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IClaim} from './interfaces/IClaim.sol';
import {IConvenience} from './interfaces/IConvenience.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {ERC20Permit} from './base/ERC20Permit.sol';
import {SafeMetadata} from './libraries/SafeMetadata.sol';
import {Strings} from '@openzeppelin/contracts/utils/Strings.sol';

contract InsurancePrincipal is IClaim, ERC20Permit {
    using SafeMetadata for IERC20;
    using Strings for uint256;

    IConvenience public immutable override convenience;
    IPair public immutable override pair;
    uint256 public immutable override maturity;

    function name() external view override returns (string memory) {
        string memory assetName = pair.asset().safeName();
        string memory collateralName = pair.collateral().safeName();
        return
            string(
                abi.encodePacked(
                    'Timeswap Insurance Principal- ',
                    assetName,
                    ' - ',
                    collateralName,
                    ' - ',
                    maturity.toString()
                )
            );
    }

    function symbol() external view override returns (string memory) {
        string memory assetSymbol = pair.asset().safeSymbol();
        string memory collateralSymbol = pair.collateral().safeSymbol();
        return string(abi.encodePacked('TS-INS-PRI-', assetSymbol, '-', collateralSymbol, '-', maturity.toString()));
    }

    function decimals() external view override returns (uint8) {
        return pair.collateral().safeDecimals();
    }

    function totalSupply() external view override returns (uint256) {
        return pair.claimsOf(maturity, address(convenience)).insurancePrincipal;
    }

    constructor(
        IConvenience _convenience,
        IPair _pair,
        uint256 _maturity
    ) ERC20Permit('Timeswap Insurance Principal') {
        convenience = _convenience;
        pair = _pair;
        maturity = _maturity;
    }

    modifier onlyConvenience() {
        require(msg.sender == address(convenience), 'E403');
        _;
    }

    function mint(address to, uint128 amount) external override onlyConvenience {
        _mint(to, amount);
    }

    function burn(address from, uint128 amount) external override onlyConvenience {
        _burn(from, amount);
    }
}",533
RealWorld_TA_96_InsuranceInterest_RealWorld_20240811220944.log,96,InsuranceInterest,62352,2183,64535,75.0,0.35542,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IClaim} from './interfaces/IClaim.sol';
import {IConvenience} from './interfaces/IConvenience.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {ERC20Permit} from './base/ERC20Permit.sol';
import {SafeMetadata} from './libraries/SafeMetadata.sol';
import {Strings} from '@openzeppelin/contracts/utils/Strings.sol';

contract InsuranceInterest is IClaim, ERC20Permit {
    using SafeMetadata for IERC20;
    using Strings for uint256;

    IConvenience public immutable override convenience;
    IPair public immutable override pair;
    uint256 public immutable override maturity;

    function name() external view override returns (string memory) {
        string memory assetName = pair.asset().safeName();
        string memory collateralName = pair.collateral().safeName();
        return
            string(
                abi.encodePacked(
                    'Timeswap Insurance Interest- ',
                    assetName,
                    ' - ',
                    collateralName,
                    ' - ',
                    maturity.toString()
                )
            );
    }

    function symbol() external view override returns (string memory) {
        string memory assetSymbol = pair.asset().safeSymbol();
        string memory collateralSymbol = pair.collateral().safeSymbol();
        return string(abi.encodePacked('TS-INS-INT-', assetSymbol, '-', collateralSymbol, '-', maturity.toString()));
    }

    function decimals() external view override returns (uint8) {
        return pair.collateral().safeDecimals();
    }

    function totalSupply() external view override returns (uint256) {
        return pair.claimsOf(maturity, address(convenience)).insuranceInterest;
    }

    constructor(
        IConvenience _convenience,
        IPair _pair,
        uint256 _maturity
    ) ERC20Permit('Timeswap Insurance Interest') {
        convenience = _convenience;
        pair = _pair;
        maturity = _maturity;
    }

    modifier onlyConvenience() {
        require(msg.sender == address(convenience), 'E403');
        _;
    }

    function mint(address to, uint128 amount) external override onlyConvenience {
        _mint(to, amount);
    }

    function burn(address from, uint128 amount) external override onlyConvenience {
        _burn(from, amount);
    }
}",533
RealWorld_TA_96_ITimeswapMintCallback_RealWorld_20240811215907.log,96,ITimeswapMintCallback,36585,1632,38217,76.0,0.215565,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

/// @title Callback for ITimeswapPair#mint
/// @notice Any contract that calls ITimeswapPair#mint must implement this interface
interface ITimeswapMintCallback {
    /// @notice Called to `msg.sender` after initiating a mint from ITimeswapPair#mint.
    /// @dev In the implementation you must pay the asset token and collateral token owed for the mint transaction.
    /// The caller of this method must be checked to be a TimeswapPair deployed by the canonical TimeswapFactory.
    /// @param assetIn The amount of asset tokens owed due to the pool for the mint transaction.
    /// @param collateralIn The amount of collateral tokens owed due to the pool for the min transaction.
    /// @param data Any data passed through by the caller via the ITimeswapPair#mint call
    function timeswapMintCallback(
        uint256 assetIn,
        uint112 collateralIn,
        bytes calldata data
    ) external;
}",217
RealWorld_TA_96_PayMath_RealWorld_20240811224037.log,96,PayMath,47538,3484,51022,77.0,0.30737,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IDue} from '../interfaces/IDue.sol';
import {SafeCast} from '@timeswap-labs/timeswap-v1-core/contracts/libraries/SafeCast.sol';

library PayMath {
    using SafeCast for uint256;

    function givenMaxAssetsIn(
        IPair pair,
        uint256 maturity,
        IDue collateralizedDebt,
        uint256[] memory ids,
        uint112[] memory maxAssetsIn
    ) internal view returns (uint112[] memory assetsIn, uint112[] memory collateralsOut) {
        uint256 length = ids.length;

        assetsIn = maxAssetsIn;
        collateralsOut = new uint112[](length);

        for (uint256 i; i < length; ) {
            IPair.Due memory due = pair.dueOf(maturity, address(this), ids[i]);

            if (assetsIn[i] > due.debt) assetsIn[i] = due.debt;
            if (msg.sender == collateralizedDebt.ownerOf(ids[i])) {
                uint256 _collateralOut = due.collateral;
                if (due.debt != 0) {
                    _collateralOut *= assetsIn[i];
                    _collateralOut /= due.debt;
                }
                collateralsOut[i] = _collateralOut.toUint112();
            }

            unchecked {
                ++i;
            }
        }
    }
}",331
RealWorld_TA_96_LendMathCallee_RealWorld_20240811221441.log,96,LendMathCallee,42250,1849,44099,69.0,0.24823,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {LendMath} from '../libraries/LendMath.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';

contract LendMathCallee {
    function givenBond(
        IPair pair,
        uint256 maturity,
        uint112 assetIn,
        uint128 bondOut
    )
        public
        view
        returns (
            uint256,
            uint112,
            uint112
        )
    {
        return LendMath.givenBond(pair, maturity, assetIn, bondOut);
    }

    function givenInsurance(
        IPair pair,
        uint256 maturity,
        uint112 assetIn,
        uint128 insuranceOut
    )
        public
        view
        returns (
            uint256,
            uint112,
            uint112
        )
    {
        return LendMath.givenInsurance(pair, maturity, assetIn, insuranceOut);
    }

    function givenPercent(
        IPair pair,
        uint256 maturity,
        uint112 assetIn,
        uint40 percent
    )
        public
        view
        returns (
            uint256,
            uint112,
            uint112
        )
    {
        return LendMath.givenPercent(pair, maturity, assetIn, percent);
    }
}",282
RealWorld_TA_97_ERC2771Context_RealWorld_20240812001636.log,97,ERC2771Context,39063,1441,40504,63.0,0.224135,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;

import ""@openzeppelin/contracts/utils/Context.sol"";

/**
 * @dev Context variant with ERC2771 support.
 */
abstract contract ERC2771Context is Context {
    address internal _trustedForwarder;

    constructor(address trustedForwarder) {
        _trustedForwarder = trustedForwarder;
    }

    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {
        return forwarder == _trustedForwarder;
    }

    function _msgSender() internal view virtual override returns (address sender) {
        if (isTrustedForwarder(msg.sender)) {
            // The assembly code is more direct than the Solidity version using `abi.decode`.
            assembly {
                sender := shr(96, calldataload(sub(calldatasize(), 20)))
            }
        } else {
            return super._msgSender();
        }
    }

    function _msgData() internal view virtual override returns (bytes calldata) {
        if (isTrustedForwarder(msg.sender)) {
            return msg.data[:msg.data.length - 20];
        } else {
            return super._msgData();
        }
    }
}",252
RealWorld_TA_97_Polygon.ETH_RealWorld_20240811235655.log,97,Polygon.ETH,413087,2057,415144,92.0,2.106575,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract PolygonETH is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st15,.prefix__st2{fill:#fff}.prefix__st15{fill-opacity:.602}.prefix__st26{font-family:&apos;Courier&apos;}.prefix__st27{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""-908.612"" cy=""-47.221"" r=""1"" gradientTransform=""matrix(0 327.499 327.499 0 15667.466 297569.594)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#8247e5""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000141442605033164902770000000811733122206392226_"" cx=""-908.323"" cy=""-44.569"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 7669.416 246228.469)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#627eea""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000141442605033164902770000000811733122206392226_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st26 prefix__st27"">',
                    suppliedLiquidity,
                    ' ETH</text><text transform=""rotate(-90 213.61 143.092)"" class=""prefix__st2 prefix__st26 prefix__st27"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st26"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><path d=""M128.52 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h71.83c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#8247e5""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON POLYGON</text><g><circle cx=""60.19"" cy=""58.5"" r=""8.5"" fill-rule=""evenodd"" clip-rule=""evenodd"" fill=""#627eea""/><path class=""prefix__st15"" d=""M60.45 52.12v4.71l3.98 1.78-3.98-6.49z""/><path class=""prefix__st2"" d=""M60.45 52.12l-3.98 6.49 3.98-1.78v-4.71z""/><path class=""prefix__st15"" d=""M60.45 61.67v3.2l3.99-5.51-3.99 2.31z""/><path class=""prefix__st2"" d=""M60.45 64.87v-3.2l-3.98-2.31 3.98 5.51z""/><path d=""M60.45 60.93l3.98-2.31-3.98-1.78v4.09z"" fill=""#fff"" fill-opacity="".2""/><path class=""prefix__st15"" d=""M56.47 58.62l3.98 2.31v-4.09l-3.98 1.78z""/></g></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Polygon"";
    }
}",4672
RealWorld_TA_97_IERC20Permit_RealWorld_20240812003638.log,97,IERC20Permit,32394,1298,33692,66.0,0.18793,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";

interface IERC20Detailed is IERC20Upgradeable {
  function name() external view returns(string memory);
  function decimals() external view returns(uint256);
}

interface IERC20Nonces is IERC20Detailed {
  function nonces(address holder) external view returns(uint);
}

interface IERC20Permit is IERC20Nonces {
  function permit(address holder, address spender, uint256 nonce, uint256 expiry,
                  bool allowed, uint8 v, bytes32 r, bytes32 s) external;

  function permit(address holder, address spender, uint256 value, uint256 expiry,
                  uint8 v, bytes32 r, bytes32 s) external;
}",181
RealWorld_TA_97_LpTokenMetadata_RealWorld_20240812001531.log,97,LpTokenMetadata,21657,1343,23000,63.0,0.135145,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

struct LpTokenMetadata {
    address token;
    uint256 suppliedLiquidity;
    uint256 shares;
}",40
RealWorld_TA_97_Avalanche.USDT_RealWorld_20240812000143.log,97,Avalanche.USDT,421980,1937,423917,96.0,2.14864,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract AvalancheUSDT is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st2{fill:#fff}.prefix__st28{font-family:&apos;Courier&apos;}.prefix__st29{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""2.777"" cy=""-505"" r=""1"" gradientTransform=""matrix(0 327.499 327.499 0 165589.5 -909.476)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#e84142""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000096046149083906169040000006838268896560026277_"" cx=""3.356"" cy=""-505"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 84809.203 -831.976)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#50af95""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000096046149083906169040000006838268896560026277_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st28 prefix__st29"">',
                    suppliedLiquidity,
                    ' USDT</text><text transform=""rotate(-90 213.61 143.092)"" class=""prefix__st2 prefix__st28 prefix__st29"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st28"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><g fill-rule=""evenodd"" clip-rule=""evenodd""><path d=""M54.8 51.18l-3.1 6.51a.14.14 0 00.03.15l8.37 8.02c.05.05.13.05.18 0l8.37-8.02c.04-.04.05-.1.03-.15l-3.1-6.51a.136.136 0 00-.11-.07H54.91c-.05-.01-.09.02-.11.07z"" fill=""#50af95""/><path d=""M61.26 58.36c-.06 0-.37.02-1.06.02-.55 0-.94-.02-1.08-.02-2.13-.09-3.72-.46-3.72-.91 0-.44 1.59-.81 3.72-.91v1.45c.14.01.54.03 1.09.03.66 0 .99-.03 1.05-.03v-1.45c2.12.09 3.71.47 3.71.91s-1.59.81-3.71.91zm0-1.97v-1.3h2.97v-1.98h-8.07v1.98h2.96v1.3c-2.41.11-4.22.59-4.22 1.16s1.81 1.05 4.22 1.16v4.15h2.14v-4.15c2.4-.11 4.21-.59 4.21-1.16s-1.8-1.05-4.21-1.16zm0 0"" fill=""#fff""/></g><g><path d=""M142.44 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h85.75c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#e84142""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON AVALANCHE</text></g></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Avalanche"";
    }
}",4785
RealWorld_TA_97_Avalanche.USDC_RealWorld_20240812000321.log,97,Avalanche.USDC,454327,1674,456001,92.0,2.305115,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract AvalancheUSDC is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st2{fill:#fff}.prefix__st31{font-family:&apos;Courier&apos;}.prefix__st32{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""-452.223"" cy=""-503.611"" r=""1"" gradientTransform=""matrix(0 327.499 327.499 0 165134.5 148102.563)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#e84142""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000112620898175617978930000002313274521866282382_"" cx=""-451.644"" cy=""-502.284"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 84354.203 122470.75)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#2775ca""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000112620898175617978930000002313274521866282382_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st31 prefix__st32"">',
                    suppliedLiquidity,
                    ' USDC</text><text transform=""rotate(-90 213.61 143.092)"" class=""prefix__st2 prefix__st31 prefix__st32"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st31"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><g><path d=""M60.19 67c4.71 0 8.5-3.79 8.5-8.5S64.9 50 60.19 50s-8.5 3.79-8.5 8.5 3.79 8.5 8.5 8.5z"" fill=""#2775ca""/><path class=""prefix__st2"" d=""M62.52 59.85c0-1.24-.74-1.66-2.23-1.84-1.06-.14-1.27-.42-1.27-.92s.35-.81 1.06-.81c.64 0 .99.21 1.17.74.04.11.14.18.25.18h.57c.14 0 .25-.11.25-.25v-.04c-.14-.78-.78-1.38-1.59-1.45v-.86c0-.14-.11-.25-.28-.28h-.55c-.14 0-.25.11-.28.28v.81c-1.06.14-1.74.85-1.74 1.74 0 1.17.71 1.63 2.2 1.81.99.18 1.31.39 1.31.96s-.5.96-1.17.96c-.92 0-1.24-.39-1.35-.92-.04-.14-.14-.21-.25-.21h-.6c-.14 0-.25.11-.25.25v.04c.14.89.71 1.52 1.88 1.7v.85c0 .14.11.25.28.28h.53c.14 0 .25-.11.28-.28v-.85c1.07-.19 1.78-.94 1.78-1.89z""/><path class=""prefix__st2"" d=""M58.38 63.56c-2.76-.99-4.18-4.07-3.15-6.8.53-1.49 1.7-2.62 3.15-3.15.14-.07.21-.18.21-.35v-.5c0-.14-.07-.25-.21-.28-.04 0-.11 0-.14.04a6.354 6.354 0 00-4.14 8 6.364 6.364 0 004.14 4.14c.14.07.28 0 .32-.14.04-.04.04-.07.04-.14v-.5c-.01-.1-.11-.24-.22-.32zm3.75-11.05c-.14-.07-.28 0-.32.14-.04.04-.04.07-.04.14v.5c0 .14.11.28.21.35 2.76.99 4.18 4.07 3.15 6.8a5.225 5.225 0 01-3.15 3.15c-.14.07-.21.18-.21.35v.5c0 .14.07.25.21.28.04 0 .11 0 .14-.04a6.354 6.354 0 004.14-8c-.62-2.01-2.18-3.53-4.13-4.17z""/></g><g><path d=""M142.44 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h85.75c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#e84142""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON AVALANCHE</text></g></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Avalanche"";
    }
}",5175
RealWorld_TA_97_ITokenManager_RealWorld_20240812002121.log,97,ITokenManager,37062,2152,39214,77.0,0.22835,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

interface ITokenManager {

    struct TokenInfo {
        uint256 transferOverhead;
        bool supportedToken;
        uint256 equilibriumFee; // Percentage fee Represented in basis points
        uint256 maxFee; // Percentage fee Represented in basis points
        TokenConfig tokenConfig;
    }

    struct TokenConfig {
        uint256 min;
        uint256 max;
    }
    
    function getEquilibriumFee(address tokenAddress) external view returns (uint256);

    function getMaxFee(address tokenAddress) external view returns (uint256);

    function changeFee(
        address tokenAddress,
        uint256 _equilibriumFee,
        uint256 _maxFee
    ) external;

    function getTokensInfo(address tokenAddress) external view returns (TokenInfo memory);

    function getDepositConfig(uint256 toChainId, address tokenAddress) external view returns (TokenConfig memory);

    function getTransferConfig(address tokenAddress) external view returns (TokenConfig memory);
}",213
RealWorld_TA_97_Polygon.BICO_RealWorld_20240811235513.log,97,Polygon.BICO,433875,2329,436204,100.0,2.215955,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract PolygonBICO is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st2{fill:#fff}.prefix__st22{font-family:&apos;Courier&apos;}.prefix__st23{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""456.388"" cy=""-51.389"" r=""1"" gradientTransform=""matrix(0 327.499 327.499 0 17032.465 -149466.516)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#8247e5""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000168091924376873730230000003268479974706684840_"" cx=""456.677"" cy=""-52.716"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 9034.416 -123679.695)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#d85111""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000168091924376873730230000003268479974706684840_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st22 prefix__st23"">',
                    suppliedLiquidity,
                    ' BICO</text><text transform=""rotate(-90 213.61 143.092)"" class=""prefix__st2 prefix__st22 prefix__st23"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st22"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><path d=""M128.52 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h71.83c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#8247e5""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON POLYGON</text><g><circle cx=""60.19"" cy=""58.5"" r=""8.5""/><linearGradient id=""prefix__SVGID_00000065782961005422185070000012495441524963081905_"" gradientUnits=""userSpaceOnUse"" x1=""58.709"" y1=""66.872"" x2=""61.662"" y2=""50.128""><stop offset=""0"" stop-color=""#fff""/><stop offset=""1"" stop-color=""#fff""/></linearGradient><path d=""M60.19 50.75c4.27 0 7.75 3.48 7.75 7.75s-3.48 7.75-7.75 7.75-7.75-3.48-7.75-7.75 3.47-7.75 7.75-7.75m0-.75c-4.69 0-8.5 3.81-8.5 8.5s3.81 8.5 8.5 8.5 8.5-3.81 8.5-8.5-3.81-8.5-8.5-8.5z"" fill=""url(#prefix__SVGID_00000065782961005422185070000012495441524963081905_)""/><g><path d=""M61.53 54.53c-.31-.18-.68-.28-1.06-.28h-2.12c.59 0 1.06.48 1.06 1.06v3.19h1.06c.39 0 .75-.1 1.06-.29.23-.13.44-.31.6-.52.29-.36.46-.82.46-1.32 0-.78-.42-1.47-1.06-1.84z"" fill=""#d85111""/><path class=""prefix__st2"" d=""M62.14 57.69a2.131 2.131 0 01-1.66.81h-1.06v-3.19a1.06 1.06 0 00-2.12 0V62.75H61c.18 0 .36-.02.53-.05a2.66 2.66 0 002.12-2.6c.01-1.07-.62-1.98-1.51-2.41z""/></g></g></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Polygon"";
    }
}",4923
RealWorld_TA_97_Polygon.USDT_RealWorld_20240812000009.log,97,Polygon.USDT,420982,1866,422848,92.0,2.14223,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract PolygonUSDT is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st2{fill:#fff}.prefix__st19{font-family:&apos;Courier&apos;}.prefix__st20{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""1.388"" cy=""-50"" r=""1"" gradientTransform=""matrix(0 327.499 327.499 0 16577.465 -454.476)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#8247e5""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000050633384941599449990000003968045424753684663_"" cx=""1.677"" cy=""-50"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 8579.416 -376.976)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#50af95""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000050633384941599449990000003968045424753684663_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st19 prefix__st20"">',
                    suppliedLiquidity,
                    ' USDT</text><text transform=""rotate(-90 213.61 143.092)"" class=""prefix__st2 prefix__st19 prefix__st20"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st19"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><g fill-rule=""evenodd"" clip-rule=""evenodd""><path d=""M54.8 51.18l-3.1 6.51a.14.14 0 00.03.15l8.37 8.02c.05.05.13.05.18 0l8.37-8.02c.04-.04.05-.1.03-.15l-3.1-6.51a.136.136 0 00-.11-.07H54.91c-.05-.01-.09.02-.11.07z"" fill=""#50af95""/><path d=""M61.26 58.36c-.06 0-.37.02-1.06.02-.55 0-.94-.02-1.08-.02-2.13-.09-3.72-.46-3.72-.91 0-.44 1.59-.81 3.72-.91v1.45c.14.01.54.03 1.09.03.66 0 .99-.03 1.05-.03v-1.45c2.12.09 3.71.47 3.71.91s-1.59.81-3.71.91zm0-1.97v-1.3h2.97v-1.98h-8.07v1.98h2.96v1.3c-2.41.11-4.22.59-4.22 1.16s1.81 1.05 4.22 1.16v4.15h2.14v-4.15c2.4-.11 4.21-.59 4.21-1.16s-1.8-1.05-4.21-1.16zm0 0"" fill=""#fff""/></g><path d=""M128.52 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h71.83c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#8247e5""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON POLYGON</text></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Polygon"";
    }
}",4779
RealWorld_TA_97_Avalanche.BICO_RealWorld_20240812000632.log,97,Avalanche.BICO,433994,1979,435973,98.0,2.20955,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract AvalancheBICO is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st2{fill:#fff}.prefix__st38{font-family:&apos;Courier&apos;}.prefix__st39{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""457.777"" cy=""-506.389"" r=""1"" gradientTransform=""matrix(0 327.499 327.499 0 166044.5 -149921.516)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#e84142""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000047027802228991556750000014900804184815511974_"" cx=""458.356"" cy=""-507.716"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 85264.203 -124134.695)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#d85111""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000047027802228991556750000014900804184815511974_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st38 prefix__st39"">',
                    suppliedLiquidity,
                    ' BICO</text><text transform=""rotate(-90 213.61 143.093)"" class=""prefix__st2 prefix__st38 prefix__st39"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st38"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><g><path d=""M142.44 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h85.75c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#e84142""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON AVALANCHE</text></g><g><circle cx=""60.19"" cy=""58.5"" r=""8.5""/><linearGradient id=""prefix__SVGID_00000129165268976242144260000016321246092256663168_"" gradientUnits=""userSpaceOnUse"" x1=""58.709"" y1=""66.872"" x2=""61.662"" y2=""50.128""><stop offset=""0"" stop-color=""#fff""/><stop offset=""1"" stop-color=""#fff""/></linearGradient><path d=""M60.19 50.75c4.27 0 7.75 3.48 7.75 7.75s-3.48 7.75-7.75 7.75-7.75-3.48-7.75-7.75 3.47-7.75 7.75-7.75m0-.75c-4.69 0-8.5 3.81-8.5 8.5s3.81 8.5 8.5 8.5 8.5-3.81 8.5-8.5-3.81-8.5-8.5-8.5z"" fill=""url(#prefix__SVGID_00000129165268976242144260000016321246092256663168_)""/><g><path d=""M61.53 54.53c-.31-.18-.68-.28-1.06-.28h-2.12c.59 0 1.06.48 1.06 1.06v3.19h1.06c.39 0 .75-.1 1.06-.29.23-.13.44-.31.6-.52.29-.36.46-.82.46-1.32 0-.78-.42-1.47-1.06-1.84z"" fill=""#d85111""/><path class=""prefix__st2"" d=""M62.14 57.69a2.131 2.131 0 01-1.66.81h-1.06v-3.19a1.06 1.06 0 00-2.12 0V62.75H61c.18 0 .36-.02.53-.05a2.66 2.66 0 002.12-2.6c.01-1.07-.62-1.98-1.51-2.41z""/></g></g></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Avalanche"";
    }
}",4929
RealWorld_TA_97_Ethereum.BICO_RealWorld_20240812001245.log,97,Ethereum.BICO,434134,2202,436336,95.0,2.21471,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract EthereumBICO is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st2{fill:#fff}.prefix__st9{font-family:&apos;Courier&apos;}.prefix__st10{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""454.998"" cy=""403.611"" r=""1"" gradientTransform=""scale(327.499 -327.499) rotate(-90 26.003 428.995)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#8c8c8c""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000149348912856748424340000004453863865774411953_"" cx=""454.998"" cy=""402.284"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 -67195.375 -123224.695)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#d85111""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000149348912856748424340000004453863865774411953_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st9 prefix__st10"">',
                    suppliedLiquidity,
                    ' BICO</text><text transform=""rotate(-90 213.61 143.092)"" class=""prefix__st2 prefix__st9 prefix__st10"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st9"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><g><path d=""M136.03 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h79.34c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#8c8c8c""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON ETHEREUM</text></g><g><circle cx=""60.19"" cy=""58.5"" r=""8.5""/><linearGradient id=""prefix__SVGID_00000121240735984433054910000011952518464616340407_"" gradientUnits=""userSpaceOnUse"" x1=""58.709"" y1=""66.872"" x2=""61.662"" y2=""50.128""><stop offset=""0"" stop-color=""#fff""/><stop offset=""1"" stop-color=""#fff""/></linearGradient><path d=""M60.19 50.75c4.27 0 7.75 3.48 7.75 7.75s-3.48 7.75-7.75 7.75-7.75-3.48-7.75-7.75 3.47-7.75 7.75-7.75m0-.75c-4.69 0-8.5 3.81-8.5 8.5s3.81 8.5 8.5 8.5 8.5-3.81 8.5-8.5-3.81-8.5-8.5-8.5z"" fill=""url(#prefix__SVGID_00000121240735984433054910000011952518464616340407_)""/><g><path d=""M61.53 54.53c-.31-.18-.68-.28-1.06-.28h-2.12c.59 0 1.06.48 1.06 1.06v3.19h1.06c.39 0 .75-.1 1.06-.29.23-.13.44-.31.6-.52.29-.36.46-.82.46-1.32 0-.78-.42-1.47-1.06-1.84z"" fill=""#d85111""/><path class=""prefix__st2"" d=""M62.14 57.69a2.131 2.131 0 01-1.66.81h-1.06v-3.19a1.06 1.06 0 00-2.12 0V62.75H61c.18 0 .36-.02.53-.05a2.66 2.66 0 002.12-2.6c.01-1.07-.62-1.98-1.51-2.41z""/></g></g></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Ethereum"";
    }
}",4932
RealWorld_TA_97_TokenManager_RealWorld_20240811235028.log,97,TokenManager,116964,2896,119860,86.0,0.64274,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""../metatx/ERC2771Context.sol"";
import ""../interfaces/ITokenManager.sol"";

contract TokenManager is ITokenManager, ERC2771Context, Ownable, Pausable {
    mapping(address => TokenInfo) public tokensInfo;

    event FeeChanged(address indexed tokenAddress, uint256 indexed equilibriumFee, uint256 indexed maxFee);

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokensInfo[tokenAddress].supportedToken, ""Token not supported"");

        _;
    }

    /**
     * First key is toChainId and second key is token address being deposited on current chain
     */
    mapping(uint256 => mapping(address => TokenConfig)) public depositConfig;

    /**
     * Store min/max amount of token to transfer based on token address
     */
    mapping(address => TokenConfig) public transferConfig;

    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {
        // Empty Constructor
    }

    function getEquilibriumFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].equilibriumFee;
    }

    function getMaxFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].maxFee;
    }

    function changeFee(
        address tokenAddress,
        uint256 _equilibriumFee,
        uint256 _maxFee
    ) external override onlyOwner whenNotPaused {
        require(_equilibriumFee != 0, ""Equilibrium Fee cannot be 0"");
        require(_maxFee != 0, ""Max Fee cannot be 0"");
        tokensInfo[tokenAddress].equilibriumFee = _equilibriumFee;
        tokensInfo[tokenAddress].maxFee = _maxFee;
        emit FeeChanged(tokenAddress, tokensInfo[tokenAddress].equilibriumFee, tokensInfo[tokenAddress].maxFee);
    }

    function setTokenTransferOverhead(address tokenAddress, uint256 gasOverhead)
        external
        tokenChecks(tokenAddress)
        onlyOwner
    {
        tokensInfo[tokenAddress].transferOverhead = gasOverhead;
    }

    /**
     * Set DepositConfig for the given combination of toChainId, tokenAddress.
     * This is used while depositing token in Liquidity Pool. Based on the destination chainid
     * min and max deposit amount is checked.
     */
    function setDepositConfig(
        uint256[] memory toChainId,
        address[] memory tokenAddresses,
        TokenConfig[] memory tokenConfig
    ) external onlyOwner {
        require(
            (toChainId.length == tokenAddresses.length) && (tokenAddresses.length == tokenConfig.length),
            "" ERR_ARRAY_LENGTH_MISMATCH""
        );
        for (uint256 index = 0; index < tokenConfig.length; ++index) {
            depositConfig[toChainId[index]][tokenAddresses[index]].min = tokenConfig[index].min;
            depositConfig[toChainId[index]][tokenAddresses[index]].max = tokenConfig[index].max;
        }
    }

    function addSupportedToken(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit,
        uint256 equilibriumFee,
        uint256 maxFee
    ) external onlyOwner {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        tokensInfo[tokenAddress].supportedToken = true;
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
        tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress];
        tokensInfo[tokenAddress].equilibriumFee = equilibriumFee;
        tokensInfo[tokenAddress].maxFee = maxFee;
    }

    function removeSupportedToken(address tokenAddress) external tokenChecks(tokenAddress) onlyOwner {
        tokensInfo[tokenAddress].supportedToken = false;
    }

    function updateTokenCap(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit
    ) external tokenChecks(tokenAddress) onlyOwner {
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
    }

    function getTokensInfo(address tokenAddress) public view override returns (TokenInfo memory) {
        TokenInfo memory tokenInfo = TokenInfo(
            tokensInfo[tokenAddress].transferOverhead,
            tokensInfo[tokenAddress].supportedToken,
            tokensInfo[tokenAddress].equilibriumFee,
            tokensInfo[tokenAddress].maxFee,
            transferConfig[tokenAddress]
        );
        return tokenInfo;
    }

    function getDepositConfig(uint256 toChainId, address tokenAddress)
        public
        view
        override
        returns (TokenConfig memory)
    {
        return depositConfig[toChainId][tokenAddress];
    }

    function getTransferConfig(address tokenAddress) public view override returns (TokenConfig memory) {
        return transferConfig[tokenAddress];
    }

    function _msgSender() internal view virtual override(Context, ERC2771Context) returns (address sender) {
        return ERC2771Context._msgSender();
    }

    function _msgData() internal view virtual override(Context, ERC2771Context) returns (bytes calldata) {
        return ERC2771Context._msgData();
    }
}",1169
RealWorld_TA_97_imports_RealWorld_20240812003228.log,97,imports,21471,2082,23553,73.0,0.148995,"// SPDX-License-Identifier: MIT
pragma solidity >=0.6.2;

import ""@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol"";",38
RealWorld_TA_97_LiquidityPool_RealWorld_20240811234831.log,97,LiquidityPool,345517,4410,349927,115.0,1.815785,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;
pragma abicoder v2;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""../security/Pausable.sol"";
import ""./interfaces/IExecutorManager.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""../interfaces/IERC20Permit.sol"";
import ""./interfaces/ITokenManager.sol"";

contract LiquidityPool is ReentrancyGuardUpgradeable, Pausable, OwnableUpgradeable, ERC2771ContextUpgradeable {
    address private constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 private constant BASE_DIVISOR = 10000000000; // Basis Points * 100 for better accuracy

    uint256 public baseGas;

    IExecutorManager private executorManager;
    ITokenManager public tokenManager;
    ILiquidityProviders public liquidityProviders;

    struct PermitRequest {
        uint256 nonce;
        uint256 expiry;
        bool allowed;
        uint8 v;
        bytes32 r;
        bytes32 s;
    }

    mapping(bytes32 => bool) public processedHash;
    mapping(address => uint256) public gasFeeAccumulatedByToken;

    // Gas fee accumulated by token address => executor address
    mapping(address => mapping(address => uint256)) public gasFeeAccumulated;

    // Incentive Pool amount per token address
    mapping(address => uint256) public incentivePool;

    event AssetSent(
        address indexed asset,
        uint256 indexed amount,
        uint256 indexed transferredAmount,
        address target,
        bytes depositHash,
        uint256 fromChainId
    );
    event FeeDetails(uint256 indexed lpFee, uint256 indexed transferFee, uint256 indexed gasFee);
    event Received(address indexed from, uint256 indexed amount);
    event Deposit(
        address indexed from,
        address indexed tokenAddress,
        address indexed receiver,
        uint256 toChainId,
        uint256 amount,
        uint256 reward,
        string tag
    );
    event GasFeeWithdraw(address indexed tokenAddress, address indexed owner, uint256 indexed amount);
    event TrustedForwarderChanged(address indexed forwarderAddress);
    event LiquidityProvidersChanged(address indexed liquidityProvidersAddress);
    event EthReceived(address, uint256);

    // MODIFIERS
    modifier onlyExecutor() {
        require(executorManager.getExecutorStatus(_msgSender()), ""Only executor is allowed"");
        _;
    }

    modifier onlyLiquidityProviders() {
        require(_msgSender() == address(liquidityProviders), ""Only liquidityProviders is allowed"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokenManager.getTokensInfo(tokenAddress).supportedToken, ""Token not supported"");
        _;
    }

    function initialize(
        address _executorManagerAddress,
        address _pauser,
        address _trustedForwarder,
        address _tokenManager,
        address _liquidityProviders
    ) public initializer {
        require(_executorManagerAddress != address(0), ""ExecutorManager cannot be 0x0"");
        require(_trustedForwarder != address(0), ""TrustedForwarder cannot be 0x0"");
        require(_liquidityProviders != address(0), ""LiquidityProviders cannot be 0x0"");
        __ERC2771Context_init(_trustedForwarder);
        __ReentrancyGuard_init();
        __Ownable_init();
        __Pausable_init(_pauser);
        executorManager = IExecutorManager(_executorManagerAddress);
        tokenManager = ITokenManager(_tokenManager);
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        baseGas = 21000;
    }

    function setTrustedForwarder(address trustedForwarder) public onlyOwner {
        require(trustedForwarder != address(0), ""TrustedForwarder can't be 0"");
        _trustedForwarder = trustedForwarder;
        emit TrustedForwarderChanged(trustedForwarder);
    }

    function setLiquidityProviders(address _liquidityProviders) public onlyOwner {
        require(_liquidityProviders != address(0), ""LiquidityProviders can't be 0"");
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        emit LiquidityProvidersChanged(_liquidityProviders);
    }

    function setBaseGas(uint128 gas) external onlyOwner {
        baseGas = gas;
    }

    function getExecutorManager() public view returns (address) {
        return address(executorManager);
    }

    function setExecutorManager(address _executorManagerAddress) external onlyOwner {
        require(_executorManagerAddress != address(0), ""Executor Manager cannot be 0"");
        executorManager = IExecutorManager(_executorManagerAddress);
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256 currentLiquidity) {
        uint256 liquidityPoolBalance = liquidityProviders.getCurrentLiquidity(tokenAddress);
        
        currentLiquidity =
            liquidityPoolBalance -
            liquidityProviders.totalLPFees(tokenAddress) -
            gasFeeAccumulatedByToken[tokenAddress] -
            incentivePool[tokenAddress];
    }

    /**
     * @dev Function used to deposit tokens into pool to initiate a cross chain token transfer.
     * @param toChainId Chain id where funds needs to be transfered
     * @param tokenAddress ERC20 Token address that needs to be transfered
     * @param receiver Address on toChainId where tokens needs to be transfered
     * @param amount Amount of token being transfered
     */
    function depositErc20(
        uint256 toChainId,
        address tokenAddress,
        address receiver,
        uint256 amount,
        string memory tag
    ) public tokenChecks(tokenAddress) whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, tokenAddress).min <= amount &&
                tokenManager.getDepositConfig(toChainId, tokenAddress).max >= amount,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(amount != 0, ""Amount cannot be 0"");
        address sender = _msgSender();

        uint256 rewardAmount = getRewardAmount(amount, tokenAddress);
        if (rewardAmount != 0) {
            incentivePool[tokenAddress] = incentivePool[tokenAddress] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);
        // Emit (amount + reward amount) in event
        emit Deposit(sender, tokenAddress, receiver, toChainId, amount + rewardAmount, rewardAmount, tag);
    }

    function getRewardAmount(uint256 amount, address tokenAddress) public view returns (uint256 rewardAmount) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);
        if (currentLiquidity < providedLiquidity) {
            uint256 liquidityDifference = providedLiquidity - currentLiquidity;
            if (amount >= liquidityDifference) {
                rewardAmount = incentivePool[tokenAddress];
            } else {
                // Multiply by 10000000000 to avoid 0 reward amount for small amount and liquidity difference
                rewardAmount = (amount * incentivePool[tokenAddress] * 10000000000) / liquidityDifference;
                rewardAmount = rewardAmount / 10000000000;
            }
        }
    }

    /**
     * DAI permit and Deposit.
     */
    function permitAndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            permitOptions.nonce,
            permitOptions.expiry,
            permitOptions.allowed,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    /**
     * EIP2612 and Deposit.
     */
    function permitEIP2612AndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            amount,
            permitOptions.expiry,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    /**
     * @dev Function used to deposit native token into pool to initiate a cross chain token transfer.
     * @param receiver Address on toChainId where tokens needs to be transfered
     * @param toChainId Chain id where funds needs to be transfered
     */
    function depositNative(
        address receiver,
        uint256 toChainId,
        string memory tag
    ) external payable whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, NATIVE).min <= msg.value &&
                tokenManager.getDepositConfig(toChainId, NATIVE).max >= msg.value,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(msg.value != 0, ""Amount cannot be 0"");

        uint256 rewardAmount = getRewardAmount(msg.value, NATIVE);
        if (rewardAmount != 0) {
            incentivePool[NATIVE] = incentivePool[NATIVE] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(NATIVE, msg.value);
        emit Deposit(_msgSender(), NATIVE, receiver, toChainId, msg.value + rewardAmount, rewardAmount, tag);
    }

    function sendFundsToUser(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash,
        uint256 tokenGasPrice,
        uint256 fromChainId
    ) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {
        uint256 initialGas = gasleft();
        require(
            tokenManager.getTransferConfig(tokenAddress).min <= amount &&
                tokenManager.getTransferConfig(tokenAddress).max >= amount,
            ""Withdraw amnt not in Cap limits""
        );
        require(receiver != address(0), ""Bad receiver address"");

        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);

        require(!status, ""Already Processed"");
        processedHash[hashSendTransaction] = true;

        uint256 amountToTransfer = getAmountToTransfer(initialGas, tokenAddress, amount, tokenGasPrice);
        liquidityProviders.decreaseCurrentLiquidity(tokenAddress, amountToTransfer);

        if (tokenAddress == NATIVE) {
            require(address(this).balance >= amountToTransfer, ""Not Enough Balance"");
            (bool success, ) = receiver.call{value: amountToTransfer}("""");
            require(success, ""Native Transfer Failed"");
        } else {
            require(IERC20Upgradeable(tokenAddress).balanceOf(address(this)) >= amountToTransfer, ""Not Enough Balance"");
            SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), receiver, amountToTransfer);
        }

        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash, fromChainId);
    }

    /**
     * @dev Internal function to calculate amount of token that needs to be transfered afetr deducting all required fees.
     * Fee to be deducted includes gas fee, lp fee and incentive pool amount if needed.
     * @param initialGas Gas provided initially before any calculations began
     * @param tokenAddress Token address for which calculation needs to be done
     * @param amount Amount of token to be transfered before deducting the fee
     * @param tokenGasPrice Gas price in the token being transfered to be used to calculate gas fee
     * @return amountToTransfer Total amount to be transfered after deducting all fees.
     */
    function getAmountToTransfer(
        uint256 initialGas,
        address tokenAddress,
        uint256 amount,
        uint256 tokenGasPrice
    ) internal returns (uint256 amountToTransfer) {
        uint256 transferFeePerc = getTransferFee(tokenAddress, amount);
        uint256 lpFee;
        if (transferFeePerc > tokenManager.getTokensInfo(tokenAddress).equilibriumFee) {
            // Here add some fee to incentive pool also
            lpFee = (amount * tokenManager.getTokensInfo(tokenAddress).equilibriumFee) / BASE_DIVISOR;
            incentivePool[tokenAddress] =
                (incentivePool[tokenAddress] +
                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /
                BASE_DIVISOR;
        } else {
            lpFee = (amount * transferFeePerc) / BASE_DIVISOR;
        }
        uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;

        liquidityProviders.addLPFee(tokenAddress, lpFee);

        uint256 totalGasUsed = initialGas - gasleft();
        totalGasUsed = totalGasUsed + tokenManager.getTokensInfo(tokenAddress).transferOverhead;
        totalGasUsed = totalGasUsed + baseGas;

        uint256 gasFee = totalGasUsed * tokenGasPrice;
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] + gasFee;
        gasFeeAccumulated[tokenAddress][_msgSender()] = gasFeeAccumulated[tokenAddress][_msgSender()] + gasFee;
        amountToTransfer = amount - (transferFeeAmount + gasFee);

        emit FeeDetails(lpFee, transferFeeAmount, gasFee);
    }

    function getTransferFee(address tokenAddress, uint256 amount) public view returns (uint256 fee) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);

        uint256 resultingLiquidity = currentLiquidity - amount;

        uint256 equilibriumFee = tokenManager.getTokensInfo(tokenAddress).equilibriumFee;
        uint256 maxFee = tokenManager.getTokensInfo(tokenAddress).maxFee;
        // Fee is represented in basis points * 10 for better accuracy
        uint256 numerator = providedLiquidity * equilibriumFee * maxFee; // F(max) * F(e) * L(e)
        uint256 denominator = equilibriumFee * providedLiquidity + (maxFee - equilibriumFee) * resultingLiquidity; // F(e) * L(e) + (F(max) - F(e)) * L(r)

        if (denominator == 0) {
            fee = 0;
        } else {
            fee = numerator / denominator;
        }
    }

    function checkHashStatus(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash
    ) public view returns (bytes32 hashSendTransaction, bool status) {
        hashSendTransaction = keccak256(abi.encode(tokenAddress, amount, receiver, keccak256(depositHash)));

        status = processedHash[hashSendTransaction];
    }

    function withdrawErc20GasFee(address tokenAddress) external onlyExecutor whenNotPaused nonReentrant {
        require(tokenAddress != NATIVE, ""Can't withdraw native token fee"");
        // uint256 gasFeeAccumulated = gasFeeAccumulatedByToken[tokenAddress];
        uint256 _gasFeeAccumulated = gasFeeAccumulated[tokenAddress][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] - _gasFeeAccumulated;
        gasFeeAccumulated[tokenAddress][_msgSender()] = 0;
        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), _msgSender(), _gasFeeAccumulated);
        emit GasFeeWithdraw(tokenAddress, _msgSender(), _gasFeeAccumulated);
    }

    function withdrawNativeGasFee() external onlyExecutor whenNotPaused nonReentrant {
        uint256 _gasFeeAccumulated = gasFeeAccumulated[NATIVE][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[NATIVE] = gasFeeAccumulatedByToken[NATIVE] - _gasFeeAccumulated;
        gasFeeAccumulated[NATIVE][_msgSender()] = 0;
        (bool success, ) = payable(_msgSender()).call{value: _gasFeeAccumulated}("""");
        require(success, ""Native Transfer Failed"");

        emit GasFeeWithdraw(address(this), _msgSender(), _gasFeeAccumulated);
    }

    function transfer(
        address _tokenAddress,
        address receiver,
        uint256 _tokenAmount
    ) external whenNotPaused onlyLiquidityProviders nonReentrant {
        require(receiver != address(0), ""Invalid receiver"");
        if (_tokenAddress == NATIVE) {
            require(address(this).balance >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            (bool success, ) = receiver.call{value: _tokenAmount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable baseToken = IERC20Upgradeable(_tokenAddress);
            require(baseToken.balanceOf(address(this)) >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            SafeERC20Upgradeable.safeTransfer(baseToken, receiver, _tokenAmount);
        }
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",4025
RealWorld_TA_97_Ethereum.USDC_RealWorld_20240812000946.log,97,Ethereum.USDC,454216,1445,455661,88.0,2.29998,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract EthereumUSDC is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st2{fill:#fff}.prefix__st11{font-family:&apos;Courier&apos;}.prefix__st12{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""-455.002"" cy=""406.389"" r=""1"" gradientTransform=""matrix(0 327.499 327.499 0 -132889.578 149012.563)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#8c8c8c""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000027595528782364205150000006743997006181374859_"" cx=""-455.002"" cy=""407.716"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 -68105.375 123380.75)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#2775ca""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000027595528782364205150000006743997006181374859_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st11 prefix__st12"">',
                    suppliedLiquidity,
                    ' USDC</text><text transform=""rotate(-90 213.61 143.092)"" class=""prefix__st2 prefix__st11 prefix__st12"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st11"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><g><path d=""M60.19 67c4.71 0 8.5-3.79 8.5-8.5S64.9 50 60.19 50s-8.5 3.79-8.5 8.5 3.79 8.5 8.5 8.5z"" fill=""#2775ca""/><path class=""prefix__st2"" d=""M62.52 59.85c0-1.24-.74-1.66-2.23-1.84-1.06-.14-1.27-.42-1.27-.92s.35-.81 1.06-.81c.64 0 .99.21 1.17.74.04.11.14.18.25.18h.57c.14 0 .25-.11.25-.25v-.04c-.14-.78-.78-1.38-1.59-1.45v-.86c0-.14-.11-.25-.28-.28h-.55c-.14 0-.25.11-.28.28v.81c-1.06.14-1.74.85-1.74 1.74 0 1.17.71 1.63 2.2 1.81.99.18 1.31.39 1.31.96s-.5.96-1.17.96c-.92 0-1.24-.39-1.35-.92-.04-.14-.14-.21-.25-.21h-.6c-.14 0-.25.11-.25.25v.04c.14.89.71 1.52 1.88 1.7v.85c0 .14.11.25.28.28h.53c.14 0 .25-.11.28-.28v-.85c1.07-.19 1.78-.94 1.78-1.89z""/><path class=""prefix__st2"" d=""M58.38 63.56c-2.76-.99-4.18-4.07-3.15-6.8.53-1.49 1.7-2.62 3.15-3.15.14-.07.21-.18.21-.35v-.5c0-.14-.07-.25-.21-.28-.04 0-.11 0-.14.04a6.354 6.354 0 00-4.14 8 6.364 6.364 0 004.14 4.14c.14.07.28 0 .32-.14.04-.04.04-.07.04-.14v-.5c-.01-.1-.11-.24-.22-.32zm3.75-11.05c-.14-.07-.28 0-.32.14-.04.04-.04.07-.04.14v.5c0 .14.11.28.21.35 2.76.99 4.18 4.07 3.15 6.8a5.225 5.225 0 01-3.15 3.15c-.14.07-.21.18-.21.35v.5c0 .14.07.25.21.28.04 0 .11 0 .14-.04a6.354 6.354 0 004.14-8c-.62-2.01-2.18-3.53-4.13-4.17z""/></g><g><path d=""M136.03 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h79.34c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#8c8c8c""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON ETHEREUM</text></g></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Ethereum"";
    }
}",5180
RealWorld_TA_97_Avalanche.ETH_RealWorld_20240812000455.log,97,Avalanche.ETH,413210,2106,415316,95.0,2.10817,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract AvalancheETH is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st15,.prefix__st2{fill:#fff}.prefix__st15{fill-opacity:.602}.prefix__st33{font-family:&apos;Courier&apos;}.prefix__st34{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""-907.223"" cy=""-502.221"" r=""1"" gradientTransform=""matrix(0 327.499 327.499 0 164679.5 297114.594)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#e84142""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000116202745994131917800000004493405675274567581_"" cx=""-906.644"" cy=""-499.568"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 83899.203 245773.469)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#627eea""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000116202745994131917800000004493405675274567581_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st33 prefix__st34"">',
                    suppliedLiquidity,
                    ' ETH</text><text transform=""rotate(-90 213.61 143.092)"" class=""prefix__st2 prefix__st33 prefix__st34"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st33"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><g><circle cx=""60.19"" cy=""58.5"" r=""8.5"" fill-rule=""evenodd"" clip-rule=""evenodd"" fill=""#627eea""/><path class=""prefix__st15"" d=""M60.45 52.12v4.71l3.98 1.78-3.98-6.49z""/><path class=""prefix__st2"" d=""M60.45 52.12l-3.98 6.49 3.98-1.78v-4.71z""/><path class=""prefix__st15"" d=""M60.45 61.67v3.2l3.99-5.51-3.99 2.31z""/><path class=""prefix__st2"" d=""M60.45 64.87v-3.2l-3.98-2.31 3.98 5.51z""/><path d=""M60.45 60.93l3.98-2.31-3.98-1.78v4.09z"" fill=""#fff"" fill-opacity="".2""/><path class=""prefix__st15"" d=""M56.47 58.62l3.98 2.31v-4.09l-3.98 1.78z""/></g><g><path d=""M142.44 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h85.75c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#e84142""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON AVALANCHE</text></g></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Avalanche"";
    }
}",4678
RealWorld_TA_97_WhitelistPeriodManager_RealWorld_20240811234649.log,97,WhitelistPeriodManager,214214,3945,218159,100.0,1.14997,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/ILPToken.sol"";

contract WhitelistPeriodManager is Initializable, OwnableUpgradeable, Pausable, ERC2771ContextUpgradeable {
    ILiquidityProviders private liquidityProviders;
    ITokenManager private tokenManager;
    ILPToken private lpToken;
    bool public areWhiteListRestrictionsEnabled;

    /* LP Status */
    // EOA? -> status, stores addresses that we want to ignore, like staking contracts.
    mapping(address => bool) public isExcludedAddress;
    // Token -> TVL
    mapping(address => uint256) private totalLiquidity;
    // Token -> TVL
    mapping(address => mapping(address => uint256)) public totalLiquidityByLp;

    /* Caps */
    // Token Address -> Limit
    mapping(address => uint256) public perTokenTotalCap;
    // Token Address -> Limit
    mapping(address => uint256) public perTokenWalletCap;

    event ExcludedAddressStatusUpdated(address indexed lp, bool indexed status);
    event TotalCapUpdated(address indexed token, uint256 totalCap);
    event PerTokenWalletCap(address indexed token, uint256 perCommunityWalletCap);
    event WhiteListStatusUpdated(bool status);

    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityProviders), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier onlyLpNft() {
        require(_msgSender() == address(lpToken), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    /**
     * @dev initalizes the contract, acts as constructor
     * @param _trustedForwarder address of trusted forwarder
     */
    function initialize(
        address _trustedForwarder,
        address _liquidityProviders,
        address _tokenManager,
        address _lpToken,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        areWhiteListRestrictionsEnabled = true;
        _setLiquidityProviders(_liquidityProviders);
        _setTokenManager(_tokenManager);
        _setLpToken(_lpToken);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    /**
     * @dev Internal Function which checks for various caps before allowing LP to add liqudity
     */
    function _beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        // Per Token Total Cap or PTTC
        require(ifEnabled(totalLiquidity[_token] + _amount <= perTokenTotalCap[_token]), ""ERR__LIQUIDITY_EXCEEDS_PTTC"");
        require(
            ifEnabled(totalLiquidityByLp[_token][_lp] + _amount <= perTokenWalletCap[_token]),
            ""ERR__LIQUIDITY_EXCEEDS_PTWC""
        );
        totalLiquidity[_token] += _amount;
        totalLiquidityByLp[_token][_lp] += _amount;
    }

    /**
     * @dev External Function which checks for various caps before allowing LP to add liqudity. Only callable by LiquidityPoolManager
     */
    function beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityAddition(_lp, _token, _amount);
    }

    /**
     * @dev Internal Function which checks for various caps before allowing LP to remove liqudity
     */
    function _beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        totalLiquidityByLp[_token][_lp] -= _amount;
        totalLiquidity[_token] -= _amount;
    }

    /**
     * @dev External Function which checks for various caps before allowing LP to remove liqudity. Only callable by LiquidityPoolManager
     */
    function beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityRemoval(_lp, _token, _amount);
    }

    /**
     * @dev External Function which checks for various caps before allowing LP to transfer their LpNFT. Only callable by LpNFT contract
     */
    function beforeLiquidityTransfer(
        address _from,
        address _to,
        address _token,
        uint256 _amount
    ) external onlyLpNft whenNotPaused {
        // Release limit from  _from
        _beforeLiquidityRemoval(_from, _token, _amount);

        // Block limit of _to
        _beforeLiquidityAddition(_to, _token, _amount);
    }

    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    function _setLiquidityProviders(address _liquidityProviders) internal {
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
    }

    function setLiquidityProviders(address _liquidityProviders) external onlyOwner {
        _setLiquidityProviders(_liquidityProviders);
    }

    function _setLpToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function setLpToken(address _lpToken) external onlyOwner {
        _setLpToken(_lpToken);
    }

    function setIsExcludedAddressStatus(address[] memory _addresses, bool[] memory _status) external onlyOwner {
        require(_addresses.length == _status.length, ""ERR__LENGTH_MISMATCH"");
        for (uint256 i = 0; i < _addresses.length; ++i) {
            isExcludedAddress[_addresses[i]] = _status[i];
            emit ExcludedAddressStatusUpdated(_addresses[i], _status[i]);
        }
    }

    function setTotalCap(address _token, uint256 _totalCap) public tokenChecks(_token) onlyOwner {
        require(totalLiquidity[_token] <= _totalCap, ""ERR__TOTAL_CAP_LESS_THAN_SL"");
        require(_totalCap >= perTokenWalletCap[_token], ""ERR__TOTAL_CAP_LT_PTWC"");
        if (perTokenTotalCap[_token] != _totalCap) {
            perTokenTotalCap[_token] = _totalCap;
            emit TotalCapUpdated(_token, _totalCap);
        }
    }

    /**
     * @dev Special care must be taken when calling this function
     *      There are no checks for _perTokenWalletCap (since it's onlyOwner), but it's essential that it
     *      should be >= max lp provided by an lp.
     *      Checking this on chain will probably require implementing a bbst, which needs more bandwidth
     *      Call the view function getMaxCommunityLpPositon() separately before changing this value
     */
    function setPerTokenWalletCap(address _token, uint256 _perTokenWalletCap) public tokenChecks(_token) onlyOwner {
        require(_perTokenWalletCap <= perTokenTotalCap[_token], ""ERR__PWC_GT_PTTC"");
        if (perTokenWalletCap[_token] != _perTokenWalletCap) {
            perTokenWalletCap[_token] = _perTokenWalletCap;
            emit PerTokenWalletCap(_token, _perTokenWalletCap);
        }
    }

    function setCap(
        address _token,
        uint256 _totalCap,
        uint256 _perTokenWalletCap
    ) public onlyOwner {
        setTotalCap(_token, _totalCap);
        setPerTokenWalletCap(_token, _perTokenWalletCap);
    }

    function setCaps(
        address[] memory _tokens,
        uint256[] memory _totalCaps,
        uint256[] memory _perTokenWalletCaps
    ) external onlyOwner {
        require(
            _tokens.length == _totalCaps.length && _totalCaps.length == _perTokenWalletCaps.length,
            ""ERR__LENGTH_MISMACH""
        );
        for (uint256 i = 0; i < _tokens.length; ++i) {
            setCap(_tokens[i], _totalCaps[i], _perTokenWalletCaps[i]);
        }
    }

    /**
     * @dev Enables (or disables) reverts if liquidity exceeds caps.
     *      Even if this is disabled, the contract will continue to track LP's positions
     */
    function setAreWhiteListRestrictionsEnabled(bool _status) external onlyOwner {
        areWhiteListRestrictionsEnabled = _status;
        emit WhiteListStatusUpdated(_status);
    }

    /**
     * @dev Returns the maximum amount a single community LP has provided
     */
    function getMaxCommunityLpPositon(address _token) external view returns (uint256) {
        uint256 totalSupply = lpToken.totalSupply();
        uint256 maxLp = 0;
        for (uint256 i = 1; i <= totalSupply; ++i) {
            uint256 liquidity = totalLiquidityByLp[_token][lpToken.ownerOf(i)];
            if (liquidity > maxLp) {
                maxLp = liquidity;
            }
        }
        return maxLp;
    }

    /**
     * @dev returns the value of if (areWhiteListEnabled) then (_cond)
     */
    function ifEnabled(bool _cond) private view returns (bool) {
        return !areWhiteListRestrictionsEnabled || (areWhiteListRestrictionsEnabled && _cond);
    }

    /**
     * @dev Meta-Transaction Helper, returns msgSender
     */
    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    /**
     * @dev Meta-Transaction Helper, returns msgData
     */
    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }
}",2422
RealWorld_TA_97_Pausable_RealWorld_20240812003521.log,97,Pausable,66946,2145,69091,74.0,0.37763,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol"";

/**
 * @dev Contract module which allows children to implement an emergency stop
 * mechanism that can be triggered by an authorized account.
 *
 * This module is used through inheritance. It will make available the
 * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
 * the functions of your contract. Note that they will not be pausable by
 * simply including this module, only once the modifiers are put in place.
 */
abstract contract Pausable is Initializable, PausableUpgradeable {
    address private _pauser;

    event PauserChanged(address indexed previousPauser, address indexed newPauser);

    /**
     * @dev The pausable constructor sets the original `pauser` of the contract to the sender
     * account & Initializes the contract in unpaused state..
     */
    function __Pausable_init(address pauser) internal initializer {
        require(pauser != address(0), ""Pauser Address cannot be 0"");
        __Pausable_init();
        _pauser = pauser;
    }

    /**
     * @return true if `msg.sender` is the owner of the contract.
     */
    function isPauser(address pauser) public view returns (bool) {
        return pauser == _pauser;
    }

    /**
     * @dev Throws if called by any account other than the pauser.
     */
    modifier onlyPauser() {
        require(isPauser(msg.sender), ""Only pauser is allowed to perform this operation"");
        _;
    }

    /**
     * @dev Allows the current pauser to transfer control of the contract to a newPauser.
     * @param newPauser The address to transfer pauserShip to.
     */
    function changePauser(address newPauser) public onlyPauser {
        _changePauser(newPauser);
    }

    /**
     * @dev Transfers control of the contract to a newPauser.
     * @param newPauser The address to transfer ownership to.
     */
    function _changePauser(address newPauser) internal {
        require(newPauser != address(0));
        emit PauserChanged(_pauser, newPauser);
        _pauser = newPauser;
    }

    function renouncePauser() external virtual onlyPauser {
        emit PauserChanged(_pauser, address(0));
        _pauser = address(0);
    }

    function pause() public onlyPauser {
        _pause();
    }

    function unpause() public onlyPauser {
        _unpause();
    }
}",587
RealWorld_TA_97_ILiquidityPool_RealWorld_20240812002240.log,97,ILiquidityPool,68150,3060,71210,81.0,0.40195,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

interface ILiquidityPool {
    function baseGas() external view returns (uint256);

    function changePauser(address newPauser) external;

    function checkHashStatus(
        address tokenAddress,
        uint256 amount,
        address receiver,
        bytes memory depositHash
    ) external view returns (bytes32 hashSendTransaction, bool status);

    function depositConfig(uint256, address) external view returns (uint256 min, uint256 max);

    function depositErc20(
        uint256 toChainId,
        address tokenAddress,
        address receiver,
        uint256 amount,
        string memory tag
    ) external;

    function depositNative(
        address receiver,
        uint256 toChainId,
        string memory tag
    ) external;

    function gasFeeAccumulated(address, address) external view returns (uint256);

    function gasFeeAccumulatedByToken(address) external view returns (uint256);

    function getCurrentLiquidity(address tokenAddress) external view returns (uint256 currentLiquidity);

    function getExecutorManager() external view returns (address);

    function getRewardAmount(uint256 amount, address tokenAddress) external view returns (uint256 rewardAmount);

    function getTransferFee(address tokenAddress, uint256 amount) external view returns (uint256 fee);

    function incentivePool(address) external view returns (uint256);

    function initialize(
        address _executorManagerAddress,
        address pauser,
        address _trustedForwarder,
        address _tokenManager,
        address _liquidityProviders
    ) external;

    function isPauser(address pauser) external view returns (bool);

    function isTrustedForwarder(address forwarder) external view returns (bool);

    function owner() external view returns (address);

    function paused() external view returns (bool);

    function processedHash(bytes32) external view returns (bool);

    function renounceOwnership() external;

    function renouncePauser() external;

    function transfer(address _tokenAddress, address receiver, uint256 _tokenAmount) external;

    function sendFundsToUser(
        address tokenAddress,
        uint256 amount,
        address receiver,
        bytes memory depositHash,
        uint256 tokenGasPrice,
        uint256 fromChainId
    ) external;

    function setBaseGas(uint128 gas) external;

    function setExecutorManager(address _executorManagerAddress) external;

    function setLiquidityProviders(address _liquidityProviders) external;

    function setTrustedForwarder(address trustedForwarder) external;

    function transferConfig(address) external view returns (uint256 min, uint256 max);

    function transferOwnership(address newOwner) external;

    function withdrawErc20GasFee(address tokenAddress) external;

    function withdrawNativeGasFee() external;
}",587
RealWorld_TA_97_LiquidityPoolProxy_RealWorld_20240812001422.log,97,LiquidityPoolProxy,54822,1340,56162,67.0,0.30091,"// contracts/bico-token/bico/BicoToken.sol

// SPDX-License-Identifier: MIT
pragma solidity 0.8.2;

import ""@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol"";

/**
 * @dev This contract implements a proxy that is upgradeable by an admin.
 *
 * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector
 * clashing], which can potentially be used in an attack, this contract uses the
 * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two
 * things that go hand in hand:
 *
 * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if
 * that call matches one of the admin functions exposed by the proxy itself.
 * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the
 * implementation. If the admin tries to call a function on the implementation it will fail with an error that says
 * ""admin cannot fallback to proxy target"".
 *
 * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing
 * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due
 * to sudden errors when trying to call a function from the proxy implementation.
 *
 * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,
 * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.
 */
contract LiquidityPoolProxy is TransparentUpgradeableProxy {
    constructor(address _implementation, address _admin)
        TransparentUpgradeableProxy(_implementation, _admin, bytes(""""))
    {}

    function getAdmin() external view returns (address adm) {
        adm = _admin();
    }

    function getImplementation() external view returns (address impl) {
        impl = _implementation();
    }
}",440
RealWorld_TA_97_ISvgHelper_RealWorld_20240812001852.log,97,ISvgHelper,35505,2173,37678,72.0,0.220985,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

interface ISvgHelper {
    function backgroundUrl() external view returns (string memory);

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) external view returns (string memory);

    function getAttributes(uint256 _suppliedLiquidity, uint256 _totalSuppliedLiquidity)
        external
        view
        returns (string memory);

    function getDescription(uint256 _suppliedLiquidity, uint256 _totalSuppliedLiquidity)
        external
        view
        returns (string memory);

    function getChainName() external view returns (string memory);

    function owner() external view returns (address);

    function renounceOwnership() external;

    function setBackgroundPngUrl(string memory _backgroundPngUrl) external;

    function transferOwnership(address newOwner) external;
}",201
RealWorld_TA_97_LPToken_RealWorld_20240811235156.log,97,LPToken,147466,3829,151295,94.0,0.81391,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;
pragma abicoder v2;

import ""@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol"";
import ""base64-sol/base64.sol"";
import ""../interfaces/ISvgHelper.sol"";
import ""../interfaces/IWhiteListPeriodManager.sol"";
import ""../interfaces/ILiquidityProviders.sol"";
import ""../../security/Pausable.sol"";
import ""../structures/LpTokenMetadata.sol"";

contract LPToken is
    OwnableUpgradeable,
    ReentrancyGuardUpgradeable,
    ERC721EnumerableUpgradeable,
    ERC721URIStorageUpgradeable,
    ERC2771ContextUpgradeable,
    Pausable
{
    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    address public liquidityProvidersAddress;
    IWhiteListPeriodManager public whiteListPeriodManager;
    mapping(uint256 => LpTokenMetadata) public tokenMetadata;
    mapping(address => ISvgHelper) public svgHelpers;

    event LiquidityProvidersUpdated(address indexed lpm);
    event WhiteListPeriodManagerUpdated(address indexed manager);
    event SvgHelperUpdated(address indexed tokenAddress, ISvgHelper indexed svgHelper);

    function initialize(
        string memory _name,
        string memory _symbol,
        address _trustedForwarder,
        address _pauser
    ) public initializer {
        __Ownable_init();
        __ERC721_init(_name, _symbol);
        __ERC721Enumerable_init();
        __Pausable_init(_pauser);
        __ERC721URIStorage_init();
        __ReentrancyGuard_init();
        __ERC2771Context_init(_trustedForwarder);
    }

    modifier onlyHyphenPools() {
        require(_msgSender() == liquidityProvidersAddress, ""ERR_UNAUTHORIZED"");
        _;
    }

    function setSvgHelper(address _tokenAddress, ISvgHelper _svgHelper) public onlyOwner {
        require(_svgHelper != ISvgHelper(address(0)), ""ERR_INVALID_SVG_HELPER"");
        require(_tokenAddress != address(0), ""ERR_INVALID_TOKEN_ADDRESS"");
        svgHelpers[_tokenAddress] = _svgHelper;
        emit SvgHelperUpdated(_tokenAddress, _svgHelper);
    }

    function setLiquidityProviders(address _liquidityProviders) external onlyOwner {
        require(_liquidityProviders != address(0), ""ERR_INVALID_LIQUIDITY_PROVIDERS"");
        liquidityProvidersAddress = _liquidityProviders;
        emit LiquidityProvidersUpdated(_liquidityProviders);
    }

    function setWhiteListPeriodManager(address _whiteListPeriodManager) external onlyOwner {
        require(_whiteListPeriodManager != address(0), ""ERR_INVALID_WHITELIST_PERIOD_MANAGER"");
        whiteListPeriodManager = IWhiteListPeriodManager(_whiteListPeriodManager);
        emit WhiteListPeriodManagerUpdated(_whiteListPeriodManager);
    }

    function getAllNftIdsByUser(address _owner) public view returns (uint256[] memory) {
        uint256[] memory nftIds = new uint256[](balanceOf(_owner));
        for (uint256 i = 0; i < nftIds.length; ++i) {
            nftIds[i] = tokenOfOwnerByIndex(_owner, i);
        }
        return nftIds;
    }

    function mint(address _to) external onlyHyphenPools whenNotPaused nonReentrant returns (uint256) {
        uint256 tokenId = totalSupply() + 1;
        _safeMint(_to, tokenId);
        return tokenId;
    }

    function updateTokenMetadata(uint256 _tokenId, LpTokenMetadata memory _lpTokenMetadata)
        external
        onlyHyphenPools
        whenNotPaused
    {
        require(_exists(_tokenId), ""ERR__TOKEN_DOES_NOT_EXIST"");
        tokenMetadata[_tokenId] = _lpTokenMetadata;
    }

    function exists(uint256 _tokenId) public view returns (bool) {
        return _exists(_tokenId);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)
        returns (string memory)
    {
        address tokenAddress = tokenMetadata[tokenId].token;
        require(svgHelpers[tokenAddress] != ISvgHelper(address(0)), ""ERR__SVG_HELPER_NOT_REGISTERED"");

        ISvgHelper svgHelper = ISvgHelper(svgHelpers[tokenAddress]);

        string memory svgData = svgHelper.getTokenSvg(
            tokenId,
            tokenMetadata[tokenId].suppliedLiquidity,
            ILiquidityProviders(liquidityProvidersAddress).totalReserve(tokenAddress)
        );

        string memory description = svgHelper.getDescription(
            tokenMetadata[tokenId].suppliedLiquidity,
            ILiquidityProviders(liquidityProvidersAddress).totalReserve(tokenAddress)
        );

        string memory attributes = svgHelper.getAttributes(
            tokenMetadata[tokenId].suppliedLiquidity,
            ILiquidityProviders(liquidityProvidersAddress).totalReserve(tokenAddress)
        );

        string memory json = Base64.encode(
            bytes(
                string(
                    abi.encodePacked(
                        '{""name"": ""',
                        name(),
                        '"", ""description"": ""',
                        description,
                        '"", ""image"": ""data:image/svg+xml;base64,',
                        Base64.encode(bytes(svgData)),
                        '"", ""attributes"": ',
                        attributes,
                        ""}""
                    )
                )
            )
        );
        return string(abi.encodePacked(""data:application/json;base64,"", json));
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual override(ERC721EnumerableUpgradeable, ERC721Upgradeable) whenNotPaused {
        super._beforeTokenTransfer(from, to, tokenId);

        // Only call whitelist period manager for NFT Transfers, not mint and burns
        if (from != address(0) && to != address(0)) {
            whiteListPeriodManager.beforeLiquidityTransfer(
                from,
                to,
                tokenMetadata[tokenId].token,
                tokenMetadata[tokenId].suppliedLiquidity
            );
        }
    }

    function _burn(uint256 tokenId) internal virtual override(ERC721URIStorageUpgradeable, ERC721Upgradeable) {
        ERC721URIStorageUpgradeable._burn(tokenId);
    }
}",1569
RealWorld_TA_97_TokenMintingReentrancy_RealWorld_20240812003343.log,97,TokenMintingReentrancy,36919,4822,41741,96.0,0.281035,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.0;
import ""../hyphen/LiquidityProviders.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol"";

contract TokenMintingReentrancy is IERC721ReceiverUpgradeable {
    LiquidityProviders public liquidityproviders;

    constructor(address _lproviders) {
        liquidityproviders = LiquidityProviders(payable(_lproviders));
    }

    function onERC721Received(
        address,
        address,
        uint256 tokenId,
        bytes calldata
    ) external override returns (bytes4) {
        if (tokenId < 10) {
            liquidityproviders.addNativeLiquidity{value: 1e12}();
        }
        return IERC721ReceiverUpgradeable.onERC721Received.selector;
    }

    receive() external payable {}

    function attack() external payable {
        liquidityproviders.addNativeLiquidity{value: msg.value}();
    }
}",207
RealWorld_TA_97_IWhiteListPeriodManager_RealWorld_20240812002524.log,97,IWhiteListPeriodManager,55730,2182,57912,76.0,0.32229,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

interface IWhiteListPeriodManager {
    function areWhiteListRestrictionsEnabled() external view returns (bool);

    function beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) external;

    function beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) external;

    function beforeLiquidityTransfer(
        address _from,
        address _to,
        address _token,
        uint256 _amount
    ) external;

    function getMaxCommunityLpPositon(address _token) external view returns (uint256);

    function initialize(
        address _trustedForwarder,
        address _liquidityProviders,
        address _tokenManager
    ) external;

    function isExcludedAddress(address) external view returns (bool);

    function isTrustedForwarder(address forwarder) external view returns (bool);

    function owner() external view returns (address);

    function paused() external view returns (bool);

    function perTokenTotalCap(address) external view returns (uint256);

    function perTokenWalletCap(address) external view returns (uint256);

    function renounceOwnership() external;

    function setAreWhiteListRestrictionsEnabled(bool _status) external;

    function setCap(
        address _token,
        uint256 _totalCap,
        uint256 _perTokenWalletCap
    ) external;

    function setCaps(
        address[] memory _tokens,
        uint256[] memory _totalCaps,
        uint256[] memory _perTokenWalletCaps
    ) external;

    function setIsExcludedAddressStatus(address[] memory _addresses, bool[] memory _status) external;

    function setLiquidityProviders(address _liquidityProviders) external;

    function setPerTokenWalletCap(address _token, uint256 _perTokenWalletCap) external;

    function setTokenManager(address _tokenManager) external;

    function setTotalCap(address _token, uint256 _totalCap) external;

    function transferOwnership(address newOwner) external;
}",443
RealWorld_TA_97_ERC2771ContextUpgradeable_RealWorld_20240812001741.log,97,ERC2771ContextUpgradeable,48722,1552,50274,69.0,0.27465,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

/**
 * @dev Context variant with ERC2771 support. 
 * Here _trustedForwarder is made internal instead of private
 * so it can be changed via Child contracts with a setter method.
 */
abstract contract ERC2771ContextUpgradeable is Initializable, ContextUpgradeable {
    address internal _trustedForwarder;

    function __ERC2771Context_init(address trustedForwarder) internal initializer {
        __Context_init_unchained();
        __ERC2771Context_init_unchained(trustedForwarder);
    }

    function __ERC2771Context_init_unchained(address trustedForwarder) internal initializer {
        _trustedForwarder = trustedForwarder;
    }

    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {
        return forwarder == _trustedForwarder;
    }

    function _msgSender() internal view virtual override returns (address sender) {
        if (isTrustedForwarder(msg.sender)) {
            // The assembly code is more direct than the Solidity version using `abi.decode`.
            assembly {
                sender := shr(96, calldataload(sub(calldatasize(), 20)))
            }
        } else {
            return super._msgSender();
        }
    }

    function _msgData() internal view virtual override returns (bytes calldata) {
        if (isTrustedForwarder(msg.sender)) {
            return msg.data[:msg.data.length - 20];
        } else {
            return super._msgData();
        }
    }
    uint256[49] private __gap;
}",372
RealWorld_TA_97_Ethereum.ETH_RealWorld_20240812001116.log,97,Ethereum.ETH,413182,1602,414784,87.0,2.09795,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract EthereumETH is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st15,.prefix__st2{fill:#fff}.prefix__st15{fill-opacity:.602}.prefix__st26{font-family:&apos;Courier&apos;}.prefix__st27{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""-455.002"" cy=""406.389"" r=""1"" gradientTransform=""matrix(0 327.499 327.499 0 -132889.578 149012.563)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#8c8c8c""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000141442605033164902770000000811733122206392226_"" cx=""-908.323"" cy=""-44.569"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 7669.416 246228.469)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#627eea""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000141442605033164902770000000811733122206392226_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st26 prefix__st27"">',
                    suppliedLiquidity,
                    ' ETH</text><text transform=""rotate(-90 213.61 143.092)"" class=""prefix__st2 prefix__st26 prefix__st27"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st26"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><g><path d=""M136.03 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h79.34c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#8c8c8c""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON ETHEREUM</text></g><g><circle cx=""60.19"" cy=""58.5"" r=""8.5"" fill-rule=""evenodd"" clip-rule=""evenodd"" fill=""#627eea""/><path class=""prefix__st15"" d=""M60.45 52.12v4.71l3.98 1.78-3.98-6.49z""/><path class=""prefix__st2"" d=""M60.45 52.12l-3.98 6.49 3.98-1.78v-4.71z""/><path class=""prefix__st15"" d=""M60.45 61.67v3.2l3.99-5.51-3.99 2.31z""/><path class=""prefix__st2"" d=""M60.45 64.87v-3.2l-3.98-2.31 3.98 5.51z""/><path d=""M60.45 60.93l3.98-2.31-3.98-1.78v4.09z"" fill=""#fff"" fill-opacity="".2""/><path class=""prefix__st15"" d=""M56.47 58.62l3.98 2.31v-4.09l-3.98 1.78z""/></g></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Ethereum"";
    }
}",4683
RealWorld_TA_97_LiquidityFarming_RealWorld_20240811234420.log,97,LiquidityFarming,321957,7168,329125,147.0,1.753145,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ILiquidityProviders.sol"";

contract HyphenLiquidityFarming is
    Initializable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable,
    ReentrancyGuardUpgradeable,
    IERC721ReceiverUpgradeable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    ILPToken public lpToken;
    ILiquidityProviders public liquidityProviders;

    struct NFTInfo {
        address payable staker;
        uint256 rewardDebt;
        uint256 unpaidRewards;
        bool isStaked;
    }

    struct PoolInfo {
        uint256 accTokenPerShare;
        uint256 lastRewardTime;
    }

    struct RewardsPerSecondEntry {
        uint256 rewardsPerSecond;
        uint256 timestamp;
    }

    /// @notice Mapping to track the rewarder pool.
    mapping(address => PoolInfo) public poolInfo;

    /// @notice Info of each NFT that is staked.
    mapping(uint256 => NFTInfo) public nftInfo;

    /// @notice Reward rate per base token
    //mapping(address => uint256) public rewardPerSecond;

    /// @notice Reward Token
    mapping(address => address) public rewardTokens;

    /// @notice Staker => NFTs staked
    mapping(address => uint256[]) public nftIdsStaked;

    /// @notice Token => Total Shares Staked
    mapping(address => uint256) public totalSharesStaked;

    /// @notice Token => Reward Rate Updation history
    mapping(address => RewardsPerSecondEntry[]) public rewardRateLog;

    uint256 private constant ACC_TOKEN_PRECISION = 1e12;
    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    event LogDeposit(address indexed user, address indexed baseToken, uint256 nftId);
    event LogWithdraw(address indexed user, address baseToken, uint256 nftId, address indexed to);
    event LogOnReward(address indexed user, address indexed baseToken, uint256 amount, address indexed to);
    event LogUpdatePool(address indexed baseToken, uint256 lastRewardTime, uint256 lpSupply, uint256 accToken1PerShare);
    event LogRewardPerSecond(address indexed baseToken, uint256 rewardPerSecond);
    event LogRewardPoolInitialized(address _baseToken, address _rewardToken, uint256 _rewardPerSecond);
    event LogNativeReceived(address indexed sender, uint256 value);

    function initialize(
        address _trustedForwarder,
        address _pauser,
        ILiquidityProviders _liquidityProviders,
        ILPToken _lpToken
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        liquidityProviders = _liquidityProviders;
        lpToken = _lpToken;
    }

    /// @notice Initialize the rewarder pool.
    /// @param _baseToken Base token to be used for the rewarder pool.
    /// @param _rewardToken Reward token to be used for the rewarder pool.
    /// @param _rewardPerSecond Reward rate per base token.
    function initalizeRewardPool(
        address _baseToken,
        address _rewardToken,
        uint256 _rewardPerSecond
    ) external onlyOwner {
        require(rewardTokens[_baseToken] == address(0), ""ERR__POOL_ALREADY_INITIALIZED"");
        require(_baseToken != address(0), ""ERR__BASE_TOKEN_IS_ZERO"");
        require(_rewardToken != address(0), ""ERR_REWARD_TOKEN_IS_ZERO"");
        rewardTokens[_baseToken] = _rewardToken;
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPoolInitialized(_baseToken, _rewardToken, _rewardPerSecond);
    }

    function _sendErc20AndGetSentAmount(
        IERC20Upgradeable _token,
        uint256 _amount,
        address _to
    ) private returns (uint256) {
        uint256 recepientBalance = _token.balanceOf(_to);
        _token.safeTransfer(_to, _amount);
        return _token.balanceOf(_to) - recepientBalance;
    }

    /// @notice Update the reward state of a nft, and if possible send reward funds to _to.
    /// @param _nftId NFT ID that is being locked
    /// @param _to Address to which rewards will be credited.
    function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {
        NFTInfo storage nft = nftInfo[_nftId];
        require(nft.isStaked, ""ERR__NFT_NOT_STAKED"");

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = updatePool(baseToken);
        uint256 pending;
        uint256 amountSent;
        if (amount > 0) {
            pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
            if (rewardTokens[baseToken] == NATIVE) {
                uint256 balance = address(this).balance;
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    (bool success, ) = _to.call{value: balance}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = balance;
                } else {
                    nft.unpaidRewards = 0;
                    (bool success, ) = _to.call{value: pending}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = pending;
                }
            } else {
                IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);
                uint256 balance = rewardToken.balanceOf(address(this));
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);
                } else {
                    nft.unpaidRewards = 0;
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);
                }
            }
        }
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;
        emit LogOnReward(_msgSender(), baseToken, amountSent, _to);
    }

    /// @notice Sets the sushi per second to be distributed. Can only be called by the owner.
    /// @param _rewardPerSecond The amount of Sushi to be distributed per second.
    function setRewardPerSecond(address _baseToken, uint256 _rewardPerSecond) public onlyOwner {
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPerSecond(_baseToken, _rewardPerSecond);
    }

    /// @notice Allows owner to reclaim/withdraw any tokens (including reward tokens) held by this contract
    /// @param _token Token to reclaim, use 0x00 for Ethereum
    /// @param _amount Amount of tokens to reclaim
    /// @param _to Receiver of the tokens, first of his name, rightful heir to the lost tokens,
    /// reightful owner of the extra tokens, and ether, protector of mistaken transfers, mother of token reclaimers,
    /// the Khaleesi of the Great Token Sea, the Unburnt, the Breaker of blockchains.
    function reclaimTokens(
        address _token,
        uint256 _amount,
        address payable _to
    ) external nonReentrant onlyOwner {
        require(_to != address(0), ""ERR__TO_IS_ZERO"");
        if (_token == NATIVE) {
            (bool success, ) = payable(_to).call{value: _amount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable(_token).safeTransfer(_to, _amount);
        }
    }

    /// @notice Deposit LP tokens
    /// @param _nftId LP token nftId to deposit.
    function deposit(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();

        require(
            lpToken.isApprovedForAll(msgSender, address(this)) || lpToken.getApproved(_nftId) == address(this),
            ""ERR__NOT_APPROVED""
        );

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        require(rewardTokens[baseToken] != address(0), ""ERR__POOL_NOT_INITIALIZED"");
        require(rewardRateLog[baseToken].length != 0, ""ERR__POOL_NOT_INITIALIZED"");

        NFTInfo storage nft = nftInfo[_nftId];
        require(!nft.isStaked, ""ERR__NFT_ALREADY_STAKED"");

        lpToken.safeTransferFrom(msgSender, address(this), _nftId);

        PoolInfo memory pool = updatePool(baseToken);
        nft.isStaked = true;
        nft.staker = _to;
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;

        nftIdsStaked[_to].push(_nftId);
        totalSharesStaked[baseToken] += amount;

        emit LogDeposit(msgSender, baseToken, _nftId);
    }

    /// @notice Withdraw LP tokens
    /// @param _nftId LP token nftId to withdraw.
    /// @param _to The receiver of `amount` withdraw benefit.
    function withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();
        uint256 nftsStakedLength = nftIdsStaked[msgSender].length;
        uint256 index;
        for (index = 0; index < nftsStakedLength; ++index) {
            if (nftIdsStaked[msgSender][index] == _nftId) {
                break;
            }
        }

        require(index != nftsStakedLength, ""ERR__NFT_NOT_STAKED"");
        nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];
        nftIdsStaked[msgSender].pop();

        _sendRewardsForNft(_nftId, _to);
        delete nftInfo[_nftId];

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();
        totalSharesStaked[baseToken] -= amount;

        lpToken.safeTransferFrom(address(this), msgSender, _nftId);

        emit LogWithdraw(msgSender, baseToken, _nftId, _to);
    }

    /// @notice Extract all rewards without withdrawing LP tokens
    /// @param _nftId LP token nftId for which rewards are to be withdrawn
    /// @param _to The receiver of withdraw benefit.
    function extractRewards(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        require(nftInfo[_nftId].staker == _msgSender(), ""ERR__NOT_OWNER"");
        _sendRewardsForNft(_nftId, _to);
    }

    /// @notice Calculates an up to date value of accTokenPerShare
    /// @notice An updated value of accTokenPerShare is comitted to storage every time a new NFT is deposited, withdrawn or rewards are extracted
    function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {
        uint256 accumulator = 0;
        uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;
        uint256 counter = block.timestamp;
        uint256 i = rewardRateLog[_baseToken].length - 1;
        while (true) {
            if (lastUpdatedTime >= counter) {
                break;
            }
            unchecked {
                accumulator +=
                    rewardRateLog[_baseToken][i].rewardsPerSecond *
                    (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));
            }
            counter = rewardRateLog[_baseToken][i].timestamp;
            if (i == 0) {
                break;
            }
            --i;
        }

        // We know that during all the periods that were included in the current iterations,
        // the value of totalSharesStaked[_baseToken] would not have changed, as we only consider the
        // updates to the pool that happened after the lastUpdatedTime.
        accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];
        return accumulator + poolInfo[_baseToken].accTokenPerShare;
    }

    /// @notice View function to see pending Token
    /// @param _nftId NFT for which pending tokens are to be viewed
    /// @return pending reward for a given user.
    function pendingToken(uint256 _nftId) external view returns (uint256) {
        NFTInfo storage nft = nftInfo[_nftId];
        if (!nft.isStaked) {
            return 0;
        }

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = poolInfo[baseToken];
        uint256 accToken1PerShare = pool.accTokenPerShare;
        if (block.timestamp > pool.lastRewardTime && totalSharesStaked[baseToken] != 0) {
            accToken1PerShare = getUpdatedAccTokenPerShare(baseToken);
        }
        return ((amount * accToken1PerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
    }

    /// @notice Update reward variables of the given pool.
    /// @return pool Returns the pool that was updated.
    function updatePool(address _baseToken) public whenNotPaused returns (PoolInfo memory pool) {
        pool = poolInfo[_baseToken];
        if (block.timestamp > pool.lastRewardTime) {
            if (totalSharesStaked[_baseToken] > 0) {
                pool.accTokenPerShare = getUpdatedAccTokenPerShare(_baseToken);
            }
            pool.lastRewardTime = block.timestamp;
            poolInfo[_baseToken] = pool;
            emit LogUpdatePool(_baseToken, pool.lastRewardTime, totalSharesStaked[_baseToken], pool.accTokenPerShare);
        }
    }

    /// @notice View function to see the tokens staked by a given user.
    /// @param _user Address of user.
    function getNftIdsStaked(address _user) public view returns (uint256[] memory nftIds) {
        nftIds = nftIdsStaked[_user];
    }

    function getRewardRatePerSecond(address _baseToken) public view returns (uint256) {
        return rewardRateLog[_baseToken][rewardRateLog[_baseToken].length - 1].rewardsPerSecond;
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure override(IERC721ReceiverUpgradeable) returns (bytes4) {
        return bytes4(keccak256(""onERC721Received(address,address,uint256,bytes)""));
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit LogNativeReceived(_msgSender(), msg.value);
    }

    function max(uint256 _a, uint256 _b) private pure returns (uint256) {
        return _a >= _b ? _a : _b;
    }
}",3691
RealWorld_TA_97_Polygon.USDC_RealWorld_20240811235829.log,97,Polygon.USDC,453896,1598,455494,98.0,2.30144,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract PolygonUSDC is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st2{fill:#fff}.prefix__st24{font-family:&apos;Courier&apos;}.prefix__st25{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""-453.612"" cy=""-48.611"" r=""1"" gradientTransform=""matrix(0 327.499 327.499 0 16122.466 148557.563)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#8247e5""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000165226099336628332060000012643825665705734299_"" cx=""-453.323"" cy=""-47.284"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 8124.416 122925.75)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#2775ca""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000165226099336628332060000012643825665705734299_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st24 prefix__st25"">',
                    suppliedLiquidity,
                    ' USDC</text><text transform=""rotate(-90 213.61 143.092)"" class=""prefix__st2 prefix__st24 prefix__st25"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st24"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><path d=""M128.52 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h71.83c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#8247e5""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON POLYGON</text><g><path d=""M60.19 67c4.71 0 8.5-3.79 8.5-8.5S64.9 50 60.19 50s-8.5 3.79-8.5 8.5 3.79 8.5 8.5 8.5z"" fill=""#2775ca""/><path class=""prefix__st2"" d=""M62.52 59.85c0-1.24-.74-1.66-2.23-1.84-1.06-.14-1.27-.42-1.27-.92s.35-.81 1.06-.81c.64 0 .99.21 1.17.74.04.11.14.18.25.18h.57c.14 0 .25-.11.25-.25v-.04c-.14-.78-.78-1.38-1.59-1.45v-.86c0-.14-.11-.25-.28-.28h-.55c-.14 0-.25.11-.28.28v.81c-1.06.14-1.74.85-1.74 1.74 0 1.17.71 1.63 2.2 1.81.99.18 1.31.39 1.31.96s-.5.96-1.17.96c-.92 0-1.24-.39-1.35-.92-.04-.14-.14-.21-.25-.21h-.6c-.14 0-.25.11-.25.25v.04c.14.89.71 1.52 1.88 1.7v.85c0 .14.11.25.28.28h.53c.14 0 .25-.11.28-.28v-.85c1.07-.19 1.78-.94 1.78-1.89z""/><path class=""prefix__st2"" d=""M58.38 63.56c-2.76-.99-4.18-4.07-3.15-6.8.53-1.49 1.7-2.62 3.15-3.15.14-.07.21-.18.21-.35v-.5c0-.14-.07-.25-.21-.28-.04 0-.11 0-.14.04a6.354 6.354 0 00-4.14 8 6.364 6.364 0 004.14 4.14c.14.07.28 0 .32-.14.04-.04.04-.07.04-.14v-.5c-.01-.1-.11-.24-.22-.32zm3.75-11.05c-.14-.07-.28 0-.32.14-.04.04-.04.07-.04.14v.5c0 .14.11.28.21.35 2.76.99 4.18 4.07 3.15 6.8a5.225 5.225 0 01-3.15 3.15c-.14.07-.21.18-.21.35v.5c0 .14.07.25.21.28.04 0 .11 0 .14-.04a6.354 6.354 0 004.14-8c-.62-2.01-2.18-3.53-4.13-4.17z""/></g></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Polygon"";
    }
}",5169
RealWorld_TA_97_LiquidityProvidersMaliciousReentrant_RealWorld_20240812002804.log,97,LiquidityProvidersMaliciousReentrant,41974,5556,47530,108.0,0.32099,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.0;
import ""../hyphen/LiquidityPool.sol"";

contract LiquidityProvidersMaliciousReentrant {
    LiquidityPool public lpool;
    address private constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    address private owner;
    modifier onlyOwner() {
        require(owner == msg.sender, ""Unauthorized"");
        _;
    }

    constructor(address _lpaddress) {
        owner = msg.sender;
        lpool = LiquidityPool(payable(_lpaddress));
    }

    fallback() external payable {
        if (address(lpool).balance >= 1 ether) {
            lpool.transfer(NATIVE, address(this), 1 ether);
        }
    }

    receive() external payable {
        if (address(lpool).balance >= 1 ether) {
            lpool.transfer(NATIVE, address(this), 1 ether);
        }
    }

    function getBalance(address target) public view returns (uint256) {
        return target.balance;
    }

    function destruct() external onlyOwner {
        selfdestruct(payable(owner));
    }
}",250
RealWorld_TA_97_ERC20Token_RealWorld_20240812002954.log,97,ERC20Token,27363,2343,29706,69.0,0.183675,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";

contract ERC20Token is ERC20Upgradeable {
  function initialize(string memory _name, string memory _symbol)
    public
    initializer
  {
    __ERC20_init(_name, _symbol);
  }

  function mint(address _to, uint256 _amount) external {
    _mint(_to, _amount);
  }
}",107
RealWorld_TA_97_SvgHelperBase_RealWorld_20240811235332.log,97,SvgHelperBase,122176,2620,124796,99.0,0.66328,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/Strings.sol"";
import ""base64-sol/base64.sol"";

abstract contract SvgHelperBase is Ownable {
    using Strings for uint256;

    uint256 public tokenDecimals;

    event BackgroundUrlUpdated(string newBackgroundUrl);
    event TokenDecimalsUpdated(uint256 newTokenDecimals);

    constructor(uint256 _tokenDecimals) Ownable() {
        tokenDecimals = _tokenDecimals;
    }

    function setTokenDecimals(uint256 _tokenDecimals) public onlyOwner {
        tokenDecimals = _tokenDecimals;
        emit TokenDecimalsUpdated(_tokenDecimals);
    }

    /// @notice Given an integer, returns the number of digits in it's decimal representation.
    /// @param _number The number to get the number of digits in.
    /// @return The number of digits in the decimal representation of the given number.
    function _getDigitsCount(uint256 _number) internal pure returns (uint256) {
        uint256 count = 0;
        while (_number > 0) {
            ++count;
            _number /= 10;
        }
        return count;
    }

    /// @notice Generates a string containing 0s of the given length.
    /// @param _length The length of the string to generate.
    /// @return A string of 0s of the given length.
    function _getZeroString(uint256 _length) internal pure returns (string memory) {
        if (_length == 0) {
            return """";
        }
        string memory result;
        for (uint256 i = 0; i < _length; ++i) {
            result = string(abi.encodePacked(result, ""0""));
        }
        return result;
    }

    /// @notice Truncate Digits from the right
    function _truncateDigitsFromRight(uint256 _number, uint256 _digitsCount) internal pure returns (uint256) {
        uint256 result = _number /= (10**_digitsCount);
        // Remove Leading Zeroes
        while (result != 0 && result % 10 == 0) {
            result /= 10;
        }
        return result;
    }

    /// @notice Return str(_value / 10^_power)
    function _divideByPowerOf10(
        uint256 _value,
        uint256 _power,
        uint256 _maxDigitsAfterDecimal
    ) internal pure returns (string memory) {
        uint256 integerPart = _value / 10**_power;
        uint256 leadingZeroesToAddBeforeDecimal = 0;
        uint256 fractionalPartTemp = _value % (10**_power);

        uint256 powerRemaining = _power;
        if (fractionalPartTemp != 0) {
            // Remove Leading Zeroes
            while (fractionalPartTemp != 0 && fractionalPartTemp % 10 == 0) {
                fractionalPartTemp /= 10;
                if (powerRemaining > 0) {
                    powerRemaining--;
                }
            }

            uint256 expectedFractionalDigits = powerRemaining;
            if (_getDigitsCount(fractionalPartTemp) < expectedFractionalDigits) {
                leadingZeroesToAddBeforeDecimal = expectedFractionalDigits - _getDigitsCount(fractionalPartTemp);
            }
        }

        if (fractionalPartTemp == 0) {
            return integerPart.toString();
        }
        uint256 digitsToTruncateCount = _getDigitsCount(fractionalPartTemp) + leadingZeroesToAddBeforeDecimal >
            _maxDigitsAfterDecimal
            ? _getDigitsCount(fractionalPartTemp) + leadingZeroesToAddBeforeDecimal - _maxDigitsAfterDecimal
            : 0;
        return
            string(
                abi.encodePacked(
                    integerPart.toString(),
                    ""."",
                    _getZeroString(leadingZeroesToAddBeforeDecimal),
                    _truncateDigitsFromRight(fractionalPartTemp, digitsToTruncateCount).toString()
                )
            );
    }

    function getAttributes(uint256 _suppliedLiquidity, uint256 _totalSuppliedLiquidity)
        public
        view
        virtual
        returns (string memory)
    {
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    ""["",
                    '{ ""trait_type"": ""Supplied Liquidity"", ""display_type"": ""number"", ""value"": ',
                    suppliedLiquidity,
                    '},{ ""trait_type"": ""Share Percentage"", ""value"": ""',
                    sharePercent,
                    '%""}]'
                )
            );
    }

    function getDescription(uint256 _suppliedLiquidity, uint256 _totalSuppliedLiquidity)
        public
        view
        virtual
        returns (string memory)
    {
        return
            string(
                abi.encodePacked(
                    ""This NFT represents your position as Liquidity Provider on Hyphen Bridge on "",
                    getChainName(),
                    "". To visit the bridge, visit [Hyphen](https://hyphen.biconomy.io).""
                )
            );
    }

    /// @notice Return str(_value / _denom * 100)
    function _calculatePercentage(uint256 _num, uint256 _denom) internal pure returns (string memory) {
        return _divideByPowerOf10((_num * 10**(18 + 2)) / _denom, 18, 2);
    }

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual returns (string memory);

    function getChainName() public view virtual returns (string memory);
}",1258
RealWorld_TA_97_Ethereum.USDT_RealWorld_20240812000812.log,97,Ethereum.USDT,422328,1697,424025,92.0,2.14558,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract EthereumUSDT is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st2{fill:#fff}.prefix__st28{font-family:&apos;Courier&apos;}.prefix__st29{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""-455.002"" cy=""406.389"" r=""1"" gradientTransform=""matrix(0 327.499 327.499 0 -132889.578 149012.563)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#8c8c8c""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000096046149083906169040000006838268896560026277_"" cx=""3.356"" cy=""-505"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 84809.203 -831.976)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#50af95""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000096046149083906169040000006838268896560026277_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st28 prefix__st29"">',
                    suppliedLiquidity,
                    ' USDT</text><text transform=""rotate(-90 213.61 143.092)"" class=""prefix__st2 prefix__st28 prefix__st29"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st28"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><g fill-rule=""evenodd"" clip-rule=""evenodd""><path d=""M54.8 51.18l-3.1 6.51a.14.14 0 00.03.15l8.37 8.02c.05.05.13.05.18 0l8.37-8.02c.04-.04.05-.1.03-.15l-3.1-6.51a.136.136 0 00-.11-.07H54.91c-.05-.01-.09.02-.11.07z"" fill=""#50af95""/><path d=""M61.26 58.36c-.06 0-.37.02-1.06.02-.55 0-.94-.02-1.08-.02-2.13-.09-3.72-.46-3.72-.91 0-.44 1.59-.81 3.72-.91v1.45c.14.01.54.03 1.09.03.66 0 .99-.03 1.05-.03v-1.45c2.12.09 3.71.47 3.71.91s-1.59.81-3.71.91zm0-1.97v-1.3h2.97v-1.98h-8.07v1.98h2.96v1.3c-2.41.11-4.22.59-4.22 1.16s1.81 1.05 4.22 1.16v4.15h2.14v-4.15c2.4-.11 4.21-.59 4.21-1.16s-1.8-1.05-4.21-1.16zm0 0"" fill=""#fff""/></g><g><path d=""M136.03 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h79.34c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#8c8c8c""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON ETHEREUM</text></g></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Ethereum"";
    }
}",4793
RealWorld_TA_97_IExecutorManager_RealWorld_20240812002006.log,97,IExecutorManager,29331,2104,31435,73.0,0.188735,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;

interface IExecutorManager {
    function getExecutorStatus(address executor) external view returns (bool status);

    function getAllExecutors() external view returns (address[] memory);

    //Register new Executors
    function addExecutors(address[] calldata executorArray) external;

    // Register single executor
    function addExecutor(address executorAddress) external;

    //Remove registered Executors
    function removeExecutors(address[] calldata executorArray) external;

    // Remove Register single executor
    function removeExecutor(address executorAddress) external;
}",124
RealWorld_TA_97_ExecutorManager_RealWorld_20240811234033.log,97,ExecutorManager,54479,2438,56917,84.0,0.321155,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./interfaces/IExecutorManager.sol"";

contract ExecutorManager is IExecutorManager, Ownable {
    address[] internal executors;
    mapping(address => bool) internal executorStatus;

    event ExecutorAdded(address executor, address owner);
    event ExecutorRemoved(address executor, address owner);

    // MODIFIERS
    modifier onlyExecutor() {
        require(executorStatus[msg.sender], ""You are not allowed to perform this operation"");
        _;
    }

    function getExecutorStatus(address executor) public view override returns (bool status) {
        status = executorStatus[executor];
    }

    function getAllExecutors() public view override returns (address[] memory) {
        return executors;
    }

    //Register new Executors
    function addExecutors(address[] calldata executorArray) external override onlyOwner {
        for (uint256 i = 0; i < executorArray.length; ++i) {
            addExecutor(executorArray[i]);
        }
    }

    // Register single executor
    function addExecutor(address executorAddress) public override onlyOwner {
        require(executorAddress != address(0), ""executor address can not be 0"");
        require(!executorStatus[executorAddress], ""Executor already registered"");
        executors.push(executorAddress);
        executorStatus[executorAddress] = true;
        emit ExecutorAdded(executorAddress, msg.sender);
    }

    //Remove registered Executors
    function removeExecutors(address[] calldata executorArray) external override onlyOwner {
        for (uint256 i = 0; i < executorArray.length; ++i) {
            removeExecutor(executorArray[i]);
        }
    }

    // Remove Register single executor
    function removeExecutor(address executorAddress) public override onlyOwner {
        require(executorAddress != address(0), ""executor address can not be 0"");
        executorStatus[executorAddress] = false;
        emit ExecutorRemoved(executorAddress, msg.sender);
    }
}",426
RealWorld_TA_97_LiquidityProvidersTest_RealWorld_20240812003105.log,97,LiquidityProvidersTest,34398,3770,38168,81.0,0.24739,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../hyphen/LiquidityProviders.sol"";
import ""hardhat/console.sol"";

contract LiquidityProvidersTest is LiquidityProviders {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    function addLpFeeTesting(address _token, uint256 _amount) external payable {
        totalReserve[_token] += _amount;
        totalLPFees[_token] += _amount;

        if (_token == NATIVE) {
            (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable(_token).safeTransferFrom(msg.sender, address(liquidityPool), _amount);
        }
    }
}",174
RealWorld_TA_97_ILiquidityProviders_RealWorld_20240812002642.log,97,ILiquidityProviders,62116,2840,64956,80.0,0.36738,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

interface ILiquidityProviders {
    function BASE_DIVISOR() external view returns (uint256);

    function initialize(address _trustedForwarder, address _lpToken) external;

    function addLPFee(address _token, uint256 _amount) external;

    function addNativeLiquidity() external;

    function addTokenLiquidity(address _token, uint256 _amount) external;

    function claimFee(uint256 _nftId) external;

    function getFeeAccumulatedOnNft(uint256 _nftId) external view returns (uint256);

    function getSuppliedLiquidityByToken(address tokenAddress) external view returns (uint256);

    function getTokenPriceInLPShares(address _baseToken) external view returns (uint256);

    function getTotalLPFeeByToken(address tokenAddress) external view returns (uint256);

    function getTotalReserveByToken(address tokenAddress) external view returns (uint256);

    function getSuppliedLiquidity(uint256 _nftId) external view returns (uint256);

    function increaseNativeLiquidity(uint256 _nftId) external;

    function increaseTokenLiquidity(uint256 _nftId, uint256 _amount) external;

    function isTrustedForwarder(address forwarder) external view returns (bool);

    function owner() external view returns (address);

    function paused() external view returns (bool);

    function removeLiquidity(uint256 _nftId, uint256 amount) external;

    function renounceOwnership() external;

    function setLiquidityPool(address _liquidityPool) external;

    function setLpToken(address _lpToken) external;

    function setWhiteListPeriodManager(address _whiteListPeriodManager) external;

    function sharesToTokenAmount(uint256 _shares, address _tokenAddress) external view returns (uint256);

    function totalLPFees(address) external view returns (uint256);

    function totalLiquidity(address) external view returns (uint256);

    function totalReserve(address) external view returns (uint256);

    function totalSharesMinted(address) external view returns (uint256);

    function transferOwnership(address newOwner) external;

    function whiteListPeriodManager() external view returns (address);

    function increaseCurrentLiquidity(address tokenAddress, uint256 amount) external;

    function decreaseCurrentLiquidity(address tokenAddress, uint256 amount) external;

    function getCurrentLiquidity(address tokenAddress) external view returns (uint256);
}",534
RealWorld_TA_97_LiquidityProviders_RealWorld_20240811234159.log,97,LiquidityProviders,379902,5398,385300,138.0,2.00747,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/IWhiteListPeriodManager.sol"";
import ""./interfaces/ILiquidityPool.sol"";

contract LiquidityProviders is
    Initializable,
    ReentrancyGuardUpgradeable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 public constant BASE_DIVISOR = 10**18;

    ILPToken internal lpToken;
    ILiquidityPool internal liquidityPool;
    ITokenManager internal tokenManager;
    IWhiteListPeriodManager internal whiteListPeriodManager;

    event LiquidityAdded(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event LiquidityRemoved(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event FeeClaimed(address indexed tokenAddress, uint256 indexed fee, address indexed lp, uint256 sharesBurnt);
    event FeeAdded(address indexed tokenAddress, uint256 indexed fee);
    event EthReceived(address indexed sender, uint256 value);
    event CurrentLiquidityChanged(address indexed token, uint256 indexed oldValue, uint256 indexed newValue);

    // LP Fee Distribution
    mapping(address => uint256) public totalReserve; // Include Liquidity + Fee accumulated
    mapping(address => uint256) public totalLiquidity; // Include Liquidity only
    mapping(address => uint256) public currentLiquidity; // Include current liquidity, updated on every in and out transfer
    mapping(address => uint256) public totalLPFees;
    mapping(address => uint256) public totalSharesMinted;

    /**
     * @dev Modifier for checking to validate a NFTId and it's ownership
     * @param _tokenId token id to validate
     * @param _transactor typically msgSender(), passed to verify against owner of _tokenId
     */
    modifier onlyValidLpToken(uint256 _tokenId, address _transactor) {
        (address token, , ) = lpToken.tokenMetadata(_tokenId);
        require(lpToken.exists(_tokenId), ""ERR__TOKEN_DOES_NOT_EXIST"");
        require(lpToken.ownerOf(_tokenId) == _transactor, ""ERR__TRANSACTOR_DOES_NOT_OWN_NFT"");
        _;
    }

    /**
     * @dev Modifier for checking if msg.sender in liquiditypool
     */
    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityPool), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    /**
     * @dev initalizes the contract, acts as constructor
     * @param _trustedForwarder address of trusted forwarder
     */
    function initialize(
        address _trustedForwarder,
        address _lpToken,
        address _tokenManager,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        _setLPToken(_lpToken);
        _setTokenManager(_tokenManager);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    function getTotalReserveByToken(address tokenAddress) public view returns (uint256) {
        return totalReserve[tokenAddress];
    }

    function getSuppliedLiquidityByToken(address tokenAddress) public view returns (uint256) {
        return totalLiquidity[tokenAddress];
    }

    function getTotalLPFeeByToken(address tokenAddress) public view returns (uint256) {
        return totalLPFees[tokenAddress];
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256) {
        return currentLiquidity[tokenAddress];
    }

    /**
     * @dev To be called post initialization, used to set address of NFT Contract
     * @param _lpToken address of lpToken
     */
    function setLpToken(address _lpToken) external onlyOwner {
        _setLPToken(_lpToken);
    }

    /**
     * Internal method to set LP token contract.
     */
    function _setLPToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function increaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _increaseCurrentLiquidity(tokenAddress, amount);
    }

    function decreaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _decreaseCurrentLiquidity(tokenAddress, amount);
    }

    function _increaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] += amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]-amount, currentLiquidity[tokenAddress]);
    }

    function _decreaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] -= amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]+amount, currentLiquidity[tokenAddress]);
    }

    /**
     * Public method to set TokenManager contract.
     */
    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    /**
     * Internal method to set TokenManager contract.
     */
    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    /**
     * @dev To be called post initialization, used to set address of WhiteListPeriodManager Contract
     * @param _whiteListPeriodManager address of WhiteListPeriodManager
     */
    function setWhiteListPeriodManager(address _whiteListPeriodManager) external onlyOwner {
        whiteListPeriodManager = IWhiteListPeriodManager(_whiteListPeriodManager);
    }

    /**
     * @dev To be called post initialization, used to set address of LiquidityPool Contract
     * @param _liquidityPool address of LiquidityPool
     */
    function setLiquidityPool(address _liquidityPool) external onlyOwner {
        liquidityPool = ILiquidityPool(_liquidityPool);
    }

    /**
     * @dev Returns price of Base token in terms of LP Shares
     * @param _baseToken address of baseToken
     * @return Price of Base token in terms of LP Shares
     */
    function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {
        uint256 supply = totalSharesMinted[_baseToken];
        if (supply > 0) {
            return totalSharesMinted[_baseToken] / totalReserve[_baseToken];
        }
        return BASE_DIVISOR;
    }

    /**
     * @dev Converts shares to token amount
     */

    function sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {
        return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress];
    }

    /**
     * @dev Returns the fee accumulated on a given NFT
     * @param _nftId Id of NFT
     * @return accumulated fee
     */
    function getFeeAccumulatedOnNft(uint256 _nftId) public view returns (uint256) {
        require(lpToken.exists(_nftId), ""ERR__INVALID_NFT"");

        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);

        if (totalNFTShares == 0) {
            return 0;
        }
        // Calculate rewards accumulated
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated;

        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount 
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        return lpFeeAccumulated;
    }

    /**
     * @dev Records fee being added to total reserve
     * @param _token Address of Token for which LP fee is being added
     * @param _amount Amount being added
     */
    function addLPFee(address _token, uint256 _amount) external onlyLiquidityPool tokenChecks(_token) whenNotPaused {
        totalReserve[_token] += _amount;
        totalLPFees[_token] += _amount;
        emit FeeAdded(_token, _amount);
    }

    /**
     * @dev Internal function to add liquidity to a new NFT
     */
    function _addLiquidity(address _token, uint256 _amount) internal {
        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        uint256 nftId = lpToken.mint(_msgSender());
        LpTokenMetadata memory data = LpTokenMetadata(_token, 0, 0);
        lpToken.updateTokenMetadata(nftId, data);
        _increaseLiquidity(nftId, _amount);
    }

    /**
     * @dev Function to mint a new NFT for a user, add native liquidity and store the
     *      record in the newly minted NFT
     */
    function addNativeLiquidity() external payable nonReentrant tokenChecks(NATIVE) whenNotPaused {
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _addLiquidity(NATIVE, msg.value);
    }

    /**
     * @dev Function to mint a new NFT for a user, add token liquidity and store the
     *      record in the newly minted NFT
     * @param _token Address of token for which liquidity is to be added
     * @param _amount Amount of liquidity added
     */
    function addTokenLiquidity(address _token, uint256 _amount)
        external
        nonReentrant
        tokenChecks(_token)
        whenNotPaused
    {
        require(_token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(_token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(_token), _msgSender(), address(liquidityPool), _amount);
        _addLiquidity(_token, _amount);
    }

    /**
     * @dev Internal helper function to increase liquidity in a given NFT
     */
    function _increaseLiquidity(uint256 _nftId, uint256 _amount) internal onlyValidLpToken(_nftId, _msgSender()) {
        (address token, uint256 totalSuppliedLiquidity, uint256 totalShares) = lpToken.tokenMetadata(_nftId);

        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        whiteListPeriodManager.beforeLiquidityAddition(_msgSender(), token, _amount);

        uint256 mintedSharesAmount;
        // Adding liquidity in the pool for the first time
        if (totalReserve[token] == 0) {
            mintedSharesAmount = BASE_DIVISOR * _amount;
        } else {
            mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];
        }

        require(mintedSharesAmount >= BASE_DIVISOR, ""ERR__AMOUNT_BELOW_MIN_LIQUIDITY"");

        totalLiquidity[token] += _amount;
        totalReserve[token] += _amount;
        totalSharesMinted[token] += mintedSharesAmount;

        LpTokenMetadata memory data = LpTokenMetadata(
            token,
            totalSuppliedLiquidity + _amount,
            totalShares + mintedSharesAmount
        );
        lpToken.updateTokenMetadata(_nftId, data);

        // Increase the current liquidity
        _increaseCurrentLiquidity(token, _amount);
        emit LiquidityAdded(token, _amount, _msgSender());
    }

    /**
     * @dev Function to allow LPs to add ERC20 token liquidity to existing NFT
     * @param _nftId ID of NFT for updating the balances
     * @param _amount Token amount to be added
     */
    function increaseTokenLiquidity(uint256 _nftId, uint256 _amount) external nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(token), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(token), _msgSender(), address(liquidityPool), _amount);
        _increaseLiquidity(_nftId, _amount);
    }

    /**
     * @dev Function to allow LPs to add native token liquidity to existing NFT
     */
    function increaseNativeLiquidity(uint256 _nftId) external payable nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(NATIVE), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token == NATIVE, ""ERR__WRONG_FUNCTION"");
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _increaseLiquidity(_nftId, msg.value);
    }

    /**
     * @dev Function to allow LPs to remove their liquidity from an existing NFT
     *      Also automatically redeems any earned fee
     */
    function removeLiquidity(uint256 _nftId, uint256 _amount)
        external
        nonReentrant
        onlyValidLpToken(_nftId, _msgSender())
        whenNotPaused
    {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        require(_amount != 0, ""ERR__INVALID_AMOUNT"");
        require(nftSuppliedLiquidity >= _amount, ""ERR__INSUFFICIENT_LIQUIDITY"");
        whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);
        // Claculate how much shares represent input amount
        uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);

        // Calculate rewards accumulated
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        
        uint256 lpFeeAccumulated;

        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount 
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        // Calculate amount of lp shares that represent accumulated Fee
        uint256 lpSharesRepresentingFee = lpFeeAccumulated * getTokenPriceInLPShares(_tokenAddress);

        totalLPFees[_tokenAddress] -= lpFeeAccumulated;
        uint256 amountToWithdraw = _amount + lpFeeAccumulated;
        uint256 lpSharesToBurn = lpSharesForInputAmount + lpSharesRepresentingFee;

        // Handle round off errors to avoid dust lp token in contract
        if (totalNFTShares - lpSharesToBurn < BASE_DIVISOR) {
            lpSharesToBurn = totalNFTShares;
        }
        totalReserve[_tokenAddress] -= amountToWithdraw;
        totalLiquidity[_tokenAddress] -= _amount;
        totalSharesMinted[_tokenAddress] -= lpSharesToBurn;

        _decreaseCurrentLiquidity(_tokenAddress, _amount);

        _burnSharesFromNft(_nftId, lpSharesToBurn, _amount, _tokenAddress);

        _transferFromLiquidityPool(_tokenAddress, _msgSender(), amountToWithdraw);

        emit LiquidityRemoved(_tokenAddress, amountToWithdraw, _msgSender());
    }

    /**
     * @dev Function to allow LPs to claim the fee earned on their NFT
     * @param _nftId ID of NFT where liquidity is recorded
     */
    function claimFee(uint256 _nftId) external onlyValidLpToken(_nftId, _msgSender()) whenNotPaused nonReentrant {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        uint256 lpSharesForSuppliedLiquidity = nftSuppliedLiquidity * getTokenPriceInLPShares(_tokenAddress);

        // Calculate rewards accumulated
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
        require(lpFeeAccumulated > 0, ""ERR__NO_REWARDS_TO_CLAIM"");
        // Calculate amount of lp shares that represent accumulated Fee
        uint256 lpSharesRepresentingFee = totalNFTShares - lpSharesForSuppliedLiquidity;

        totalReserve[_tokenAddress] -= lpFeeAccumulated;
        totalSharesMinted[_tokenAddress] -= lpSharesRepresentingFee;
        totalLPFees[_tokenAddress] -= lpFeeAccumulated;

        _burnSharesFromNft(_nftId, lpSharesRepresentingFee, 0, _tokenAddress);
        _transferFromLiquidityPool(_tokenAddress, _msgSender(), lpFeeAccumulated);
        emit FeeClaimed(_tokenAddress, lpFeeAccumulated, _msgSender(), lpSharesRepresentingFee);
    }

    /**
     * @dev Internal Function to burn LP shares and remove liquidity from existing NFT
     */
    function _burnSharesFromNft(
        uint256 _nftId,
        uint256 _shares,
        uint256 _tokenAmount,
        address _tokenAddress
    ) internal {
        (, uint256 nftSuppliedLiquidity, uint256 nftShares) = lpToken.tokenMetadata(_nftId);
        nftShares -= _shares;
        nftSuppliedLiquidity -= _tokenAmount;

        lpToken.updateTokenMetadata(_nftId, LpTokenMetadata(_tokenAddress, nftSuppliedLiquidity, nftShares));
    }

    function _transferFromLiquidityPool(
        address _tokenAddress,
        address _receiver,
        uint256 _tokenAmount
    ) internal {
        liquidityPool.transfer(_tokenAddress, _receiver, _tokenAmount);
    }

    function getSuppliedLiquidity(uint256 _nftId) external view returns (uint256) {
        (, uint256 totalSuppliedLiquidity, ) = lpToken.tokenMetadata(_nftId);
        return totalSuppliedLiquidity;
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",4555
RealWorld_TA_97_ILPToken_RealWorld_20240812002403.log,97,ILPToken,64756,2437,67193,79.0,0.37252,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../structures/LpTokenMetadata.sol"";

interface ILPToken {
    function approve(address to, uint256 tokenId) external;

    function balanceOf(address _owner) external view returns (uint256);

    function exists(uint256 _tokenId) external view returns (bool);

    function getAllNftIdsByUser(address _owner) external view returns (uint256[] memory);

    function getApproved(uint256 tokenId) external view returns (address);

    function initialize(
        string memory _name,
        string memory _symbol,
        address _trustedForwarder
    ) external;

    function isApprovedForAll(address _owner, address operator) external view returns (bool);

    function isTrustedForwarder(address forwarder) external view returns (bool);

    function liquidityPoolAddress() external view returns (address);

    function mint(address _to) external returns (uint256);

    function name() external view returns (string memory);

    function owner() external view returns (address);

    function ownerOf(uint256 tokenId) external view returns (address);

    function paused() external view returns (bool);

    function renounceOwnership() external;

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) external;

    function setApprovalForAll(address operator, bool approved) external;

    function setLiquidityPool(address _lpm) external;

    function setWhiteListPeriodManager(address _whiteListPeriodManager) external;

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

    function symbol() external view returns (string memory);

    function tokenByIndex(uint256 index) external view returns (uint256);

    function tokenMetadata(uint256)
        external
        view
        returns (
            address token,
            uint256 totalSuppliedLiquidity,
            uint256 totalShares
        );

    function tokenOfOwnerByIndex(address _owner, uint256 index) external view returns (uint256);

    function tokenURI(uint256 tokenId) external view returns (string memory);

    function totalSupply() external view returns (uint256);

    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    function transferOwnership(address newOwner) external;

    function updateTokenMetadata(uint256 _tokenId, LpTokenMetadata memory _lpTokenMetadata) external;

    function whiteListPeriodManager() external view returns (address);
}",540
RealWorld_TA_98_AssetsRegistry_RealWorld_20240812080859.log,98,AssetsRegistry,72332,1875,74207,72.0,0.39916,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""../interfaces/IQuantConfig.sol"";
import ""../interfaces/IAssetsRegistry.sol"";

/// @title For managing assets supported as underlying for options in the Quant Protocol
/// @author Rolla
contract AssetsRegistry is IAssetsRegistry {
    struct AssetProperties {
        string name;
        string symbol;
        uint8 decimals;
    }

    IQuantConfig private _quantConfig;

    /// @inheritdoc IAssetsRegistry
    mapping(address => AssetProperties) public override assetProperties;

    /// @inheritdoc IAssetsRegistry
    address[] public override registeredAssets;

    /// @dev Checks that the `msg.sender` has permission to add assets to the registry.
    /// @dev Also checks that the asset had not been added before.
    modifier validAsset(address _underlying) {
        require(
            _quantConfig.hasRole(
                _quantConfig.quantRoles(""ASSETS_REGISTRY_MANAGER_ROLE""),
                msg.sender
            ),
            ""AssetsRegistry: only asset registry managers can add assets""
        );

        require(
            bytes(assetProperties[_underlying].symbol).length == 0,
            ""AssetsRegistry: asset already added""
        );

        _;
    }

    /// @param quantConfig_ address of the Quant central configuration contract
    constructor(address quantConfig_) {
        require(
            quantConfig_ != address(0),
            ""AssetsRegistry: invalid QuantConfig address""
        );

        _quantConfig = IQuantConfig(quantConfig_);
    }

    /// @inheritdoc IAssetsRegistry
    function addAsset(
        address _underlying,
        string calldata _name,
        string calldata _symbol,
        uint8 _decimals
    ) external override validAsset(_underlying) {
        assetProperties[_underlying] = AssetProperties(
            _name,
            _symbol,
            _decimals
        );

        registeredAssets.push(_underlying);

        emit AssetAdded(_underlying, _name, _symbol, _decimals);
    }

    /// @inheritdoc IAssetsRegistry
    function addAssetWithOptionalERC20Methods(address _underlying)
        external
        override
        validAsset(_underlying)
    {
        string memory name = ERC20(_underlying).name();
        require(bytes(name).length > 0, ""AssetsRegistry: invalid empty name"");

        string memory symbol = ERC20(_underlying).symbol();
        require(
            bytes(symbol).length > 0,
            ""AssetsRegistry: invalid empty symbol""
        );

        uint8 decimals = ERC20(_underlying).decimals();
        require(decimals > 0, ""AssetsRegistry: invalid zero decimals"");

        assetProperties[_underlying] = AssetProperties(name, symbol, decimals);

        registeredAssets.push(_underlying);

        emit AssetAdded(_underlying, name, symbol, decimals);
    }

    /// @inheritdoc IAssetsRegistry
    function getAssetsLength() external view override returns (uint256) {
        return registeredAssets.length;
    }
}",642
RealWorld_TA_98_ERC1155_RealWorld_20240812084704.log,98,ERC1155,340029,2480,342509,102.0,1.749745,"// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC1155/ERC1155.sol)

pragma solidity 0.8.12;

import ""@openzeppelin/contracts/token/ERC1155/IERC1155.sol"";
import ""@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol"";
import ""@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol"";
import ""@openzeppelin/contracts/utils/Context.sol"";
import ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";

/**
 * @dev Implementation of the basic standard multi-token.
 * See https://eips.ethereum.org/EIPS/eip-1155
 * Originally based on code by Enjin: https://github.com/enjin/erc-1155
 *
 * _Available since v3.1._
 */
contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {
    using Address for address;

    // Mapping from token ID to account balances
    mapping(uint256 => mapping(address => uint256)) private _balances;

    // Mapping from account to operator approvals
    mapping(address => mapping(address => bool)) internal _operatorApprovals;

    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json
    string private _uri;

    /**
     * @dev See {_setURI}.
     */
    constructor(string memory uri_) {
        _setURI(uri_);
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC165, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(IERC1155).interfaceId ||
            interfaceId == type(IERC1155MetadataURI).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /**
     * @dev See {IERC1155MetadataURI-uri}.
     *
     * This implementation returns the same URI for *all* token types. It relies
     * on the token type ID substitution mechanism
     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].
     *
     * Clients calling this function must replace the `\{id\}` substring with the
     * actual token type ID.
     */
    function uri(uint256) public view virtual override returns (string memory) {
        return _uri;
    }

    /**
     * @dev See {IERC1155-balanceOf}.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function balanceOf(address account, uint256 id)
        public
        view
        virtual
        override
        returns (uint256)
    {
        require(
            account != address(0),
            ""ERC1155: balance query for the zero address""
        );
        return _balances[id][account];
    }

    /**
     * @dev See {IERC1155-balanceOfBatch}.
     *
     * Requirements:
     *
     * - `accounts` and `ids` must have the same length.
     */
    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)
        public
        view
        virtual
        override
        returns (uint256[] memory)
    {
        require(
            accounts.length == ids.length,
            ""ERC1155: accounts and ids length mismatch""
        );

        uint256[] memory batchBalances = new uint256[](accounts.length);

        for (uint256 i = 0; i < accounts.length; ++i) {
            batchBalances[i] = balanceOf(accounts[i], ids[i]);
        }

        return batchBalances;
    }

    /**
     * @dev See {IERC1155-setApprovalForAll}.
     */
    function setApprovalForAll(address operator, bool approved)
        public
        virtual
        override
    {
        _setApprovalForAll(_msgSender(), operator, approved);
    }

    /**
     * @dev See {IERC1155-isApprovedForAll}.
     */
    function isApprovedForAll(address account, address operator)
        public
        view
        virtual
        override
        returns (bool)
    {
        return _operatorApprovals[account][operator];
    }

    /**
     * @dev See {IERC1155-safeTransferFrom}.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }

    /**
     * @dev See {IERC1155-safeBatchTransferFrom}.
     */
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: transfer caller is not owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }

    /**
     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - `from` must have a balance of tokens of type `id` of at least `amount`.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function _safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) internal virtual {
        require(to != address(0), ""ERC1155: transfer to the zero address"");

        address operator = _msgSender();

        _beforeTokenTransfer(
            operator,
            from,
            to,
            _asSingletonArray(id),
            _asSingletonArray(amount),
            data
        );

        uint256 fromBalance = _balances[id][from];
        require(
            fromBalance >= amount,
            ""ERC1155: insufficient balance for transfer""
        );
        unchecked {
            _balances[id][from] = fromBalance - amount;
        }
        _balances[id][to] += amount;

        emit TransferSingle(operator, from, to, id, amount);

        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);
    }

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.
     *
     * Emits a {TransferBatch} event.
     *
     * Requirements:
     *
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
     * acceptance magic value.
     */
    function _safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal virtual {
        require(
            ids.length == amounts.length,
            ""ERC1155: ids and amounts length mismatch""
        );
        require(to != address(0), ""ERC1155: transfer to the zero address"");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, from, to, ids, amounts, data);

        for (uint256 i = 0; i < ids.length; ++i) {
            uint256 id = ids[i];
            uint256 amount = amounts[i];

            uint256 fromBalance = _balances[id][from];
            require(
                fromBalance >= amount,
                ""ERC1155: insufficient balance for transfer""
            );
            unchecked {
                _balances[id][from] = fromBalance - amount;
            }
            _balances[id][to] += amount;
        }

        emit TransferBatch(operator, from, to, ids, amounts);

        _doSafeBatchTransferAcceptanceCheck(
            operator,
            from,
            to,
            ids,
            amounts,
            data
        );
    }

    /**
     * @dev Sets a new URI for all token types, by relying on the token type ID
     * substitution mechanism
     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].
     *
     * By this mechanism, any occurrence of the `\{id\}` substring in either the
     * URI or any of the amounts in the JSON file at said URI will be replaced by
     * clients with the token type ID.
     *
     * For example, the `https://token-cdn-domain/\{id\}.json` URI would be
     * interpreted by clients as
     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`
     * for token type ID 0x4cce0.
     *
     * See {uri}.
     *
     * Because these URIs cannot be meaningfully represented by the {URI} event,
     * this function emits no events.
     */
    function _setURI(string memory newuri) internal virtual {
        _uri = newuri;
    }

    /**
     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function _mint(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) internal virtual {
        require(to != address(0), ""ERC1155: mint to the zero address"");

        address operator = _msgSender();

        _beforeTokenTransfer(
            operator,
            address(0),
            to,
            _asSingletonArray(id),
            _asSingletonArray(amount),
            data
        );

        _balances[id][to] += amount;
        emit TransferSingle(operator, address(0), to, id, amount);

        _doSafeTransferAcceptanceCheck(
            operator,
            address(0),
            to,
            id,
            amount,
            data
        );
    }

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.
     *
     * Requirements:
     *
     * - `ids` and `amounts` must have the same length.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
     * acceptance magic value.
     */
    function _mintBatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal virtual {
        require(to != address(0), ""ERC1155: mint to the zero address"");
        require(
            ids.length == amounts.length,
            ""ERC1155: ids and amounts length mismatch""
        );

        address operator = _msgSender();

        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);

        for (uint256 i = 0; i < ids.length; i++) {
            _balances[ids[i]][to] += amounts[i];
        }

        emit TransferBatch(operator, address(0), to, ids, amounts);

        _doSafeBatchTransferAcceptanceCheck(
            operator,
            address(0),
            to,
            ids,
            amounts,
            data
        );
    }

    /**
     * @dev Destroys `amount` tokens of token type `id` from `from`
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `from` must have at least `amount` tokens of token type `id`.
     */
    function _burn(
        address from,
        uint256 id,
        uint256 amount
    ) internal virtual {
        require(from != address(0), ""ERC1155: burn from the zero address"");

        address operator = _msgSender();

        _beforeTokenTransfer(
            operator,
            from,
            address(0),
            _asSingletonArray(id),
            _asSingletonArray(amount),
            """"
        );

        uint256 fromBalance = _balances[id][from];
        require(fromBalance >= amount, ""ERC1155: burn amount exceeds balance"");
        unchecked {
            _balances[id][from] = fromBalance - amount;
        }

        emit TransferSingle(operator, from, address(0), id, amount);
    }

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.
     *
     * Requirements:
     *
     * - `ids` and `amounts` must have the same length.
     */
    function _burnBatch(
        address from,
        uint256[] memory ids,
        uint256[] memory amounts
    ) internal virtual {
        require(from != address(0), ""ERC1155: burn from the zero address"");
        require(
            ids.length == amounts.length,
            ""ERC1155: ids and amounts length mismatch""
        );

        address operator = _msgSender();

        _beforeTokenTransfer(operator, from, address(0), ids, amounts, """");

        for (uint256 i = 0; i < ids.length; i++) {
            uint256 id = ids[i];
            uint256 amount = amounts[i];

            uint256 fromBalance = _balances[id][from];
            require(
                fromBalance >= amount,
                ""ERC1155: burn amount exceeds balance""
            );
            unchecked {
                _balances[id][from] = fromBalance - amount;
            }
        }

        emit TransferBatch(operator, from, address(0), ids, amounts);
    }

    /**
     * @dev Approve `operator` to operate on all of `owner` tokens
     *
     * Emits a {ApprovalForAll} event.
     */
    function _setApprovalForAll(
        address owner,
        address operator,
        bool approved
    ) internal virtual {
        require(owner != operator, ""ERC1155: setting approval status for self"");
        _operatorApprovals[owner][operator] = approved;
        emit ApprovalForAll(owner, operator, approved);
    }

    /**
     * @dev Hook that is called before any token transfer. This includes minting
     * and burning, as well as batched variants.
     *
     * The same hook is called on both single and batched variants. For single
     * transfers, the length of the `id` and `amount` arrays will be 1.
     *
     * Calling conditions (for each `id` and `amount` pair):
     *
     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * of token type `id` will be  transferred to `to`.
     * - When `from` is zero, `amount` tokens of token type `id` will be minted
     * for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`
     * will be burned.
     * - `from` and `to` are never both zero.
     * - `ids` and `amounts` have the same, non-zero length.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal virtual {}

    function _doSafeTransferAcceptanceCheck(
        address operator,
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) private {
        if (to.isContract()) {
            try
                IERC1155Receiver(to).onERC1155Received(
                    operator,
                    from,
                    id,
                    amount,
                    data
                )
            returns (bytes4 response) {
                if (response != IERC1155Receiver.onERC1155Received.selector) {
                    revert(""ERC1155: ERC1155Receiver rejected tokens"");
                }
            } catch Error(string memory reason) {
                revert(reason);
            } catch {
                revert(""ERC1155: transfer to non ERC1155Receiver implementer"");
            }
        }
    }

    function _doSafeBatchTransferAcceptanceCheck(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) private {
        if (to.isContract()) {
            try
                IERC1155Receiver(to).onERC1155BatchReceived(
                    operator,
                    from,
                    ids,
                    amounts,
                    data
                )
            returns (bytes4 response) {
                if (
                    response != IERC1155Receiver.onERC1155BatchReceived.selector
                ) {
                    revert(""ERC1155: ERC1155Receiver rejected tokens"");
                }
            } catch Error(string memory reason) {
                revert(reason);
            } catch {
                revert(""ERC1155: transfer to non ERC1155Receiver implementer"");
            }
        }
    }

    function _asSingletonArray(uint256 element)
        private
        pure
        returns (uint256[] memory)
    {
        uint256[] memory array = new uint256[](1);
        array[0] = element;

        return array;
    }
}",3886
RealWorld_TA_98_IOperateProxy_RealWorld_20240812085609.log,98,IOperateProxy,28140,1918,30058,65.0,0.17906,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

interface IOperateProxy {
    /// @notice emitted when a external contract call is executed
    event FunctionCallExecuted(
        address indexed originalSender,
        bytes returnData
    );

    /// @notice Makes a call to an external contract
    /// @param callee address of the contract to call
    /// @param data the calldata to send to the contract
    function callFunction(address callee, bytes memory data) external;
}",112
RealWorld_TA_98_IOracleRegistry_RealWorld_20240812085831.log,98,IOracleRegistry,59257,2010,61267,71.0,0.336485,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import ""./IQuantConfig.sol"";

/// @title For centrally managing a list of oracle providers
/// @author Rolla
/// @notice oracle provider registry for holding a list of oracle providers and their id
interface IOracleRegistry {
    event AddedOracle(address oracle, uint256 oracleId);

    event ActivatedOracle(address oracle);

    event DeactivatedOracle(address oracle);

    /// @notice Add an oracle to the oracle registry which will generate an id. By default oracles are deactivated
    /// @param _oracle the address of the oracle
    /// @return the id of the oracle
    function addOracle(address _oracle) external returns (uint256);

    /// @notice Deactivate an oracle so no new options can be created with this oracle address.
    /// @param _oracle the oracle to deactivate
    function deactivateOracle(address _oracle) external returns (bool);

    /// @notice Activate an oracle so options can be created with this oracle address.
    /// @param _oracle the oracle to activate
    function activateOracle(address _oracle) external returns (bool);

    /// @notice oracle address => OracleInfo
    function oracleInfo(address) external view returns (bool, uint256);

    /// @notice exhaustive list of oracles in map
    function oracles(uint256) external view returns (address);

    /// @notice quant central configuration
    function config() external view returns (IQuantConfig);

    /// @notice Check if an oracle is registered in the registry
    /// @param _oracle the oracle to check
    function isOracleRegistered(address _oracle) external view returns (bool);

    /// @notice Check if an oracle is active i.e. are we allowed to create options with this oracle
    /// @param _oracle the oracle to check
    function isOracleActive(address _oracle) external view returns (bool);

    /// @notice Get the numeric id of an oracle
    /// @param _oracle the oracle to get the id of
    function getOracleId(address _oracle) external view returns (uint256);

    /// @notice Get total number of oracles in registry
    /// @return the number of oracles in the registry
    function getOraclesLength() external view returns (uint256);
}",483
RealWorld_TA_98_MockChainlinkAggregatorProxy_RealWorld_20240812082101.log,98,MockChainlinkAggregatorProxy,25760,1871,27631,68.0,0.16622,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

contract MockChainlinkAggregatorProxy {
    int256 private _defaultLatestAnswer;

    constructor(int256 defaultLatestAnswer_) {
        _defaultLatestAnswer = defaultLatestAnswer_;
    }

    function latestAnswer() external view returns (int256) {
        return _defaultLatestAnswer;
    }
}",82
RealWorld_TA_98_BasicERC20_RealWorld_20240812082552.log,98,BasicERC20,170507,1845,172352,87.0,0.889435,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/utils/Context.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract BasicERC20 is Context, IERC20 {
    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount)
        public
        virtual
        override
        returns (bool)
    {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount)
        public
        virtual
        override
        returns (bool)
    {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * Requirements:
     *
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(
            sender,
            _msgSender(),
            _allowances[sender][_msgSender()] -= amount
        );
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue)
        public
        virtual
        returns (bool)
    {
        _approve(
            _msgSender(),
            spender,
            _allowances[_msgSender()][spender] + addedValue
        );
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue)
        public
        virtual
        returns (bool)
    {
        _approve(
            _msgSender(),
            spender,
            _allowances[_msgSender()][spender] -= subtractedValue
        );
        return true;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account)
        public
        view
        virtual
        override
        returns (uint256)
    {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender)
        public
        view
        virtual
        override
        returns (uint256)
    {
        return _allowances[owner][spender];
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] -= amount;
        _totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be to transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount // solhint-disable-next-line no-empty-blocks
    ) internal virtual {}
}",1835
RealWorld_TA_98_MockAggregatorProxy_RealWorld_20240812083234.log,98,MockAggregatorProxy,114225,3652,117877,91.0,0.644165,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""../interfaces/external/chainlink/IEACAggregatorProxy.sol"";

/// @title Mock chainlink proxy
/// @author Rolla
contract MockAggregatorProxy is IEACAggregatorProxy {
    struct LatestRoundData {
        uint80 roundId;
        int256 answer;
        uint256 startedAt;
        uint256 updatedAt;
        uint80 answeredInRound;
    }

    mapping(uint256 => uint256) public roundTimestamps;
    mapping(uint256 => int256) public roundIdAnswers;
    LatestRoundData public latestRoundDataValue;
    int256 public latestAnswerValue;
    uint256 public latestTimestampValue;
    uint256 public latestRoundValue;

    function setTimestamp(uint256 _round, uint256 _timestamp) external {
        roundTimestamps[_round] = _timestamp;
    }

    function setRoundIdAnswer(uint256 _roundId, int256 _answer) external {
        roundIdAnswers[_roundId] = _answer;
    }

    function setLatestRoundData(LatestRoundData calldata _latestRoundData)
        external
    {
        latestRoundDataValue = _latestRoundData;
    }

    function setLatestAnswer(int256 _latestAnswer) external {
        latestAnswerValue = _latestAnswer;
    }

    function setLatestTimestamp(uint256 _latestTimestamp) external {
        latestTimestampValue = _latestTimestamp;
    }

    function setLatestRound(uint256 _latestRound) external {
        latestRoundValue = _latestRound;
    }

    // solhint-disable-next-line no-empty-blocks
    function acceptOwnership() external override {
        //noop
    }

    // solhint-disable-next-line no-empty-blocks
    function confirmAggregator(address _aggregator) external override {
        //noop
    }

    // solhint-disable-next-line no-empty-blocks
    function proposeAggregator(address _aggregator) external override {
        //noop
    }

    // solhint-disable-next-line no-empty-blocks
    function setController(address _accessController) external override {
        //noop
    }

    // solhint-disable-next-line no-empty-blocks
    function transferOwnership(address _to) external override {
        //noop
    }

    function getAnswer(uint256 _roundId)
        external
        view
        override
        returns (int256)
    {
        return roundIdAnswers[_roundId];
    }

    function getTimestamp(uint256 _roundId)
        external
        view
        override
        returns (uint256)
    {
        return roundTimestamps[_roundId];
    }

    function latestAnswer() external view override returns (int256) {
        return latestAnswerValue;
    }

    function latestRound() external view override returns (uint256) {
        return latestRoundValue;
    }

    function latestRoundData()
        external
        view
        override
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        return (
            latestRoundDataValue.roundId,
            latestRoundDataValue.answer,
            latestRoundDataValue.startedAt,
            latestRoundDataValue.updatedAt,
            latestRoundDataValue.answeredInRound
        );
    }

    function latestTimestamp() external view override returns (uint256) {
        return latestTimestampValue;
    }

    function accessController() external pure override returns (address) {
        return address(0);
    }

    function aggregator() external pure override returns (address) {
        return address(0);
    }

    function decimals() external pure override returns (uint8) {
        return 0;
    }

    function description() external pure override returns (string memory) {
        return ""..."";
    }

    function getRoundData(uint80)
        external
        pure
        override
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        return (0, 0, 0, 0, 0);
    }

    function owner() external pure override returns (address) {
        return address(0);
    }

    function phaseAggregators(uint16) external pure override returns (address) {
        return address(0);
    }

    function phaseId() external pure override returns (uint16) {
        return 0;
    }

    function proposedAggregator() external pure override returns (address) {
        return address(0);
    }

    function proposedGetRoundData(uint80)
        external
        pure
        override
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        return (0, 0, 0, 0, 0);
    }

    function proposedLatestRoundData()
        external
        pure
        override
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        return (0, 0, 0, 0, 0);
    }

    function version() external pure override returns (uint256) {
        return 0;
    }
}",1122
RealWorld_TA_98_CollateralToken_RealWorld_20240812081432.log,98,CollateralToken,177158,3961,181119,97.0,0.96501,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol"";
import ""../external/openzeppelin/ERC1155.sol"";
import ""../interfaces/ICollateralToken.sol"";

/// @title Tokens representing a Quant user's short positions
/// @author Rolla
/// @notice Can be used by owners to claim their collateral
/// @dev This is a multi-token contract that implements the ERC1155 token standard:
/// https://eips.ethereum.org/EIPS/eip-1155
contract CollateralToken is ERC1155, ICollateralToken, EIP712 {
    /// @dev stores metadata for a CollateralToken with an specific id
    /// @param qTokenAddress address of the corresponding QToken
    /// @param qTokenAsCollateral QToken address of an option used as collateral in a spread
    struct CollateralTokenInfo {
        address qTokenAddress;
        address qTokenAsCollateral;
    }

    /// @inheritdoc ICollateralToken
    IQuantConfig public override quantConfig;

    /// @inheritdoc ICollateralToken
    mapping(uint256 => CollateralTokenInfo) public override idToInfo;

    /// @inheritdoc ICollateralToken
    uint256[] public override collateralTokenIds;

    // Signature nonce per address
    mapping(address => uint256) public nonces;

    // keccak256(
    //     ""metaSetApprovalForAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)""
    // );
    bytes32 private constant _META_APPROVAL_TYPEHASH =
        0xf8f9aaf28cf20cd45b21061d07505fa1da285124284441ea655b9eb837ed89b7;

    /// @notice Initializes a new ERC1155 multi-token contract for representing
    /// users' short positions
    /// @param _quantConfig the address of the Quant system configuration contract
    /// @param _name name for the domain typehash in EIP712 meta transactions
    /// @param _version version for the domain typehash in EIP712 meta transactions
    /// @param uri_ URI for ERC1155 tokens metadata
    constructor(
        address _quantConfig,
        string memory _name,
        string memory _version,
        string memory uri_
    ) ERC1155(uri_) EIP712(_name, _version) {
        require(
            _quantConfig != address(0),
            ""CollateralToken: invalid QuantConfig address""
        );

        quantConfig = IQuantConfig(_quantConfig);
    }

    /// @inheritdoc ICollateralToken
    function createCollateralToken(
        address _qTokenAddress,
        address _qTokenAsCollateral
    ) external override returns (uint256 id) {
        id = getCollateralTokenId(_qTokenAddress, _qTokenAsCollateral);

        require(
            quantConfig.hasRole(
                quantConfig.quantRoles(""COLLATERAL_CREATOR_ROLE""),
                msg.sender
            ),
            ""CollateralToken: Only a collateral creator can create new CollateralTokens""
        );

        require(
            _qTokenAddress != _qTokenAsCollateral,
            ""CollateralToken: Can only create a collateral token with different tokens""
        );

        require(
            idToInfo[id].qTokenAddress == address(0),
            ""CollateralToken: this token has already been created""
        );

        idToInfo[id] = CollateralTokenInfo({
            qTokenAddress: _qTokenAddress,
            qTokenAsCollateral: _qTokenAsCollateral
        });

        collateralTokenIds.push(id);

        emit CollateralTokenCreated(
            _qTokenAddress,
            _qTokenAsCollateral,
            id,
            collateralTokenIds.length
        );
    }

    /// @inheritdoc ICollateralToken
    function mintCollateralToken(
        address recipient,
        uint256 collateralTokenId,
        uint256 amount
    ) external override {
        require(
            quantConfig.hasRole(
                quantConfig.quantRoles(""COLLATERAL_MINTER_ROLE""),
                msg.sender
            ),
            ""CollateralToken: Only a collateral minter can mint CollateralTokens""
        );

        emit CollateralTokenMinted(recipient, collateralTokenId, amount);

        _mint(recipient, collateralTokenId, amount, """");
    }

    /// @inheritdoc ICollateralToken
    function burnCollateralToken(
        address owner,
        uint256 collateralTokenId,
        uint256 amount
    ) external override {
        require(
            quantConfig.hasRole(
                quantConfig.quantRoles(""COLLATERAL_BURNER_ROLE""),
                msg.sender
            ),
            ""CollateralToken: Only a collateral burner can burn CollateralTokens""
        );
        _burn(owner, collateralTokenId, amount);

        emit CollateralTokenBurned(owner, collateralTokenId, amount);
    }

    /// @inheritdoc ICollateralToken
    function mintCollateralTokenBatch(
        address recipient,
        uint256[] calldata ids,
        uint256[] calldata amounts
    ) external override {
        require(
            quantConfig.hasRole(
                quantConfig.quantRoles(""COLLATERAL_MINTER_ROLE""),
                msg.sender
            ),
            ""CollateralToken: Only a collateral minter can mint CollateralTokens""
        );

        uint256 length = ids.length;
        for (uint256 i = 0; i < length; ) {
            emit CollateralTokenMinted(recipient, ids[i], amounts[i]);
            unchecked {
                ++i;
            }
        }

        _mintBatch(recipient, ids, amounts, """");
    }

    /// @inheritdoc ICollateralToken
    function burnCollateralTokenBatch(
        address owner,
        uint256[] calldata ids,
        uint256[] calldata amounts
    ) external override {
        require(
            quantConfig.hasRole(
                quantConfig.quantRoles(""COLLATERAL_BURNER_ROLE""),
                msg.sender
            ),
            ""CollateralToken: Only a collateral burner can burn CollateralTokens""
        );
        _burnBatch(owner, ids, amounts);

        uint256 length = ids.length;
        for (uint256 i = 0; i < length; ) {
            emit CollateralTokenBurned(owner, ids[i], amounts[i]);
            unchecked {
                ++i;
            }
        }
    }

    /// @inheritdoc ICollateralToken
    function metaSetApprovalForAll(
        address owner,
        address operator,
        bool approved,
        uint256 nonce,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external override {
        // solhint-disable-next-line not-rely-on-time
        require(
            block.timestamp <= deadline,
            ""CollateralToken: expired deadline""
        );

        require(nonce == nonces[owner], ""CollateralToken: invalid nonce"");

        bytes32 structHash = keccak256(
            abi.encode(
                _META_APPROVAL_TYPEHASH,
                owner,
                operator,
                approved,
                nonce,
                deadline
            )
        );

        bytes32 hash = _hashTypedDataV4(structHash);

        address signer = ecrecover(hash, v, r, s);
        require(signer == owner, ""CollateralToken: invalid signature"");

        nonces[owner]++;
        _operatorApprovals[owner][operator] = approved;
        emit ApprovalForAll(owner, operator, approved);
    }

    /// @inheritdoc ICollateralToken
    function getCollateralTokensLength()
        external
        view
        override
        returns (uint256)
    {
        return collateralTokenIds.length;
    }

    /// @inheritdoc ICollateralToken
    function getCollateralTokenInfo(uint256 id)
        external
        view
        override
        returns (QTokensDetails memory qTokensDetails)
    {
        CollateralTokenInfo memory info = idToInfo[id];

        require(
            info.qTokenAddress != address(0),
            ""CollateralToken: Invalid id""
        );

        IQToken.QTokenInfo memory shortDetails = IQToken(info.qTokenAddress)
            .getQTokenInfo();

        qTokensDetails.underlyingAsset = shortDetails.underlyingAsset;
        qTokensDetails.strikeAsset = shortDetails.strikeAsset;
        qTokensDetails.oracle = shortDetails.oracle;
        qTokensDetails.shortStrikePrice = shortDetails.strikePrice;
        qTokensDetails.expiryTime = shortDetails.expiryTime;
        qTokensDetails.isCall = shortDetails.isCall;

        if (info.qTokenAsCollateral != address(0)) {
            // the given id is for a CollateralToken representing a spread
            qTokensDetails.longStrikePrice = IQToken(info.qTokenAsCollateral)
                .strikePrice();
        }
    }

    /// @inheritdoc ICollateralToken
    function getCollateralTokenId(address _qToken, address _qTokenAsCollateral)
        public
        pure
        override
        returns (uint256 id)
    {
        id = uint256(keccak256(abi.encodePacked(_qToken, _qTokenAsCollateral)));
    }
}",1929
RealWorld_TA_98_PriceRegistry_RealWorld_20240812085002.log,98,PriceRegistry,81963,3400,85363,83.0,0.477815,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""../interfaces/IQuantConfig.sol"";
import ""../interfaces/IPriceRegistry.sol"";
import ""../libraries/QuantMath.sol"";

/// @title For centrally managing a log of settlement prices, for each option.
/// @author Rolla
contract PriceRegistry is IPriceRegistry {
    using QuantMath for uint256;
    using QuantMath for QuantMath.FixedPointInt;

    /// @inheritdoc IPriceRegistry
    IQuantConfig public override config;

    uint8 private immutable _strikeAssetDecimals;

    /// @dev oracle => asset => expiry => price
    mapping(address => mapping(address => mapping(uint256 => PriceWithDecimals)))
        private _settlementPrices;

    /// @param _config address of quant central configuration
    constructor(address _config, uint8 strikeAssetDecimals_) {
        config = IQuantConfig(_config);
        _strikeAssetDecimals = strikeAssetDecimals_;
    }

    /// @inheritdoc IPriceRegistry
    function setSettlementPrice(
        address _asset,
        uint256 _expiryTimestamp,
        uint256 _settlementPrice,
        uint8 _settlementPriceDecimals
    ) external override {
        require(
            config.hasRole(
                config.quantRoles(""PRICE_SUBMITTER_ROLE""),
                msg.sender
            ),
            ""PriceRegistry: Price submitter is not an oracle""
        );

        uint256 currentSettlementPrice = _settlementPrices[msg.sender][_asset][
            _expiryTimestamp
        ].price;

        require(
            currentSettlementPrice == 0,
            ""PriceRegistry: Settlement price has already been set""
        );

        require(
            _expiryTimestamp <= block.timestamp,
            ""PriceRegistry: Can't set a price for a time in the future""
        );

        _settlementPrices[msg.sender][_asset][
            _expiryTimestamp
        ] = PriceWithDecimals(_settlementPrice, _settlementPriceDecimals);

        emit PriceStored(
            msg.sender,
            _asset,
            _expiryTimestamp,
            _settlementPrice,
            _settlementPriceDecimals
        );
    }

    /// @inheritdoc IPriceRegistry
    function getSettlementPriceWithDecimals(
        address _oracle,
        address _asset,
        uint256 _expiryTimestamp
    )
        external
        view
        override
        returns (PriceWithDecimals memory settlementPrice)
    {
        settlementPrice = _settlementPrices[_oracle][_asset][_expiryTimestamp];
        require(
            settlementPrice.price != 0,
            ""PriceRegistry: No settlement price has been set""
        );
    }

    /// @inheritdoc IPriceRegistry
    function getSettlementPrice(
        address _oracle,
        address _asset,
        uint256 _expiryTimestamp
    ) external view override returns (uint256) {
        PriceWithDecimals memory settlementPrice = _settlementPrices[_oracle][
            _asset
        ][_expiryTimestamp];
        require(
            settlementPrice.price != 0,
            ""PriceRegistry: No settlement price has been set""
        );

        //convert price to the correct number of decimals
        return
            settlementPrice
                .price
                .fromScaledUint(settlementPrice.decimals)
                .toScaledUint(_strikeAssetDecimals, true);
    }

    /// @inheritdoc IPriceRegistry
    function hasSettlementPrice(
        address _oracle,
        address _asset,
        uint256 _expiryTimestamp
    ) public view override returns (bool) {
        return _settlementPrices[_oracle][_asset][_expiryTimestamp].price != 0;
    }
}",758
RealWorld_TA_98_FundsCalculator_RealWorld_20240812084113.log,98,FundsCalculator,258996,3303,262299,101.0,1.36104,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""./QuantMath.sol"";
import ""../options/QToken.sol"";
import ""../interfaces/IPriceRegistry.sol"";

/// @title For calculating collateral requirements and payouts for options and spreads
/// in a fixed point format
/// @author Rolla
library FundsCalculator {
    using QuantMath for uint256;
    using QuantMath for int256;
    using QuantMath for QuantMath.FixedPointInt;

    struct OptionPayoutInput {
        QuantMath.FixedPointInt strikePrice;
        QuantMath.FixedPointInt expiryPrice;
        QuantMath.FixedPointInt amount;
    }

    /// @notice Calculates payout of an option post-expiry from a qToken address
    /// @param _qToken the address of the qToken (option) which is being exercised
    /// @param _amount the amount of the qToken which is being exercised
    /// @param _optionsDecimals option decimals constant. qTokens have 18 decimals
    /// @param _strikeAssetDecimals the amount of decimals the strike asset has
    /// @param _expiryPrice the expiry price of the option with the amount of decimals
    /// @return payoutToken the address of the payout token
    /// @return payoutAmount the amount to be payed out as a fixed point type
    function getPayout(
        address _qToken,
        uint256 _amount,
        uint8 _optionsDecimals,
        uint8 _strikeAssetDecimals,
        IPriceRegistry.PriceWithDecimals memory _expiryPrice
    )
        internal
        view
        returns (
            address payoutToken,
            QuantMath.FixedPointInt memory payoutAmount
        )
    {
        QToken qToken = QToken(_qToken);
        bool isCall = qToken.isCall();

        payoutToken = isCall ? qToken.underlyingAsset() : qToken.strikeAsset();

        payoutAmount = getPayoutAmount(
            isCall,
            qToken.strikePrice(),
            _amount,
            _optionsDecimals,
            _strikeAssetDecimals,
            _expiryPrice
        );
    }

    /// @notice Calculates the collateral required to mint an option or a spread
    /// @param _qTokenToMint the desired qToken
    /// @param _qTokenForCollateral for spreads, this is the address of the qtoken to be used as collateral.
    /// for options, no collateral is provided so the zero address should be passed.
    /// @param _optionsAmount the amount of options/spread to mint
    /// @param _optionsDecimals option decimals constant. qTokens have 18 decimals
    /// @param _underlyingDecimals the amount of decimals the underlying asset has
    /// @param _strikeAssetDecimals the amount of decimals the strike asset has
    /// @return collateral the address of the collateral token required
    /// @return collateralAmount the collateral amount required as a fixed point type
    function getCollateralRequirement(
        address _qTokenToMint,
        address _qTokenForCollateral,
        uint256 _optionsAmount,
        uint8 _optionsDecimals,
        uint8 _underlyingDecimals,
        uint8 _strikeAssetDecimals
    )
        internal
        view
        returns (
            address collateral,
            QuantMath.FixedPointInt memory collateralAmount
        )
    {
        QToken qTokenToMint = QToken(_qTokenToMint);
        uint256 qTokenToMintStrikePrice = qTokenToMint.strikePrice();

        uint256 qTokenForCollateralStrikePrice;

        // check if we're getting the collateral requirement for a spread
        if (_qTokenForCollateral != address(0)) {
            QToken qTokenForCollateral = QToken(_qTokenForCollateral);
            qTokenForCollateralStrikePrice = qTokenForCollateral.strikePrice();

            // Check that expiries match
            require(
                qTokenToMint.expiryTime() == qTokenForCollateral.expiryTime(),
                ""Controller: Can't create spreads from options with different expiries""
            );

            // Check that the underlyings match
            require(
                qTokenToMint.underlyingAsset() ==
                    qTokenForCollateral.underlyingAsset(),
                ""Controller: Can't create spreads from options with different underlying assets""
            );

            // Check that the option types match
            require(
                qTokenToMint.isCall() == qTokenForCollateral.isCall(),
                ""Controller: Can't create spreads from options with different types""
            );

            // Check that the options have a matching oracle
            require(
                qTokenToMint.oracle() == qTokenForCollateral.oracle(),
                ""Controller: Can't create spreads from options with different oracles""
            );
        } else {
            // we're not getting the collateral requirement for a spread
            qTokenForCollateralStrikePrice = 0;
        }

        collateralAmount = getOptionCollateralRequirement(
            qTokenToMintStrikePrice,
            qTokenForCollateralStrikePrice,
            _optionsAmount,
            qTokenToMint.isCall(),
            _optionsDecimals,
            _underlyingDecimals,
            _strikeAssetDecimals
        );

        collateral = qTokenToMint.isCall()
            ? qTokenToMint.underlyingAsset()
            : qTokenToMint.strikeAsset();
    }

    /// @notice Calculates payout of an option post-expiry from qToken attributes
    /// @param _isCall true if the option is a call, false for a put
    /// @param _strikePrice the strike price of the option
    /// @param _amount the amount of options being exercised
    /// @param _optionsDecimals option decimals constant. qTokens have 18 decimals
    /// @param _strikeAssetDecimals the amount of decimals the strike asset has
    /// @param _expiryPrice the expiry price of the option with the amount of decimals
    /// @return payoutAmount the amount to be payed out as a fixed point type
    function getPayoutAmount(
        bool _isCall,
        uint256 _strikePrice,
        uint256 _amount,
        uint8 _optionsDecimals,
        uint8 _strikeAssetDecimals,
        IPriceRegistry.PriceWithDecimals memory _expiryPrice
    ) internal pure returns (QuantMath.FixedPointInt memory payoutAmount) {
        FundsCalculator.OptionPayoutInput memory payoutInput = FundsCalculator
            .OptionPayoutInput(
                _strikePrice.fromScaledUint(_strikeAssetDecimals),
                _expiryPrice.price.fromScaledUint(_expiryPrice.decimals),
                _amount.fromScaledUint(_optionsDecimals)
            );

        if (_isCall) {
            payoutAmount = getPayoutForCall(payoutInput);
        } else {
            payoutAmount = getPayoutForPut(payoutInput);
        }
    }

    /// @notice Calculates payout of a call given option payout inputs of strike, expiry and amount
    /// @param payoutInput strike, expiry and amount as fixed points
    /// @return payoutAmount the amount to be payed out as a fixed point type
    function getPayoutForCall(
        FundsCalculator.OptionPayoutInput memory payoutInput
    ) internal pure returns (QuantMath.FixedPointInt memory payoutAmount) {
        payoutAmount = payoutInput.expiryPrice.isGreaterThan(
            payoutInput.strikePrice
        )
            ? payoutInput
                .expiryPrice
                .sub(payoutInput.strikePrice)
                .mul(payoutInput.amount)
                .div(payoutInput.expiryPrice)
            : int256(0).fromUnscaledInt();
    }

    /// @notice Calculates payout of a put given option payout inputs of strike, expiry and amount
    /// @param payoutInput strike, expiry and amount as fixed points
    /// @return payoutAmount the amount to be payed out as a fixed point type
    function getPayoutForPut(
        FundsCalculator.OptionPayoutInput memory payoutInput
    ) internal pure returns (QuantMath.FixedPointInt memory payoutAmount) {
        payoutAmount = payoutInput.strikePrice.isGreaterThan(
            payoutInput.expiryPrice
        )
            ? (payoutInput.strikePrice.sub(payoutInput.expiryPrice)).mul(
                payoutInput.amount
            )
            : int256(0).fromUnscaledInt();
    }

    /// @notice Calculates the collateral required to mint an option or spread
    /// @param _qTokenToMintStrikePrice the strike price of the qToken being minted 
    /// @param _qTokenForCollateralStrikePrice the strike price of the qToken being used as
    /// collateral in the case of a spread
    /// @param _optionsAmount the amount of options/spread being minted
    /// @param _qTokenToMintIsCall whether or not the token to mint is a call. if a spread,
    /// the qToken as collateral is implicitly also a call. and for minting a put, the 
    /// qToken as collateral is implicitly also a put
    /// @param _optionsDecimals option decimals constant. qTokens have 18 decimals
    /// @param _underlyingDecimals the amount of decimals the underlying asset has
    /// @param _strikeAssetDecimals the amount of decimals the strike asset has
    /// @return collateralAmount the collateral amount required as a fixed point type    
    function getOptionCollateralRequirement(
        uint256 _qTokenToMintStrikePrice,
        uint256 _qTokenForCollateralStrikePrice,
        uint256 _optionsAmount,
        bool _qTokenToMintIsCall,
        uint8 _optionsDecimals,
        uint8 _underlyingDecimals,
        uint8 _strikeAssetDecimals
    ) internal pure returns (QuantMath.FixedPointInt memory collateralAmount) {
        QuantMath.FixedPointInt memory collateralPerOption;
        if (_qTokenToMintIsCall) {
            collateralPerOption = getCallCollateralRequirement(
                _qTokenToMintStrikePrice,
                _qTokenForCollateralStrikePrice,
                _underlyingDecimals,
                _strikeAssetDecimals
            );
        } else {
            collateralPerOption = getPutCollateralRequirement(
                _qTokenToMintStrikePrice,
                _qTokenForCollateralStrikePrice,
                _strikeAssetDecimals
            );
        }

        collateralAmount = _optionsAmount.fromScaledUint(_optionsDecimals).mul(
            collateralPerOption
        );
    }

    /// @notice Calculates the collateral required to mint a single PUT option or PUT spread
    /// @param _qTokenToMintStrikePrice the strike price of the PUT qToken being minted 
    /// @param _qTokenForCollateralStrikePrice the strike price of the PUT qToken being used as
    /// collateral in the case of a spread
    /// @param _strikeAssetDecimals the amount of decimals the strike asset has
    /// @return collateralPerOption the collateral amount required per option as a fixed point type
    function getPutCollateralRequirement(
        uint256 _qTokenToMintStrikePrice,
        uint256 _qTokenForCollateralStrikePrice,
        uint8 _strikeAssetDecimals
    )
        internal
        pure
        returns (QuantMath.FixedPointInt memory collateralPerOption)
    {
        QuantMath.FixedPointInt
            memory mintStrikePrice = _qTokenToMintStrikePrice.fromScaledUint(
                _strikeAssetDecimals
            );
        QuantMath.FixedPointInt
            memory collateralStrikePrice = _qTokenForCollateralStrikePrice
                .fromScaledUint(_strikeAssetDecimals);

        // Initially (non-spread) required collateral is the long strike price
        collateralPerOption = mintStrikePrice;

        if (_qTokenForCollateralStrikePrice > 0) {
            collateralPerOption = mintStrikePrice.isGreaterThan(
                collateralStrikePrice
            )
                ? mintStrikePrice.sub(collateralStrikePrice) // Put Credit Spread
                : int256(0).fromUnscaledInt(); // Put Debit Spread
        }
    }

    /// @notice Calculates the collateral required to mint a single CALL option or CALL spread
    /// @param _qTokenToMintStrikePrice the strike price of the CALL qToken being minted 
    /// @param _qTokenForCollateralStrikePrice the strike price of the CALL qToken being
    /// used as collateral in the case of a spread
    /// @param _underlyingDecimals the amount of decimals the underlying asset has
    /// @param _strikeAssetDecimals the amount of decimals the strike asset has
    /// @return collateralPerOption the collateral amount required per option as a fixed point type
    function getCallCollateralRequirement(
        uint256 _qTokenToMintStrikePrice,
        uint256 _qTokenForCollateralStrikePrice,
        uint8 _underlyingDecimals,
        uint8 _strikeAssetDecimals
    )
        internal
        pure
        returns (QuantMath.FixedPointInt memory collateralPerOption)
    {
        QuantMath.FixedPointInt
            memory mintStrikePrice = _qTokenToMintStrikePrice.fromScaledUint(
                _strikeAssetDecimals
            );
        QuantMath.FixedPointInt
            memory collateralStrikePrice = _qTokenForCollateralStrikePrice
                .fromScaledUint(_strikeAssetDecimals);

        // Initially (non-spread) required collateral is the long strike price
        collateralPerOption = (10**_underlyingDecimals).fromScaledUint(
            _underlyingDecimals
        );

        if (_qTokenForCollateralStrikePrice > 0) {
            collateralPerOption = mintStrikePrice.isGreaterThanOrEqual(
                collateralStrikePrice
            )
                ? int256(0).fromUnscaledInt() // Call Debit Spread
                : (collateralStrikePrice.sub(mintStrikePrice)).div(
                    collateralStrikePrice
                ); // Call Credit Spread
        }
    }
}",2959
RealWorld_TA_98_Actions_RealWorld_20240812083613.log,98,Actions,91014,1661,92675,66.0,0.48829,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

enum ActionType {
    MintOption,
    MintSpread,
    Exercise,
    ClaimCollateral,
    Neutralize,
    QTokenPermit,
    CollateralTokenApproval,
    Call
}

struct ActionArgs {
    ActionType actionType; //type of action to perform
    address qToken; //qToken to exercise or mint
    address secondaryAddress; //secondary address depending on the action type
    address receiver; //receiving address of minting or function call
    uint256 amount; //amount of qTokens or collateral tokens
    uint256 collateralTokenId; //collateral token id for claiming collateral and neutralizing positions
    bytes data; //extra data for function calls
}

/// @title Library to parse arguments for actions to be executed by the Controller
/// @author Rolla
library Actions {
    function parseMintOptionArgs(ActionArgs memory _args)
        internal
        pure
        returns (
            address to,
            address qToken,
            uint256 amount
        )
    {
        require(_args.amount != 0, ""Actions: cannot mint 0 options"");

        to = _args.receiver;
        qToken = _args.qToken;
        amount = _args.amount;
    }

    function parseMintSpreadArgs(ActionArgs memory _args)
        internal
        pure
        returns (
            address qTokenToMint,
            address qTokenForCollateral,
            uint256 amount
        )
    {
        require(
            _args.amount != 0,
            ""Actions: cannot mint 0 options from spreads""
        );

        qTokenToMint = _args.qToken;
        qTokenForCollateral = _args.secondaryAddress;
        amount = _args.amount;
    }

    function parseExerciseArgs(ActionArgs memory _args)
        internal
        pure
        returns (address qToken, uint256 amount)
    {
        qToken = _args.qToken;
        amount = _args.amount;
    }

    function parseClaimCollateralArgs(ActionArgs memory _args)
        internal
        pure
        returns (uint256 collateralTokenId, uint256 amount)
    {
        collateralTokenId = _args.collateralTokenId;
        amount = _args.amount;
    }

    function parseNeutralizeArgs(ActionArgs memory _args)
        internal
        pure
        returns (uint256 collateralTokenId, uint256 amount)
    {
        collateralTokenId = _args.collateralTokenId;
        amount = _args.amount;
    }

    function parseQTokenPermitArgs(ActionArgs memory _args)
        internal
        pure
        returns (
            address qToken,
            address owner,
            address spender,
            uint256 value,
            uint256 deadline,
            uint8 v,
            bytes32 r,
            bytes32 s
        )
    {
        (v, r, s) = abi.decode(_args.data, (uint8, bytes32, bytes32));

        qToken = _args.qToken;
        owner = _args.secondaryAddress;
        spender = _args.receiver;
        value = _args.amount;
        deadline = _args.collateralTokenId;
    }

    function parseCollateralTokenApprovalArgs(ActionArgs memory _args)
        internal
        pure
        returns (
            address owner,
            address operator,
            bool approved,
            uint256 nonce,
            uint256 deadline,
            uint8 v,
            bytes32 r,
            bytes32 s
        )
    {
        (approved, v, r, s) = abi.decode(
            _args.data,
            (bool, uint8, bytes32, bytes32)
        );

        owner = _args.secondaryAddress;
        operator = _args.receiver;
        nonce = _args.amount;
        deadline = _args.collateralTokenId;
    }

    function parseCallArgs(ActionArgs memory _args)
        internal
        pure
        returns (address callee, bytes memory data)
    {
        require(
            _args.receiver != address(0),
            ""Actions: cannot make calls to the zero address""
        );

        callee = _args.receiver;
        data = _args.data;
    }
}",871
RealWorld_TA_98_IProviderOracleManager_RealWorld_20240812091041.log,98,IProviderOracleManager,67533,2611,70144,73.0,0.389885,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import ""./IQuantConfig.sol"";

/// @title Oracle manager for holding asset addresses and their oracle addresses for a single provider
/// @author Rolla
/// @notice Once an oracle is added for an asset it can't be changed!
interface IProviderOracleManager {
    event OracleAdded(address asset, address oracle);

    /// @notice Add an asset to the oracle manager with its corresponding oracle address
    /// @dev Once this is set for an asset, it can't be changed or removed
    /// @param _asset the address of the asset token we are adding the oracle for
    /// @param _oracle the address of the oracle
    function addAssetOracle(address _asset, address _oracle) external;

    /// @notice Get the expiry price from oracle and store it in the price registry so we have a copy
    /// @param _asset asset to set price of
    /// @param _expiryTimestamp timestamp of price
    /// @param _calldata additional parameter that the method may need to execute
    function setExpiryPriceInRegistry(
        address _asset,
        uint256 _expiryTimestamp,
        bytes memory _calldata
    ) external;

    /// @notice quant central configuration
    function config() external view returns (IQuantConfig);

    /// @notice asset address => oracle address
    function assetOracles(address) external view returns (address);

    /// @notice exhaustive list of asset addresses in map
    function assets(uint256) external view returns (address);

    /// @notice Get the oracle address associated with an asset
    /// @param _asset asset to get price of
    function getAssetOracle(address _asset) external view returns (address);

    /// @notice Get the total number of assets managed by the oracle manager
    /// @return total number of assets managed by the oracle manager
    function getAssetsLength() external view returns (uint256);

    /// @notice Function that should be overridden which should return the current price of an asset from the provider
    /// @param _asset the address of the asset token we want the price for
    /// @return the current price of the asset
    function getCurrentPrice(address _asset) external view returns (uint256);

    /// @notice Checks if the option is valid for the oracle manager with the given parameters
    /// @param _underlyingAsset the address of the underlying asset
    /// @param _expiryTime the expiry timestamp of the option
    /// @param _strikePrice the strike price of the option
    function isValidOption(
        address _underlyingAsset,
        uint256 _expiryTime,
        uint256 _strikePrice
    ) external view returns (bool);
}",576
RealWorld_TA_98_IOracleFallbackMechanism_RealWorld_20240812090700.log,98,IOracleFallbackMechanism,28404,2177,30581,76.0,0.18556,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

interface IOracleFallbackMechanism {
    /// @notice Fallback mechanism to submit price to the registry (should enforce a locking period)
    /// @param _asset asset to set price of
    /// @param _expiryTimestamp timestamp of price
    /// @param _price price to submit
    function setExpiryPriceInRegistryFallback(
        address _asset,
        uint256 _expiryTimestamp,
        uint256 _price
    ) external;
}",114
RealWorld_TA_98_QToken_RealWorld_20240812081013.log,98,QToken,110501,3049,113550,80.0,0.613485,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""../pricing/PriceRegistry.sol"";
import ""../interfaces/IQuantConfig.sol"";
import ""../interfaces/IQToken.sol"";
import ""../libraries/ProtocolValue.sol"";
import ""../libraries/OptionsUtils.sol"";
import ""../libraries/QuantMath.sol"";
import ""./QTokenStringUtils.sol"";

/// @title Token that represents a user's long position
/// @author Rolla
/// @notice Can be used by owners to exercise their options
/// @dev Every option long position is an ERC20 token: https://eips.ethereum.org/EIPS/eip-20
contract QToken is ERC20Permit, QTokenStringUtils, IQToken {
    using QuantMath for uint256;

    /// @inheritdoc IQToken
    IQuantConfig public override quantConfig;

    /// @inheritdoc IQToken
    address public override underlyingAsset;

    /// @inheritdoc IQToken
    address public override strikeAsset;

    /// @inheritdoc IQToken
    address public override oracle;

    /// @inheritdoc IQToken
    uint256 public override strikePrice;

    /// @inheritdoc IQToken
    uint256 public override expiryTime;

    /// @inheritdoc IQToken
    bool public override isCall;

    /// @notice Configures the parameters of a new option token
    /// @param _quantConfig the address of the Quant system configuration contract
    /// @param _underlyingAsset asset that the option references
    /// @param _strikeAsset asset that the strike is denominated in
    /// @param _oracle price oracle for the underlying
    /// @param _strikePrice strike price with as many decimals in the strike asset
    /// @param _expiryTime expiration timestamp as a unix timestamp
    /// @param _isCall true if it's a call option, false if it's a put option
    constructor(
        address _quantConfig,
        address _underlyingAsset,
        address _strikeAsset,
        address _oracle,
        uint256 _strikePrice,
        uint256 _expiryTime,
        bool _isCall
    )
        ERC20(
            _qTokenName(
                _quantConfig,
                _underlyingAsset,
                _strikeAsset,
                _strikePrice,
                _expiryTime,
                _isCall
            ),
            _qTokenSymbol(
                _quantConfig,
                _underlyingAsset,
                _strikeAsset,
                _strikePrice,
                _expiryTime,
                _isCall
            )
        )
        ERC20Permit(
            _qTokenName(
                _quantConfig,
                _underlyingAsset,
                _strikeAsset,
                _strikePrice,
                _expiryTime,
                _isCall
            )
        )
    {
        require(
            _quantConfig != address(0),
            ""QToken: invalid QuantConfig address""
        );
        require(
            _underlyingAsset != address(0),
            ""QToken: invalid underlying asset address""
        );
        require(
            _strikeAsset != address(0),
            ""QToken: invalid strike asset address""
        );
        require(_oracle != address(0), ""QToken: invalid oracle address"");

        quantConfig = IQuantConfig(_quantConfig);
        underlyingAsset = _underlyingAsset;
        strikeAsset = _strikeAsset;
        oracle = _oracle;
        strikePrice = _strikePrice;
        expiryTime = _expiryTime;
        isCall = _isCall;
    }

    /// @inheritdoc IQToken
    function mint(address account, uint256 amount) external override {
        require(
            quantConfig.hasRole(
                quantConfig.quantRoles(""OPTIONS_MINTER_ROLE""),
                msg.sender
            ),
            ""QToken: Only an options minter can mint QTokens""
        );
        _mint(account, amount);
        emit QTokenMinted(account, amount);
    }

    /// @inheritdoc IQToken
    function burn(address account, uint256 amount) external override {
        require(
            quantConfig.hasRole(
                quantConfig.quantRoles(""OPTIONS_BURNER_ROLE""),
                msg.sender
            ),
            ""QToken: Only an options burner can burn QTokens""
        );
        _burn(account, amount);
        emit QTokenBurned(account, amount);
    }

    /// @inheritdoc IQToken
    function getOptionPriceStatus()
        external
        view
        override
        returns (PriceStatus)
    {
        if (block.timestamp > expiryTime) {
            PriceRegistry priceRegistry = PriceRegistry(
                quantConfig.protocolAddresses(
                    ProtocolValue.encode(""priceRegistry"")
                )
            );

            if (
                priceRegistry.hasSettlementPrice(
                    oracle,
                    underlyingAsset,
                    expiryTime
                )
            ) {
                return PriceStatus.SETTLED;
            }
            return PriceStatus.AWAITING_SETTLEMENT_PRICE;
        } else {
            return PriceStatus.ACTIVE;
        }
    }

    /// @inheritdoc IQToken
    function getQTokenInfo()
        external
        view
        override
        returns (QTokenInfo memory)
    {
        return OptionsUtils.getQTokenInfo(address(this));
    }
}",1099
RealWorld_TA_98_QuantConfigV2_RealWorld_20240812083004.log,98,QuantConfigV2,111267,3032,114299,80.0,0.616975,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""../libraries/ProtocolValue.sol"";
import ""../interfaces/ITimelockedConfig.sol"";

/// @title A central config for the quant system. Also acts as a central access control manager.
/// @author Rolla
/// @notice For storing constants, variables and allowing them to be changed by the admin (governance)
/// @dev This should be used as a central access control manager which other contracts use to check permissions
contract QuantConfigV2 is
    AccessControlUpgradeable,
    OwnableUpgradeable,
    ITimelockedConfig
{
    address payable public override timelockController;

    mapping(bytes32 => address) public override protocolAddresses;
    bytes32[] public override configuredProtocolAddresses;

    mapping(bytes32 => uint256) public override protocolUints256;
    bytes32[] public override configuredProtocolUints256;

    mapping(bytes32 => bool) public override protocolBooleans;
    bytes32[] public override configuredProtocolBooleans;

    mapping(string => bytes32) public override quantRoles;
    bytes32[] public override configuredQuantRoles;

    mapping(bytes32 => mapping(ProtocolValue.Type => bool))
        public
        override isProtocolValueSet;

    uint256 public newV2StateVariable;

    function setProtocolAddress(bytes32 _protocolAddress, address _newValue)
        external
        override
        onlyOwner
    {
        require(
            _protocolAddress != ProtocolValue.encode(""priceRegistry"") ||
                !protocolBooleans[ProtocolValue.encode(""isPriceRegistrySet"")],
            ""QuantConfig: priceRegistry can only be set once""
        );

        protocolAddresses[_protocolAddress] = _newValue;
        configuredProtocolAddresses.push(_protocolAddress);
    }

    function setProtocolUint256(bytes32 _protocolUint256, uint256 _newValue)
        external
        override
        onlyOwner
    {
        protocolUints256[_protocolUint256] = _newValue;
        configuredProtocolUints256.push(_protocolUint256);
    }

    function setProtocolBoolean(bytes32 _protocolBoolean, bool _newValue)
        external
        override
        onlyOwner
    {
        require(
            _protocolBoolean != ProtocolValue.encode(""isPriceRegistrySet"") ||
                !protocolBooleans[ProtocolValue.encode(""isPriceRegistrySet"")],
            ""QuantConfig: can only change isPriceRegistrySet once""
        );

        protocolBooleans[_protocolBoolean] = _newValue;
        configuredProtocolBooleans.push(_protocolBoolean);
    }

    function setProtocolRole(string calldata _protocolRole, address _roleAdmin)
        external
        override
        onlyOwner
    {
        bytes32 role = keccak256(abi.encodePacked(_protocolRole));
        grantRole(role, _roleAdmin);
        quantRoles[_protocolRole] = role;
        configuredQuantRoles.push(role);
    }

    function setRoleAdmin(bytes32 role, bytes32 adminRole)
        external
        override
        onlyOwner
    {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not admin"");
        _setRoleAdmin(role, adminRole);
    }

    function protocolAddressesLength()
        external
        view
        override
        returns (uint256)
    {
        return configuredProtocolAddresses.length;
    }

    function protocolUints256Length() external view override returns (uint256) {
        return configuredProtocolUints256.length;
    }

    function protocolBooleansLength() external view override returns (uint256) {
        return configuredProtocolBooleans.length;
    }

    function quantRolesLength() external view override returns (uint256) {
        return configuredQuantRoles.length;
    }

    /// @notice Initializes the system roles and assign them to the given TimelockController address
    /// @param _timelockController Address of the TimelockController to receive the system roles
    /// @dev The TimelockController should have a Quant multisig as its sole proposer
    function initialize(address payable _timelockController)
        public
        override
        initializer
    {
        __AccessControl_init();
        __Ownable_init_unchained();
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(DEFAULT_ADMIN_ROLE, _timelockController);
        // // On deployment, this role should be transferd to the OptionsFactory as its only admin
        bytes32 optionsControllerRole = keccak256(""OPTIONS_CONTROLLER_ROLE"");
        // quantRoles[""OPTIONS_CONTROLLER_ROLE""] = optionsControllerRole;
        _setupRole(optionsControllerRole, _timelockController);
        _setupRole(optionsControllerRole, _msgSender());
        // quantRoles.push(optionsControllerRole);
        bytes32 oracleManagerRole = keccak256(""ORACLE_MANAGER_ROLE"");
        // quantRoles[""ORACLE_MANAGER_ROLE""] = oracleManagerRole;
        _setupRole(oracleManagerRole, _timelockController);
        _setupRole(oracleManagerRole, _msgSender());
        timelockController = _timelockController;
    }
}",1089
RealWorld_TA_98_QTokenStringUtils_RealWorld_20240812081136.log,98,QTokenStringUtils,181222,2340,183562,85.0,0.95291,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/utils/Strings.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@quant-finance/solidity-datetime/contracts/DateTime.sol"";
import ""../interfaces/IAssetsRegistry.sol"";
import ""../interfaces/IQuantConfig.sol"";
import ""../libraries/ProtocolValue.sol"";

abstract contract QTokenStringUtils {
    /// @notice get the ERC20 token symbol from the AssetsRegistry
    /// @dev the asset is assumed to be in the AssetsRegistry since QTokens
    /// must be created through the OptionsFactory, which performs that check
    /// @param _quantConfig address of the Quant system configuration contract
    /// @param _asset address of the asset in the AssetsRegistry
    /// @return assetSymbol string stored as the ERC20 token symbol
    function _assetSymbol(address _quantConfig, address _asset)
        internal
        view
        virtual
        returns (string memory assetSymbol)
    {
        (, assetSymbol, ) = IAssetsRegistry(
            IQuantConfig(_quantConfig).protocolAddresses(
                ProtocolValue.encode(""assetsRegistry"")
            )
        ).assetProperties(_asset);
    }

    /// @notice generates the name for an option
    /// @param _quantConfig address of the Quant system configuration contract
    /// @param _underlyingAsset asset that the option references
    /// @param _strikePrice strike price with as many decimals in the strike asset
    /// @param _expiryTime expiration timestamp as a unix timestamp
    /// @param _isCall true if it's a call option, false if it's a put option
    /// @return tokenName name string for the QToken
    function _qTokenName(
        address _quantConfig,
        address _underlyingAsset,
        address _strikeAsset,
        uint256 _strikePrice,
        uint256 _expiryTime,
        bool _isCall
    ) internal view virtual returns (string memory tokenName) {
        string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);
        string memory displayStrikePrice = _displayedStrikePrice(
            _strikePrice,
            _strikeAsset
        );

        // convert the expiry to a readable string
        (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(
            _expiryTime
        );

        // get option type string
        (, string memory typeFull) = _getOptionType(_isCall);

        // get option month string
        (, string memory monthFull) = _getMonth(month);

        /// concatenated name string
        tokenName = string(
            abi.encodePacked(
                ""ROLLA"",
                "" "",
                underlying,
                "" "",
                _uintToChars(day),
                ""-"",
                monthFull,
                ""-"",
                Strings.toString(year),
                "" "",
                displayStrikePrice,
                "" "",
                typeFull
            )
        );
    }

    /// @notice generates the symbol for an option
    /// @param _underlyingAsset asset that the option references
    /// @param _quantConfig address of the Quant system configuration contract
    /// @param _strikePrice strike price with as many decimals in the strike asset
    /// @param _expiryTime expiration timestamp as a unix timestamp
    /// @param _isCall true if it's a call option, false if it's a put option
    /// @return tokenSymbol symbol string for the QToken
    function _qTokenSymbol(
        address _quantConfig,
        address _underlyingAsset,
        address _strikeAsset,
        uint256 _strikePrice,
        uint256 _expiryTime,
        bool _isCall
    ) internal view virtual returns (string memory tokenSymbol) {
        string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);
        string memory displayStrikePrice = _displayedStrikePrice(
            _strikePrice,
            _strikeAsset
        );

        // convert the expiry to a readable string
        (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(
            _expiryTime
        );

        // get option type string
        (string memory typeSymbol, ) = _getOptionType(_isCall);

        // get option month string
        (string memory monthSymbol, ) = _getMonth(month);

        /// concatenated symbol string
        tokenSymbol = string(
            abi.encodePacked(
                ""ROLLA"",
                ""-"",
                underlying,
                ""-"",
                _uintToChars(day),
                monthSymbol,
                _uintToChars(year),
                ""-"",
                displayStrikePrice,
                ""-"",
                typeSymbol
            )
        );
    }

    /// @dev convert the option strike price scaled to a human readable value
    /// @param _strikePrice the option strike price scaled by 1e20
    /// @return strike price string
    function _displayedStrikePrice(uint256 _strikePrice, address _strikeAsset)
        internal
        view
        virtual
        returns (string memory)
    {
        uint256 strikePriceDigits = ERC20(_strikeAsset).decimals();
        uint256 strikePriceScale = 10**strikePriceDigits;
        uint256 remainder = _strikePrice % strikePriceScale;
        uint256 quotient = _strikePrice / strikePriceScale;
        string memory quotientStr = Strings.toString(quotient);

        if (remainder == 0) {
            return quotientStr;
        }

        uint256 trailingZeroes;
        while (remainder % 10 == 0) {
            remainder /= 10;
            trailingZeroes++;
        }

        // pad the number with ""1 + starting zeroes""
        remainder += 10**(strikePriceDigits - trailingZeroes);

        string memory tmp = Strings.toString(remainder);
        tmp = _slice(tmp, 1, (1 + strikePriceDigits) - trailingZeroes);

        return string(abi.encodePacked(quotientStr, ""."", tmp));
    }

    /// @dev get the string representation of the option type
    /// @return a 1 character representation of the option type
    /// @return a full length string of the option type
    function _getOptionType(bool _isCall)
        internal
        pure
        virtual
        returns (string memory, string memory)
    {
        return _isCall ? (""C"", ""Call"") : (""P"", ""Put"");
    }

    /// @dev get the representation of a number using 2 characters, adding a leading 0 if it's one digit,
    /// and two trailing digits if it's a 3 digit number
    /// @return 2 characters that correspond to a number
    function _uintToChars(uint256 _number)
        internal
        pure
        virtual
        returns (string memory)
    {
        if (_number > 99) {
            _number %= 100;
        }

        string memory str = Strings.toString(_number);

        if (_number < 10) {
            return string(abi.encodePacked(""0"", str));
        }

        return str;
    }

    /// @dev cut a string into string[start:end]
    /// @param _s string to cut
    /// @param _start the starting index
    /// @param _end the ending index (not inclusive)
    /// @return the indexed string
    function _slice(
        string memory _s,
        uint256 _start,
        uint256 _end
    ) internal pure virtual returns (string memory) {
        uint256 range = _end - _start;
        bytes memory slice = new bytes(range);
        for (uint256 i = 0; i < range; ) {
            slice[i] = bytes(_s)[_start + 1];
            unchecked {
                ++i;
            }
        }

        return string(slice);
    }

    /// @dev get the string representations of a month
    /// @return a 3 character representation
    /// @return a full length string representation
    function _getMonth(uint256 _month)
        internal
        pure
        virtual
        returns (string memory, string memory)
    {
        if (_month == 1) {
            return (""JAN"", ""January"");
        } else if (_month == 2) {
            return (""FEB"", ""February"");
        } else if (_month == 3) {
            return (""MAR"", ""March"");
        } else if (_month == 4) {
            return (""APR"", ""April"");
        } else if (_month == 5) {
            return (""MAY"", ""May"");
        } else if (_month == 6) {
            return (""JUN"", ""June"");
        } else if (_month == 7) {
            return (""JUL"", ""July"");
        } else if (_month == 8) {
            return (""AUG"", ""August"");
        } else if (_month == 9) {
            return (""SEP"", ""September"");
        } else if (_month == 10) {
            return (""OCT"", ""October"");
        } else if (_month == 11) {
            return (""NOV"", ""November"");
        } else {
            return (""DEC"", ""December"");
        }
    }
}",1938
RealWorld_TA_98_ChainlinkOracleManager_RealWorld_20240812085416.log,98,ChainlinkOracleManager,193088,5545,198633,110.0,1.07634,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""../../interfaces/external/chainlink/IEACAggregatorProxy.sol"";
import ""../PriceRegistry.sol"";
import ""./ProviderOracleManager.sol"";
import ""../../libraries/ProtocolValue.sol"";
import ""../../libraries/QuantMath.sol"";
import ""../../interfaces/IChainlinkOracleManager.sol"";

/// @title For managing chainlink oracles for assets and submitting chainlink prices to the registry
/// @author Rolla
/// @notice Once an oracle is added for an asset it can't be changed!
contract ChainlinkOracleManager is
    ProviderOracleManager,
    IChainlinkOracleManager
{
    using QuantMath for uint256;
    using QuantMath for QuantMath.FixedPointInt;

    struct BinarySearchResult {
        uint80 firstRound;
        uint80 lastRound;
        uint80 firstRoundProxy;
        uint80 lastRoundProxy;
    }

    uint256 public immutable override fallbackPeriodSeconds;
    uint8 public immutable override strikeAssetDecimals;
    uint8 public constant CHAINLINK_ORACLE_DECIMALS = 8;

    /// @param _config address of quant central configuration
    /// @param _fallbackPeriodSeconds amount of seconds before fallback price submitter can submit
    constructor(
        address _config,
        uint8 _strikeAssetDecimals,
        uint256 _fallbackPeriodSeconds
    ) ProviderOracleManager(_config) {
        fallbackPeriodSeconds = _fallbackPeriodSeconds;
        strikeAssetDecimals = _strikeAssetDecimals;
    }

    /// @inheritdoc IChainlinkOracleManager
    function setExpiryPriceInRegistryByRound(
        address _asset,
        uint256 _expiryTimestamp,
        uint256 _roundIdAfterExpiry
    ) external override {
        _setExpiryPriceInRegistryByRound(
            _asset,
            _expiryTimestamp,
            _roundIdAfterExpiry
        );
    }

    /// @inheritdoc IProviderOracleManager
    function setExpiryPriceInRegistry(
        address _asset,
        uint256 _expiryTimestamp,
        bytes memory
    ) external override(ProviderOracleManager, IProviderOracleManager) {
        //search and get round
        uint80 roundAfterExpiry = searchRoundToSubmit(_asset, _expiryTimestamp);

        //submit price to registry
        _setExpiryPriceInRegistryByRound(
            _asset,
            _expiryTimestamp,
            roundAfterExpiry
        );
    }

    /// @inheritdoc IOracleFallbackMechanism
    function setExpiryPriceInRegistryFallback(
        address _asset,
        uint256 _expiryTimestamp,
        uint256 _price
    ) external override {
        require(
            config.hasRole(
                config.quantRoles(""FALLBACK_PRICE_ROLE""),
                msg.sender
            ),
            ""ChainlinkOracleManager: Only the fallback price submitter can submit a fallback price""
        );

        require(
            block.timestamp >= _expiryTimestamp + fallbackPeriodSeconds,
            ""ChainlinkOracleManager: The fallback price period has not passed since the timestamp""
        );

        emit PriceRegistrySubmission(
            _asset,
            _expiryTimestamp,
            _price,
            0,
            msg.sender,
            true
        );

        PriceRegistry(
            config.protocolAddresses(ProtocolValue.encode(""priceRegistry""))
        ).setSettlementPrice(
                _asset,
                _expiryTimestamp,
                _price,
                CHAINLINK_ORACLE_DECIMALS
            );
    }

    /// @inheritdoc IProviderOracleManager
    function getCurrentPrice(address _asset)
        external
        view
        override(ProviderOracleManager, IProviderOracleManager)
        returns (uint256)
    {
        address assetOracle = getAssetOracle(_asset);
        IEACAggregatorProxy aggregator = IEACAggregatorProxy(assetOracle);
        int256 answer = aggregator.latestAnswer();
        require(
            answer > 0,
            ""ChainlinkOracleManager: No pricing data available""
        );

        return
            uint256(answer)
                .fromScaledUint(CHAINLINK_ORACLE_DECIMALS)
                .toScaledUint(strikeAssetDecimals, true);
    }

    /// @inheritdoc IProviderOracleManager
    function isValidOption(
        address,
        uint256,
        uint256
    )
        public
        view
        virtual
        override(ProviderOracleManager, IProviderOracleManager)
        returns (bool)
    {
        return true;
    }

    /// @inheritdoc IChainlinkOracleManager
    function searchRoundToSubmit(address _asset, uint256 _expiryTimestamp)
        public
        view
        override
        returns (uint80)
    {
        address assetOracle = getAssetOracle(_asset);

        IEACAggregatorProxy aggregator = IEACAggregatorProxy(assetOracle);

        require(
            aggregator.latestTimestamp() > _expiryTimestamp,
            ""ChainlinkOracleManager: The latest round timestamp is not after the expiry timestamp""
        );

        uint80 latestRound = uint80(aggregator.latestRound());

        uint16 phaseOffset = 64;
        uint16 phaseId = uint16(latestRound >> phaseOffset);

        uint80 lowestPossibleRound = uint80((phaseId << phaseOffset) | 1);
        uint80 highestPossibleRound = latestRound;
        uint80 firstId = lowestPossibleRound;
        uint80 lastId = highestPossibleRound;

        require(
            lastId > firstId,
            ""ChainlinkOracleManager: Not enough rounds to find round after""
        );

        //binary search until we find two values our desired timestamp lies between
        while (lastId - firstId != 1) {
            BinarySearchResult memory result = _binarySearchStep(
                aggregator,
                _expiryTimestamp,
                lowestPossibleRound,
                highestPossibleRound
            );

            lowestPossibleRound = result.firstRound;
            highestPossibleRound = result.lastRound;
            firstId = result.firstRoundProxy;
            lastId = result.lastRoundProxy;
        }

        return highestPossibleRound; //return round above
    }

    /// @notice Get the expiry price from chainlink asset oracle and store it in the price registry
    /// @param _asset asset to set price of
    /// @param _expiryTimestamp timestamp of price
    /// @param _roundIdAfterExpiry the chainlink round id immediately after the option expired
    function _setExpiryPriceInRegistryByRound(
        address _asset,
        uint256 _expiryTimestamp,
        uint256 _roundIdAfterExpiry
    ) internal {
        address assetOracle = getAssetOracle(_asset);

        IEACAggregatorProxy aggregator = IEACAggregatorProxy(assetOracle);

        require(
            aggregator.getTimestamp(uint256(_roundIdAfterExpiry)) >
                _expiryTimestamp,
            ""ChainlinkOracleManager: The round posted is not after the expiry timestamp""
        );

        uint16 phaseOffset = 64;
        uint16 phaseId = uint16(_roundIdAfterExpiry >> phaseOffset);

        uint64 expiryRound = uint64(_roundIdAfterExpiry) - 1;
        uint80 expiryRoundId = uint80(
            (uint256(phaseId) << phaseOffset) | expiryRound
        );

        require(
            aggregator.getTimestamp(uint256(expiryRoundId)) <= _expiryTimestamp,
            ""ChainlinkOracleManager: Expiry round prior to the one posted is after the expiry timestamp""
        );

        (uint256 price, uint256 roundId) = _getExpiryPrice(
            aggregator,
            _expiryTimestamp,
            _roundIdAfterExpiry,
            expiryRoundId
        );

        emit PriceRegistrySubmission(
            _asset,
            _expiryTimestamp,
            price,
            roundId,
            msg.sender,
            false
        );

        PriceRegistry(
            config.protocolAddresses(ProtocolValue.encode(""priceRegistry""))
        ).setSettlementPrice(
                _asset,
                _expiryTimestamp,
                price,
                CHAINLINK_ORACLE_DECIMALS
            );
    }

    function _getExpiryPrice(
        IEACAggregatorProxy aggregator,
        uint256,
        uint256,
        uint256 _expiryRoundId
    ) internal view virtual returns (uint256, uint256) {
        return (uint256(aggregator.getAnswer(_expiryRoundId)), _expiryRoundId);
    }

    /// @notice Performs a binary search step between the first and last round in the aggregator proxy
    /// @param _expiryTimestamp expiry timestamp to find the price at
    /// @param _firstRoundProxy the lowest possible round for the timestamp
    /// @param _lastRoundProxy the highest possible round for the timestamp
    /// @return a binary search result object representing lowest and highest possible rounds of the timestamp
    function _binarySearchStep(
        IEACAggregatorProxy aggregator,
        uint256 _expiryTimestamp,
        uint80 _firstRoundProxy,
        uint80 _lastRoundProxy
    ) internal view returns (BinarySearchResult memory) {
        uint16 phaseOffset = 64;
        uint16 phaseId = uint16(_lastRoundProxy >> phaseOffset);

        uint64 lastRoundId = uint64(_lastRoundProxy);
        uint64 firstRoundId = uint64(_firstRoundProxy);

        uint80 roundToCheck = uint80(
            (uint256(firstRoundId) + uint256(lastRoundId)) / 2
        );
        uint80 roundToCheckProxy = uint80(
            (uint256(phaseId) << phaseOffset) | roundToCheck
        );

        uint256 roundToCheckTimestamp = aggregator.getTimestamp(
            uint256(roundToCheckProxy)
        );

        if (roundToCheckTimestamp <= _expiryTimestamp) {
            return
                BinarySearchResult(
                    roundToCheckProxy,
                    _lastRoundProxy,
                    roundToCheck,
                    lastRoundId
                );
        }

        return
            BinarySearchResult(
                _firstRoundProxy,
                roundToCheckProxy,
                firstRoundId,
                roundToCheck
            );
    }
}",2072
RealWorld_TA_98_SignedConverterTester_RealWorld_20240812082441.log,98,SignedConverterTester,27603,1682,29285,69.0,0.171655,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""../libraries/SignedConverter.sol"";

contract SignedConverterTester {
    using SignedConverter for int256;
    using SignedConverter for uint256;

    function testFromInt(int256 a) external pure returns (uint256) {
        return SignedConverter.intToUint(a);
    }

    function testFromUint(uint256 a) external pure returns (int256) {
        return SignedConverter.uintToInt(a);
    }
}",106
RealWorld_TA_98_ControllerV2_RealWorld_20240812083407.log,98,ControllerV2,267867,5505,273372,123.0,1.449435,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""../QuantConfig.sol"";
import ""../utils/EIP712MetaTransaction.sol"";
import ""../utils/OperateProxy.sol"";
import ""../interfaces/IQToken.sol"";
import ""../interfaces/IOracleRegistry.sol"";
import ""../interfaces/ICollateralToken.sol"";
import ""../interfaces/IController.sol"";
import ""../interfaces/IOperateProxy.sol"";
import ""../interfaces/IQuantCalculator.sol"";
import ""../interfaces/IOptionsFactory.sol"";
import ""../libraries/ProtocolValue.sol"";
import ""../libraries/QuantMath.sol"";
import ""../libraries/FundsCalculator.sol"";
import ""../libraries/OptionsUtils.sol"";
import ""../libraries/Actions.sol"";

contract ControllerV2 is
    IController,
    EIP712MetaTransaction,
    ReentrancyGuardUpgradeable
{
    using SafeERC20 for IERC20;
    using QuantMath for QuantMath.FixedPointInt;
    using Actions for ActionArgs;

    address public override optionsFactory;

    address public override operateProxy;

    address public override quantCalculator;

    uint256 public newV2StateVariable;

    function operate(ActionArgs[] memory _actions)
        external
        override
        nonReentrant
        returns (bool)
    {
        for (uint256 i = 0; i < _actions.length; i++) {
            ActionArgs memory action = _actions[i];

            if (action.actionType == ActionType.MintOption) {
                (address to, address qToken, uint256 amount) = action
                    .parseMintOptionArgs();
                _mintOptionsPosition(to, qToken, amount);
            } else if (action.actionType == ActionType.MintSpread) {
                (
                    address qTokenToMint,
                    address qTokenForCollateral,
                    uint256 amount
                ) = action.parseMintSpreadArgs();
                _mintSpread(qTokenToMint, qTokenForCollateral, amount);
            } else if (action.actionType == ActionType.Exercise) {
                (address qToken, uint256 amount) = action.parseExerciseArgs();
                _exercise(qToken, amount);
            } else if (action.actionType == ActionType.ClaimCollateral) {
                (uint256 collateralTokenId, uint256 amount) = action
                    .parseClaimCollateralArgs();
                _claimCollateral(collateralTokenId, amount);
            } else if (action.actionType == ActionType.Neutralize) {
                (uint256 collateralTokenId, uint256 amount) = action
                    .parseNeutralizeArgs();
                _neutralizePosition(collateralTokenId, amount);
            } else if (action.actionType == ActionType.QTokenPermit) {
                (
                    address qToken,
                    address owner,
                    address spender,
                    uint256 value,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) = action.parseQTokenPermitArgs();
                _qTokenPermit(qToken, owner, spender, value, deadline, v, r, s);
            } else if (
                action.actionType == ActionType.CollateralTokenApproval
            ) {
                (
                    address owner,
                    address operator,
                    bool approved,
                    uint256 nonce,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) = action.parseCollateralTokenApprovalArgs();
                _collateralTokenApproval(
                    owner,
                    operator,
                    approved,
                    nonce,
                    deadline,
                    v,
                    r,
                    s
                );
            } else {
                require(
                    action.actionType == ActionType.Call,
                    ""Controller: Invalid action type""
                );
                (address callee, bytes memory data) = action.parseCallArgs();
                _call(callee, data);
            }
        }

        return true;
    }

    function setNewV2StateVariable(uint256 _value) external {
        newV2StateVariable = _value;
    }

    function initialize(
        string memory _name,
        string memory _version,
        address _optionsFactory,
        address _quantCalculator
    ) public override initializer {
        require(
            _optionsFactory != address(0),
            ""Controller: invalid OptionsFactory address""
        );
        require(
            _quantCalculator != address(0),
            ""Controller: invalid QuantCalculator address""
        );

        __ReentrancyGuard_init();
        EIP712MetaTransaction.initializeEIP712(_name, _version);
        optionsFactory = _optionsFactory;
        operateProxy = address(new OperateProxy());
        quantCalculator = _quantCalculator;
    }

    function _mintOptionsPosition(
        address _to,
        address _qToken,
        uint256 _amount
    ) internal returns (uint256) {
        IQToken qToken = IQToken(_qToken);

        (address collateral, uint256 collateralAmount) = IQuantCalculator(
            quantCalculator
        ).getCollateralRequirement(_qToken, address(0), _amount);

        _checkIfUnexpiredQToken(_qToken);

        require(
            IOracleRegistry(
                IOptionsFactory(optionsFactory).quantConfig().protocolAddresses(
                    ProtocolValue.encode(""oracleRegistry"")
                )
            ).isOracleActive(qToken.oracle()),
            ""Controller: Can't mint an options position as the oracle is inactive""
        );

        IERC20(collateral).safeTransferFrom(
            _msgSender(),
            address(this),
            collateralAmount
        );

        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)
            .collateralToken();

        // Mint the options to the sender's address
        qToken.mint(_to, _amount);
        uint256 collateralTokenId = collateralToken.getCollateralTokenId(
            _qToken,
            address(0)
        );

        // There's no need to check if the collateralTokenId exists before minting because if the QToken is valid,
        // then it's guaranteed that the respective CollateralToken has already also been created by the OptionsFactory
        collateralToken.mintCollateralToken(_to, collateralTokenId, _amount);

        emit OptionsPositionMinted(
            _to,
            _msgSender(),
            _qToken,
            _amount,
            collateral,
            collateralAmount
        );

        return collateralTokenId;
    }

    function _mintSpread(
        address _qTokenToMint,
        address _qTokenForCollateral,
        uint256 _amount
    ) internal returns (uint256) {
        require(
            _qTokenToMint != _qTokenForCollateral,
            ""Controller: Can only create a spread with different tokens""
        );

        IQToken qTokenToMint = IQToken(_qTokenToMint);
        IQToken qTokenForCollateral = IQToken(_qTokenForCollateral);

        (address collateral, uint256 collateralAmount) = IQuantCalculator(
            quantCalculator
        ).getCollateralRequirement(
                _qTokenToMint,
                _qTokenForCollateral,
                _amount
            );

        _checkIfUnexpiredQToken(_qTokenToMint);
        _checkIfUnexpiredQToken(_qTokenForCollateral);

        qTokenForCollateral.burn(_msgSender(), _amount);

        if (collateralAmount > 0) {
            IERC20(collateral).safeTransferFrom(
                _msgSender(),
                address(this),
                collateralAmount
            );
        }

        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)
            .collateralToken();

        // Check if the corresponding CollateralToken has already been created
        // Create it if it hasn't
        uint256 collateralTokenId = collateralToken.getCollateralTokenId(
            _qTokenToMint,
            _qTokenForCollateral
        );
        (, address qTokenAsCollateral) = collateralToken.idToInfo(
            collateralTokenId
        );
        if (qTokenAsCollateral == address(0)) {
            require(
                collateralTokenId ==
                    collateralToken.createCollateralToken(
                        _qTokenToMint,
                        _qTokenForCollateral
                    ),
                ""Controller: failed creating the collateral token to represent the spread""
            );
        }

        collateralToken.mintCollateralToken(
            _msgSender(),
            collateralTokenId,
            _amount
        );

        qTokenToMint.mint(_msgSender(), _amount);

        emit SpreadMinted(
            _msgSender(),
            _qTokenToMint,
            _qTokenForCollateral,
            _amount,
            collateral,
            collateralAmount
        );

        return collateralTokenId;
    }

    function _exercise(address _qToken, uint256 _amount) internal {
        IQToken qToken = IQToken(_qToken);
        require(
            block.timestamp > qToken.expiryTime(),
            ""Controller: Can not exercise options before their expiry""
        );

        uint256 amountToExercise = _amount;
        if (amountToExercise == 0) {
            amountToExercise = qToken.balanceOf(_msgSender());
        }

        (
            bool isSettled,
            address payoutToken,
            uint256 exerciseTotal
        ) = IQuantCalculator(quantCalculator).getExercisePayout(
                address(qToken),
                amountToExercise
            );

        require(isSettled, ""Controller: Cannot exercise unsettled options"");

        qToken.burn(_msgSender(), amountToExercise);

        if (exerciseTotal > 0) {
            IERC20(payoutToken).safeTransfer(_msgSender(), exerciseTotal);
        }

        emit OptionsExercised(
            _msgSender(),
            address(qToken),
            amountToExercise,
            exerciseTotal,
            payoutToken
        );
    }

    function _claimCollateral(uint256 _collateralTokenId, uint256 _amount)
        internal
    {
        uint256 collateralTokenId = _collateralTokenId;

        (
            uint256 returnableCollateral,
            address collateralAsset,
            uint256 amountToClaim
        ) = IQuantCalculator(quantCalculator).calculateClaimableCollateral(
                collateralTokenId,
                _amount,
                _msgSender()
            );

        IOptionsFactory(optionsFactory).collateralToken().burnCollateralToken(
            _msgSender(),
            collateralTokenId,
            amountToClaim
        );

        if (returnableCollateral > 0) {
            IERC20(collateralAsset).safeTransfer(
                _msgSender(),
                returnableCollateral
            );
        }

        emit CollateralClaimed(
            _msgSender(),
            collateralTokenId,
            amountToClaim,
            returnableCollateral,
            collateralAsset
        );
    }

    function _neutralizePosition(uint256 _collateralTokenId, uint256 _amount)
        internal
    {
        (uint256 collateralTokenId, uint256 amount) = (
            _collateralTokenId,
            _amount
        );

        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)
            .collateralToken();
        (address qTokenShort, address qTokenLong) = collateralToken.idToInfo(
            collateralTokenId
        );

        //get the amount of collateral tokens owned
        uint256 collateralTokensOwned = collateralToken.balanceOf(
            _msgSender(),
            collateralTokenId
        );

        //get the amount of qTokens owned
        uint256 qTokensOwned = IQToken(qTokenShort).balanceOf(_msgSender());

        //the amount of position that can be neutralized
        uint256 maxNeutralizable = qTokensOwned < collateralTokensOwned
            ? qTokensOwned
            : collateralTokensOwned;

        uint256 amountToNeutralize;

        if (amount != 0) {
            require(
                amount <= maxNeutralizable,
                ""Controller: Tried to neutralize more than balance""
            );
            amountToNeutralize = amount;
        } else {
            amountToNeutralize = maxNeutralizable;
        }

        (address collateralType, uint256 collateralOwed) = IQuantCalculator(
            quantCalculator
        ).getNeutralizationPayout(qTokenShort, qTokenLong, amountToNeutralize);

        IQToken(qTokenShort).burn(_msgSender(), amountToNeutralize);

        collateralToken.burnCollateralToken(
            _msgSender(),
            collateralTokenId,
            amountToNeutralize
        );

        IERC20(collateralType).safeTransfer(_msgSender(), collateralOwed);

        //give the user their long tokens (if any)
        if (qTokenLong != address(0)) {
            IQToken(qTokenLong).mint(_msgSender(), amountToNeutralize);
        }

        emit NeutralizePosition(
            _msgSender(),
            qTokenShort,
            amountToNeutralize,
            collateralOwed,
            collateralType,
            qTokenLong
        );
    }

    function _qTokenPermit(
        address _qToken,
        address _owner,
        address _spender,
        uint256 _value,
        uint256 _deadline,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) internal {
        IQToken(_qToken).permit(
            _owner,
            _spender,
            _value,
            _deadline,
            _v,
            _r,
            _s
        );
    }

    function _collateralTokenApproval(
        address _owner,
        address _operator,
        bool _approved,
        uint256 _nonce,
        uint256 _deadline,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) internal {
        IOptionsFactory(optionsFactory).collateralToken().metaSetApprovalForAll(
                _owner,
                _operator,
                _approved,
                _nonce,
                _deadline,
                _v,
                _r,
                _s
            );
    }

    function _call(address _callee, bytes memory _data) internal {
        IOperateProxy(operateProxy).callFunction(_callee, _data);
    }

    function _checkIfUnexpiredQToken(address _qToken) internal view {
        require(
            IQToken(_qToken).expiryTime() > block.timestamp,
            ""Controller: Cannot mint expired options""
        );
    }
}",3022
RealWorld_TA_98_OperateProxy_RealWorld_20240812084426.log,98,OperateProxy,32429,2404,34833,70.0,0.210225,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""../interfaces/IOperateProxy.sol"";

/// @title Contract to be used by the Controller to make unprivileged external calls
/// @author Rolla
contract OperateProxy is IOperateProxy {
    /// @inheritdoc IOperateProxy
    function callFunction(address callee, bytes memory data) external override {
        require(
            callee != address(0),
            ""OperateProxy: cannot make function calls to the zero address""
        );

        (bool success, bytes memory returnData) = address(callee).call(data);
        require(success, ""OperateProxy: low-level call failed"");
        emit FunctionCallExecuted(tx.origin, returnData);
    }
}",160
RealWorld_TA_98_ConfigTimelockController_RealWorld_20240812081611.log,98,ConfigTimelockController,438721,2696,441417,114.0,2.247525,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""./TimelockController.sol"";
import ""../interfaces/IQuantConfig.sol"";
import ""../libraries/ProtocolValue.sol"";

/// @title Timelock controller contract for setting values in the QuantConfig and scheduling calls
/// to external contracts.
/// @author Rolla
/// @dev Built on top of OpenZeppelin's TimelockController.
contract ConfigTimelockController is TimelockController {
    mapping(bytes32 => uint256) public delays;

    mapping(bytes32 => uint256) private _timestamps;

    /// @notice The minimum delay for scheduled executions
    uint256 public minDelay;

    constructor(
        uint256 _minDelay,
        address[] memory _proposers,
        address[] memory _executors
    )
        TimelockController(_minDelay, _proposers, _executors)
    // solhint-disable-next-line no-empty-blocks
    {
        minDelay = _minDelay;
    }

    /// @notice Sets the delay for a specific protocol value
    /// @param _protocolValue the bytes32 encoded representation of the protocol value
    /// @param _newDelay the delay in seconds
    function setDelay(bytes32 _protocolValue, uint256 _newDelay)
        external
        onlyRole(EXECUTOR_ROLE)
    {
        // Delays must be greater than or equal to the minimum delay
        delays[_protocolValue] = _newDelay >= minDelay ? _newDelay : minDelay;
    }

    /// @inheritdoc TimelockController
    function schedule(
        address target,
        uint256 value,
        bytes memory data,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay,
        bool
    ) public virtual override onlyRole(PROPOSER_ROLE) {
        require(
            !_isProtocoValueSetter(data),
            ""ConfigTimelockController: Can not schedule changes to a protocol value with an arbitrary delay""
        );

        super.schedule(target, value, data, predecessor, salt, delay, false);
    }

    /// @notice Schedule a call to set a protocol address in the QuantConfig contract
    /// @param protocolAddress the encoded name of the protocol address variable to set in the config
    /// @param newAddress the new address value to set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled call can be executed
    function scheduleSetProtocolAddress(
        bytes32 protocolAddress,
        address newAddress,
        address quantConfig,
        uint256 eta
    ) public onlyRole(PROPOSER_ROLE) {
        bytes memory data = _encodeSetProtocolAddress(
            protocolAddress,
            newAddress,
            quantConfig
        );

        uint256 delay = _getProtocolValueDelay(
            quantConfig,
            protocolAddress,
            ProtocolValue.Type.Address
        );

        require(
            eta >= delay + block.timestamp,
            ""ConfigTimelockController: Estimated execution block must satisfy delay""
        );

        super.schedule(
            quantConfig,
            0,
            data,
            bytes32(0),
            bytes32(eta),
            delay,
            true
        );
    }

    /// @notice Schedule a call to set a protocol uint256 in the QuantConfig contract
    /// @param protocolUint256 the encoded name of the protocol uint256 variable to set in the config
    /// @param newUint256 the new uint256 value to set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled call can be executed
    function scheduleSetProtocolUint256(
        bytes32 protocolUint256,
        uint256 newUint256,
        address quantConfig,
        uint256 eta
    ) public onlyRole(PROPOSER_ROLE) {
        bytes memory data = _encodeSetProtocolUint256(
            protocolUint256,
            newUint256,
            quantConfig
        );

        uint256 delay = _getProtocolValueDelay(
            quantConfig,
            protocolUint256,
            ProtocolValue.Type.Uint256
        );

        require(
            eta >= delay + block.timestamp,
            ""ConfigTimelockController: Estimated execution block must satisfy delay""
        );

        super.schedule(
            quantConfig,
            0,
            data,
            bytes32(0),
            bytes32(eta),
            delay,
            true
        );
    }

    /// @notice Schedule a call to set a protocol boolean in the QuantConfig contract
    /// @param protocolBoolean the encoded name of the protocol boolean variable to set in the config
    /// @param newBoolean the new boolean value to set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled call can be executed
    function scheduleSetProtocolBoolean(
        bytes32 protocolBoolean,
        bool newBoolean,
        address quantConfig,
        uint256 eta
    ) public onlyRole(PROPOSER_ROLE) {
        bytes memory data = _encodeSetProtocolBoolean(
            protocolBoolean,
            newBoolean,
            quantConfig
        );

        uint256 delay = _getProtocolValueDelay(
            quantConfig,
            protocolBoolean,
            ProtocolValue.Type.Bool
        );

        require(
            eta >= delay + block.timestamp,
            ""ConfigTimelockController: Estimated execution block must satisfy delay""
        );
        super.schedule(
            quantConfig,
            0,
            data,
            bytes32(0),
            bytes32(eta),
            delay,
            true
        );
    }

    /// @notice Schedule a call to set a protocol role in the QuantConfig contract
    /// @param protocolRole the name of the protocol role variable to set in the config
    /// @param roleAdmin address to be the role admin
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled call can be executed
    function scheduleSetProtocolRole(
        string calldata protocolRole,
        address roleAdmin,
        address quantConfig,
        uint256 eta
    ) public onlyRole(PROPOSER_ROLE) {
        bytes memory data = _encodeSetProtocolRole(
            protocolRole,
            roleAdmin,
            quantConfig
        );

        uint256 delay = _getProtocolValueDelay(
            quantConfig,
            keccak256(abi.encodePacked(protocolRole)),
            ProtocolValue.Type.Role
        );

        require(
            eta >= delay + block.timestamp,
            ""ConfigTimelockController: Estimated execution block must satisfy delay""
        );

        super.schedule(
            quantConfig,
            0,
            data,
            bytes32(0),
            bytes32(eta),
            delay,
            true
        );
    }

    /// @notice Schedule multiple contract calls
    /// @dev Cannot schedule calls to set protocol values in the QuantConfig
    /// @param targets array of contracts to receive the scheduled calls
    /// @param values array of values to be sent to the contracts
    /// @param datas array of data to be sent to the contracts
    /// @param predecessor extra 32 bytes to be used when hashing the operation batch
    /// @param salt salt to be used when hashing the operation batch
    /// @param delay execution delay in seconds
    function scheduleBatch(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory datas,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay
    ) public virtual override onlyRole(PROPOSER_ROLE) {
        uint256 length = targets.length;
        for (uint256 i = 0; i < length; ) {
            require(
                !_isProtocoValueSetter(datas[i]),
                ""ConfigTimelockController: Can not schedule changes to a protocol value with an arbitrary delay""
            );
            unchecked {
                ++i;
            }
        }

        super.scheduleBatch(targets, values, datas, predecessor, salt, delay);
    }

    /// @notice Schedule multiple calls to set protocol address values in the QuantConfig
    /// @param protocolValues array of protocol address values to be set
    /// @param newAddresses array of new addresses to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled calls can be executed
    function scheduleBatchSetProtocolAddress(
        bytes32[] calldata protocolValues,
        address[] calldata newAddresses,
        address quantConfig,
        uint256 eta
    ) public onlyRole(PROPOSER_ROLE) {
        uint256 length = protocolValues.length;

        require(
            length == newAddresses.length,
            ""ConfigTimelockController: length mismatch""
        );

        for (uint256 i = 0; i < length; ) {
            scheduleSetProtocolAddress(
                protocolValues[i],
                newAddresses[i],
                quantConfig,
                eta
            );
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Schedule multiple calls to set protocol uint256 values in the QuantConfig
    /// @param protocolValues array of protocol uint256 values to be set
    /// @param newUints array of new uints to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled calls can be executed
    function scheduleBatchSetProtocolUints(
        bytes32[] calldata protocolValues,
        uint256[] calldata newUints,
        address quantConfig,
        uint256 eta
    ) public onlyRole(PROPOSER_ROLE) {
        uint256 length = protocolValues.length;

        require(
            length == newUints.length,
            ""ConfigTimelockController: length mismatch""
        );

        for (uint256 i = 0; i < length; ) {
            scheduleSetProtocolUint256(
                protocolValues[i],
                newUints[i],
                quantConfig,
                eta
            );
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Schedule multiple calls to set protocol boolean values in the QuantConfig
    /// @param protocolValues array of protocol boolean values to be set
    /// @param newBooleans array of new booleans to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled calls can be executed
    function scheduleBatchSetProtocolBooleans(
        bytes32[] calldata protocolValues,
        bool[] calldata newBooleans,
        address quantConfig,
        uint256 eta
    ) public onlyRole(PROPOSER_ROLE) {
        uint256 length = protocolValues.length;

        require(
            length == newBooleans.length,
            ""ConfigTimelockController: length mismatch""
        );

        for (uint256 i = 0; i < length; ) {
            scheduleSetProtocolBoolean(
                protocolValues[i],
                newBooleans[i],
                quantConfig,
                eta
            );
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Schedule multiple calls to set protocol roles in the QuantConfig
    /// @param protocolRoles array of protocol roles to be set
    /// @param roleAdmins array of role admins to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled calls can be executed
    function scheduleBatchSetProtocolRoles(
        string[] calldata protocolRoles,
        address[] calldata roleAdmins,
        address quantConfig,
        uint256 eta
    ) public onlyRole(PROPOSER_ROLE) {
        uint256 length = protocolRoles.length;

        require(
            length == roleAdmins.length,
            ""ConfigTimelockController: length mismatch""
        );

        for (uint256 i = 0; i < length; ) {
            scheduleSetProtocolRole(
                protocolRoles[i],
                roleAdmins[i],
                quantConfig,
                eta
            );
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Execute a scheduled call to set a protocol address value in the QuantConfig
    /// @param protocolAddress the protocol address value to be set
    /// @param newAddress the new address to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled call can be executed
    function executeSetProtocolAddress(
        bytes32 protocolAddress,
        address newAddress,
        address quantConfig,
        uint256 eta
    ) public onlyRole(EXECUTOR_ROLE) {
        execute(
            quantConfig,
            0,
            _encodeSetProtocolAddress(protocolAddress, newAddress, quantConfig),
            bytes32(0),
            bytes32(eta)
        );
    }

    /// @notice Execute a scheduled call to set a protocol uint256 value in the QuantConfig
    /// @param protocolUint256 the protocol uint256 value to be set
    /// @param newUint256 the new uint to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled call can be executed
    function executeSetProtocolUint256(
        bytes32 protocolUint256,
        uint256 newUint256,
        address quantConfig,
        uint256 eta
    ) public onlyRole(EXECUTOR_ROLE) {
        execute(
            quantConfig,
            0,
            _encodeSetProtocolUint256(protocolUint256, newUint256, quantConfig),
            bytes32(0),
            bytes32(eta)
        );
    }

    /// @notice Execute a scheduled call to set a protocol boolean value in the QuantConfig
    /// @param protocolBoolean the protocol boolean value to be set
    /// @param newBoolean the new boolean to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled call can be executed
    function executeSetProtocolBoolean(
        bytes32 protocolBoolean,
        bool newBoolean,
        address quantConfig,
        uint256 eta
    ) public onlyRole(EXECUTOR_ROLE) {
        execute(
            quantConfig,
            0,
            _encodeSetProtocolBoolean(protocolBoolean, newBoolean, quantConfig),
            bytes32(0),
            bytes32(eta)
        );
    }

    /// @notice Execute a scheduled call to set a protocol role in the QuantConfig
    /// @param protocolRole the protocol role to be set
    /// @param roleAdmin the role admin to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled call can be executed
    function executeSetProtocolRole(
        string calldata protocolRole,
        address roleAdmin,
        address quantConfig,
        uint256 eta
    ) public onlyRole(EXECUTOR_ROLE) {
        execute(
            quantConfig,
            0,
            _encodeSetProtocolRole(protocolRole, roleAdmin, quantConfig),
            bytes32(0),
            bytes32(eta)
        );
    }

    /// @notice Execute multiple scheduled calls to set protocol address values in the QuantConfig
    /// @param protocolValues array of protocol address values to be set
    /// @param newAddresses array of new addresses to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled calls can be executed
    function executeBatchSetProtocolAddress(
        bytes32[] calldata protocolValues,
        address[] calldata newAddresses,
        address quantConfig,
        uint256 eta
    ) public onlyRole(EXECUTOR_ROLE) {
        uint256 length = protocolValues.length;

        require(
            length == newAddresses.length,
            ""ConfigTimelockController: length mismatch""
        );

        for (uint256 i = 0; i < length; ) {
            execute(
                quantConfig,
                0,
                _encodeSetProtocolAddress(
                    protocolValues[i],
                    newAddresses[i],
                    quantConfig
                ),
                bytes32(0),
                bytes32(eta)
            );
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Execute multiple scheduled calls to set protocol uint256 values in the QuantConfig
    /// @param protocolValues array of protocol uint256 values to be set
    /// @param newUints array of new uints to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled calls can be executed
    function executeBatchSetProtocolUint256(
        bytes32[] calldata protocolValues,
        uint256[] calldata newUints,
        address quantConfig,
        uint256 eta
    ) public onlyRole(EXECUTOR_ROLE) {
        uint256 length = protocolValues.length;

        require(
            length == newUints.length,
            ""ConfigTimelockController: length mismatch""
        );

        for (uint256 i = 0; i < length; ) {
            execute(
                quantConfig,
                0,
                _encodeSetProtocolUint256(
                    protocolValues[i],
                    newUints[i],
                    quantConfig
                ),
                bytes32(0),
                bytes32(eta)
            );
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Execute multiple scheduled calls to set protocol boolean values in the QuantConfig
    /// @param protocolValues array of protocol boolean values to be set
    /// @param newBooleans array of new booleans to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled calls can be executed
    function executeBatchSetProtocolBoolean(
        bytes32[] calldata protocolValues,
        bool[] calldata newBooleans,
        address quantConfig,
        uint256 eta
    ) public onlyRole(EXECUTOR_ROLE) {
        uint256 length = protocolValues.length;

        require(
            length == newBooleans.length,
            ""ConfigTimelockController: length mismatch""
        );

        for (uint256 i = 0; i < length; ) {
            execute(
                quantConfig,
                0,
                _encodeSetProtocolBoolean(
                    protocolValues[i],
                    newBooleans[i],
                    quantConfig
                ),
                bytes32(0),
                bytes32(eta)
            );
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Execute multiple scheduled calls to set protocol roles in the QuantConfig
    /// @param protocolRoles array of protocol roles to be set
    /// @param roleAdmins array of role admins to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled calls can be executed
    function executeBatchSetProtocolRoles(
        string[] calldata protocolRoles,
        address[] calldata roleAdmins,
        address quantConfig,
        uint256 eta
    ) public onlyRole(EXECUTOR_ROLE) {
        uint256 length = protocolRoles.length;

        require(
            length == roleAdmins.length,
            ""ConfigTimelockController: length mismatch""
        );

        for (uint256 i = 0; i < length; ) {
            execute(
                quantConfig,
                0,
                _encodeSetProtocolRole(
                    protocolRoles[i],
                    roleAdmins[i],
                    quantConfig
                ),
                bytes32(0),
                bytes32(eta)
            );
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Gets the delay to set a specific protocol value using the timelock
    /// @param quantConfig  the address of the QuantConfig contract
    /// @param protocolValue the protocol value to get the delay for
    /// @return the delay required to set the protocol value
    function _getProtocolValueDelay(
        address quantConfig,
        bytes32 protocolValue,
        ProtocolValue.Type protocolValueType
    ) internal view returns (uint256) {
        // There shouldn't be a delay when setting a protocol value for the first time
        if (
            !IQuantConfig(quantConfig).isProtocolValueSet(
                protocolValue,
                protocolValueType
            )
        ) {
            return 0;
        }

        uint256 storedDelay = delays[protocolValue];
        return storedDelay != 0 ? storedDelay : minDelay;
    }

    /// @notice Checks if a given calldata is for setting a protocol value, which could be used
    /// to bypass the minimum delay required to set a protocol value of a specific type
    /// @param data the calldata to check
    /// @return true if the calldata is for setting a protocol value, false otherwise
    /// @dev There could be a clash between the 4-byte selector for `setProtocolValue` functions
    /// and other external functions. That's unlikely to happen, but if it does, scheduling calls
    /// to those functions will always revert.
    function _isProtocoValueSetter(bytes memory data)
        internal
        pure
        returns (bool)
    {
        bytes4 selector;

        assembly {
            selector := mload(add(data, 32))
        }

        return
            selector == IQuantConfig(address(0)).setProtocolAddress.selector ||
            selector == IQuantConfig(address(0)).setProtocolUint256.selector ||
            selector == IQuantConfig(address(0)).setProtocolBoolean.selector;
    }

    /// @notice Encodes the calldata for setting a protocol address value
    /// @param _protocolAddress the protocol address value to be set
    /// @param _newAddress the new address to be set
    /// @param _quantConfig the address of the QuantConfig contract
    function _encodeSetProtocolAddress(
        bytes32 _protocolAddress,
        address _newAddress,
        address _quantConfig
    ) internal pure returns (bytes memory) {
        return
            abi.encodeWithSelector(
                IQuantConfig(_quantConfig).setProtocolAddress.selector,
                _protocolAddress,
                _newAddress
            );
    }

    /// @notice Encodes the calldata for setting a protocol uint256 value
    /// @param _protocolUint256 the protocol uint256 value to be set
    /// @param _newUint256 the new uint to be set
    /// @param _quantConfig the address of the QuantConfig contract
    function _encodeSetProtocolUint256(
        bytes32 _protocolUint256,
        uint256 _newUint256,
        address _quantConfig
    ) internal pure returns (bytes memory) {
        return
            abi.encodeWithSelector(
                IQuantConfig(_quantConfig).setProtocolUint256.selector,
                _protocolUint256,
                _newUint256
            );
    }

    /// @notice Encodes the calldata for setting a protocol boolean value
    /// @param _protocolBoolean the protocol boolean value to be set
    /// @param _newBoolean the new boolean to be set
    /// @param _quantConfig the address of the QuantConfig contract
    function _encodeSetProtocolBoolean(
        bytes32 _protocolBoolean,
        bool _newBoolean,
        address _quantConfig
    ) internal pure returns (bytes memory) {
        return
            abi.encodeWithSelector(
                IQuantConfig(_quantConfig).setProtocolBoolean.selector,
                _protocolBoolean,
                _newBoolean
            );
    }

    /// @notice Encodes the calldata for setting a protocol role
    /// @param _protocolRole the protocol role to be set
    /// @param _roleAdmin the role admin to be set
    /// @param _quantConfig the address of the QuantConfig contract
    function _encodeSetProtocolRole(
        string memory _protocolRole,
        address _roleAdmin,
        address _quantConfig
    ) internal pure returns (bytes memory) {
        return
            abi.encodeWithSelector(
                IQuantConfig(_quantConfig).setProtocolRole.selector,
                _protocolRole,
                _roleAdmin
            );
    }
}",5016
RealWorld_TA_98_MockERC20_RealWorld_20240812082324.log,98,MockERC20,29611,2215,31826,75.0,0.192355,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MockERC20 is ERC20 {
    uint8 private _decimals;

    constructor(
        string memory name_,
        string memory symbol_,
        uint8 decimals_
    ) ERC20(name_, symbol_) {
        _decimals = decimals_;
    }

    function mint(address account, uint256 amount) external {
        _mint(account, amount);
    }

    function decimals() public view virtual override returns (uint8) {
        return _decimals;
    }
}",133
RealWorld_TA_98_ActionsTester_RealWorld_20240812083126.log,98,ActionsTester,53087,1469,54556,66.0,0.294815,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""../libraries/Actions.sol"";

contract ActionsTester {
    function testParseMintOptionArgs(ActionArgs memory args)
        external
        pure
        returns (
            address,
            address,
            uint256
        )
    {
        return Actions.parseMintOptionArgs(args);
    }

    function testParseMintSpreadArgs(ActionArgs memory args)
        external
        pure
        returns (
            address,
            address,
            uint256
        )
    {
        return Actions.parseMintSpreadArgs(args);
    }

    function testParseExerciseArgs(ActionArgs memory args)
        external
        pure
        returns (address, uint256)
    {
        return Actions.parseExerciseArgs(args);
    }

    function testParseClaimCollateralArgs(ActionArgs memory args)
        external
        pure
        returns (uint256, uint256)
    {
        return Actions.parseClaimCollateralArgs(args);
    }

    function testParseNeutralizeArgs(ActionArgs memory args)
        external
        pure
        returns (uint256, uint256)
    {
        return Actions.parseNeutralizeArgs(args);
    }

    function testParseQTokenPermitArgs(ActionArgs memory args)
        external
        pure
        returns (
            address,
            address,
            address,
            uint256,
            uint256,
            uint8,
            bytes32,
            bytes32
        )
    {
        return Actions.parseQTokenPermitArgs(args);
    }

    function testParseCollateralTokenApprovalArgs(ActionArgs memory args)
        external
        pure
        returns (
            address,
            address,
            bool,
            uint256,
            uint256,
            uint8,
            bytes32,
            bytes32
        )
    {
        return Actions.parseCollateralTokenApprovalArgs(args);
    }

    function testParseCallArgs(ActionArgs memory args)
        external
        pure
        returns (address, bytes memory)
    {
        return Actions.parseCallArgs(args);
    }
}",423
RealWorld_TA_98_IQuantCalculator_RealWorld_20240812090425.log,98,IQuantCalculator,113098,1504,114602,71.0,0.59557,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

/// @title For calculating collateral requirements and payouts for options and spreads
/// @author Rolla
interface IQuantCalculator {
    /// @notice Calculates the amount of collateral that can be claimed back post-settlement
    /// from a CollateralToken
    /// @param _collateralTokenId the id of the collateral token that is being claimed
    /// @param _amount the amount of the collateral token being claimed. passing 0 claims the
    /// users whole collateral token balance (does a balance lookup)
    /// @param _msgSender the address of the claiming account
    /// @return returnableCollateral the amount of collateral that will be returned from the claim
    /// @return collateralAsset the address of the asset that will be returned from the claim
    /// @return amountToClaim the amount of collateral tokens claimed. can only different to _amount
    /// when the _amount passed was 0 and the user had a collateral token balance > 0
    function calculateClaimableCollateral(
        uint256 _collateralTokenId,
        uint256 _amount,
        address _msgSender
    )
        external
        view
        returns (
            uint256 returnableCollateral,
            address collateralAsset,
            uint256 amountToClaim
        );

    /// @notice Calculates the collateral required to mint an option or a spread
    /// @param _qTokenToMint the desired qToken
    /// @param _qTokenForCollateral for spreads, this is the address of the qtoken to be used as collateral.
    /// for options, no collateral is provided so the zero address should be passed.
    /// @param _amount the amount of options/spread to mint
    /// @return collateral the address of the collateral token required
    /// @return collateralAmount the amount of collateral that is required to mint the option/spread
    function getCollateralRequirement(
        address _qTokenToMint,
        address _qTokenForCollateral,
        uint256 _amount
    ) external view returns (address collateral, uint256 collateralAmount);

    /// @notice Calculates exercisable amount of an option post-expiry
    /// @param _qToken address of the qToken being exercised
    /// @param _amount the amount of the qToken being exercised
    /// @return isSettled true if there is a settlement price for this option
    /// and it can be exercised. false if there is no settlement price for this
    /// option meaning it can't be exercised. if this value is false, payoutToken
    /// will return the zero address and payout amount will be 0.
    /// @return payoutToken the token that will be received from exercise. this will
    /// return the zero address if the option is unsettled (can't exercise unsettled option)
    /// @return payoutAmount the amount of payoutToken that will be received from exercising.
    /// zero if the option is unsettled (can't exercise unsettled option)
    function getExercisePayout(address _qToken, uint256 _amount)
        external
        view
        returns (
            bool isSettled,
            address payoutToken,
            uint256 payoutAmount
        );

    /// @notice Calculates the amount that will be received from neutralizing an option or spread.
    /// Neutralizing is the opposite action to mint - you give collateral token and qToken and receive
    /// back collateral required to mint. Thus, the calculation is the same as getting the collateral
    /// requirement with the only difference being rounding.
    /// For neutralizing a spread, not only will the collateral provided be returned (if any), but also
    /// the qToken that was provided as collateral when minting the spread will also be returned.
    /// @param _qTokenShort the desired qToken
    /// @param _qTokenLong for spreads, this is the address of the qtoken to be used as collateral.
    /// for options, no collateral is provided so the zero address should be passed.
    /// @param _amountToNeutralize the amount of options/spread being neutralized
    /// @return collateralType the token that will be returned from neutralizing. this is the same
    /// as the token that was provided when minting since this method is returning that collateral
    /// back.
    /// @return collateralOwed the amount of collateral that will be returned from neutralizing.
    /// given the same parameters used for minting this will return the same amount of collateral
    /// in all cases except when there is rounding involved. in those cases, the difference will be
    /// 1 unit of collateral less for the neutralize than the mint.
    function getNeutralizationPayout(
        address _qTokenShort,
        address _qTokenLong,
        uint256 _amountToNeutralize
    ) external view returns (address collateralType, uint256 collateralOwed);

    /// @notice The amount of decimals for Quant options
    // solhint-disable-next-line func-name-mixedcase
    function OPTIONS_DECIMALS() external view returns (uint8);

    /// @notice The amount of decimals for the strike asset used in the Quant Protocol
    function strikeAssetDecimals() external view returns (uint8);

    /// @notice The address of the factory contract that creates Quant options
    function optionsFactory() external view returns (address);
}",1137
RealWorld_TA_98_QuantCalculator_RealWorld_20240812080539.log,98,QuantCalculator,171340,3462,174802,103.0,0.92594,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""./interfaces/IQuantCalculator.sol"";
import ""./interfaces/IOptionsFactory.sol"";
import ""./interfaces/IQToken.sol"";
import ""./interfaces/IPriceRegistry.sol"";
import ""./libraries/FundsCalculator.sol"";
import ""./libraries/OptionsUtils.sol"";
import ""./libraries/QuantMath.sol"";

/// @title For calculating collateral requirements and payouts for options and spreads
/// @author Rolla
/// @dev Uses fixed point arithmetic from the QuantMath library.
contract QuantCalculator is IQuantCalculator {
    using QuantMath for uint256;
    using QuantMath for int256;
    using QuantMath for QuantMath.FixedPointInt;

    /// @inheritdoc IQuantCalculator
    uint8 public constant override OPTIONS_DECIMALS = 18;

    /// @inheritdoc IQuantCalculator
    uint8 public immutable override strikeAssetDecimals;

    /// @inheritdoc IQuantCalculator
    address public immutable override optionsFactory;

    /// @notice Checks that the QToken was created through the configured OptionsFactory
    modifier validQToken(address _qToken) {
        require(
            IOptionsFactory(optionsFactory).isQToken(_qToken),
            ""QuantCalculator: Invalid QToken address""
        );

        _;
    }

    /// @notice Checks that the QToken used as collateral for a spread is either the zero address
    /// or a QToken created through the configured OptionsFactory
    modifier validQTokenAsCollateral(address _qTokenAsCollateral) {
        if (_qTokenAsCollateral != address(0)) {
            // it could be the zero address for the qTokenAsCollateral for non-spreads
            require(
                IOptionsFactory(optionsFactory).isQToken(_qTokenAsCollateral),
                ""QuantCalculator: Invalid QToken address""
            );
        }

        _;
    }

    /// @param _strikeAssetDecimals the number of decimals used to denominate strike prices
    /// @param _optionsFactory the address of the OptionsFactory contract
    constructor(uint8 _strikeAssetDecimals, address _optionsFactory) {
        strikeAssetDecimals = _strikeAssetDecimals;
        optionsFactory = _optionsFactory;
    }

    /// @inheritdoc IQuantCalculator
    function calculateClaimableCollateral(
        uint256 _collateralTokenId,
        uint256 _amount,
        address _msgSender
    )
        external
        view
        override
        returns (
            uint256 returnableCollateral,
            address collateralAsset,
            uint256 amountToClaim
        )
    {
        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)
            .collateralToken();

        (address _qTokenShort, address qTokenAsCollateral) = collateralToken
            .idToInfo(_collateralTokenId);

        require(
            _qTokenShort != address(0),
            ""Can not claim collateral from non-existing option""
        );

        IQToken qTokenShort = IQToken(_qTokenShort);

        require(
            block.timestamp > qTokenShort.expiryTime(),
            ""Can not claim collateral from options before their expiry""
        );
        require(
            qTokenShort.getOptionPriceStatus() == PriceStatus.SETTLED,
            ""Can not claim collateral before option is settled""
        );

        amountToClaim = _amount == 0
            ? collateralToken.balanceOf(_msgSender, _collateralTokenId)
            : _amount;

        IQuantConfig quantConfig = IOptionsFactory(optionsFactory)
            .quantConfig();

        IPriceRegistry priceRegistry = IPriceRegistry(
            quantConfig.protocolAddresses(ProtocolValue.encode(""priceRegistry""))
        );

        IPriceRegistry.PriceWithDecimals memory expiryPrice = priceRegistry
            .getSettlementPriceWithDecimals(
                qTokenShort.oracle(),
                qTokenShort.underlyingAsset(),
                qTokenShort.expiryTime()
            );

        address qTokenLong;
        QuantMath.FixedPointInt memory payoutFromLong;

        if (qTokenAsCollateral != address(0)) {
            qTokenLong = qTokenAsCollateral;

            (, payoutFromLong) = FundsCalculator.getPayout(
                qTokenLong,
                amountToClaim,
                OPTIONS_DECIMALS,
                strikeAssetDecimals,
                expiryPrice
            );
        } else {
            qTokenLong = address(0);
            payoutFromLong = int256(0).fromUnscaledInt();
        }

        uint8 payoutDecimals = OptionsUtils.getPayoutDecimals(
            strikeAssetDecimals,
            qTokenShort,
            quantConfig
        );

        QuantMath.FixedPointInt memory collateralRequirement;
        (collateralAsset, collateralRequirement) = FundsCalculator
            .getCollateralRequirement(
                _qTokenShort,
                qTokenLong,
                amountToClaim,
                OPTIONS_DECIMALS,
                payoutDecimals,
                strikeAssetDecimals
            );

        (, QuantMath.FixedPointInt memory payoutFromShort) = FundsCalculator
            .getPayout(
                _qTokenShort,
                amountToClaim,
                OPTIONS_DECIMALS,
                strikeAssetDecimals,
                expiryPrice
            );

        returnableCollateral = payoutFromLong
            .add(collateralRequirement)
            .sub(payoutFromShort)
            .toScaledUint(payoutDecimals, true);
    }

    /// @inheritdoc IQuantCalculator
    function getNeutralizationPayout(
        address _qTokenShort,
        address _qTokenLong,
        uint256 _amountToNeutralize
    )
        external
        view
        override
        returns (address collateralType, uint256 collateralOwed)
    {
        uint8 payoutDecimals = OptionsUtils.getPayoutDecimals(
            strikeAssetDecimals,
            IQToken(_qTokenShort),
            IOptionsFactory(optionsFactory).quantConfig()
        );

        QuantMath.FixedPointInt memory collateralOwedFP;
        (collateralType, collateralOwedFP) = FundsCalculator
            .getCollateralRequirement(
                _qTokenShort,
                _qTokenLong,
                _amountToNeutralize,
                OPTIONS_DECIMALS,
                payoutDecimals,
                strikeAssetDecimals
            );

        collateralOwed = collateralOwedFP.toScaledUint(payoutDecimals, true);
    }

    /// @inheritdoc IQuantCalculator
    function getCollateralRequirement(
        address _qTokenToMint,
        address _qTokenForCollateral,
        uint256 _amount
    )
        external
        view
        override
        validQToken(_qTokenToMint)
        validQTokenAsCollateral(_qTokenForCollateral)
        returns (address collateral, uint256 collateralAmount)
    {
        QuantMath.FixedPointInt memory collateralAmountFP;
        uint8 payoutDecimals = OptionsUtils.getPayoutDecimals(
            strikeAssetDecimals,
            IQToken(_qTokenToMint),
            IOptionsFactory(optionsFactory).quantConfig()
        );

        (collateral, collateralAmountFP) = FundsCalculator
            .getCollateralRequirement(
                _qTokenToMint,
                _qTokenForCollateral,
                _amount,
                OPTIONS_DECIMALS,
                payoutDecimals,
                strikeAssetDecimals
            );

        collateralAmount = collateralAmountFP.toScaledUint(
            payoutDecimals,
            false
        );
    }

    /// @inheritdoc IQuantCalculator
    function getExercisePayout(address _qToken, uint256 _amount)
        external
        view
        override
        validQToken(_qToken)
        returns (
            bool isSettled,
            address payoutToken,
            uint256 payoutAmount
        )
    {
        IQToken qToken = IQToken(_qToken);
        isSettled = qToken.getOptionPriceStatus() == PriceStatus.SETTLED;
        if (!isSettled) {
            return (false, address(0), 0);
        } else {
            isSettled = true;
        }

        QuantMath.FixedPointInt memory payout;

        IQuantConfig quantConfig = IOptionsFactory(optionsFactory)
            .quantConfig();

        IPriceRegistry priceRegistry = IPriceRegistry(
            quantConfig.protocolAddresses(ProtocolValue.encode(""priceRegistry""))
        );

        uint8 payoutDecimals = OptionsUtils.getPayoutDecimals(
            strikeAssetDecimals,
            qToken,
            quantConfig
        );

        address underlyingAsset = qToken.underlyingAsset();

        IPriceRegistry.PriceWithDecimals memory expiryPrice = priceRegistry
            .getSettlementPriceWithDecimals(
                qToken.oracle(),
                underlyingAsset,
                qToken.expiryTime()
            );

        (payoutToken, payout) = FundsCalculator.getPayout(
            _qToken,
            _amount,
            OPTIONS_DECIMALS,
            strikeAssetDecimals,
            expiryPrice
        );

        payoutAmount = payout.toScaledUint(payoutDecimals, true);
    }
}",1864
RealWorld_TA_98_ProviderOracleManager_RealWorld_20240812085302.log,98,ProviderOracleManager,62481,2503,64984,71.0,0.362465,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""../../interfaces/IQuantConfig.sol"";
import ""../../interfaces/IProviderOracleManager.sol"";

/// @title Oracle manager for holding asset addresses and their oracle addresses for a single provider
/// @author Rolla
/// @notice Once an oracle is added for an asset it can't be changed!
abstract contract ProviderOracleManager is IProviderOracleManager {
    /// @inheritdoc IProviderOracleManager
    IQuantConfig public override config;

    /// @inheritdoc IProviderOracleManager
    mapping(address => address) public override assetOracles;

    /// @inheritdoc IProviderOracleManager
    address[] public override assets;

    constructor(address _config) {
        config = IQuantConfig(_config);
    }

    /// @inheritdoc IProviderOracleManager
    function addAssetOracle(address _asset, address _oracle) external override {
        require(
            config.hasRole(
                config.quantRoles(""ORACLE_MANAGER_ROLE""),
                msg.sender
            ),
            ""ProviderOracleManager: Only an oracle admin can add an oracle""
        );
        require(
            assetOracles[_asset] == address(0),
            ""ProviderOracleManager: Oracle already set for asset""
        );
        assets.push(_asset);
        assetOracles[_asset] = _oracle;

        emit OracleAdded(_asset, _oracle);
    }

    /// @inheritdoc IProviderOracleManager
    function setExpiryPriceInRegistry(
        address _asset,
        uint256 _expiryTimestamp,
        bytes memory _calldata
    ) external virtual override;

    /// @inheritdoc IProviderOracleManager
    function getAssetsLength() external view override returns (uint256) {
        return assets.length;
    }

    /// @inheritdoc IProviderOracleManager
    function getCurrentPrice(address _asset)
        external
        view
        virtual
        override
        returns (uint256);

    function isValidOption(
        address _underlyingAsset,
        uint256 _expiryTime,
        uint256 _strikePrice
    ) public view virtual override returns (bool);

    /// @inheritdoc IProviderOracleManager
    function getAssetOracle(address _asset)
        public
        view
        override
        returns (address)
    {
        address assetOracle = assetOracles[_asset];
        require(
            assetOracles[_asset] != address(0),
            ""ProviderOracleManager: Oracle doesn't exist for that asset""
        );
        return assetOracle;
    }
}",515
RealWorld_TA_98_OptionsFactory_RealWorld_20240812081303.log,98,OptionsFactory,138273,3281,141554,87.0,0.756985,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""../libraries/OptionsUtils.sol"";
import ""../interfaces/IOptionsFactory.sol"";
import ""../interfaces/IQuantConfig.sol"";
import ""../interfaces/IProviderOracleManager.sol"";
import ""../interfaces/IOracleRegistry.sol"";
import ""../interfaces/IAssetsRegistry.sol"";
import ""../interfaces/ICollateralToken.sol"";

/// @title Factory contract for Quant options
/// @author Rolla
/// @notice Creates tokens for long (QToken) and short (CollateralToken) positions
/// @dev This contract follows the factory design pattern
contract OptionsFactory is IOptionsFactory {
    /// @inheritdoc IOptionsFactory
    address[] public override qTokens;

    /// @inheritdoc IOptionsFactory
    address public override strikeAsset;

    IQuantConfig public override quantConfig;

    ICollateralToken public override collateralToken;

    mapping(uint256 => address) private _collateralTokenIdToQTokenAddress;

    /// @inheritdoc IOptionsFactory
    mapping(address => uint256)
        public
        override qTokenAddressToCollateralTokenId;

    /// @notice Initializes a new options factory
    /// @param _strikeAsset address of the asset used to denominate strike prices
    /// for options created through this factory
    /// @param _quantConfig the address of the Quant system configuration contract
    /// @param _collateralToken address of the CollateralToken contract
    constructor(
        address _strikeAsset,
        address _quantConfig,
        address _collateralToken
    ) {
        require(
            _strikeAsset != address(0),
            ""OptionsFactory: invalid strike asset address""
        );
        require(
            _quantConfig != address(0),
            ""OptionsFactory: invalid QuantConfig address""
        );
        require(
            _collateralToken != address(0),
            ""OptionsFactory: invalid CollateralToken address""
        );

        strikeAsset = _strikeAsset;
        quantConfig = IQuantConfig(_quantConfig);
        collateralToken = ICollateralToken(_collateralToken);
    }

    /// @inheritdoc IOptionsFactory
    function createOption(
        address _underlyingAsset,
        address _oracle,
        uint256 _strikePrice,
        uint256 _expiryTime,
        bool _isCall
    )
        external
        override
        returns (address newQToken, uint256 newCollateralTokenId)
    {
        OptionsUtils.validateOptionParameters(
            _underlyingAsset,
            _oracle,
            _expiryTime,
            address(quantConfig),
            _strikePrice
        );

        newCollateralTokenId = OptionsUtils.getTargetCollateralTokenId(
            collateralToken,
            address(quantConfig),
            _underlyingAsset,
            strikeAsset,
            _oracle,
            address(0),
            _strikePrice,
            _expiryTime,
            _isCall
        );

        require(
            _collateralTokenIdToQTokenAddress[newCollateralTokenId] ==
                address(0),
            ""option already created""
        );

        newQToken = address(
            new QToken{salt: OptionsUtils.SALT}(
                address(quantConfig),
                _underlyingAsset,
                strikeAsset,
                _oracle,
                _strikePrice,
                _expiryTime,
                _isCall
            )
        );

        _collateralTokenIdToQTokenAddress[newCollateralTokenId] = newQToken;
        qTokens.push(newQToken);

        qTokenAddressToCollateralTokenId[newQToken] = newCollateralTokenId;

        emit OptionCreated(
            newQToken,
            msg.sender,
            _underlyingAsset,
            _oracle,
            _strikePrice,
            _expiryTime,
            newCollateralTokenId,
            qTokens.length,
            _isCall
        );

        collateralToken.createCollateralToken(newQToken, address(0));
    }

    /// @inheritdoc IOptionsFactory
    function getTargetCollateralTokenId(
        address _underlyingAsset,
        address _oracle,
        address _qTokenAsCollateral,
        uint256 _strikePrice,
        uint256 _expiryTime,
        bool _isCall
    ) external view override returns (uint256) {
        return
            OptionsUtils.getTargetCollateralTokenId(
                collateralToken,
                address(quantConfig),
                _underlyingAsset,
                strikeAsset,
                _oracle,
                _qTokenAsCollateral,
                _strikePrice,
                _expiryTime,
                _isCall
            );
    }

    /// @inheritdoc IOptionsFactory
    function getTargetQTokenAddress(
        address _underlyingAsset,
        address _oracle,
        uint256 _strikePrice,
        uint256 _expiryTime,
        bool _isCall
    ) external view override returns (address) {
        return
            OptionsUtils.getTargetQTokenAddress(
                address(quantConfig),
                _underlyingAsset,
                strikeAsset,
                _oracle,
                _strikePrice,
                _expiryTime,
                _isCall
            );
    }

    /// @inheritdoc IOptionsFactory
    function getCollateralToken(
        address _underlyingAsset,
        address _oracle,
        address _qTokenAsCollateral,
        uint256 _strikePrice,
        uint256 _expiryTime,
        bool _isCall
    ) external view override returns (uint256) {
        address qToken = getQToken(
            _underlyingAsset,
            _oracle,
            _strikePrice,
            _expiryTime,
            _isCall
        );

        uint256 id = collateralToken.getCollateralTokenId(
            qToken,
            _qTokenAsCollateral
        );

        (address storedQToken, ) = collateralToken.idToInfo(id);
        return storedQToken != address(0) ? id : 0;
    }

    /// @inheritdoc IOptionsFactory
    function getOptionsLength() external view override returns (uint256) {
        return qTokens.length;
    }

    /// @inheritdoc IOptionsFactory
    function isQToken(address _qToken) external view override returns (bool) {
        return qTokenAddressToCollateralTokenId[_qToken] != 0;
    }

    /// @inheritdoc IOptionsFactory
    function getQToken(
        address _underlyingAsset,
        address _oracle,
        uint256 _strikePrice,
        uint256 _expiryTime,
        bool _isCall
    ) public view override returns (address) {
        uint256 collateralTokenId = OptionsUtils.getTargetCollateralTokenId(
            collateralToken,
            address(quantConfig),
            _underlyingAsset,
            strikeAsset,
            _oracle,
            address(0),
            _strikePrice,
            _expiryTime,
            _isCall
        );

        return _collateralTokenIdToQTokenAddress[collateralTokenId];
    }
}",1429
RealWorld_TA_98_OracleRegistry_RealWorld_20240812084848.log,98,OracleRegistry,83823,2123,85946,71.0,0.461575,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""../interfaces/IQuantConfig.sol"";
import ""../interfaces/IOracleRegistry.sol"";

/// @title For centrally managing a list of oracle providers
/// @author Rolla
/// @notice oracle provider registry for holding a list of oracle providers and their id
contract OracleRegistry is IOracleRegistry {
    struct OracleInfo {
        bool isActive;
        uint256 oracleId;
    }

    /// @inheritdoc IOracleRegistry
    mapping(address => OracleInfo) public override oracleInfo;

    /// @inheritdoc IOracleRegistry
    address[] public override oracles;

    /// @inheritdoc IOracleRegistry
    IQuantConfig public override config;

    /// @param _config address of quant central configuration
    constructor(address _config) {
        config = IQuantConfig(_config);
    }

    /// @inheritdoc IOracleRegistry
    function addOracle(address _oracle) external override returns (uint256) {
        require(
            config.hasRole(
                config.quantRoles(""ORACLE_MANAGER_ROLE""),
                msg.sender
            ),
            ""OracleRegistry: Only an oracle admin can add an oracle""
        );
        require(
            oracleInfo[_oracle].oracleId == 0,
            ""OracleRegistry: Oracle already exists in registry""
        );

        oracles.push(_oracle);

        uint256 currentId = oracles.length;

        emit AddedOracle(_oracle, currentId);

        config.grantRole(config.quantRoles(""PRICE_SUBMITTER_ROLE""), _oracle);

        oracleInfo[_oracle] = OracleInfo(false, currentId);
        return currentId;
    }

    /// @inheritdoc IOracleRegistry
    function deactivateOracle(address _oracle)
        external
        override
        returns (bool)
    {
        require(
            config.hasRole(
                config.quantRoles(""ORACLE_MANAGER_ROLE""),
                msg.sender
            ),
            ""OracleRegistry: Only an oracle admin can add an oracle""
        );
        require(
            oracleInfo[_oracle].isActive,
            ""OracleRegistry: Oracle is already deactivated""
        );

        emit DeactivatedOracle(_oracle);

        return oracleInfo[_oracle].isActive = false;
    }

    /// @inheritdoc IOracleRegistry
    function activateOracle(address _oracle) external override returns (bool) {
        require(
            config.hasRole(
                config.quantRoles(""ORACLE_MANAGER_ROLE""),
                msg.sender
            ),
            ""OracleRegistry: Only an oracle admin can add an oracle""
        );
        require(
            !oracleInfo[_oracle].isActive,
            ""OracleRegistry: Oracle is already activated""
        );

        emit ActivatedOracle(_oracle);

        return oracleInfo[_oracle].isActive = true;
    }

    /// @inheritdoc IOracleRegistry
    function isOracleRegistered(address _oracle)
        external
        view
        override
        returns (bool)
    {
        return oracleInfo[_oracle].oracleId != 0;
    }

    /// @inheritdoc IOracleRegistry
    function isOracleActive(address _oracle)
        external
        view
        override
        returns (bool)
    {
        return oracleInfo[_oracle].isActive;
    }

    /// @inheritdoc IOracleRegistry
    function getOracleId(address _oracle)
        external
        view
        override
        returns (uint256)
    {
        uint256 oracleId = oracleInfo[_oracle].oracleId;
        require(
            oracleId != 0,
            ""OracleRegistry: Oracle doesn't exist in registry""
        );
        return oracleId;
    }

    /// @inheritdoc IOracleRegistry
    function getOraclesLength() external view override returns (uint256) {
        return oracles.length;
    }
}",762
RealWorld_TA_98_IEIP712MetaTransaction_RealWorld_20240812090213.log,98,IEIP712MetaTransaction,25920,1272,27192,62.0,0.15504,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

interface IEIP712MetaTransaction {
    function executeMetaTransaction(
        address,
        bytes memory,
        bytes32,
        bytes32,
        uint8
    ) external payable returns (bytes memory);

    function initializeEIP712(string memory, string memory) external;

    function getNonce(address) external view returns (uint256);
}",90
RealWorld_TA_98_ProtocolValue_RealWorld_20240812083838.log,98,ProtocolValue,30454,1271,31725,61.0,0.17769,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

/// @title Library for QuantConfig's protocol values
/// @author Rolla
library ProtocolValue {
    enum Type {
        Address,
        Uint256,
        Bool,
        Role
    }

    /// @notice Gets the bytes32 encoded representation of a protocol value name
    /// @param _protocolValue the name of the protocol value
    /// @return the encoded bytes32 representation of the protocol value name
    function encode(string memory _protocolValue)
        internal
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(_protocolValue));
    }
}",146
RealWorld_TA_98_IOptionsFactory_RealWorld_20240812090927.log,98,IOptionsFactory,120629,2171,122800,72.0,0.646565,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import ""./IQuantConfig.sol"";
import ""./ICollateralToken.sol"";

interface IOptionsFactory {
    /// @notice emitted when the factory creates a new option
    event OptionCreated(
        address qTokenAddress,
        address creator,
        address indexed underlying,
        address oracle,
        uint256 strikePrice,
        uint256 expiry,
        uint256 collateralTokenId,
        uint256 allOptionsLength,
        bool isCall
    );

    /// @notice Creates new options (QToken + CollateralToken)
    /// @dev The CREATE2 opcode is used to deterministically deploy new QTokens
    /// @param _underlyingAsset asset that the option references
    /// @param _oracle price oracle for the option underlying
    /// @param _strikePrice strike price with as many decimals in the strike asset
    /// @param _expiryTime expiration timestamp as a unix timestamp
    /// @param _isCall true if it's a call option, false if it's a put option
    function createOption(
        address _underlyingAsset,
        address _oracle,
        uint256 _strikePrice,
        uint256 _expiryTime,
        bool _isCall
    ) external returns (address, uint256);

    /// @notice array of all the created QTokens
    function qTokens(uint256) external view returns (address);

    function quantConfig() external view returns (IQuantConfig);

    function collateralToken() external view returns (ICollateralToken);

    function qTokenAddressToCollateralTokenId(address)
        external
        view
        returns (uint256);

    /// @notice get the address at which a new QToken with the given parameters would be deployed
    /// @notice return the exact address the QToken will be deployed at with OpenZeppelin's Create2
    /// library computeAddress function
    /// @param _underlyingAsset asset that the option references
    /// @param _oracle price oracle for the option underlying
    /// @param _strikePrice strike price with as many decimals in the strike asset
    /// @param _expiryTime expiration timestamp as a unix timestamp
    /// @param _isCall true if it's a call option, false if it's a put option
    /// @return the address where a QToken would be deployed
    function getTargetQTokenAddress(
        address _underlyingAsset,
        address _oracle,
        uint256 _strikePrice,
        uint256 _expiryTime,
        bool _isCall
    ) external view returns (address);

    /// @notice get the id that a CollateralToken with the given parameters would have
    /// @param _underlyingAsset asset that the option references
    /// @param _oracle price oracle for the option underlying
    /// @param _strikePrice strike price with as many decimals in the strike asset
    /// @param _expiryTime expiration timestamp as a unix timestamp
    /// @param _qTokenAsCollateral initial spread collateral
    /// @param _isCall true if it's a call option, false if it's a put option
    /// @return the id that a CollateralToken would have
    function getTargetCollateralTokenId(
        address _underlyingAsset,
        address _oracle,
        address _qTokenAsCollateral,
        uint256 _strikePrice,
        uint256 _expiryTime,
        bool _isCall
    ) external view returns (uint256);

    /// @notice get the CollateralToken id for an already created CollateralToken,
    /// if no QToken has been created with these parameters, it will return 0
    /// @param _underlyingAsset asset that the option references
    /// @param _oracle price oracle for the option underlying
    /// @param _strikePrice strike price with as many decimals in the strike asset
    /// @param _expiryTime expiration timestamp as a unix timestamp
    /// @param _qTokenAsCollateral initial spread collateral
    /// @param _isCall true if it's a call option, false if it's a put option
    /// @return id of the requested CollateralToken
    function getCollateralToken(
        address _underlyingAsset,
        address _oracle,
        address _qTokenAsCollateral,
        uint256 _strikePrice,
        uint256 _expiryTime,
        bool _isCall
    ) external view returns (uint256);

    /// @notice get the QToken address for an already created QToken, if no QToken has been created
    /// with these parameters, it will return the zero address
    /// @param _underlyingAsset asset that the option references
    /// @param _oracle price oracle for the option underlying
    /// @param _strikePrice strike price with as many decimals in the strike asset
    /// @param _expiryTime expiration timestamp as a unix timestamp
    /// @param _isCall true if it's a call option, false if it's a put option
    /// @return address of the requested QToken
    function getQToken(
        address _underlyingAsset,
        address _oracle,
        uint256 _strikePrice,
        uint256 _expiryTime,
        bool _isCall
    ) external view returns (address);

    /// @notice get the total number of options created by the factory
    /// @return length of the options array
    function getOptionsLength() external view returns (uint256);

    /// @notice checks if an address is a QToken
    /// @return true if the given address represents a registered QToken.
    /// false otherwise
    function isQToken(address) external view returns (bool);

    /// @notice get the strike asset used for options created by the factory
    /// @return the strike asset address
    function strikeAsset() external view returns (address);
}",1230
RealWorld_TA_98_IAssetsRegistry_RealWorld_20240812090057.log,98,IAssetsRegistry,60534,1610,62144,74.0,0.33487,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

interface IAssetsRegistry {
    /// @notice emitted when a new asset is added to the registry
    /// @param underlying address of the asset
    /// @param name name of the asset
    /// @param symbol symbol of the asset
    /// @param decimals the amount of decimals the asset has
    event AssetAdded(
        address indexed underlying,
        string name,
        string symbol,
        uint8 decimals
    );

    /// @notice Add a new asset to the registry
    /// @dev It will revert when trying to add an asset with the same address twice
    /// @dev Can only be called by addresses with the ASSETS_REGISTRY_MANAGER_ROLE role
    /// @param _underlying address of the asset
    /// @param _name name of the asset
    /// @param _symbol symbol of the asset
    /// @param _decimals the amount of decimals the asset has
    function addAsset(
        address _underlying,
        string calldata _name,
        string calldata _symbol,
        uint8 _decimals
    ) external;

    /// @notice Add a new asset to the registry, calling the optional ERC20 methods
    /// to get its name, symbol and decimals
    /// @param _underlying address of the asset
    function addAssetWithOptionalERC20Methods(address _underlying) external;

    /// @notice Returns the name, symbol and decimals of an asset that's already in the registry
    /// @dev Will return empty strings and zero for non-existent assets
    /// @return name asset's name
    /// @return symbol asset's symbol
    /// @return decimals asset's decimals
    function assetProperties(address asset)
        external
        view
        returns (
            string memory name,
            string memory symbol,
            uint8 decimals
        );

    /// @notice Returns the address of the asset at the given index
    /// @param index index of the asset in the registry
    /// @return asset address of the asset at the given index
    function registeredAssets(uint256 index)
        external
        view
        returns (address asset);

    /// @notice Returns the number of assets in the registry
    /// @return length number of assets in the registry
    function getAssetsLength() external view returns (uint256 length);
}",500
RealWorld_TA_98_EIP712MetaTransaction_RealWorld_20240812084538.log,98,EIP712MetaTransaction,157958,2887,160845,84.0,0.84753,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol"";
import ""@openzeppelin/contracts/utils/cryptography/ECDSA.sol"";
import ""../interfaces/IEIP712MetaTransaction.sol"";
import ""../interfaces/IController.sol"";
import ""../libraries/Actions.sol"";
import {ActionArgs} from ""../libraries/Actions.sol"";

/// @title Contract to be inherited by contracts that want to support meta transactions.
/// @author Rolla
contract EIP712MetaTransaction is EIP712Upgradeable {
    using ECDSA for bytes32;

    struct MetaAction {
        uint256 nonce;
        uint256 deadline;
        address from;
        ActionArgs[] actions;
    }

    bytes32 private constant _META_ACTION_TYPEHASH =
        keccak256(
            // solhint-disable-next-line max-line-length
            ""MetaAction(uint256 nonce,uint256 deadline,address from,ActionArgs[] actions)ActionArgs(uint8 actionType,address qToken,address secondaryAddress,address receiver,uint256 amount,uint256 collateralTokenId,bytes data)""
        );
    bytes32 private constant _ACTION_TYPEHASH =
        keccak256(
            // solhint-disable-next-line max-line-length
            ""ActionArgs(uint8 actionType,address qToken,address secondaryAddress,address receiver,uint256 amount,uint256 collateralTokenId,bytes data)""
        );

    mapping(address => uint256) private _nonces;

    /// @notice user readable name of signing domain for EIP712 (the protocol name)
    string public name;

    /// @notice the current major version of the signing domain for EIP712
    string public version;

    /// @notice emitted when a meta transaction is executed
    event MetaTransactionExecuted(
        address indexed userAddress,
        address payable indexed relayerAddress,
        uint256 nonce
    );

    /// @notice Given an encoded action and a signature, executes the action on behalf of the signer.
    /// @param metaAction The encoded action to be executed.
    /// @param r The r-value of the signature.
    /// @param s The s-value of the signature.
    /// @param v The v-value of the signature.
    /// @return The returned data from the low-level call.
    function executeMetaTransaction(
        MetaAction memory metaAction,
        bytes32 r,
        bytes32 s,
        uint8 v
    ) external payable returns (bytes memory) {
        require(
            _verify(metaAction.from, metaAction, r, s, v),
            ""signer and signature don't match""
        );

        uint256 currentNonce = _nonces[metaAction.from];

        // intentionally allow this to overflow to save gas,
        // and it's impossible for someone to do 2 ^ 256 - 1 meta txs
        unchecked {
            _nonces[metaAction.from] = currentNonce + 1;
        }

        // Append the metaAction.from at the end so that it can be extracted later
        // from the calling context (see _msgSender() below)
        (bool success, bytes memory returnData) = address(this).call(
            abi.encodePacked(
                abi.encodeWithSelector(
                    IController(address(this)).operate.selector,
                    metaAction.actions
                ),
                metaAction.from
            )
        );

        require(success, ""unsuccessful function call"");
        emit MetaTransactionExecuted(
            metaAction.from,
            payable(msg.sender),
            currentNonce
        );
        return returnData;
    }

    /// @notice Returns the current nonce for a user.
    /// @param user the address of the user to get the nonce for.
    /// @return nonce the current nonce for the user.
    function getNonce(address user) external view returns (uint256 nonce) {
        nonce = _nonces[user];
    }

    /// @notice initialize method for EIP712Upgradeable
    /// @dev called once after initial deployment and every upgrade.
    /// @param _name the user readable name of the signing domain for EIP712
    /// @param _version the current major version of the signing domain for EIP712
    function initializeEIP712(string memory _name, string memory _version)
        public
        initializer
    {
        name = _name;
        version = _version;

        __EIP712_init(_name, _version);
    }

    /// @notice Returns the address of the signer when called from this contract,
    /// otherwise returns the msg.sender
    /// @return sender the address of the signer or msg.sender
    function _msgSender() internal view returns (address sender) {
        if (msg.sender == address(this)) {
            bytes memory array = msg.data;
            uint256 index = msg.data.length;
            assembly {
                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.
                sender := and(
                    mload(add(array, index)),
                    0xffffffffffffffffffffffffffffffffffffffff
                )
            }
        } else {
            sender = msg.sender;
        }
        return sender;
    }

    /// @notice Verifies that the signature is valid for a given user and action.
    /// @param user the address to check as the signer.
    /// @param metaAction the action struct to check.
    /// @param r the r-value of the signature.
    /// @param s the s-value of the signature.
    /// @param v the v-value of the signature.
    function _verify(
        address user,
        MetaAction memory metaAction,
        bytes32 r,
        bytes32 s,
        uint8 v
    ) internal view returns (bool) {
        require(metaAction.nonce == _nonces[user], ""invalid nonce"");

        require(metaAction.deadline >= block.timestamp, ""expired deadline"");

        address signer = _hashTypedDataV4(_hashMetaAction(metaAction)).recover(
            v,
            r,
            s
        );

        return signer == user;
    }

    /// @notice Hashes a given ActionArgs struct to be used with EIP712.
    /// @param action the ActionArgs struct to hash.
    /// @return the hash of the ActionArgs struct.
    function _hashAction(ActionArgs memory action)
        private
        pure
        returns (bytes32)
    {
        return
            keccak256(
                abi.encode(
                    _ACTION_TYPEHASH,
                    action.actionType,
                    action.qToken,
                    action.secondaryAddress,
                    action.receiver,
                    action.amount,
                    action.collateralTokenId,
                    keccak256(action.data)
                )
            );
    }

    /// @notice Hashes an array of ActionArgs structs to be used with EIP712.
    /// @param actions the array of ActionArgs structs to hash.
    /// @return the array of hashes for the ActionArgs structs.
    function _hashActions(ActionArgs[] memory actions)
        private
        pure
        returns (bytes32[] memory)
    {
        bytes32[] memory hashedActions = new bytes32[](actions.length);
        uint256 length = actions.length;
        for (uint256 i = 0; i < length; ) {
            hashedActions[i] = _hashAction(actions[i]);
            unchecked {
                ++i;
            }
        }
        return hashedActions;
    }

    /// @notice Hashes a MetaAction struct to be used with EIP712.
    /// @param metaAction the MetaAction struct to hash.
    /// @return the hash of the MetaAction struct.
    function _hashMetaAction(MetaAction memory metaAction)
        private
        pure
        returns (bytes32)
    {
        return
            keccak256(
                abi.encode(
                    _META_ACTION_TYPEHASH,
                    metaAction.nonce,
                    metaAction.deadline,
                    metaAction.from,
                    keccak256(
                        abi.encodePacked(_hashActions(metaAction.actions))
                    )
                )
            );
    }
}",1658
RealWorld_TA_98_QuantConfig_RealWorld_20240812080724.log,98,QuantConfig,140555,3160,143715,92.0,0.765975,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""./libraries/ProtocolValue.sol"";
import ""./interfaces/ITimelockedConfig.sol"";

/// @title A central config for the Quant Protocol. Also acts as a central access control manager.
/// @author Rolla
/// @notice For storing constants, variables and allowing them to be changed by the admin (governance)
/// @dev This should be used as a central access control manager which other contracts use to check permissions
contract QuantConfig is
    AccessControlUpgradeable,
    OwnableUpgradeable,
    ITimelockedConfig
{
    /// @inheritdoc ITimelockedConfig
    address payable public override timelockController;

    /// @inheritdoc ITimelockedConfig
    mapping(bytes32 => address) public override protocolAddresses;
    /// @inheritdoc ITimelockedConfig
    bytes32[] public override configuredProtocolAddresses;

    /// @inheritdoc ITimelockedConfig
    mapping(bytes32 => uint256) public override protocolUints256;
    /// @inheritdoc ITimelockedConfig
    bytes32[] public override configuredProtocolUints256;

    /// @inheritdoc ITimelockedConfig
    mapping(bytes32 => bool) public override protocolBooleans;
    /// @inheritdoc ITimelockedConfig
    bytes32[] public override configuredProtocolBooleans;

    /// @inheritdoc ITimelockedConfig
    mapping(string => bytes32) public override quantRoles;
    /// @inheritdoc ITimelockedConfig
    bytes32[] public override configuredQuantRoles;

    /// @inheritdoc ITimelockedConfig
    mapping(bytes32 => mapping(ProtocolValue.Type => bool))
        public
        override isProtocolValueSet;

    /// @inheritdoc ITimelockedConfig
    function setProtocolAddress(bytes32 _protocolAddress, address _newValue)
        external
        override
        onlyOwner
    {
        require(
            _protocolAddress != ProtocolValue.encode(""priceRegistry"") ||
                !protocolBooleans[ProtocolValue.encode(""isPriceRegistrySet"")],
            ""QuantConfig: priceRegistry can only be set once""
        );
        address previousValue = protocolAddresses[_protocolAddress];
        protocolAddresses[_protocolAddress] = _newValue;
        configuredProtocolAddresses.push(_protocolAddress);
        isProtocolValueSet[_protocolAddress][ProtocolValue.Type.Address] = true;

        if (_protocolAddress == ProtocolValue.encode(""priceRegistry"")) {
            protocolBooleans[ProtocolValue.encode(""isPriceRegistrySet"")] = true;
        }

        emit SetProtocolAddress(_protocolAddress, previousValue, _newValue);
    }

    /// @inheritdoc ITimelockedConfig
    function setProtocolUint256(bytes32 _protocolUint256, uint256 _newValue)
        external
        override
        onlyOwner
    {
        uint256 previousValue = protocolUints256[_protocolUint256];
        protocolUints256[_protocolUint256] = _newValue;
        configuredProtocolUints256.push(_protocolUint256);
        isProtocolValueSet[_protocolUint256][ProtocolValue.Type.Uint256] = true;

        emit SetProtocolUint256(_protocolUint256, previousValue, _newValue);
    }

    /// @inheritdoc ITimelockedConfig
    function setProtocolBoolean(bytes32 _protocolBoolean, bool _newValue)
        external
        override
        onlyOwner
    {
        require(
            _protocolBoolean != ProtocolValue.encode(""isPriceRegistrySet"") ||
                !protocolBooleans[ProtocolValue.encode(""isPriceRegistrySet"")],
            ""QuantConfig: can only change isPriceRegistrySet once""
        );
        bool previousValue = protocolBooleans[_protocolBoolean];
        protocolBooleans[_protocolBoolean] = _newValue;
        configuredProtocolBooleans.push(_protocolBoolean);
        isProtocolValueSet[_protocolBoolean][ProtocolValue.Type.Bool] = true;

        emit SetProtocolBoolean(_protocolBoolean, previousValue, _newValue);
    }

    /// @inheritdoc ITimelockedConfig
    function setProtocolRole(string calldata _protocolRole, address _roleAdmin)
        external
        override
        onlyOwner
    {
        _setProtocolRole(_protocolRole, _roleAdmin);
    }

    /// @inheritdoc ITimelockedConfig
    function setRoleAdmin(bytes32 role, bytes32 adminRole)
        external
        override
        onlyOwner
    {
        _setRoleAdmin(role, adminRole);

        emit SetRoleAdmin(role, adminRole);
    }

    /// @inheritdoc ITimelockedConfig
    function protocolAddressesLength()
        external
        view
        override
        returns (uint256)
    {
        return configuredProtocolAddresses.length;
    }

    /// @inheritdoc ITimelockedConfig
    function protocolUints256Length() external view override returns (uint256) {
        return configuredProtocolUints256.length;
    }

    /// @inheritdoc ITimelockedConfig
    function protocolBooleansLength() external view override returns (uint256) {
        return configuredProtocolBooleans.length;
    }

    /// @inheritdoc ITimelockedConfig
    function quantRolesLength() external view override returns (uint256) {
        return configuredQuantRoles.length;
    }

    /// @inheritdoc ITimelockedConfig
    function initialize(address payable _timelockController)
        public
        override
        initializer
    {
        require(
            _timelockController != address(0),
            ""QuantConfig: invalid TimelockController address""
        );

        __AccessControl_init();
        __Ownable_init_unchained();
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(DEFAULT_ADMIN_ROLE, _timelockController);

        string memory oracleManagerRole = ""ORACLE_MANAGER_ROLE"";
        _setProtocolRole(oracleManagerRole, _timelockController);
        _setProtocolRole(oracleManagerRole, _msgSender());
        timelockController = _timelockController;
    }

    /// @notice Sets a new protocol role, while also assigning a role admin
    /// @dev If the role already exists in the config, only the role admin will be changed
    function _setProtocolRole(string memory _protocolRole, address _roleAdmin)
        internal
    {
        bytes32 role = keccak256(abi.encodePacked(_protocolRole));
        grantRole(role, _roleAdmin);
        if (quantRoles[_protocolRole] == bytes32(0)) {
            quantRoles[_protocolRole] = role;
            configuredQuantRoles.push(role);
            isProtocolValueSet[role][ProtocolValue.Type.Role] = true;
        }

        emit SetProtocolRole(_protocolRole, role, _roleAdmin);
    }
}",1429
RealWorld_TA_98_ICollateralToken_RealWorld_20240812091157.log,98,ICollateralToken,139299,2655,141954,81.0,0.749595,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC1155/IERC1155.sol"";
import ""./IQuantConfig.sol"";
import ""./IQToken.sol"";

/// @title Tokens representing a Quant user's short positions
/// @author Rolla
/// @notice Can be used by owners to claim their collateral
interface ICollateralToken is IERC1155 {
    struct QTokensDetails {
        address underlyingAsset;
        address strikeAsset;
        address oracle;
        uint256 shortStrikePrice;
        uint256 longStrikePrice;
        uint256 expiryTime;
        bool isCall;
    }

    /// @notice event emitted when a new CollateralToken is created
    /// @param qTokenAddress address of the corresponding QToken
    /// @param qTokenAsCollateral QToken address of an option used as collateral in a spread
    /// @param id unique id of the created CollateralToken
    /// @param allCollateralTokensLength the updated number of already created CollateralTokens
    event CollateralTokenCreated(
        address indexed qTokenAddress,
        address qTokenAsCollateral,
        uint256 id,
        uint256 allCollateralTokensLength
    );

    /// @notice event emitted when CollateralTokens are minted
    /// @param recipient address that received the minted CollateralTokens
    /// @param id unique id of the minted CollateralToken
    /// @param amount the amount of CollateralToken minted
    event CollateralTokenMinted(
        address indexed recipient,
        uint256 indexed id,
        uint256 amount
    );

    /// @notice event emitted when CollateralTokens are burned
    /// @param owner address that the CollateralToken was burned from
    /// @param id unique id of the burned CollateralToken
    /// @param amount the amount of CollateralToken burned
    event CollateralTokenBurned(
        address indexed owner,
        uint256 indexed id,
        uint256 amount
    );

    /// @notice Create new CollateralTokens
    /// @param _qTokenAddress address of the corresponding QToken
    /// @param _qTokenAsCollateral QToken address of an option used as collateral in a spread
    /// @return id the id for the CollateralToken created with the given arguments
    function createCollateralToken(
        address _qTokenAddress,
        address _qTokenAsCollateral
    ) external returns (uint256 id);

    /// @notice Mint CollateralTokens for a given account
    /// @param recipient address to receive the minted tokens
    /// @param amount amount of tokens to mint
    /// @param collateralTokenId id of the token to be minted
    function mintCollateralToken(
        address recipient,
        uint256 collateralTokenId,
        uint256 amount
    ) external;

    /// @notice Mint CollateralTokens for a given account
    /// @param owner address to burn tokens from
    /// @param amount amount of tokens to burn
    /// @param collateralTokenId id of the token to be burned
    function burnCollateralToken(
        address owner,
        uint256 collateralTokenId,
        uint256 amount
    ) external;

    /// @notice Batched minting of multiple CollateralTokens for a given account
    /// @dev Should be used when minting multiple CollateralTokens for a single user,
    /// i.e., when a user buys more than one short position through the interface
    /// @param recipient address to receive the minted tokens
    /// @param ids array of CollateralToken ids to be minted
    /// @param amounts array of amounts of tokens to be minted
    /// @dev ids and amounts must have the same length
    function mintCollateralTokenBatch(
        address recipient,
        uint256[] calldata ids,
        uint256[] calldata amounts
    ) external;

    /// @notice Batched burning of multiple CollateralTokens from a given account
    /// @dev Should be used when burning multiple CollateralTokens for a single user,
    /// i.e., when a user sells more than one short position through the interface
    /// @param owner address to burn tokens from
    /// @param ids array of CollateralToken ids to be burned
    /// @param amounts array of amounts of tokens to be burned
    /// @dev ids and amounts shoud have the same length
    function burnCollateralTokenBatch(
        address owner,
        uint256[] calldata ids,
        uint256[] calldata amounts
    ) external;

    /// @notice Set approval for all IDs by providing parameters to setApprovalForAll
    /// alongside a valid signature (r, s, v)
    /// @dev This method is implemented by following EIP-712: https://eips.ethereum.org/EIPS/eip-712
    /// @param owner     Address that wants to set operator status
    /// @param operator  Address to add to the set of authorized operators
    /// @param approved  True if the operator is approved, false to revoke approval
    /// @param nonce     Nonce valid for the owner at the time of the meta-tx execution
    /// @param deadline  Maximum unix timestamp at which the signature is still valid
    /// @param v         Last byte of the signed data
    /// @param r         The first 64 bytes of the signed data
    /// @param s         Bytes 64128 of the signed data
    function metaSetApprovalForAll(
        address owner,
        address operator,
        bool approved,
        uint256 nonce,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /// @notice The Quant system config
    function quantConfig() external view returns (IQuantConfig);

    /// @notice mapping of CollateralToken ids to their respective info struct
    function idToInfo(uint256) external view returns (address, address);

    /// @notice array of all the created CollateralToken ids
    function collateralTokenIds(uint256) external view returns (uint256);

    /// @notice get the total amount of collateral tokens created
    function getCollateralTokensLength() external view returns (uint256);

    /// @notice get the details of the QTokens related to a given CollateralToken id
    function getCollateralTokenInfo(uint256 id)
        external
        view
        returns (QTokensDetails memory);

    /// @notice Returns a unique CollateralToken id based on its parameters
    /// @param _qToken the address of the corresponding QToken
    /// @param _qTokenAsCollateral QToken address of an option used as collateral in a spread
    /// @return id the id for the CollateralToken with the given arguments
    function getCollateralTokenId(address _qToken, address _qTokenAsCollateral)
        external
        pure
        returns (uint256 id);
}",1470
RealWorld_TA_98_IController_RealWorld_20240812091433.log,98,IController,105091,1287,106378,71.0,0.551195,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import ""../libraries/Actions.sol"";

interface IController {
    /// @notice emitted after a new position is created
    /// @param mintedTo address that received both QTokens and CollateralTokens
    /// @param minter address that provided collateral and created the position
    /// @param qToken address of the QToken minted
    /// @param optionsAmount amount of options minted
    /// @param collateralAsset asset provided as collateral to create the position
    /// @param collateralAmount amount of collateral provided
    event OptionsPositionMinted(
        address indexed mintedTo,
        address indexed minter,
        address indexed qToken,
        uint256 optionsAmount,
        address collateralAsset,
        uint256 collateralAmount
    );

    /// @notice emitted after a spread position is created
    /// @param account address that created the spread position, receiving both QTokens and CollateralTokens
    /// @param qTokenToMint QToken of the option the position is going long on
    /// @param qTokenForCollateral QToken of the option the position is shorting
    /// @param optionsAmount amount of qTokenToMint options minted
    /// @param collateralAsset asset provided as collateral to create the position (if debit spread)
    /// @param collateralAmount amount of collateral provided (if debit spread)
    event SpreadMinted(
        address indexed account,
        address indexed qTokenToMint,
        address indexed qTokenForCollateral,
        uint256 optionsAmount,
        address collateralAsset,
        uint256 collateralAmount
    );

    /// @notice emitted after a QToken is used to close a long position after expiry
    /// @param account address that used the QToken to exercise the position
    /// @param qToken address of the QToken representing the long position
    /// @param amountExercised amount of options exercised
    /// @param payout amount received from exercising the options
    /// @param payoutAsset asset received after exercising the options
    event OptionsExercised(
        address indexed account,
        address indexed qToken,
        uint256 amountExercised,
        uint256 payout,
        address payoutAsset
    );

    /// @notice emitted after both QTokens and CollateralTokens are used to claim the initial collateral
    /// that was used to create the position
    /// @param account address that used the QTokens and CollateralTokens to claim the collateral
    /// @param qToken address of the QToken representing the long position
    /// @param amountNeutralized amount of options that were used to claim the collateral
    /// @param collateralReclaimed amount of collateral returned
    /// @param collateralAsset asset returned after claiming the collateral
    /// @param longTokenReturned QToken returned if neutralizing a spread position
    event NeutralizePosition(
        address indexed account,
        address qToken,
        uint256 amountNeutralized,
        uint256 collateralReclaimed,
        address collateralAsset,
        address longTokenReturned
    );

    /// @notice emitted after a CollateralToken is used to close a short position after expiry
    /// @param account address that used the CollateralToken to close the position
    /// @param collateralTokenId ERC1155 id of the CollateralToken representing the short position
    /// @param amountClaimed amount of CollateralToken used to close the position
    /// @param collateralReturned amount returned of the asset used to mint the option
    /// @param collateralAsset asset returned after claiming the collateral, i.e. the same used when minting the option
    event CollateralClaimed(
        address indexed account,
        uint256 indexed collateralTokenId,
        uint256 amountClaimed,
        uint256 collateralReturned,
        address collateralAsset
    );

    /// @notice The main entry point in the Quant Protocol. This function takes an array of actions
    /// and executes them in order. Actions are passed encoded as ActionArgs structs, and then for each
    /// different action, the relevant arguments are parsed and passed to the respective internal function
    /// @dev For documentation of each individual action, see the corresponding internal function in Controller.sol
    /// @param _actions array of ActionArgs structs, each representing an action to be executed
    /// @return boolean indicating whether the actions were successfully executed
    function operate(ActionArgs[] memory _actions) external returns (bool);

    /// @notice Upgradable proxy initialization function called during deployment and upgrades
    function initialize(
        string memory,
        string memory,
        address,
        address
    ) external;

    /// @notice Address of the OptionsFactory contract
    function optionsFactory() external view returns (address);

    /// @notice Address of th OperateProxy contract deployed through the initialize function
    function operateProxy() external view returns (address);

    /// @notice Address of the QuantCalculator being used
    function quantCalculator() external view returns (address);
}",1044
RealWorld_TA_98_IEACAggregatorProxy_RealWorld_20240812091546.log,98,IEACAggregatorProxy,64911,1703,66614,67.0,0.358615,"// SPDX-License-Identifier: BUSL-1.1
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol. SEE BELOW FOR SOURCE. !!
pragma solidity ^0.8.0;

interface IEACAggregatorProxy {
    event AnswerUpdated(
        int256 indexed current,
        uint256 indexed roundId,
        uint256 updatedAt
    );
    event NewRound(
        uint256 indexed roundId,
        address indexed startedBy,
        uint256 startedAt
    );
    event OwnershipTransferRequested(address indexed from, address indexed to);
    event OwnershipTransferred(address indexed from, address indexed to);

    function acceptOwnership() external;

    function confirmAggregator(address _aggregator) external;

    function proposeAggregator(address _aggregator) external;

    function setController(address _accessController) external;

    function transferOwnership(address _to) external;

    function accessController() external view returns (address);

    function aggregator() external view returns (address);

    function decimals() external view returns (uint8);

    function description() external view returns (string memory);

    function getAnswer(uint256 _roundId) external view returns (int256);

    function getRoundData(uint80 _roundId)
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );

    function getTimestamp(uint256 _roundId) external view returns (uint256);

    function latestAnswer() external view returns (int256);

    function latestRound() external view returns (uint256);

    function latestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );

    function latestTimestamp() external view returns (uint256);

    function owner() external view returns (address);

    function phaseAggregators(uint16) external view returns (address);

    function phaseId() external view returns (uint16);

    function proposedAggregator() external view returns (address);

    function proposedGetRoundData(uint80 _roundId)
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );

    function proposedLatestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );

    function version() external view returns (uint256);
}",548
RealWorld_TA_98_SignedConverter_RealWorld_20240812083721.log,98,SignedConverter,37341,1635,38976,75.0,0.219405,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

/**
 * @title SignedConverter
 * @author Rolla
 * @notice A library to convert an unsigned integer to signed integer or signed integer to unsigned integer.
 */
library SignedConverter {
    /**
     * @notice convert an unsigned integer to a signed integer
     * @param a uint to convert into a signed integer
     * @return converted signed integer
     */
    function uintToInt(uint256 a) internal pure returns (int256) {
        require(a < 2**255, ""QuantMath: out of int range"");

        return int256(a);
    }

    /**
     * @notice convert a signed integer to an unsigned integer
     * @param a int to convert into an unsigned integer
     * @return converted unsigned integer
     */
    function intToUint(int256 a) internal pure returns (uint256) {
        if (a < 0) {
            return uint256(-a);
        } else {
            return uint256(a);
        }
    }
}",225
RealWorld_TA_98_QuantMath_RealWorld_20240812084257.log,98,QuantMath,175076,2859,177935,86.0,0.93256,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""./SignedConverter.sol"";

/**
 * @title QuantMath
 * @author Rolla
 * @notice FixedPoint library
 */
library QuantMath {
    using SignedConverter for int256;
    using SignedConverter for uint256;

    struct FixedPointInt {
        int256 value;
    }

    int256 private constant _SCALING_FACTOR = 1e27;
    uint256 private constant _BASE_DECIMALS = 27;

    /**
     * @notice constructs an `FixedPointInt` from an unscaled int, e.g., `b=5` gets stored internally as `5**27`.
     * @param a int to convert into a FixedPoint.
     * @return the converted FixedPoint.
     */
    function fromUnscaledInt(int256 a)
        internal
        pure
        returns (FixedPointInt memory)
    {
        return FixedPointInt(a * _SCALING_FACTOR);
    }

    /**
     * @notice constructs an FixedPointInt from an scaled uint with {_decimals} decimals
     * Examples:
     * (1)  USDC    decimals = 6
     *      Input:  5 * 1e6 USDC  =>    Output: 5 * 1e27 (FixedPoint 8.0 USDC)
     * (2)  cUSDC   decimals = 8
     *      Input:  5 * 1e6 cUSDC =>    Output: 5 * 1e25 (FixedPoint 0.08 cUSDC)
     * @param _a uint256 to convert into a FixedPoint.
     * @param _decimals  original decimals _a has
     * @return the converted FixedPoint, with 27 decimals.
     */
    function fromScaledUint(uint256 _a, uint256 _decimals)
        internal
        pure
        returns (FixedPointInt memory)
    {
        FixedPointInt memory fixedPoint;

        if (_decimals == _BASE_DECIMALS) {
            fixedPoint = FixedPointInt(_a.uintToInt());
        } else if (_decimals > _BASE_DECIMALS) {
            uint256 exp = _decimals - _BASE_DECIMALS;
            fixedPoint = FixedPointInt((_a / 10**exp).uintToInt());
        } else {
            uint256 exp = _BASE_DECIMALS - _decimals;
            fixedPoint = FixedPointInt((_a * 10**exp).uintToInt());
        }

        return fixedPoint;
    }

    /**
     * @notice convert a FixedPointInt number to an uint256 with a specific number of decimals
     * @param _a FixedPointInt to convert
     * @param _decimals number of decimals that the uint256 should be scaled to
     * @param _roundDown True to round down the result, False to round up
     * @return the converted uint256
     */
    function toScaledUint(
        FixedPointInt memory _a,
        uint256 _decimals,
        bool _roundDown
    ) internal pure returns (uint256) {
        uint256 scaledUint;

        if (_decimals == _BASE_DECIMALS) {
            scaledUint = _a.value.intToUint();
        } else if (_decimals > _BASE_DECIMALS) {
            uint256 exp = _decimals - _BASE_DECIMALS;
            scaledUint = (_a.value).intToUint() * 10**exp;
        } else {
            uint256 exp = _BASE_DECIMALS - _decimals;
            uint256 tailing;
            if (!_roundDown) {
                uint256 remainer = (_a.value).intToUint() % 10**exp;
                if (remainer > 0) tailing = 1;
            }
            scaledUint = (_a.value).intToUint() / 10**exp + tailing;
        }

        return scaledUint;
    }

    /**
     * @notice add two signed integers, a + b
     * @param a FixedPointInt
     * @param b FixedPointInt
     * @return sum of the two signed integers
     */
    function add(FixedPointInt memory a, FixedPointInt memory b)
        internal
        pure
        returns (FixedPointInt memory)
    {
        return FixedPointInt(a.value + b.value);
    }

    /**
     * @notice subtract two signed integers, a-b
     * @param a FixedPointInt
     * @param b FixedPointInt
     * @return difference of two signed integers
     */
    function sub(FixedPointInt memory a, FixedPointInt memory b)
        internal
        pure
        returns (FixedPointInt memory)
    {
        return FixedPointInt(a.value - b.value);
    }

    /**
     * @notice multiply two signed integers, a by b
     * @param a FixedPointInt
     * @param b FixedPointInt
     * @return mul of two signed integers
     */
    function mul(FixedPointInt memory a, FixedPointInt memory b)
        internal
        pure
        returns (FixedPointInt memory)
    {
        return FixedPointInt((a.value * b.value) / _SCALING_FACTOR);
    }

    /**
     * @notice divide two signed integers, a by b
     * @param a FixedPointInt
     * @param b FixedPointInt
     * @return div of two signed integers
     */
    function div(FixedPointInt memory a, FixedPointInt memory b)
        internal
        pure
        returns (FixedPointInt memory)
    {
        return FixedPointInt((a.value * _SCALING_FACTOR) / b.value);
    }

    /**
     * @notice minimum between two signed integers, a and b
     * @param a FixedPointInt
     * @param b FixedPointInt
     * @return min of two signed integers
     */
    function min(FixedPointInt memory a, FixedPointInt memory b)
        internal
        pure
        returns (FixedPointInt memory)
    {
        return a.value < b.value ? a : b;
    }

    /**
     * @notice maximum between two signed integers, a and b
     * @param a FixedPointInt
     * @param b FixedPointInt
     * @return max of two signed integers
     */
    function max(FixedPointInt memory a, FixedPointInt memory b)
        internal
        pure
        returns (FixedPointInt memory)
    {
        return a.value > b.value ? a : b;
    }

    /**
     * @notice is a is equal to b
     * @param a FixedPointInt
     * @param b FixedPointInt
     * @return True if equal, False if not
     */
    function isEqual(FixedPointInt memory a, FixedPointInt memory b)
        internal
        pure
        returns (bool)
    {
        return a.value == b.value;
    }

    /**
     * @notice is a greater than b
     * @param a FixedPointInt
     * @param b FixedPointInt
     * @return True if a > b, False if not
     */
    function isGreaterThan(FixedPointInt memory a, FixedPointInt memory b)
        internal
        pure
        returns (bool)
    {
        return a.value > b.value;
    }

    /**
     * @notice is a greater than or equal to b
     * @param a FixedPointInt
     * @param b FixedPointInt
     * @return True if a >= b, False if not
     */
    function isGreaterThanOrEqual(
        FixedPointInt memory a,
        FixedPointInt memory b
    ) internal pure returns (bool) {
        return a.value >= b.value;
    }

    /**
     * @notice is a is less than b
     * @param a FixedPointInt
     * @param b FixedPointInt
     * @return True if a < b, False if not
     */
    function isLessThan(FixedPointInt memory a, FixedPointInt memory b)
        internal
        pure
        returns (bool)
    {
        return a.value < b.value;
    }

    /**
     * @notice is a less than or equal to b
     * @param a FixedPointInt
     * @param b FixedPointInt
     * @return True if a <= b, False if not
     */
    function isLessThanOrEqual(FixedPointInt memory a, FixedPointInt memory b)
        internal
        pure
        returns (bool)
    {
        return a.value <= b.value;
    }
}",1843
RealWorld_TA_98_ChainlinkFixedTimeOracleManager_RealWorld_20240812085127.log,98,ChainlinkFixedTimeOracleManager,74036,2673,76709,92.0,0.42364,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""./ChainlinkOracleManager.sol"";
import ""../../interfaces/external/chainlink/IEACAggregatorProxy.sol"";
import ""../../interfaces/IChainlinkFixedTimeOracleManager.sol"";

/// @title For managing Chainlink oracles with updates at fixed times.
/// @author Rolla
/// @notice Update times are counted as seconds since the start of the day.
contract ChainlinkFixedTimeOracleManager is
    ChainlinkOracleManager,
    IChainlinkFixedTimeOracleManager
{
    mapping(uint256 => bool) public override chainlinkFixedTimeUpdates;

    /// @param _config address of quant central configuration
    /// @param _fallbackPeriodSeconds amount of seconds before fallback price submitter can submit
    constructor(
        address _config,
        uint8 _strikeAssetDecimals,
        uint256 _fallbackPeriodSeconds
    )
        ChainlinkOracleManager(
            _config,
            _strikeAssetDecimals,
            _fallbackPeriodSeconds
        )
    // solhint-disable-next-line no-empty-blocks
    {

    }

    /// @inheritdoc IChainlinkFixedTimeOracleManager
    function setFixedTimeUpdate(uint256 fixedTime, bool isValidTime)
        external
        override
    {
        require(
            config.hasRole(
                config.quantRoles(""ORACLE_MANAGER_ROLE""),
                msg.sender
            ),
            ""ChainlinkFixedTimeOracleManager: Only an oracle admin can add a fixed time for updates""
        );

        chainlinkFixedTimeUpdates[fixedTime] = isValidTime;

        emit FixedTimeUpdate(fixedTime, isValidTime);
    }

    /// @inheritdoc IProviderOracleManager
    function isValidOption(
        address,
        uint256 _expiryTime,
        uint256
    )
        public
        view
        override(ChainlinkOracleManager, IProviderOracleManager)
        returns (bool)
    {
        uint256 timeInSeconds = _expiryTime % 86400;
        return chainlinkFixedTimeUpdates[timeInSeconds];
    }

    /// @notice Gets the price and roundId for a given expiry time.
    /// @param aggregator address of the Chainlink aggregator proxy contract
    /// @param _expiryTimestamp option expiration timestamp in seconds since the Unix epoch
    /// @param _roundIdAfterExpiry id of the round right after the expiry
    /// @param _expiryRoundId id of the round right before or at the expiry
    function _getExpiryPrice(
        IEACAggregatorProxy aggregator,
        uint256 _expiryTimestamp,
        uint256 _roundIdAfterExpiry,
        uint256 _expiryRoundId
    ) internal view override returns (uint256 price, uint256 roundId) {
        if (
            aggregator.getTimestamp(uint256(_expiryRoundId)) == _expiryTimestamp
        ) {
            price = uint256(aggregator.getAnswer(_expiryRoundId));
            roundId = _expiryRoundId;
        } else {
            price = uint256(aggregator.getAnswer(_roundIdAfterExpiry));
            roundId = _roundIdAfterExpiry;
        }
    }
}",650
RealWorld_TA_98_QuantMathTester_RealWorld_20240812081949.log,98,QuantMathTester,76070,1351,77421,70.0,0.40737,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""../libraries/QuantMath.sol"";

contract QuantMathTester {
    using QuantMath for QuantMath.FixedPointInt;

    function testFromUnscaledInt(int256 a)
        external
        pure
        returns (QuantMath.FixedPointInt memory)
    {
        return QuantMath.fromUnscaledInt(a);
    }

    function testFromScaledUint(uint256 a, uint256 decimals)
        external
        pure
        returns (QuantMath.FixedPointInt memory)
    {
        return QuantMath.fromScaledUint(a, decimals);
    }

    function testToScaledUint(
        QuantMath.FixedPointInt memory a,
        uint256 decimals,
        bool roundDown
    ) external pure returns (uint256) {
        return QuantMath.toScaledUint(a, decimals, roundDown);
    }

    function testAdd(
        QuantMath.FixedPointInt memory a,
        QuantMath.FixedPointInt memory b
    ) external pure returns (QuantMath.FixedPointInt memory) {
        return a.add(b);
    }

    function testSub(
        QuantMath.FixedPointInt memory a,
        QuantMath.FixedPointInt memory b
    ) external pure returns (QuantMath.FixedPointInt memory) {
        return a.sub(b);
    }

    function testMul(
        QuantMath.FixedPointInt memory a,
        QuantMath.FixedPointInt memory b
    ) external pure returns (QuantMath.FixedPointInt memory) {
        return a.mul(b);
    }

    function testDiv(
        QuantMath.FixedPointInt memory a,
        QuantMath.FixedPointInt memory b
    ) external pure returns (QuantMath.FixedPointInt memory) {
        return a.div(b);
    }

    function testMin(
        QuantMath.FixedPointInt memory a,
        QuantMath.FixedPointInt memory b
    ) external pure returns (QuantMath.FixedPointInt memory) {
        return QuantMath.min(a, b);
    }

    function testMax(
        QuantMath.FixedPointInt memory a,
        QuantMath.FixedPointInt memory b
    ) external pure returns (QuantMath.FixedPointInt memory) {
        return QuantMath.max(a, b);
    }

    function testIsEqual(
        QuantMath.FixedPointInt memory a,
        QuantMath.FixedPointInt memory b
    ) external pure returns (bool) {
        return a.isEqual(b);
    }

    function testIsGreaterThan(
        QuantMath.FixedPointInt memory a,
        QuantMath.FixedPointInt memory b
    ) external pure returns (bool) {
        return a.isGreaterThan(b);
    }

    function testIsGreaterThanOrEqual(
        QuantMath.FixedPointInt memory a,
        QuantMath.FixedPointInt memory b
    ) external pure returns (bool) {
        return a.isGreaterThanOrEqual(b);
    }

    function testIsLessThan(
        QuantMath.FixedPointInt memory a,
        QuantMath.FixedPointInt memory b
    ) external pure returns (bool) {
        return a.isLessThan(b);
    }

    function testIsLessThanOrEqual(
        QuantMath.FixedPointInt memory a,
        QuantMath.FixedPointInt memory b
    ) external pure returns (bool) {
        return a.isLessThanOrEqual(b);
    }
}",680
RealWorld_TA_98_BUSD_RealWorld_20240812082211.log,98,BUSD,26256,2228,28484,71.0,0.17584,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract BUSD is ERC20 {
    // solhint-disable-next-line no-empty-blocks
    constructor() ERC20(""BUSD Token"", ""BUSD"") {}

    function mint(address account, uint256 amount) external {
        _mint(account, amount);
    }
}",93
RealWorld_TA_98_ITimelockedConfig_RealWorld_20240812090538.log,98,ITimelockedConfig,128502,2233,130735,80.0,0.68717,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import ""../libraries/ProtocolValue.sol"";

interface ITimelockedConfig {
    /// @notice emitted when a protocol address is set in the config
    /// @param protocolAddress the encoded name of the protocol value
    /// @param previousValue the previous value for the protocol address
    /// @param newValue the new value for the protocol address
    event SetProtocolAddress(
        bytes32 protocolAddress,
        address previousValue,
        address newValue
    );

    /// @notice emitted when a protocol uint256 is set in the config
    /// @param protocolUint256 the encoded name of the protocol value
    /// @param previousValue the previous value for the protocol uint256
    /// @param newValue the new value for the protocol uint256
    event SetProtocolUint256(
        bytes32 protocolUint256,
        uint256 previousValue,
        uint256 newValue
    );

    /// @notice emitted when a protocol boolean is set in the config
    /// @param protocolBoolean the encoded name of the protocol value
    /// @param previousValue the previous value for the protocol boolean
    /// @param newValue the new value for the protocol boolean
    event SetProtocolBoolean(
        bytes32 protocolBoolean,
        bool previousValue,
        bool newValue
    );

    /// @notice emitted when a protocol role is set in the config
    /// @param protocolRole the name of the protocol role
    /// @param role the encoded name of the protocol role
    /// @param roleAdmin the address of the role admin
    event SetProtocolRole(string protocolRole, bytes32 role, address roleAdmin);

    /// @notice emitted when a role admin is set
    /// @param role the encoded name of the protocol role
    /// @param adminRole the encoded name of the role to act as an admin
    event SetRoleAdmin(bytes32 role, bytes32 adminRole);

    /// @notice Sets a address protocol value
    /// @param _protocolAddress the encoded name of the protocol address
    /// @param _newValue the new value for the protocol address
    function setProtocolAddress(bytes32 _protocolAddress, address _newValue)
        external;

    /// @notice Sets a uint256 protocol value
    /// @param _protocolUint256 the encoded name of the protocol uint256
    /// @param _newValue the new value for the protocol uint256
    function setProtocolUint256(bytes32 _protocolUint256, uint256 _newValue)
        external;

    /// @notice Sets a boolean protocol value
    /// @param _protocolBoolean the encoded name of the protocol boolean
    /// @param _newValue the new value for the protocol boolean
    function setProtocolBoolean(bytes32 _protocolBoolean, bool _newValue)
        external;

    /// @notice Sets a role protocol
    /// @param _protocolRole the name of the protocol role
    /// @param _roleAdmin the address of the role admin
    function setProtocolRole(string calldata _protocolRole, address _roleAdmin)
        external;

    /// @notice Sets a role admin
    /// @param role the encoded name of the protocol role
    /// @param adminRole the encoded name of the role to act as an admin
    function setRoleAdmin(bytes32 role, bytes32 adminRole) external;

    /// @notice Initializes the system roles and assign them to the given TimelockController address
    /// @param _timelockController Address of the TimelockController to receive the system roles
    /// @dev The TimelockController should have a Quant multisig as its sole proposer
    function initialize(address payable _timelockController) external;

    /// @notice Returns the address of the TimelockController
    function timelockController() external view returns (address payable);

    /// @notice Given an encoded protocol value name, returns the address of the protocol value
    function protocolAddresses(bytes32) external view returns (address);

    /// @notice Given an index, returns the encoded name for a protocol address value
    function configuredProtocolAddresses(uint256)
        external
        view
        returns (bytes32);

    /// @notice Given an encoded protocol value name, returns the uint256 value of the protocol value
    function protocolUints256(bytes32) external view returns (uint256);

    /// @notice Given an index, returns the encoded name for a protocol uint256 value
    function configuredProtocolUints256(uint256)
        external
        view
        returns (bytes32);

    /// @notice Given an encoded protocol value name, returns the boolean value of the protocol value
    function protocolBooleans(bytes32) external view returns (bool);

    /// @notice Given an index, returns the encoded name for a protocol boolean value
    function configuredProtocolBooleans(uint256)
        external
        view
        returns (bytes32);

    /// @notice Given a protocol role name, returns the encoded name of the role
    function quantRoles(string calldata) external view returns (bytes32);

    /// @notice Checks if a given protocol value is already set in the config
    /// @param protocolValueName the encoded name of the protocol value
    /// @param protocolValueType the type of the protocol value
    /// @return whether the protocol value is already set in the config
    function isProtocolValueSet(
        bytes32 protocolValueName,
        ProtocolValue.Type protocolValueType
    ) external view returns (bool);

    /// @notice Array of roles configured in the Quant Protocol system through the QuantConfig
    function configuredQuantRoles(uint256) external view returns (bytes32);

    /// @notice The length of the configuredProtocolAddresses array
    function protocolAddressesLength() external view returns (uint256);

    /// @notice The length of the configuredProtocolUints256 array
    function protocolUints256Length() external view returns (uint256);

    /// @notice The length of the configuredProtocolBooleans array
    function protocolBooleansLength() external view returns (uint256);

    /// @notice The length of the configuredQuantRoles array
    function quantRolesLength() external view returns (uint256);
}",1291
RealWorld_TA_98_ExternalQToken_RealWorld_20240812082842.log,98,ExternalQToken,33862,2302,36164,79.0,0.21535,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""../options/QToken.sol"";

contract ExternalQToken is QToken {
    constructor(
        address _quantConfig,
        address _underlyingAsset,
        address _strikeAsset,
        address _oracle,
        uint256 _strikePrice,
        uint256 _expiryTime,
        bool _isCall
    )
        QToken(
            _quantConfig,
            _underlyingAsset,
            _strikeAsset,
            _oracle,
            _strikePrice,
            _expiryTime,
            _isCall
        )
    // solhint-disable-next-line no-empty-blocks
    {

    }

    function permissionlessMint(address account, uint256 amount) external {
        _mint(account, amount);
        emit QTokenMinted(account, amount);
    }
}",178
RealWorld_TA_98_OptionsUtils_RealWorld_20240812083941.log,98,OptionsUtils,156646,2818,159464,90.0,0.83959,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/utils/Create2.sol"";
import ""./ProtocolValue.sol"";
import ""../options/QToken.sol"";
import ""../interfaces/ICollateralToken.sol"";
import ""../interfaces/IOracleRegistry.sol"";
import ""../interfaces/IProviderOracleManager.sol"";
import ""../interfaces/IQuantConfig.sol"";
import ""../interfaces/IQToken.sol"";
import ""../interfaces/IAssetsRegistry.sol"";

/// @title Options utilities for Quant's QToken and CollateralToken
/// @author Rolla
/// @dev This library must be deployed and linked while deploying contracts that use it
library OptionsUtils {
    /// @notice constant salt because options will only be deployed with the same parameters once
    bytes32 public constant SALT = bytes32(""ROLLA.FINANCE"");

    /// @notice get the address at which a new QToken with the given parameters would be deployed
    /// @notice return the exact address the QToken will be deployed at with OpenZeppelin's Create2
    /// library computeAddress function
    /// @param _underlyingAsset asset that the option references
    /// @param _strikeAsset asset that the strike is denominated in
    /// @param _oracle price oracle for the option underlying
    /// @param _strikePrice strike price with as many decimals in the strike asset
    /// @param _expiryTime expiration timestamp as a unix timestamp
    /// @param _isCall true if it's a call option, false if it's a put option
    /// @return the address where a QToken would be deployed
    function getTargetQTokenAddress(
        address _quantConfig,
        address _underlyingAsset,
        address _strikeAsset,
        address _oracle,
        uint256 _strikePrice,
        uint256 _expiryTime,
        bool _isCall
    ) internal view returns (address) {
        bytes32 bytecodeHash = keccak256(
            abi.encodePacked(
                type(QToken).creationCode,
                abi.encode(
                    _quantConfig,
                    _underlyingAsset,
                    _strikeAsset,
                    _oracle,
                    _strikePrice,
                    _expiryTime,
                    _isCall
                )
            )
        );

        return Create2.computeAddress(SALT, bytecodeHash);
    }

    /// @notice get the id that a CollateralToken with the given parameters would have
    /// @param _underlyingAsset asset that the option references
    /// @param _strikeAsset asset that the strike is denominated in
    /// @param _oracle price oracle for the option underlying
    /// @param _strikePrice strike price with as many decimals in the strike asset
    /// @param _expiryTime expiration timestamp as a unix timestamp
    /// @param _qTokenAsCollateral initial spread collateral
    /// @param _isCall true if it's a call option, false if it's a put option
    /// @return the id that a CollateralToken would have
    function getTargetCollateralTokenId(
        ICollateralToken _collateralToken,
        address _quantConfig,
        address _underlyingAsset,
        address _strikeAsset,
        address _oracle,
        address _qTokenAsCollateral,
        uint256 _strikePrice,
        uint256 _expiryTime,
        bool _isCall
    ) internal view returns (uint256) {
        address qToken = getTargetQTokenAddress(
            _quantConfig,
            _underlyingAsset,
            _strikeAsset,
            _oracle,
            _strikePrice,
            _expiryTime,
            _isCall
        );
        return
            _collateralToken.getCollateralTokenId(qToken, _qTokenAsCollateral);
    }

    /// @notice Checks if the given option parameters are valid for creation in the Quant Protocol
    /// @param _underlyingAsset asset that the option is for
    /// @param _oracle price oracle for the option underlying
    /// @param _expiryTime expiration timestamp as a unix timestamp
    /// @param _quantConfig address of the QuantConfig contract
    /// @param _strikePrice strike price with as many decimals in the strike asset
    function validateOptionParameters(
        address _underlyingAsset,
        address _oracle,
        uint256 _expiryTime,
        address _quantConfig,
        uint256 _strikePrice
    ) internal view {
        require(
            _expiryTime > block.timestamp,
            ""OptionsFactory: given expiry time is in the past""
        );

        IOracleRegistry oracleRegistry = IOracleRegistry(
            IQuantConfig(_quantConfig).protocolAddresses(
                ProtocolValue.encode(""oracleRegistry"")
            )
        );

        require(
            oracleRegistry.isOracleRegistered(_oracle),
            ""OptionsFactory: Oracle is not registered in OracleRegistry""
        );

        require(
            IProviderOracleManager(_oracle).getAssetOracle(_underlyingAsset) !=
                address(0),
            ""OptionsFactory: Asset does not exist in oracle""
        );

        require(
            IProviderOracleManager(_oracle).isValidOption(
                _underlyingAsset,
                _expiryTime,
                _strikePrice
            ),
            ""OptionsFactory: Oracle doesn't support the given option""
        );

        require(
            oracleRegistry.isOracleActive(_oracle),
            ""OptionsFactory: Oracle is not active in the OracleRegistry""
        );

        require(_strikePrice > 0, ""strike can't be 0"");

        require(
            isInAssetsRegistry(_underlyingAsset, _quantConfig),
            ""underlying not in the registry""
        );
    }

    /// @notice Checks if a given asset is in the AssetsRegistry configured in the QuantConfig
    /// @param _asset address of the asset to check
    /// @param _quantConfig address of the QuantConfig contract
    /// @return whether the asset is in the configured registry
    function isInAssetsRegistry(address _asset, address _quantConfig)
        internal
        view
        returns (bool)
    {
        string memory symbol;
        (, symbol, ) = IAssetsRegistry(
            IQuantConfig(_quantConfig).protocolAddresses(
                ProtocolValue.encode(""assetsRegistry"")
            )
        ).assetProperties(_asset);

        return bytes(symbol).length != 0;
    }

    /// @notice Gets the amount of decimals for an option exercise payout
    /// @param _strikeAssetDecimals decimals of the strike asset
    /// @param _qToken address of the option's QToken contract
    /// @param _quantConfig address of the QuantConfig contract
    /// @return payoutDecimals amount of decimals for the option exercise payout
    function getPayoutDecimals(
        uint8 _strikeAssetDecimals,
        IQToken _qToken,
        IQuantConfig _quantConfig
    ) internal view returns (uint8 payoutDecimals) {
        IAssetsRegistry assetsRegistry = IAssetsRegistry(
            _quantConfig.protocolAddresses(
                ProtocolValue.encode(""assetsRegistry"")
            )
        );

        if (_qToken.isCall()) {
            (, , payoutDecimals) = assetsRegistry.assetProperties(
                _qToken.underlyingAsset()
            );
        } else {
            payoutDecimals = _strikeAssetDecimals;
        }
    }

    /// @notice Gets the option details for a given QToken
    /// @param _qToken QToken to get the info for
    /// @return qTokenInfo struct containing all the QToken details
    function getQTokenInfo(address _qToken)
        internal
        view
        returns (IQToken.QTokenInfo memory qTokenInfo)
    {
        IQToken qToken = IQToken(_qToken);

        qTokenInfo = IQToken.QTokenInfo(
            qToken.underlyingAsset(),
            qToken.strikeAsset(),
            qToken.oracle(),
            qToken.strikePrice(),
            qToken.expiryTime(),
            qToken.isCall()
        );
    }
}",1654
RealWorld_TA_98_IChainlinkFixedTimeOracleManager_RealWorld_20240812085945.log,98,IChainlinkFixedTimeOracleManager,30565,2430,32995,70.0,0.201425,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import ""./IChainlinkOracleManager.sol"";

interface IChainlinkFixedTimeOracleManager is IChainlinkOracleManager {
    /// @notice emitted when a new time is added for fixed updates
    event FixedTimeUpdate(uint256 fixedTime, bool isValidTime);

    /// @notice Validate or invalidated a given fixed time for updates
    function setFixedTimeUpdate(uint256 fixedTime, bool isValidTime) external;

    /// @notice fixed time => is allowed
    function chainlinkFixedTimeUpdates(uint256) external view returns (bool);
}",132
RealWorld_TA_98_IPriceRegistry_RealWorld_20240812085716.log,98,IPriceRegistry,68388,2267,70655,73.0,0.38728,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import ""./IQuantConfig.sol"";

/// @title For centrally managing a log of settlement prices, for each option.
/// @author Rolla
interface IPriceRegistry {
    struct PriceWithDecimals {
        uint256 price;
        uint8 decimals;
    }

    event PriceStored(
        address indexed _oracle,
        address indexed _asset,
        uint256 indexed _expiryTimestamp,
        uint256 _settlementPrice,
        uint8 _settlementPriceDecimals
    );

    /// @notice Set the price at settlement for a particular asset, expiry
    /// @param _asset asset to set price for
    /// @param _settlementPrice price at settlement
    /// @param _expiryTimestamp timestamp of price to set
    function setSettlementPrice(
        address _asset,
        uint256 _expiryTimestamp,
        uint256 _settlementPrice,
        uint8 _settlementPriceDecimals
    ) external;

    /// @notice quant central configuration
    function config() external view returns (IQuantConfig);

    /// @notice Fetch the settlement price with decimals from an oracle for an asset at a particular timestamp.
    /// @param _oracle oracle which price should come from
    /// @param _asset asset to fetch price for
    /// @param _expiryTimestamp timestamp we want the price for
    /// @return the price (with decimals) which has been submitted for the asset at the timestamp by that oracle
    function getSettlementPriceWithDecimals(
        address _oracle,
        address _asset,
        uint256 _expiryTimestamp
    ) external view returns (PriceWithDecimals memory);

    /// @notice Fetch the settlement price from an oracle for an asset at a particular timestamp.
    /// @notice Rounds down if there's extra precision from the oracle
    /// @param _oracle oracle which price should come from
    /// @param _asset asset to fetch price for
    /// @param _expiryTimestamp timestamp we want the price for
    /// @return the price which has been submitted for the asset at the timestamp by that oracle
    function getSettlementPrice(
        address _oracle,
        address _asset,
        uint256 _expiryTimestamp
    ) external view returns (uint256);

    /// @notice Check if the settlement price for an asset exists from an oracle at a particular timestamp
    /// @param _oracle oracle from which price comes from
    /// @param _asset asset to check price for
    /// @param _expiryTimestamp timestamp of price
    /// @return whether or not a price has been submitted for the asset at the timestamp by that oracle
    function hasSettlementPrice(
        address _oracle,
        address _asset,
        uint256 _expiryTimestamp
    ) external view returns (bool);
}",594
RealWorld_TA_98_AssetsRegistry.t_RealWorld_20240812091655.log,98,AssetsRegistry.t,88436,2005,90441,71.0,0.48228,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.12;

import ""ds-test/test.sol"";
import ""contracts/options/AssetsRegistry.sol"";
import ""@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol"";
import ""contracts/QuantConfig.sol"";
import ""forge-std/stdlib.sol"";
import ""forge-std/Vm.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract ERC20WithDecimals is ERC20 {
    uint8 private _decimals;

    constructor(
        string memory _name,
        string memory _symbol,
        uint8 decimals_
    ) ERC20(_name, _symbol) {
        _decimals = decimals_;
    }

    function decimals() public view virtual override returns (uint8) {
        return _decimals;
    }
}

contract SimpleERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }
}

contract AssetsRegistryTest is DSTest {
    Vm public constant vm = Vm(HEVM_ADDRESS);

    AssetsRegistry public assetsRegistry;

    event AssetAdded(
        address indexed underlying,
        string name,
        string symbol,
        uint8 decimals
    );

    function setUp() public {
        address quantConfig = address(new QuantConfig());
        assetsRegistry = new AssetsRegistry(quantConfig);
        vm.mockCall(
            quantConfig,
            abi.encodeWithSelector(AccessControlUpgradeable.hasRole.selector),
            abi.encode(true)
        );
    }

    function testAddAssetWithOptionalERC20Methods() public {
        string memory name = ""BTCB Token"";
        string memory symbol = ""BTCB"";
        uint8 decimals = 18;

        ERC20WithDecimals asset = new ERC20WithDecimals(name, symbol, decimals);

        assertEq(asset.name(), name);
        assertEq(asset.symbol(), symbol);
        assertEq(uint256(asset.decimals()), uint256(decimals));

        vm.expectEmit(true, false, false, true);

        emit AssetAdded(address(asset), name, symbol, decimals);

        assetsRegistry.addAssetWithOptionalERC20Methods(address(asset));

        address registeredAsset = assetsRegistry.registeredAssets(0);
        assertEq(registeredAsset, address(asset));

        (
            string memory registerdName,
            string memory registeredSymbol,
            uint8 registeredDecimals
        ) = assetsRegistry.assetProperties(registeredAsset);

        assertEq(registerdName, name);
        assertEq(registeredSymbol, symbol);
        assertEq(uint256(registeredDecimals), uint256(decimals));
    }

    function testAddAssetWithoutOptionalERC20Methods(
        string memory name,
        string memory symbol
    ) public {
        SimpleERC20 asset = new SimpleERC20(name, symbol);

        // Should revert when trying to call asset.name()
        vm.expectRevert(bytes(""""));

        assetsRegistry.addAssetWithOptionalERC20Methods(address(asset));
    }

    function testAddAssetAsNotRegistryMananger() public {
        vm.clearMockedCalls();

        string memory name = ""BUSD Token"";
        string memory symbol = ""BUSD"";
        uint8 decimals = 18;

        ERC20WithDecimals asset = new ERC20WithDecimals(name, symbol, decimals);

        vm.expectRevert(
            bytes(""AssetsRegistry: only asset registry managers can add assets"")
        );

        assetsRegistry.addAssetWithOptionalERC20Methods(address(asset));
    }

    function testAddSameAssetTwice() public {
        string memory name = ""Wrapped Ether"";
        string memory symbol = ""WETH"";
        uint8 decimals = 18;

        ERC20WithDecimals asset = new ERC20WithDecimals(name, symbol, decimals);

        assetsRegistry.addAssetWithOptionalERC20Methods(address(asset));

        vm.expectRevert(bytes(""AssetsRegistry: asset already added""));

        assetsRegistry.addAssetWithOptionalERC20Methods(address(asset));
    }
}",849
RealWorld_TA_98_Controller_RealWorld_20240812080325.log,98,Controller,386961,5002,391963,132.0,2.034845,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""./QuantConfig.sol"";
import ""./utils/EIP712MetaTransaction.sol"";
import ""./utils/OperateProxy.sol"";
import ""./interfaces/IQToken.sol"";
import ""./interfaces/IOracleRegistry.sol"";
import ""./interfaces/ICollateralToken.sol"";
import ""./interfaces/IController.sol"";
import ""./interfaces/IOperateProxy.sol"";
import ""./interfaces/IQuantCalculator.sol"";
import ""./interfaces/IOptionsFactory.sol"";
import ""./libraries/ProtocolValue.sol"";
import ""./libraries/QuantMath.sol"";
import ""./libraries/OptionsUtils.sol"";
import ""./libraries/Actions.sol"";

/// @title The main entry point in the Quant Protocol
/// @author Rolla
/// @notice Handles minting options and spreads, exercising, claiming collateral and neutralizing positions.
/// @dev This contract has no receive method, and also no way to recover tokens sent to it by accident.
/// Its balance of options or any other tokens are never used in any calculations, so there is no risk if that happens.
/// @dev This contract is an upgradeable proxy, and it supports meta transactions.
/// @dev The Controller holds all the collateral used to mint options. Options need to be created through the
/// OptionsFactory first.
contract Controller is
    IController,
    EIP712MetaTransaction,
    ReentrancyGuardUpgradeable
{
    using SafeERC20 for IERC20;
    using QuantMath for QuantMath.FixedPointInt;
    using Actions for ActionArgs;

    /// @inheritdoc IController
    address public override optionsFactory;

    /// @inheritdoc IController
    address public override operateProxy;

    /// @inheritdoc IController
    address public override quantCalculator;

    /// @inheritdoc IController
    function operate(ActionArgs[] memory _actions)
        external
        override
        nonReentrant
        returns (bool)
    {
        uint256 length = _actions.length;
        for (uint256 i = 0; i < length; ) {
            ActionArgs memory action = _actions[i];

            if (action.actionType == ActionType.MintOption) {
                (address to, address qToken, uint256 amount) = action
                    .parseMintOptionArgs();
                _mintOptionsPosition(to, qToken, amount);
            } else if (action.actionType == ActionType.MintSpread) {
                (
                    address qTokenToMint,
                    address qTokenForCollateral,
                    uint256 amount
                ) = action.parseMintSpreadArgs();
                _mintSpread(qTokenToMint, qTokenForCollateral, amount);
            } else if (action.actionType == ActionType.Exercise) {
                (address qToken, uint256 amount) = action.parseExerciseArgs();
                _exercise(qToken, amount);
            } else if (action.actionType == ActionType.ClaimCollateral) {
                (uint256 collateralTokenId, uint256 amount) = action
                    .parseClaimCollateralArgs();
                _claimCollateral(collateralTokenId, amount);
            } else if (action.actionType == ActionType.Neutralize) {
                (uint256 collateralTokenId, uint256 amount) = action
                    .parseNeutralizeArgs();
                _neutralizePosition(collateralTokenId, amount);
            } else if (action.actionType == ActionType.QTokenPermit) {
                (
                    address qToken,
                    address owner,
                    address spender,
                    uint256 value,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) = action.parseQTokenPermitArgs();
                _qTokenPermit(qToken, owner, spender, value, deadline, v, r, s);
            } else if (
                action.actionType == ActionType.CollateralTokenApproval
            ) {
                (
                    address owner,
                    address operator,
                    bool approved,
                    uint256 nonce,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) = action.parseCollateralTokenApprovalArgs();
                _collateralTokenApproval(
                    owner,
                    operator,
                    approved,
                    nonce,
                    deadline,
                    v,
                    r,
                    s
                );
            } else {
                require(
                    action.actionType == ActionType.Call,
                    ""Controller: Invalid action type""
                );
                (address callee, bytes memory data) = action.parseCallArgs();
                _call(callee, data);
            }

            unchecked {
                ++i;
            }
        }

        return true;
    }

    // @inheritdoc IController
    function initialize(
        string memory _name,
        string memory _version,
        address _optionsFactory,
        address _quantCalculator
    ) public override initializer {
        require(
            _optionsFactory != address(0),
            ""Controller: invalid OptionsFactory address""
        );
        require(
            _quantCalculator != address(0),
            ""Controller: invalid QuantCalculator address""
        );

        __ReentrancyGuard_init();
        EIP712MetaTransaction.initializeEIP712(_name, _version);
        optionsFactory = _optionsFactory;

        /// @dev Unless this line is removed, a new OperateProxy will be created
        /// during each upgrade. So make sure any application that requires approving
        /// the OperateProxy to spend funds is aware of this.
        operateProxy = address(new OperateProxy());

        quantCalculator = _quantCalculator;
    }

    /// @notice Mints options for a given QToken, which must have been previously created in
    /// the configured OptionsFactory.
    /// @dev The caller (or signer in case of meta transactions) must first approve the Controller
    /// to spend the collateral asset, and then this function can be called, pulling the collateral
    /// from the caller/signer and minting QTokens and CollateralTokens to the given `to` address.
    /// Note that QTokens represent a long position, giving holders the ability to exercise options
    /// after expiry, while CollateralTokens represent a short position, giving holders the ability
    /// to claim the collateral after expiry.
    /// @param _to The address to which the QTokens and CollateralTokens will be minted.
    /// @param _qToken The QToken that represents the long position for the option to be minted.
    /// @param _amount The amount of options to be minted.
    function _mintOptionsPosition(
        address _to,
        address _qToken,
        uint256 _amount
    ) internal returns (uint256) {
        IQToken qToken = IQToken(_qToken);

        // get the collateral required to mint the specified amount of options
        // the zero address is passed as the second argument as it's only used
        // for spreads
        (address collateral, uint256 collateralAmount) = IQuantCalculator(
            quantCalculator
        ).getCollateralRequirement(_qToken, address(0), _amount);

        _checkIfUnexpiredQToken(_qToken);

        // check if the oracle set during the option's creation through the OptionsFactory
        // is an active oracle in the OracleRegistry
        require(
            IOracleRegistry(
                IOptionsFactory(optionsFactory).quantConfig().protocolAddresses(
                    ProtocolValue.encode(""oracleRegistry"")
                )
            ).isOracleActive(qToken.oracle()),
            ""Controller: Can't mint an options position as the oracle is inactive""
        );

        // pull the required collateral from the caller/signer
        IERC20(collateral).safeTransferFrom(
            _msgSender(),
            address(this),
            collateralAmount
        );

        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)
            .collateralToken();

        // Mint the options to the sender's address
        qToken.mint(_to, _amount);
        uint256 collateralTokenId = collateralToken.getCollateralTokenId(
            _qToken,
            address(0)
        );

        // There's no need to check if the collateralTokenId exists before minting because if the QToken is valid,
        // then it's guaranteed that the respective CollateralToken has already also been created by the OptionsFactory
        collateralToken.mintCollateralToken(_to, collateralTokenId, _amount);

        emit OptionsPositionMinted(
            _to,
            _msgSender(),
            _qToken,
            _amount,
            collateral,
            collateralAmount
        );

        return collateralTokenId;
    }

    /// @notice Creates a spread position from an option to long and another option to short.
    /// @dev The caller (or signer in case of meta transactions) must first approve the Controller
    /// to spend the collateral asset in cases of a debit spread.
    /// @param _qTokenToMint The QToken for the option to be long.
    /// @param _qTokenForCollateral The QToken for the option to be short.
    /// @param _amount The amount of long options to be minted.
    function _mintSpread(
        address _qTokenToMint,
        address _qTokenForCollateral,
        uint256 _amount
    ) internal returns (uint256) {
        require(
            _qTokenToMint != _qTokenForCollateral,
            ""Controller: Can only create a spread with different tokens""
        );

        IQToken qTokenToMint = IQToken(_qTokenToMint);
        IQToken qTokenForCollateral = IQToken(_qTokenForCollateral);

        // Calculate the extra collateral required to create the spread.
        // A positive value for debit spreads and zero for credit spreads.
        (address collateral, uint256 collateralAmount) = IQuantCalculator(
            quantCalculator
        ).getCollateralRequirement(
                _qTokenToMint,
                _qTokenForCollateral,
                _amount
            );

        _checkIfUnexpiredQToken(_qTokenToMint);
        _checkIfUnexpiredQToken(_qTokenForCollateral);

        // Burn the QToken being shorted
        qTokenForCollateral.burn(_msgSender(), _amount);

        // Transfer in any collateral required for the spread
        if (collateralAmount > 0) {
            IERC20(collateral).safeTransferFrom(
                _msgSender(),
                address(this),
                collateralAmount
            );
        }

        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)
            .collateralToken();

        // Check if the CollateralToken representing this specific spread has already been created
        // Create it if it hasn't
        uint256 collateralTokenId = collateralToken.getCollateralTokenId(
            _qTokenToMint,
            _qTokenForCollateral
        );
        (, address qTokenAsCollateral) = collateralToken.idToInfo(
            collateralTokenId
        );
        if (qTokenAsCollateral == address(0)) {
            require(
                collateralTokenId ==
                    collateralToken.createCollateralToken(
                        _qTokenToMint,
                        _qTokenForCollateral
                    ),
                ""Controller: failed creating the collateral token to represent the spread""
            );
        }

        // Mint the tokens for the new spread position
        collateralToken.mintCollateralToken(
            _msgSender(),
            collateralTokenId,
            _amount
        );
        qTokenToMint.mint(_msgSender(), _amount);

        emit SpreadMinted(
            _msgSender(),
            _qTokenToMint,
            _qTokenForCollateral,
            _amount,
            collateral,
            collateralAmount
        );

        return collateralTokenId;
    }

    /// @notice Closes a long position after the option's expiry.
    /// @dev Pass an `_amount` of 0 to close the entire position.
    /// @param _qToken The QToken representing the long position to be closed.
    /// @param _amount The amount of options to exercise.
    function _exercise(address _qToken, uint256 _amount) internal {
        IQToken qToken = IQToken(_qToken);
        require(
            block.timestamp > qToken.expiryTime(),
            ""Controller: Can not exercise options before their expiry""
        );

        uint256 amountToExercise = _amount;
        // if the amount is 0, the entire position will be exercised
        if (amountToExercise == 0) {
            amountToExercise = qToken.balanceOf(_msgSender());
        }

        // Use the QuantCalculator to check how much the sender/signer is due.
        // Will only be a positive value for options that expired In The Money.
        (
            bool isSettled,
            address payoutToken,
            uint256 exerciseTotal
        ) = IQuantCalculator(quantCalculator).getExercisePayout(
                address(qToken),
                amountToExercise
            );

        require(isSettled, ""Controller: Cannot exercise unsettled options"");

        // Burn the long tokens
        qToken.burn(_msgSender(), amountToExercise);

        // Transfer any profit due after expiration
        if (exerciseTotal > 0) {
            IERC20(payoutToken).safeTransfer(_msgSender(), exerciseTotal);
        }

        emit OptionsExercised(
            _msgSender(),
            address(qToken),
            amountToExercise,
            exerciseTotal,
            payoutToken
        );
    }

    /// @notice Closes a short position after the option's expiry.
    /// @param _collateralTokenId ERC1155 token id representing the short position to be closed.
    /// @param _amount The size of the position to close.
    function _claimCollateral(uint256 _collateralTokenId, uint256 _amount)
        internal
    {
        uint256 collateralTokenId = _collateralTokenId;

        // Use the QuantCalculator to check how much collateral the sender/signer is due.
        (
            uint256 returnableCollateral,
            address collateralAsset,
            uint256 amountToClaim
        ) = IQuantCalculator(quantCalculator).calculateClaimableCollateral(
                collateralTokenId,
                _amount,
                _msgSender()
            );

        // Burn the short tokens
        IOptionsFactory(optionsFactory).collateralToken().burnCollateralToken(
            _msgSender(),
            collateralTokenId,
            amountToClaim
        );

        // Transfer any collateral due after expiration
        if (returnableCollateral > 0) {
            IERC20(collateralAsset).safeTransfer(
                _msgSender(),
                returnableCollateral
            );
        }

        emit CollateralClaimed(
            _msgSender(),
            collateralTokenId,
            amountToClaim,
            returnableCollateral,
            collateralAsset
        );
    }

    /// @notice Closes a neutral position, claiming all the collateral required to create it.
    /// @dev Unlike `_exercise` and `_claimCollateral`, this function does not require the option to be expired.
    /// @param _collateralTokenId ERC1155 token id representing the position to be closed.
    /// @param _amount The size of the position to close.
    function _neutralizePosition(uint256 _collateralTokenId, uint256 _amount)
        internal
    {
        /// @dev Put these values in the stack to save gas from having to read
        /// from calldata
        (uint256 collateralTokenId, uint256 amount) = (
            _collateralTokenId,
            _amount
        );

        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)
            .collateralToken();
        (address qTokenShort, address qTokenLong) = collateralToken.idToInfo(
            collateralTokenId
        );

        //get the amount of CollateralTokens owned
        uint256 collateralTokensOwned = collateralToken.balanceOf(
            _msgSender(),
            collateralTokenId
        );

        //get the amount of QTokens owned
        uint256 qTokensOwned = IQToken(qTokenShort).balanceOf(_msgSender());

        // the size of the position that can be neutralized
        uint256 maxNeutralizable = qTokensOwned < collateralTokensOwned
            ? qTokensOwned
            : collateralTokensOwned;

        // make sure that the amount passed is not greater than the amount that can be neutralized
        uint256 amountToNeutralize;
        if (amount != 0) {
            require(
                amount <= maxNeutralizable,
                ""Controller: Tried to neutralize more than balance""
            );
            amountToNeutralize = amount;
        } else {
            amountToNeutralize = maxNeutralizable;
        }

        // use the QuantCalculator to check how much collateral the sender/signer is due
        // for closing the neutral position
        (address collateralType, uint256 collateralOwed) = IQuantCalculator(
            quantCalculator
        ).getNeutralizationPayout(qTokenShort, qTokenLong, amountToNeutralize);

        // burn the short tokens
        IQToken(qTokenShort).burn(_msgSender(), amountToNeutralize);

        // burn the long tokens
        collateralToken.burnCollateralToken(
            _msgSender(),
            collateralTokenId,
            amountToNeutralize
        );

        // tranfer the collateral owed
        IERC20(collateralType).safeTransfer(_msgSender(), collateralOwed);

        //give the user their long tokens (if any, in case of CollateralTokens representing a spread)
        if (qTokenLong != address(0)) {
            IQToken(qTokenLong).mint(_msgSender(), amountToNeutralize);
        }

        emit NeutralizePosition(
            _msgSender(),
            qTokenShort,
            amountToNeutralize,
            collateralOwed,
            collateralType,
            qTokenLong
        );
    }

    /// @notice Allows a QToken owner to approve a spender to transfer a specified amount of tokens on their behalf.
    /// @param _qToken The QToken to be approved.
    /// @param _spender The address of the spender.
    /// @param _value The amount of tokens to be approved for spending.
    /// @param _deadline Timestamp at which the permit signature expires.
    /// @param _v The signature's v value.
    /// @param _r The signature's r value.
    /// @param _s The signature's s value.
    function _qTokenPermit(
        address _qToken,
        address _owner,
        address _spender,
        uint256 _value,
        uint256 _deadline,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) internal {
        IQToken(_qToken).permit(
            _owner,
            _spender,
            _value,
            _deadline,
            _v,
            _r,
            _s
        );
    }

    /// @notice Allows a CollateralToken owner to either approve an operator address
    /// to spend all of their tokens on their behalf, or to remove a prior approval.
    /// @param _owner The address of the owner of the CollateralToken.
    /// @param _operator The address of the operator to be approved or removed.
    /// @param _approved Whether the operator is being approved or removed.
    /// @param _nonce The nonce for the approval through a meta transaction.
    /// @param _deadline Timestamp at which the approval signature expires.
    /// @param _v The signature's v value.
    /// @param _r The signature's r value.
    /// @param _s The signature's s value.
    function _collateralTokenApproval(
        address _owner,
        address _operator,
        bool _approved,
        uint256 _nonce,
        uint256 _deadline,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) internal {
        IOptionsFactory(optionsFactory).collateralToken().metaSetApprovalForAll(
                _owner,
                _operator,
                _approved,
                _nonce,
                _deadline,
                _v,
                _r,
                _s
            );
    }

    /// @notice Allows a sender/signer to make external calls to any other contract.
    /// @dev A separate OperateProxy contract is used to make the external calls so
    /// that the Controller, which holds funds and has special privileges in the Quant
    /// Protocol, is never the `msg.sender` in any of those external calls.
    /// @param _callee The address of the contract to be called.
    /// @param _data The calldata to be sent to the contract.
    function _call(address _callee, bytes memory _data) internal {
        IOperateProxy(operateProxy).callFunction(_callee, _data);
    }

    /// @notice Checks if the given QToken has not expired yet, reverting otherwise
    /// @param _qToken The address of the QToken to check.
    function _checkIfUnexpiredQToken(address _qToken) internal view {
        require(
            IQToken(_qToken).expiryTime() > block.timestamp,
            ""Controller: Cannot mint expired options""
        );
    }
}",4451
RealWorld_TA_98_IChainlinkOracleManager_RealWorld_20240812091321.log,98,IChainlinkOracleManager,47170,1938,49108,70.0,0.27461,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import ""./IProviderOracleManager.sol"";
import ""./IOracleFallbackMechanism.sol"";

interface IChainlinkOracleManager is
    IProviderOracleManager,
    IOracleFallbackMechanism
{
    event PriceRegistrySubmission(
        address asset,
        uint256 expiryTimestamp,
        uint256 price,
        uint256 expiryRoundId,
        address priceSubmitter,
        bool isFallback
    );

    /// @notice Set the price of an asset at a timestamp using a chainlink round id
    /// @param _asset address of asset to set price for
    /// @param _expiryTimestamp expiry timestamp to set the price at
    /// @param _roundIdAfterExpiry the chainlink round id immediately after the expiry timestamp
    function setExpiryPriceInRegistryByRound(
        address _asset,
        uint256 _expiryTimestamp,
        uint256 _roundIdAfterExpiry
    ) external;

    function fallbackPeriodSeconds() external view returns (uint256);

    /// @notice Searches for the round in the asset oracle immediately after the expiry timestamp
    /// @param _asset address of asset to search price for
    /// @param _expiryTimestamp expiry timestamp to find the price at or before
    /// @return the round id immediately after the timestamp submitted
    function searchRoundToSubmit(address _asset, uint256 _expiryTimestamp)
        external
        view
        returns (uint80);

    /// @notice The amount of decimals the strike asset has
    function strikeAssetDecimals() external view returns (uint8);
}",339
RealWorld_TA_98_WETH_RealWorld_20240812082722.log,98,WETH,26470,2745,29215,78.0,0.18725,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract WETH is ERC20 {
    // solhint-disable-next-line no-empty-blocks
    constructor() ERC20(""Wrapped Ether"", ""WETH"") {}

    function mint(address account, uint256 amount) external {
        _mint(account, amount);
    }
}",92
RealWorld_TA_98_TimelockController_RealWorld_20240812081807.log,98,TimelockController,245648,3446,249094,99.0,1.29716,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.12;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

/**
 * @dev Contract module which acts as a timelocked controller. When set as the
 * owner of an `Ownable` smart contract, it enforces a timelock on all
 * `onlyOwner` maintenance operations. This gives time for users of the
 * controlled contract to exit before a potentially dangerous maintenance
 * operation is applied.
 *
 * By default, this contract is self administered, meaning administration tasks
 * have to go through the timelock process. The proposer (resp executor) role
 * is in charge of proposing (resp executing) operations. A common use case is
 * to position this {TimelockController} as the owner of a smart contract, with
 * a multisig or a DAO as the sole proposer.
 *
 * _Available since v3.3._
 */
abstract contract TimelockController is AccessControl {
    bytes32 public constant TIMELOCK_ADMIN_ROLE =
        keccak256(""TIMELOCK_ADMIN_ROLE"");
    bytes32 public constant PROPOSER_ROLE = keccak256(""PROPOSER_ROLE"");
    bytes32 public constant EXECUTOR_ROLE = keccak256(""EXECUTOR_ROLE"");
    uint256 internal constant _DONE_TIMESTAMP = uint256(1);

    mapping(bytes32 => uint256) private _timestamps;
    uint256 private _minDelay;

    /**
     * @dev Emitted when a call is scheduled as part of operation `id`.
     */
    event CallScheduled(
        bytes32 indexed id,
        uint256 indexed index,
        address target,
        uint256 value,
        bytes data,
        bytes32 predecessor,
        uint256 delay
    );

    /**
     * @dev Emitted when a call is performed as part of operation `id`.
     */
    event CallExecuted(
        bytes32 indexed id,
        uint256 indexed index,
        address target,
        uint256 value,
        bytes data
    );

    /**
     * @dev Emitted when operation `id` is cancelled.
     */
    event Cancelled(bytes32 indexed id);

    /**
     * @dev Emitted when the minimum delay for future operations is modified.
     */
    event MinDelayChange(uint256 oldDuration, uint256 newDuration);

    /**
     * @dev Initializes the contract with a given `minDelay`.
     */
    constructor(
        uint256 minDelay,
        address[] memory proposers,
        address[] memory executors
    ) {
        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);
        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);
        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);

        // deployer + self administration
        _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());
        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));

        // register proposers
        for (uint256 i = 0; i < proposers.length; ++i) {
            _setupRole(PROPOSER_ROLE, proposers[i]);
        }

        // register executors
        for (uint256 i = 0; i < executors.length; ++i) {
            _setupRole(EXECUTOR_ROLE, executors[i]);
        }

        _minDelay = minDelay;
        emit MinDelayChange(0, minDelay);
    }

    /**
     * @dev Contract might receive/hold ETH as part of the maintenance process.
     */
    // solhint-disable-next-line no-empty-blocks
    receive() external payable {}

    /**
     * @dev Changes the minimum timelock duration for future operations.
     *
     * Emits a {MinDelayChange} event.
     *
     * Requirements:
     *
     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing
     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.
     */
    function updateDelay(uint256 newDelay) external virtual {
        require(
            msg.sender == address(this),
            ""TimelockController: caller must be timelock""
        );
        emit MinDelayChange(_minDelay, newDelay);
        _minDelay = newDelay;
    }

    /**
     * @dev Schedule an operation containing a single transaction.
     *
     * Emits a {CallScheduled} event.
     *
     * Requirements:
     *
     * - the caller must have the 'proposer' role.
     */
    function schedule(
        address target,
        uint256 value,
        bytes memory data,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay,
        bool ignoreMinDelay
    ) public virtual onlyRole(PROPOSER_ROLE) {
        bytes32 id = hashOperation(target, value, data, predecessor, salt);
        _schedule(id, delay, ignoreMinDelay);
        emit CallScheduled(id, 0, target, value, data, predecessor, delay);
    }

    /**
     * @dev Schedule an operation containing a batch of transactions.
     *
     * Emits one {CallScheduled} event per transaction in the batch.
     *
     * Requirements:
     *
     * - the caller must have the 'proposer' role.
     */
    function scheduleBatch(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory datas,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay
    ) public virtual onlyRole(PROPOSER_ROLE) {
        require(
            targets.length == values.length,
            ""TimelockController: length mismatch""
        );
        require(
            targets.length == datas.length,
            ""TimelockController: length mismatch""
        );

        bytes32 id = hashOperationBatch(
            targets,
            values,
            datas,
            predecessor,
            salt
        );
        _schedule(id, delay, false);
        for (uint256 i = 0; i < targets.length; ++i) {
            emit CallScheduled(
                id,
                i,
                targets[i],
                values[i],
                datas[i],
                predecessor,
                delay
            );
        }
    }

    /**
     * @dev Cancel an operation.
     *
     * Requirements:
     *
     * - the caller must have the 'proposer' role.
     */
    function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {
        require(
            isOperationPending(id),
            ""TimelockController: operation cannot be cancelled""
        );
        delete _timestamps[id];

        emit Cancelled(id);
    }

    /**
     * @dev Execute an (ready) operation containing a single transaction.
     *
     * Emits a {CallExecuted} event.
     *
     * Requirements:
     *
     * - the caller must have the 'executor' role.
     */
    function execute(
        address target,
        uint256 value,
        bytes memory data,
        bytes32 predecessor,
        bytes32 salt
    ) public payable virtual onlyRole(EXECUTOR_ROLE) {
        bytes32 id = hashOperation(target, value, data, predecessor, salt);
        _beforeCall(id, predecessor);
        _call(id, 0, target, value, data);
        _afterCall(id);
    }

    /**
     * @dev Execute an (ready) operation containing a batch of transactions.
     *
     * Emits one {CallExecuted} event per transaction in the batch.
     *
     * Requirements:
     *
     * - the caller must have the 'executor' role.
     */
    function executeBatch(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory datas,
        bytes32 predecessor,
        bytes32 salt
    ) public payable virtual onlyRole(EXECUTOR_ROLE) {
        require(
            targets.length == values.length,
            ""TimelockController: length mismatch""
        );
        require(
            targets.length == datas.length,
            ""TimelockController: length mismatch""
        );

        bytes32 id = hashOperationBatch(
            targets,
            values,
            datas,
            predecessor,
            salt
        );
        _beforeCall(id, predecessor);
        for (uint256 i = 0; i < targets.length; ++i) {
            _call(id, i, targets[i], values[i], datas[i]);
        }
        _afterCall(id);
    }

    /**
     * @dev Returns whether an id correspond to a registered operation. This
     * includes both Pending, Ready and Done operations.
     */
    function isOperation(bytes32 id)
        public
        view
        virtual
        returns (bool pending)
    {
        return getTimestamp(id) > 0;
    }

    /**
     * @dev Returns whether an operation is pending or not.
     */
    function isOperationPending(bytes32 id)
        public
        view
        virtual
        returns (bool pending)
    {
        return getTimestamp(id) > _DONE_TIMESTAMP;
    }

    /**
     * @dev Returns whether an operation is ready or not.
     */
    function isOperationReady(bytes32 id)
        public
        view
        virtual
        returns (bool ready)
    {
        uint256 timestamp = getTimestamp(id);
        // solhint-disable-next-line not-rely-on-time
        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;
    }

    /**
     * @dev Returns whether an operation is done or not.
     */
    function isOperationDone(bytes32 id)
        public
        view
        virtual
        returns (bool done)
    {
        return getTimestamp(id) == _DONE_TIMESTAMP;
    }

    /**
     * @dev Returns the timestamp at with an operation becomes ready (0 for
     * unset operations, 1 for done operations).
     */
    function getTimestamp(bytes32 id)
        public
        view
        virtual
        returns (uint256 timestamp)
    {
        return _timestamps[id];
    }

    /**
     * @dev Returns the minimum delay for an operation to become valid.
     *
     * This value can be changed by executing an operation that calls `updateDelay`.
     */
    function getMinDelay() public view virtual returns (uint256 duration) {
        return _minDelay;
    }

    /**
     * @dev Returns the identifier of an operation containing a single
     * transaction.
     */
    function hashOperation(
        address target,
        uint256 value,
        bytes memory data,
        bytes32 predecessor,
        bytes32 salt
    ) public pure virtual returns (bytes32 hash) {
        return keccak256(abi.encode(target, value, data, predecessor, salt));
    }

    /**
     * @dev Returns the identifier of an operation containing a batch of
     * transactions.
     */
    function hashOperationBatch(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory datas,
        bytes32 predecessor,
        bytes32 salt
    ) public pure virtual returns (bytes32 hash) {
        return keccak256(abi.encode(targets, values, datas, predecessor, salt));
    }

    /**
     * @dev Schedule an operation that is to becomes valid after a given delay.
     */
    function _schedule(
        bytes32 id,
        uint256 delay,
        bool ignoreMinDelay
    ) private {
        require(
            !isOperation(id),
            ""TimelockController: operation already scheduled""
        );
        require(
            ignoreMinDelay || delay >= getMinDelay(),
            ""TimelockController: insufficient delay""
        );
        // solhint-disable-next-line not-rely-on-time
        _timestamps[id] = block.timestamp + delay;
    }

    /**
     * @dev Checks after execution of an operation's calls.
     */
    function _afterCall(bytes32 id) private {
        require(
            isOperationReady(id),
            ""TimelockController: operation is not ready""
        );
        _timestamps[id] = _DONE_TIMESTAMP;
    }

    /**
     * @dev Execute an operation's call.
     *
     * Emits a {CallExecuted} event.
     */
    function _call(
        bytes32 id,
        uint256 index,
        address target,
        uint256 value,
        bytes memory data
    ) private {
        // solhint-disable-next-line avoid-low-level-calls
        (bool success, ) = target.call{value: value}(data);
        require(success, ""TimelockController: underlying transaction reverted"");

        emit CallExecuted(id, index, target, value, data);
    }

    /**
     * @dev Checks before execution of an operation's calls.
     */
    function _beforeCall(bytes32 id, bytes32 predecessor) private view {
        require(
            isOperationReady(id),
            ""TimelockController: operation is not ready""
        );
        require(
            predecessor == bytes32(0) || isOperationDone(predecessor),
            ""TimelockController: missing dependency""
        );
    }
}",2703
RealWorld_TA_98_IQToken_RealWorld_20240812090317.log,98,IQToken,74865,1658,76523,65.0,0.407485,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol"";
import ""./IQuantConfig.sol"";

/// @dev Current pricing status of option. Only SETTLED options can be exercised
enum PriceStatus {
    ACTIVE,
    AWAITING_SETTLEMENT_PRICE,
    SETTLED
}

/// @title Token that represents a user's long position
/// @author Rolla
/// @notice Can be used by owners to exercise their options
/// @dev Every option long position is an ERC20 token: https://eips.ethereum.org/EIPS/eip-20
interface IQToken is IERC20, IERC20Permit {
    struct QTokenInfo {
        address underlyingAsset;
        address strikeAsset;
        address oracle;
        uint256 strikePrice;
        uint256 expiryTime;
        bool isCall;
    }

    /// @notice event emitted when QTokens are minted
    /// @param account account the QToken was minted to
    /// @param amount the amount of QToken minted
    event QTokenMinted(address indexed account, uint256 amount);

    /// @notice event emitted when QTokens are burned
    /// @param account account the QToken was burned from
    /// @param amount the amount of QToken burned
    event QTokenBurned(address indexed account, uint256 amount);

    /// @notice mint option token for an account
    /// @param account account to mint token to
    /// @param amount amount to mint
    function mint(address account, uint256 amount) external;

    /// @notice burn option token from an account.
    /// @param account account to burn token from
    /// @param amount amount to burn
    function burn(address account, uint256 amount) external;

    /// @dev Address of system config.
    function quantConfig() external view returns (IQuantConfig);

    /// @dev Address of the underlying asset. WETH for ethereum options.
    function underlyingAsset() external view returns (address);

    /// @dev Address of the strike asset. Quant Web options always use USDC.
    function strikeAsset() external view returns (address);

    /// @dev Address of the oracle to be used with this option
    function oracle() external view returns (address);

    /// @dev The strike price for the token with the strike asset precision.
    function strikePrice() external view returns (uint256);

    /// @dev UNIX time for the expiry of the option
    function expiryTime() external view returns (uint256);

    /// @dev True if the option is a CALL. False if the option is a PUT.
    function isCall() external view returns (bool);

    /// @notice Get the price status of the option.
    /// @return the price status of the option. option is either active, awaiting settlement price or settled
    function getOptionPriceStatus() external view returns (PriceStatus);

    /// @notice Get the details of the QToken
    /// @return a QTokenInfo with all of the QToken parameters
    function getQTokenInfo() external view returns (QTokenInfo memory);
}",690
RealWorld_TA_98_IQuantConfig_RealWorld_20240812090818.log,98,IQuantConfig,24170,1432,25602,66.0,0.14949,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import ""./ITimelockedConfig.sol"";
import ""@openzeppelin/contracts/access/IAccessControl.sol"";

// solhint-disable-next-line no-empty-blocks
interface IQuantConfig is ITimelockedConfig, IAccessControl {

}",71
