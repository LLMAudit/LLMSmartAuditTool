filename,contest_id,contract_name,input_token,completion_token,total_token,execution_time,cost,contract_content,contract_size
RealWorld_BA_55_Mocks_RealWord_20240821144737.log,55,Mocks,16956,5510,22466,85.0,0.19498,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity ^0.8.7;

import { IERC20 }             from ""../../../modules/erc20/src/interfaces/IERC20.sol"";
import { ILiquidatorLike }    from ""../../../modules/liquidations/contracts/interfaces/Interfaces.sol"";

import { ERC20Helper } from ""../../../modules/erc20-helper/src/ERC20Helper.sol"";
import { MockERC20 }   from ""../../../modules/erc20/src/test/mocks/MockERC20.sol"";

import { IDebtLocker }        from ""../../interfaces/IDebtLocker.sol"";
import { IDebtLockerFactory } from ""../../interfaces/IDebtLockerFactory.sol"";

contract MockPoolFactory {

    address public globals;

    constructor(address globals_) {
        globals = globals_;
    }

    function createPool(address poolDelegate_) external returns (address) {
        return address(new MockPool(poolDelegate_));
    }

}

contract MockPool {

    address public poolDelegate;
    address public superFactory;

    constructor(address poolDelegate_) {
        poolDelegate = poolDelegate_;
        superFactory = msg.sender;
    }

    function createDebtLocker(address dlFactory, address loan) external returns (address) {
        return IDebtLockerFactory(dlFactory).newLocker(loan);
    }

    function claim(address debtLocker) external returns (uint256[7] memory) {
        return IDebtLocker(debtLocker).claim();
    }

    function triggerDefault(address debtLocker) external {
        return IDebtLocker(debtLocker).triggerDefault();
    }

}

contract MockLiquidationStrategy {

    function flashBorrowLiquidation(address lender_, uint256 swapAmount_, address collateralAsset_, address fundsAsset_) external {
        uint256 repaymentAmount = IDebtLocker(lender_).getExpectedAmount(swapAmount_);

        ERC20Helper.approve(fundsAsset_, lender_, repaymentAmount);

        ILiquidatorLike(lender_).liquidatePortion(
            swapAmount_,
            type(uint256).max,
            abi.encodeWithSelector(this.swap.selector, collateralAsset_, fundsAsset_, swapAmount_, repaymentAmount)
        );
    }

    function swap(address collateralAsset_, address fundsAsset_, uint256 swapAmount_, uint256 repaymentAmount_) external {
        MockERC20(fundsAsset_).mint(address(this), repaymentAmount_);
        MockERC20(collateralAsset_).burn(address(this), swapAmount_);
    }

}

contract MockLoan {
    
    function principalRequested() external view returns (uint256 principalRequested_) {
        return 0;
    }

    function acceptNewTerms(address refinancer_, bytes[] calldata calls_, uint256 amount_) external {
        // Empty, just testing ACL
    }
    
}

contract MockGlobals {

    address public governor;

    mapping(address => bool) public isValidCollateralAsset;
    mapping(address => bool) public isValidLiquidityAsset;
    
    bool public protocolPaused;

    mapping(address => uint256) assetPrices;

    constructor (address governor_) {
        governor = governor_;
    }

    function getLatestPrice(address asset_) external view returns (uint256 price_) {
        return assetPrices[asset_];
    }

    function setPrice(address asset_, uint256 price_) external {
        assetPrices[asset_] = price_;
    }

    function setProtocolPause(bool paused_) external {
        protocolPaused = paused_;
    }

    function investorFee() external pure returns (uint256 investorFee_) {
        return 50;
    }

    function treasuryFee() external pure returns (uint256 treasuryFee_) {
        return 50;
    }

    function mapleTreasury() external pure returns (address mapleTreasury_) {
        return address(1);
    }

    function setValidCollateralAsset(address asset_, bool valid_) external {
        isValidCollateralAsset[asset_] = valid_;
    }

    function setValidLiquidityAsset(address asset_, bool valid_) external {
        isValidLiquidityAsset[asset_] = valid_;
    }

}

contract MockMigrator {

    fallback() external { }

}",837
RealWorld_BA_55_PoolDelegate_RealWord_20240821145306.log,55,PoolDelegate,15620,5070,20690,77.0,0.1795,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity 0.8.7;

import { User as ProxyUser } from ""../../../modules/maple-proxy-factory/contracts/test/accounts/User.sol"";

import { IDebtLocker, IMapleProxied } from ""../../interfaces/IDebtLocker.sol"";

contract PoolDelegate is ProxyUser {

    /************************/
    /*** Direct Functions ***/
    /************************/

    function debtLocker_acceptNewTerms(address debtLocker_, address refinancer_, bytes[] calldata calls_, uint256 amount_) external {
        IDebtLocker(debtLocker_).acceptNewTerms(refinancer_, calls_, amount_);
    }

    function debtLocker_setAllowedSlippage(address debtLocker_, uint256 allowedSlippage_) external {
        IDebtLocker(debtLocker_).setAllowedSlippage(allowedSlippage_);
    }

    function debtLocker_setAuctioneer(address debtLocker_, address auctioneer_) external {
        IDebtLocker(debtLocker_).setAuctioneer(auctioneer_);
    }

    function debtLocker_setFundsToCapture(address debtLocker_, uint256 amount_) external {
        IDebtLocker(debtLocker_).setFundsToCapture(amount_);
    }

    function debtLocker_setMinRatio(address debtLocker_, uint256 minRatio_) external {
        IDebtLocker(debtLocker_).setMinRatio(minRatio_);
    }

    function debtLocker_stopLiquidation(address debtLocker_) external {
        IDebtLocker(debtLocker_).stopLiquidation();
    }
    
    function debtLocker_upgrade(address debtLocker_, uint256 toVersion_, bytes memory arguments_) external {
        IDebtLocker(debtLocker_).upgrade(toVersion_, arguments_);
    }

    /*********************/
    /*** Try Functions ***/
    /*********************/

    function try_debtLocker_acceptNewTerms(
        address debtLocker_, 
        address refinancer_,
        bytes[] calldata calls_,
        uint256 amount_
    ) external returns (bool ok_) {
        ( ok_, ) = debtLocker_.call(abi.encodeWithSelector(IDebtLocker.acceptNewTerms.selector, refinancer_, calls_, amount_));
    }

    function try_debtLocker_setAllowedSlippage(address debtLocker_, uint256 allowedSlippage_) external returns (bool ok_) {
        ( ok_, ) = debtLocker_.call(abi.encodeWithSelector(IDebtLocker.setAllowedSlippage.selector, allowedSlippage_));
    }

    function try_debtLocker_setAuctioneer(address debtLocker_, address auctioneer_) external returns (bool ok_) {
        ( ok_, ) = debtLocker_.call(abi.encodeWithSelector(IDebtLocker.setAuctioneer.selector, auctioneer_));
    }

    function try_debtLocker_setFundsToCapture(address debtLocker_, uint256 amount_) external returns (bool ok_) {
        ( ok_, ) = debtLocker_.call(abi.encodeWithSelector(IDebtLocker.setFundsToCapture.selector, amount_));
    }

    function try_debtLocker_setMinRatio(address debtLocker_, uint256 minRatio_) external returns (bool ok_) {
        ( ok_, ) = debtLocker_.call(abi.encodeWithSelector(IDebtLocker.setMinRatio.selector, minRatio_));
    }

    function try_debtLocker_stopLiquidation(address debtLocker_) external returns (bool ok_) {
        ( ok_, ) = debtLocker_.call(abi.encodeWithSelector(IDebtLocker.stopLiquidation.selector));
    }
    
    function try_debtLocker_upgrade(address debtLocker_, uint256 toVersion_, bytes memory arguments_) external returns (bool ok_) {
        ( ok_, ) = debtLocker_.call(abi.encodeWithSelector(IMapleProxied.upgrade.selector, toVersion_, arguments_));
    }

}",789
RealWorld_BA_55_ManipulatableDebtLocker_RealWord_20240821145015.log,55,ManipulatableDebtLocker,7060,4837,11897,79.0,0.13204,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity ^0.8.7;

import { IMapleLoanLike } from ""../../interfaces/Interfaces.sol"";

import { DebtLocker } from ""../../DebtLocker.sol"";

contract ManipulatableDebtLocker is DebtLocker {

    bytes32 constant FACTORY_SLOT = bytes32(0x7a45a402e4cb6e08ebc196f20f66d5d30e67285a2a8aa80503fa409e727a4af1);

    constructor(address loan_, address pool_, address factory_) public {
        _loan = loan_;
        _pool = pool_;

        _principalRemainingAtLastClaim = IMapleLoanLike(loan_).principalRequested();

        setFactory(factory_);
    }

    /**************************************/
    /*** Storage Manipulation Functions ***/
    /**************************************/

    function setFactory(address factory_) public {
        _setSlotValue(FACTORY_SLOT, bytes32(uint256(uint160(factory_))));
    }

    function setPool(address pool_) external {
        _pool = pool_;
    }

}",232
RealWorld_BA_56_YearnControllerMock_RealWord_20240821165537.log,56,YearnControllerMock,9062,5117,14179,79.0,0.14765,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

import 'hardhat/console.sol';

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYearnController.sol';

contract YearnControllerMock is IYearnController {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    address public constant blackhole = 0x000000000000000000000000000000000000dEaD;

    uint256 public withdrawalFee = 50;
    uint256 public constant withdrawalMax = 10000;

    function setWithdrawalFee(uint256 _withdrawalFee) external {
        withdrawalFee = _withdrawalFee;
    }

    function balanceOf(address _token) external view override returns (uint256) {
        return IERC20(_token).balanceOf(address(this));
    }

    function earn(address _token, uint256 _amount) external override {}

    function withdraw(address _token, uint256 _amount) external override {
        uint256 _balance = IERC20(_token).balanceOf(address(this));
        // uint _fee = _amount.mul(withdrawalFee).div(withdrawalMax);

        // IERC20(_token).safeTransfer(blackhole, _fee);
        IERC20(_token).safeTransfer(msg.sender, _amount);
    }
}",346
RealWorld_BA_56_IWETH_RealWord_20240821163132.log,56,IWETH,4246,4692,8938,85.0,0.11507,"// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.5.0;

interface IWETH {
    function deposit() external payable;

    function transfer(address to, uint256 value) external returns (bool);

    function withdraw(uint256) external;
}",55
RealWorld_BA_56_MockFlamIncome_RealWord_20240821151847.log,56,MockFlamIncome,11208,5517,16725,84.0,0.16638,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""./MockERC20.sol"";

contract MockFlamIncomeVault is MockERC20 {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    IERC20 public token;

    uint public min = 9500;
    uint public constant max = 10000;

    constructor (address _token) public MockERC20(
        string(abi.encodePacked(""flamincomed "", ERC20(_token).name())),
        string(abi.encodePacked(""f"", ERC20(_token).symbol())),
        ERC20(_token).decimals()
    ) {
        token = IERC20(_token);
    }

    function balance() public view returns (uint) {
        return token.balanceOf(address(this));
    }

    function available() public view returns (uint) {
        return token.balanceOf(address(this)).mul(min).div(max);
    }

    function depositAll() external {
        deposit(token.balanceOf(msg.sender));
    }

    function deposit(uint _amount) public {
        uint _pool = balance();
        uint _before = token.balanceOf(address(this));
        token.safeTransferFrom(msg.sender, address(this), _amount);
        uint _after = token.balanceOf(address(this));
        _amount = _after.sub(_before);
        uint shares = 0;
        if (totalSupply() == 0) {
            shares = _amount;
        } else {
            shares = (_amount.mul(totalSupply())).div(_pool);
        }
        _mint(msg.sender, shares);
    }

    function withdrawAll() external {
        withdraw(balanceOf(msg.sender));
    }

    function withdraw(uint _shares) public {
        uint r = (balance().mul(_shares)).div(totalSupply());
        _burn(msg.sender, _shares);
        token.safeTransfer(msg.sender, r);
    }

    function priceE18() public view returns (uint) {
        return balance().mul(1e18).div(totalSupply());
    }
}",500
RealWorld_BA_56_Swap_RealWord_20240821150534.log,56,Swap,11398,5471,16869,94.0,0.16641,"// SPDX-License-Identifier: MIT
// solhint-disable var-name-mixedcase
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./interfaces/IsYAX.sol"";

/**
 * @title Swap
 * @notice This contract swaps a user's YAX and sYAX to the YAXIS token
 * If the user does not have YAX or sYAX, it will not attempt to swap
 * those assets in order to save gas.
 */
contract Swap {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    IERC20 public immutable YAXIS;
    IERC20 public immutable YAX;
    IERC20 public immutable SYAX;

    /**
     * @param _yaxis The YAXIS token address
     * @param _yax The YAX token address
     * @param _syax The sYAX token address
     */
    constructor(
        address _yaxis,
        address _yax,
        address _syax
    )
        public
    {
        YAXIS = IERC20(_yaxis);
        YAX = IERC20(_yax);
        SYAX = IERC20(_syax);
    }

    /**
     * @notice Swaps the user's YAX and sYAX for YAXIS
     * @dev Assumes this contract should never hold YAX directly
     * because it will send its entire balance to the caller.
     * @dev This contract must be funded with YAXIS before
     * users can call swap().
     */
    function swap()
        external
    {
        uint256 _balance = YAX.balanceOf(address(this));
        uint256 _amount = SYAX.balanceOf(msg.sender);
        if (_amount > 0) {
            SYAX.safeTransferFrom(msg.sender, address(this), _amount);
            IsYAX(address(SYAX)).exit();
        }
        _amount = YAX.balanceOf(msg.sender);
        if (_amount > 0) {
            YAX.safeTransferFrom(msg.sender, address(this), _amount);
        }
        _amount = YAX.balanceOf(address(this)).sub(_balance);
        if (_amount > 0) {
            YAXIS.safeTransfer(msg.sender, _amount);
        }
    }
}",522
RealWorld_BA_56_MetaVault_RealWord_20240821153810.log,56,MetaVault,110440,5594,116034,90.0,0.66408,"// SPDX-License-Identifier: MIT
// solhint-disable

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/GSN/Context.sol"";

import ""./IVaultManager.sol"";
import ""./IController.sol"";
import ""./IConverter.sol"";
import ""./IMetaVault.sol"";

/**
 * @title MetaVault (yAxisMetaVault)
 * @notice The metavault is where users deposit and withdraw stablecoins
 * @dev This metavault will pay YAX incentive for depositors and stakers
 * It does not need minter key of YAX. Governance multisig will mint total
 * of 34000 YAX and send into the vault in the beginning
 */
contract MetaVault is ERC20, IMetaVault {
    using Address for address;
    using SafeMath for uint;
    using SafeERC20 for IERC20;

    IERC20[4] public inputTokens; // DAI, USDC, USDT, 3Crv

    IERC20 public token3CRV;
    IERC20 public tokenYAX;

    uint public min = 9500;
    uint public constant max = 10000;

    uint public earnLowerlimit = 5 ether; // minimum to invest is 5 3CRV
    uint public totalDepositCap = 10000000 ether; // initial cap set at 10 million dollar

    address public governance;
    address public controller;
    uint public insurance;
    IVaultManager public vaultManager;
    IConverter public converter;

    bool public acceptContractDepositor = false; // dont accept contract at beginning

    struct UserInfo {
        uint amount;
        uint yaxRewardDebt;
        uint accEarned;
    }

    uint public lastRewardBlock;
    uint public accYaxPerShare;

    uint public yaxPerBlock;

    mapping(address => UserInfo) public userInfo;

    address public treasuryWallet = 0x362Db1c17db4C79B51Fe6aD2d73165b1fe9BaB4a;

    uint public constant BLOCKS_PER_WEEK = 46500;

    // Block number when each epoch ends.
    uint[5] public epochEndBlocks;

    // Reward multipler for each of 5 epoches (epochIndex: reward multipler)
    uint[6] public epochRewardMultiplers = [86000, 64000, 43000, 21000, 10000, 1];

    /**
     * @notice Emitted when a user deposits funds
     */
    event Deposit(address indexed user, uint amount);

    /**
     * @notice Emitted when a user withdraws funds
     */
    event Withdraw(address indexed user, uint amount);

    /**
     * @notice Emitted when YAX is paid to a user
     */
    event RewardPaid(address indexed user, uint reward);

    /**
     * @param _tokenDAI The address of the DAI token
     * @param _tokenUSDC The address of the USDC token
     * @param _tokenUSDT The address of the USDT token
     * @param _token3CRV The address of the 3CRV token
     * @param _tokenYAX The address of the YAX token
     * @param _yaxPerBlock The amount of YAX rewarded per block
     * @param _startBlock The starting block for rewards
     */
    constructor (IERC20 _tokenDAI, IERC20 _tokenUSDC, IERC20 _tokenUSDT, IERC20 _token3CRV, IERC20 _tokenYAX,
        uint _yaxPerBlock, uint _startBlock) public ERC20(""yAxis.io:MetaVault:3CRV"", ""MVLT"") {
        inputTokens[0] = _tokenDAI;
        inputTokens[1] = _tokenUSDC;
        inputTokens[2] = _tokenUSDT;
        inputTokens[3] = _token3CRV;
        token3CRV = _token3CRV;
        tokenYAX = _tokenYAX;
        yaxPerBlock = _yaxPerBlock; // supposed to be 0.000001 YAX (1000000000000 = 1e12 wei)
        lastRewardBlock = (_startBlock > block.number) ? _startBlock : block.number; // supposed to be 11,163,000 (Sat Oct 31 2020 06:30:00 GMT+0)
        epochEndBlocks[0] = lastRewardBlock + BLOCKS_PER_WEEK * 2; // weeks 1-2
        epochEndBlocks[1] = epochEndBlocks[0] + BLOCKS_PER_WEEK * 2; // weeks 3-4
        epochEndBlocks[2] = epochEndBlocks[1] + BLOCKS_PER_WEEK * 4; // month 2
        epochEndBlocks[3] = epochEndBlocks[2] + BLOCKS_PER_WEEK * 8; // month 3-4
        epochEndBlocks[4] = epochEndBlocks[3] + BLOCKS_PER_WEEK * 8; // month 5-6
        governance = msg.sender;
    }

    /**
     * @dev Throws if called by a contract and we are not allowing.
     */
    modifier checkContract() {
        if (!acceptContractDepositor) {
            require(!address(msg.sender).isContract() && msg.sender == tx.origin, ""Sorry we do not accept contract!"");
        }
        _;
    }

    /**
     * @notice Returns the current token3CRV balance of the vault and controller, minus insurance
     * @dev Ignore insurance fund for balance calculations
     */
    function balance() public override view returns (uint) {
        uint bal = token3CRV.balanceOf(address(this));
        if (controller != address(0)) bal = bal.add(IController(controller).balanceOf(address(token3CRV)));
        return bal.sub(insurance);
    }

    /**
     * @notice Called by Governance to set the value for min
     * @param _min The new min value
     */
    function setMin(uint _min) external {
        require(msg.sender == governance, ""!governance"");
        min = _min;
    }

    /**
     * @notice Called by Governance to set the value for the governance address
     * @param _governance The new governance value
     */
    function setGovernance(address _governance) public {
        require(msg.sender == governance, ""!governance"");
        governance = _governance;
    }

    /**
     * @notice Called by Governance to set the value for the controller address
     * @param _controller The new controller value
     */
    function setController(address _controller) public override {
        require(msg.sender == governance, ""!governance"");
        controller = _controller;
    }

    /**
     * @notice Called by Governance to set the value for the converter address
     * @param _converter The new converter value
     * @dev Requires that the return address of token() from the converter is the
     * same as token3CRV
     */
    function setConverter(IConverter _converter) public {
        require(msg.sender == governance, ""!governance"");
        require(_converter.token() == address(token3CRV), ""!token3CRV"");
        converter = _converter;
    }

    /**
     * @notice Called by Governance to set the value for the vaultManager address
     * @param _vaultManager The new vaultManager value
     */
    function setVaultManager(IVaultManager _vaultManager) public {
        require(msg.sender == governance, ""!governance"");
        vaultManager = _vaultManager;
    }

    /**
     * @notice Called by Governance to set the value for the earnLowerlimit
     * @dev earnLowerlimit determines the minimum balance of this contract for earn
     * to be called
     * @param _earnLowerlimit The new earnLowerlimit value
     */
    function setEarnLowerlimit(uint _earnLowerlimit) public {
        require(msg.sender == governance, ""!governance"");
        earnLowerlimit = _earnLowerlimit;
    }

    /**
     * @notice Called by Governance to set the value for the totalDepositCap
     * @dev totalDepositCap is the maximum amount of value that can be deposited
     * to the metavault at a time
     * @param _totalDepositCap The new totalDepositCap value
     */
    function setTotalDepositCap(uint _totalDepositCap) public {
        require(msg.sender == governance, ""!governance"");
        totalDepositCap = _totalDepositCap;
    }

    /**
     * @notice Called by Governance to set the value for acceptContractDepositor
     * @dev acceptContractDepositor allows the metavault to accept deposits from
     * smart contract addresses
     * @param _acceptContractDepositor The new acceptContractDepositor value
     */
    function setAcceptContractDepositor(bool _acceptContractDepositor) public {
        require(msg.sender == governance, ""!governance"");
        acceptContractDepositor = _acceptContractDepositor;
    }

    /**
     * @notice Called by Governance to set the value for yaxPerBlock
     * @dev Makes a call to updateReward()
     * @param _yaxPerBlock The new yaxPerBlock value
     */
    function setYaxPerBlock(uint _yaxPerBlock) public {
        require(msg.sender == governance, ""!governance"");
        updateReward();
        yaxPerBlock = _yaxPerBlock;
    }

    /**
     * @notice Called by Governance to set the value for epochEndBlocks at the given index
     * @dev Throws if _index >= 5
     * @dev Throws if _epochEndBlock > the current block.number
     * @dev Throws if the stored block.number at the given index is > the current block.number
     * @param _index The index to set of epochEndBlocks
     * @param _epochEndBlock The new epochEndBlocks value at the index
     */
    function setEpochEndBlock(uint8 _index, uint256 _epochEndBlock) public {
        require(msg.sender == governance, ""!governance"");
        require(_index < 5, ""_index out of range"");
        require(_epochEndBlock > block.number, ""Too late to update"");
        require(epochEndBlocks[_index] > block.number, ""Too late to update"");
        epochEndBlocks[_index] = _epochEndBlock;
    }

    /**
     * @notice Called by Governance to set the value for epochRewardMultiplers at the given index
     * @dev Throws if _index < 1 or > 5
     * @dev Throws if the stored block.number at the previous index is > the current block.number
     * @param _index The index to set of epochRewardMultiplers
     * @param _epochRewardMultipler The new epochRewardMultiplers value at the index
     */
    function setEpochRewardMultipler(uint8 _index, uint256 _epochRewardMultipler) public {
        require(msg.sender == governance, ""!governance"");
        require(_index > 0 && _index < 6, ""Index out of range"");
        require(epochEndBlocks[_index - 1] > block.number, ""Too late to update"");
        epochRewardMultiplers[_index] = _epochRewardMultipler;
    }

    /**
     * @notice Return reward multiplier over the given _from to _to block.
     * @param _from The from block
     * @param _to The to block
     */
    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {
        // start at the end of the epochs
        for (uint8 epochId = 5; epochId >= 1; --epochId) {
            // if _to (the current block number if called within this contract) is after the previous epoch ends
            if (_to >= epochEndBlocks[epochId - 1]) {
                // if the last reward block is after the previous epoch: return the number of blocks multiplied by this epochs multiplier
                if (_from >= epochEndBlocks[epochId - 1]) return _to.sub(_from).mul(epochRewardMultiplers[epochId]);
                // get the multiplier amount for the remaining reward of the current epoch
                uint256 multiplier = _to.sub(epochEndBlocks[epochId - 1]).mul(epochRewardMultiplers[epochId]);
                // if epoch is 1: return the remaining current epoch reward with the first epoch reward
                if (epochId == 1) return multiplier.add(epochEndBlocks[0].sub(_from).mul(epochRewardMultiplers[0]));
                // for all epochs in between the first and current epoch
                for (epochId = epochId - 1; epochId >= 1; --epochId) {
                    // if the last reward block is after the previous epoch: return the current remaining reward with the previous epoch
                    if (_from >= epochEndBlocks[epochId - 1]) return multiplier.add(epochEndBlocks[epochId].sub(_from).mul(epochRewardMultiplers[epochId]));
                    // accumulate the multipler with the reward from the epoch
                    multiplier = multiplier.add(epochEndBlocks[epochId].sub(epochEndBlocks[epochId - 1]).mul(epochRewardMultiplers[epochId]));
                }
                // return the accumulated multiplier with the reward from the first epoch
                return multiplier.add(epochEndBlocks[0].sub(_from).mul(epochRewardMultiplers[0]));
            }
        }
        // return the reward amount between _from and _to in the first epoch
        return _to.sub(_from).mul(epochRewardMultiplers[0]);
    }

    /**
     * @notice Called by Governance to set the value for the treasuryWallet
     * @param _treasuryWallet The new treasuryWallet value
     */
    function setTreasuryWallet(address _treasuryWallet) public {
        require(msg.sender == governance, ""!governance"");
        treasuryWallet = _treasuryWallet;
    }

    /**
     * @notice Called by Governance or the controller to claim the amount stored in the insurance fund
     * @dev If called by the controller, insurance will auto compound the vault, increasing getPricePerFullShare
     */
    function claimInsurance() external override {
        // if claim by controller for auto-compounding (current insurance will stay to increase sharePrice)
        // otherwise send the fund to treasuryWallet
        if (msg.sender != controller) {
            // claim by governance for insurance
            require(msg.sender == governance, ""!governance"");
            token3CRV.safeTransfer(treasuryWallet, insurance);
        }
        insurance = 0;
    }

    /**
     * @notice Get the address of the 3CRV token
     */
    function token() public override view returns (address) {
        return address(token3CRV);
    }

    /**
     * @notice Get the amount that the metavault allows to be borrowed
     * @dev min and max are used to keep small withdrawals cheap
     */
    function available() public override view returns (uint) {
        return token3CRV.balanceOf(address(this)).mul(min).div(max);
    }

    /**
     * @notice If the controller is set, returns the withdrawFee of the 3CRV token for the given _amount
     * @param _amount The amount being queried to withdraw
     */
    function withdrawFee(uint _amount) public override view returns (uint) {
        return (controller == address(0)) ? 0 : IController(controller).withdrawFee(address(token3CRV), _amount);
    }

    /**
     * @notice Sends accrued 3CRV tokens on the metavault to the controller to be deposited to strategies
     */
    function earn() public override {
        if (controller != address(0)) {
            IController _contrl = IController(controller);
            if (_contrl.investEnabled()) {
                uint _bal = available();
                token3CRV.safeTransfer(controller, _bal);
                _contrl.earn(address(token3CRV), _bal);
            }
        }
    }

    /**
     * @notice Returns the amount of 3CRV given for the amounts deposited
     * @param amounts The stablecoin amounts being deposited
     */
    function calc_token_amount_deposit(uint[3] calldata amounts) external override view returns (uint) {
        return converter.calc_token_amount(amounts, true);
    }

    /**
     * @notice Returns the amount given in the desired token for the given shares
     * @param _shares The amount of shares to withdraw
     * @param _output The desired token to withdraw
     */
    function calc_token_amount_withdraw(uint _shares, address _output) external override view returns (uint) {
        uint _withdrawFee = withdrawFee(_shares);
        if (_withdrawFee > 0) {
            _shares = _shares.mul(10000 - _withdrawFee).div(10000);
        }
        uint r = (balance().mul(_shares)).div(totalSupply());
        if (_output == address(token3CRV)) {
            return r;
        }
        return converter.calc_token_amount_withdraw(r, _output);
    }

    /**
     * @notice Returns the amount of 3CRV that would be given for the amount of input tokens
     * @param _input The stablecoin to convert to 3CRV
     * @param _amount The amount of stablecoin to convert
     */
    function convert_rate(address _input, uint _amount) external override view returns (uint) {
        return converter.convert_rate(_input, address(token3CRV), _amount);
    }

    /**
     * @notice Deposit a single stablecoin to the metavault
     * @dev Users must approve the metavault to spend their stablecoin
     * @param _amount The amount of the stablecoin to deposit
     * @param _input The address of the stablecoin being deposited
     * @param _min_mint_amount The expected amount of shares to receive
     * @param _isStake Stakes shares or not
     */
    function deposit(uint _amount, address _input, uint _min_mint_amount, bool _isStake) external override checkContract {
        require(_amount > 0, ""!_amount"");
        uint _pool = balance();
        uint _before = token3CRV.balanceOf(address(this));
        if (_input == address(token3CRV)) {
            token3CRV.safeTransferFrom(msg.sender, address(this), _amount);
        } else if (converter.convert_rate(_input, address(token3CRV), _amount) > 0) {
            IERC20(_input).safeTransferFrom(msg.sender, address(converter), _amount);
            converter.convert(_input, address(token3CRV), _amount);
        }
        uint _after = token3CRV.balanceOf(address(this));
        require(totalDepositCap == 0 || _after <= totalDepositCap, "">totalDepositCap"");
        _amount = _after.sub(_before); // Additional check for deflationary tokens
        require(_amount >= _min_mint_amount, ""slippage"");
        if (_amount > 0) {
            if (!_isStake) {
                _deposit(msg.sender, _pool, _amount);
            } else {
                uint _shares = _deposit(address(this), _pool, _amount);
                _stakeShares(_shares);
            }
        }
    }

    /**
     * @notice Deposits multiple stablecoins simultaneously to the metavault
     * @dev 0: DAI, 1: USDC, 2: USDT, 3: 3CRV
     * @dev Users must approve the metavault to spend their stablecoin
     * @param _amounts The amounts of each stablecoin being deposited
     * @param _min_mint_amount The expected amount of shares to receive
     * @param _isStake Stakes shares or not
     */
    function depositAll(uint[4] calldata _amounts, uint _min_mint_amount, bool _isStake) external checkContract {
        uint _pool = balance();
        uint _before = token3CRV.balanceOf(address(this));
        bool hasStables = false;
        for (uint8 i = 0; i < 4; i++) {
            uint _inputAmount = _amounts[i];
            if (_inputAmount > 0) {
                if (i == 3) {
                    inputTokens[i].safeTransferFrom(msg.sender, address(this), _inputAmount);
                } else if (converter.convert_rate(address(inputTokens[i]), address(token3CRV), _inputAmount) > 0) {
                    inputTokens[i].safeTransferFrom(msg.sender, address(converter), _inputAmount);
                    hasStables = true;
                }
            }
        }
        if (hasStables) {
            uint[3] memory _stablesAmounts;
            _stablesAmounts[0] = _amounts[0];
            _stablesAmounts[1] = _amounts[1];
            _stablesAmounts[2] = _amounts[2];
            converter.convert_stables(_stablesAmounts);
        }
        uint _after = token3CRV.balanceOf(address(this));
        require(totalDepositCap == 0 || _after <= totalDepositCap, "">totalDepositCap"");
        uint _totalDepositAmount = _after.sub(_before); // Additional check for deflationary tokens
        require(_totalDepositAmount >= _min_mint_amount, ""slippage"");
        if (_totalDepositAmount > 0) {
            if (!_isStake) {
                _deposit(msg.sender, _pool, _totalDepositAmount);
            } else {
                uint _shares = _deposit(address(this), _pool, _totalDepositAmount);
                _stakeShares(_shares);
            }
        }
    }

    /**
     * @notice Stakes metavault shares
     * @param _shares The amount of shares to stake
     */
    function stakeShares(uint _shares) external {
        uint _before = balanceOf(address(this));
        IERC20(address(this)).transferFrom(msg.sender, address(this), _shares);
        uint _after = balanceOf(address(this));
        _shares = _after.sub(_before);
        // Additional check for deflationary tokens
        _stakeShares(_shares);
    }

    function _deposit(address _mintTo, uint _pool, uint _amount) internal returns (uint _shares) {
        if (address(vaultManager) != address(0)) {
            // expected 0.1% of deposits go into an insurance fund (or auto-compounding if called by controller) in-case of negative profits to protect withdrawals
            // it is updated by governance (community vote)
            uint _insuranceFee = vaultManager.insuranceFee();
            if (_insuranceFee > 0) {
                uint _insurance = _amount.mul(_insuranceFee).div(10000);
                _amount = _amount.sub(_insurance);
                insurance = insurance.add(_insurance);
            }
        }

        if (totalSupply() == 0) {
            _shares = _amount;
        } else {
            _shares = (_amount.mul(totalSupply())).div(_pool);
        }
        if (_shares > 0) {
            if (token3CRV.balanceOf(address(this)) > earnLowerlimit) {
                earn();
            }
            _mint(_mintTo, _shares);
        }
    }

    function _stakeShares(uint _shares) internal {
        UserInfo storage user = userInfo[msg.sender];
        updateReward();
        _getReward();
        user.amount = user.amount.add(_shares);
        user.yaxRewardDebt = user.amount.mul(accYaxPerShare).div(1e12);
        emit Deposit(msg.sender, _shares);
    }

    /**
     * @notice Returns the pending YAXs for a given account
     * @param _account The address to query
     */
    function pendingYax(address _account) public view returns (uint _pending) {
        UserInfo storage user = userInfo[_account];
        uint _accYaxPerShare = accYaxPerShare;
        uint lpSupply = balanceOf(address(this));
        if (block.number > lastRewardBlock && lpSupply != 0) {
            uint256 _multiplier = getMultiplier(lastRewardBlock, block.number);
            _accYaxPerShare = accYaxPerShare.add(_multiplier.mul(yaxPerBlock).mul(1e12).div(lpSupply));
        }
        _pending = user.amount.mul(_accYaxPerShare).div(1e12).sub(user.yaxRewardDebt);
    }

    /**
     * @notice Sets the lastRewardBlock and accYaxPerShare
     */
    function updateReward() public {
        if (block.number <= lastRewardBlock) {
            return;
        }
        uint lpSupply = balanceOf(address(this));
        if (lpSupply == 0) {
            lastRewardBlock = block.number;
            return;
        }
        uint256 _multiplier = getMultiplier(lastRewardBlock, block.number);
        accYaxPerShare = accYaxPerShare.add(_multiplier.mul(yaxPerBlock).mul(1e12).div(lpSupply));
        lastRewardBlock = block.number;
    }

    function _getReward() internal {
        UserInfo storage user = userInfo[msg.sender];
        uint _pendingYax = user.amount.mul(accYaxPerShare).div(1e12).sub(user.yaxRewardDebt);
        if (_pendingYax > 0) {
            user.accEarned = user.accEarned.add(_pendingYax);
            safeYaxTransfer(msg.sender, _pendingYax);
            emit RewardPaid(msg.sender, _pendingYax);
        }
    }

    /**
     * @notice Withdraw the entire balance for an account
     * @param _output The address of the desired stablecoin to receive
     */
    function withdrawAll(address _output) external {
        unstake(userInfo[msg.sender].amount);
        withdraw(balanceOf(msg.sender), _output);
    }

    /**
     * @notice Used to swap any borrowed reserve over the debt limit to liquidate to 'token'
     * @param reserve The address of the token to swap to 3CRV
     * @param amount The amount to swap
     */
    function harvest(address reserve, uint amount) external override {
        require(msg.sender == controller, ""!controller"");
        require(reserve != address(token3CRV), ""token3CRV"");
        IERC20(reserve).safeTransfer(controller, amount);
    }

    /**
     * @notice Unstakes the given shares from the metavault
     * @dev call unstake(0) to only receive the reward
     * @param _amount The amount to unstake
     */
    function unstake(uint _amount) public {
        updateReward();
        _getReward();
        UserInfo storage user = userInfo[msg.sender];
        if (_amount > 0) {
            require(user.amount >= _amount, ""stakedBal < _amount"");
            user.amount = user.amount.sub(_amount);
            IERC20(address(this)).transfer(msg.sender, _amount);
        }
        user.yaxRewardDebt = user.amount.mul(accYaxPerShare).div(1e12);
        emit Withdraw(msg.sender, _amount);
    }

    /**
     * @notice Withdraws an amount of shares to a given output stablecoin
     * @dev No rebalance implementation for lower fees and faster swaps
     * @param _shares The amount of shares to withdraw
     * @param _output The address of the stablecoin to receive
     */
    function withdraw(uint _shares, address _output) public override {
        uint _userBal = balanceOf(msg.sender);
        if (_shares > _userBal) {
            uint _need = _shares.sub(_userBal);
            require(_need <= userInfo[msg.sender].amount, ""_userBal+staked < _shares"");
            unstake(_need);
        }
        uint r = (balance().mul(_shares)).div(totalSupply());
        _burn(msg.sender, _shares);

        if (address(vaultManager) != address(0)) {
            // expected 0.1% of withdrawal go back to vault (for auto-compounding) to protect withdrawals
            // it is updated by governance (community vote)
            uint _withdrawalProtectionFee = vaultManager.withdrawalProtectionFee();
            if (_withdrawalProtectionFee > 0) {
                uint _withdrawalProtection = r.mul(_withdrawalProtectionFee).div(10000);
                r = r.sub(_withdrawalProtection);
            }
        }

        // Check balance
        uint b = token3CRV.balanceOf(address(this));
        if (b < r) {
            uint _toWithdraw = r.sub(b);
            if (controller != address(0)) {
                IController(controller).withdraw(address(token3CRV), _toWithdraw);
            }
            uint _after = token3CRV.balanceOf(address(this));
            uint _diff = _after.sub(b);
            if (_diff < _toWithdraw) {
                r = b.add(_diff);
            }
        }

        if (_output == address(token3CRV)) {
            token3CRV.safeTransfer(msg.sender, r);
        } else {
            require(converter.convert_rate(address(token3CRV), _output, r) > 0, ""rate=0"");
            token3CRV.safeTransfer(address(converter), r);
            uint _outputAmount = converter.convert(address(token3CRV), _output, r);
            IERC20(_output).safeTransfer(msg.sender, _outputAmount);
        }
    }

    /**
     * @notice Returns the address of the 3CRV token
     */
    function want() external override view returns (address) {
        return address(token3CRV);
    }

    /**
     * @notice Returns the rate of earnings of a single share
     */
    function getPricePerFullShare() external override view returns (uint) {
        return balance().mul(1e18).div(totalSupply());
    }

    /**
     * @notice Transfers YAX from the metavault to a given address
     * @dev Ensures the metavault has enough balance to transfer
     * @param _to The address to transfer to
     * @param _amount The amount to transfer
     */
    function safeYaxTransfer(address _to, uint _amount) internal {
        uint _tokenBal = tokenYAX.balanceOf(address(this));
        tokenYAX.safeTransfer(_to, (_tokenBal < _amount) ? _tokenBal : _amount);
    }

    /**
     * @notice Converts non-3CRV stablecoins held in the metavault to 3CRV
     * @param _token The address to convert
     */
    function earnExtra(address _token) public {
        require(msg.sender == governance, ""!governance"");
        require(address(_token) != address(token3CRV), ""3crv"");
        require(address(_token) != address(this), ""mlvt"");
        uint _amount = IERC20(_token).balanceOf(address(this));
        require(converter.convert_rate(_token, address(token3CRV), _amount) > 0, ""rate=0"");
        IERC20(_token).safeTransfer(address(converter), _amount);
        converter.convert(_token, address(token3CRV), _amount);
    }
}",6761
RealWorld_BA_56_ILegacyController_RealWord_20240821161840.log,56,ILegacyController,3516,4249,7765,74.0,0.10256,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

interface ILegacyController {
    function legacyDeposit(uint256 _expected) external;
}",34
RealWorld_BA_56_MockStabilizePool_RealWord_20240821153404.log,56,MockStabilizePool,11380,5004,16384,64.0,0.15698,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""../interfaces/Stabilize.sol"";

contract MockStabilizePool is IZPAPool {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    IERC20 public lpToken;
    IERC20 public rewardToken;
    uint256 public rewardRate;

    struct UserInfo {
        uint256 amount;
        uint256 rewardDebt;
        uint256 unclaimedReward;
    }

    mapping(uint256 => mapping(address => UserInfo)) private userInfo;
    mapping(uint256 => address) public override poolTokenAddress;

    constructor(
        address _lpToken,
        address _rewardToken,
        uint256 _rewardRate
    ) public {
        lpToken = IERC20(_lpToken);
        rewardToken = IERC20(_rewardToken);
        rewardRate = _rewardRate;
    }

    function deposit(uint256 _pid, uint256 _amount) external override {
        userInfo[_pid][msg.sender].amount = userInfo[_pid][msg.sender].amount.add(_amount);
        lpToken.safeTransferFrom(msg.sender, address(this), _amount);
    }

    function withdraw(uint256 _pid, uint256 _amount) public override {
        userInfo[_pid][msg.sender].amount = userInfo[_pid][msg.sender].amount.sub(_amount);
        lpToken.safeTransfer(msg.sender, _amount);
    }

    function exit(uint256 _pid, uint256 _amount) external override {
        withdraw(_pid, _amount);
        getReward(_pid);
    }

    function getReward(uint256 _pid) public override {
        uint256 _amount = rewardEarned(_pid, msg.sender);
        rewardToken.safeTransfer(msg.sender, _amount);
    }

    function rewardEarned(uint256 _pid, address _user) public view override returns (uint256) {
        return poolBalance(_pid, _user).mul(rewardRate).div(1000);
    }

    function poolBalance(uint256 _pid, address _user) public view override returns (uint256) {
        return userInfo[_pid][_user].amount;
    }
}",492
RealWorld_BA_56_Manager_RealWord_20240821155200.log,56,Manager,53697,5845,59542,97.0,0.385385,"// SPDX-License-Identifier: MIT
// solhint-disable max-states-count
// solhint-disable var-name-mixedcase

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./interfaces/IController.sol"";
import ""./interfaces/IConverter.sol"";
import ""./interfaces/IHarvester.sol"";
import ""./interfaces/IManager.sol"";
import ""./interfaces/IStrategy.sol"";
import ""./interfaces/IVault.sol"";

/**
 * @title Manager
 * @notice This contract serves as the central point for governance-voted
 * variables. Fees and permissioned addresses are stored and referenced in
 * this contract only.
 */
contract Manager is IManager {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    uint256 public constant PENDING_STRATEGIST_TIMELOCK = 7 days;
    uint256 public constant MAX_TOKENS = 256;

    address public immutable override yaxis;

    bool public override halted;

    address public override governance;
    address public override harvester;
    address public override insurancePool;
    address public override stakingPool;
    address public override strategist;
    address public override pendingStrategist;
    address public override treasury;

    // The following fees are all mutable.
    // They are updated by governance (community vote).
    uint256 public override insuranceFee;
    uint256 public override insurancePoolFee;
    uint256 public override stakingPoolShareFee;
    uint256 public override treasuryFee;
    uint256 public override withdrawalProtectionFee;


    uint256 private setPendingStrategistTime;

    // Governance must first allow the following properties before
    // the strategist can make use of them
    mapping(address => bool) public override allowedControllers;
    mapping(address => bool) public override allowedConverters;
    mapping(address => bool) public override allowedStrategies;
    mapping(address => bool) public override allowedVaults;

    // vault => controller
    mapping(address => address) public override controllers;
    // vault => token
    mapping(address => address) internal tokens;

    event AllowedController(
        address indexed _controller,
        bool _allowed
    );
    event AllowedConverter(
        address indexed _converter,
        bool _allowed
    );
    event AllowedStrategy(
        address indexed _strategy,
        bool _allowed
    );
    event AllowedVault(
        address indexed _vault,
        bool _allowed
    );
    event Halted();
    event SetController(
        address indexed _vault,
        address indexed _controller
    );
    event SetGovernance(
        address indexed _governance
    );
    event SetPendingStrategist(
        address indexed _strategist
    );
    event SetStrategist(
        address indexed _strategist
    );
    event VaultAdded(
        address indexed _vault,
        address indexed _token
    );
    event VaultRemoved(
        address indexed _vault
    );

    /**
     * @param _yaxis The address of the YAX token
     */
    constructor(
        address _yaxis
    )
        public
    {
        require(_yaxis != address(0), ""!_yaxis"");
        yaxis = _yaxis;
        governance = msg.sender;
        strategist = msg.sender;
        harvester = msg.sender;
        treasury = msg.sender;
        stakingPoolShareFee = 2000;
        treasuryFee = 500;
        withdrawalProtectionFee = 10;
    }

    /**
     * GOVERNANCE-ONLY FUNCTIONS
     */

    /**
     * @notice Sets the permission for the given controller
     * @param _controller The address of the controller
     * @param _allowed The status of if it is allowed
     */
    function setAllowedController(
        address _controller,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IController(_controller).manager()) == address(this), ""!manager"");
        allowedControllers[_controller] = _allowed;
        emit AllowedController(_controller, _allowed);
    }

    /**
     * @notice Sets the permission for the given converter
     * @param _converter The address of the converter
     * @param _allowed The status of if it is allowed
     */
    function setAllowedConverter(
        address _converter,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IConverter(_converter).manager()) == address(this), ""!manager"");
        allowedConverters[_converter] = _allowed;
        emit AllowedConverter(_converter, _allowed);
    }

    /**
     * @notice Sets the permission for the given strategy
     * @param _strategy The address of the strategy
     * @param _allowed The status of if it is allowed
     */
    function setAllowedStrategy(
        address _strategy,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IStrategy(_strategy).manager()) == address(this), ""!manager"");
        allowedStrategies[_strategy] = _allowed;
        emit AllowedStrategy(_strategy, _allowed);
    }

    /**
     * @notice Sets the permission for the given vault
     * @param _vault The address of the vault
     * @param _allowed The status of if it is allowed
     */
    function setAllowedVault(
        address _vault,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IVault(_vault).manager()) == address(this), ""!manager"");
        allowedVaults[_vault] = _allowed;
        emit AllowedVault(_vault, _allowed);
    }

    /**
     * @notice Sets the governance address
     * @param _governance The address of the governance
     */
    function setGovernance(
        address _governance
    )
        external
        notHalted
        onlyGovernance
    {
        governance = _governance;
        emit SetGovernance(_governance);
    }

    /**
     * @notice Sets the harvester address
     * @param _harvester The address of the harvester
     */
    function setHarvester(
        address _harvester
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IHarvester(_harvester).manager()) == address(this), ""!manager"");
        harvester = _harvester;
    }

    /**
     * @notice Sets the insurance fee
     * @dev Throws if setting fee over 1%
     * @param _insuranceFee The value for the insurance fee
     */
    function setInsuranceFee(
        uint256 _insuranceFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_insuranceFee <= 100, ""_insuranceFee over 1%"");
        insuranceFee = _insuranceFee;
    }

    /**
     * @notice Sets the insurance pool address
     * @param _insurancePool The address of the insurance pool
     */
    function setInsurancePool(
        address _insurancePool
    )
        external
        notHalted
        onlyGovernance
    {
        insurancePool = _insurancePool;
    }

    /**
     * @notice Sets the insurance pool fee
     * @dev Throws if setting fee over 20%
     * @param _insurancePoolFee The value for the insurance pool fee
     */
    function setInsurancePoolFee(
        uint256 _insurancePoolFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_insurancePoolFee <= 2000, ""_insurancePoolFee over 20%"");
        insurancePoolFee = _insurancePoolFee;
    }

    /**
     * @notice Sets the staking pool address
     * @param _stakingPool The address of the staking pool
     */
    function setStakingPool(
        address _stakingPool
    )
        external
        notHalted
        onlyGovernance
    {
        stakingPool = _stakingPool;
    }

    /**
     * @notice Sets the staking pool share fee
     * @dev Throws if setting fee over 50%
     * @param _stakingPoolShareFee The value for the staking pool fee
     */
    function setStakingPoolShareFee(
        uint256 _stakingPoolShareFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_stakingPoolShareFee <= 5000, ""_stakingPoolShareFee over 50%"");
        stakingPoolShareFee = _stakingPoolShareFee;
    }

    /**
     * @notice Sets the pending strategist and the timestamp
     * @param _strategist The address of the strategist
     */
    function setStrategist(
        address _strategist
    )
        external
        notHalted
        onlyGovernance
    {
        require(_strategist != address(0), ""!_strategist"");
        pendingStrategist = _strategist;
        // solhint-disable-next-line not-rely-on-time
        setPendingStrategistTime = block.timestamp;
        emit SetPendingStrategist(_strategist);
    }

    /**
     * @notice Sets the treasury address
     * @param _treasury The address of the treasury
     */
    function setTreasury(
        address _treasury
    )
        external
        notHalted
        onlyGovernance
    {
        require(_treasury != address(0), ""!_treasury"");
        treasury = _treasury;
    }

    /**
     * @notice Sets the treasury fee
     * @dev Throws if setting fee over 20%
     * @param _treasuryFee The value for the treasury fee
     */
    function setTreasuryFee(
        uint256 _treasuryFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_treasuryFee <= 2000, ""_treasuryFee over 20%"");
        treasuryFee = _treasuryFee;
    }

    /**
     * @notice Sets the withdrawal protection fee
     * @dev Throws if setting fee over 1%
     * @param _withdrawalProtectionFee The value for the withdrawal protection fee
     */
    function setWithdrawalProtectionFee(
        uint256 _withdrawalProtectionFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_withdrawalProtectionFee <= 100, ""_withdrawalProtectionFee over 1%"");
        withdrawalProtectionFee = _withdrawalProtectionFee;
    }

    /**
     * STRATEGIST-ONLY FUNCTIONS
     */

    /**
     * @notice Updates the strategist to the pending strategist
     * @dev This can only be called after the pending strategist timelock (7 days)
     */
    function acceptStrategist()
        external
        notHalted
    {
        require(msg.sender == pendingStrategist, ""!pendingStrategist"");
        // solhint-disable-next-line not-rely-on-time
        require(block.timestamp > setPendingStrategistTime.add(PENDING_STRATEGIST_TIMELOCK), ""PENDING_STRATEGIST_TIMELOCK"");
        delete pendingStrategist;
        delete setPendingStrategistTime;
        strategist = msg.sender;
        emit SetStrategist(msg.sender);
    }

    /**
     * @notice Adds a token to be able to be deposited for a given vault
     * @param _vault The address of the vault
     */
    function addVault(
        address _vault
    )
        external
        override
        notHalted
        onlyStrategist
    {
        require(allowedVaults[_vault], ""!allowedVaults"");
        require(tokens[_vault] == address(0), ""!_vault"");
        address _token = IVault(_vault).getToken();
        tokens[_vault] = _token;
        emit VaultAdded(_vault, _token);
    }

    /**
     * @notice Allows the strategist to pull tokens out of this contract
     * @dev This contract should never hold tokens
     * @param _token The address of the token
     * @param _amount The amount to withdraw
     * @param _to The address to send to
     */
    function recoverToken(
        IERC20 _token,
        uint256 _amount,
        address _to
    )
        external
        notHalted
        onlyStrategist
    {
        _token.safeTransfer(_to, _amount);
    }

    /**
     * @notice Removes a token from being able to be deposited for a given vault
     * @param _vault The address of the vault
     */
    function removeVault(
        address _vault
    )
        external
        override
        notHalted
        onlyStrategist
    {
        require(tokens[_vault] != address(0), ""!_vault"");
        delete tokens[_vault];
        delete allowedVaults[_vault];
        emit VaultRemoved(_vault);
    }

    /**
     * @notice Sets the vault address for a controller
     * @param _vault The address of the vault
     * @param _controller The address of the controller
     */
    function setController(
        address _vault,
        address _controller
    )
        external
        notHalted
        onlyStrategist
    {
        require(allowedVaults[_vault], ""!_vault"");
        require(allowedControllers[_controller], ""!_controller"");
        controllers[_vault] = _controller;
        emit SetController(_vault, _controller);
    }

    /**
     * @notice Sets the protocol as halted, disallowing all deposits forever
     * @dev Withdraws will still work, allowing users to exit the protocol
     */
    function setHalted()
        external
        notHalted
        onlyStrategist
    {
        halted = true;
        emit Halted();
    }

    /**
     * EXTERNAL VIEW FUNCTIONS
     */

    /**
     * @notice Returns an array of token addresses for a given vault
     * @param _vault The address of the vault
     */
    function getToken(
        address _vault
    )
        external
        view
        override
        returns (address)
    {
        return tokens[_vault];
    }

    /**
     * @notice Returns a tuple of:
     *     YAXIS token address,
     *     Treasury address,
     *     Treasury fee
     */
    function getHarvestFeeInfo()
        external
        view
        override
        returns (
            address,
            address,
            uint256
        )
    {
        return (
            yaxis,
            treasury,
            treasuryFee
        );
    }

    modifier notHalted() {
        require(!halted, ""halted"");
        _;
    }

    modifier onlyGovernance() {
        require(msg.sender == governance, ""!governance"");
        _;
    }

    modifier onlyStrategist() {
        require(msg.sender == strategist, ""!strategist"");
        _;
    }
}",3191
RealWorld_BA_56_MerkleDistributor_RealWord_20240821150710.log,56,MerkleDistributor,9976,5099,15075,73.0,0.15186,"// SPDX-License-Identifier: UNLICENSED
// solhint-disable
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/cryptography/MerkleProof.sol"";
import ""./interfaces/IMerkleDistributor.sol"";

contract MerkleDistributor is IMerkleDistributor {
    address public immutable override token;
    bytes32 public immutable override merkleRoot;

    // This is a packed array of booleans.
    mapping(uint256 => uint256) private claimedBitMap;

    constructor(address token_, bytes32 merkleRoot_) public {
        token = token_;
        merkleRoot = merkleRoot_;
    }

    function isClaimed(uint256 index) public view override returns (bool) {
        uint256 claimedWordIndex = index / 256;
        uint256 claimedBitIndex = index % 256;
        uint256 claimedWord = claimedBitMap[claimedWordIndex];
        uint256 mask = (1 << claimedBitIndex);
        return claimedWord & mask == mask;
    }

    function _setClaimed(uint256 index) private {
        uint256 claimedWordIndex = index / 256;
        uint256 claimedBitIndex = index % 256;
        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);
    }

    function claim(uint256 index, address account, uint256 amount, bytes32[] calldata merkleProof) external override {
        require(!isClaimed(index), 'MerkleDistributor: Drop already claimed.');

        // Verify the merkle proof.
        bytes32 node = keccak256(abi.encodePacked(index, account, amount));
        require(MerkleProof.verify(merkleProof, merkleRoot, node), 'MerkleDistributor: Invalid proof.');

        // Mark it claimed and send the token.
        _setClaimed(index);
        require(IERC20(token).transfer(account, amount), 'MerkleDistributor: Transfer failed.');

        emit Claimed(index, account, amount);
    }
}",442
RealWorld_BA_56_YearnVaultAdapter_RealWord_20240821170642.log,56,YearnVaultAdapter,16380,5126,21506,105.0,0.18442,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

import ""hardhat/console.sol"";

import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";

import {FixedPointMath} from ""../libraries/FixedPointMath.sol"";
import {IDetailedERC20} from ""../interfaces/IDetailedERC20.sol"";
import {IVaultAdapter} from ""../interfaces/IVaultAdapter.sol"";
import {IyVaultV2} from ""../interfaces/IyVaultV2.sol"";

/// @title YearnVaultAdapter
///
/// @dev A vault adapter implementation which wraps a yEarn vault.
contract YearnVaultAdapter is IVaultAdapter {
  using FixedPointMath for FixedPointMath.FixedDecimal;
  using SafeERC20 for IDetailedERC20;
  using SafeMath for uint256;

  /// @dev The vault that the adapter is wrapping.
  IyVaultV2 public vault;

  /// @dev The address which has admin control over this contract.
  address public admin;

  /// @dev The decimals of the token.
  uint256 public decimals;

  constructor(IyVaultV2 _vault, address _admin) public {
    vault = _vault;
    admin = _admin;
    updateApproval();
    decimals = _vault.decimals();
  }

  /// @dev A modifier which reverts if the caller is not the admin.
  modifier onlyAdmin() {
    require(admin == msg.sender, ""YearnVaultAdapter: only admin"");
    _;
  }

  /// @dev Gets the token that the vault accepts.
  ///
  /// @return the accepted token.
  function token() external view override returns (IDetailedERC20) {
    return IDetailedERC20(vault.token());
  }

  /// @dev Gets the total value of the assets that the adapter holds in the vault.
  ///
  /// @return the total assets.
  function totalValue() external view override returns (uint256) {
    return _sharesToTokens(vault.balanceOf(address(this)));
  }

  /// @dev Deposits tokens into the vault.
  ///
  /// @param _amount the amount of tokens to deposit into the vault.
  function deposit(uint256 _amount) external override {
    vault.deposit(_amount);
  }

  /// @dev Withdraws tokens from the vault to the recipient.
  ///
  /// This function reverts if the caller is not the admin.
  ///
  /// @param _recipient the account to withdraw the tokes to.
  /// @param _amount    the amount of tokens to withdraw.
  function withdraw(address _recipient, uint256 _amount) external override onlyAdmin {
    vault.withdraw(_tokensToShares(_amount),_recipient);
  }

  /// @dev Updates the vaults approval of the token to be the maximum value.
  function updateApproval() public {
    address _token = vault.token();
    IDetailedERC20(_token).safeApprove(address(vault), uint256(-1));
  }

  /// @dev Computes the number of tokens an amount of shares is worth.
  ///
  /// @param _sharesAmount the amount of shares.
  ///
  /// @return the number of tokens the shares are worth.
  
  function _sharesToTokens(uint256 _sharesAmount) internal view returns (uint256) {
    return _sharesAmount.mul(vault.pricePerShare()).div(10**decimals);
  }

  /// @dev Computes the number of shares an amount of tokens is worth.
  ///
  /// @param _tokensAmount the amount of shares.
  ///
  /// @return the number of shares the tokens are worth.
  function _tokensToShares(uint256 _tokensAmount) internal view returns (uint256) {
    return _tokensAmount.mul(10**decimals).div(vault.pricePerShare());
  }
}",826
RealWorld_BA_56_IUniswapV2Pair_RealWord_20240821173112.log,56,IUniswapV2Pair,4335,4745,9080,81.0,0.116575,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IUniswapV2Pair is IERC20 {
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
}",95
RealWorld_BA_56_dYdXSoloMargin_RealWord_20240821174451.log,56,dYdXSoloMargin,13428,5156,18584,93.0,0.17026,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;
pragma experimental ABIEncoderV2;

library Account {
    enum Status {
        Normal,
        Liquid,
        Vapor
    }

    struct Info {
        address owner;  // The address that owns the account
        uint256 number; // A nonce that allows a single address to control many accounts
    }

    function equals(
        Info memory a,
        Info memory b
    )
        internal
        pure
        returns (bool)
    {
        return a.owner == b.owner && a.number == b.number;
    }
}

library Types {
    enum AssetDenomination {
        Wei // the amount is denominated in wei
    }

    struct Wei {
        bool sign; // true if positive
        uint256 value;
    }

    enum AssetReference {
        Delta // the amount is given as a delta from the current value
    }

    struct AssetAmount {
        bool sign; // true if positive
        AssetDenomination denomination;
        AssetReference ref;
        uint256 value;
    }
}

library Actions {
    enum ActionType {
        Deposit, // supply tokens
        Withdraw // borrow tokens
    }

    enum AccountLayout {
        OnePrimary,
        TwoPrimary,
        PrimaryAndSecondary
    }

    enum MarketLayout {
        ZeroMarkets,
        OneMarket,
        TwoMarkets
    }

    struct ActionArgs {
        ActionType actionType;
        uint256 accountId;
        Types.AssetAmount amount;
        uint256 primaryMarketId;
        uint256 secondaryMarketId;
        address otherAddress;
        uint256 otherAccountId;
        bytes data;
    }

    struct DepositArgs {
        Types.AssetAmount amount;
        Account.Info account;
        uint256 market;
        address from;
    }

    struct WithdrawArgs {
        Types.AssetAmount amount;
        Account.Info account;
        uint256 market;
        address to;
    }

    function parseDepositArgs(
        Account.Info[] memory accounts,
        ActionArgs memory args
    )
        internal
        pure
        returns (DepositArgs memory)
    {
        assert(args.actionType == ActionType.Deposit);
        return DepositArgs({
            amount: args.amount,
            account: accounts[args.accountId],
            market: args.primaryMarketId,
            from: args.otherAddress
        });
    }

    function parseWithdrawArgs(
        Account.Info[] memory accounts,
        ActionArgs memory args
    )
        internal
        pure
        returns (WithdrawArgs memory)
    {
        assert(args.actionType == ActionType.Withdraw);
        return WithdrawArgs({
            amount: args.amount,
            account: accounts[args.accountId],
            market: args.primaryMarketId,
            to: args.otherAddress
        });
    }
}

interface ISoloMargin {
    function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) external;
    function getMarketTokenAddress(uint256 marketId) external view returns (address);
    function getAccountWei(Account.Info memory account, uint256 marketId) external view returns (Types.Wei memory);
}",625
RealWorld_BA_56_MockYaxisChef_RealWord_20240821154746.log,56,MockYaxisChef,5956,4280,10236,75.0,0.11538,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

contract MockYaxisChef {
    mapping(address => uint256) private _userInfo;
    mapping(address => uint256) private _pending;

    function addBalance(
        address _user,
        uint256 _amount,
        uint256 _pendingAmount
    )
        external
    {
        _userInfo[_user] += _amount;
        _pending[_user] += _pendingAmount;
    }

    function userInfo(
        uint256,
        address _user
    )
        external
        view
        returns (uint256, uint256, uint256)
    {
        return (_userInfo[_user], 0, 0);
    }

    function pendingYaxis(
        uint256,
        address _user
    )
        external
        view
        returns (uint256)
    {
        return _pending[_user];
    }
}",188
RealWorld_BA_56_ICurvePool_RealWord_20240821162536.log,56,ICurvePool,6280,4859,11139,78.0,0.12858,"// SPDX-License-Identifier: MIT
// solhint-disable func-name-mixedcase
// solhint-disable var-name-mixedcase

pragma solidity 0.6.12;

interface ICurvePool {
    function get_virtual_price() external view returns (uint256);

    function coins(uint256) external view returns (address);

    function balances(uint256) external view returns (uint256);

    function get_dy(
        int128 i,
        int128 j,
        uint256 dx
    ) external view returns (uint256 dy);

    function exchange(
        int128 i,
        int128 j,
        uint256 dx,
        uint256 min_dy
    ) external;

    function remove_liquidity_one_coin(
        uint256 _token_amount,
        int128 i,
        uint256 min_amount
    ) external;

    function calc_withdraw_one_coin(uint256 _token_amount, int128 i)
        external
        view
        returns (uint256);
}",199
RealWorld_BA_56_MockDErc20_RealWord_20240821153241.log,56,MockDErc20,8607,5268,13875,80.0,0.148395,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

contract MockDErc20 is ERC20 {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    IERC20 public underlying;

    constructor(string memory name, string memory symbol, IERC20 _underlying) public ERC20(name, symbol) {
        underlying = _underlying;
    }

    function getExchangeRate() public pure returns (uint256) {
        return 2e18; // 1 dDAI = 2 DAI
    }

    function getTokenBalance(address _account) external view returns (uint256) {
        return balanceOf(_account).mul(getExchangeRate()).div(1e18);
    }

    function mint(address _account, uint256 _amount) external {
        uint256 _toMint = _amount.mul(1e18).div(getExchangeRate());
        underlying.safeTransferFrom(msg.sender, address(this), _amount);
        _mint(_account, _toMint);
    }

    function redeem(address _account, uint256 _amount) external {
        uint256 _underlyingAmount = _amount.mul(getExchangeRate()).div(1e18);
        _burn(_account, _amount);
        underlying.safeTransfer(msg.sender, _underlyingAmount);
    }
}",339
RealWorld_BA_56_ExtendedIERC20_RealWord_20240821162124.log,56,ExtendedIERC20,3801,3695,7496,75.0,0.092905,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

interface ExtendedIERC20 {
    function decimals() external view returns (uint8);
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
}",56
RealWorld_BA_56_ICurve3Pool_RealWord_20240821164240.log,56,ICurve3Pool,7069,5176,12245,93.0,0.138865,"// SPDX-License-Identifier: MIT
// solhint-disable func-name-mixedcase
// solhint-disable var-name-mixedcase

pragma solidity 0.6.12;

interface ICurve3Pool {
    function get_virtual_price() external view returns (uint);
    function balances(uint) external view returns (uint);
    function get_dy(int128 i, int128 j, uint dx) external view returns (uint dy);
    function exchange(int128 i, int128 j, uint dx, uint min_dy) external;
    function add_liquidity(uint[3] calldata amounts, uint min_mint_amount) external;
    function remove_liquidity(uint _amount, uint[3] calldata amounts) external;
    function remove_liquidity_one_coin(uint _token_amount, int128 i, uint min_amount) external;
    function calc_token_amount(uint[3] calldata amounts, bool deposit) external view returns (uint);
    function calc_withdraw_one_coin(uint _token_amount, int128 i) external view returns (uint);
}",217
RealWorld_BA_56_IConverter_RealWord_20240821164415.log,56,IConverter,5507,5306,10813,95.0,0.133655,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""./IManager.sol"";

interface IConverter {
    function manager() external view returns (IManager);
    function convert(
        address _input,
        address _output,
        uint256 _inputAmount,
        uint256 _estimatedOutput
    ) external returns (uint256 _outputAmount);
    function expected(
        address _input,
        address _output,
        uint256 _inputAmount
    ) external view returns (uint256 _outputAmount);
}",110
RealWorld_BA_56_IYearnVault_RealWord_20240821171249.log,56,IYearnVault,6502,5693,12195,115.0,0.14637,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.6.12;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import {IDetailedERC20} from ""./IDetailedERC20.sol"";

interface IYearnVault  {
    function balanceOf(address user)  external view returns (uint);
    function pricePerShare()  external view returns (uint);
    function deposit(uint amount)  external returns (uint);
    function withdraw(uint shares, address recipient)  external returns (uint); 
    function token() external view returns (IDetailedERC20);
    function totalAssets()  external view returns (uint);
    function decimals() external  view returns (uint8);
}",158
RealWorld_BA_56_YearnV2_RealWord_20240821175503.log,56,YearnV2,4598,4858,9456,79.0,0.12015,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface IYearnV2Vault {
    function deposit(uint256 amount) external returns (uint256);
    function deposit() external returns (uint256);
    function withdraw(uint256 shares) external;
    function withdraw() external;
    function pricePerShare() external view returns (uint256);
    function token() external view returns (address);
}",86
RealWorld_BA_56_Rewards_RealWord_20240821150256.log,56,Rewards,30694,5623,36317,79.0,0.26593,"// SPDX-License-Identifier: MIT
// solhint-disable reason-string
// solhint-disable not-rely-on-time
/**
 * This contract has been modified with:
 * - generalized for any reward token, staking token, and duration
 * - upgraded to Solidity 6
 * - support ERC677 transferAndCall
 * <3 Synthetix
 */


/*
   ____            __   __        __   _
  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __
 _\ \ / // // _ \/ __// _ \/ -_)/ __// / \ \ /
/___/ \_, //_//_/\__//_//_/\__/ \__//_/ /_\_\
     /___/

* Synthetix: CurveRewards.sol
*
* Docs: https://docs.synthetix.io/
*
*
* MIT License
* ===========
*
* Copyright (c) 2020 Synthetix
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the ""Software""), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
*/

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/Math.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

import ""../vendor/LinkToken/token/ERC677Receiver.sol"";

abstract contract IRewardDistributionRecipient is Ownable {
    address public rewardDistribution;

    function notifyRewardAmount(uint256 reward) external virtual;

    modifier onlyRewardDistribution() {
        require(_msgSender() == rewardDistribution, ""Caller is not reward distribution"");
        _;
    }

    function setRewardDistribution(address _rewardDistribution)
        external
        onlyOwner
    {
        rewardDistribution = _rewardDistribution;
    }
}

contract LPTokenWrapper {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    IERC20 public immutable stakingToken;

    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;

    constructor(
        address _stakingToken
    )
        public
    {
        stakingToken = IERC20(_stakingToken);
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function stake(uint256 amount) public virtual {
        _totalSupply = _totalSupply.add(amount);
        _balances[msg.sender] = _balances[msg.sender].add(amount);
        stakingToken.safeTransferFrom(msg.sender, address(this), amount);
    }

    function stakeFor(address account, uint256 amount) internal {
        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        // we don't transferFrom here because this is only triggered
        // when tokens have already been received
    }

    function withdraw(uint256 amount) public virtual {
        _totalSupply = _totalSupply.sub(amount);
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
        stakingToken.safeTransfer(msg.sender, amount);
    }
}

contract Rewards is LPTokenWrapper, IRewardDistributionRecipient, ERC677Receiver {
    IERC20 public immutable rewardToken;
    uint256 public immutable duration;

    uint256 public periodFinish = 0;
    uint256 public rewardRate = 0;
    uint256 public lastUpdateTime;
    uint256 public rewardPerTokenStored;
    mapping(address => uint256) public userRewardPerTokenPaid;
    mapping(address => uint256) public rewards;

    event RewardAdded(uint256 reward);
    event Staked(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    event RewardPaid(address indexed user, uint256 reward);

    constructor(
        address _rewardToken,
        address _stakingToken,
        uint256 _duration
    )
        public
        LPTokenWrapper(_stakingToken)
    {
        rewardToken = IERC20(_rewardToken);
        duration = _duration;
    }

    modifier updateReward(address account) {
        rewardPerTokenStored = rewardPerToken();
        lastUpdateTime = lastTimeRewardApplicable();
        if (account != address(0)) {
            rewards[account] = earned(account);
            userRewardPerTokenPaid[account] = rewardPerTokenStored;
        }
        _;
    }

    function onTokenTransfer(address sender, uint256 amount, bytes memory)
        public override updateReward(sender)
    {
        require(msg.sender == address(stakingToken), ""!stakingToken"");
        super.stakeFor(sender, amount);
        emit Staked(sender, amount);
    }

    function lastTimeRewardApplicable() public view returns (uint256) {
        return Math.min(block.timestamp, periodFinish);
    }

    function rewardPerToken() public view returns (uint256) {
        if (totalSupply() == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored.add(
                lastTimeRewardApplicable()
                    .sub(lastUpdateTime)
                    .mul(rewardRate)
                    .mul(1e18)
                    .div(totalSupply())
            );
    }

    function earned(address account) public view returns (uint256) {
        return
            balanceOf(account)
                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))
                .div(1e18)
                .add(rewards[account]);
    }

    // stake visibility is public as overriding LPTokenWrapper's stake() function
    function stake(uint256 amount) public override updateReward(msg.sender) {
        require(amount > 0, ""Cannot stake 0"");
        super.stake(amount);
        emit Staked(msg.sender, amount);
    }

    function withdraw(uint256 amount) public override updateReward(msg.sender) {
        require(amount > 0, ""Cannot withdraw 0"");
        super.withdraw(amount);
        emit Withdrawn(msg.sender, amount);
    }

    function exit() external {
        withdraw(balanceOf(msg.sender));
        getReward();
    }

    function getReward() public updateReward(msg.sender) {
        uint256 reward = earned(msg.sender);
        if (reward > 0) {
            rewards[msg.sender] = 0;
            rewardToken.safeTransfer(msg.sender, reward);
            emit RewardPaid(msg.sender, reward);
        }
    }

    function notifyRewardAmount(uint256 reward)
        external
        override
        onlyRewardDistribution
        updateReward(address(0))
    {
        if (block.timestamp >= periodFinish) {
            rewardRate = reward.div(duration);
        } else {
            uint256 remaining = periodFinish.sub(block.timestamp);
            uint256 leftover = remaining.mul(rewardRate);
            rewardRate = reward.add(leftover).div(duration);
        }
        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp.add(duration);
        emit RewardAdded(reward);
    }
}",1696
RealWorld_BA_56_IController_RealWord_20240821154223.log,56,IController,5039,4847,9886,71.0,0.122135,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

interface IController {
    function balanceOf(address) external view returns (uint256);
    function earn(address, uint256) external;
    function investEnabled() external view returns (bool);
    function harvestStrategy(address) external;
    function strategyTokens(address) external returns (address);
    function vaults(address) external view returns (address);
    function want(address) external view returns (address);
    function withdraw(address, uint256) external;
    function withdrawFee(address, uint256) external view returns (uint256);
}",123
RealWorld_BA_56_LinkERC20_RealWord_20240821173505.log,56,LinkERC20,8275,5524,13799,101.0,0.151855,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

abstract contract LinkERC20 is ERC20 {
  /**
   * @dev Atomically increases the allowance granted to `spender` by the caller.
   *
   * This is an alternative to {approve} that can be used as a mitigation for
   * problems described in {IERC20-approve}.
   *
   * Emits an {Approval} event indicating the updated allowance.
   *
   * Requirements:
   *
   * - `spender` cannot be the zero address.
   */
  function increaseApproval(address spender, uint256 addedValue) public virtual returns (bool) {
    return super.increaseAllowance(spender, addedValue);
  }

  /**
   * @dev Atomically decreases the allowance granted to `spender` by the caller.
   *
   * This is an alternative to {approve} that can be used as a mitigation for
   * problems described in {IERC20-approve}.
   *
   * Emits an {Approval} event indicating the updated allowance.
   *
   * Requirements:
   *
   * - `spender` cannot be the zero address.
   * - `spender` must have allowance for the caller of at least
   * `subtractedValue`.
   */
  function decreaseApproval(address spender, uint256 subtractedValue) public virtual returns (bool) {
    return super.decreaseAllowance(spender, subtractedValue);
  }
}",317
RealWorld_BA_56_MinterWrapper_RealWord_20240821155628.log,56,MinterWrapper,12272,5311,17583,77.0,0.16758,"// SPDX-License-Identifier: MIT
// solhint-disable func-name-mixedcase

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

contract MinterWrapper is Ownable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    IERC20 public immutable token;
    address public minter;
    uint256 public rate;

    event Write();

    constructor(
        address _token
    )
        public
        Ownable()
    {
        token = IERC20(_token);
        rate = 1e12;
    }

    /**
     * @notice Sets the address of the minter contract
     * @dev can only be set once
     * @param _minter The address of the minter
     */
    function setMinter(
        address _minter
    )
        external
        onlyOwner
    {
        require(minter == address(0), ""minter"");
        require(_minter != address(0), ""!_minter"");
        minter = _minter;
    }

    /**
     * @notice Sets the emission rate
     * @param _rate The rate of reward token emissions
     */
    function setRate(
        uint256 _rate
    )
        external
        onlyOwner
    {
        rate = _rate;
    }

    /**
     * @notice Mints the given amount to the given account
     * @dev Requires this contract to be funded with the reward token
     * @param _account The address to receive the reward tokens
     * @param _amount The amount of tokens to send the receiver
     */
    function mint(
        address _account,
        uint256 _amount
    )
        external
        returns (bool)
    {
        require(msg.sender == minter, ""!minter"");
        token.safeTransfer(_account, _amount);
        return true;
    }

    /**
     * @notice Returns the current block timestamp
     * @dev Emits Write event to prevent from being a view function
     */
    function future_epoch_time_write()
        external
        returns (uint256)
    {
        emit Write();
        // solhint-disable-next-line not-rely-on-time
        return block.timestamp;
    }

    /**
     * @notice Returns the amount of reward tokens on this contract
     */
    function available_supply()
        public
        view
        returns (uint256)
    {
        return token.balanceOf(address(this));
    }
}",569
RealWorld_BA_56_IyVaultV2_RealWord_20240821171556.log,56,IyVaultV2,11688,5272,16960,96.0,0.16388,"pragma solidity ^0.6.12;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IyVaultV2 is IERC20 {
    function token() external view returns (address);
    function deposit() external returns (uint);
    function deposit(uint) external returns (uint);
    function deposit(uint, address) external returns (uint);
    function withdraw() external returns (uint);
    function withdraw(uint) external returns (uint);
    function withdraw(uint, address) external returns (uint);
    function withdraw(uint, address, uint) external returns (uint);
    function permit(address, address, uint, uint, bytes32) external view returns (bool);
    function pricePerShare() external view returns (uint);
    
    function apiVersion() external view returns (string memory);
    function totalAssets() external view returns (uint);
    function maxAvailableShares() external view returns (uint);
    function debtOutstanding() external view returns (uint);
    function debtOutstanding(address strategy) external view returns (uint);
    function creditAvailable() external view returns (uint);
    function creditAvailable(address strategy) external view returns (uint);
    function availableDepositLimit() external view returns (uint);
    function expectedReturn() external view returns (uint);
    function expectedReturn(address strategy) external view returns (uint);
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint);
    function balanceOf(address owner) external view override returns (uint);
    function totalSupply() external view override returns (uint);
    function governance() external view returns (address);
    function management() external view returns (address);
    function guardian() external view returns (address);
    function guestList() external view returns (address);
    function strategies(address) external view returns (uint, uint, uint, uint, uint, uint, uint, uint);
    function withdrawalQueue(uint) external view returns (address);
    function emergencyShutdown() external view returns (bool);
    function depositLimit() external view returns (uint);
    function debtRatio() external view returns (uint);
    function totalDebt() external view returns (uint);
    function lastReport() external view returns (uint);
    function activation() external view returns (uint);
    function rewards() external view returns (address);
    function managementFee() external view returns (uint);
    function performanceFee() external view returns (uint);
}",518
RealWorld_BA_56_ConvexStrategy_RealWord_20240821160725.log,56,ConvexStrategy,25214,5574,30788,82.0,0.23755,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import '../interfaces/IConvexVault.sol';
import './BaseStrategy.sol';

contract ConvexStrategy is BaseStrategy {
    // used for Crv -> weth -> [dai/usdc/usdt] -> 3crv route
    address public immutable crv;
    address public immutable cvx;

    // for add_liquidity via curve.fi to get back 3CRV (use getMostPremium() for the best stable coin used in the route)
    address public immutable dai;
    address public immutable usdc;
    address public immutable usdt;

    uint256 public immutable pid;
    IConvexVault public immutable convexVault;
    address public immutable cvxDepositLP;
    IConvexRewards public immutable crvRewards;
    IStableSwap3Pool public immutable stableSwap3Pool;

    constructor(
        string memory _name,
        address _want,
        address _crv,
        address _cvx,
        address _weth,
        address _dai,
        address _usdc,
        address _usdt,
        uint256 _pid,
        IConvexVault _convexVault,
        IStableSwap3Pool _stableSwap3Pool,
        address _controller,
        address _manager,
        address _router
    ) public BaseStrategy(_name, _controller, _manager, _want, _weth, _router) {
        (, address _token, , address _crvRewards, , ) = _convexVault.poolInfo(_pid);
        crv = _crv;
        cvx = _cvx;
        dai = _dai;
        usdc = _usdc;
        usdt = _usdt;
        pid = _pid;
        convexVault = _convexVault;
        cvxDepositLP = _token;
        crvRewards = IConvexRewards(_crvRewards);
        stableSwap3Pool = _stableSwap3Pool;
        // Required to overcome ""Stack Too Deep"" error
        _setApprovals(
            _want,
            _crv,
            _cvx,
            _dai,
            _usdc,
            _usdt,
            address(_convexVault),
            _router,
            address(_stableSwap3Pool)
        );
    }

    function _setApprovals(
        address _want,
        address _crv,
        address _cvx,
        address _dai,
        address _usdc,
        address _usdt,
        address _convexVault,
        address _router,
        address _stableSwap3Pool
    ) internal {
        IERC20(_want).safeApprove(address(_convexVault), type(uint256).max);
        IERC20(_crv).safeApprove(address(_router), type(uint256).max);
        IERC20(_cvx).safeApprove(address(_router), type(uint256).max);
        IERC20(_dai).safeApprove(address(_stableSwap3Pool), type(uint256).max);
        IERC20(_usdc).safeApprove(address(_stableSwap3Pool), type(uint256).max);
        IERC20(_usdt).safeApprove(address(_stableSwap3Pool), type(uint256).max);
        IERC20(_want).safeApprove(address(_stableSwap3Pool), type(uint256).max);
    }

    function _deposit() internal override {
        convexVault.depositAll(pid, true);
    }

    function _claimReward() internal {
        crvRewards.getReward(address(this), true);
    }

    function _addLiquidity() internal {
        uint256[3] memory amounts;
        amounts[0] = IERC20(dai).balanceOf(address(this));
        amounts[1] = IERC20(usdc).balanceOf(address(this));
        amounts[2] = IERC20(usdt).balanceOf(address(this));
        stableSwap3Pool.add_liquidity(amounts, 1);
    }

    function getMostPremium() public view returns (address, uint256) {
        uint256[] memory balances = new uint256[](3);
        balances[0] = stableSwap3Pool.balances(0); // DAI
        balances[1] = stableSwap3Pool.balances(1).mul(10**12); // USDC
        balances[2] = stableSwap3Pool.balances(2).mul(10**12); // USDT

        if (balances[0] < balances[1] && balances[0] < balances[2]) {
            // DAI
            return (dai, 0);
        }

        if (balances[1] < balances[0] && balances[1] < balances[2]) {
            // USDC
            return (usdc, 1);
        }

        if (balances[2] < balances[0] && balances[2] < balances[1]) {
            // USDT
            return (usdt, 2);
        }

        return (dai, 0); // If they're somehow equal, we just want DAI
    }

    function _harvest(uint256 _estimatedWETH, uint256 _estimatedYAXIS) internal override {
        _claimReward();
        uint256 _cvxBalance = IERC20(cvx).balanceOf(address(this));
        if (_cvxBalance > 0) {
            _swapTokens(cvx, crv, _cvxBalance, 1);
        }

        uint256 _remainingWeth = _payHarvestFees(crv, _estimatedWETH, _estimatedYAXIS);

        if (_remainingWeth > 0) {
            (address _stableCoin, ) = getMostPremium(); // stablecoin we want to convert to
            _swapTokens(weth, _stableCoin, _remainingWeth, 1);
            _addLiquidity();

            if (balanceOfWant() > 0) {
                _deposit();
            }
        }
    }

    function _withdrawAll() internal override {
        convexVault.withdrawAll(pid);
    }

    function _withdraw(uint256 _amount) internal override {
        convexVault.withdraw(pid, _amount);
    }

    function balanceOfPool() public view override returns (uint256) {
        return IERC20(cvxDepositLP).balanceOf(address(this));
    }
}",1353
RealWorld_BA_56_VaultToken_RealWord_20240821154903.log,56,VaultToken,13585,5351,18936,86.0,0.174945,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""../vendor/LinkToken/token/LinkERC20.sol"";
import ""../vendor/LinkToken/ERC677Token.sol"";

import ""./interfaces/IManager.sol"";
import ""./interfaces/IVaultToken.sol"";

/**
 * @notice Vault Token
 * @dev Contract has been copied from:
 * https://github.com/smartcontractkit/LinkToken/blob/master/contracts/v0.6/LinkToken.sol
 * with modification made to specify name and symbol, deploys with 0 total supply
 */
contract VaultToken is IVaultToken, LinkERC20, ERC677Token {

    IManager public immutable manager;

    constructor(
        string memory _name,
        string memory _symbol,
        address _manager
    )
        public
        ERC20(_name, _symbol)
    // solhint-disable-next-line no-empty-blocks
    {
        manager = IManager(_manager);
    }

    function mint(
        address _account,
        uint256 _amount
    )
        external
        override
        onlyVault
    {
        _mint(_account, _amount);
    }

    function burn(
        address _account,
        uint256 _amount
    )
        external
        override
        onlyVault
    {
        _burn(_account, _amount);
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount)
        internal
        override
        virtual
        validAddress(recipient)
    {
        super._transfer(sender, recipient, amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount)
        internal
        override
        virtual
        validAddress(spender)
    {
        super._approve(owner, spender, amount);
    }


    // MODIFIERS

    modifier validAddress(address _recipient) {
        require(_recipient != address(this), ""!validAddress"");
        _;
    }

    modifier onlyVault() {
        require(manager.allowedVaults(msg.sender), ""!vault"");
        _;
    }
}",641
RealWorld_BA_56_Converter_RealWord_20240821175933.log,56,Converter,3354,4073,7427,80.0,0.09823,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface Converter {
    function convert(address) external returns (uint);
}",30
RealWorld_BA_56_MockGenericVault_RealWord_20240821152700.log,56,MockGenericVault,11254,5479,16733,81.0,0.16585,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""./MockERC20.sol"";
import ""../interfaces/GenericVault.sol"";

contract MockGenericVault is MockERC20 {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    IERC20 public token;

    uint public min = 9500;
    uint public constant max = 10000;

    constructor (address _token) public MockERC20(
        string(abi.encodePacked(""Generic Vault "", ERC20(_token).name())),
        string(abi.encodePacked(""v"", ERC20(_token).symbol())),
        ERC20(_token).decimals()
    ) {
        token = IERC20(_token);
    }

    function balance() public view returns (uint) {
        return token.balanceOf(address(this));
    }

    function available() public view returns (uint) {
        return token.balanceOf(address(this)).mul(min).div(max);
    }

    function depositAll() external {
        deposit(token.balanceOf(msg.sender));
    }

    function deposit(uint _amount) public {
        uint _pool = balance();
        uint _before = token.balanceOf(address(this));
        token.safeTransferFrom(msg.sender, address(this), _amount);
        uint _after = token.balanceOf(address(this));
        _amount = _after.sub(_before);
        uint shares = 0;
        if (totalSupply() == 0) {
            shares = _amount;
        } else {
            shares = (_amount.mul(totalSupply())).div(_pool);
        }
        _mint(msg.sender, shares);
    }

    function withdrawAll() external {
        withdraw(balanceOf(msg.sender));
    }

    function withdraw(uint _shares) public {
        uint r = (balance().mul(_shares)).div(totalSupply());
        _burn(msg.sender, _shares);
        token.safeTransfer(msg.sender, r);
    }

    function getPricePerFullShare() public view returns (uint) {
        return balance().mul(1e18).div(totalSupply());
    }
}",506
RealWorld_BA_56_StablesConverter_RealWord_20240821161311.log,56,StablesConverter,31679,5622,37301,113.0,0.270835,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import ""../interfaces/IConverter.sol"";
import ""../interfaces/IManager.sol"";
import ""../interfaces/ICurve3Pool.sol"";

/**
 * @title StablesConverter
 */
contract StablesConverter is IConverter {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    IManager public immutable override manager;
    ICurve3Pool public immutable stableSwap3Pool;
    IERC20 public immutable token3CRV; // 3Crv

    IERC20[3] public tokens; // DAI, USDC, USDT

    mapping(address => int128) internal indices;

    /**
     * @param _tokenDAI The address of the DAI token
     * @param _tokenUSDC The address of the USDC token
     * @param _tokenUSDT The address of the USDT token
     * @param _token3CRV The address of the 3CRV token
     * @param _stableSwap3Pool The address of 3Pool
     * @param _manager The address of the Vault Manager
     */
    constructor(
        IERC20 _tokenDAI,
        IERC20 _tokenUSDC,
        IERC20 _tokenUSDT,
        IERC20 _token3CRV,
        ICurve3Pool _stableSwap3Pool,
        IManager _manager
    ) public {
        tokens[0] = _tokenDAI;
        tokens[1] = _tokenUSDC;
        tokens[2] = _tokenUSDT;
        indices[address(_tokenDAI)] = 0;
        indices[address(_tokenUSDC)] = 1;
        indices[address(_tokenUSDT)] = 2;
        token3CRV = _token3CRV;
        stableSwap3Pool = _stableSwap3Pool;
        tokens[0].safeApprove(address(_stableSwap3Pool), type(uint256).max);
        tokens[1].safeApprove(address(_stableSwap3Pool), type(uint256).max);
        tokens[2].safeApprove(address(_stableSwap3Pool), type(uint256).max);
        _token3CRV.safeApprove(address(_stableSwap3Pool), type(uint256).max);
        manager = _manager;
    }

    /**
     * STRATEGIST-ONLY FUNCTIONS
     */

    /**
     * @notice Called by the strategist to approve a token address to be spent by an address
     * @param _token The address of the token
     * @param _spender The address of the spender
     * @param _amount The amount to spend
     */
    function approveForSpender(
        IERC20 _token,
        address _spender,
        uint256 _amount
    )
        external
        onlyStrategist
    {
        _token.safeApprove(_spender, 0);
        _token.safeApprove(_spender, _amount);
    }

    /**
     * @notice Allows the strategist to withdraw tokens from the converter
     * @dev This contract should never have any tokens in it at the end of a transaction
     * @param _token The address of the token
     * @param _amount The amount to withdraw
     * @param _to The address to receive the tokens
     */
    function recoverUnsupported(
        IERC20 _token,
        uint256 _amount,
        address _to
    )
        external
        onlyStrategist
    {
        _token.safeTransfer(_to, _amount);
    }

    /**
     * AUTHORIZED-ONLY FUNCTIONS
     */

    /**
     * @notice Converts the amount of input tokens to output tokens
     * @param _input The address of the token being converted
     * @param _output The address of the token to be converted to
     * @param _inputAmount The input amount of tokens that are being converted
     * @param _estimatedOutput The estimated output tokens after converting
     */
    function convert(
        address _input,
        address _output,
        uint256 _inputAmount,
        uint256 _estimatedOutput
    )
        external
        override
        onlyAuthorized
        returns (uint256 _outputAmount)
    {
        if (_output == address(token3CRV)) { // convert to 3CRV
            uint256[3] memory amounts;
            for (uint8 i = 0; i < 3; i++) {
                if (_input == address(tokens[i])) {
                    amounts[i] = _inputAmount;
                    uint256 _before = token3CRV.balanceOf(address(this));
                    stableSwap3Pool.add_liquidity(amounts, _estimatedOutput);
                    uint256 _after = token3CRV.balanceOf(address(this));
                    _outputAmount = _after.sub(_before);
                    token3CRV.safeTransfer(msg.sender, _outputAmount);
                    return _outputAmount;
                }
            }
        } else if (_input == address(token3CRV)) { // convert from 3CRV
            // A temporary cache, used to save gas.
            IERC20 _token;
            for (uint8 i = 0; i < 3; i++) {
                _token = tokens[i];
                if (_output == address(_token)) {
                    uint256 _before = _token.balanceOf(address(this));
                    stableSwap3Pool.remove_liquidity_one_coin(
                        _inputAmount,
                        i,
                        _estimatedOutput
                    );
                    uint256 _after = _token.balanceOf(address(this));
                    _outputAmount = _after.sub(_before);
                    _token.safeTransfer(msg.sender, _outputAmount);
                    return _outputAmount;
                }
            }
        } else {
            stableSwap3Pool.exchange(
                indices[_input],
                indices[_output],
                _inputAmount,
                _estimatedOutput
            );
            _outputAmount = IERC20(_output).balanceOf(address(this));
            IERC20(_output).safeTransfer(msg.sender, _outputAmount);
            return _outputAmount;
        }
        return 0;
    }

    /**
     * @notice Checks the amount of input tokens to output tokens
     * @param _input The address of the token being converted
     * @param _output The address of the token to be converted to
     * @param _inputAmount The input amount of tokens that are being converted
     */
    function expected(
        address _input,
        address _output,
        uint256 _inputAmount
    )
        external
        override
        view
        returns (uint256)
    {
        if (_output == address(token3CRV)) { // convert to 3CRV
            uint256[3] memory amounts;
            for (uint8 i = 0; i < 3; i++) {
                if (_input == address(tokens[i])) {
                    amounts[i] = _inputAmount;
                    return stableSwap3Pool.calc_token_amount(amounts, true);
                }
            }
        } else if (_input == address(token3CRV)) { // convert from 3CRV
            for (uint8 i = 0; i < 3; i++) {
                if (_output == address(tokens[i])) {
                    // @dev this is for UI reference only, the actual share price
                    // (stable/CRV) will be re-calculated on-chain when we do convert()
                    return stableSwap3Pool.calc_withdraw_one_coin(_inputAmount, i);
                }
            }
        } else {
            return stableSwap3Pool.get_dy(indices[_input], indices[_output], _inputAmount);
        }
        return 0;
    }

    /**
     * MODIFIERS
     */

    /**
     * @dev Throws if not called by an allowed vault, controller, or strategy
     */
    modifier onlyAuthorized() {
        require(manager.allowedVaults(msg.sender)
            || manager.allowedControllers(msg.sender)
            || manager.allowedStrategies(msg.sender),
            ""!authorized""
        );
        _;
    }

    /**
     * @dev Throws if not called by the strategist
     */
    modifier onlyStrategist {
        require(msg.sender == manager.strategist(), ""!strategist"");
        _;
    }
}",1792
RealWorld_BA_56_ETHConvexStrategy_RealWord_20240821160543.log,56,ETHConvexStrategy,24682,5655,30337,100.0,0.23651,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IConvexVault.sol';
import '../interfaces/ExtendedIERC20.sol';
import '../interfaces/IStableSwap2Pool.sol';
import '../interfaces/IWETH.sol';
import './BaseStrategy.sol';

contract ETHConvexStrategy is BaseStrategy {
    using SafeMath for uint8;

    address public immutable crv;
    address public immutable cvx;
    address public immutable aleth;

    uint256 public immutable pid;
    IConvexVault public immutable convexVault;
    address public immutable cvxDepositLP;
    IConvexRewards public immutable crvRewards;
    IStableSwap2Pool public immutable stableSwapPool;

    /**
     * @param _name The strategy name
     * @param _want The desired token of the strategy
     * @param _crv The address of CRV
     * @param _cvx The address of CVX
     * @param _weth The address of WETH
     * @param _aleth The address of alternative ETH
     * @param _pid The pool id of convex
     * @param _convexVault The address of the convex vault
     * @param _stableSwapPool The address of the stable swap pool
     * @param _controller The address of the controller
     * @param _manager The address of the manager
     * @param _router The address of the router for swapping tokens
     */
    constructor(
        string memory _name,
        address _want,
        address _crv,
        address _cvx,
        address _weth,
        address _aleth,
        uint256 _pid,
        IConvexVault _convexVault,
        address _stableSwapPool,
        address _controller,
        address _manager,
        address _router
    ) public BaseStrategy(_name, _controller, _manager, _want, _weth, _router) {
        require(address(_crv) != address(0), '!_crv');
        require(address(_cvx) != address(0), '!_cvx');
        require(address(_aleth) != address(0), '!_aleth');
        require(address(_convexVault) != address(0), '!_convexVault');
        require(address(_stableSwapPool) != address(0), '!_stableSwapPool');

        (, address _token, , address _crvRewards, , ) = _convexVault.poolInfo(_pid);
        crv = _crv;
        cvx = _cvx;
        aleth = _aleth;
        pid = _pid;
        convexVault = _convexVault;
        cvxDepositLP = _token;
        crvRewards = IConvexRewards(_crvRewards);
        stableSwapPool = IStableSwap2Pool(_stableSwapPool);

        IERC20(_want).safeApprove(address(_convexVault), type(uint256).max);
        IERC20(_crv).safeApprove(address(_router), type(uint256).max);
        IERC20(_cvx).safeApprove(address(_router), type(uint256).max);
        IERC20(_want).safeApprove(address(_stableSwapPool), type(uint256).max);
        IERC20(_aleth).safeApprove(_stableSwapPool, type(uint256).max);
    }

    function _deposit() internal override {
        convexVault.depositAll(pid, true);
    }

    function _claimReward() internal {
        crvRewards.getReward(address(this), true);
    }

    function _addLiquidity() internal {
        uint256[2] memory amounts;
        amounts[0] = address(this).balance;
        amounts[1] = IERC20(aleth).balanceOf(address(this));
        stableSwapPool.add_liquidity(amounts, 1);
        return;
    }

    function getMostPremium() public view returns (address, uint256) {
        uint256 balance0 = address(this).balance;
        uint256 balance1 = stableSwapPool.balances(1);

        if (balance0 > balance1) {
            return (aleth, 1);
        }

        return (address(0), 0);
    }

    function _harvest(uint256 _estimatedWETH, uint256 _estimatedYAXIS) internal override {
        _claimReward();
        uint256 _cvxBalance = IERC20(cvx).balanceOf(address(this));
        if (_cvxBalance > 0) {
            _swapTokens(cvx, crv, _cvxBalance, 1);
        }

        uint256 _extraRewardsLength = crvRewards.extraRewardsLength();
        for (uint256 i = 0; i < _extraRewardsLength; i++) {
            address _rewardToken = IConvexRewards(crvRewards.extraRewards(i)).rewardToken();
            uint256 _extraRewardBalance = IERC20(_rewardToken).balanceOf(address(this));
            if (_extraRewardBalance > 0) {
                _swapTokens(_rewardToken, weth, _extraRewardBalance, 1);
            }
        }

        uint256 _remainingWeth = _payHarvestFees(crv, _estimatedWETH, _estimatedYAXIS);
        if (_remainingWeth > 0) {
            (address _targetCoin, ) = getMostPremium();
            if (_targetCoin != address(0)) {
                _swapTokens(weth, _targetCoin, _remainingWeth, 1);
            } else {
                IWETH(weth).withdraw(_remainingWeth);
            }
            _addLiquidity();

            if (balanceOfWant() > 0) {
                _deposit();
            }
        }
    }

    function _withdrawAll() internal override {
        convexVault.withdrawAll(pid);
    }

    function _withdraw(uint256 _amount) internal override {
        convexVault.withdraw(pid, _amount);
    }

    function balanceOfPool() public view override returns (uint256) {
        return IERC20(cvxDepositLP).balanceOf(address(this));
    }
}",1315
RealWorld_BA_56_Gauge_RealWord_20240821180401.log,56,Gauge,4156,4486,8642,71.0,0.1105,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface Gauge {
    function deposit(uint) external;
    function balanceOf(address) external view returns (uint);
    function withdraw(uint) external;
    function claimable_tokens(address) external view returns (uint);
}

interface Mintr {
    function mint(address) external;
}",71
RealWorld_BA_56_MockDRewards_RealWord_20240821152131.log,56,MockDRewards,9967,5204,15171,91.0,0.153915,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

contract MockDRewards {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    IERC20 public lpToken;
    IERC20 public rewardToken;

    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;

    uint256 rewardRate; // over 1000

    constructor(
        address _lpToken,
        address _rewardToken,
        uint256 _rewardRate
    ) public {
        lpToken = IERC20(_lpToken);
        rewardToken = IERC20(_rewardToken);
        rewardRate = _rewardRate;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function earned(address account) public view returns (uint256) {
        return balanceOf(account).mul(rewardRate).div(1000);
    }

    function stake(uint256 amount) public {
        _totalSupply = _totalSupply.add(amount);
        _balances[msg.sender] = _balances[msg.sender].add(amount);
        lpToken.safeTransferFrom(msg.sender, address(this), amount);
    }

    function withdraw(uint256 amount) public {
        _totalSupply = _totalSupply.sub(amount);
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
        lpToken.safeTransfer(msg.sender, amount);
    }

    function exit() external {
        withdraw(balanceOf(msg.sender));
        getReward();
    }

    function getReward() public {
        uint256 reward = earned(msg.sender);
        if (reward > 0) {
            if (reward > rewardToken.balanceOf(address(this))) {
                reward = rewardToken.balanceOf(address(this));
            }
            rewardToken.safeTransfer(msg.sender, reward);
        }
    }
}",451
RealWorld_BA_56_YaxisVoteProxy_RealWord_20240821172544.log,56,YaxisVoteProxy,8689,5020,13709,80.0,0.143845,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./interfaces/IVoteProxy.sol"";

contract YaxisVoteProxy {
    IVoteProxy public voteProxy;
    address public governance;
    constructor() public {
        governance = msg.sender;
    }

    function name() external pure returns (string memory) {
        return ""YAXIS Vote Power"";
    }

    function symbol() external pure returns (string memory) {
        return ""YAX VP"";
    }

    function decimals() external view returns (uint8) {
        return voteProxy.decimals();
    }

    function totalSupply() external view returns (uint256) {
        return voteProxy.totalSupply();
    }

    function balanceOf(address _voter) external view returns (uint256) {
        return voteProxy.balanceOf(_voter);
    }

    function setVoteProxy(IVoteProxy _voteProxy) external {
        require(msg.sender == governance, ""!governance"");
        voteProxy = _voteProxy;
    }

    function setGovernance(address _governance) external {
        require(msg.sender == governance, ""!governance"");
        governance = _governance;
    }



/**
 * This function allows governance to take unsupported tokens out of the contract.
 * This is in an effort to make someone whole, should they seriously mess up.
 * There is no guarantee governance will vote to return these.
 * It also allows for removal of airdropped tokens.
 */
    function governanceRecoverUnsupported(IERC20 _token, uint256 amount, address to) external {
        require(msg.sender == governance, ""!governance"");
        _token.transfer(to, amount);
    }
}",363
RealWorld_BA_56_IMasterChef_RealWord_20240821172944.log,56,IMasterChef,4042,4633,8675,86.0,0.11287,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

interface IMasterChef {
    function userInfo(uint256, address) external view returns (uint256, uint256, uint256);
    function pendingYaxis(uint256, address) external view returns (uint256);
}",60
RealWorld_BA_56_MockERC20_RealWord_20240821151547.log,56,MockERC20,18374,5815,24189,78.0,0.20817,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

contract MockERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    address private _owner;

    uint internal _totalSupply;

    mapping(address => uint)                   private _balance;
    mapping(address => mapping(address => uint)) private _allowance;

    modifier _onlyOwner_() {
        require(msg.sender == _owner, ""ERR_NOT_OWNER"");
        _;
    }

    event Approval(address indexed src, address indexed dst, uint amt);
    event Transfer(address indexed src, address indexed dst, uint amt);

    // Math
    function add(uint a, uint b) internal pure returns (uint c) {
        require((c = a + b) >= a);
    }

    function sub(uint a, uint b) internal pure returns (uint c) {
        require((c = a - b) <= a);
    }

    constructor(
        string memory name,
        string memory symbol,
        uint8 decimals
    ) public {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
        _owner = msg.sender;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function _move(address src, address dst, uint amt) internal {
        require(_balance[src] >= amt, ""!bal"");
        _balance[src] = sub(_balance[src], amt);
        _balance[dst] = add(_balance[dst], amt);
        emit Transfer(src, dst, amt);
    }

    function _push(address to, uint amt) internal {
        _move(address(this), to, amt);
    }

    function _pull(address from, uint amt) internal {
        _move(from, address(this), amt);
    }

    function _mint(address dst, uint amt) internal {
        _balance[dst] = add(_balance[dst], amt);
        _totalSupply = add(_totalSupply, amt);
        emit Transfer(address(0), dst, amt);
    }

    function _burn(address dst, uint amt) internal {
        _balance[dst] = sub(_balance[dst], amt);
        _totalSupply = sub(_totalSupply, amt);
        emit Transfer(dst, address(0), amt);
    }

    function allowance(address src, address dst) external view returns (uint) {
        return _allowance[src][dst];
    }

    function balanceOf(address whom) public view returns (uint) {
        return _balance[whom];
    }

    function faucet(uint256 amt) public returns (bool) {
        _mint(msg.sender, amt);
        return true;
    }

    function totalSupply() public view returns (uint) {
        return _totalSupply;
    }

    function approve(address dst, uint amt) external returns (bool) {
        _allowance[msg.sender][dst] = amt;
        emit Approval(msg.sender, dst, amt);
        return true;
    }

    function mint(address dst, uint256 amt) public _onlyOwner_ returns (bool) {
        _mint(dst, amt);
        return true;
    }

    function burn(uint amt) public returns (bool) {
        require(_balance[msg.sender] >= amt, ""!bal"");
        _burn(msg.sender, amt);
        return true;
    }

    function burnFrom(address src, uint amt) public _onlyOwner_ returns (bool) {
        require(_balance[src] >= amt, ""!bal"");
        _burn(src, amt);
        return true;
    }

    function transfer(address dst, uint amt) external returns (bool) {
        _move(msg.sender, dst, amt);
        return true;
    }

    function transferFrom(address src, address dst, uint amt) external returns (bool) {
        require(msg.sender == src || amt <= _allowance[src][msg.sender], ""!spender"");
        _move(src, dst, amt);
        if (msg.sender != src && _allowance[src][msg.sender] != uint256(- 1)) {
            _allowance[src][msg.sender] = sub(_allowance[src][msg.sender], amt);
            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);
        }
        return true;
    }

    function transferOwnership(address newOwner) external _onlyOwner_ {
        _owner = newOwner;
    }
}",955
RealWorld_BA_56_MockUniswapPair_RealWord_20240821154622.log,56,MockUniswapPair,7966,5237,13203,82.0,0.14457,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

contract MockUniswapPair is ERC20 {
    using SafeERC20 for IERC20;

    address public immutable token0;
    address public immutable token1;

    constructor(
        address _token0,
        address _token1
    )
        public
        ERC20(""Uniswap Pair"", ""UNI-V2"")
    {
        token0 = _token0;
        token1 = _token1;
    }

    function addLiquidity(
        uint256 _amount0,
        uint256 _amount1,
        uint256 _amountOut
    )
        external
    {
        IERC20(token0).safeTransferFrom(msg.sender, address(this), _amount0);
        IERC20(token1).safeTransferFrom(msg.sender, address(this), _amount1);
        _mint(msg.sender, _amountOut);
    }

    function getReserves()
        external
        view
        returns (uint112, uint112, uint32)
    {
        return (
            uint112(IERC20(token0).balanceOf(address(this))),
            uint112(IERC20(token1).balanceOf(address(this))),
            uint32(block.timestamp)
        );
    }
}",310
RealWorld_BA_56_IMetaVault_RealWord_20240821154336.log,56,IMetaVault,6957,5162,12119,75.0,0.138025,"// SPDX-License-Identifier: MIT
// solhint-disable func-name-mixedcase
// solhint-disable var-name-mixedcase

pragma solidity 0.6.12;

interface IMetaVault {
    function balance() external view returns (uint);
    function setController(address _controller) external;
    function claimInsurance() external;
    function token() external view returns (address);
    function available() external view returns (uint);
    function withdrawFee(uint _amount) external view returns (uint);
    function earn() external;
    function calc_token_amount_deposit(uint[3] calldata amounts) external view returns (uint);
    function calc_token_amount_withdraw(uint _shares, address _output) external view returns (uint);
    function convert_rate(address _input, uint _amount) external view returns (uint);
    function deposit(uint _amount, address _input, uint _min_mint_amount, bool _isStake) external;
    function harvest(address reserve, uint amount) external;
    function withdraw(uint _shares, address _output) external;
    function want() external view returns (address);
    function getPricePerFullShare() external view returns (uint);
}",241
RealWorld_BA_56_YaxisVotePower_RealWord_20240821172422.log,56,YaxisVotePower,13004,5388,18392,80.0,0.17278,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";

import ""./interfaces/IRewards.sol"";
import ""./interfaces/IUniswapV2Pair.sol"";
import ""./interfaces/IVoteProxy.sol"";

contract YaxisVotePower is IVoteProxy {
    using SafeMath for uint256;

    // solhint-disable-next-line const-name-snakecase
    uint8 public constant override decimals = uint8(18);

    IUniswapV2Pair public immutable yaxisEthUniswapV2Pair;
    IERC20 public immutable yaxis;
    IRewards public immutable rewardsYaxis;
    IRewards public immutable rewardsYaxisEth;

    constructor(
        address _yaxis,
        address _rewardsYaxis,
        address _rewardsYaxisEth,
        address _yaxisEthUniswapV2Pair
    )
        public
    {
        yaxis = IERC20(_yaxis);
        rewardsYaxis = IRewards(_rewardsYaxis);
        rewardsYaxisEth = IRewards(_rewardsYaxisEth);
        yaxisEthUniswapV2Pair = IUniswapV2Pair(_yaxisEthUniswapV2Pair);
    }

    function totalSupply()
        external
        view
        override
        returns (uint256)
    {
        return sqrt(yaxis.totalSupply());
    }

    function balanceOf(
        address _voter
    )
        external
        view
        override
        returns (uint256 _balance)
    {
        uint256 _stakeAmount = rewardsYaxisEth.balanceOf(_voter);
        (uint256 _yaxReserves,,) = yaxisEthUniswapV2Pair.getReserves();
        uint256 _supply = yaxisEthUniswapV2Pair.totalSupply();
        _supply = _supply == 0
            ? 1e18
            : _supply;
        uint256 _lpStakingYax = _yaxReserves
            .mul(_stakeAmount)
            .div(_supply)
            .add(rewardsYaxisEth.earned(_voter));
        uint256 _rewardsYaxisAmount = rewardsYaxis.balanceOf(_voter)
            .add(rewardsYaxis.earned(_voter));
        _balance = sqrt(
            yaxis.balanceOf(_voter)
                .add(_lpStakingYax)
                .add(_rewardsYaxisAmount)
        );
    }

    function sqrt(
        uint256 x
    )
        private
        pure
        returns (uint256 y)
    {
        uint256 z = (x + 1) / 2;
        y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
        y = y * (10 ** 9);
    }
}",622
RealWorld_BA_56_YearnVaultMock_RealWord_20240821165952.log,56,YearnVaultMock,15405,5329,20734,94.0,0.183605,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

import 'hardhat/console.sol';

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';

import '../interfaces/IYearnController.sol';
import '../interfaces/IYearnVault.sol';

contract YearnVaultMock is ERC20 {
    using SafeERC20 for IDetailedERC20;
    using SafeMath for uint256;

    uint256 public min = 9500;
    uint256 public constant max = 10000;

    IYearnController public controller;
    IDetailedERC20 public token;

    constructor(IDetailedERC20 _token, IYearnController _controller)
        public
        ERC20('yEarn Mock', 'yMOCK')
    {
        token = _token;
        controller = _controller;
    }

    function vdecimals() external view returns (uint8) {
        return decimals();
    }

    function balance() public view returns (uint256) {
        return token.balanceOf(address(this)).add(controller.balanceOf(address(token)));
    }

    function available() public view returns (uint256) {
        return token.balanceOf(address(this)).mul(min).div(max);
    }

    function earn() external {
        uint256 _bal = available();
        token.safeTransfer(address(controller), _bal);
        controller.earn(address(token), _bal);
    }

    function deposit(uint256 _amount) external returns (uint256) {
        uint256 _pool = balance();
        uint256 _before = token.balanceOf(address(this));
        token.safeTransferFrom(msg.sender, address(this), _amount);
        uint256 _after = token.balanceOf(address(this));
        _amount = _after.sub(_before); // Additional check for deflationary tokens
        uint256 _shares = 0;
        if (totalSupply() == 0) {
            _shares = _amount;
        } else {
            _shares = (_amount.mul(totalSupply())).div(_pool);
        }
        _mint(msg.sender, _shares);
    }

    function withdraw(uint256 _shares, address _recipient) external returns (uint256) {
        uint256 _r = (balance().mul(_shares)).div(totalSupply());
        _burn(msg.sender, _shares);

        // Check balance
        uint256 _b = token.balanceOf(address(this));
        if (_b < _r) {
            uint256 _withdraw = _r.sub(_b);
            controller.withdraw(address(token), _withdraw);
            uint256 _after = token.balanceOf(address(this));
            uint256 _diff = _after.sub(_b);
            if (_diff < _withdraw) {
                _r = _b.add(_diff);
            }
        }

        token.safeTransfer(_recipient, _r);
    }

    function pricePerShare() external view returns (uint256) {
        return balance().mul(1e18).div(totalSupply());
    } // changed to v2

    /// @dev This is not part of the vault contract and is meant for quick debugging contracts to have control over
    /// completely clearing the vault buffer to test certain behaviors better.
    function clear() external {
        token.safeTransfer(address(controller), token.balanceOf(address(this)));
        controller.earn(address(token), token.balanceOf(address(this)));
    }
}",740
RealWorld_BA_56_MockPickleJar_RealWord_20240821152304.log,56,MockPickleJar,8723,4956,13679,84.0,0.142735,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../interfaces/PickleJar.sol"";
import ""./MockERC20.sol"";

contract MockPickleJar is MockERC20 {
    IERC20 public t3crv;
    IERC20 public lpToken;

    constructor(IERC20 _t3crv) public MockERC20(""pickling Curve.fi DAI/USDC/USDT"", ""p3Crv"", 18) {
        t3crv = _t3crv;
    }

    function balance() public view returns (uint) {
        return t3crv.balanceOf(address(this));
    }

    function available() external view returns (uint) {
        return balance() * 9500 / 10000;
    }

    function depositAll() external {
        deposit(t3crv.balanceOf(msg.sender));
    }

    function deposit(uint _amount) public {
        t3crv.transferFrom(msg.sender, address(this), _amount);
        uint256 shares = _amount * 1000000000000000000 / getRatio();
        _mint(msg.sender, shares);
    }

    function withdrawAll() external {
        withdraw(balanceOf(msg.sender));
    }

    function withdraw(uint _shares) public {
        uint256 r = _shares * getRatio() / 1000000000000000000;
        _burn(msg.sender, _shares);
        t3crv.transfer(msg.sender, r);
    }

    function getRatio() public pure returns (uint) {
        return 1010000000000000000; // +1%
    }
}",352
RealWorld_BA_56_IStableSwapPool_RealWord_20240821162415.log,56,IStableSwapPool,3885,3631,7516,79.0,0.092045,"// SPDX-License-Identifier: MIT
// solhint-disable func-name-mixedcase
// solhint-disable var-name-mixedcase

pragma solidity 0.6.12;

interface IStableSwapPool {
    function coins(uint256) external view returns (address);
}",56
RealWorld_BA_56_MockERC677_RealWord_20240821150825.log,56,MockERC677,11082,5020,16102,73.0,0.15581,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import ""../../vendor/LinkToken/token/LinkERC20.sol"";
import ""../../vendor/LinkToken/ERC677Token.sol"";

contract MockERC677 is LinkERC20, ERC677Token {

    constructor(
        string memory _name,
        string memory _symbol
    )
        public
        ERC20(_name, _symbol)
    {}

    function mint(
        address _to,
        uint256 _amount
    )
        external
    {
        _mint(_to, _amount);
    }

    function faucet(
        uint256 _amount
    )
        external
    {
        _mint(msg.sender, _amount);
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount)
        internal
        override
        virtual
        validAddress(recipient)
    {
        super._transfer(sender, recipient, amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount)
        internal
        override
        virtual
        validAddress(spender)
    {
        super._approve(owner, spender, amount);
    }


    // MODIFIERS

    modifier validAddress(address _recipient) {
        require(_recipient != address(this), ""!validAddress"");
        _;
    }
}",486
RealWorld_BA_56_Uniswap_RealWord_20240821175228.log,56,Uniswap,3588,4181,7769,72.0,0.10156,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface Uni {
    function swapExactTokensForTokens(uint, uint, address[] calldata, address, uint) external;
}",42
RealWorld_BA_56_MockzpaToken_RealWord_20240821152542.log,56,MockzpaToken,15065,5733,20798,76.0,0.189985,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""../interfaces/Stabilize.sol"";

contract MockzpaToken is ERC20, IZPAToken {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    address constant DEAD = 0x000000000000000000000000000000000000dEaD;
    uint256 constant divisionFactor = 100000;

    address public override underlyingAsset;
    uint256 public override initialFee = 1000; // 1000 = 1%, 100000 = 100%, max fee restricted in contract is 10%
    uint256 public override endFee = 100; // 100 = 0.1%
    uint256 public override feeDuration = 604800; // The amount of seconds it takes from the initial to end fee

    // Info of each user.
    struct UserInfo {
        uint256 depositTime; // The time the user made a deposit, every deposit resets the time
    }

    mapping(address => UserInfo) private userInfo;

    constructor(
        string memory _name,
        string memory _symbol,
        address _underlyingAsset
    )
        public
        ERC20(_name, _symbol)
    {
        underlyingAsset = _underlyingAsset;
    }

    function deposit(uint256 _amount) external override {
        uint256 _toMint = _amount.mul(1e18).div(pricePerToken());
        IERC20(underlyingAsset).safeTransferFrom(msg.sender, address(this), _amount);
        _mint(msg.sender, _toMint);
        userInfo[_msgSender()].depositTime = block.timestamp; // Update the deposit time
    }

    function redeem(uint256 _amount) external override {
        uint256 _underlyingAmount = _amount.mul(pricePerToken()).div(1e18);
        _burn(msg.sender, _amount);

        // Pay fee upon withdrawing
        if (userInfo[_msgSender()].depositTime == 0) {
            // The user has never deposited here
            userInfo[_msgSender()].depositTime = block.timestamp; // Give them the max fee
        }

        uint256 feeSubtraction = initialFee.sub(endFee).mul(block.timestamp.sub(userInfo[_msgSender()].depositTime)).div(feeDuration);
        if (feeSubtraction > initialFee.sub(endFee)) {
            // Cannot reduce fee more than this
            feeSubtraction = initialFee.sub(endFee);
        }
        uint256 fee = initialFee.sub(feeSubtraction);
        fee = _underlyingAmount.mul(fee).div(divisionFactor);
        _underlyingAmount = _underlyingAmount.sub(fee);

        // Now withdraw this amount to the user and send fee to treasury
        IERC20(underlyingAsset).safeTransfer(msg.sender, _underlyingAmount);
        IERC20(underlyingAsset).safeTransfer(DEAD, fee);
    }

    function pricePerToken() public view override returns (uint256) {
        return 2e18;
    }
}",699
RealWorld_BA_56_Harvester_RealWord_20240821155339.log,56,Harvester,37512,5812,43324,84.0,0.3038,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";

import ""./interfaces/IVault.sol"";
import ""./interfaces/IController.sol"";
import ""./interfaces/IHarvester.sol"";
import ""./interfaces/ILegacyController.sol"";
import ""./interfaces/IManager.sol"";
import ""./interfaces/IStrategy.sol"";
import ""./interfaces/ISwap.sol"";

/**
 * @title Harvester
 * @notice This contract is to be used as a central point to call
 * harvest on all strategies for any given vault. It has its own
 * permissions for harvesters (set by the strategist or governance).
 */
contract Harvester is IHarvester {
    using SafeMath for uint256;

    uint256 public constant ONE_HUNDRED_PERCENT = 10000;

    IManager public immutable override manager;
    IController public immutable controller;
    ILegacyController public immutable legacyController;

    uint256 public slippage;

    struct Strategy {
        uint256 timeout;
        uint256 lastCalled;
        address[] addresses;
    }

    mapping(address => Strategy) public strategies;
    mapping(address => bool) public isHarvester;

    /**
     * @notice Logged when harvest is called for a strategy
     */
    event Harvest(
        address indexed controller,
        address indexed strategy
    );

    /**
     * @notice Logged when a harvester is set
     */
    event HarvesterSet(address indexed harvester, bool status);

    /**
     * @notice Logged when a strategy is added for a vault
     */
    event StrategyAdded(address indexed vault, address indexed strategy, uint256 timeout);

    /**
     * @notice Logged when a strategy is removed for a vault
     */
    event StrategyRemoved(address indexed vault, address indexed strategy, uint256 timeout);

    /**
     * @param _manager The address of the yAxisMetaVaultManager contract
     * @param _controller The address of the controller
     */
    constructor(
        address _manager,
        address _controller,
        address _legacyController
    )
        public
    {
        manager = IManager(_manager);
        controller = IController(_controller);
        legacyController = ILegacyController(_legacyController);
    }

    /**
     * (GOVERNANCE|STRATEGIST)-ONLY FUNCTIONS
     */

    /**
     * @notice Adds a strategy to the rotation for a given vault and sets a timeout
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     * @param _timeout The timeout between harvests
     */
    function addStrategy(
        address _vault,
        address _strategy,
        uint256 _timeout
    )
        external
        override
        onlyController
    {
        strategies[_vault].addresses.push(_strategy);
        strategies[_vault].timeout = _timeout;
        emit StrategyAdded(_vault, _strategy, _timeout);
    }

    /**
     * @notice Removes a strategy from the rotation for a given vault and sets a timeout
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     * @param _timeout The timeout between harvests
     */
    function removeStrategy(
        address _vault,
        address _strategy,
        uint256 _timeout
    )
        external
        override
        onlyController
    {
        uint256 tail = strategies[_vault].addresses.length;
        uint256 index;
        bool found;
        for (uint i; i < tail; i++) {
            if (strategies[_vault].addresses[i] == _strategy) {
                index = i;
                found = true;
                break;
            }
        }

        if (found) {
            strategies[_vault].addresses[index] = strategies[_vault].addresses[tail.sub(1)];
            strategies[_vault].addresses.pop();
            strategies[_vault].timeout = _timeout;
            emit StrategyRemoved(_vault, _strategy, _timeout);
        }
    }

    /**
     * @notice Sets the status of a harvester address to be able to call harvest functions
     * @param _harvester The address of the harvester
     * @param _status The status to allow the harvester to harvest
     */
    function setHarvester(
        address _harvester,
        bool _status
    )
        external
        onlyStrategist
    {
        isHarvester[_harvester] = _status;
        emit HarvesterSet(_harvester, _status);
    }

    function setSlippage(
        uint256 _slippage
    )
        external
        onlyStrategist
    {
        require(_slippage < ONE_HUNDRED_PERCENT, ""!_slippage"");
        slippage = _slippage;
    }

    /**
     * HARVESTER-ONLY FUNCTIONS
     */

    function earn(
        address _strategy,
        address _vault
    )
        external
        onlyHarvester
    {
        IVault(_vault).earn(_strategy);
    }

    /**
     * @notice Harvests a given strategy on the provided controller
     * @dev This function ignores the timeout
     * @param _controller The address of the controller
     * @param _strategy The address of the strategy
     */
    function harvest(
        IController _controller,
        address _strategy,
        uint256 _estimatedWETH,
        uint256 _estimatedYAXIS
    )
        public
        onlyHarvester
    {
        _controller.harvestStrategy(_strategy, _estimatedWETH, _estimatedYAXIS);
        emit Harvest(address(_controller), _strategy);
    }

    /**
     * @notice Harvests the next available strategy for a given vault and
     * rotates the strategies
     * @param _vault The address of the vault
     */
    function harvestNextStrategy(
        address _vault,
        uint256 _estimatedWETH,
        uint256 _estimatedYAXIS
    )
        external
    {
        require(canHarvest(_vault), ""!canHarvest"");
        address strategy = strategies[_vault].addresses[0];
        harvest(controller, strategy, _estimatedWETH, _estimatedYAXIS);
        uint256 k = strategies[_vault].addresses.length;
        if (k > 1) {
            address[] memory _strategies = new address[](k);
            for (uint i; i < k-1; i++) {
                _strategies[i] = strategies[_vault].addresses[i+1];
            }
            _strategies[k-1] = strategy;
            strategies[_vault].addresses = _strategies;
        }
        // solhint-disable-next-line not-rely-on-time
        strategies[_vault].lastCalled = block.timestamp;
    }

    /**
     * @notice Earns tokens in the LegacyController to the v3 vault
     * @param _expected The expected amount to deposit after conversion
     */
    function legacyEarn(
        uint256 _expected
    )
        external
        onlyHarvester
    {
        legacyController.legacyDeposit(_expected);
    }

    /**
     * EXTERNAL VIEW FUNCTIONS
     */

    /**
     * @notice Returns the addresses of the strategies for a given vault
     * @param _vault The address of the vault
     */
    function strategyAddresses(
        address _vault
    )
        external
        view
        returns (address[] memory)
    {
        return strategies[_vault].addresses;
    }

    /**
     * PUBLIC VIEW FUNCTIONS
     */

    /**
     * @notice Returns the availability of a vault's strategy to be harvested
     * @param _vault The address of the vault
     */
    function canHarvest(
        address _vault
    )
        public
        view
        returns (bool)
    {
        Strategy storage strategy = strategies[_vault];
        // only can harvest if there are strategies, and when sufficient time has elapsed
        // solhint-disable-next-line not-rely-on-time
        return (strategy.addresses.length > 0 && strategy.lastCalled <= block.timestamp.sub(strategy.timeout));
    }

    /**
     * @notice Returns the estimated amount of WETH and YAXIS for the given strategy
     * @param _strategy The address of the strategy
     */
    function getEstimates(
        address _strategy
    )
        public
        view
        returns (uint256 _estimatedWETH, uint256 _estimatedYAXIS)
    {
        ISwap _router = IStrategy(_strategy).router();
        address[] memory _path;
        _path[0] = IStrategy(_strategy).want();
        _path[1] = IStrategy(_strategy).weth();
        uint256[] memory _amounts = _router.getAmountsOut(
            IStrategy(_strategy).balanceOfPool(),
            _path
        );
        _estimatedWETH = _amounts[1];
        uint256 _slippage = slippage;
        if (_slippage > 0) {
            _estimatedWETH = _estimatedWETH.mul(_slippage).div(ONE_HUNDRED_PERCENT);
        }
        _path[0] = manager.yaxis();
        uint256 _fee = _estimatedWETH.mul(manager.treasuryFee()).div(ONE_HUNDRED_PERCENT);
        _amounts = _router.getAmountsOut(_fee, _path);
        _estimatedYAXIS = _amounts[1];
        if (_slippage > 0) {
            _estimatedYAXIS = _estimatedYAXIS.mul(_slippage).div(ONE_HUNDRED_PERCENT);
        }
    }

    /**
     * MODIFIERS
     */

    modifier onlyController() {
        require(manager.allowedControllers(msg.sender), ""!controller"");
        _;
    }

    modifier onlyHarvester() {
        require(isHarvester[msg.sender], ""!harvester"");
        _;
    }

    modifier onlyStrategist() {
        require(msg.sender == manager.strategist(), ""!strategist"");
        _;
    }
}",2096
RealWorld_BA_56_MockPickleMasterChef_RealWord_20240821151434.log,56,MockPickleMasterChef,9374,5048,14422,71.0,0.14783,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract MockPickleMasterChef {
    IERC20 public pickleToken;
    IERC20 public lpToken;

    struct UserInfo {
        uint amount; // How many LP tokens the user has provided.
        uint rewardDebt; // Reward debt. See explanation below.
    }

    mapping(uint => mapping(address => UserInfo)) public userInfo;

    constructor(IERC20 _pickleToken, IERC20 _lpToken) public {
        pickleToken = _pickleToken;
        lpToken = _lpToken;
    }

    function deposit(uint _pid, uint _amount) external {
        lpToken.transferFrom(msg.sender, address(this), _amount);
        UserInfo storage user = userInfo[_pid][msg.sender];
        pickleToken.transfer(msg.sender, user.amount / 10); // always get 10% of deposited amount
        user.amount = user.amount + _amount;
    }

    function withdraw(uint _pid, uint _amount) external {
        lpToken.transfer(msg.sender, _amount);
        UserInfo storage user = userInfo[_pid][msg.sender];
        pickleToken.transfer(msg.sender, user.amount / 10); // always get 10% of deposited amount
        user.amount = user.amount - _amount;
    }

    function pendingPickle(uint, address) external view returns (uint) {
        return pickleToken.balanceOf(address(this)) / 10;
    }

    function emergencyWithdraw(uint _pid) external {
        UserInfo storage user = userInfo[_pid][msg.sender];
        lpToken.transfer(msg.sender, user.amount);
        user.amount = 0;
        user.rewardDebt = 0;
    }
}",364
RealWorld_BA_56_IConvexVault_RealWord_20240821163544.log,56,IConvexVault,7111,5164,12275,76.0,0.138835,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

interface IConvexVault {
    function poolInfo(uint256 pid)
        external
        view
        returns (
            address lptoken,
            address token,
            address gauge,
            address crvRewards,
            address stash,
            bool shutdown
        );

    function deposit(
        uint256 pid,
        uint256 amount,
        bool stake
    ) external returns (bool);

    function depositAll(uint256 pid, bool stake) external returns (bool);

    function withdraw(uint256 pid, uint256 amount) external returns (bool);

    function withdrawAll(uint256 pid) external returns (bool);
}

interface IConvexRewards {
    function getReward(address _account, bool _claimExtras) external returns (bool);

    function extraRewardsLength() external view returns (uint256);

    function extraRewards(uint256 _pid) external view returns (address);

    function rewardToken() external view returns (address);
}",208
RealWorld_BA_56_IController_RealWord_20240821164801.log,56,IController,5884,5220,11104,106.0,0.13382,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""./IManager.sol"";

interface IController {
    function balanceOf() external view returns (uint256);
    function converter(address _vault) external view returns (address);
    function earn(address _strategy, address _token, uint256 _amount) external;
    function investEnabled() external view returns (bool);
    function harvestStrategy(address _strategy, uint256 _estimatedWETH, uint256 _estimatedYAXIS) external;
    function manager() external view returns (IManager);
    function strategies() external view returns (uint256);
    function withdraw(address _token, uint256 _amount) external;
    function withdrawAll(address _strategy, address _convert) external;
}",156
RealWorld_BA_56_GeneralConverter_RealWord_20240821161139.log,56,GeneralConverter,30385,5372,35757,90.0,0.259365,"pragma solidity 0.6.12;

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
// SPDX-License-Identifier: MIT
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';

import '../interfaces/IConverter.sol';
import '../interfaces/IManager.sol';
import '../interfaces/ICurvePool.sol';
import '../interfaces/ICurve2Pool.sol';
import '../interfaces/ICurve3Pool.sol';

/**
 * @title GeneralConverter
 */
contract GeneralConverter is IConverter {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    IManager public immutable override manager;
    ICurvePool public immutable swapPool;
    IERC20 public immutable tokenCRV;

    IERC20[] public tokens;

    mapping(address => int128) internal indices;

    /**
     * @param _coinCount The number of coins in the pool
     * @param _tokenCRV The address of the CRV token
     * @param _swapPool The address of swap pool
     * @param _manager The address of the Vault Manager
     */
    constructor(
        uint256 _coinCount,
        IERC20 _tokenCRV,
        ICurvePool _swapPool,
        IManager _manager
    ) public {
        require(_coinCount == 2 || _coinCount == 3, '_coinCount should be 2 or 3');

        tokenCRV = _tokenCRV;
        swapPool = _swapPool;
        manager = _manager;

        for (uint256 i = 0; i < _coinCount; i++) {
            tokens.push(IERC20(_swapPool.coins(i)));
            indices[address(tokens[i])] = int128(i);
            tokens[i].safeApprove(address(_swapPool), type(uint256).max);
        }

        _tokenCRV.safeApprove(address(_swapPool), type(uint256).max);
    }

    /**
     * STRATEGIST-ONLY FUNCTIONS
     */

    /**
     * @notice Called by the strategist to approve a token address to be spent by an address
     * @param _token The address of the token
     * @param _spender The address of the spender
     * @param _amount The amount to spend
     */
    function approveForSpender(
        IERC20 _token,
        address _spender,
        uint256 _amount
    ) external onlyStrategist {
        _token.safeApprove(_spender, _amount);
    }

    /**
     * @notice Allows the strategist to withdraw tokens from the converter
     * @dev This contract should never have any tokens in it at the end of a transaction
     * @param _token The address of the token
     * @param _amount The amount to withdraw
     * @param _to The address to receive the tokens
     */
    function recoverUnsupported(
        IERC20 _token,
        uint256 _amount,
        address _to
    ) external onlyStrategist {
        _token.safeTransfer(_to, _amount);
    }

    /**
     * AUTHORIZED-ONLY FUNCTIONS
     */

    /**
     * @notice Converts the amount of input tokens to output tokens
     * @param _input The address of the token being converted
     * @param _output The address of the token to be converted to
     * @param _inputAmount The input amount of tokens that are being converted
     * @param _estimatedOutput The estimated output tokens after converting
     */
    function convert(
        address _input,
        address _output,
        uint256 _inputAmount,
        uint256 _estimatedOutput
    ) external override onlyAuthorized returns (uint256 _outputAmount) {
        if (_output == address(tokenCRV)) {
            // convert to CRV
            for (uint8 i = 0; i < tokens.length; i++) {
                if (_input == address(tokens[i])) {
                    uint256 _before = tokenCRV.balanceOf(address(this));

                    if (tokens.length == 2) {
                        uint256[2] memory amounts;
                        amounts[i] = _inputAmount;
                        ICurve2Pool(address(swapPool)).add_liquidity(
                            amounts,
                            _estimatedOutput
                        );
                    } else {
                        uint256[3] memory amounts;
                        amounts[i] = _inputAmount;
                        ICurve3Pool(address(swapPool)).add_liquidity(
                            amounts,
                            _estimatedOutput
                        );
                    }

                    uint256 _after = tokenCRV.balanceOf(address(this));
                    _outputAmount = _after.sub(_before);
                    tokenCRV.safeTransfer(msg.sender, _outputAmount);
                    return _outputAmount;
                }
            }
        } else if (_input == address(tokenCRV)) {
            // convert from CRV
            for (uint8 i = 0; i < tokens.length; i++) {
                if (_output == address(tokens[i])) {
                    uint256 _before = tokens[i].balanceOf(address(this));
                    swapPool.remove_liquidity_one_coin(_inputAmount, i, _estimatedOutput);
                    uint256 _after = tokens[i].balanceOf(address(this));
                    _outputAmount = _after.sub(_before);
                    tokens[i].safeTransfer(msg.sender, _outputAmount);
                    return _outputAmount;
                }
            }
        } else {
            swapPool.exchange(
                indices[_input],
                indices[_output],
                _inputAmount,
                _estimatedOutput
            );
            _outputAmount = IERC20(_output).balanceOf(address(this));
            IERC20(_output).safeTransfer(msg.sender, _outputAmount);
            return _outputAmount;
        }
        return 0;
    }

    /**
     * @notice Checks the amount of input tokens to output tokens
     * @param _input The address of the token being converted
     * @param _output The address of the token to be converted to
     * @param _inputAmount The input amount of tokens that are being converted
     */
    function expected(
        address _input,
        address _output,
        uint256 _inputAmount
    ) external view override returns (uint256) {
        if (_output == address(tokenCRV)) {
            // convert to CRV
            for (uint8 i = 0; i < tokens.length; i++) {
                if (_input == address(tokens[i])) {
                    if (tokens.length == 2) {
                        uint256[2] memory amounts;
                        amounts[i] = _inputAmount;
                        return ICurve2Pool(address(swapPool)).calc_token_amount(amounts, true);
                    } else {
                        uint256[3] memory amounts;
                        amounts[i] = _inputAmount;
                        return ICurve3Pool(address(swapPool)).calc_token_amount(amounts, true);
                    }
                }
            }
        } else if (_input == address(tokenCRV)) {
            // convert from CRV
            for (uint8 i = 0; i < tokens.length; i++) {
                if (_output == address(tokens[i])) {
                    // @dev this is for UI reference only, the actual share price
                    // (stable/CRV) will be re-calculated on-chain when we do convert()
                    return swapPool.calc_withdraw_one_coin(_inputAmount, i);
                }
            }
        } else {
            return swapPool.get_dy(indices[_input], indices[_output], _inputAmount);
        }
        return 0;
    }

    /**
     * MODIFIERS
     */

    /**
     * @dev Throws if not called by an allowed vault, controller, or strategy
     */
    modifier onlyAuthorized() {
        require(
            manager.allowedVaults(msg.sender) ||
                manager.allowedControllers(msg.sender) ||
                manager.allowedStrategies(msg.sender),
            '!authorized'
        );
        _;
    }

    /**
     * @dev Throws if not called by the strategist
     */
    modifier onlyStrategist() {
        require(msg.sender == manager.strategist(), '!strategist');
        _;
    }
}",1715
RealWorld_BA_56_ERC677Token_RealWord_20240821173345.log,56,ERC677Token,8530,5266,13796,78.0,0.14797,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""./token/ERC677.sol"";
import ""./token/ERC677Receiver.sol"";

abstract contract ERC677Token is ERC20, ERC677 {
  /**
   * @dev transfer token to a contract address with additional data if the recipient is a contact.
   * @param _to The address to transfer to.
   * @param _value The amount to be transferred.
   * @param _data The extra data to be passed to the receiving contract.
   */
  function transferAndCall(address _to, uint _value, bytes memory _data)
    public
    override
    virtual
    returns (bool success)
  {
    super.transfer(_to, _value);
    emit Transfer(msg.sender, _to, _value, _data);
    if (isContract(_to)) {
      contractFallback(_to, _value, _data);
    }
    return true;
  }


  // PRIVATE

  function contractFallback(address _to, uint _value, bytes memory _data)
    private
  {
    ERC677Receiver receiver = ERC677Receiver(_to);
    receiver.onTokenTransfer(msg.sender, _value, _data);
  }

  function isContract(address _addr)
    private
    view
    returns (bool hasCode)
  {
    uint length;
    assembly { length := extcodesize(_addr) }
    return length > 0;
  }
}",317
RealWorld_BA_56_Stabilize_RealWord_20240821175624.log,56,Stabilize,6379,5190,11569,90.0,0.135695,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface IZPAToken {
    function deposit(uint256) external;
    function redeem(uint256) external;
    function underlyingAsset() external view returns (address);
    function pricePerToken() external view returns (uint256);

    function initialFee() external view returns (uint256);
    function endFee() external view returns (uint256);
    function feeDuration() external view returns (uint256);
}

interface IZPAPool {
    function deposit(uint256, uint256) external;
    function withdraw(uint256, uint256) external;
    function exit(uint256, uint256) external;
    function getReward(uint256) external;
    function rewardEarned(uint256, address) external view returns (uint256);
    function poolTokenAddress(uint256) external view returns (address);
    function poolBalance(uint256, address) external view returns (uint256);
}",196
RealWorld_BA_56_Transmuter_RealWord_20240821164950.log,56,Transmuter,76395,5848,82243,104.0,0.498935,"pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import ""@openzeppelin/contracts/GSN/Context.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""./interfaces/IERC20Burnable.sol"";

import ""hardhat/console.sol"";

//    ___    __        __                _               ___                              __         _ 
//   / _ |  / / ____  / /  ___   __ _   (_) __ __       / _ \  ____ ___   ___ ___   ___  / /_  ___  (_)
//  / __ | / / / __/ / _ \/ -_) /  ' \ / /  \ \ /      / ___/ / __// -_) (_-</ -_) / _ \/ __/ (_-< _
// /_/ |_|/_/  \__/ /_//_/\__/ /_/_/_//_/  /_\_\      /_/    /_/   \__/ /___/\__/ /_//_/\__/ /___/(_)
//
// .___________..______           ___      .__   __.      _______..___  ___.  __    __  .___________. _______ .______
// |           ||   _  \         /   \     |  \ |  |     /       ||   \/   | |  |  |  | |           ||   ____||   _  \
// `---|  |----`|  |_)  |       /  ^  \    |   \|  |    |   (----`|  \  /  | |  |  |  | `---|  |----`|  |__   |  |_)  |
//     |  |     |      /       /  /_\  \   |  . `  |     \   \    |  |\/|  | |  |  |  |     |  |     |   __|  |      /
//     |  |     |  |\  \----. /  _____  \  |  |\   | .----)   |   |  |  |  | |  `--'  |     |  |     |  |____ |  |\  \----.
//     |__|     | _| `._____|/__/     \__\ |__| \__| |_______/    |__|  |__|  \______/      |__|     |_______|| _| `._____|
/**
 * @dev Implementation of the {IERC20Burnable} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20Burnable-approve}.
 */
contract Transmuter is Context {
    using SafeMath for uint256;
    using SafeERC20 for IERC20Burnable;
    using Address for address;

    address public constant ZERO_ADDRESS = address(0);
    uint256 public TRANSMUTATION_PERIOD;

    address public AlToken;
    address public Token;

    mapping(address => uint256) public depositedAlTokens;
    mapping(address => uint256) public tokensInBucket;
    mapping(address => uint256) public realisedTokens;
    mapping(address => uint256) public lastDividendPoints;

    mapping(address => bool) public userIsKnown;
    mapping(uint256 => address) public userList;
    uint256 public nextUser;

    uint256 public totalSupplyAltokens;
    uint256 public buffer;
    uint256 public lastDepositBlock;

    ///@dev values needed to calculate the distribution of base asset in proportion for alTokens staked
    uint256 public pointMultiplier = 10e18;

    uint256 public totalDividendPoints;
    uint256 public unclaimedDividends;

    /// @dev alchemist addresses whitelisted
    mapping (address => bool) public whiteList;

    /// @dev The address of the account which currently has administrative capabilities over this contract.
    address public governance;

    /// @dev The address of the pending governance.
    address public pendingGovernance;

    event GovernanceUpdated(
        address governance
    );

    event PendingGovernanceUpdated(
        address pendingGovernance
    );

    event TransmuterPeriodUpdated(
        uint256 newTransmutationPeriod
    );

    constructor(address _AlToken, address _Token, address _governance) public {
        require(_governance != ZERO_ADDRESS, ""Transmuter: 0 gov"");
        governance = _governance;
        AlToken = _AlToken;
        Token = _Token;
        TRANSMUTATION_PERIOD = 50;
    }

    ///@return displays the user's share of the pooled alTokens.
    function dividendsOwing(address account) public view returns (uint256) {
        uint256 newDividendPoints = totalDividendPoints.sub(lastDividendPoints[account]);
        return depositedAlTokens[account].mul(newDividendPoints).div(pointMultiplier);
    }

    ///@dev modifier to fill the bucket and keep bookkeeping correct incase of increase/decrease in shares
    modifier updateAccount(address account) {
        uint256 owing = dividendsOwing(account);
        if (owing > 0) {
            unclaimedDividends = unclaimedDividends.sub(owing);
            tokensInBucket[account] = tokensInBucket[account].add(owing);
        }
        lastDividendPoints[account] = totalDividendPoints;
        _;
    }
    ///@dev modifier add users to userlist. Users are indexed in order to keep track of when a bond has been filled
    modifier checkIfNewUser() {
        if (!userIsKnown[msg.sender]) {
            userList[nextUser] = msg.sender;
            userIsKnown[msg.sender] = true;
            nextUser++;
        }
        _;
    }

    ///@dev run the phased distribution of the buffered funds
    modifier runPhasedDistribution() {
        uint256 _lastDepositBlock = lastDepositBlock;
        uint256 _currentBlock = block.number;
        uint256 _toDistribute = 0;
        uint256 _buffer = buffer;

        // check if there is something in bufffer
        if (_buffer > 0) {
            // NOTE: if last deposit was updated in the same block as the current call
            // then the below logic gates will fail

            //calculate diffrence in time
            uint256 deltaTime = _currentBlock.sub(_lastDepositBlock);

            // distribute all if bigger than timeframe
            if(deltaTime >= TRANSMUTATION_PERIOD) {
                _toDistribute = _buffer;
            } else {

                //needs to be bigger than 0 cuzz solidity no decimals
                if(_buffer.mul(deltaTime) > TRANSMUTATION_PERIOD)
                {
                    _toDistribute = _buffer.mul(deltaTime).div(TRANSMUTATION_PERIOD);
                }
            }

            // factually allocate if any needs distribution
            if(_toDistribute > 0){

                // remove from buffer
                buffer = _buffer.sub(_toDistribute);

                // increase the allocation
                increaseAllocations(_toDistribute);
            }
        }

        // current timeframe is now the last
        lastDepositBlock = _currentBlock;
        _;
    }

    /// @dev A modifier which checks if whitelisted for minting.
    modifier onlyWhitelisted() {
        require(whiteList[msg.sender], ""Transmuter: !whitelisted"");
        _;
    }

    /// @dev Checks that the current message sender or caller is the governance address.
    ///
    ///
    modifier onlyGov() {
        require(msg.sender == governance, ""Transmuter: !governance"");
        _;
    }

    ///@dev set the TRANSMUTATION_PERIOD variable
    ///
    /// sets the length (in blocks) of one full distribution phase
    function setTransmutationPeriod(uint256 newTransmutationPeriod) public onlyGov() {
        TRANSMUTATION_PERIOD = newTransmutationPeriod;
        emit TransmuterPeriodUpdated(TRANSMUTATION_PERIOD);
    }

    ///@dev claims the base token after it has been transmuted
    ///
    ///This function reverts if there is no realisedToken balance
    function claim() public {
        address sender = msg.sender;
        require(realisedTokens[sender] > 0);
        uint256 value = realisedTokens[sender];
        realisedTokens[sender] = 0;
        IERC20Burnable(Token).safeTransfer(sender, value);
    }

    ///@dev Withdraws staked alTokens from the transmuter
    ///
    /// This function reverts if you try to draw more tokens than you deposited
    ///
    ///@param amount the amount of alTokens to unstake
    function unstake(uint256 amount) public updateAccount(msg.sender) {
        // by calling this function before transmuting you forfeit your gained allocation
        address sender = msg.sender;
        require(depositedAlTokens[sender] >= amount,""Transmuter: unstake amount exceeds deposited amount"");
        depositedAlTokens[sender] = depositedAlTokens[sender].sub(amount);
        totalSupplyAltokens = totalSupplyAltokens.sub(amount);
        IERC20Burnable(AlToken).safeTransfer(sender, amount);
    }
    ///@dev Deposits alTokens into the transmuter 
    ///
    ///@param amount the amount of alTokens to stake
    function stake(uint256 amount)
        public
        runPhasedDistribution()
        updateAccount(msg.sender)
        checkIfNewUser()
    {
        // requires approval of AlToken first
        address sender = msg.sender;
        //require tokens transferred in;
        IERC20Burnable(AlToken).safeTransferFrom(sender, address(this), amount);
        totalSupplyAltokens = totalSupplyAltokens.add(amount);
        depositedAlTokens[sender] = depositedAlTokens[sender].add(amount);
    }
    /// @dev Converts the staked alTokens to the base tokens in amount of the sum of pendingdivs and tokensInBucket
    ///
    /// once the alToken has been converted, it is burned, and the base token becomes realisedTokens which can be recieved using claim()    
    ///
    /// reverts if there are no pendingdivs or tokensInBucket
    function transmute() public runPhasedDistribution() updateAccount(msg.sender) {
        address sender = msg.sender;
        uint256 pendingz = tokensInBucket[sender];
        uint256 diff;

        require(pendingz > 0, ""need to have pending in bucket"");

        tokensInBucket[sender] = 0;

        // check bucket overflow
        if (pendingz > depositedAlTokens[sender]) {
            diff = pendingz.sub(depositedAlTokens[sender]);

            // remove overflow
            pendingz = depositedAlTokens[sender];
        }

        // decrease altokens
        depositedAlTokens[sender] = depositedAlTokens[sender].sub(pendingz);

        // BURN ALTOKENS
        IERC20Burnable(AlToken).burn(pendingz);

        // adjust total
        totalSupplyAltokens = totalSupplyAltokens.sub(pendingz);

        // reallocate overflow
        increaseAllocations(diff);

        // add payout
        realisedTokens[sender] = realisedTokens[sender].add(pendingz);
    }

    /// @dev Executes transmute() on another account that has had more base tokens allocated to it than alTokens staked.
    ///
    /// The caller of this function will have the surlus base tokens credited to their tokensInBucket balance, rewarding them for performing this action
    ///
    /// This function reverts if the address to transmute is not over-filled.
    ///
    /// @param toTransmute address of the account you will force transmute.
    function forceTransmute(address toTransmute)
        public
        runPhasedDistribution()
        updateAccount(msg.sender)
        updateAccount(toTransmute)
    {
        //load into memory
        address sender = msg.sender;
        uint256 pendingz = tokensInBucket[toTransmute];
        // check restrictions
        require(
            pendingz > depositedAlTokens[toTransmute],
            ""Transmuter: !overflow""
        );

        // empty bucket
        tokensInBucket[toTransmute] = 0;

        // calculaate diffrence
        uint256 diff = pendingz.sub(depositedAlTokens[toTransmute]);

        // remove overflow
        pendingz = depositedAlTokens[toTransmute];

        // decrease altokens
        depositedAlTokens[toTransmute] = 0;

        // BURN ALTOKENS
        IERC20Burnable(AlToken).burn(pendingz);

        // adjust total
        totalSupplyAltokens = totalSupplyAltokens.sub(pendingz);

        // reallocate overflow
        tokensInBucket[sender] = tokensInBucket[sender].add(diff);

        // add payout
        realisedTokens[toTransmute] = realisedTokens[toTransmute].add(pendingz);

        // force payout of realised tokens of the toTransmute address
        if (realisedTokens[toTransmute] > 0) {
            uint256 value = realisedTokens[toTransmute];
            realisedTokens[toTransmute] = 0;
            IERC20Burnable(Token).safeTransfer(toTransmute, value);
        }
    }

    /// @dev Transmutes and unstakes all alTokens
    ///
    /// This function combines the transmute and unstake functions for ease of use
    function exit() public {
        transmute();
        uint256 toWithdraw = depositedAlTokens[msg.sender];
        unstake(toWithdraw);
    }

    /// @dev Transmutes and claims all converted base tokens.
    ///
    /// This function combines the transmute and claim functions while leaving your remaining alTokens staked.
    function transmuteAndClaim() public {
        transmute();
        claim();
    }

    /// @dev Transmutes, claims base tokens, and withdraws alTokens.
    ///
    /// This function helps users to exit the transmuter contract completely after converting their alTokens to the base pair.
    function transmuteClaimAndWithdraw() public {
        transmute();
        claim();
        uint256 toWithdraw = depositedAlTokens[msg.sender];
        unstake(toWithdraw);
    }

    /// @dev Distributes the base token proportionally to all alToken stakers.
    ///
    /// This function is meant to be called by the Alchemist contract for when it is sending yield to the transmuter. 
    /// Anyone can call this and add funds, idk why they would do that though...
    ///
    /// @param origin the account that is sending the tokens to be distributed.
    /// @param amount the amount of base tokens to be distributed to the transmuter.
    function distribute(address origin, uint256 amount) public onlyWhitelisted() runPhasedDistribution() {
        IERC20Burnable(Token).safeTransferFrom(origin, address(this), amount);
        buffer = buffer.add(amount);
    }

    /// @dev Allocates the incoming yield proportionally to all alToken stakers.
    ///
    /// @param amount the amount of base tokens to be distributed in the transmuter.
    function increaseAllocations(uint256 amount) internal {
        if(totalSupplyAltokens > 0 && amount > 0) {
            totalDividendPoints = totalDividendPoints.add(
                amount.mul(pointMultiplier).div(totalSupplyAltokens)
            );
            unclaimedDividends = unclaimedDividends.add(amount);
        } else {
            buffer = buffer.add(amount);
        }
    }

    /// @dev Gets the status of a user's staking position.
    ///
    /// The total amount allocated to a user is the sum of pendingdivs and inbucket.
    ///
    /// @param user the address of the user you wish to query.
    ///
    /// returns user status
    
    function userInfo(address user)
        public
        view
        returns (
            uint256 depositedAl,
            uint256 pendingdivs,
            uint256 inbucket,
            uint256 realised
        )
    {
        uint256 _depositedAl = depositedAlTokens[user];
        uint256 _toDistribute = buffer.mul(block.number.sub(lastDepositBlock)).div(TRANSMUTATION_PERIOD);
        if(block.number.sub(lastDepositBlock) > TRANSMUTATION_PERIOD){
            _toDistribute = buffer;
        }
        uint256 _pendingdivs = _toDistribute.mul(depositedAlTokens[user]).div(totalSupplyAltokens);
        uint256 _inbucket = tokensInBucket[user].add(dividendsOwing(user));
        uint256 _realised = realisedTokens[user];
        return (_depositedAl, _pendingdivs, _inbucket, _realised);
    }

    /// @dev Gets the status of multiple users in one call
    ///
    /// This function is used to query the contract to check for
    /// accounts that have overfilled positions in order to check 
    /// who can be force transmuted.
    ///
    /// @param from the first index of the userList
    /// @param to the last index of the userList
    ///
    /// returns the userList with their staking status in paginated form. 
    function getMultipleUserInfo(uint256 from, uint256 to)
        public
        view
        returns (address[] memory theUserList, uint256[] memory theUserData)
    {
        uint256 i = from;
        uint256 delta = to - from;
        address[] memory _theUserList = new address[](delta); //user
        uint256[] memory _theUserData = new uint256[](delta * 2); //deposited-bucket
        uint256 y = 0;
        uint256 _toDistribute = buffer.mul(block.number.sub(lastDepositBlock)).div(TRANSMUTATION_PERIOD);
        if(block.number.sub(lastDepositBlock) > TRANSMUTATION_PERIOD){
            _toDistribute = buffer;
        }
        for (uint256 x = 0; x < delta; x += 1) {
            _theUserList[x] = userList[i];
            _theUserData[y] = depositedAlTokens[userList[i]];
            _theUserData[y + 1] = dividendsOwing(userList[i]).add(tokensInBucket[userList[i]]).add(_toDistribute.mul(depositedAlTokens[userList[i]]).div(totalSupplyAltokens));
            y += 2;
            i += 1;
        }
        return (_theUserList, _theUserData);
    }

    /// @dev Gets info on the buffer
    ///
    /// This function is used to query the contract to get the
    /// latest state of the buffer
    ///
    /// @return _toDistribute the amount ready to be distributed
    /// @return _deltaBlocks the amount of time since the last phased distribution
    /// @return _buffer the amount in the buffer 
    function bufferInfo() public view returns (uint256 _toDistribute, uint256 _deltaBlocks, uint256 _buffer){
        _deltaBlocks = block.number.sub(lastDepositBlock);
        _buffer = buffer; 
        _toDistribute = _buffer.mul(_deltaBlocks).div(TRANSMUTATION_PERIOD);
    }

    /// @dev Sets the pending governance.
    ///
    /// This function reverts if the new pending governance is the zero address or the caller is not the current
    /// governance. This is to prevent the contract governance being set to the zero address which would deadlock
    /// privileged contract functionality.
    ///
    /// @param _pendingGovernance the new pending governance.
    function setPendingGovernance(address _pendingGovernance) external onlyGov {
        require(_pendingGovernance != ZERO_ADDRESS, ""Transmuter: 0 gov"");

        pendingGovernance = _pendingGovernance;

        emit PendingGovernanceUpdated(_pendingGovernance);
    }

    /// @dev Accepts the role as governance.
    ///
    /// This function reverts if the caller is not the new pending governance.
    function acceptGovernance() external  {
        require(msg.sender == pendingGovernance,""!pendingGovernance"");
        address _pendingGovernance = pendingGovernance;
        governance = _pendingGovernance;

        emit GovernanceUpdated(_pendingGovernance);
    }

    /// This function reverts if the caller is not governance
    ///
    /// @param _toWhitelist the account to mint tokens to.
    /// @param _state the whitelist state.

    function setWhitelist(address _toWhitelist, bool _state) external onlyGov {
        whiteList[_toWhitelist] = _state;
    }
}",4586
RealWorld_BA_56_IStrategy_RealWord_20240821163407.log,56,IStrategy,6194,5338,11532,95.0,0.13773,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""./IManager.sol"";
import ""./ISwap.sol"";

interface IStrategy {
    function balanceOf() external view returns (uint256);
    function balanceOfPool() external view returns (uint256);
    function balanceOfWant() external view returns (uint256);
    function deposit() external;
    function harvest(uint256, uint256) external;
    function manager() external view returns (IManager);
    function name() external view returns (string memory);
    function router() external view returns (ISwap);
    function skim() external;
    function want() external view returns (address);
    function weth() external view returns (address);
    function withdraw(address) external;
    function withdraw(uint256) external;
    function withdrawAll() external;
}",170
RealWorld_BA_56_IStableSwap3Pool_RealWord_20240821162241.log,56,IStableSwap3Pool,7356,4989,12345,92.0,0.13656,"// SPDX-License-Identifier: MIT
// solhint-disable func-name-mixedcase
// solhint-disable var-name-mixedcase

pragma solidity 0.6.12;

interface IStableSwap3Pool {
    function get_virtual_price() external view returns (uint);
    function balances(uint) external view returns (uint);
    function get_dy(int128 i, int128 j, uint dx) external view returns (uint dy);
    function exchange(int128 i, int128 j, uint dx, uint min_dy) external;
    function add_liquidity(uint[3] calldata amounts, uint min_mint_amount) external;
    function remove_liquidity(uint _amount, uint[3] calldata amounts) external;
    function remove_liquidity_one_coin(uint _token_amount, int128 i, uint min_amount) external;
    function calc_token_amount(uint[3] calldata amounts, bool deposit) external view returns (uint);
    function calc_withdraw_one_coin(uint _token_amount, int128 i) external view returns (uint);
}",219
RealWorld_BA_56_IYearnController_RealWord_20240821171446.log,56,IYearnController,4339,3976,8315,68.0,0.101215,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.6.12;

interface IYearnController {
  function balanceOf(address _token) external view returns (uint256);
  function earn(address _token, uint256 _amount) external;
  function withdraw(address _token, uint256 _withdrawAmount) external;
}",71
RealWorld_BA_56_Chainlink_RealWord_20240821180514.log,56,Chainlink,8529,4961,13490,92.0,0.141865,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

interface AggregatorInterface {
      function latestAnswer() external view returns (int256);
      function latestTimestamp() external view returns (uint256);
      function latestRound() external view returns (uint256);
      function getAnswer(uint256 roundId) external view returns (int256);
      function getTimestamp(uint256 roundId) external view returns (uint256);
}

interface AggregatorV3Interface {

      function decimals() external view returns (uint8);
      function description() external view returns (string memory);
      function version() external view returns (uint256);

      // getRoundData and latestRoundData should both raise ""No data present""
      // if they do not have data to report, instead of returning unset values
      // which could be misinterpreted as actual reported values.
      function getRoundData(uint80 _roundId)
            external
            view
            returns (
                  uint80 roundId,
                  int256 answer,
                  uint256 startedAt,
                  uint256 updatedAt,
                  uint80 answeredInRound
            );
      function latestRoundData()
            external
            view
            returns (
                  uint80 roundId,
                  int256 answer,
                  uint256 startedAt,
                  uint256 updatedAt,
                  uint80 answeredInRound
            );
}

interface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface
{
}",295
RealWorld_BA_56_IHarvester_RealWord_20240821164124.log,56,IHarvester,4121,4278,8399,73.0,0.106165,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""./IManager.sol"";

interface IHarvester {
    function addStrategy(address, address, uint256) external;
    function manager() external view returns (IManager);
    function removeStrategy(address, address, uint256) external;
}",65
RealWorld_BA_56_ERC677Receiver_RealWord_20240821173648.log,56,ERC677Receiver,3826,3946,7772,66.0,0.09805,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

abstract contract ERC677Receiver {
  function onTokenTransfer(address _sender, uint _value, bytes memory _data) public virtual;
}",44
RealWorld_BA_56_IVaultToken_RealWord_20240821163703.log,56,IVaultToken,3689,4275,7964,84.0,0.103945,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

interface IVaultToken {
    function mint(address,uint256) external;
    function burn(address,uint256) external;
}",40
RealWorld_BA_56_BaseStrategy_RealWord_20240821160219.log,56,BaseStrategy,36433,5892,42325,110.0,0.300005,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import ""../interfaces/IStableSwap3Pool.sol"";
import ""../interfaces/ISwap.sol"";
import ""../interfaces/IManager.sol"";
import ""../interfaces/IStrategy.sol"";
import ""../interfaces/IController.sol"";

/**
 * @title BaseStrategy
 * @notice The BaseStrategy is an abstract contract which all
 * yAxis strategies should inherit functionality from. It gives
 * specific security properties which make it hard to write an
 * insecure strategy.
 * @notice All state-changing functions implemented in the strategy
 * should be internal, since any public or externally-facing functions
 * are already handled in the BaseStrategy.
 * @notice The following functions must be implemented by a strategy:
 * - function _deposit() internal virtual;
 * - function _harvest() internal virtual;
 * - function _withdraw(uint256 _amount) internal virtual;
 * - function _withdrawAll() internal virtual;
 * - function balanceOfPool() public view override virtual returns (uint256);
 */
abstract contract BaseStrategy is IStrategy {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    uint256 public constant ONE_HUNDRED_PERCENT = 10000;

    address public immutable override want;
    address public immutable override weth;
    address public immutable controller;
    IManager public immutable override manager;
    string public override name;
    ISwap public override router;

    /**
     * @param _controller The address of the controller
     * @param _manager The address of the manager
     * @param _want The desired token of the strategy
     * @param _weth The address of WETH
     * @param _router The address of the router for swapping tokens
     */
    constructor(
        string memory _name,
        address _controller,
        address _manager,
        address _want,
        address _weth,
        address _router
    ) public {
        name = _name;
        want = _want;
        controller = _controller;
        manager = IManager(_manager);
        weth = _weth;
        router = ISwap(_router);
        IERC20(_weth).safeApprove(address(_router), type(uint256).max);
    }

    /**
     * GOVERNANCE-ONLY FUNCTIONS
     */

    /**
     * @notice Approves a token address to be spent by an address
     * @param _token The address of the token
     * @param _spender The address of the spender
     * @param _amount The amount to spend
     */
    function approveForSpender(
        IERC20 _token,
        address _spender,
        uint256 _amount
    )
        external
    {
        require(msg.sender == manager.governance(), ""!governance"");
        _token.safeApprove(_spender, 0);
        _token.safeApprove(_spender, _amount);
    }

    /**
     * @notice Sets the address of the ISwap-compatible router
     * @param _router The address of the router
     */
    function setRouter(
        address _router
    )
        external
    {
        require(msg.sender == manager.governance(), ""!governance"");
        router = ISwap(_router);
        IERC20(weth).safeApprove(address(_router), 0);
        IERC20(weth).safeApprove(address(_router), type(uint256).max);
    }

    /**
     * CONTROLLER-ONLY FUNCTIONS
     */

    /**
     * @notice Deposits funds to the strategy's pool
     */
    function deposit()
        external
        override
        onlyController
    {
        _deposit();
    }

    /**
     * @notice Harvest funds in the strategy's pool
     */
    function harvest(
        uint256 _estimatedWETH,
        uint256 _estimatedYAXIS
    )
        external
        override
        onlyController
    {
        _harvest(_estimatedWETH, _estimatedYAXIS);
    }

    /**
     * @notice Sends stuck want tokens in the strategy to the controller
     */
    function skim()
        external
        override
        onlyController
    {
        IERC20(want).safeTransfer(controller, balanceOfWant());
    }

    /**
     * @notice Sends stuck tokens in the strategy to the controller
     * @param _asset The address of the token to withdraw
     */
    function withdraw(
        address _asset
    )
        external
        override
        onlyController
    {
        require(want != _asset, ""want"");

        IERC20 _assetToken = IERC20(_asset);
        uint256 _balance = _assetToken.balanceOf(address(this));
        _assetToken.safeTransfer(controller, _balance);
    }

    /**
     * @notice Initiated from a vault, withdraws funds from the pool
     * @param _amount The amount of the want token to withdraw
     */
    function withdraw(
        uint256 _amount
    )
        external
        override
        onlyController
    {
        uint256 _balance = balanceOfWant();
        if (_balance < _amount) {
            _amount = _withdrawSome(_amount.sub(_balance));
            _amount = _amount.add(_balance);
        }

        IERC20(want).safeTransfer(controller, _amount);
    }

    /**
     * @notice Withdraws all funds from the strategy
     */
    function withdrawAll()
        external
        override
        onlyController
    {
        _withdrawAll();

        uint256 _balance = IERC20(want).balanceOf(address(this));

        IERC20(want).safeTransfer(controller, _balance);
    }

    /**
     * EXTERNAL VIEW FUNCTIONS
     */

    /**
     * @notice Returns the strategy's balance of the want token plus the balance of pool
     */
    function balanceOf()
        external
        view
        override
        returns (uint256)
    {
        return balanceOfWant().add(balanceOfPool());
    }

    /**
     * PUBLIC VIEW FUNCTIONS
     */

    /**
     * @notice Returns the balance of the pool
     * @dev Must be implemented by the strategy
     */
    function balanceOfPool()
        public
        view
        virtual
        override
        returns (uint256);

    /**
     * @notice Returns the balance of the want token on the strategy
     */
    function balanceOfWant()
        public
        view
        override
        returns (uint256)
    {
        return IERC20(want).balanceOf(address(this));
    }

    /**
     * INTERNAL FUNCTIONS
     */

    function _deposit()
        internal
        virtual;

    function _harvest(
        uint256 _estimatedWETH,
        uint256 _estimatedYAXIS
    )
        internal
        virtual;

    function _payHarvestFees(
        address _poolToken,
        uint256 _estimatedWETH,
        uint256 _estimatedYAXIS
    )
        internal
        returns (uint256 _wethBal)
    {
        uint256 _amount = IERC20(_poolToken).balanceOf(address(this));
        _swapTokens(_poolToken, weth, _amount, _estimatedWETH);
        _wethBal = IERC20(weth).balanceOf(address(this));

        if (_wethBal > 0) {
            // get all the necessary variables in a single call
            (
                address yaxis,
                address treasury,
                uint256 treasuryFee
            ) = manager.getHarvestFeeInfo();

            uint256 _fee;

            // pay the treasury with YAX
            if (treasuryFee > 0 && treasury != address(0)) {
                _fee = _wethBal.mul(treasuryFee).div(ONE_HUNDRED_PERCENT);
                _swapTokens(weth, yaxis, _fee, _estimatedYAXIS);
                IERC20(yaxis).safeTransfer(treasury, IERC20(yaxis).balanceOf(address(this)));
            }

            // return the remaining WETH balance
            _wethBal = IERC20(weth).balanceOf(address(this));
        }
    }

    function _swapTokens(
        address _input,
        address _output,
        uint256 _amount,
        uint256 _expected
    )
        internal
    {
        address[] memory path = new address[](2);
        path[0] = _input;
        path[1] = _output;
        router.swapExactTokensForTokens(
            _amount,
            _expected,
            path,
            address(this),
            // The deadline is a hardcoded value that is far in the future.
            1e10
        );
    }

    function _withdraw(
        uint256 _amount
    )
        internal
        virtual;

    function _withdrawAll()
        internal
        virtual;

    function _withdrawSome(
        uint256 _amount
    )
        internal
        returns (uint256)
    {
        uint256 _before = IERC20(want).balanceOf(address(this));
        _withdraw(_amount);
        uint256 _after = IERC20(want).balanceOf(address(this));
        _amount = _after.sub(_before);

        return _amount;
    }

    /**
     * MODIFIERS
     */

    modifier onlyStrategist() {
        require(msg.sender == manager.strategist(), ""!strategist"");
        _;
    }

    modifier onlyController() {
        require(msg.sender == controller, ""!controller"");
        _;
    }
}",2055
RealWorld_BA_56_MockV3Aggregatgor_RealWord_20240821152013.log,56,MockV3Aggregatgor,12868,4770,17638,76.0,0.15974,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import ""../interfaces/Chainlink.sol"";

/**
 * @title MockV3Aggregator
 * @notice Based on the FluxAggregator contract
 * @notice Use this contract when you need to test
 * other contract's ability to read data from an
 * aggregator contract, but how the aggregator got
 * its answer is unimportant
 */
contract MockV3Aggregator is AggregatorV2V3Interface {
  uint256 constant public override version = 0;

  uint8 public override decimals;
  int256 public override latestAnswer;
  uint256 public override latestTimestamp;
  uint256 public override latestRound;

  mapping(uint256 => int256) public override getAnswer;
  mapping(uint256 => uint256) public override getTimestamp;
  mapping(uint256 => uint256) private getStartedAt;

  constructor(
    uint8 _decimals,
    int256 _initialAnswer
  ) public {
    decimals = _decimals;
    updateAnswer(_initialAnswer);
  }

  function updateAnswer(
    int256 _answer
  ) public {
    latestAnswer = _answer;
    latestTimestamp = block.timestamp;
    latestRound++;
    getAnswer[latestRound] = _answer;
    getTimestamp[latestRound] = block.timestamp;
    getStartedAt[latestRound] = block.timestamp;
  }

  function updateRoundData(
    uint80 _roundId,
    int256 _answer,
    uint256 _timestamp,
    uint256 _startedAt
  ) public {
    latestRound = _roundId;
    latestAnswer = _answer;
    latestTimestamp = _timestamp;
    getAnswer[latestRound] = _answer;
    getTimestamp[latestRound] = _timestamp;
    getStartedAt[latestRound] = _startedAt;
  }

  function getRoundData(uint80 _roundId)
    external
    view
    override
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    )
  {
    return (
      _roundId,
      getAnswer[_roundId],
      getStartedAt[_roundId],
      getTimestamp[_roundId],
      _roundId
    );
  }

  function latestRoundData()
    external
    view
    override
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    )
  {
    return (
      uint80(latestRound),
      getAnswer[latestRound],
      getStartedAt[latestRound],
      getTimestamp[latestRound],
      uint80(latestRound)
    );
  }

  function description()
    external
    view
    override
    returns (string memory)
  {
    return ""v0.6/tests/MockV3Aggregator.sol"";
  }
}",612
RealWorld_BA_56_VaultAdapterMock_RealWord_20240821165658.log,56,VaultAdapterMock,6250,4977,11227,84.0,0.13079,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.6.12;

import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import ""../interfaces/IVaultAdapter.sol"";

contract VaultAdapterMock is IVaultAdapter {
  using SafeERC20 for IDetailedERC20;

  IDetailedERC20 private _token;

  constructor(IDetailedERC20 token_) public {
    _token = token_;
  }

  function token() external view override returns (IDetailedERC20) {
    return _token;
  }

  function totalValue() external view override returns (uint256) {
    return _token.balanceOf(address(this));
  }

  function deposit(uint256 _amount) external override { }

  function withdraw(address _recipient, uint256 _amount) external override {
    _token.safeTransfer(_recipient, _amount);
  }
}",187
RealWorld_BA_56_IDetailedERC20_RealWord_20240821172019.log,56,IDetailedERC20,4429,4613,9042,77.0,0.114405,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IDetailedERC20 is IERC20 {
  function name() external returns (string memory);
  function symbol() external returns (string memory);
  function decimals() external returns (uint8);
}",78
RealWorld_BA_56_Vault_RealWord_20240821155031.log,56,Vault,35847,5797,41644,87.0,0.295175,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/GSN/Context.sol"";

import ""./interfaces/IManager.sol"";
import ""./interfaces/IController.sol"";
import ""./interfaces/IConverter.sol"";
import ""./interfaces/IVault.sol"";
import ""./interfaces/IVaultToken.sol"";
import ""./interfaces/ExtendedIERC20.sol"";

/**
 * @title Vault
 * @notice The vault is where users deposit and withdraw
 * like-kind assets that have been added by governance.
 */
contract Vault is IVault {
    using Address for address;
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    uint256 public constant MAX = 10000;

    IManager public immutable override manager;
    IERC20 public immutable token;
    IVaultToken public immutable vaultToken;

    // Strategist-updated variables
    address public override gauge;
    uint256 public min;
    uint256 public totalDepositCap;

    event Deposit(address indexed account, uint256 amount);
    event Withdraw(address indexed account, uint256 amount);
    event Earn(address indexed token, uint256 amount);

    /**
     * @param _depositToken The address of the deposit token of the vault
     * @param _vaultToken The address of the share token for the vault
     * @param _manager The address of the vault manager contract
     */
    constructor(
        address _depositToken,
        address _vaultToken,
        address _manager
    )
        public
    {
        manager = IManager(_manager);
        token = IERC20(_depositToken);
        vaultToken = IVaultToken(_vaultToken);
        min = 9500;
        totalDepositCap = 10000000 ether;
    }

    /**
     * STRATEGIST-ONLY FUNCTIONS
     */

    /**
     * @notice Sets the value of this vault's gauge
     * @dev Allow to be unset with the zero address
     * @param _gauge The address of the gauge
     */
    function setGauge(
        address _gauge
    )
        external
        notHalted
        onlyStrategist
    {
        gauge = _gauge;
    }

    /**
     * @notice Sets the value for min
     * @dev min is the minimum percent of funds to keep small withdrawals cheap
     * @param _min The new min value
     */
    function setMin(
        uint256 _min
    )
        external
        notHalted
        onlyStrategist
    {
        require(_min <= MAX, ""!_min"");
        min = _min;
    }

    /**
     * @notice Sets the value for the totalDepositCap
     * @dev totalDepositCap is the maximum amount of value that can be deposited
     * to the metavault at a time
     * @param _totalDepositCap The new totalDepositCap value
     */
    function setTotalDepositCap(
        uint256 _totalDepositCap
    )
        external
        notHalted
        onlyStrategist
    {
        totalDepositCap = _totalDepositCap;
    }

    /**
     * HARVESTER-ONLY FUNCTIONS
     */

    /**
     * @notice Sends accrued 3CRV tokens on the metavault to the controller to be deposited to strategies
     */
    function earn(
        address _strategy
    )
        external
        override
        notHalted
        onlyHarvester
    {
        require(manager.allowedStrategies(_strategy), ""!_strategy"");
        IController _controller = IController(manager.controllers(address(this)));
        if (_controller.investEnabled()) {
            uint256 _balance = available();
            token.safeTransfer(address(_controller), _balance);
            _controller.earn(_strategy, address(token), _balance);
            emit Earn(address(token), _balance);
        }
    }

    /**
     * USER-FACING FUNCTIONS
     */

    /**
     * @notice Deposits the given token into the vault
     * @param _amount The amount of tokens to deposit
     */
     function deposit(
        uint256 _amount
     )
        public
        override
        notHalted
        returns (uint256 _shares)
    {
        require(_amount > 0, ""!_amount"");

        uint256 _balance = balance();

        uint256 _before = token.balanceOf(address(this));
        token.safeTransferFrom(msg.sender, address(this), _amount);
        _amount = token.balanceOf(address(this)).sub(_before);
        uint256 _supply = IERC20(address(vaultToken)).totalSupply();

        _amount = _normalizeDecimals(_amount);

        if (_supply > 0) {
            _amount = (_amount.mul(_supply)).div(_balance);
        }

        _shares = _amount;

        require(_shares > 0, ""shares=0"");
        require(_supply.add(_shares) <= totalDepositCap, "">totalDepositCap"");
        vaultToken.mint(msg.sender, _shares);
        emit Deposit(msg.sender, _shares);
    }

    /**
     * @notice Withdraws an amount of shares to a given output token
     * @param _shares The amount of shares to withdraw
     */
    function withdraw(
        uint256 _shares
    )
        public
        override
    {
        uint256 _amount = (balance().mul(_shares)).div(IERC20(address(vaultToken)).totalSupply());
        vaultToken.burn(msg.sender, _shares);

        uint256 _withdrawalProtectionFee = manager.withdrawalProtectionFee();
        if (_withdrawalProtectionFee > 0) {
            uint256 _withdrawalProtection = _amount.mul(_withdrawalProtectionFee).div(MAX);
            _amount = _amount.sub(_withdrawalProtection);
        }

        uint256 _balance = token.balanceOf(address(this));
        if (_balance < _amount) {
            IController _controller = IController(manager.controllers(address(this)));
            uint256 _toWithdraw = _amount.sub(_balance);
            if (_controller.strategies() > 0) {
                _controller.withdraw(address(token), _toWithdraw);
            }
            uint256 _after = token.balanceOf(address(this));
            uint256 _diff = _after.sub(_balance);
            if (_diff < _toWithdraw) {
                _amount = _after;
            }
        }

        token.safeTransfer(msg.sender, _amount);
        emit Withdraw(msg.sender, _amount);
    }

    /**
     * @notice Withdraw the entire balance for an account
     */
    function withdrawAll()
        external
        override
    {
        withdraw(IERC20(address(vaultToken)).balanceOf(msg.sender));
    }

    /**
     * VIEWS
     */

    /**
     * @notice Returns the amount of tokens available to be sent to strategies
     * @dev Custom logic in here for how much the vault allows to be borrowed
     * @dev Sets minimum required on-hand to keep small withdrawals cheap
     */
    function available()
        public
        view
        override
        returns (uint256)
    {
        return token.balanceOf(address(this)).mul(min).div(MAX);
    }

    /**
     * @notice Returns the total balance of the vault, including strategies
     */
    function balance()
        public
        view
        override
        returns (uint256 _balance)
    {
        return balanceOfThis().add(IController(manager.controllers(address(this))).balanceOf());
    }

    /**
     * @notice Returns the balance of allowed tokens present on the vault only
     */
    function balanceOfThis()
        public
        view
        returns (uint256)
    {
        return _normalizeDecimals(token.balanceOf(address(this)));
    }

    /**
     * @notice Returns the rate of vault shares
     */
    function getPricePerFullShare()
        external
        view
        override
        returns (uint256)
    {
        uint256 _supply = IERC20(address(vaultToken)).totalSupply();
        if (_supply > 0) {
            return balance().mul(1e18).div(_supply);
        } else {
            return balance();
        }
    }

    /**
     * @notice Returns the deposit token for the vault
     */
    function getToken()
        public
        view
        override
        returns (address)
    {
        return address(token);
    }

    function getLPToken()
        external
        view
        override
        returns (address)
    {
        return address(vaultToken);
    }

    /**
     * @notice Returns the fee for withdrawing the given amount
     * @param _amount The amount to withdraw
     */
    function withdrawFee(
        uint256 _amount
    )
        external
        view
        override
        returns (uint256)
    {
        return manager.withdrawalProtectionFee().mul(_amount).div(MAX);
    }

    function _normalizeDecimals(
        uint256 _amount
    )
        internal
        view
        returns (uint256)
    {
        uint256 _decimals = uint256(ExtendedIERC20(address(token)).decimals());
        if (_decimals < 18) {
            _amount = _amount.mul(10**(18-_decimals));
        }
        return _amount;
    }

    /**
     * MODIFIERS
     */

    modifier notHalted() {
        require(!manager.halted(), ""halted"");
        _;
    }

    modifier onlyHarvester() {
        require(msg.sender == manager.harvester(), ""!harvester"");
        _;
    }

    modifier onlyStrategist() {
        require(msg.sender == manager.strategist(), ""!strategist"");
        _;
    }
}",2071
RealWorld_BA_56_MockConvexBaseRewardPool_RealWord_20240821160849.log,56,MockConvexBaseRewardPool,7114,4252,11366,81.0,0.12061,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/utils/Address.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';

contract MockConvexBaseRewardPool {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    IERC20 public rewardToken;

    uint256 public pid;
    uint256 public extraRewardsLength;

    constructor(
        uint256 pid_,
        address, /*stakingToken_*/
        address rewardToken_,
        address, /*operator_*/
        address /*rewardManager_*/
    ) public {
        pid = pid_;
        rewardToken = IERC20(rewardToken_);
        extraRewardsLength = 0;
    }

    function stakeFor(
        address, /*_for*/
        uint256 /*_amount*/
    ) public pure returns (bool) {
        return true;
    }

    function getReward(
        address _account,
        bool /*_claimExtras*/
    ) public returns (bool) {
        IERC20(rewardToken).safeTransferFrom(address(this), _account, 1000);
        return true;
    }
}",277
RealWorld_BA_56_IERC677_RealWord_20240821151154.log,56,IERC677,3902,4137,8039,70.0,0.10225,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IERC677 is IERC20 {
    function transferAndCall(address, address, uint256, bytes calldata) external returns (bool);
}",64
RealWorld_BA_56_MockCurveGauge_RealWord_20240821151306.log,56,MockCurveGauge,7482,6060,13542,86.0,0.15861,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import ""../interfaces/Gauge.sol"";

contract MockCurveGauge is Gauge {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    IERC20 want;

    mapping(address => uint) public amounts;

    constructor(IERC20 _want) public {
        want = _want;
    }

    function deposit(uint _amount) external override {
        want.safeTransferFrom(msg.sender, address(this), _amount);
        amounts[msg.sender] = amounts[msg.sender].add(_amount);
    }

    function balanceOf(address _account) external override view returns (uint) {
        return amounts[_account];
    }

    function claimable_tokens(address _account) external override view returns (uint) {
        return amounts[_account].div(10); // always return 10% of staked
    }

    function withdraw(uint _amount) external override {
        want.safeTransfer(msg.sender, _amount);
        amounts[msg.sender] = amounts[msg.sender].sub(_amount);
    }
}",269
RealWorld_BA_56_ICurveToken_RealWord_20240821171009.log,56,ICurveToken,3472,4572,8044,82.0,0.1088,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.6.12;

interface ICurveToken {
    function get_virtual_price() external view returns (uint256);
}",39
RealWorld_BA_56_YaxisVaultAdapter_RealWord_20240821170829.log,56,YaxisVaultAdapter,16429,4978,21407,97.0,0.181705,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

import 'hardhat/console.sol';

import {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';

import {FixedPointMath} from '../libraries/FixedPointMath.sol';
import {IDetailedERC20} from '../interfaces/IDetailedERC20.sol';
import {IVaultAdapter} from '../interfaces/IVaultAdapter.sol';
import {IVault} from '../../interfaces/IVault.sol';

/// @title YaxisVaultAdapter
///
/// @dev A vault adapter implementation which wraps a yAxis vault.
contract YaxisVaultAdapter is IVaultAdapter {
    using FixedPointMath for FixedPointMath.FixedDecimal;
    using SafeERC20 for IDetailedERC20;
    using SafeMath for uint256;

    /// @dev The vault that the adapter is wrapping.
    IVault public vault;

    /// @dev The address which has admin control over this contract.
    address public admin;

    constructor(IVault _vault, address _admin) public {
        vault = _vault;
        admin = _admin;
        updateApproval();
    }

    /// @dev A modifier which reverts if the caller is not the admin.
    modifier onlyAdmin() {
        require(admin == msg.sender, 'YaxisVaultAdapter: only admin');
        _;
    }

    /// @dev Gets the token that the vault accepts.
    ///
    /// @return the accepted token.
    function token() external view override returns (IDetailedERC20) {
        return IDetailedERC20(vault.getToken());
    }

    /// @dev Gets the total value of the assets that the adapter holds in the vault.
    ///
    /// @return the total assets.
    function totalValue() external view override returns (uint256) {
        return _sharesToTokens(IDetailedERC20(vault.getLPToken()).balanceOf(address(this)));
    }

    /// @dev Deposits tokens into the vault.
    ///
    /// @param _amount the amount of tokens to deposit into the vault.
    function deposit(uint256 _amount) external override {
        vault.deposit(_amount);
    }

    /// @dev Withdraws tokens from the vault to the recipient.
    ///
    /// This function reverts if the caller is not the admin.
    ///
    /// @param _recipient the account to withdraw the tokes to.
    /// @param _amount    the amount of tokens to withdraw.
    function withdraw(address _recipient, uint256 _amount) external override onlyAdmin {
        vault.withdraw(_tokensToShares(_amount));
        address _token = vault.getToken();
        IDetailedERC20(_token).safeTransfer(_recipient, _amount);
    }

    /// @dev Updates the vaults approval of the token to be the maximum value.
    function updateApproval() public {
        address _token = vault.getToken();
        IDetailedERC20(_token).safeApprove(address(vault), uint256(-1));
    }

    /// @dev Computes the number of tokens an amount of shares is worth.
    ///
    /// @param _sharesAmount the amount of shares.
    ///
    /// @return the number of tokens the shares are worth.

    function _sharesToTokens(uint256 _sharesAmount) internal view returns (uint256) {
        return _sharesAmount.mul(vault.getPricePerFullShare()).div(1e18);
    }

    /// @dev Computes the number of shares an amount of tokens is worth.
    ///
    /// @param _tokensAmount the amount of shares.
    ///
    /// @return the number of shares the tokens are worth.
    function _tokensToShares(uint256 _tokensAmount) internal view returns (uint256) {
        return _tokensAmount.mul(1e18).div(vault.getPricePerFullShare());
    }
}",820
RealWorld_BA_56_Yfii_RealWord_20240821174331.log,56,Yfii,4035,4715,8750,78.0,0.114475,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface Yfii {
    function withdraw(uint) external;
    function getReward() external;
    function stake(uint) external;
    function balanceOf(address) external view returns (uint);
    function exit() external;
}",61
RealWorld_BA_56_IVault_RealWord_20240821162656.log,56,IVault,5826,5124,10950,97.0,0.13161,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""./IManager.sol"";

interface IVault {
    function available() external view returns (uint256);
    function balance() external view returns (uint256);
    function deposit(uint256 _amount) external returns (uint256);
    function earn(address _strategy) external;
    function gauge() external returns (address);
    function getLPToken() external view returns (address);
    function getPricePerFullShare() external view returns (uint256);
    function getToken() external view returns (address);
    function manager() external view returns (IManager);
    function withdraw(uint256 _amount) external;
    function withdrawAll() external;
    function withdrawFee(uint256 _amount) external view returns (uint256);
}",162
RealWorld_BA_56_ITransmuter_RealWord_20240821172138.log,56,ITransmuter,3658,4322,7980,72.0,0.10473,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.6.12;

interface ITransmuter  {
  function distribute (address origin, uint256 amount) external;
}",41
RealWorld_BA_56_IStableSwap2Pool_RealWord_20240821161956.log,56,IStableSwap2Pool,7277,5313,12590,86.0,0.142645,"// SPDX-License-Identifier: MIT
// solhint-disable func-name-mixedcase
// solhint-disable var-name-mixedcase

pragma solidity 0.6.12;

interface IStableSwap2Pool {
    function get_virtual_price() external view returns (uint256);

    function balances(uint256) external view returns (uint256);

    function get_dy(
        int128 i,
        int128 j,
        uint256 dx
    ) external view returns (uint256 dy);

    function exchange(
        int128 i,
        int128 j,
        uint256 dx,
        uint256 min_dy
    ) external;

    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount) external;

    function remove_liquidity(uint256 _amount, uint256[2] calldata amounts) external;

    function remove_liquidity_one_coin(
        uint256 _token_amount,
        int128 i,
        uint256 min_amount
    ) external;

    function calc_token_amount(uint256[2] calldata amounts, bool deposit)
        external
        view
        returns (uint256);

    function calc_withdraw_one_coin(uint256 _token_amount, int128 i)
        external
        view
        returns (uint256);
}",265
RealWorld_BA_56_IChainlink_RealWord_20240821171904.log,56,IChainlink,3661,3984,7645,73.0,0.097985,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.6.12;

interface IChainlink {
  function latestAnswer() external view returns (int256);
}",38
RealWorld_BA_56_IMerkleDistributor_RealWord_20240821151045.log,56,IMerkleDistributor,6212,4516,10728,67.0,0.12138,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.6.0;

// Allows anyone to claim a token if they exist in a merkle root.
interface IMerkleDistributor {
    // Returns the address of the token distributed by this contract.
    function token() external view returns (address);
    // Returns the merkle root of the merkle tree containing account balances available to claim.
    function merkleRoot() external view returns (bytes32);
    // Returns true if the index has been marked claimed.
    function isClaimed(uint256 index) external view returns (bool);
    // Claim the given amount of the token to the given address. Reverts if the inputs are invalid.
    function claim(uint256 index, address account, uint256 amount, bytes32[] calldata merkleProof) external;

    // This event is triggered whenever a call to #claim succeeds.
    event Claimed(uint256 index, address account, uint256 amount);
}",200
RealWorld_BA_56_AlchemistVault_RealWord_20240821170308.log,56,AlchemistVault,24967,5203,30170,116.0,0.228895,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.6.12;

//import ""hardhat/console.sol"";

import {Math} from '@openzeppelin/contracts/math/Math.sol';
import {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';
import {IDetailedERC20} from '../../interfaces/IDetailedERC20.sol';
import {IVaultAdapter} from '../../interfaces/IVaultAdapter.sol';
import 'hardhat/console.sol';

/// @title Pool
///
/// @dev A library which provides the AlchemistVault data struct and associated functions.
library AlchemistVault {
    using AlchemistVault for Data;
    using AlchemistVault for List;
    using SafeERC20 for IDetailedERC20;
    using SafeMath for uint256;

    struct Data {
        IVaultAdapter adapter;
        uint256 totalDeposited;
    }

    struct List {
        Data[] elements;
    }

    /// @dev Gets the total amount of assets deposited in the vault.
    ///
    /// @return the total assets.
    function totalValue(Data storage _self) internal view returns (uint256) {
        return _self.adapter.totalValue();
    }

    /// @dev Gets the token that the vault accepts.
    ///
    /// @return the accepted token.
    function token(Data storage _self) internal view returns (IDetailedERC20) {
        return IDetailedERC20(_self.adapter.token());
    }

    /// @dev Deposits funds from the caller into the vault.
    ///
    /// @param _amount the amount of funds to deposit.
    function deposit(Data storage _self, uint256 _amount) internal returns (uint256) {
        // Push the token that the vault accepts onto the stack to save gas.
        IDetailedERC20 _token = _self.token();

        _token.safeTransfer(address(_self.adapter), _amount);
        _self.adapter.deposit(_amount);
        _self.totalDeposited = _self.totalDeposited.add(_amount);

        return _amount;
    }

    /// @dev Deposits the entire token balance of the caller into the vault.
    function depositAll(Data storage _self) internal returns (uint256) {
        IDetailedERC20 _token = _self.token();
        return _self.deposit(_token.balanceOf(address(this)));
    }

    /// @dev Withdraw deposited funds from the vault.
    ///
    /// @param _recipient the account to withdraw the tokens to.
    /// @param _amount    the amount of tokens to withdraw.
    function withdraw(
        Data storage _self,
        address _recipient,
        uint256 _amount
    ) internal returns (uint256, uint256) {
        (uint256 _withdrawnAmount, uint256 _decreasedValue) = _self.directWithdraw(
            _recipient,
            _amount
        );
        _self.totalDeposited = _self.totalDeposited.sub(_decreasedValue);
        return (_withdrawnAmount, _decreasedValue);
    }

    /// @dev Directly withdraw deposited funds from the vault.
    ///
    /// @param _recipient the account to withdraw the tokens to.
    /// @param _amount    the amount of tokens to withdraw.
    function directWithdraw(
        Data storage _self,
        address _recipient,
        uint256 _amount
    ) internal returns (uint256, uint256) {
        IDetailedERC20 _token = _self.token();

        uint256 _startingBalance = _token.balanceOf(_recipient);
        uint256 _startingTotalValue = _self.totalValue();

        _self.adapter.withdraw(_recipient, _amount);

        uint256 _endingBalance = _token.balanceOf(_recipient);
        uint256 _withdrawnAmount = _endingBalance.sub(_startingBalance);

        uint256 _endingTotalValue = _self.totalValue();
        uint256 _decreasedValue = _startingTotalValue.sub(_endingTotalValue);

        return (_withdrawnAmount, _decreasedValue);
    }

    /// @dev Withdraw all the deposited funds from the vault.
    ///
    /// @param _recipient the account to withdraw the tokens to.
    function withdrawAll(Data storage _self, address _recipient)
        internal
        returns (uint256, uint256)
    {
        return _self.withdraw(_recipient, _self.totalDeposited);
    }

    /// @dev Harvests yield from the vault.
    ///
    /// @param _recipient the account to withdraw the harvested yield to.
    function harvest(Data storage _self, address _recipient)
        internal
        returns (uint256, uint256)
    {
        if (_self.totalValue() <= _self.totalDeposited) {
            return (0, 0);
        }
        uint256 _withdrawAmount = _self.totalValue().sub(_self.totalDeposited);
        return _self.directWithdraw(_recipient, _withdrawAmount);
    }

    /// @dev Adds a element to the list.
    ///
    /// @param _element the element to add.
    function push(List storage _self, Data memory _element) internal {
        _self.elements.push(_element);
    }

    /// @dev Gets a element from the list.
    ///
    /// @param _index the index in the list.
    ///
    /// @return the element at the specified index.
    function get(List storage _self, uint256 _index) internal view returns (Data storage) {
        return _self.elements[_index];
    }

    /// @dev Gets the last element in the list.
    ///
    /// This function will revert if there are no elements in the list.
    ///
    /// @return the last element in the list.
    function last(List storage _self) internal view returns (Data storage) {
        return _self.elements[_self.lastIndex()];
    }

    /// @dev Gets the index of the last element in the list.
    ///
    /// This function will revert if there are no elements in the list.
    ///
    /// @return the index of the last element.
    function lastIndex(List storage _self) internal view returns (uint256) {
        uint256 _length = _self.length();
        return _length.sub(1, 'AlchemistVault.List: empty');
    }

    /// @dev Gets the number of elements in the list.
    ///
    /// @return the number of elements.
    function length(List storage _self) internal view returns (uint256) {
        return _self.elements.length;
    }
}",1370
RealWorld_BA_56_YaxisToken_RealWord_20240821150417.log,56,YaxisToken,12799,5140,17939,75.0,0.166795,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""../vendor/LinkToken/token/LinkERC20.sol"";
import ""../vendor/LinkToken/ERC677Token.sol"";

/**
 * @notice yAxis Token
 * @dev Contract has been copied from:
 * https://github.com/smartcontractkit/LinkToken/blob/master/contracts/v0.6/LinkToken.sol
 * with modifications only made to TOTAL_SUPPLY, NAME, SYMBOL, and the validAddress
 * modifier's revert message.
 */
contract YaxisToken is LinkERC20, ERC677Token {
    uint256 private constant TOTAL_SUPPLY = 11*10**24;
    string private constant NAME = ""yAxis V2"";
    string private constant SYMBOL = ""YAXIS"";

    constructor()
        public
        ERC20(NAME, SYMBOL)
    {
        _onCreate();
    }

    /**
     * @dev Hook that is called when this contract is created.
     * Useful to override constructor behaviour in child contracts (e.g., LINK bridge tokens).
     * @notice Default implementation mints 10**27 tokens to msg.sender
     */
    function _onCreate()
        internal
        virtual
    {
        _mint(msg.sender, TOTAL_SUPPLY);
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount)
        internal
        override
        virtual
        validAddress(recipient)
    {
        super._transfer(sender, recipient, amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount)
        internal
        override
        virtual
        validAddress(spender)
    {
        super._approve(owner, spender, amount);
    }


    // MODIFIERS

    modifier validAddress(address _recipient) {
        require(_recipient != address(this), ""!validAddress"");
        _;
    }
}",598
RealWorld_BA_56_IVaultAdapter_RealWord_20240821172252.log,56,IVaultAdapter,6436,4412,10848,88.0,0.12042,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./IDetailedERC20.sol"";

/// Interface for all Vault Adapter implementations.
interface IVaultAdapter {

  /// @dev Gets the token that the adapter accepts.
  function token() external view returns (IDetailedERC20);

  /// @dev The total value of the assets deposited into the vault.
  function totalValue() external view returns (uint256);

  /// @dev Deposits funds into the vault.
  ///
  /// @param _amount  the amount of funds to deposit.
  function deposit(uint256 _amount) external;

  /// @dev Attempts to withdraw funds from the wrapped vault.
  ///
  /// The amount withdrawn to the recipient may be less than the amount requested.
  ///
  /// @param _recipient the recipient of the funds.
  /// @param _amount    the amount of funds to withdraw.
  function withdraw(address _recipient, uint256 _amount) external;
}",221
RealWorld_BA_56_ICurve2Pool_RealWord_20240821164552.log,56,ICurve2Pool,5463,5136,10599,127.0,0.130035,"// SPDX-License-Identifier: MIT
// solhint-disable func-name-mixedcase
// solhint-disable var-name-mixedcase

pragma solidity 0.6.12;

interface ICurve2Pool {
    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount) external;

    function remove_liquidity(uint256 _amount, uint256[2] calldata amounts) external;

    function calc_token_amount(uint256[2] calldata amounts, bool deposit)
        external
        view
        returns (uint256);
}",118
RealWorld_BA_56_VaultHelper_RealWord_20240821155506.log,56,VaultHelper,13624,5163,18787,80.0,0.17138,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import ""./interfaces/ILiquidityGaugeV2.sol"";
import ""./interfaces/IVault.sol"";

/**
 * @title VaultHelper
 * @notice The VaultHelper acts as a single contract that users may set
 * token approvals on for any token of any vault.
 * @dev This contract has no state and could be deployed by anyone if
 * they didn't trust the original deployer.
 */
contract VaultHelper {
    using SafeERC20 for IERC20;

    /**
     * @notice Deposits into the specified vault and stakes in the gauge
     * @dev Users must approve the vault helper to spend their token
     * @param _vault The address of the vault
     * @param _amount The amount of tokens to deposit
     */
    function depositVault(
        address _vault,
        uint256 _amount
    )
        external
    {
        require(_amount > 0, ""!_amount"");
        address _token = IVault(_vault).getToken();
        address _vaultToken = IVault(_vault).getLPToken();
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);
        IERC20(_token).safeApprove(_vault, 0);
        IERC20(_token).safeApprove(_vault, _amount);
        uint256 _shares = IVault(_vault).deposit(_amount);
        address _gauge = IVault(_vault).gauge();
        if (_gauge != address(0)) {
            IERC20(_vaultToken).safeApprove(_gauge, 0);
            IERC20(_vaultToken).safeApprove(_gauge, _shares);
            ILiquidityGaugeV2(_gauge).deposit(_shares);
            IERC20(_gauge).safeTransfer(msg.sender, _shares);
        } else {
            IERC20(_vaultToken).safeTransfer(msg.sender, _shares);
        }
    }

    function withdrawVault(
        address _vault,
        uint256 _amount
    )
        external
    {
        address _gauge = IVault(_vault).gauge();
        address _token = IVault(_vault).getToken();
        address _vaultToken = IVault(_vault).getLPToken();
        if (_gauge != address(0)) {
            IERC20(_gauge).safeTransferFrom(msg.sender, address(this), _amount);
            ILiquidityGaugeV2(_gauge).withdraw(_amount);
            IVault(_vault).withdraw(IERC20(_vaultToken).balanceOf(address(this)));
            IERC20(_token).safeTransfer(msg.sender, IERC20(_token).balanceOf(address(this)));
        } else {
            IERC20(_vaultToken).safeTransferFrom(msg.sender, address(this), _amount);
            IVault(_vault).withdraw(_amount);
            IERC20(_token).safeTransfer(msg.sender, IERC20(_token).balanceOf(address(this)));
        }
    }
}",668
RealWorld_BA_56_ERC20Mock_RealWord_20240821165824.log,56,ERC20Mock,5978,4879,10857,86.0,0.12747,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

import {ERC20} from ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

/// @title ERC20Mock
///
/// @dev A mock of an ERC20 token which lets anyone burn and mint tokens.
contract ERC20Mock is ERC20 {

  constructor(string memory _name, string memory _symbol, uint8 _decimals) public ERC20(_name, _symbol) {
    _setupDecimals(_decimals);
  }

  function mint(address _recipient, uint256 _amount) external {
    _mint(_recipient, _amount);
  }

  function burn(address _account, uint256 _amount) external {
    _burn(_account, _amount);
  }
}",173
RealWorld_BA_56_Curve_RealWord_20240821180055.log,56,Curve,5450,4799,10249,95.0,0.12323,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface ICurveFi {
  function get_virtual_price() external view returns (uint);
  function add_liquidity(
    uint256[4] calldata amounts,
    uint256 min_mint_amount
  ) external;
  function remove_liquidity_imbalance(
    uint256[4] calldata amounts,
    uint256 max_burn_amount
  ) external;
  function remove_liquidity(
    uint256 _amount,
    uint256[4] calldata amounts
  ) external;
  function exchange(
    int128 from, int128 to, uint256 _from_amount, uint256 _min_to_amount
  ) external;
}",151
RealWorld_BA_56_LegacyController_RealWord_20240821161653.log,56,LegacyController,28576,6193,34769,105.0,0.26674,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import ""../interfaces/IController.sol"";
import ""../interfaces/IConverter.sol"";
import ""../interfaces/ILegacyController.sol"";
import ""../interfaces/ILegacyVault.sol"";
import ""../interfaces/IManager.sol"";
import ""../interfaces/IVault.sol"";

contract LegacyController is ILegacyController {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    uint256 public constant MAX = 10000;

    IManager public immutable manager;
    IERC20 public immutable token;
    address public immutable metavault;

    bool public investEnabled;
    IVault public vault;
    IConverter public converter;

    event Earn(uint256 amount);
    event Withdraw(uint256 amount);

    /**
     * @param _manager The vault manager contract
     * @param _metavault The legacy MetaVault contract
     */
    constructor(
        address _manager,
        address _metavault
    )
        public
    {
        manager = IManager(_manager);
        metavault = _metavault;
        address _token = ILegacyVault(_metavault).want();
        token = IERC20(_token);
    }

    /**
     * @notice Sets the vault address
     * @param _vault The v3 vault address
     */
    function setVault(
        address _vault
    )
        external
        onlyStrategist
    {
        IVault cachedVault = vault;
        if (address(cachedVault) != address(0)) {
            cachedVault.withdrawAll();
            token.safeTransfer(metavault, token.balanceOf(address(this)));
        }
        vault = IVault(_vault);
    }

    /**
     * @notice Sets the converter address
     * @param _converter The address of the converter
     */
    function setConverter(
        address _converter
    )
        external
        onlyStrategist
    {
        converter = IConverter(_converter);
    }

    /**
     * @notice Sets the investEnabled status flag
     * @param _investEnabled Bool for enabling investment
     */
    function setInvestEnabled(
        bool _investEnabled
    )
        external
        onlyStrategist
    {
        investEnabled = _investEnabled;
    }

    /**
     * @notice Recovers stuck tokens sent directly to this contract
     * @dev This only allows the strategist to recover unsupported tokens
     * @param _token The address of the token
     * @param _receiver The address to receive the tokens
     */
    function recoverUnsupportedToken(
        address _token,
        address _receiver
    )
        external
        onlyStrategist
    {
        require(_token != address(token), ""!_token"");
        IERC20(_token).safeTransfer(_receiver, IERC20(_token).balanceOf(address(this)));
    }

    /**
     * @notice Returns the balance of the given token on the vault
     */
    function balanceOf(
        address
    )
        external
        view
        returns (uint256)
    {
        return token.balanceOf(address(this))
                    .add(IERC20(vault.getLPToken()).balanceOf(address(this)));
    }

    /**
     * @notice Returns the withdraw fee for withdrawing the given token and amount
     * @param _amount The amount to withdraw
     */
    function withdrawFee(
        address ,
        uint256 _amount
    )
        external
        view
        returns (uint256)
    {
        return manager.withdrawalProtectionFee().mul(_amount).div(MAX);
    }

    /**
     * @notice Withdraws the amount from the v3 vault
     * @param _amount The amount to withdraw
     */
    function withdraw(
        address,
        uint256 _amount
    )
        external
        onlyEnabledVault
        onlyMetaVault
    {
        uint256 _balance = token.balanceOf(address(this));
        // happy path exits without calling back to the vault
        if (_balance >= _amount) {
            token.safeTransfer(metavault, _amount);
            emit Withdraw(_amount);
        } else {
            uint256 _toWithdraw = _amount.sub(_balance);
            IVault cachedVault = vault;
            // convert to vault shares
            address _token = cachedVault.getToken();
            // get the amount of the token that we would be withdrawing
            uint256 _expected = converter.expected(address(token), _token, _toWithdraw);
            uint256 _shares = _expected.mul(1e18).div(cachedVault.getPricePerFullShare());
            cachedVault.withdraw(_shares);
            _balance = IERC20(_token).balanceOf(address(this));
            IERC20(_token).safeTransfer(address(converter), _balance);
            // TODO: calculate expected
            converter.convert(_token, address(token), _balance, 1);
            emit Withdraw(token.balanceOf(address(this)));
            token.safeTransfer(metavault, token.balanceOf(address(this)));
        }
    }

    /**
     * @notice Only emits the Earn event
     * @dev This is a dummy function to allow the MetaVault to call
     * @param _amount The amount to earn
     */
    function earn(
        address,
        uint256 _amount
    )
        external
        onlyMetaVault
    {
        emit Earn(_amount);
    }

    /**
     * @notice Deposits the given token to the v3 vault
     * @param _expected The expected amount to deposit after conversion
     */
    function legacyDeposit(
        uint256 _expected
    )
        external
        override
        onlyEnabledConverter
        onlyHarvester
    {
        address _token = vault.getToken();
        uint256 _amount = token.balanceOf(address(this));
        token.safeTransfer(address(converter), _amount);
        converter.convert(address(token), _token, _amount, _expected);
        IERC20(_token).safeApprove(address(vault), 0);
        IERC20(_token).safeApprove(address(vault), type(uint256).max);
        vault.deposit(IERC20(_token).balanceOf(address(this)));
    }

    /**
     * @notice Reverts if the converter is not set
     */
    modifier onlyEnabledConverter() {
        require(address(converter) != address(0), ""!converter"");
        _;
    }

    /**
     * @notice Reverts if the vault is not set
     */
    modifier onlyEnabledVault() {
        require(address(vault) != address(0), ""!vault"");
        _;
    }

    /**
     * @notice Reverts if the caller is not the harvester
     */
    modifier onlyHarvester() {
        require(msg.sender == manager.harvester(), ""!harvester"");
        _;
    }

    /**
     * @notice Reverts if the caller is not the MetaVault
     */
    modifier onlyMetaVault() {
        require(msg.sender == metavault, ""!metavault"");
        _;
    }

    /**
     * @notice Reverts if the caller is not the strategist
     */
    modifier onlyStrategist() {
        require(msg.sender == manager.strategist(), ""!strategist"");
        _;
    }
}",1551
RealWorld_BA_56_IVoteProxy_RealWord_20240821172706.log,56,IVoteProxy,3956,3983,7939,63.0,0.09944,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

interface IVoteProxy {
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint256);
    function balanceOf(address _voter) external view returns (uint256);
}",61
RealWorld_BA_56_MockYearnV2_RealWord_20240821152823.log,56,MockYearnV2,10077,5082,15159,76.0,0.152025,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

contract MockYearnV2 is ERC20 {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    IERC20 public underlying;

    constructor(string memory name, string memory symbol, IERC20 _underlying) public ERC20(name, symbol) {
        underlying = _underlying;
    }

    function balance() public view returns (uint256) {
        return underlying.balanceOf(address(this));
    }

    function pricePerShare() public view returns (uint256) {
        return balance().mul(1e18).div(totalSupply());
    }

    function deposit() external returns (uint256) {
        uint256 _balance = underlying.balanceOf(msg.sender);
        return deposit(_balance);
    }

    function deposit(uint256 _amount) public returns (uint256) {
        uint256 underlyingTotal = balance();
        uint256 _before = balance();
        underlying.safeTransferFrom(msg.sender, address(this), _amount);
        uint256 _after = balance();
        _amount = _after.sub(_before);
        uint256 shares;
        if (totalSupply() == 0) {
            shares = _amount;
        } else {
            shares = (_amount.mul(totalSupply())).div(underlyingTotal);
        }
        _mint(msg.sender, shares);
        return shares;
    }

    function withdraw() external {
        withdraw(balanceOf(msg.sender));
    }

    function withdraw(uint256 _amount) public {
        uint256 ret = (balance().mul(_amount)).div(totalSupply());
        _burn(msg.sender, _amount);
        underlying.safeTransfer(msg.sender, ret);
    }

    function token() external view returns (address) {
        return address(underlying);
    }
}",433
RealWorld_BA_56_GenericVault_RealWord_20240821175756.log,56,GenericVault,4376,5070,9446,94.0,0.12328,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

interface IGenericVault {
    function token() external view returns (address);
    function getPricePerFullShare() external view returns (uint256);
    function deposit(uint256) external;
    function withdraw(uint256) external;
    function depositAll() external;
    function withdrawAll() external;
}",76
RealWorld_BA_56_IConverter_RealWord_20240821154057.log,56,IConverter,6781,4886,11667,83.0,0.131625,"// SPDX-License-Identifier: MIT
// solhint-disable func-name-mixedcase
// solhint-disable var-name-mixedcase

pragma solidity 0.6.12;

interface IConverter {
    function token() external view returns (address _share);
    function convert(
        address _input,
        address _output,
        uint _inputAmount
    ) external returns (uint _outputAmount);
    function convert_rate(
        address _input,
        address _output,
        uint _inputAmount
    ) external view returns (uint _outputAmount);
    function convert_stables(
        uint[3] calldata amounts
    ) external returns (uint _shareAmount); // 0: DAI, 1: USDC, 2: USDT
    function calc_token_amount(
        uint[3] calldata amounts,
        bool deposit
    ) external view returns (uint _shareAmount);
    function calc_token_amount_withdraw(
        uint _shares,
        address _output
    ) external view returns (uint _outputAmount);
    function setStrategy(address _strategy, bool _status) external;
}",232
RealWorld_BA_56_MockIdleToken_RealWord_20240821152941.log,56,MockIdleToken,9847,5393,15240,77.0,0.157095,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""../interfaces/Idle.sol"";

contract MockIdleToken is ERC20, IIdleTokenV3_1 {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    address public override token;
    IERC20 public rewardToken;
    IERC20 public govToken;

    constructor(
        string memory _name,
        string memory _symbol,
        address _underlyingAsset,
        address _rewardToken,
        address _govToken
    )
        public
        ERC20(_name, _symbol)
    {
        token = _underlyingAsset;
        rewardToken = ERC20(_rewardToken);
        govToken = ERC20(_govToken);
    }

    function mintIdleToken(uint256 _amount, bool, address) external override returns (uint256 mintedTokens) {
        mintedTokens = _amount.mul(1e18).div(tokenPrice());
        IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);
        _mint(msg.sender, mintedTokens);
    }

    function redeemIdleToken(uint256 _amount) external override returns (uint256 redeemedTokens) {
        uint256 price = tokenPrice();
        redeemedTokens = _amount.mul(price).div(1e18);
        _burn(msg.sender, _amount);
        rewardToken.safeTransfer(msg.sender, 10e18);
        govToken.safeTransfer(msg.sender, 5e18);
        IERC20(token).safeTransfer(msg.sender, redeemedTokens);
    }

    function tokenPrice() public view override returns (uint256) {
        return 2e18; // 1 idleDAI = 2 DAI
    }
}",424
RealWorld_BA_56_ERC677_RealWord_20240821173756.log,56,ERC677,4285,4174,8459,88.0,0.104905,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

abstract contract ERC677 is IERC20 {
  function transferAndCall(address to, uint value, bytes memory data) public virtual returns (bool success);

  event Transfer(address indexed from, address indexed to, uint value, bytes data);
}",82
RealWorld_BA_56_IERC20Burnable_RealWord_20240821171133.log,56,IERC20Burnable,4240,4077,8317,73.0,0.10274,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.6.8;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IERC20Burnable is IERC20 {
  function burn(uint256 amount) external;
  function burnFrom(address account, uint256 amount) external;
}",71
RealWorld_BA_56_IYaxisBar_RealWord_20240821173236.log,56,IYaxisBar,3826,3818,7644,67.0,0.09549,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IYaxisBar is IERC20 {
    function availableBalance() external view returns (uint256);
}",56
RealWorld_BA_56_IMintableERC20_RealWord_20240821171735.log,56,IMintableERC20,4468,4702,9170,87.0,0.11638,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.6.12;


import {IDetailedERC20} from ""./IDetailedERC20.sol"";

interface IMintableERC20 is IDetailedERC20{
  function mint(address _recipient, uint256 _amount) external;
  function burnFrom(address account, uint256 amount) external;
  function lowerHasMinted(uint256 amount)external;
}",88
RealWorld_BA_56_MockConvexVault_RealWord_20240821161012.log,56,MockConvexVault,20370,5607,25977,85.0,0.21399,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
import '@openzeppelin/contracts/utils/Address.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';

import '../../mock/MockERC20.sol';
import './MockConvexBaseRewardPool.sol';

contract MockConvexVault {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    address public immutable crv;
    address public immutable cvx;

    address public owner;
    address public immutable staker;
    address public immutable minter;

    struct PoolInfo {
        address lptoken;
        address token;
        address gauge;
        address crvRewards;
        address stash;
        bool shutdown;
    }

    //index(pid) -> pool
    PoolInfo[] public poolInfo;

    event Deposited(address indexed user, uint256 indexed poolid, uint256 amount);
    event Withdrawn(address indexed user, uint256 indexed poolid, uint256 amount);

    constructor(
        address _staker,
        address _minter,
        address _crv,
        address _cvx
    ) public {
        staker = _staker;
        owner = msg.sender;
        minter = _minter;
        crv = _crv;
        cvx = _cvx;
    }

    function poolLength() external view returns (uint256) {
        return poolInfo.length;
    }

    //create a new pool
    function addPool(
        address _lptoken,
        address _gauge,
        uint256 /*_stashVersion*/
    ) external returns (bool) {
        //the next pool's pid
        uint256 pid = poolInfo.length;

        //create a tokenized deposit
        MockERC20 token = new MockERC20(
            string(abi.encodePacked(ERC20(_lptoken).name(), ' Convex Deposit')),
            string(abi.encodePacked('cvx', ERC20(_lptoken).symbol())),
            18
        );

        //create a reward contract for crv rewards
        MockConvexBaseRewardPool newRewardPool = new MockConvexBaseRewardPool(
            pid,
            address(token),
            crv,
            address(this),
            address(this)
        );

        // give some fake generated rewards to reward pool so user can claim
        IERC20(cvx).safeTransferFrom(address(this), address(newRewardPool), 10000);

        //add the new pool
        poolInfo.push(
            PoolInfo({
                lptoken: _lptoken,
                token: address(token),
                gauge: _gauge,
                crvRewards: address(newRewardPool),
                stash: address(0),
                shutdown: false
            })
        );
        return true;
    }

    //deposit lp tokens and stake
    function deposit(
        uint256 _pid,
        uint256 _amount,
        bool /*_stake*/
    ) public returns (bool) {
        PoolInfo storage pool = poolInfo[_pid];
        //send to proxy to stake
        address lptoken = pool.lptoken;
        IERC20(lptoken).safeTransferFrom(msg.sender, address(this), _amount);

        address token = pool.token;

        //add user balance directly
        MockERC20(token).mint(msg.sender, _amount);

        emit Deposited(msg.sender, _pid, _amount);
        return true;
    }

    //deposit all lp tokens and stake
    function depositAll(uint256 _pid, bool _stake) external returns (bool) {
        address lptoken = poolInfo[_pid].lptoken;
        uint256 balance = IERC20(lptoken).balanceOf(msg.sender);
        deposit(_pid, balance, _stake);
        return true;
    }

    //withdraw lp tokens
    function _withdraw(
        uint256 _pid,
        uint256 _amount,
        address _from,
        address _to
    ) internal {
        PoolInfo storage pool = poolInfo[_pid];
        address lptoken = pool.lptoken;

        //remove lp balance
        address token = pool.token;
        MockERC20(token).burnFrom(_from, _amount);

        //return lp tokens
        IERC20(lptoken).safeTransfer(_to, _amount);

        emit Withdrawn(_to, _pid, _amount);
    }

    //withdraw lp tokens
    function withdraw(uint256 _pid, uint256 _amount) public returns (bool) {
        _withdraw(_pid, _amount, msg.sender, msg.sender);
        return true;
    }

    //withdraw all lp tokens
    function withdrawAll(uint256 _pid) public returns (bool) {
        address token = poolInfo[_pid].token;
        uint256 userBal = IERC20(token).balanceOf(msg.sender);
        withdraw(_pid, userBal);
        return true;
    }
}",1067
RealWorld_BA_56_ILegacyVault_RealWord_20240821163829.log,56,ILegacyVault,4210,4560,8770,74.0,0.11225,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

interface ILegacyVault {
    function want() external returns (address);
}",32
RealWorld_BA_56_ILiquidityGaugeV2_RealWord_20240821163300.log,56,ILiquidityGaugeV2,3768,3787,7555,65.0,0.09458,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

interface ILiquidityGaugeV2 {
    function set_approve_deposit(address, bool) external;
    function deposit(uint256) external;
    function withdraw(uint256) external;
}",54
RealWorld_BA_56_PickleJar_RealWord_20240821175103.log,56,PickleJar,4583,4548,9131,83.0,0.113875,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

interface PickleJar {
    function balanceOf(address account) external view returns (uint);
    function balance() external view returns (uint);
    function available() external view returns (uint);
    function depositAll() external;
    function deposit(uint _amount) external;
    function withdrawAll() external;
    function withdraw(uint _shares) external;
    function getRatio() external view returns (uint);
}",98
RealWorld_BA_56_IStablesOracle_RealWord_20240821162835.log,56,IStablesOracle,4078,3984,8062,84.0,0.10007,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

interface IStablesOracle {
    function getEthereumPrice() external view returns (uint256);
    function getPrices() external view returns (uint256, uint256);
    function getSafeAnswer(address) external view returns (uint256);
}",67
RealWorld_BA_56_AlToken_RealWord_20240821165136.log,56,AlToken,25764,5726,31490,116.0,0.24334,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

import {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';
import {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';
import {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';

import {IDetailedERC20} from './interfaces/IDetailedERC20.sol';

/// @title AlToken
///
/// @dev This is the contract for the Yaxis utillity token usd.
///
/// Initially, the contract deployer is given both the admin and minter role. This allows them to pre-mine tokens,
/// transfer admin to a timelock contract, and lastly, grant the staking pools the minter role. After this is done,
/// the deployer must revoke their admin role and minter role.
contract AlToken is AccessControl, ERC20('Yaxis USD', 'yalUSD') {
    using SafeERC20 for ERC20;

    /// @dev The identifier of the role which maintains other roles.
    bytes32 public constant ADMIN_ROLE = keccak256('ADMIN');

    /// @dev The identifier of the role which allows accounts to mint tokens.
    bytes32 public constant SENTINEL_ROLE = keccak256('SENTINEL');

    /// @dev addresses whitelisted for minting new tokens
    mapping(address => bool) public whiteList;

    /// @dev addresses blacklisted for minting new tokens
    mapping(address => bool) public blacklist;

    /// @dev addresses paused for minting new tokens
    mapping(address => bool) public paused;

    /// @dev ceiling per address for minting new tokens
    mapping(address => uint256) public ceiling;

    /// @dev already minted amount per address to track the ceiling
    mapping(address => uint256) public hasMinted;

    event Paused(address alchemistAddress, bool isPaused);

    constructor() public {
        _setupRole(ADMIN_ROLE, msg.sender);
        _setupRole(SENTINEL_ROLE, msg.sender);
        _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);
        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
    }

    /// @dev A modifier which checks if whitelisted for minting.
    modifier onlyWhitelisted() {
        require(whiteList[msg.sender], 'AlUSD: Alchemist is not whitelisted');
        _;
    }

    /// @dev Mints tokens to a recipient.
    ///
    /// This function reverts if the caller does not have the minter role.
    ///
    /// @param _recipient the account to mint tokens to.
    /// @param _amount    the amount of tokens to mint.
    function mint(address _recipient, uint256 _amount) external onlyWhitelisted {
        require(!blacklist[msg.sender], 'AlUSD: Alchemist is blacklisted.');
        uint256 _total = _amount.add(hasMinted[msg.sender]);
        require(_total <= ceiling[msg.sender], ""AlUSD: Alchemist's ceiling was breached."");
        require(!paused[msg.sender], 'AlUSD: user is currently paused.');
        hasMinted[msg.sender] = hasMinted[msg.sender].add(_amount);
        _mint(_recipient, _amount);
    }

    /// This function reverts if the caller does not have the admin role.
    ///
    /// @param _toWhitelist the account to mint tokens to.
    /// @param _state the whitelist state.

    function setWhitelist(address _toWhitelist, bool _state) external onlyAdmin {
        whiteList[_toWhitelist] = _state;
    }

    /// This function reverts if the caller does not have the admin role.
    ///
    /// @param _newSentinel the account to set as sentinel.

    function setSentinel(address _newSentinel) external onlyAdmin {
        _setupRole(SENTINEL_ROLE, _newSentinel);
    }

    /// This function reverts if the caller does not have the admin role.
    ///
    /// @param _toBlacklist the account to mint tokens to.
    function setBlacklist(address _toBlacklist) external onlySentinel {
        blacklist[_toBlacklist] = true;
    }

    /// This function reverts if the caller does not have the admin role.
    function pauseAlchemist(address _toPause, bool _state) external onlySentinel {
        paused[_toPause] = _state;
        Paused(_toPause, _state);
    }

    /// This function reverts if the caller does not have the admin role.
    ///
    /// @param _toSetCeiling the account set the ceiling off.
    /// @param _ceiling the max amount of tokens the account is allowed to mint.
    function setCeiling(address _toSetCeiling, uint256 _ceiling) external onlyAdmin {
        ceiling[_toSetCeiling] = _ceiling;
    }

    /// @dev A modifier which checks that the caller has the admin role.
    modifier onlyAdmin() {
        require(hasRole(ADMIN_ROLE, msg.sender), 'only admin');
        _;
    }
    /// @dev A modifier which checks that the caller has the sentinel role.
    modifier onlySentinel() {
        require(hasRole(SENTINEL_ROLE, msg.sender), 'only sentinel');
        _;
    }

    /**
     * @dev Destroys `amount` tokens from the caller.
     *
     * See {ERC20-_burn}.
     */
    function burn(uint256 amount) public virtual {
        _burn(_msgSender(), amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, deducting from the caller's
     * allowance.
     *
     * See {ERC20-_burn} and {ERC20-allowance}.
     *
     * Requirements:
     *
     * - the caller must have allowance for ``accounts``'s tokens of at least
     * `amount`.
     */
    function burnFrom(address account, uint256 amount) public virtual {
        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(
            amount,
            'ERC20: burn amount exceeds allowance'
        );

        _approve(account, _msgSender(), decreasedAllowance);
        _burn(account, amount);
    }

    /**
     * @dev lowers hasminted from the caller's allocation
     *
     */
    function lowerHasMinted(uint256 amount) public onlyWhitelisted {
        hasMinted[msg.sender] = hasMinted[msg.sender].sub(amount);
    }
}",1417
RealWorld_BA_56_FixedPointMath_RealWord_20240821170128.log,56,FixedPointMath,11985,5647,17632,98.0,0.172865,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.6.12;

library FixedPointMath {
  uint256 public constant DECIMALS = 18;
  uint256 public constant SCALAR = 10**DECIMALS;

  struct FixedDecimal {
    uint256 x;
  }

  function fromU256(uint256 value) internal pure returns (FixedDecimal memory) {
    uint256 x;
    require(value == 0 || (x = value * SCALAR) / SCALAR == value);
    return FixedDecimal(x);
  }

  function maximumValue() internal pure returns (FixedDecimal memory) {
    return FixedDecimal(uint256(-1));
  }

  function add(FixedDecimal memory self, FixedDecimal memory value) internal pure returns (FixedDecimal memory) {
    uint256 x;
    require((x = self.x + value.x) >= self.x);
    return FixedDecimal(x);
  }

  function add(FixedDecimal memory self, uint256 value) internal pure returns (FixedDecimal memory) {
    return add(self, fromU256(value));
  }

  function sub(FixedDecimal memory self, FixedDecimal memory value) internal pure returns (FixedDecimal memory) {
    uint256 x;
    require((x = self.x - value.x) <= self.x);
    return FixedDecimal(x);
  }

  function sub(FixedDecimal memory self, uint256 value) internal pure returns (FixedDecimal memory) {
    return sub(self, fromU256(value));
  }

  function mul(FixedDecimal memory self, uint256 value) internal pure returns (FixedDecimal memory) {
    uint256 x;
    require(value == 0 || (x = self.x * value) / value == self.x);
    return FixedDecimal(x);
  }

  function div(FixedDecimal memory self, uint256 value) internal pure returns (FixedDecimal memory) {
    require(value != 0);
    return FixedDecimal(self.x / value);
  }

  function cmp(FixedDecimal memory self, FixedDecimal memory value) internal pure returns (int256) {
    if (self.x < value.x) {
      return -1;
    }

    if (self.x > value.x) {
      return 1;
    }

    return 0;
  }

  function decode(FixedDecimal memory self) internal pure returns (uint256) {
    return self.x / SCALAR;
  }
}",496
RealWorld_BA_56_MStable_RealWord_20240821175342.log,56,MStable,4377,4687,9064,79.0,0.115625,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface MStable {
    function mint(address, uint) external;
    function redeem(address, uint) external;
}

interface mSavings {
    function depositSavings(uint) external;
    function creditBalances(address) external view returns (uint);
    function redeem(uint) external;
    function exchangeRate() external view returns (uint);
}",86
RealWorld_BA_56_IManager_RealWord_20240821163945.log,56,IManager,8223,6065,14288,97.0,0.162415,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

interface IManager {
    function addVault(address) external;
    function allowedControllers(address) external view returns (bool);
    function allowedConverters(address) external view returns (bool);
    function allowedStrategies(address) external view returns (bool);
    function allowedVaults(address) external view returns (bool);
    function controllers(address) external view returns (address);
    function getHarvestFeeInfo() external view returns (address, address, uint256);
    function getToken(address) external view returns (address);
    function governance() external view returns (address);
    function halted() external view returns (bool);
    function harvester() external view returns (address);
    function insuranceFee() external view returns (uint256);
    function insurancePool() external view returns (address);
    function insurancePoolFee() external view returns (uint256);
    function pendingStrategist() external view returns (address);
    function removeVault(address) external;
    function stakingPool() external view returns (address);
    function stakingPoolShareFee() external view returns (uint256);
    function strategist() external view returns (address);
    function treasury() external view returns (address);
    function treasuryFee() external view returns (uint256);
    function withdrawalProtectionFee() external view returns (uint256);
    function yaxis() external view returns (address);
}",292
RealWorld_BA_56_MockUniswapRouter_RealWord_20240821151707.log,56,MockUniswapRouter,15168,5399,20567,97.0,0.18382,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

interface IUniswapRouter {
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
}

contract MockUniswapRouter is IUniswapRouter {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    IERC20 univ2LpToken;

    constructor(IERC20 _univ2LpToken) public {
        univ2LpToken = _univ2LpToken;
    }

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) public override returns (uint256[] memory amounts) {
        return _swap(amountIn, amountOutMin, path, to, deadline);
    }

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external override returns (uint256[] memory amounts) {
        return _swap(amountIn, amountOutMin, path, to, deadline);
    }

    function _swap(
        uint256 amountIn,
        uint256,
        address[] calldata path,
        address to,
        uint256
    ) internal returns (uint256[] memory amounts) {
        uint256 amountOut = amountIn.mul(1); // assume 1 INPUT -> 1 OUTPUT
        IERC20 inputToken = IERC20(path[0]);
        IERC20 outputToken = IERC20(path[path.length - 1]);
        inputToken.safeTransferFrom(msg.sender, address(this), amountIn);
        outputToken.safeTransfer(to, amountOut);
        amounts = new uint256[](2);
        amounts[0] = amountIn;
        amounts[1] = amountOut;
    }

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint,
        uint,
        address to,
        uint
    ) external override returns (uint amountA, uint amountB, uint liquidity) {
        amountA = (amountADesired < amountBDesired) ? amountADesired : amountBDesired;
        amountB = amountA;
        liquidity = amountA;
        IERC20(tokenA).safeTransferFrom(msg.sender, address(this), amountA);
        IERC20(tokenB).safeTransferFrom(msg.sender, address(this), amountB);
        univ2LpToken.safeTransfer(to, liquidity); // 1A + 1B -> 1LP
    }
}",776
RealWorld_BA_56_Controller_RealWord_20240821161506.log,56,Controller,79303,5678,84981,104.0,0.510075,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""../interfaces/IController.sol"";
import ""../interfaces/IConverter.sol"";
import ""../interfaces/IVault.sol"";
import ""../interfaces/IHarvester.sol"";
import ""../interfaces/IStrategy.sol"";
import ""../interfaces/IManager.sol"";

/**
 * @title Controller
 * @notice This controller allows multiple strategies to be used
 * for a single vault supporting multiple tokens.
 */
contract Controller is IController {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    IManager public immutable override manager;

    bool public globalInvestEnabled;
    uint256 public maxStrategies;

    struct VaultDetail {
        address converter;
        uint256 balance;
        address[] strategies;
        mapping(address => uint256) balances;
        mapping(address => uint256) index;
        mapping(address => uint256) caps;
    }

    // vault => Vault
    mapping(address => VaultDetail) internal _vaultDetails;
    // strategy => vault
    mapping(address => address) internal _vaultStrategies;

    /**
     * @notice Logged when harvest is called for a strategy
     */
    event Harvest(address indexed strategy);

    /**
     * @notice Logged when a strategy is added for a vault
     */
    event StrategyAdded(address indexed vault, address indexed strategy, uint256 cap);

    /**
     * @notice Logged when a strategy is removed for a vault
     */
    event StrategyRemoved(address indexed vault, address indexed strategy);

    /**
     * @notice Logged when strategies are reordered for a vault
     */
    event StrategiesReordered(
        address indexed vault,
        address indexed strategy1,
        address indexed strategy2
    );

    /**
     * @param _manager The address of the manager
     */
    constructor(
        address _manager
    )
        public
    {
        manager = IManager(_manager);
        globalInvestEnabled = true;
        maxStrategies = 10;
    }

    /**
     * STRATEGIST-ONLY FUNCTIONS
     */

    /**
     * @notice Adds a strategy for a given vault
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     * @param _cap The cap of the strategy
     * @param _timeout The timeout between harvests
     */
    function addStrategy(
        address _vault,
        address _strategy,
        uint256 _cap,
        uint256 _timeout
    )
        external
        notHalted
        onlyStrategist
        onlyStrategy(_strategy)
    {
        require(manager.allowedVaults(_vault), ""!_vault"");
        require(_vaultDetails[_vault].converter != address(0), ""!converter"");
        // checking if strategy is already added
        require(_vaultStrategies[_strategy] == address(0), ""Strategy is already added""); 
        // get the index of the newly added strategy
        uint256 index = _vaultDetails[_vault].strategies.length;
        // ensure we haven't added too many strategies already
        require(index < maxStrategies, ""!maxStrategies"");
        // push the strategy to the array of strategies
        _vaultDetails[_vault].strategies.push(_strategy);
        // set the cap
        _vaultDetails[_vault].caps[_strategy] = _cap;
        // set the index
        _vaultDetails[_vault].index[_strategy] = index;
        // store the mapping of strategy to the vault
        _vaultStrategies[_strategy] = _vault;
        if (_timeout > 0) {
            // add it to the harvester
            IHarvester(manager.harvester()).addStrategy(_vault, _strategy, _timeout);
        }
        emit StrategyAdded(_vault, _strategy, _cap);
    }

    /**
     * @notice Withdraws token from a strategy to the treasury address as returned by the manager
     * @param _strategy The address of the strategy
     * @param _token The address of the token
     */
    function inCaseStrategyGetStuck(
        address _strategy,
        address _token
    )
        external
        onlyStrategist
    {
        IStrategy(_strategy).withdraw(_token);
        IERC20(_token).safeTransfer(
            manager.treasury(),
            IERC20(_token).balanceOf(address(this))
        );
    }

    /**
     * @notice Withdraws token from the controller to the treasury
     * @param _token The address of the token
     * @param _amount The amount that will be withdrawn
     */
    function inCaseTokensGetStuck(
        address _token,
        uint256 _amount
    )
        external
        onlyStrategist
    {
        IERC20(_token).safeTransfer(manager.treasury(), _amount);
    }

    /**
     * @notice Removes a strategy for a given token
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     * @param _timeout The timeout between harvests
     */
    function removeStrategy(
        address _vault,
        address _strategy,
        uint256 _timeout
    )
        external
        notHalted
        onlyStrategist
    {
        require(manager.allowedVaults(_vault), ""!_vault"");
        VaultDetail storage vaultDetail = _vaultDetails[_vault];
        // get the index of the strategy to remove
        uint256 index = vaultDetail.index[_strategy];
        // get the index of the last strategy
        uint256 tail = vaultDetail.strategies.length.sub(1);
        // get the address of the last strategy
        address replace = vaultDetail.strategies[tail];
        // replace the removed strategy with the tail
        vaultDetail.strategies[index] = replace;
        // set the new index for the replaced strategy
        vaultDetail.index[replace] = index;
        // remove the duplicate replaced strategy
        vaultDetail.strategies.pop();
        // remove the strategy's index
        delete vaultDetail.index[_strategy];
        // remove the strategy's cap
        delete vaultDetail.caps[_strategy];
        // remove the strategy's balance
        delete vaultDetail.balances[_strategy];
        // remove the mapping of strategy to the vault
        delete _vaultStrategies[_strategy];
        // pull funds from the removed strategy to the vault
        IStrategy(_strategy).withdrawAll();
        // remove the strategy from the harvester
        IHarvester(manager.harvester()).removeStrategy(_vault, _strategy, _timeout);
        emit StrategyRemoved(_vault, _strategy);
    }

    /**
     * @notice Reorders two strategies for a given vault
     * @param _vault The address of the vault
     * @param _strategy1 The address of the first strategy
     * @param _strategy2 The address of the second strategy
     */
    function reorderStrategies(
        address _vault,
        address _strategy1,
        address _strategy2
    )
        external
        notHalted
        onlyStrategist
    {
        require(manager.allowedVaults(_vault), ""!_vault"");
        require(_vaultStrategies[_strategy1] == _vault, ""!_strategy1"");
        require(_vaultStrategies[_strategy2] == _vault, ""!_strategy2"");
        VaultDetail storage vaultDetail = _vaultDetails[_vault];
        // get the indexes of the strategies
        uint256 index1 = vaultDetail.index[_strategy1];
        uint256 index2 = vaultDetail.index[_strategy2];
        // set the new addresses at their indexes
        vaultDetail.strategies[index1] = _strategy2;
        vaultDetail.strategies[index2] = _strategy1;
        // update indexes
        vaultDetail.index[_strategy1] = index2;
        vaultDetail.index[_strategy2] = index1;
        emit StrategiesReordered(_vault, _strategy1, _strategy2);
    }

    /**
     * @notice Sets/updates the cap of a strategy for a vault
     * @dev If the balance of the strategy is greater than the new cap (except if
     * the cap is 0), then withdraw the difference from the strategy to the vault.
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     * @param _cap The new cap of the strategy
     */
    function setCap(
        address _vault,
        address _strategy,
        uint256 _cap,
        address _convert
    )
        external
        notHalted
        onlyStrategist
        onlyStrategy(_strategy)
    {
        _vaultDetails[_vault].caps[_strategy] = _cap;
        uint256 _balance = IStrategy(_strategy).balanceOf();
        // send excess funds (over cap) back to the vault
        if (_balance > _cap && _cap != 0) {
            uint256 _diff = _balance.sub(_cap);
            IStrategy(_strategy).withdraw(_diff);
            updateBalance(_vault, _strategy);
            _balance = IStrategy(_strategy).balanceOf();
            _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_diff);
            address _want = IStrategy(_strategy).want();
            _balance = IERC20(_want).balanceOf(address(this));
            if (_convert != address(0)) {
                IConverter _converter = IConverter(_vaultDetails[_vault].converter);
                IERC20(_want).safeTransfer(address(_converter), _balance);
                _balance = _converter.convert(_want, _convert, _balance, 1);
                IERC20(_convert).safeTransfer(_vault, _balance);
            } else {
                IERC20(_want).safeTransfer(_vault, _balance);
            }
        }
    }

    /**
     * @notice Sets/updates the converter for a given vault
     * @param _vault The address of the vault
     * @param _converter The address of the converter
     */
    function setConverter(
        address _vault,
        address _converter
    )
        external
        notHalted
        onlyStrategist
    {
        require(manager.allowedConverters(_converter), ""!allowedConverters"");
        _vaultDetails[_vault].converter = _converter;
    }

    /**
     * @notice Sets/updates the global invest enabled flag
     * @param _investEnabled The new bool of the invest enabled flag
     */
    function setInvestEnabled(
        bool _investEnabled
    )
        external
        notHalted
        onlyStrategist
    {
        globalInvestEnabled = _investEnabled;
    }

    /**
     * @notice Sets/updates the maximum number of strategies for a vault
     * @param _maxStrategies The new value of the maximum strategies
     */
    function setMaxStrategies(
        uint256 _maxStrategies
    )
        external
        notHalted
        onlyStrategist
    {
        maxStrategies = _maxStrategies;
    }

    function skim(
        address _strategy
    )
        external
        onlyStrategist
        onlyStrategy(_strategy)
    {
        address _want = IStrategy(_strategy).want();
        IStrategy(_strategy).skim();
        IERC20(_want).safeTransfer(_vaultStrategies[_strategy], IERC20(_want).balanceOf(address(this)));
    }

    /**
     * @notice Withdraws all funds from a strategy
     * @param _strategy The address of the strategy
     * @param _convert The token address to convert to
     */
    function withdrawAll(
        address _strategy,
        address _convert
    )
        external
        override
        onlyStrategist
        onlyStrategy(_strategy)
    {
        address _want = IStrategy(_strategy).want();
        IStrategy(_strategy).withdrawAll();
        uint256 _amount = IERC20(_want).balanceOf(address(this));
        address _vault = _vaultStrategies[_strategy];
        updateBalance(_vault, _strategy);
        if (_convert != address(0)) {
            IConverter _converter = IConverter(_vaultDetails[_vault].converter);
            IERC20(_want).safeTransfer(address(_converter), _amount);
            _amount = _converter.convert(_want, _convert, _amount, 1);
            IERC20(_convert).safeTransfer(_vault, _amount);
        } else {
            IERC20(_want).safeTransfer(_vault, _amount);
        }
        uint256 _balance = _vaultDetails[_vault].balance;
        if (_balance >= _amount) {
            _vaultDetails[_vault].balance = _balance.sub(_amount);
        } else {
            _vaultDetails[_vault].balance = 0;
        }
    }

    /**
     * HARVESTER-ONLY FUNCTIONS
     */

    /**
     * @notice Harvests the specified strategy
     * @param _strategy The address of the strategy
     */
    function harvestStrategy(
        address _strategy,
        uint256 _estimatedWETH,
        uint256 _estimatedYAXIS
    )
        external
        override
        notHalted
        onlyHarvester
        onlyStrategy(_strategy)
    {
        uint256 _before = IStrategy(_strategy).balanceOf();
        IStrategy(_strategy).harvest(_estimatedWETH, _estimatedYAXIS);
        uint256 _after = IStrategy(_strategy).balanceOf();
        address _vault = _vaultStrategies[_strategy];
        _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.add(_after.sub(_before));
        _vaultDetails[_vault].balances[_strategy] = _after;
        emit Harvest(_strategy);
    }

    /**
     * VAULT-ONLY FUNCTIONS
     */

    /**
     * @notice Invests funds into a strategy
     * @param _strategy The address of the strategy
     * @param _token The address of the token
     * @param _amount The amount that will be invested
     */
    function earn(
        address _strategy,
        address _token,
        uint256 _amount
    )
        external
        override
        notHalted
        onlyStrategy(_strategy)
        onlyVault()
    {
        // get the want token of the strategy
        address _want = IStrategy(_strategy).want();
        if (_want != _token) {
            IConverter _converter = IConverter(_vaultDetails[msg.sender].converter);
            IERC20(_token).safeTransfer(address(_converter), _amount);
            // TODO: do estimation for received
            _amount = _converter.convert(_token, _want, _amount, 1);
            IERC20(_want).safeTransfer(_strategy, _amount);
        } else {
            IERC20(_token).safeTransfer(_strategy, _amount);
        }
        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.add(_amount);
        // call the strategy deposit function
        IStrategy(_strategy).deposit();
        updateBalance(msg.sender, _strategy);
    }

    /**
     * @notice Withdraws funds from a strategy
     * @dev If the withdraw amount is greater than the first strategy given
     * by getBestStrategyWithdraw, this function will loop over strategies
     * until the requested amount is met.
     * @param _token The address of the token
     * @param _amount The amount that will be withdrawn
     */
    function withdraw(
        address _token,
        uint256 _amount
    )
        external
        override
        onlyVault()
    {
        (
            address[] memory _strategies,
            uint256[] memory _amounts
        ) = getBestStrategyWithdraw(msg.sender, _amount);
        for (uint i = 0; i < _strategies.length; i++) {
            // getBestStrategyWithdraw will return arrays larger than needed
            // if this happens, simply exit the loop
            if (_strategies[i] == address(0)) {
                break;
            }
            IStrategy(_strategies[i]).withdraw(_amounts[i]);
            updateBalance(msg.sender, _strategies[i]);
            address _want = IStrategy(_strategies[i]).want();
            if (_want != _token) {
                address _converter = _vaultDetails[msg.sender].converter;
                IERC20(_want).safeTransfer(_converter, _amounts[i]);
                // TODO: do estimation for received
                IConverter(_converter).convert(_want, _token, _amounts[i], 1);
            }
        }
        _amount = IERC20(_token).balanceOf(address(this));
        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.sub(_amount);
        IERC20(_token).safeTransfer(msg.sender, _amount);
    }

    /**
     * EXTERNAL VIEW FUNCTIONS
     */

    /**
     * @notice Returns the rough balance of the sum of all strategies for a given vault
     * @dev This function is optimized to prevent looping over all strategy balances,
     * and instead the controller tracks the earn, withdraw, and harvest amounts.
     */
    function balanceOf()
        external
        view
        override
        returns (uint256 _balance)
    {
        return _vaultDetails[msg.sender].balance;
    }

    /**
     * @notice Returns the converter assigned for the given vault
     * @param _vault Address of the vault
     */
    function converter(
        address _vault
    )
        external
        view
        override
        returns (address)
    {
        return _vaultDetails[_vault].converter;
    }

    /**
     * @notice Returns the cap of a strategy for a given vault
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     */
    function getCap(
        address _vault,
        address _strategy
    )
        external
        view
        returns (uint256)
    {
        return _vaultDetails[_vault].caps[_strategy];
    }

    /**
     * @notice Returns whether investing is enabled for the calling vault
     * @dev Should be called by the vault
     */
    function investEnabled()
        external
        view
        override
        returns (bool)
    {
        if (globalInvestEnabled) {
            return _vaultDetails[msg.sender].strategies.length > 0;
        }
        return false;
    }

    /**
     * @notice Returns all the strategies for a given vault
     * @param _vault The address of the vault
     */
    function strategies(
        address _vault
    )
        external
        view
        returns (address[] memory)
    {
        return _vaultDetails[_vault].strategies;
    }

    /**
     * @notice Returns the length of the strategies of the calling vault
     * @dev This function is expected to be called by a vault
     */
    function strategies()
        external
        view
        override
        returns (uint256)
    {
        return _vaultDetails[msg.sender].strategies.length;
    }

    /**
     * INTERNAL FUNCTIONS
     */

    /**
     * @notice Returns the best (optimistic) strategy for funds to be withdrawn from
     * @dev Since Solidity doesn't support dynamic arrays in memory, the returned arrays
     * from this function will always be the same length as the amount of strategies for
     * a token. Check that _strategies[i] != address(0) when consuming to know when to
     * break out of the loop.
     * @param _vault The address of the vault
     * @param _amount The amount that will be withdrawn
     */
    function getBestStrategyWithdraw(
        address _vault,
        uint256 _amount
    )
        internal
        view
        returns (
            address[] memory _strategies,
            uint256[] memory _amounts
        )
    {
        // get the length of strategies for a single token
        uint256 k = _vaultDetails[_vault].strategies.length;
        // initialize fixed-length memory arrays
        _strategies = new address[](k);
        _amounts = new uint256[](k);
        address _strategy;
        uint256 _balance;
        // scan forward from the the beginning of strategies
        for (uint i = 0; i < k; i++) {
            _strategy = _vaultDetails[_vault].strategies[i];
            _strategies[i] = _strategy;
            // get the balance of the strategy
            _balance = _vaultDetails[_vault].balances[_strategy];
            // if the strategy doesn't have the balance to cover the withdraw
            if (_balance < _amount) {
                // withdraw what we can and add to the _amounts
                _amounts[i] = _balance;
                _amount = _amount.sub(_balance);
            } else {
                // stop scanning if the balance is more than the withdraw amount
                _amounts[i] = _amount;
                break;
            }
        }
    }

    /**
     * @notice Updates the stored balance of a given strategy for a vault
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     */
    function updateBalance(
        address _vault,
        address _strategy
    )
        internal
    {
        _vaultDetails[_vault].balances[_strategy] = IStrategy(_strategy).balanceOf();
    }

    /**
     * MODIFIERS
     */

    /**
     * @notice Reverts if the protocol is halted
     */
    modifier notHalted() {
        require(!manager.halted(), ""halted"");
        _;
    }

    /**
     * @notice Reverts if the caller is not governance
     */
    modifier onlyGovernance() {
        require(msg.sender == manager.governance(), ""!governance"");
        _;
    }

    /**
     * @notice Reverts if the caller is not the strategist
     */
    modifier onlyStrategist() {
        require(msg.sender == manager.strategist(), ""!strategist"");
        _;
    }

    /**
     * @notice Reverts if the strategy is not allowed in the manager
     */
    modifier onlyStrategy(address _strategy) {
        require(manager.allowedStrategies(_strategy), ""!allowedStrategy"");
        _;
    }

    /**
     * @notice Reverts if the caller is not the harvester
     */
    modifier onlyHarvester() {
        require(msg.sender == manager.harvester(), ""!harvester"");
        _;
    }

    /**
     * @notice Reverts if the caller is not the vault for the given token
     */
    modifier onlyVault() {
        require(manager.allowedVaults(msg.sender), ""!vault"");
        _;
    }
}",4825
RealWorld_BA_56_IsYAX_RealWord_20240821150940.log,56,IsYAX,3441,4231,7672,63.0,0.101825,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

interface IsYAX {
    function exit() external;
}",28
RealWorld_BA_56_MetaVaultNonConverter_RealWord_20240821153653.log,56,MetaVaultNonConverter,17851,5584,23435,75.0,0.200935,"// SPDX-License-Identifier: MIT
// solhint-disable func-name-mixedcase
// solhint-disable var-name-mixedcase

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import ""./IConverter.sol"";
import ""./IVaultManager.sol"";

/**
 * @title MetaVaultNonConverter (StableSwap3PoolConverter)
 * @notice The StableSwap3PoolConverter is used to convert funds on Curve's 3Pool.
 * This is a safe version that does not allow the vault to be used for arbitrage.
 */
contract MetaVaultNonConverter is IConverter {
    using SafeERC20 for IERC20;

    IVaultManager public immutable vaultManager;
    IERC20 public immutable token3CRV; // 3Crv

    /**
     * @param _token3CRV The address of the 3CRV token
     * @param _vaultManager The address of the Vault Manager
     */
    constructor(
        IERC20 _token3CRV,
        IVaultManager _vaultManager
    ) public {
        token3CRV = _token3CRV;
        vaultManager = _vaultManager;
    }

    /**
     * @notice Called by Governance to enable or disable a strategy to use the converter
     */
    function setStrategy(address, bool) external override onlyGovernance {
        return;
    }

    /**
     * @notice Called by Governance to approve a token address to be spent by an address
     * @param _token The address of the token
     * @param _spender The address of the spender
     * @param _amount The amount to spend
     */
    function approveForSpender(
        IERC20 _token,
        address _spender,
        uint256 _amount
    ) external onlyGovernance {
        _token.safeApprove(_spender, _amount);
    }

    /**
     * @notice Returns the address of the 3CRV token
     */
    function token() external view override returns (address) {
        return address(token3CRV);
    }

    /**
     * @notice Converts the amount of input tokens to output tokens
     */
    function convert(
        address,
        address,
        uint256
    ) external override returns (uint256) {
        revert(""Only 3CRV allowed"");
    }

    /**
     * @notice Checks the amount of input tokens to output tokens
     */
    function convert_rate(
        address,
        address,
        uint256
    ) external override view returns (uint256) {
        revert(""Only 3CRV allowed"");
    }

    /**
     * @notice Converts stables of the 3Pool to 3CRV
     */
    function convert_stables(
        uint256[3] calldata
    ) external override returns (uint256) {
        revert(""Only 3CRV allowed"");
    }

    /**
     * @notice Checks the amount of 3CRV given for the amounts
     */
    function calc_token_amount(
        uint256[3] calldata,
        bool
    ) external override view returns (uint256) {
        revert(""Only 3CRV allowed"");
    }

    /**
     * @notice Checks the amount of an output token given for 3CRV
     */
    function calc_token_amount_withdraw(
        uint256,
        address
    ) external override view returns (uint256) {
        revert(""Only 3CRV allowed"");
    }

    /**
     * @notice Allows Governance to withdraw tokens from the converter
     * @dev This contract should never have any tokens in it at the end of a transaction
     * @param _token The address of the token
     * @param _amount The amount to withdraw
     * @param _to The address to receive the tokens
     */
    function governanceRecoverUnsupported(
        IERC20 _token,
        uint256 _amount,
        address _to
    ) external onlyGovernance {
        _token.safeTransfer(_to, _amount);
    }

    /**
     * @dev Throws if not called by a controller or governance
     */
    modifier onlyGovernance() {
        require(vaultManager.controllers(msg.sender)
            || msg.sender == vaultManager.governance(), ""!governance"");
        _;
    }
}",920
RealWorld_BA_56_OneSplitAudit_RealWord_20240821180232.log,56,OneSplitAudit,5129,4696,9825,87.0,0.119565,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface OneSplitAudit {
    function swap(
        address fromToken,
        address destToken,
        uint256 amount,
        uint256 minReturn,
        uint256[] calldata distribution,
        uint256 flags
    )
        external
        payable
        returns(uint256 returnAmount);

    function getExpectedReturn(
        address fromToken,
        address destToken,
        uint256 amount,
        uint256 parts,
        uint256 flags // See constants in IOneSplit.sol
    )
        external
        view
        returns(
            uint256 returnAmount,
            uint256[] memory distribution
        );
}",140
RealWorld_BA_56_ISwap_RealWord_20240821163001.log,56,ISwap,3996,3971,7967,89.0,0.0994,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface ISwap {
    function swapExactTokensForTokens(uint256, uint256, address[] calldata, address, uint256) external;
    function getAmountsOut(uint256, address[] calldata) external view returns (uint256[] memory);
}",69
RealWorld_BA_56_Balancer_RealWord_20240821173926.log,56,Balancer,6926,5194,12120,86.0,0.13851,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface Balancer {
    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external;
    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut) external;
    function swapExactAmountIn(
        address tokenIn,
        uint tokenAmountIn,
        address tokenOut,
        uint minAmountOut,
        uint maxPrice
    ) external returns (uint tokenAmountOut, uint spotPriceAfter);
    function swapExactAmountOut(
        address tokenIn,
        uint maxAmountIn,
        address tokenOut,
        uint tokenAmountOut,
        uint maxPrice
    ) external returns (uint tokenAmountIn, uint spotPriceAfter);
    function joinswapExternAmountIn(
        address tokenIn,
        uint tokenAmountIn,
        uint minPoolAmountOut
    ) external returns (uint poolAmountOut);
    function exitswapPoolAmountIn(
        address tokenOut,
        uint poolAmountIn,
        uint minAmountOut
    ) external returns (uint tokenAmountOut);
}",230
RealWorld_BA_56_MIMConvexStrategy_RealWord_20240821160039.log,56,MIMConvexStrategy,26922,5837,32759,98.0,0.25135,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import '../interfaces/IConvexVault.sol';
import '../interfaces/IStableSwap2Pool.sol';
import './BaseStrategy.sol';

contract MIMConvexStrategy is BaseStrategy {
    // used for Crv -> weth -> [mim/3crv] -> mimCrv route
    address public immutable crv;
    address public immutable cvx;

    address public immutable mim;
    address public immutable crv3;

    uint256 public immutable pid;
    IConvexVault public immutable convexVault;
    address public immutable mimCvxDepositLP;
    IConvexRewards public immutable crvRewards;
    IStableSwap2Pool public immutable stableSwap2Pool;

    /**
     * @param _name The strategy name
     * @param _want The desired token of the strategy
     * @param _crv The address of CRV
     * @param _cvx The address of CVX
     * @param _weth The address of WETH
     * @param _mim The address of MIM
     * @param _crv3 The address of 3CRV
     * @param _pid The pool id of convex
     * @param _convexVault The address of the convex vault
     * @param _stableSwap2Pool The address of the stable swap pool
     * @param _controller The address of the controller
     * @param _manager The address of the manager
     * @param _router The address of the router for swapping tokens
     */
    constructor(
        string memory _name,
        address _want,
        address _crv,
        address _cvx,
        address _weth,
        address _mim,
        address _crv3,
        uint256 _pid,
        IConvexVault _convexVault,
        IStableSwap2Pool _stableSwap2Pool,
        address _controller,
        address _manager,
        address _router
    ) public BaseStrategy(_name, _controller, _manager, _want, _weth, _router) {
        require(address(_crv) != address(0), '!_crv');
        require(address(_cvx) != address(0), '!_cvx');
        require(address(_mim) != address(0), '!_mim');
        require(address(_crv3) != address(0), '!_crv3');
        require(address(_convexVault) != address(0), '!_convexVault');
        require(address(_stableSwap2Pool) != address(0), '!_stableSwap2Pool');

        (, address _token, , address _crvRewards, , ) = _convexVault.poolInfo(_pid);
        crv = _crv;
        cvx = _cvx;
        mim = _mim;
        crv3 = _crv3;
        pid = _pid;
        convexVault = _convexVault;
        mimCvxDepositLP = _token;
        crvRewards = IConvexRewards(_crvRewards);
        stableSwap2Pool = _stableSwap2Pool;
        // Required to overcome ""Stack Too Deep"" error
        _setApprovals(
            _want,
            _crv,
            _cvx,
            _mim,
            _crv3,
            address(_convexVault),
            address(_stableSwap2Pool)
        );
    }

    function _setApprovals(
        address _want,
        address _crv,
        address _cvx,
        address _mim,
        address _crv3,
        address _convexVault,
        address _stableSwap2Pool
    ) internal {
        IERC20(_want).safeApprove(address(_convexVault), type(uint256).max);
        IERC20(_crv).safeApprove(address(router), type(uint256).max);
        IERC20(_cvx).safeApprove(address(router), type(uint256).max);
        IERC20(_mim).safeApprove(address(_stableSwap2Pool), type(uint256).max);
        IERC20(_crv3).safeApprove(address(_stableSwap2Pool), type(uint256).max);
        IERC20(_want).safeApprove(address(_stableSwap2Pool), type(uint256).max);
    }

    function _deposit() internal override {
        if (balanceOfWant() > 0) {
            convexVault.depositAll(pid, true);
        }
    }

    function _claimReward() internal {
        crvRewards.getReward(address(this), true);
    }

    function _addLiquidity() internal {
        uint256[2] memory amounts;
        amounts[0] = IERC20(mim).balanceOf(address(this));
        amounts[1] = IERC20(crv3).balanceOf(address(this));
        stableSwap2Pool.add_liquidity(amounts, 1);
    }

    function getMostPremium() public view returns (address, uint256) {
        // both MIM and 3CRV have 18 decimals
        if (stableSwap2Pool.balances(0) > stableSwap2Pool.balances(1)) {
            return (crv3, 1);
        }

        return (mim, 0); // If they're somehow equal, we just want MIM
    }

    function _harvest(uint256 _estimatedWETH, uint256 _estimatedYAXIS) internal override {
        _claimReward();
        uint256 _cvxBalance = IERC20(cvx).balanceOf(address(this));
        if (_cvxBalance > 0) {
            _swapTokens(cvx, crv, _cvxBalance, 1);
        }

        uint256 _extraRewardsLength = crvRewards.extraRewardsLength();
        for (uint256 i = 0; i < _extraRewardsLength; i++) {
            address _rewardToken = IConvexRewards(crvRewards.extraRewards(i)).rewardToken();
            uint256 _extraRewardBalance = IERC20(_rewardToken).balanceOf(address(this));
            if (_extraRewardBalance > 0) {
                _swapTokens(_rewardToken, weth, _extraRewardBalance, 1);
            }
        }

        uint256 _remainingWeth = _payHarvestFees(crv, _estimatedWETH, _estimatedYAXIS);
        if (_remainingWeth > 0) {
            (address _token, ) = getMostPremium(); // stablecoin we want to convert to
            _swapTokens(weth, _token, _remainingWeth, 1);
            _addLiquidity();
            _deposit();
        }
    }

    function _withdrawAll() internal override {
        convexVault.withdrawAll(pid);
    }

    function _withdraw(uint256 _amount) internal override {
        convexVault.withdraw(pid, _amount);
    }

    function balanceOfPool() public view override returns (uint256) {
        return IERC20(mimCvxDepositLP).balanceOf(address(this));
    }
}",1512
RealWorld_BA_56_FlamIncome_RealWord_20240821174054.log,56,FlamIncome,4012,4186,8198,79.0,0.10378,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

interface IVault {
    function token() external view returns (address);
    function priceE18() external view returns (uint);
    function deposit(uint) external;
    function withdraw(uint) external;
    function depositAll() external;
    function withdrawAll() external;
}",71
RealWorld_BA_56_NativeStrategyCurve3Crv_RealWord_20240821155855.log,56,NativeStrategyCurve3Crv,21644,5913,27557,102.0,0.22648,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""../../interfaces/Gauge.sol"";
import ""../../interfaces/Balancer.sol"";

import ""../interfaces/ExtendedIERC20.sol"";

import ""./BaseStrategy.sol"";

contract NativeStrategyCurve3Crv is BaseStrategy {
    // used for Crv -> weth -> [dai/usdc/usdt] -> 3crv route
    address public immutable crv;

    // for add_liquidity via curve.fi to get back 3CRV (use getMostPremium() for the best stable coin used in the route)
    address public immutable dai;
    address public immutable usdc;
    address public immutable usdt;

    Mintr public immutable crvMintr;
    IStableSwap3Pool public immutable stableSwap3Pool;
    Gauge public immutable gauge; // 3Crv Gauge

    constructor(
        string memory _name,
        address _want,
        address _crv,
        address _weth,
        address _dai,
        address _usdc,
        address _usdt,
        Gauge _gauge,
        Mintr _crvMintr,
        IStableSwap3Pool _stableSwap3Pool,
        address _controller,
        address _manager,
        address _router
    )
        public
        BaseStrategy(_name, _controller, _manager, _want, _weth, _router)
    {
        crv = _crv;
        dai = _dai;
        usdc = _usdc;
        usdt = _usdt;
        stableSwap3Pool = _stableSwap3Pool;
        gauge = _gauge;
        crvMintr = _crvMintr;
        IERC20(_want).safeApprove(address(_gauge), type(uint256).max);
        IERC20(_crv).safeApprove(address(_router), type(uint256).max);
        IERC20(_dai).safeApprove(address(_stableSwap3Pool), type(uint256).max);
        IERC20(_usdc).safeApprove(address(_stableSwap3Pool), type(uint256).max);
        IERC20(_usdt).safeApprove(address(_stableSwap3Pool), type(uint256).max);
        IERC20(_want).safeApprove(address(_stableSwap3Pool), type(uint256).max);
    }

    function _deposit()
        internal
        override
    {
        uint256 _wantBal = balanceOfWant();
        if (_wantBal > 0) {
            // deposit [want] to Gauge
            gauge.deposit(_wantBal);
        }
    }

    function _claimReward()
        internal
    {
        crvMintr.mint(address(gauge));
    }

    function _addLiquidity()
        internal
    {
        uint256[3] memory amounts;
        amounts[0] = IERC20(dai).balanceOf(address(this));
        amounts[1] = IERC20(usdc).balanceOf(address(this));
        amounts[2] = IERC20(usdt).balanceOf(address(this));
        stableSwap3Pool.add_liquidity(amounts, 1);
    }

    function getMostPremium()
        public
        view
        returns (address, uint256)
    {
        uint daiBalance = stableSwap3Pool.balances(0);
        // USDC - Supports a change up to the 18 decimal standard
        uint usdcBalance = stableSwap3Pool.balances(1).mul(10**18).div(10**(ExtendedIERC20(usdc).decimals()));
        uint usdtBalance = stableSwap3Pool.balances(2).mul(10**12);

        if (daiBalance <= usdcBalance && daiBalance <= usdtBalance) {
            return (dai, 0);
        }

        if (usdcBalance <= daiBalance && usdcBalance <= usdtBalance) {
            return (usdc, 1);
        }

        if (usdtBalance <= daiBalance && usdtBalance <= usdcBalance) {
            return (usdt, 2);
        }

        return (dai, 0); // If they're somehow equal, we just want DAI
    }

    function _harvest(
        uint256 _estimatedWETH,
        uint256 _estimatedYAXIS
    )
        internal
        override
    {
        _claimReward();
        uint256 _remainingWeth = _payHarvestFees(crv, _estimatedWETH, _estimatedYAXIS);

        if (_remainingWeth > 0) {
            (address _stableCoin,) = getMostPremium(); // stablecoin we want to convert to
            _swapTokens(weth, _stableCoin, _remainingWeth, 1);
            _addLiquidity();

            _deposit();
        }
    }

    function _withdrawAll()
        internal
        override
    {
        uint256 _bal = gauge.balanceOf(address(this));
        _withdraw(_bal);
    }

    function _withdraw(
        uint256 _amount
    )
        internal
        override
    {
        gauge.withdraw(_amount);
    }

    function balanceOfPool()
        public
        view
        override
        returns (uint256)
    {
        return gauge.balanceOf(address(this));
    }
}",1121
RealWorld_BA_56_MockYaxisBar_RealWord_20240821154454.log,56,MockYaxisBar,9497,5492,14989,86.0,0.157325,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

contract MockYaxisBar is ERC20 {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    IERC20 public immutable YAX;

    constructor(
        address _yax
    )
        public
        ERC20(""Staked yAxis"", ""sYAX"")
    {
        YAX = IERC20(_yax);
    }

    function availableBalance()
        external
        view
        returns (uint256)
    {
        return YAX.balanceOf(address(this));
    }

    function enter(
        uint256 _amount
    )
        external
    {
        require(_amount > 0, ""!_amount"");
        _mint(msg.sender, _amount.mul(1e18).div(getPricePerFullShare()));
        YAX.safeTransferFrom(msg.sender, address(this), _amount);
    }

    function leave(
        uint256 _amount
    )
        public
    {
        require(_amount > 0, ""!_amount"");
        _burn(msg.sender, _amount);
        YAX.safeTransfer(msg.sender, _amount.mul(getPricePerFullShare()).div(1e18));
    }

    function exit()
        external
    {
        leave(balanceOf(msg.sender));
    }

    function getPricePerFullShare()
        public
        view
        returns (uint256)
    {
        return totalSupply() == 0
            ? 1e18
            : YAX.balanceOf(address(this)).mul(1e18).div(totalSupply());
    }
}",394
RealWorld_BA_56_CDP_RealWord_20240821170507.log,56,CDP,21395,5710,27105,92.0,0.221175,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.6.12;

import {Math} from ""@openzeppelin/contracts/math/Math.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";

import {FixedPointMath} from ""../FixedPointMath.sol"";
import {IDetailedERC20} from ""../../interfaces/IDetailedERC20.sol"";
import ""hardhat/console.sol"";

/// @title CDP
///
/// @dev A library which provides the CDP data struct and associated functions.
library CDP {
  using CDP for Data;
  using FixedPointMath for FixedPointMath.FixedDecimal;
  using SafeERC20 for IDetailedERC20;
  using SafeMath for uint256;

  struct Context {
    FixedPointMath.FixedDecimal collateralizationLimit;
    FixedPointMath.FixedDecimal accumulatedYieldWeight;
  }

  struct Data {
    uint256 totalDeposited;
    uint256 totalDebt;
    uint256 totalCredit;
    uint256 lastDeposit;
    FixedPointMath.FixedDecimal lastAccumulatedYieldWeight;
  }

  function update(Data storage _self, Context storage _ctx) internal {
    uint256 _earnedYield = _self.getEarnedYield(_ctx);
    if (_earnedYield > _self.totalDebt) {
      uint256 _currentTotalDebt = _self.totalDebt;
      _self.totalDebt = 0;
      _self.totalCredit = _earnedYield.sub(_currentTotalDebt);
    } else {
      _self.totalDebt = _self.totalDebt.sub(_earnedYield);
    }
    _self.lastAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;
  }

  /// @dev Assures that the CDP is healthy.
  ///
  /// This function will revert if the CDP is unhealthy.
  function checkHealth(Data storage _self, Context storage _ctx, string memory _msg) internal view {
    require(_self.isHealthy(_ctx), _msg);
  }

  /// @dev Gets if the CDP is considered healthy.
  ///
  /// A CDP is healthy if its collateralization ratio is greater than the global collateralization limit.
  ///
  /// @return if the CDP is healthy.
  function isHealthy(Data storage _self, Context storage _ctx) internal view returns (bool) {
    return _ctx.collateralizationLimit.cmp(_self.getCollateralizationRatio(_ctx)) <= 0;
  }

  function getUpdatedTotalDebt(Data storage _self, Context storage _ctx) internal view returns (uint256) {
    uint256 _unclaimedYield = _self.getEarnedYield(_ctx);
    if (_unclaimedYield == 0) {
      return _self.totalDebt;
    }

    uint256 _currentTotalDebt = _self.totalDebt;
    if (_unclaimedYield >= _currentTotalDebt) {
      return 0;
    }

    return _currentTotalDebt - _unclaimedYield;
  }

  function getUpdatedTotalCredit(Data storage _self, Context storage _ctx) internal view returns (uint256) {
    uint256 _unclaimedYield = _self.getEarnedYield(_ctx);
    if (_unclaimedYield == 0) {
      return _self.totalCredit;
    }

    uint256 _currentTotalDebt = _self.totalDebt;
    if (_unclaimedYield <= _currentTotalDebt) {
      return 0;
    }

    return _self.totalCredit + (_unclaimedYield - _currentTotalDebt);
  }

  /// @dev Gets the amount of yield that a CDP has earned since the last time it was updated.
  ///
  /// @param _self the CDP to query.
  /// @param _ctx  the CDP context.
  ///
  /// @return the amount of earned yield.
  function getEarnedYield(Data storage _self, Context storage _ctx) internal view returns (uint256) {
    FixedPointMath.FixedDecimal memory _currentAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;
    FixedPointMath.FixedDecimal memory _lastAccumulatedYieldWeight = _self.lastAccumulatedYieldWeight;

    if (_currentAccumulatedYieldWeight.cmp(_lastAccumulatedYieldWeight) == 0) {
      return 0;
    }

    return _currentAccumulatedYieldWeight
      .sub(_lastAccumulatedYieldWeight)
      .mul(_self.totalDeposited)
      .decode();
  }

  /// @dev Gets a CDPs collateralization ratio.
  ///
  /// The collateralization ratio is defined as the ratio of collateral to debt. If the CDP has zero debt then this
  /// will return the maximum value of a fixed point integer.
  ///
  /// This function will use the updated total debt so an update before calling this function is not required.
  ///
  /// @param _self the CDP to query.
  ///
  /// @return a fixed point integer representing the collateralization ratio.
  function getCollateralizationRatio(Data storage _self, Context storage _ctx)
    internal view
    returns (FixedPointMath.FixedDecimal memory)
  {
    uint256 _totalDebt = _self.getUpdatedTotalDebt(_ctx);
    if (_totalDebt == 0) {
      return FixedPointMath.maximumValue();
    }
    return FixedPointMath.fromU256(_self.totalDeposited).div(_totalDebt);
  }
}",1200
RealWorld_BA_56_IRewards_RealWord_20240821172811.log,56,IRewards,4076,4950,9026,91.0,0.11938,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

interface IRewards {
    function balanceOf(address) external view returns (uint256);
    function earned(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
}",59
RealWorld_BA_56_MockdYdXSoloMargin_RealWord_20240821153101.log,56,MockdYdXSoloMargin,18764,6291,25055,98.0,0.21964,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;
pragma experimental ABIEncoderV2;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""../interfaces/dYdXSoloMargin.sol"";

contract MockdYdXSoloMargin is ISoloMargin {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;
    using SafeMath for uint128;

    // Store balances as (Account => (MarketID => balance))
    mapping(address => mapping(uint256 => uint128)) balances;

    // Mapping of tokens as (MarketID => token)
    mapping(uint256 => address) tokens;

    constructor (uint256[] memory _marketIds, address[] memory _addresses) public {
        require(_marketIds.length == _addresses.length, ""marketIds.length != addresses.length"");
        for (uint256 i = 0; i < _marketIds.length; i++) {
            tokens[_marketIds[i]] = _addresses[i];
        }
    }

    function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) public override {
        _verifyInputs(accounts, actions);

        _runActions(
            accounts,
            actions
        );
    }

    function _verifyInputs(
        Account.Info[] memory accounts,
        Actions.ActionArgs[] memory actions
    ) private pure {
        require(actions.length != 0, ""Cannot have zero actions"");
        require(accounts.length != 0, ""Cannot have zero accounts"");

        for (uint256 a = 0; a < accounts.length; a++) {
            for (uint256 b = a + 1; b < accounts.length; b++) {
                require(!Account.equals(accounts[a], accounts[b]), ""Cannot duplicate accounts"");
            }
        }
    }

    function _runActions(
        Account.Info[] memory accounts,
        Actions.ActionArgs[] memory actions
    ) private {
        for (uint256 i = 0; i < actions.length; i++) {
            Actions.ActionArgs memory action = actions[i];
            Actions.ActionType actionType = action.actionType;

            if (actionType == Actions.ActionType.Deposit) {
                _deposit(Actions.parseDepositArgs(accounts, action));
            } else if (actionType == Actions.ActionType.Withdraw) {
                _withdraw(Actions.parseWithdrawArgs(accounts, action));
            }
        }
    }

    function _deposit(
        Actions.DepositArgs memory args
    )
        private
    {
        require(
            args.from == msg.sender || args.from == args.account.owner,
            ""Invalid deposit source""
        );

        // We'll not implement all cases in this mock, for simplicity
        require(args.amount.denomination == Types.AssetDenomination.Wei, ""!Types.AssetDenomination.Wei"");
        IERC20(tokens[args.market]).safeTransferFrom(args.from, address(this), args.amount.value);

        uint128 newBalance = to128(SafeMath.add(balances[args.account.owner][args.market], args.amount.value));
        balances[args.account.owner][args.market] = newBalance;
    }

    function _withdraw(
        Actions.WithdrawArgs memory args
    )
        private
    {
        require(
            msg.sender == args.account.owner,
            ""Not valid operator""
        );
        require(args.amount.value <= balances[args.account.owner][args.market], ""!balance"");
        require(!args.amount.sign, ""should receive negative amount"");
        IERC20(tokens[args.market]).safeTransfer(args.to, args.amount.value);

        uint128 newBalance = to128(SafeMath.sub(balances[args.account.owner][args.market], args.amount.value));
        balances[args.account.owner][args.market] = newBalance;
    }

    function getMarketTokenAddress(uint256 marketId) external override view returns (address) {
        return tokens[marketId];
    }

    function getAccountWei(Account.Info memory account, uint256 marketId)
        external
        override
        view
        returns (Types.Wei memory)
    {
        Types.Wei memory balance = Types.Wei({
            sign: true,
            value: balances[account.owner][marketId]
        });
        return balance;
    }

    function to128(
        uint256 number
    )
        internal
        pure
        returns (uint128)
    {
        uint128 result = uint128(number);
        require(result == number, ""Unsafe cast to uint128"");
        return result;
    }
}",978
RealWorld_BA_56_MockERC20NonStandard_RealWord_20240821153510.log,56,MockERC20NonStandard,18696,6073,24769,101.0,0.21494,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

contract MockERC20NonStandard {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    address private _owner;

    uint internal _totalSupply;

    mapping(address => uint)                   private _balance;
    mapping(address => mapping(address => uint)) private _allowance;

    modifier _onlyOwner_() {
        require(msg.sender == _owner, ""ERR_NOT_OWNER"");
        _;
    }

    event Approval(address indexed src, address indexed dst, uint amt);
    event Transfer(address indexed src, address indexed dst, uint amt);

    // Math
    function add(uint a, uint b) internal pure returns (uint c) {
        require((c = a + b) >= a);
    }

    function sub(uint a, uint b) internal pure returns (uint c) {
        require((c = a - b) <= a);
    }

    constructor(
        string memory name,
        string memory symbol,
        uint8 decimals
    ) public {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
        _owner = msg.sender;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function _move(address src, address dst, uint amt) internal {
        require(_balance[src] >= amt, ""!bal"");
        _balance[src] = sub(_balance[src], amt);
        _balance[dst] = add(_balance[dst], amt);
        emit Transfer(src, dst, amt);
    }

    function _push(address to, uint amt) internal {
        _move(address(this), to, amt);
    }

    function _pull(address from, uint amt) internal {
        _move(from, address(this), amt);
    }

    function _mint(address dst, uint amt) internal {
        _balance[dst] = add(_balance[dst], amt);
        _totalSupply = add(_totalSupply, amt);
        emit Transfer(address(0), dst, amt);
    }

    function _burn(address dst, uint amt) internal {
        _balance[dst] = sub(_balance[dst], amt);
        _totalSupply = sub(_totalSupply, amt);
        emit Transfer(dst, address(0), amt);
    }

    function allowance(address src, address dst) external view returns (uint) {
        return _allowance[src][dst];
    }

    function balanceOf(address whom) public view returns (uint) {
        return _balance[whom];
    }

    function faucet(uint256 amt) public {
        _mint(msg.sender, amt);
    }

    function totalSupply() public view returns (uint) {
        return _totalSupply;
    }

    function approve(address dst, uint amt) external {
        _allowance[msg.sender][dst] = amt;
        emit Approval(msg.sender, dst, amt);
    }

    function mint(address dst, uint256 amt) public _onlyOwner_ {
        _mint(dst, amt);
    }

    function burn(uint amt) public {
        require(_balance[msg.sender] >= amt, ""!bal"");
        _burn(msg.sender, amt);
    }

    function burnFrom(address src, uint amt) public _onlyOwner_ {
        require(_balance[src] >= amt, ""!bal"");
        _burn(src, amt);
    }

    function transfer(address dst, uint amt) external {
        _move(msg.sender, dst, amt);
    }

    function transferFrom(address src, address dst, uint amt) external {
        require(msg.sender == src || amt <= _allowance[src][msg.sender], ""!spender"");
        _move(src, dst, amt);
        if (msg.sender != src && _allowance[src][msg.sender] != uint256(- 1)) {
            _allowance[src][msg.sender] = sub(_allowance[src][msg.sender], amt);
            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);
        }
    }

    function transferOwnership(address newOwner) external _onlyOwner_ {
        _owner = newOwner;
    }
}",901
RealWorld_BA_56_IVaultManager_RealWord_20240821153942.log,56,IVaultManager,6608,4552,11160,73.0,0.12408,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

interface IVaultManager {
    function controllers(address) external view returns (bool);
    function getHarvestFeeInfo() external view returns (address, address, uint256, address, uint256, address, uint256);
    function governance() external view returns (address);
    function harvester() external view returns (address);
    function insuranceFee() external view returns (uint256);
    function insurancePool() external view returns (address);
    function insurancePoolFee() external view returns (uint256);
    function stakingPool() external view returns (address);
    function stakingPoolShareFee() external view returns (uint256);
    function strategist() external view returns (address);
    function treasury() external view returns (address);
    function treasuryBalance() external view returns (uint256);
    function treasuryFee() external view returns (uint256);
    function vaults(address) external view returns (bool);
    function withdrawalProtectionFee() external view returns (uint256);
    function yax() external view returns (address);
}",226
RealWorld_BA_56_AlwaysAccess_RealWord_20240821155747.log,56,AlwaysAccess,5565,3894,9459,65.0,0.105705,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

contract AlwaysAccess {
    mapping(address => bool) private authorized;

    constructor(bool _authorized)
    public
    {
        authorized[msg.sender] = _authorized;
    }

    function setAuthorized(address _address, bool _authorized) external {
        authorized[_address] = _authorized;
    }

    function allowedVaults(address _address) external view returns (bool) {
        return authorized[_address];
    }

    function allowedControllers(address _address) external view returns (bool) {
        return authorized[_address];
    }

    function allowedStrategies(address _address) external view returns (bool) {
        return authorized[_address];
    }
}",148
RealWorld_BA_56_Aave_RealWord_20240821174928.log,56,Aave,8879,5349,14228,93.0,0.151375,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface Aave {
    function borrow(address _reserve, uint _amount, uint _interestRateModel, uint16 _referralCode) external;
    function setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral) external;
    function repay(address _reserve, uint _amount, address payable _onBehalfOf) external payable;
    function getUserAccountData(address _user)
        external
        view
        returns (
            uint totalLiquidityETH,
            uint totalCollateralETH,
            uint totalBorrowsETH,
            uint totalFeesETH,
            uint availableBorrowsETH,
            uint currentLiquidationThreshold,
            uint ltv,
            uint healthFactor
        );
    function getUserReserveData(address _reserve, address _user)
        external
        view
        returns (
            uint currentATokenBalance,
            uint currentBorrowBalance,
            uint principalBorrowBalance,
            uint borrowRateMode,
            uint borrowRate,
            uint liquidityRate,
            uint originationFee,
            uint variableBorrowIndex,
            uint lastUpdateTimestamp,
            bool usageAsCollateralEnabled
        );
}

interface LendingPoolAddressesProvider {
    function getLendingPool() external view returns (address);
    function getLendingPoolCore() external view returns (address);
    function getPriceOracle() external view returns (address);
}

interface AaveToken {
    function underlyingAssetAddress() external view returns (address);
}

interface Oracle {
    function getAssetPrice(address reserve) external view returns (uint);
    function latestAnswer() external view returns (uint);
}",348
RealWorld_BA_56_MockCurveMinter_RealWord_20240821152430.log,56,MockCurveMinter,5590,4606,10196,70.0,0.12007,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import ""../interfaces/Gauge.sol"";

contract MockCurveMinter is Mintr {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    IERC20 crv;

    constructor(IERC20 _crv) public {
        crv = _crv;
    }

    function mint(address) external override {
        uint _bal = crv.balanceOf(address(this));
        crv.safeTransfer(msg.sender, _bal.div(10)); // always mint 10% amount of balance
    }
}",172
RealWorld_BA_56_Idle_RealWord_20240821174806.log,56,Idle,4492,5093,9585,80.0,0.12432,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface IIdleTokenV3_1 {
    function tokenPrice() external view returns (uint256 price);
    function token() external view returns (address);
    function mintIdleToken(uint256 _amount, bool _skipRebalance, address _referral) external returns (uint256 mintedTokens);
    function redeemIdleToken(uint256 _amount) external returns (uint256 redeemedTokens);
}",97
RealWorld_BA_56_DForce_RealWord_20240821174626.log,56,DForce,4688,4896,9584,98.0,0.12136,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface dRewards {
    function withdraw(uint) external;
    function getReward() external;
    function stake(uint) external;
    function balanceOf(address) external view returns (uint);
    function exit() external;
}

interface dERC20 {
  function mint(address, uint256) external;
  function redeem(address, uint) external;
  function getTokenBalance(address) external view returns (uint);
  function getExchangeRate() external view returns (uint);
}",110
RealWorld_BA_56_GeneralConvexStrategy_RealWord_20240821160411.log,56,GeneralConvexStrategy,29944,5974,35918,89.0,0.2692,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IConvexVault.sol';
import '../interfaces/ExtendedIERC20.sol';
import '../interfaces/IStableSwapPool.sol';
import '../interfaces/IStableSwap2Pool.sol';
import './BaseStrategy.sol';

contract GeneralConvexStrategy is BaseStrategy {
    using SafeMath for uint8;

    address public immutable crv;
    address public immutable cvx;

    uint256 public immutable pid;
    IConvexVault public immutable convexVault;
    address public immutable cvxDepositLP;
    IConvexRewards public immutable crvRewards;
    address public immutable stableSwapPool;

    address[] public tokens;
    uint8[] public decimalMultiples;

    /**
     * @param _name The strategy name
     * @param _want The desired token of the strategy
     * @param _crv The address of CRV
     * @param _cvx The address of CVX
     * @param _weth The address of WETH
     * @param _pid The pool id of convex
     * @param _coinCount The number of coins in the pool
     * @param _convexVault The address of the convex vault
     * @param _stableSwapPool The address of the stable swap pool
     * @param _controller The address of the controller
     * @param _manager The address of the manager
     * @param _router The address of the router for swapping tokens
     */
    constructor(
        string memory _name,
        address _want,
        address _crv,
        address _cvx,
        address _weth,
        uint256 _pid,
        uint256 _coinCount,
        IConvexVault _convexVault,
        address _stableSwapPool,
        address _controller,
        address _manager,
        address _router
    ) public BaseStrategy(_name, _controller, _manager, _want, _weth, _router) {
        require(_coinCount == 2 || _coinCount == 3, '_coinCount should be 2 or 3');
        require(address(_crv) != address(0), '!_crv');
        require(address(_cvx) != address(0), '!_cvx');
        require(address(_convexVault) != address(0), '!_convexVault');
        require(address(_stableSwapPool) != address(0), '!_stableSwapPool');

        (, address _token, , address _crvRewards, , ) = _convexVault.poolInfo(_pid);
        crv = _crv;
        cvx = _cvx;
        pid = _pid;
        convexVault = _convexVault;
        cvxDepositLP = _token;
        crvRewards = IConvexRewards(_crvRewards);
        stableSwapPool = _stableSwapPool;

        for (uint256 i = 0; i < _coinCount; i++) {
            tokens.push(IStableSwapPool(_stableSwapPool).coins(i));
            decimalMultiples.push(18 - ExtendedIERC20(tokens[i]).decimals());
            IERC20(tokens[i]).safeApprove(_stableSwapPool, type(uint256).max);
        }

        IERC20(_want).safeApprove(address(_convexVault), type(uint256).max);
        IERC20(_crv).safeApprove(address(_router), type(uint256).max);
        IERC20(_cvx).safeApprove(address(_router), type(uint256).max);
        IERC20(_want).safeApprove(address(_stableSwapPool), type(uint256).max);
    }

    function _deposit() internal override {
        convexVault.depositAll(pid, true);
    }

    function _claimReward() internal {
        crvRewards.getReward(address(this), true);
    }

    function _addLiquidity() internal {
        if (tokens.length == 2) {
            uint256[2] memory amounts;
            amounts[0] = IERC20(tokens[0]).balanceOf(address(this));
            amounts[1] = IERC20(tokens[1]).balanceOf(address(this));
            IStableSwap2Pool(stableSwapPool).add_liquidity(amounts, 1);
            return;
        }

        uint256[3] memory amounts;
        amounts[0] = IERC20(tokens[0]).balanceOf(address(this));
        amounts[1] = IERC20(tokens[1]).balanceOf(address(this));
        amounts[2] = IERC20(tokens[2]).balanceOf(address(this));
        IStableSwap3Pool(stableSwapPool).add_liquidity(amounts, 1);
    }

    function getMostPremium() public view returns (address, uint256) {
        uint256 balance0 = IStableSwap3Pool(stableSwapPool).balances(0).mul(
            10**(decimalMultiples[0])
        );
        uint256 balance1 = IStableSwap3Pool(stableSwapPool).balances(1).mul(
            10**(decimalMultiples[1])
        );

        if (tokens.length == 2) {
            if (balance0 > balance1) {
                return (tokens[1], 1);
            }

            return (tokens[0], 0);
        }

        uint256 balance2 = IStableSwap3Pool(stableSwapPool).balances(2).mul(
            10**(decimalMultiples[2])
        );

        if (balance0 < balance1 && balance0 < balance2) {
            return (tokens[0], 0);
        }

        if (balance1 < balance0 && balance1 < balance2) {
            return (tokens[1], 1);
        }

        if (balance2 < balance0 && balance2 < balance1) {
            return (tokens[2], 2);
        }

        return (tokens[0], 0);
    }

    function _harvest(uint256 _estimatedWETH, uint256 _estimatedYAXIS) internal override {
        _claimReward();
        uint256 _cvxBalance = IERC20(cvx).balanceOf(address(this));
        if (_cvxBalance > 0) {
            _swapTokens(cvx, crv, _cvxBalance, 1);
        }

        uint256 _extraRewardsLength = crvRewards.extraRewardsLength();
        for (uint256 i = 0; i < _extraRewardsLength; i++) {
            address _rewardToken = IConvexRewards(crvRewards.extraRewards(i)).rewardToken();
            uint256 _extraRewardBalance = IERC20(_rewardToken).balanceOf(address(this));
            if (_extraRewardBalance > 0) {
                _swapTokens(_rewardToken, weth, _extraRewardBalance, 1);
            }
        }

        uint256 _remainingWeth = _payHarvestFees(crv, _estimatedWETH, _estimatedYAXIS);
        if (_remainingWeth > 0) {
            (address _targetCoin, ) = getMostPremium();
            _swapTokens(weth, _targetCoin, _remainingWeth, 1);
            _addLiquidity();

            if (balanceOfWant() > 0) {
                _deposit();
            }
        }
    }

    function _withdrawAll() internal override {
        convexVault.withdrawAll(pid);
    }

    function _withdraw(uint256 _amount) internal override {
        convexVault.withdraw(pid, _amount);
    }

    function balanceOfPool() public view override returns (uint256) {
        return IERC20(cvxDepositLP).balanceOf(address(this));
    }
}",1642
RealWorld_BA_56_Alchemist_RealWord_20240821165334.log,56,Alchemist,120651,6023,126674,121.0,0.723715,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

//import {ERC20} from ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import {Math} from '@openzeppelin/contracts/math/Math.sol';
import {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import {Address} from '@openzeppelin/contracts/utils/Address.sol';
import {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';

import {CDP} from './libraries/alchemist/CDP.sol';
import {FixedPointMath} from './libraries/FixedPointMath.sol';
import {AlchemistVault} from './libraries/alchemist/AlchemistVault.sol';
import {ITransmuter} from './interfaces/ITransmuter.sol';
import {IMintableERC20} from './interfaces/IMintableERC20.sol';
import {ICurveToken} from './interfaces/ICurveToken.sol';
import {IVaultAdapter} from './interfaces/IVaultAdapter.sol';

import 'hardhat/console.sol';

// ERC20,removing ERC20 from the alchemist
//    ___    __        __                _               ___                              __         _
//   / _ |  / / ____  / /  ___   __ _   (_) __ __       / _ \  ____ ___   ___ ___   ___  / /_  ___  (_)
//  / __ | / / / __/ / _ \/ -_) /  ' \ / /  \ \ /      / ___/ / __// -_) (_-</ -_) / _ \/ __/ (_-< _
// /_/ |_|/_/  \__/ /_//_/\__/ /_/_/_//_/  /_\_\      /_/    /_/   \__/ /___/\__/ /_//_/\__/ /___/(_)
//
//      ___       __        ______  __    __   _______ .___  ___.  __       _______..___________.
//     /   \     |  |      /      ||  |  |  | |   ____||   \/   | |  |     /       ||           |
//    /  ^  \    |  |     |  ,----'|  |__|  | |  |__   |  \  /  | |  |    |   (----``---|  |----`
//   /  /_\  \   |  |     |  |     |   __   | |   __|  |  |\/|  | |  |     \   \        |  |
//  /  _____  \  |  `----.|  `----.|  |  |  | |  |____ |  |  |  | |  | .----)   |       |  |
// /__/     \__\ |_______| \______||__|  |__| |_______||__|  |__| |__| |_______/        |__|

contract Alchemist is ReentrancyGuard {
    using CDP for CDP.Data;
    using FixedPointMath for FixedPointMath.FixedDecimal;
    using AlchemistVault for AlchemistVault.Data;
    using AlchemistVault for AlchemistVault.List;
    using SafeERC20 for IMintableERC20;
    using SafeMath for uint256;
    using Address for address;

    address public constant ZERO_ADDRESS = address(0);

    /// @dev Resolution for all fixed point numeric parameters which represent percents. The resolution allows for a
    /// granularity of 0.01% increments.
    uint256 public constant PERCENT_RESOLUTION = 10000;

    /// @dev The minimum value that the collateralization limit can be set to by the governance. This is a safety rail
    /// to prevent the collateralization from being set to a value which breaks the system.
    ///
    /// This value is equal to 100%.
    ///
    /// IMPORTANT: This constant is a raw FixedPointMath.FixedDecimal value and assumes a resolution of 64 bits. If the
    ///            resolution for the FixedPointMath library changes this constant must change as well.
    uint256 public constant MINIMUM_COLLATERALIZATION_LIMIT = 1000000000000000000;

    /// @dev The maximum value that the collateralization limit can be set to by the governance. This is a safety rail
    /// to prevent the collateralization from being set to a value which breaks the system.
    ///
    /// This value is equal to 400%.
    ///
    /// IMPORTANT: This constant is a raw FixedPointMath.FixedDecimal value and assumes a resolution of 64 bits. If the
    ///            resolution for the FixedPointMath library changes this constant must change as well.
    uint256 public constant MAXIMUM_COLLATERALIZATION_LIMIT = 4000000000000000000;

    event GovernanceUpdated(address governance);

    event PendingGovernanceUpdated(address pendingGovernance);

    event SentinelUpdated(address sentinel);

    event TransmuterUpdated(address transmuter);

    event RewardsUpdated(address treasury);

    event HarvestFeeUpdated(uint256 fee);

    event CollateralizationLimitUpdated(uint256 limit);

    event EmergencyExitUpdated(bool status);

    event ActiveVaultUpdated(IVaultAdapter indexed adapter);

    event FundsHarvested(uint256 withdrawnAmount, uint256 decreasedValue);

    event FundsRecalled(
        uint256 indexed vaultId,
        uint256 withdrawnAmount,
        uint256 decreasedValue
    );

    event FundsFlushed(uint256 amount);

    event TokensDeposited(address indexed account, uint256 amount);

    event TokensWithdrawn(
        address indexed account,
        uint256 requestedAmount,
        uint256 withdrawnAmount,
        uint256 decreasedValue
    );

    event TokensRepaid(address indexed account, uint256 parentAmount, uint256 childAmount);

    event TokensLiquidated(
        address indexed account,
        uint256 requestedAmount,
        uint256 withdrawnAmount,
        uint256 decreasedValue
    );

    /// @dev The token that this contract is using as the parent asset.
    IMintableERC20 public token;

    /// @dev The token that this contract is using as the child asset.
    IMintableERC20 public xtoken;

    /// @dev The address of the account which currently has administrative capabilities over this contract.
    address public governance;

    /// @dev The address of the pending governance.
    address public pendingGovernance;

    /// @dev The address of the account which can initiate an emergency withdraw of funds in a vault.
    address public sentinel;

    /// @dev The address of the contract which will transmute synthetic tokens back into native tokens.
    address public transmuter;

    /// @dev The address of the contract which will receive fees.
    address public rewards;

    /// @dev The percent of each profitable harvest that will go to the rewards contract.
    uint256 public harvestFee;

    /// @dev The percent of each profitable harvest that will go to the rewards contract.
    uint256 public borrowFee;

    /// @dev The total amount the native token deposited into the system that is owned by external users.
    uint256 public totalDeposited;

    /// @dev when movemetns are bigger than this number flush is activated.
    uint256 public flushActivator;

    /// @dev A flag indicating if the contract has been initialized yet.
    bool public initialized;

    /// @dev A flag indicating if deposits and flushes should be halted and if all parties should be able to recall
    /// from the active vault.
    bool public emergencyExit;

    /// @dev The context shared between the CDPs.
    CDP.Context private _ctx;

    /// @dev A mapping of all of the user CDPs. If a user wishes to have multiple CDPs they will have to either
    /// create a new address or set up a proxy contract that interfaces with this contract.
    mapping(address => CDP.Data) private _cdps;

    /// @dev A list of all of the vaults. The last element of the list is the vault that is currently being used for
    /// deposits and withdraws. Vaults before the last element are considered inactive and are expected to be cleared.
    AlchemistVault.List private _vaults;

    /// @dev The address of the link oracle.
    address public _linkGasOracle;

    /// @dev The minimum returned amount needed to be on peg according to the oracle.
    uint256 public pegMinimum;

    constructor(
        IMintableERC20 _token,
        IMintableERC20 _xtoken,
        address _governance,
        address _sentinel
    )
        public
    /*ERC20(
      string(abi.encodePacked(""Alchemic "", _token.name())),
      string(abi.encodePacked(""al"", _token.symbol()))
    )*/
    {
        require(_governance != ZERO_ADDRESS, 'Alchemist: governance address cannot be 0x0.');
        require(_sentinel != ZERO_ADDRESS, 'Alchemist: sentinel address cannot be 0x0.');

        token = _token;
        xtoken = _xtoken;
        governance = _governance;
        sentinel = _sentinel;
        flushActivator = 100000 ether; // change for non 18 digit tokens

        //_setupDecimals(_token.decimals());
        uint256 COLL_LIMIT = MINIMUM_COLLATERALIZATION_LIMIT.mul(2);
        _ctx.collateralizationLimit = FixedPointMath.FixedDecimal(COLL_LIMIT);
        _ctx.accumulatedYieldWeight = FixedPointMath.FixedDecimal(0);
    }

    /// @dev Sets the pending governance.
    ///
    /// This function reverts if the new pending governance is the zero address or the caller is not the current
    /// governance. This is to prevent the contract governance being set to the zero address which would deadlock
    /// privileged contract functionality.
    ///
    /// @param _pendingGovernance the new pending governance.
    function setPendingGovernance(address _pendingGovernance) external onlyGov {
        require(
            _pendingGovernance != ZERO_ADDRESS,
            'Alchemist: governance address cannot be 0x0.'
        );

        pendingGovernance = _pendingGovernance;

        emit PendingGovernanceUpdated(_pendingGovernance);
    }

    /// @dev Accepts the role as governance.
    ///
    /// This function reverts if the caller is not the new pending governance.
    function acceptGovernance() external {
        require(msg.sender == pendingGovernance, 'sender is not pendingGovernance');
        address _pendingGovernance = pendingGovernance;
        governance = _pendingGovernance;

        emit GovernanceUpdated(_pendingGovernance);
    }

    function setSentinel(address _sentinel) external onlyGov {
        require(_sentinel != ZERO_ADDRESS, 'Alchemist: sentinel address cannot be 0x0.');

        sentinel = _sentinel;

        emit SentinelUpdated(_sentinel);
    }

    /// @dev Sets the transmuter.
    ///
    /// This function reverts if the new transmuter is the zero address or the caller is not the current governance.
    ///
    /// @param _transmuter the new transmuter.
    function setTransmuter(address _transmuter) external onlyGov {
        // Check that the transmuter address is not the zero address. Setting the transmuter to the zero address would break
        // transfers to the address because of `safeTransfer` checks.
        require(_transmuter != ZERO_ADDRESS, 'Alchemist: transmuter address cannot be 0x0.');

        transmuter = _transmuter;

        emit TransmuterUpdated(_transmuter);
    }

    /// @dev Sets the flushActivator.
    ///
    /// @param _flushActivator the new flushActivator.
    function setFlushActivator(uint256 _flushActivator) external onlyGov {
        flushActivator = _flushActivator;
    }

    /// @dev Sets the rewards contract.
    ///
    /// This function reverts if the new rewards contract is the zero address or the caller is not the current governance.
    ///
    /// @param _rewards the new rewards contract.
    function setRewards(address _rewards) external onlyGov {
        // Check that the rewards address is not the zero address. Setting the rewards to the zero address would break
        // transfers to the address because of `safeTransfer` checks.
        require(_rewards != ZERO_ADDRESS, 'Alchemist: rewards address cannot be 0x0.');

        rewards = _rewards;

        emit RewardsUpdated(_rewards);
    }

    /// @dev Sets the harvest fee.
    ///
    /// This function reverts if the caller is not the current governance.
    ///
    /// @param _harvestFee the new harvest fee.
    function setHarvestFee(uint256 _harvestFee) external onlyGov {
        // Check that the harvest fee is within the acceptable range. Setting the harvest fee greater than 100% could
        // potentially break internal logic when calculating the harvest fee.
        require(_harvestFee <= PERCENT_RESOLUTION, 'Alchemist: harvest fee above maximum.');

        harvestFee = _harvestFee;

        emit HarvestFeeUpdated(_harvestFee);
    }

    /// @dev Sets the borrow fee.
    ///
    /// This function reverts if the caller is not the current governance.
    ///
    /// @param _borrowFee the new borrow fee.
    function setBorrowFee(uint256 _borrowFee) external onlyGov {
        // Check that the borrow fee is within the acceptable range. Setting the borrow fee greater than 100% could
        // potentially break internal logic when calculating the borrow fee.
        require(_borrowFee <= PERCENT_RESOLUTION, 'Alchemist: borrow fee above maximum.');

        borrowFee = _borrowFee;

        emit HarvestFeeUpdated(_borrowFee);
    }

    /// @dev Sets the collateralization limit.
    ///
    /// This function reverts if the caller is not the current governance or if the collateralization limit is outside
    /// of the accepted bounds.
    ///
    /// @param _limit the new collateralization limit.
    function setCollateralizationLimit(uint256 _limit) external onlyGov {
        require(
            _limit >= MINIMUM_COLLATERALIZATION_LIMIT,
            'Alchemist: collateralization limit below minimum.'
        );
        require(
            _limit <= MAXIMUM_COLLATERALIZATION_LIMIT,
            'Alchemist: collateralization limit above maximum.'
        );

        _ctx.collateralizationLimit = FixedPointMath.FixedDecimal(_limit);

        emit CollateralizationLimitUpdated(_limit);
    }

    /// @dev Set pegMinimum.
    function setPegMinimum(uint256 peg) external onlyGov {
        pegMinimum = peg;
    }

    /// @dev Sets if the contract should enter emergency exit mode.
    ///
    /// @param _emergencyExit if the contract should enter emergency exit mode.
    function setEmergencyExit(bool _emergencyExit) external {
        require(msg.sender == governance || msg.sender == sentinel, '');

        emergencyExit = _emergencyExit;

        emit EmergencyExitUpdated(_emergencyExit);
    }

    /// @dev Gets the collateralization limit.
    ///
    /// The collateralization limit is the minimum ratio of collateral to debt that is allowed by the system.
    ///
    /// @return the collateralization limit.
    function collateralizationLimit()
        external
        view
        returns (FixedPointMath.FixedDecimal memory)
    {
        return _ctx.collateralizationLimit;
    }

    /// @dev Initializes the contract.
    ///
    /// This function checks that the transmuter and rewards have been set and sets up the active vault.
    ///
    /// @param _adapter the vault adapter of the active vault.
    function initialize(IVaultAdapter _adapter) external onlyGov {
        require(!initialized, 'Alchemist: already initialized');

        require(
            transmuter != ZERO_ADDRESS,
            'Alchemist: cannot initialize transmuter address to 0x0'
        );
        require(
            rewards != ZERO_ADDRESS,
            'Alchemist: cannot initialize rewards address to 0x0'
        );

        _updateActiveVault(_adapter);

        initialized = true;
    }

    /// @dev Migrates the system to a new vault.
    ///
    /// This function reverts if the vault adapter is the zero address, if the token that the vault adapter accepts
    /// is not the token that this contract defines as the parent asset, or if the contract has not yet been initialized.
    ///
    /// @param _adapter the adapter for the vault the system will migrate to.
    function migrate(IVaultAdapter _adapter) external expectInitialized onlyGov {
        _updateActiveVault(_adapter);
    }

    /// @dev Harvests yield from a vault.
    ///
    /// @param _vaultId the identifier of the vault to harvest from.
    ///
    /// @return the amount of funds that were harvested from the vault.
    function harvest(uint256 _vaultId) external expectInitialized returns (uint256, uint256) {
        AlchemistVault.Data storage _vault = _vaults.get(_vaultId);

        (uint256 _harvestedAmount, uint256 _decreasedValue) = _vault.harvest(address(this));

        if (_harvestedAmount > 0) {
            uint256 _feeAmount = _harvestedAmount.mul(harvestFee).div(PERCENT_RESOLUTION);
            uint256 _distributeAmount = _harvestedAmount.sub(_feeAmount);

            FixedPointMath.FixedDecimal memory _weight = FixedPointMath
                .fromU256(_distributeAmount)
                .div(totalDeposited);
            _ctx.accumulatedYieldWeight = _ctx.accumulatedYieldWeight.add(_weight);

            if (_feeAmount > 0) {
                token.safeTransfer(rewards, _feeAmount);
            }

            if (_distributeAmount > 0) {
                _distributeToTransmuter(_distributeAmount);

                // token.safeTransfer(transmuter, _distributeAmount); previous version call
            }
        }

        emit FundsHarvested(_harvestedAmount, _decreasedValue);

        return (_harvestedAmount, _decreasedValue);
    }

    /// @dev Recalls an amount of deposited funds from a vault to this contract.
    ///
    /// @param _vaultId the identifier of the recall funds from.
    ///
    /// @return the amount of funds that were recalled from the vault to this contract and the decreased vault value.
    function recall(uint256 _vaultId, uint256 _amount)
        external
        nonReentrant
        expectInitialized
        returns (uint256, uint256)
    {
        return _recallFunds(_vaultId, _amount);
    }

    /// @dev Recalls all the deposited funds from a vault to this contract.
    ///
    /// @param _vaultId the identifier of the recall funds from.
    ///
    /// @return the amount of funds that were recalled from the vault to this contract and the decreased vault value.
    function recallAll(uint256 _vaultId)
        external
        nonReentrant
        expectInitialized
        returns (uint256, uint256)
    {
        AlchemistVault.Data storage _vault = _vaults.get(_vaultId);
        return _recallFunds(_vaultId, _vault.totalDeposited);
    }

    /// @dev Flushes buffered tokens to the active vault.
    ///
    /// This function reverts if an emergency exit is active. This is in place to prevent the potential loss of
    /// additional funds.
    ///
    /// @return the amount of tokens flushed to the active vault.
    function flush() external nonReentrant expectInitialized returns (uint256) {
        // Prevent flushing to the active vault when an emergency exit is enabled to prevent potential loss of funds if
        // the active vault is poisoned for any reason.
        require(!emergencyExit, 'emergency pause enabled');

        return flushActiveVault();
    }

    /// @dev Internal function to flush buffered tokens to the active vault.
    ///
    /// This function reverts if an emergency exit is active. This is in place to prevent the potential loss of
    /// additional funds.
    ///
    /// @return the amount of tokens flushed to the active vault.
    function flushActiveVault() internal returns (uint256) {
        AlchemistVault.Data storage _activeVault = _vaults.last();
        uint256 _depositedAmount = _activeVault.depositAll();

        emit FundsFlushed(_depositedAmount);

        return _depositedAmount;
    }

    /// @dev Deposits collateral into a CDP.
    ///
    /// This function reverts if an emergency exit is active. This is in place to prevent the potential loss of
    /// additional funds.
    ///
    /// @param _amount the amount of collateral to deposit.
    function deposit(uint256 _amount)
        external
        nonReentrant
        noContractAllowed
        expectInitialized
    {
        require(!emergencyExit, 'emergency pause enabled');

        CDP.Data storage _cdp = _cdps[msg.sender];
        _cdp.update(_ctx);

        token.safeTransferFrom(msg.sender, address(this), _amount);
        if (_amount >= flushActivator) {
            flushActiveVault();
        }
        totalDeposited = totalDeposited.add(_amount);

        _cdp.totalDeposited = _cdp.totalDeposited.add(_amount);
        _cdp.lastDeposit = block.number;

        emit TokensDeposited(msg.sender, _amount);
    }

    /// @dev Attempts to withdraw part of a CDP's collateral.
    ///
    /// This function reverts if a deposit into the CDP was made in the same block. This is to prevent flash loan attacks
    /// on other internal or external systems.
    ///
    /// @param _amount the amount of collateral to withdraw.
    function withdraw(uint256 _amount)
        external
        nonReentrant
        noContractAllowed
        expectInitialized
        returns (uint256, uint256)
    {
        CDP.Data storage _cdp = _cdps[msg.sender];
        require(block.number > _cdp.lastDeposit, '');

        _cdp.update(_ctx);

        (uint256 _withdrawnAmount, uint256 _decreasedValue) = _withdrawFundsTo(
            msg.sender,
            _amount
        );

        _cdp.totalDeposited = _cdp.totalDeposited.sub(
            _decreasedValue,
            'Exceeds withdrawable amount'
        );
        _cdp.checkHealth(_ctx, 'Action blocked: unhealthy collateralization ratio');
        if (_amount >= flushActivator) {
            flushActiveVault();
        }
        emit TokensWithdrawn(msg.sender, _amount, _withdrawnAmount, _decreasedValue);

        return (_withdrawnAmount, _decreasedValue);
    }

    /// @dev Repays debt with the native and or synthetic token.
    ///
    /// An approval is required to transfer native tokens to the transmuter.
    function repay(uint256 _parentAmount, uint256 _childAmount)
        external
        nonReentrant
        noContractAllowed
        onPriceCheck
        expectInitialized
    {
        CDP.Data storage _cdp = _cdps[msg.sender];
        _cdp.update(_ctx);

        if (_parentAmount > 0) {
            token.safeTransferFrom(msg.sender, address(this), _parentAmount);
            _distributeToTransmuter(_parentAmount);
        }

        if (_childAmount > 0) {
            xtoken.burnFrom(msg.sender, _childAmount);
            //lower debt cause burn
            xtoken.lowerHasMinted(_childAmount);
        }

        uint256 _totalAmount = _parentAmount.add(_childAmount);
        _cdp.totalDebt = _cdp.totalDebt.sub(_totalAmount, '');

        emit TokensRepaid(msg.sender, _parentAmount, _childAmount);
    }

    /// @dev Attempts to liquidate part of a CDP's collateral to pay back its debt.
    ///
    /// @param _amount the amount of collateral to attempt to liquidate.
    function liquidate(uint256 _amount)
        external
        nonReentrant
        noContractAllowed
        onPriceCheck
        expectInitialized
        returns (uint256, uint256)
    {
        CDP.Data storage _cdp = _cdps[msg.sender];
        _cdp.update(_ctx);

        // don't attempt to liquidate more than is possible
        if (_amount > _cdp.totalDebt) {
            _amount = _cdp.totalDebt;
        }
        (uint256 _withdrawnAmount, uint256 _decreasedValue) = _withdrawFundsTo(
            address(this),
            _amount
        );
        //changed to new transmuter compatibillity
        _distributeToTransmuter(_withdrawnAmount);

        _cdp.totalDeposited = _cdp.totalDeposited.sub(_decreasedValue, '');
        _cdp.totalDebt = _cdp.totalDebt.sub(_withdrawnAmount, '');
        emit TokensLiquidated(msg.sender, _amount, _withdrawnAmount, _decreasedValue);

        return (_withdrawnAmount, _decreasedValue);
    }

    /// @dev Mints synthetic tokens by either claiming credit or increasing the debt.
    ///
    /// Claiming credit will take priority over increasing the debt.
    ///
    /// This function reverts if the debt is increased and the CDP health check fails.
    ///
    /// @param _amount the amount of alchemic tokens to borrow.
    function mint(uint256 _amount)
        external
        nonReentrant
        noContractAllowed
        onPriceCheck
        expectInitialized
    {
        CDP.Data storage _cdp = _cdps[msg.sender];
        _cdp.update(_ctx);

        uint256 _totalCredit = _cdp.totalCredit;

        if (_totalCredit < _amount) {
            uint256 _remainingAmount = _amount.sub(_totalCredit);

            if (borrowFee > 0) {
                uint256 _borrowFeeAmount = _remainingAmount.mul(borrowFee).div(
                    PERCENT_RESOLUTION
                );
                _cdp.totalDebt = _cdp.totalDebt.add(_borrowFeeAmount);
                xtoken.mint(rewards, _borrowFeeAmount);
            }
            _cdp.totalDebt = _cdp.totalDebt.add(_remainingAmount);
            _cdp.totalCredit = 0;

            _cdp.checkHealth(_ctx, 'Alchemist: Loan-to-value ratio breached');
        } else {
            _cdp.totalCredit = _totalCredit.sub(_amount);
        }

        xtoken.mint(msg.sender, _amount);
        if (_amount >= flushActivator) {
            flushActiveVault();
        }
    }

    /// @dev Gets the number of vaults in the vault list.
    ///
    /// @return the vault count.
    function vaultCount() external view returns (uint256) {
        return _vaults.length();
    }

    /// @dev Get the adapter of a vault.
    ///
    /// @param _vaultId the identifier of the vault.
    ///
    /// @return the vault adapter.
    function getVaultAdapter(uint256 _vaultId) external view returns (IVaultAdapter) {
        AlchemistVault.Data storage _vault = _vaults.get(_vaultId);
        return _vault.adapter;
    }

    /// @dev Get the total amount of the parent asset that has been deposited into a vault.
    ///
    /// @param _vaultId the identifier of the vault.
    ///
    /// @return the total amount of deposited tokens.
    function getVaultTotalDeposited(uint256 _vaultId) external view returns (uint256) {
        AlchemistVault.Data storage _vault = _vaults.get(_vaultId);
        return _vault.totalDeposited;
    }

    /// @dev Get the total amount of collateral deposited into a CDP.
    ///
    /// @param _account the user account of the CDP to query.
    ///
    /// @return the deposited amount of tokens.
    function getCdpTotalDeposited(address _account) external view returns (uint256) {
        CDP.Data storage _cdp = _cdps[_account];
        return _cdp.totalDeposited;
    }

    /// @dev Get the total amount of alchemic tokens borrowed from a CDP.
    ///
    /// @param _account the user account of the CDP to query.
    ///
    /// @return the borrowed amount of tokens.
    function getCdpTotalDebt(address _account) external view returns (uint256) {
        CDP.Data storage _cdp = _cdps[_account];
        return _cdp.getUpdatedTotalDebt(_ctx);
    }

    /// @dev Get the total amount of credit that a CDP has.
    ///
    /// @param _account the user account of the CDP to query.
    ///
    /// @return the amount of credit.
    function getCdpTotalCredit(address _account) external view returns (uint256) {
        CDP.Data storage _cdp = _cdps[_account];
        return _cdp.getUpdatedTotalCredit(_ctx);
    }

    /// @dev Gets the last recorded block of when a user made a deposit into their CDP.
    ///
    /// @param _account the user account of the CDP to query.
    ///
    /// @return the block number of the last deposit.
    function getCdpLastDeposit(address _account) external view returns (uint256) {
        CDP.Data storage _cdp = _cdps[_account];
        return _cdp.lastDeposit;
    }

    /// @dev sends tokens to the transmuter
    ///
    /// benefit of great nation of transmuter
    function _distributeToTransmuter(uint256 amount) internal {
        token.approve(transmuter, amount);
        ITransmuter(transmuter).distribute(address(this), amount);
        // lower debt cause of 'burn'
        xtoken.lowerHasMinted(amount);
    }

    /// @dev Checks that parent token is on peg.
    ///
    /// This is used over a modifier limit of pegged interactions.
    modifier onPriceCheck() {
        if (pegMinimum > 0) {
            require(
                ICurveToken(address(token)).get_virtual_price() > pegMinimum,
                'off peg limitation'
            );
        }
        _;
    }
    /// @dev Checks that caller is not a eoa.
    ///
    /// This is used to prevent contracts from interacting.
    modifier noContractAllowed() {
        require(
            !address(msg.sender).isContract() && msg.sender == tx.origin,
            'Sorry we do not accept contract!'
        );
        _;
    }
    /// @dev Checks that the contract is in an initialized state.
    ///
    /// This is used over a modifier to reduce the size of the contract
    modifier expectInitialized() {
        require(initialized, 'Alchemist: not initialized.');
        _;
    }

    /// @dev Checks that the current message sender or caller is a specific address.
    ///
    /// @param _expectedCaller the expected caller.
    function _expectCaller(address _expectedCaller) internal {
        require(msg.sender == _expectedCaller, '');
    }

    /// @dev Checks that the current message sender or caller is the governance address.
    ///
    ///
    modifier onlyGov() {
        require(msg.sender == governance, 'Alchemist: only governance.');
        _;
    }

    /// @dev Updates the active vault.
    ///
    /// This function reverts if the vault adapter is the zero address, if the token that the vault adapter accepts
    /// is not the token that this contract defines as the parent asset, or if the contract has not yet been initialized.
    ///
    /// @param _adapter the adapter for the new active vault.
    function _updateActiveVault(IVaultAdapter _adapter) internal {
        require(
            _adapter != IVaultAdapter(ZERO_ADDRESS),
            'Alchemist: active vault address cannot be 0x0.'
        );
        require(_adapter.token() == token, 'Alchemist: token mismatch.');

        _vaults.push(AlchemistVault.Data({adapter: _adapter, totalDeposited: 0}));

        emit ActiveVaultUpdated(_adapter);
    }

    /// @dev Recalls an amount of funds from a vault to this contract.
    ///
    /// @param _vaultId the identifier of the recall funds from.
    /// @param _amount  the amount of funds to recall from the vault.
    ///
    /// @return the amount of funds that were recalled from the vault to this contract and the decreased vault value.
    function _recallFunds(uint256 _vaultId, uint256 _amount)
        internal
        returns (uint256, uint256)
    {
        require(
            emergencyExit || msg.sender == governance || _vaultId != _vaults.lastIndex(),
            'Alchemist: not an emergency, not governance, and user does not have permission to recall funds from active vault'
        );

        AlchemistVault.Data storage _vault = _vaults.get(_vaultId);
        (uint256 _withdrawnAmount, uint256 _decreasedValue) = _vault.withdraw(
            address(this),
            _amount
        );

        emit FundsRecalled(_vaultId, _withdrawnAmount, _decreasedValue);

        return (_withdrawnAmount, _decreasedValue);
    }

    /// @dev Attempts to withdraw funds from the active vault to the recipient.
    ///
    /// Funds will be first withdrawn from this contracts balance and then from the active vault. This function
    /// is different from `recallFunds` in that it reduces the total amount of deposited tokens by the decreased
    /// value of the vault.
    ///
    /// @param _recipient the account to withdraw the funds to.
    /// @param _amount    the amount of funds to withdraw.
    function _withdrawFundsTo(address _recipient, uint256 _amount)
        internal
        returns (uint256, uint256)
    {
        // Pull the funds from the buffer.
        uint256 _bufferedAmount = Math.min(_amount, token.balanceOf(address(this)));

        if (_recipient != address(this)) {
            token.safeTransfer(_recipient, _bufferedAmount);
        }

        uint256 _totalWithdrawn = _bufferedAmount;
        uint256 _totalDecreasedValue = _bufferedAmount;

        uint256 _remainingAmount = _amount.sub(_bufferedAmount);

        // Pull the remaining funds from the active vault.
        if (_remainingAmount > 0) {
            AlchemistVault.Data storage _activeVault = _vaults.last();
            (uint256 _withdrawAmount, uint256 _decreasedValue) = _activeVault.withdraw(
                _recipient,
                _remainingAmount
            );

            _totalWithdrawn = _totalWithdrawn.add(_withdrawAmount);
            _totalDecreasedValue = _totalDecreasedValue.add(_decreasedValue);
        }

        totalDeposited = totalDeposited.sub(_totalDecreasedValue);

        return (_totalWithdrawn, _totalDecreasedValue);
    }
}",7461
RealWorld_BA_56_PickleMasterChef_RealWord_20240821174215.log,56,PickleMasterChef,4697,4572,9269,74.0,0.114925,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

interface PickleMasterChef {
    function deposit(uint _poolId, uint _amount) external;
    function withdraw(uint _poolId, uint _amount) external;
    function pendingPickle(uint _pid, address _user) external view returns (uint);
    function userInfo(uint _pid, address _user) external view returns (uint amount, uint rewardDebt);
    function emergencyWithdraw(uint _pid) external;
}",103
RealWorld_BA_57_ISwap_RealWord_20240821185702.log,57,ISwap,5969,5128,11097,100.0,0.132405,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

interface ISwap {
    function get_virtual_price() external view returns (uint);
    function exchange(int128 i, int128 j, uint dx, uint min_dy) external;
}

interface ISaddleSwap {
    function getVirtualPrice() external view returns (uint);
}

interface renDeposit {
    function add_liquidity(uint[2] calldata amounts, uint min_mint_amount) external returns (uint);
}

interface sbtcDeposit {
    function add_liquidity(uint[3] calldata amounts, uint min_mint_amount) external returns (uint);
}

interface tbtcDeposit {
    function add_liquidity(uint[4] calldata amounts, uint min_mint_amount) external returns (uint);
}",163
RealWorld_BA_57_ICore_RealWord_20240821185237.log,57,ICore,5569,4779,10348,83.0,0.123425,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

interface ICore {
    function mint(uint btc, address account, bytes32[] calldata merkleProof) external returns (uint);
    function redeem(uint btc, address account) external returns (uint);
    function btcToBbtc(uint btc) external view returns (uint, uint);
    function bBtcToBtc(uint bBtc) external view returns (uint btc, uint fee);
    function pricePerShare() external view returns (uint);
}",110
RealWorld_BA_57_Swap_RealWord_20240821183339.log,57,Swap,4462,4523,8985,89.0,0.11277,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import {ISwap} from ""../interfaces/ISwap.sol"";

contract Swap is ISwap {
    function get_virtual_price() override external view returns (uint) {
        return 1e18;
    }

    function exchange(int128 i, int128 j, uint dx, uint min_dy) override external {}
}",80
RealWorld_BA_57_IERCProxy_RealWord_20240821184639.log,57,IERCProxy,3952,4320,8272,76.0,0.10616,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

interface IERCProxy {
    function proxyType() external pure returns (uint proxyTypeId);
    function implementation() external view returns (address codeAddr);
}",47
RealWorld_BA_57_Rebalance_RealWord_20240821182204.log,57,Rebalance,14359,4943,19302,99.0,0.170655,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;
pragma experimental ABIEncoderV2;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20, SafeMath} from ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import {ISett} from ""./interfaces/ISett.sol"";
import {IBadgerSettPeak, IByvWbtcPeak} from ""./interfaces/IPeak.sol"";

import {ICurveFi, Zap} from ""./Zap.sol"";

import ""hardhat/console.sol"";

contract Rebalance {
    using SafeERC20 for IERC20;
    using SafeMath for uint;

    IBadgerSettPeak public constant settPeak = IBadgerSettPeak(0x41671BA1abcbA387b9b2B752c205e22e916BE6e3);
    IByvWbtcPeak public constant byvWbtcPeak = IByvWbtcPeak(0x825218beD8BE0B30be39475755AceE0250C50627);
    IERC20 public constant ibbtc = IERC20(0xc4E15973E6fF2A35cC804c2CF9D2a1b817a8b40F);
    IERC20 public constant wbtc = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);

    IZap public constant zap = IZap(0x4459A591c61CABd905EAb8486Bf628432b15C8b1);

    function cycleWithSett(uint poolId, uint amount) external {
        Zap.Pool memory pool = zap.pools(poolId);
        pool.lpToken.safeTransferFrom(msg.sender, address(this), amount);
        pool.lpToken.safeApprove(address(pool.sett), amount);
        pool.sett.deposit(amount);

        amount = pool.sett.balanceOf(address(this));
        IERC20(address(pool.sett)).safeApprove(address(settPeak), amount);
        uint _ibbtc = settPeak.mint(poolId, amount, new bytes32[](0));
        _redeem(_ibbtc, msg.sender);
    }

    function cycleWithWbtc(uint poolId, uint idx, uint amount) external {
        wbtc.safeTransferFrom(msg.sender, address(this), amount);
        wbtc.approve(address(zap), amount);
        uint _ibbtc = zap.mint(wbtc, amount, poolId, idx, 0);
        _redeem(_ibbtc, msg.sender);
    }

    function _redeem(uint _ibbtc, address user) internal {
        ibbtc.safeApprove(address(zap), _ibbtc);
        uint _wbtc = zap.redeem(wbtc, _ibbtc, 3, 0, 0); // redeem from byvwbtc
        wbtc.safeTransfer(user, _wbtc);
    }
}

interface IZap {
    function pools(uint idx) external returns(Zap.Pool memory);

    function mint(IERC20 token, uint amount, uint poolId, uint idx, uint minOut)
        external
        returns(uint _ibbtc);

    function redeem(IERC20 token, uint amount, uint poolId, int128 idx, uint minOut)
        external
        returns(uint out);
}",733
RealWorld_BA_57_GuestList_RealWord_20240821184327.log,57,GuestList,25671,5762,31433,85.0,0.243595,"// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.6.0 <0.7.0;
pragma experimental ABIEncoderV2;

import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {MerkleProof} from ""@openzeppelin/contracts/cryptography/MerkleProof.sol"";
import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";

import {IbBTC} from ""../interfaces/IbBTC.sol"";

/**
 * @notice A basic guest list contract for testing.
 * @dev For a Vyper implementation of this contract containing additional
 * functionality, see https://github.com/banteg/guest-list/blob/master/contracts/GuestList.vy
 * The owner can invite arbitrary guests
 * A guest can be added permissionlessly with proof of inclusion in current merkle set
 * The owner can change the merkle root at any time
 * Merkle-based permission that has been claimed cannot be revoked permissionlessly.
 * Any guests can be revoked by the owner at-will
 * The TVL cap is based on the number of want tokens in the underlying vaults.
 * This can only be made more permissive over time. If decreased, existing TVL is maintained and no deposits are possible until the TVL has gone below the threshold
 * A variant of the yearn AffiliateToken that supports guest list control of deposits
 * A guest list that gates access by merkle root and a TVL cap
 */
contract GuestList is Ownable {
    using SafeMath for uint;

    IbBTC public immutable bBTC;

    bytes32 public guestRoot;
    uint public userDepositCap;
    uint public totalDepositCap;

    mapping(address => bool) public guests;

    event ProveInvitation(address indexed account, bytes32 indexed guestRoot);
    event SetGuestRoot(bytes32 indexed guestRoot);
    event SetUserDepositCap(uint cap);
    event SetTotalDepositCap(uint cap);

    constructor(address _bBTC) public {
        bBTC = IbBTC(_bBTC);
    }

    function remainingTotalDepositAllowed() public view returns (uint) {
        return totalDepositCap.sub(bBTC.totalSupply());
    }

    function remainingUserDepositAllowed(address user) public view returns (uint) {
        return userDepositCap.sub(bBTC.balanceOf(user));
    }

    /**
     * @notice Invite guests or kick them from the party.
     * @param _guests The guests to add or update.
     * @param _invited A flag for each guest at the matching index, inviting or
     * uninviting the guest.
     */
    function setGuests(address[] calldata _guests, bool[] calldata _invited) external onlyOwner {
        _setGuests(_guests, _invited);
    }

    /**
     * @notice Permissionly prove an address is included in the current merkle root, thereby granting access
     * @notice Note that the list is designed to ONLY EXPAND in future instances
     * @notice The admin does retain the ability to ban individual addresses
     */
    function proveInvitation(address account, bytes32[] calldata merkleProof) public {
        // Verify Merkle Proof
        require(verifyInvitationProof(account, merkleProof));

        address[] memory accounts = new address[](1);
        bool[] memory invited = new bool[](1);

        accounts[0] = account;
        invited[0] = true;

        _setGuests(accounts, invited);

        emit ProveInvitation(account, guestRoot);
    }

    /**
     * @notice Set the merkle root to verify invitation proofs against.
     * @notice Note that accounts not included in the root will still be invited if their inviation was previously approved.
     * @notice Setting to 0 removes proof verification versus the root, opening access
     */
    function setGuestRoot(bytes32 guestRoot_) external onlyOwner {
        guestRoot = guestRoot_;

        emit SetGuestRoot(guestRoot);
    }

    function setUserDepositCap(uint cap_) external onlyOwner {
        userDepositCap = cap_;

        emit SetUserDepositCap(userDepositCap);
    }

    function setTotalDepositCap(uint cap_) external onlyOwner {
        totalDepositCap = cap_;

        emit SetTotalDepositCap(totalDepositCap);
    }

    /**
     * @notice Check if a guest with a bag of a certain size is allowed into
     * the party.
     * @dev Note that `_amount` isn't checked to keep test setup simple, since
     * from the wrapper tests' perspective this is a pass/fail call anyway.
     * @param _guest The guest's address to check.
     */
    function authorized(address _guest, uint _amount, bytes32[] calldata _merkleProof) external view returns (bool) {
        // Yes: If the user is on the list, and under the cap
        // Yes: If the user is not on the list, supplies a valid proof (thereby being added to the list), and is under the cap
        // No: If the user is not on the list, does not supply a valid proof, or is over the cap
        bool invited = guests[_guest];

        // If there is no guest root, all users are invited
        if (!invited && guestRoot == bytes32(0)) {
            invited = true;
        }

        // If the user is not already invited and there is an active guestList, require verification of merkle proof to grant temporary invitation (does not set storage variable)
        if (!invited && guestRoot != bytes32(0)) {
            // Will revert on invalid proof
            invited = verifyInvitationProof(_guest, _merkleProof);
        }

        // If the user was previously invited, or proved invitiation via list, verify if the amount to deposit keeps them under the cap
        if (invited && remainingUserDepositAllowed(_guest) >= _amount && remainingTotalDepositAllowed() >= _amount) {
            return true;
        } else {
            return false;
        }
    }

    function _setGuests(address[] memory _guests, bool[] memory _invited) internal {
        require(_guests.length == _invited.length);
        for (uint i = 0; i < _guests.length; i++) {
            if (_guests[i] == address(0)) {
                break;
            }
            guests[_guests[i]] = _invited[i];
        }
    }

    function verifyInvitationProof(address account, bytes32[] calldata merkleProof) public view returns (bool) {
        bytes32 node = keccak256(abi.encodePacked(account));
        return MerkleProof.verify(merkleProof, guestRoot, node);
    }
}",1417
RealWorld_BA_57_GovernableProxy_RealWord_20240821184936.log,57,GovernableProxy,7287,5051,12338,98.0,0.137455,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

contract GovernableProxy {
    bytes32 constant OWNER_SLOT = keccak256(""proxy.owner"");

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() internal {
        _transferOwnership(msg.sender);
    }

    modifier onlyGovernance() {
        require(owner() == msg.sender, ""NOT_OWNER"");
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns(address _owner) {
        bytes32 position = OWNER_SLOT;
        assembly {
            _owner := sload(position)
        }
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function transferOwnership(address newOwner) external onlyGovernance {
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), ""OwnableProxy: new owner is the zero address"");
        emit OwnershipTransferred(owner(), newOwner);
        bytes32 position = OWNER_SLOT;
        assembly {
            sstore(position, newOwner)
        }
    }
}",250
RealWorld_BA_57_IbBTC_RealWord_20240821185541.log,57,IbBTC,4195,4628,8823,79.0,0.113535,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IbBTC is IERC20 {
    function mint(address account, uint amount) external;
    function burn(address account, uint amount) external;
}",70
RealWorld_BA_57_Sett_RealWord_20240821182947.log,57,Sett,8056,5363,13419,101.0,0.14754,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import {ERC20} from ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {ISett} from ""../interfaces/ISett.sol"";

contract Sett is ERC20, ISett {
    IERC20 token;

    constructor(IERC20 _token) public ERC20(""Sett"", ""sett"") {
        token = _token;
    }

    function deposit(uint256 _amount) override external {
        token.transferFrom(msg.sender, address(this), _amount);
        _mint(msg.sender, _amount);
    }

    function withdraw(uint256 _shares) override external {
        _burn(msg.sender, _shares);
        token.transfer(msg.sender, _shares);
    }

    function withdrawAll() override external {
        uint256 _shares = balanceOf(msg.sender);
        _burn(msg.sender, _shares);
        token.transfer(msg.sender, _shares);
    }

    function approveContractAccess(address account) override external {}

    function getPricePerFullShare() override external view returns (uint256) {
        return 1e18;
    }

    function balance() override external view returns (uint256) {
        return token.balanceOf(address(this));
    }

    function pricePerShare() override external view returns (uint256) {}
    function withdrawalFee() override external view returns (uint256) {}
}",311
RealWorld_BA_57_IbyvWbtc_RealWord_20240821185402.log,57,IbyvWbtc,4978,5241,10219,97.0,0.12971,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IbyvWbtc is IERC20 {
    function pricePerShare() external view returns (uint);
    function deposit(bytes32[] calldata merkleProof) external;
    function withdraw() external returns (uint);
}",86
RealWorld_BA_57_IPeak_RealWord_20240821185844.log,57,IPeak,8329,5604,13933,115.0,0.153725,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

interface IPeak {
    function portfolioValue() external view returns (uint);
}

interface IBadgerSettPeak is IPeak {
    function mint(uint poolId, uint inAmount, bytes32[] calldata merkleProof)
        external
        returns(uint outAmount);

    function calcMint(uint poolId, uint inAmount)
        external
        view
        returns(uint bBTC, uint fee);

    function redeem(uint poolId, uint inAmount)
        external
        returns (uint outAmount);

    function calcRedeem(uint poolId, uint bBtc)
        external
        view
        returns(uint sett, uint fee, uint max);
}

interface IByvWbtcPeak is IPeak {
    function mint(uint inAmount, bytes32[] calldata merkleProof)
        external
        returns(uint outAmount);

    function calcMint(uint inAmount)
        external
        view
        returns(uint bBTC, uint fee);

    function redeem(uint inAmount)
        external
        returns (uint outAmount);

    function calcRedeem(uint bBtc)
        external
        view
        returns(uint sett, uint fee, uint max);
}",263
RealWorld_BA_57_Proxy_RealWord_20240821184757.log,57,Proxy,8081,5677,13758,97.0,0.153945,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import {IERCProxy} from ""./IERCProxy.sol"";

abstract contract Proxy is IERCProxy {
    function delegatedFwd(address _dst, bytes memory _calldata) internal {
        // solium-disable-next-line security/no-inline-assembly
        assembly {
            let result := delegatecall(
                sub(gas(), 10000),
                _dst,
                add(_calldata, 0x20),
                mload(_calldata),
                0,
                0
            )
            let size := returndatasize()

            let ptr := mload(0x40)
            returndatacopy(ptr, 0, size)

            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.
            // if the call returned error data, forward it
            switch result
                case 0 {
                    revert(ptr, size)
                }
                default {
                    return(ptr, size)
                }
        }
    }

    function proxyType() override external pure returns (uint proxyTypeId) {
        // Upgradeable proxy
        proxyTypeId = 2;
    }

    function implementation() override virtual public view returns (address);
}",259
RealWorld_BA_57_ISett_RealWord_20240821190041.log,57,ISett,5841,5648,11489,110.0,0.142165,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface ISett is IERC20 {
    function deposit(uint256 _amount) external;
    function withdraw(uint256 _shares) external;
    function withdrawAll() external;
    function approveContractAccess(address account) external;

    function getPricePerFullShare() external view returns (uint256);
    function balance() external view returns (uint256);

    // byvwbtc
    function pricePerShare() external view returns (uint256);
    function withdrawalFee() external view returns (uint256);
}",143
RealWorld_BA_57_Core_RealWord_20240821182752.log,57,Core,30517,5705,36222,113.0,0.266685,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20, SafeMath} from ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import {Math} from ""@openzeppelin/contracts/math/Math.sol"";

import {IPeak} from ""./interfaces/IPeak.sol"";
import {IbBTC} from ""./interfaces/IbBTC.sol"";
import {ICore} from ""./interfaces/ICore.sol"";
import {GovernableProxy} from ""./common/proxy/GovernableProxy.sol"";

contract Core is GovernableProxy, ICore {
    using SafeERC20 for IERC20;
    using SafeMath for uint;
    using Math for uint;

    uint constant PRECISION = 1e4;

    IbBTC public immutable bBTC;

    BadgerGuestListAPI public guestList;

    enum PeakState { Extinct, Active, Dormant }
    mapping(address => PeakState) public peaks;

    address[] public peakAddresses;
    address public feeSink;
    uint public mintFee;
    uint public redeemFee;
    uint public accumulatedFee;

    uint256[50] private __gap;

    // END OF STORAGE VARIABLES

    event PeakWhitelisted(address indexed peak);
    event FeeCollected(uint amount);

    /**
    * @param _bBTC bBTC token address
    */
    constructor(address _bBTC) public {
        require(_bBTC != address(0), ""NULL_ADDRESS"");
        bBTC = IbBTC(_bBTC);
    }

    /**
    * @notice Mint bBTC
    * @dev Only whitelisted peaks can call this function
    * @param btc BTC amount supplied, scaled by 1e18
    * @return bBtc Badger BTC that was minted
    */
    function mint(uint btc, address account, bytes32[] calldata merkleProof)
        override
        external
        returns(uint)
    {
        require(peaks[msg.sender] == PeakState.Active, ""PEAK_INACTIVE"");
        if (address(guestList) != address(0)) {
            require(
                guestList.authorized(account, btc, merkleProof),
                ""guest-list-authorization""
            );
        }
        (uint bBtc, uint fee) = btcToBbtc(btc);
        require(bBtc > 0, ""MINTING_0_bBTC"");
        accumulatedFee = accumulatedFee.add(fee);
        bBTC.mint(account, bBtc);
        return bBtc;
    }

    /**
    * @param btc BTC amount supplied
    */
    function btcToBbtc(uint btc) override public view returns (uint bBtc, uint fee) {
        uint _totalSupply = IERC20(address(bBTC)).totalSupply().add(accumulatedFee);
        if (_totalSupply > 0) {
            bBtc = btc.mul(_totalSupply).div(totalSystemAssets());
        } else {
            bBtc = btc;
        }
        fee = bBtc.mul(mintFee).div(PRECISION);
        bBtc = bBtc.sub(fee);
    }

    /**
    * @notice Redeem bBTC
    * @dev Only whitelisted peaks can call this function
    * @param bBtc bBTC amount to redeem
    * @return btc amount redeemed, scaled by 1e36
    */
    function redeem(uint bBtc, address account) override external returns (uint) {
        require(bBtc > 0, ""REDEEMING_0_bBTC"");
        require(peaks[msg.sender] != PeakState.Extinct, ""PEAK_EXTINCT"");
        (uint btc, uint fee) = bBtcToBtc(bBtc);
        accumulatedFee = accumulatedFee.add(fee);
        bBTC.burn(account, bBtc);
        return btc;
    }

    /**
    * @return btc amount redeemed, scaled by 1e36
    */
    function bBtcToBtc(uint bBtc) override public view returns (uint btc, uint fee) {
        fee = bBtc.mul(redeemFee).div(PRECISION);
        btc = bBtc.sub(fee).mul(pricePerShare());
    }

    function pricePerShare() override public view returns (uint) {
        uint _totalSupply = IERC20(address(bBTC)).totalSupply().add(accumulatedFee);
        if (_totalSupply > 0) {
            return totalSystemAssets().mul(1e18).div(_totalSupply);
        }
        return 1e18;
    }

    /**
    * @notice Collect all the accumulated fee (denominated in bBTC)
    */
    function collectFee() external {
        require(feeSink != address(0), ""NULL_ADDRESS"");
        uint _fee = accumulatedFee;
        require(_fee > 0, ""NO_FEE"");
        accumulatedFee = 0;
        bBTC.mint(feeSink, _fee);
        emit FeeCollected(_fee);
    }

    function totalSystemAssets() public view returns (uint totalAssets) {
        address[] memory _peakAddresses = peakAddresses;
        uint numPeaks = _peakAddresses.length;
        for (uint i = 0; i < numPeaks; i++) {
            if (peaks[_peakAddresses[i]] == PeakState.Extinct) {
                continue;
            }
            totalAssets = totalAssets.add(
                IPeak(_peakAddresses[i]).portfolioValue()
            );
        }
    }

    /* ##### Governance ##### */

    /**
    * @notice Whitelist a new peak
    * @param peak Address of the contract that interfaces with the 3rd-party protocol
    */
    function whitelistPeak(address peak)
        external
        onlyGovernance
    {
        require(
            peaks[peak] == PeakState.Extinct,
            ""DUPLICATE_PEAK""
        );

        address[] memory _peakAddresses = peakAddresses;
        uint numPeaks = _peakAddresses.length;
        for (uint i = 0; i < numPeaks; i++) {
            require(_peakAddresses[i] != peak, ""USE_setPeakStatus"");
        }

        IPeak(peak).portfolioValue(); // sanity check
        peakAddresses.push(peak);
        peaks[peak] = PeakState.Active;
        emit PeakWhitelisted(peak);
    }

    /**
    * @notice Change a peaks status
    */
    function setPeakStatus(address peak, PeakState state)
        external
        onlyGovernance
    {
        require(
            peaks[peak] != PeakState.Extinct,
            ""Peak is extinct""
        );
        if (state == PeakState.Extinct) {
            require(IPeak(peak).portfolioValue() <= 1e15, ""NON_TRIVIAL_FUNDS_IN_PEAK"");
        }
        peaks[peak] = state;
    }

    /**
    * @notice Set config
    * @param _mintFee Mint Fee
    * @param _redeemFee Redeem Fee
    * @param _feeSink Address of the EOA/contract where accumulated fee will be transferred
    */
    function setConfig(
        uint _mintFee,
        uint _redeemFee,
        address _feeSink
    )
        external
        onlyGovernance
    {
        require(
            _mintFee <= PRECISION
            && _redeemFee <= PRECISION,
            ""INVALID_PARAMETERS""
        );
        require(_feeSink != address(0), ""NULL_ADDRESS"");

        mintFee = _mintFee;
        redeemFee = _redeemFee;
        feeSink = _feeSink;
    }

    function setGuestList(address _guestList) external onlyGovernance {
        guestList = BadgerGuestListAPI(_guestList);
    }
}

interface BadgerGuestListAPI {
    function authorized(address guest, uint256 amount, bytes32[] calldata merkleProof) external view returns (bool);
}",1691
RealWorld_BA_57_CurveLPToken_RealWord_20240821183510.log,57,CurveLPToken,4611,5048,9659,76.0,0.124015,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import {ERC20} from ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract CurveLPToken is ERC20 {

    constructor() ERC20(""Curve LP"", ""crvLP"") public {}

    function mint(address account, uint amount) public {
        _mint(account, amount);
    }
}",83
RealWorld_BA_57_SaddlePeak_RealWord_20240821184153.log,57,SaddlePeak,21805,5556,27361,92.0,0.220145,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;
pragma experimental ABIEncoderV2;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20, SafeMath} from ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import {Math} from ""@openzeppelin/contracts/math/Math.sol"";

import {ISaddleSwap} from ""../interfaces/ISwap.sol"";
import {ICore} from ""../interfaces/ICore.sol"";
import {ISett} from ""../interfaces/ISett.sol"";
import {IPeak} from ""../interfaces/IPeak.sol"";
import {AccessControlDefended} from ""../common/AccessControlDefended.sol"";

contract SaddlePeak is AccessControlDefended, IPeak {
    using SafeERC20 for IERC20;
    using SafeERC20 for ISett;
    using SafeMath for uint;
    using Math for uint;

    ICore public immutable core;

    struct CurvePool {
        IERC20 lpToken;
        ISaddleSwap swap;
    }
    mapping(uint => CurvePool) public pools;
    uint public numPools;

    // END OF STORAGE VARIABLES

    event Mint(address account, uint amount);
    event Redeem(address account, uint amount);

    /**
    * @param _core Address of the the Core contract
    */
    constructor(address _core) public {
        core = ICore(_core);
    }

    /**
    * @notice Mint bBTC with Sett LP token
    * @dev Invoking pool.lpToken.safeTransferFrom() before core.mint(), will mess up core.totalSystemAssets() calculation
    * @param poolId System internal ID of the whitelisted curve pool
    * @param inAmount Amount of Sett LP token to mint bBTC with
    * @return outAmount Amount of bBTC minted to user's account
    */
    function mint(uint poolId, uint inAmount, bytes32[] calldata merkleProof)
        external
        defend
        blockLocked
        returns(uint outAmount)
    {
        _lockForBlock(msg.sender);
        CurvePool memory pool = pools[poolId];
        outAmount = core.mint(_settToBtc(pool, inAmount), msg.sender, merkleProof);
        // will revert if user passed an unsupported poolId
        pool.lpToken.safeTransferFrom(msg.sender, address(this), inAmount);
        emit Mint(msg.sender, outAmount);
    }

    /**
    * @notice Redeem bBTC in Sett LP tokens
    * @dev There might not be enough Sett LP to fulfill the request, in which case the transaction will revert
    *      Invoking pool.lpToken.safeTransfer() before core.redeem(), will mess up core.totalSystemAssets() calculation
    * @param poolId System internal ID of the whitelisted curve pool
    * @param inAmount Amount of bBTC to redeem
    * @return outAmount Amount of Sett LP token
    */
    function redeem(uint poolId, uint inAmount)
        external
        defend
        blockLocked
        returns (uint outAmount)
    {
        _lockForBlock(msg.sender);
        CurvePool memory pool = pools[poolId];
        outAmount = _btcToSett(pool, core.redeem(inAmount, msg.sender));
        // will revert if the contract has insufficient funds.
        pool.lpToken.safeTransfer(msg.sender, outAmount);
        emit Redeem(msg.sender, inAmount);
    }

    /* ##### View ##### */

    function calcMint(uint poolId, uint inAmount) external view returns(uint, uint) {}

    function calcRedeem(uint poolId, uint bBtc) external view returns(uint,uint,uint) {}

    function portfolioValue()
        override
        external
        view
        returns (uint assets)
    {
        CurvePool memory pool;
        // We do not expect to have more than 3-4 pools, so this loop should be fine
        for (uint i = 0; i < numPools; i++) {
            pool = pools[i];
            assets = assets
                .add(
                    _settToBtc(
                        pool,
                        pool.lpToken.balanceOf(address(this))
                    )
                );
        }
    }

    /**
    * @param btc BTC amount scaled by 1e18
    */
    function _btcToSett(CurvePool memory pool, uint btc)
        internal
        view
        returns(uint)
    {
        return btc
            .div(pool.swap.getVirtualPrice());
    }

    function _settToBtc(CurvePool memory pool, uint amount)
        internal
        view
        returns(uint)
    {
        return amount
            .mul(pool.swap.getVirtualPrice())
            .div(1e18);
    }

    /* ##### Admin ##### */

    /**
    * @notice Manage whitelisted curve pools and their respective sett vaults
    */
    function modifyWhitelistedCurvePools(
        CurvePool[] calldata _pools
    )
        external
        onlyGovernance
    {
        numPools = _pools.length;
        CurvePool memory pool;
        for (uint i = 0; i < numPools; i++) {
            pool = _pools[i];
            require(
                address(pool.lpToken) != address(0)
                && address(pool.swap) != address(0),
                ""NULL_ADDRESS""
            );
            pools[i] = CurvePool(pool.lpToken, pool.swap);
        }
    }
}",1171
RealWorld_BA_57_Zap_RealWord_20240821182523.log,57,Zap,74171,5561,79732,147.0,0.482075,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

// unused imports; required for a forced contract compilation
import {TransparentUpgradeableProxy} from ""@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol"";
import {ProxyAdmin} from ""@openzeppelin/contracts/proxy/ProxyAdmin.sol"";

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20, SafeMath} from ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import {Initializable} from ""@openzeppelin/contracts/proxy/Initializable.sol"";
import {Pausable} from ""@openzeppelin/contracts/utils/Pausable.sol"";

import {AccessControlDefendedBase} from ""./common/AccessControlDefended.sol"";

import {ISett} from ""./interfaces/ISett.sol"";
import {IBadgerSettPeak, IByvWbtcPeak} from ""./interfaces/IPeak.sol"";
import {IbBTC} from ""./interfaces/IbBTC.sol"";
import {IbyvWbtc} from ""./interfaces/IbyvWbtc.sol"";

contract Zap is Initializable, Pausable, AccessControlDefendedBase {
    using SafeERC20 for IERC20;
    using SafeMath for uint;

    IBadgerSettPeak public constant settPeak = IBadgerSettPeak(0x41671BA1abcbA387b9b2B752c205e22e916BE6e3);
    IByvWbtcPeak public constant byvWbtcPeak = IByvWbtcPeak(0x825218beD8BE0B30be39475755AceE0250C50627);
    IERC20 public constant ibbtc = IERC20(0xc4E15973E6fF2A35cC804c2CF9D2a1b817a8b40F);
    IERC20 public constant ren = IERC20(0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D);
    IERC20 public constant wbtc = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);
    IController public constant controller = IController(0x63cF44B2548e4493Fd099222A1eC79F3344D9682);

    struct Pool {
        IERC20 lpToken;
        ICurveFi deposit;
        ISett sett;
    }
    Pool[4] public pools;

    address public governance;

    modifier onlyGovernance() {
        require(governance == msg.sender, ""NOT_OWNER"");
        _;
    }

    function init(address _governance) initializer external {
        _setGovernance(_governance);
        pools[0] = Pool({ // crvRenWBTC [ ren, wbtc ]
            lpToken: IERC20(0x49849C98ae39Fff122806C06791Fa73784FB3675),
            deposit: ICurveFi(0x93054188d876f558f4a66B2EF1d97d16eDf0895B),
            sett: ISett(0x6dEf55d2e18486B9dDfaA075bc4e4EE0B28c1545)
        });
        pools[1] = Pool({ // crvRenWSBTC [ ren, wbtc, sbtc ]
            lpToken: IERC20(0x075b1bb99792c9E1041bA13afEf80C91a1e70fB3),
            deposit: ICurveFi(0x7fC77b5c7614E1533320Ea6DDc2Eb61fa00A9714),
            sett: ISett(0xd04c48A53c111300aD41190D63681ed3dAd998eC)
        });
        pools[2] = Pool({ // tbtc-sbtcCrv [ tbtc, ren, wbtc, sbtc ]
            lpToken: IERC20(0x64eda51d3Ad40D56b9dFc5554E06F94e1Dd786Fd),
            deposit: ICurveFi(0xaa82ca713D94bBA7A89CEAB55314F9EfFEdDc78c),
            sett: ISett(0xb9D076fDe463dbc9f915E5392F807315Bf940334)
        });
        pools[3] = Pool({ // Exclusive to wBTC
            lpToken: wbtc,
            deposit: ICurveFi(0x0),
            sett: ISett(0x4b92d19c11435614CD49Af1b589001b7c08cD4D5) // byvWbtc
        });

        // Since we don't hold any tokens in this contract, we can optimize gas usage in mint calls by providing infinite approvals
        for (uint i = 0; i < pools.length; i++) {
            Pool memory pool = pools[i];
            pool.lpToken.safeApprove(address(pool.sett), uint(-1));
            if (i < 3) {
                ren.safeApprove(address(pool.deposit), uint(-1));
                wbtc.safeApprove(address(pool.deposit), uint(-1));
                IERC20(address(pool.sett)).safeApprove(address(settPeak), uint(-1));
            } else {
                IERC20(address(pool.sett)).safeApprove(address(byvWbtcPeak), uint(-1));
            }
        }
        pools[2].lpToken.safeApprove(address(pools[2].deposit), uint(-1));
    }

    /**
    * @notice Mint ibbtc with wBTC / renBTC
    * @param token wBTC or renBTC address
    * @param amount wBTC or renBTC amount
    * @param poolId 0=crvRenWBTC, 1=crvRenWSBTC, 2=tbtc-sbtcCrv, 3=yvWbtc
    * @param idx Index of the token in the curve pool while adding liquidity; redundant for yvWbtc
    * @param minOut Minimum amount of ibbtc to mint. Use for capping slippage while adding liquidity to curve pool.
    * @return _ibbtc Minted ibbtc amount
    */
    function mint(IERC20 token, uint amount, uint poolId, uint idx, uint minOut)
        external
        defend
        blockLocked
        whenNotPaused
        returns(uint _ibbtc)
    {
        token.safeTransferFrom(msg.sender, address(this), amount);

        Pool memory pool = pools[poolId];
        if (poolId < 3) { // setts
            _addLiquidity(pool.deposit, amount, poolId + 2, idx); // pools are such that the #tokens they support is +2 from their poolId.
            pool.sett.deposit(pool.lpToken.balanceOf(address(this)));
            _ibbtc = settPeak.mint(poolId, pool.sett.balanceOf(address(this)), new bytes32[](0));
        } else if (poolId == 3) { // byvwbtc
            IbyvWbtc(address(pool.sett)).deposit(new bytes32[](0)); // pulls all available
            _ibbtc = byvWbtcPeak.mint(pool.sett.balanceOf(address(this)), new bytes32[](0));
        } else {
            revert(""INVALID_POOL_ID"");
        }

        require(_ibbtc >= minOut, ""INSUFFICIENT_IBBTC""); // used for capping slippage in curve pools
        ibbtc.safeTransfer(msg.sender, _ibbtc);
    }

    /**
    * @dev Add liquidity to curve btc pools
    * @param amount wBTC / renBTC amount
    * @param pool Curve btc pool
    * @param numTokens # supported tokens for the curve pool
    * @param idx Index of the supported token in the curve pool in question
    */
    function _addLiquidity(ICurveFi pool, uint amount, uint numTokens, uint idx) internal {
        if (numTokens == 2) {
            uint[2] memory amounts;
            amounts[idx] = amount;
            pool.add_liquidity(amounts, 0);
        }

        if (numTokens == 3) {
            uint[3] memory amounts;
            amounts[idx] = amount;
            pool.add_liquidity(amounts, 0);
        }

        if (numTokens == 4) {
            uint[4] memory amounts;
            amounts[idx] = amount;
            pool.add_liquidity(amounts, 0);
        }
    }

    /**
    * @notice Calculate the most optimal route and expected ibbtc amount when minting with wBTC / renBtc.
    * @dev Use returned params poolId, idx and bBTC in the call to mint(...)
           The last param `minOut` in mint(...) should be a bit less than the returned bBTC value.
           For instance 0.2% - 1% lesser depending on slippage tolerange.
    * @param amount renBTC amount
    * @return poolId 0=crvRenWBTC, 1=crvRenWSBTC, 2=tbtc-sbtcCrv, 3=byvwbtc
    * @return idx Index of the supported token in the curve pool (poolId). Should be ignored for poolId=3
    * @return bBTC Expected ibbtc. Not for precise calculations. Doesn't factor in (deposit) fee charged by the curve pool / byvwbtc.
    * @return fee Fee being charged by ibbtc system. Denominated in corresponding sett token
    */
    function calcMint(address token, uint amount) external view returns(uint poolId, uint idx, uint bBTC, uint fee) {
        if (token == address(ren)) {
            return calcMintWithRen(amount);
        }
        if (token == address(wbtc)) {
            return calcMintWithWbtc(amount);
        }
        revert(""INVALID_TOKEN"");
    }

    /**
    * @notice Calculate mint through renWBTC pool route and expected ibbtc amount when minting with renBTC.
    * @dev Use returned params poolId, idx and bBTC in the call to mint(...)
           The last param `minOut` in mint(...) should be a bit more than the returned bBTC value.
           For instance 0.2% - 1% higher depending on slippage tolerange.
    * @param amount renBTC amount
    * @return poolId 0=crvRenWBTC, 1=crvRenWSBTC, 2=tbtc-sbtcCrv
    * @return idx Index of the supported token in the curve pool (poolId)
    * @return bBTC Expected ibbtc. Not for precise calculations. Doesn't factor in fee charged by the curve pool
    * @return fee Fee being charged by ibbtc system. Denominated in corresponding sett token
    */
    function calcMintWithRen(uint amount) public view returns(uint poolId, uint idx, uint bBTC, uint fee) {
        uint _ibbtc;
        uint _fee;

        // poolId=0, idx=0
        (bBTC, fee) = curveLPToIbbtc(0, pools[0].deposit.calc_token_amount([amount,0], true));
    }

    /**
    * @notice Calculate mint through renWBTC pool route and expected ibbtc amount when minting with wBTC.
    * @dev Use returned params poolId, idx and bBTC in the call to mint(...)
           The last param `minOut` in mint(...) should be a bit more than the returned bBTC value.
           For instance 0.2% - 1% higher depending on slippage tolerange.
    * @param amount renBTC amount
    * @return poolId 0=crvRenWBTC, 1=crvRenWSBTC, 2=tbtc-sbtcCrv, 3=byvwbtc
    * @return idx Index of the supported token in the curve pool (poolId). Should be ignored for poolId=3
    * @return bBTC Expected ibbtc. Not for precise calculations. Doesn't factor in (deposit) fee charged by the curve pool / byvwbtc.
    * @return fee Fee being charged by ibbtc system. Denominated in corresponding sett token
    */
    function calcMintWithWbtc(uint amount) public view returns(uint poolId, uint idx, uint bBTC, uint fee) {
        uint _ibbtc;
        uint _fee;

        // poolId=0
        (bBTC, fee) = curveLPToIbbtc(0, pools[0].deposit.calc_token_amount([0,amount], true));
        idx = 1;
    }

    /**
    * @dev Curve LP token amount to expected ibbtc amount
    */
    function curveLPToIbbtc(uint poolId, uint _lp) public view returns(uint bBTC, uint fee) {
        Pool memory pool = pools[poolId];
        uint _sett = _lp.mul(1e18).div(pool.sett.getPricePerFullShare());
        return settPeak.calcMint(poolId, _sett);
    }

    // Redeem Methods

    function redeem(IERC20 token, uint amount, uint poolId, int128 idx, uint minOut)
        external
        defend
        blockLocked
        whenNotPaused
        returns(uint out)
    {
        ibbtc.safeTransferFrom(msg.sender, address(this), amount);

        Pool memory pool = pools[poolId];
        if (poolId < 3) { // setts
            settPeak.redeem(poolId, amount);
            pool.sett.withdrawAll();
            pool.deposit.remove_liquidity_one_coin(pool.lpToken.balanceOf(address(this)), idx, minOut);
        } else if (poolId == 3) { // byvwbtc
            byvWbtcPeak.redeem(amount);
            IbyvWbtc(address(pool.sett)).withdraw(); // withdraws all available
        } else {
            revert(""INVALID_POOL_ID"");
        }
        out = token.balanceOf(address(this));
        token.safeTransfer(msg.sender, out);
    }

    /**
    * @notice Calculate redeem through renWBTC pool route and expected token amount when redeeming ibbtc.
    * @dev Use returned params poolId, idx and out in the call to redeem(...)
           The last param `redeem` in mint(...) should be a bit less than the returned `out` value.
           For instance 0.2% - 1% lesser depending on slippage tolerange.
    * @param amount ibbtc amount
    * @return poolId 0=crvRenWBTC, 1=crvRenWSBTC, 2=tbtc-sbtcCrv, 3=byvwbtc
    * @return idx Index of the supported token in the curve pool (poolId). Should be ignored for poolId=3
    * @return out Expected amount for token. Not for precise calculations. Doesn't factor in (deposit) fee charged by the curve pool / byvwbtc.
    * @return fee Fee being charged by ibbtc + setts. Denominated in corresponding sett token
    */
    function calcRedeem(address token, uint amount) external view returns(uint poolId, uint idx, uint out, uint fee) {
        if (token == address(ren)) {
            return calcRedeemInRen(amount);
        }
        if (token == address(wbtc)) {
            return calcRedeemInWbtc(amount);
        }
        revert(""INVALID_TOKEN"");
    }

    /**
    * @notice Calculate redeem through renWBTC pool route and expected renbtc amount when redeeming ibbtc.
    * @dev Use returned params poolId, idx and renAmount in the call to redeem(...)
           The last param `minOut` in redeem(...) should be a bit less than the returned renAmount value.
           For instance 0.2% - 1% lesser depending on slippage tolerange.
    * @param amount ibbtc amount
    * @return poolId 0=crvRenWBTC, 1=crvRenWSBTC, 2=tbtc-sbtcCrv
    * @return idx Index of the supported token in the curve pool (poolId)
    * @return renAmount Expected renBtc. Not for precise calculations. Doesn't factor in fee charged by the curve pool
    * @return fee Fee being charged by ibbtc system. Denominated in corresponding sett token
    */
    function calcRedeemInRen(uint amount) public view returns(uint poolId, uint idx, uint renAmount, uint fee) {
        uint _lp;
        uint _fee;
        uint _ren;

        // poolId=0, idx=0
        (_lp, fee) = ibbtcToCurveLP(0, amount);
        renAmount = pools[0].deposit.calc_withdraw_one_coin(_lp, 0);
    }

    /**
    * @notice Calculate the most optimal route and expected wbtc amount when redeeming ibbtc.
    * @dev Use returned params poolId, idx and wbtc in the call to redeem(...)
           The last param `minOut` in redeem(...) should be a bit less than the returned wbtc value.
           For instance 0.2% - 1% lesser depending on slippage tolerange.
    * @param amount ibbtc amount
    * @return poolId 0=crvRenWBTC, 1=crvRenWSBTC, 2=tbtc-sbtcCrv, 3=byvwbtc
    * @return idx Index of the supported token in the curve pool (poolId)
    * @return wBTCAmount Expected wbtc. Not for precise calculations. Doesn't factor in fee charged by the curve pool
    * @return fee Fee being charged by ibbtc system. Denominated in corresponding sett token
    */
    function calcRedeemInWbtc(uint amount) public view returns(uint poolId, uint idx, uint wBTCAmount, uint fee) {
        uint _lp;
        uint _fee;
        uint _wbtc;

        // poolId=0, idx=0
        (_lp, fee) = ibbtcToCurveLP(0, amount);
        wBTCAmount = pools[0].deposit.calc_withdraw_one_coin(_lp, 1);
        idx = 1;
    }

    function ibbtcToCurveLP(uint poolId, uint bBtc) public view returns(uint lp, uint fee) {
        uint sett;
        uint max;
        (sett,fee,max) = settPeak.calcRedeem(poolId, bBtc);
        Pool memory pool = pools[poolId];
        if (bBtc > max) {
            return (0,fee);
        } else {
            // pesimistically charge 0.5% on the withdrawal.
            // Actual fee might be lesser if the vault keeps keeps a buffer
            uint strategyFee = sett.mul(controller.strategies(pool.lpToken).withdrawalFee()).div(10000);
            lp = sett.sub(strategyFee).mul(pool.sett.getPricePerFullShare()).div(1e18);
            fee = fee.add(strategyFee);
        }
    }

    // Governance controls

    function setGovernance(address _governance) external onlyGovernance {
        _setGovernance(_governance);
    }

    function _setGovernance(address _governance) internal {
        require(_governance != address(0), ""NULL_ADDRESS"");
        governance = _governance;
    }

    function approveContractAccess(address account) external onlyGovernance {
        _approveContractAccess(account);
    }

    function revokeContractAccess(address account) external onlyGovernance {
        _revokeContractAccess(account);
    }

    function pause() external onlyGovernance {
        _pause();
    }

    function unpause() external onlyGovernance {
        _unpause();
    }
}

interface ICurveFi {
    function add_liquidity(uint[2] calldata amounts, uint min_mint_amount) external;
    function calc_token_amount(uint[2] calldata amounts, bool isDeposit) external view returns(uint);

    function add_liquidity(uint[3] calldata amounts, uint min_mint_amount) external;
    function calc_token_amount(uint[3] calldata amounts, bool isDeposit) external view returns(uint);

    function add_liquidity(uint[4] calldata amounts, uint min_mint_amount) external;
    function calc_token_amount(uint[4] calldata amounts, bool isDeposit) external view returns(uint);

    function remove_liquidity_one_coin(uint _token_amount, int128 i, uint min_amount) external;
    function calc_withdraw_one_coin(uint _token_amount, int128 i) external view returns(uint);
}

interface IStrategy {
    function withdrawalFee() external view returns(uint);
}

interface IController {
    function strategies(IERC20 token) external view returns(IStrategy);
}",4547
RealWorld_BA_57_BadgerYearnWbtcPeak_RealWord_20240821183629.log,57,BadgerYearnWbtcPeak,21947,5615,27562,115.0,0.222035,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;
pragma experimental ABIEncoderV2;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20, SafeMath} from ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import {Math} from ""@openzeppelin/contracts/math/Math.sol"";

import {AccessControlDefended} from ""../common/AccessControlDefended.sol"";
import {ICore} from ""../interfaces/ICore.sol"";
import {IbyvWbtc} from ""../interfaces/IbyvWbtc.sol"";
import {IByvWbtcPeak} from ""../interfaces/IPeak.sol"";

contract BadgerYearnWbtcPeak is AccessControlDefended, IByvWbtcPeak {
    using SafeERC20 for IERC20;
    using SafeERC20 for IbyvWbtc;

    using SafeMath for uint;
    using Math for uint;

    ICore public immutable core;
    IbyvWbtc public immutable byvWBTC;

    // END OF STORAGE VARIABLES

    event Mint(address account, uint ibBTC, uint byvWBTC);
    event Redeem(address account, uint ibBTC, uint byvWBTC);

    /**
    * @param _core Address of the the Core contract
    */
    constructor(address _core, address _byvWBTC) public {
        core = ICore(_core);
        byvWBTC = IbyvWbtc(_byvWBTC);
    }

    /**
    * @notice Mint bBTC with byvWBTC token
    * @dev Invoking byvWBTC.safeTransferFrom() before core.mint(), will mess up core.totalSystemAssets() calculation
    * @param inAmount Amount of byvWBTC token to mint bBTC with
    * @return outAmount Amount of bBTC minted to user's account
    */
    function mint(uint inAmount, bytes32[] calldata merkleProof)
        override
        external
        defend
        blockLocked
        returns(uint outAmount)
    {
        _lockForBlock(msg.sender);
        outAmount = core.mint(_byvWbtcToBtc(inAmount), msg.sender, merkleProof);
        byvWBTC.safeTransferFrom(msg.sender, address(this), inAmount);
        emit Mint(msg.sender, outAmount, inAmount);
    }

    /**
    * @notice Redeem bBTC in byvWBTC tokens
    * @dev There might not be enough byvWBTC to fulfill the request, in which case the transaction will revert
    *      Invoking byvWBTC.safeTransfer() before core.redeem(), will mess up core.totalSystemAssets() calculation
    * @param inAmount Amount of bBTC to redeem
    * @return outAmount Amount of byvWBTC token
    */
    function redeem(uint inAmount)
        override
        external
        defend
        blockLocked
        returns (uint outAmount)
    {
        _lockForBlock(msg.sender);
        outAmount = _btcTobyvWBTC(core.redeem(inAmount, msg.sender));
        byvWBTC.safeTransfer(msg.sender, outAmount);
        emit Redeem(msg.sender, inAmount, outAmount);
    }

    /* ##### View ##### */

    function calcMint(uint inAmount)
        override
        external
        view
        returns(uint bBTC, uint fee)
    {
        (bBTC, fee) = core.btcToBbtc(_byvWbtcToBtc(inAmount));
    }

    /**
    * @notice Determines the Sett tokens that will be received when redeeming bBTC
    * @return sett Number of sett tokens
    * @return fee Fee charges
    * @return max Max amount of bBTC redeemable for byvWBTC
    */
    function calcRedeem(uint bBtc)
        override
        external
        view
        returns(uint sett, uint fee, uint max)
    {
        uint btc;
        (btc, fee) = core.bBtcToBtc(bBtc);
        sett = _btcTobyvWBTC(btc);
        max = portfolioValue()
            .mul(1e18)
            .div(core.pricePerShare());
    }

    function portfolioValue()
        override
        public
        view
        returns (uint)
    {
        return _byvWbtcToBtc(
            byvWBTC.balanceOf(address(this))
        );
    }

    /**
    * @dev Determine sett amount given btc
    * @param btc BTC amount, scaled by 1e36
    */
    function _btcTobyvWBTC(uint btc)
        internal
        view
        returns(uint)
    {
        return btc // this value is scaled by 1e36
            .div(byvWBTC.pricePerShare())
            .div(1e20);
    }

    /**
    * @dev Determine btc amount given byvWBTC amount
    * @param amount byvWBTC amount
    * @return btc value, scaled by 1e18
    */
    function _byvWbtcToBtc(uint amount)
        internal
        view
        returns(uint)
    {
        // wBTC and byvWBTC are scaled by 8 decimals.
        // Multiply by 100 to return a value scaled by 1e18.
        return amount
            .mul(byvWBTC.pricePerShare())
            .mul(100);
    }
}",1170
RealWorld_BA_57_AccessControlDefended_RealWord_20240821184454.log,57,AccessControlDefended,7931,5683,13614,103.0,0.153315,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import {GovernableProxy} from ""./proxy/GovernableProxy.sol"";

contract AccessControlDefendedBase {
    mapping (address => bool) public approved;
    mapping(address => uint256) public blockLock;

    modifier defend() {
        require(msg.sender == tx.origin || approved[msg.sender], ""ACCESS_DENIED"");
        _;
    }

    modifier blockLocked() {
        require(approved[msg.sender] || blockLock[msg.sender] < block.number, ""BLOCK_LOCKED"");
        _;
    }

    function _lockForBlock(address account) internal {
        blockLock[account] = block.number;
    }

    function _approveContractAccess(address account) internal {
        approved[account] = true;
    }

    function _revokeContractAccess(address account) internal {
        approved[account] = false;
    }
}

contract AccessControlDefended is GovernableProxy, AccessControlDefendedBase {
    uint256[50] private __gap;

    function approveContractAccess(address account) external onlyGovernance {
        _approveContractAccess(account);
    }

    function revokeContractAccess(address account) external onlyGovernance {
        _revokeContractAccess(account);
    }
}",258
RealWorld_BA_57_ZapCall_RealWord_20240821184012.log,57,ZapCall,5714,4313,10027,99.0,0.11483,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

contract ZapCall {
    using SafeERC20 for IERC20;

    function mint(IERC20 wbtc, IZap zap) external {
        uint bal = wbtc.balanceOf(address(this));
        wbtc.safeApprove(address(zap), bal);
        zap.mint(wbtc, bal, 0, 1, 0);
    }
}

interface IZap {
    function mint(IERC20 token, uint amount, uint poolId, uint idx, uint minOut) external returns(uint _ibbtc);
}",171
RealWorld_BA_57_bBTC_RealWord_20240821182345.log,57,bBTC,6950,5707,12657,96.0,0.14889,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import {ERC20} from ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import {ICore} from ""./interfaces/ICore.sol"";
import {IbBTC} from ""./interfaces/IbBTC.sol"";

contract bBTC is ERC20, IbBTC {
    address public core;

    constructor(address _core)
        public
        ERC20(""Interest-Bearing BTC"", ""ibBTC"")
    {
        require(_core != address(0), ""NULL_ADDRESS"");
        core = _core;
    }

    modifier onlyCore() {
        require(msg.sender == core, ""bBTC: NO_AUTH"");
        _;
    }

    function mint(address account, uint amount) override external onlyCore {
        _mint(account, amount);
    }

    function burn(address account, uint amount) override external onlyCore {
        _burn(account, amount);
    }

    function switchCore(address _core) external onlyCore {
        require(_core != address(0), ""NULL_ADDRESS"");
        core = _core;
    }

    function pricePerShare() external view returns (uint) {
        return ICore(core).pricePerShare();
    }
}",254
RealWorld_BA_57_UpgradableProxy_RealWord_20240821185116.log,57,UpgradableProxy,8241,5081,13322,79.0,0.142825,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import {Proxy} from ""./Proxy.sol"";
import {GovernableProxy} from ""./GovernableProxy.sol"";

contract UpgradableProxy is GovernableProxy, Proxy {
    bytes32 constant IMPLEMENTATION_SLOT = keccak256(""proxy.implementation"");

    event ProxyUpdated(address indexed previousImpl, address indexed newImpl);

    fallback() external {
        delegatedFwd(implementation(), msg.data);
    }

    function implementation() override public view returns(address _impl) {
        bytes32 position = IMPLEMENTATION_SLOT;
        assembly {
            _impl := sload(position)
        }
    }

    function updateImplementation(address _newProxyTo) external onlyGovernance {
        require(_newProxyTo != address(0x0), ""INVALID_PROXY_ADDRESS"");
        require(isContract(_newProxyTo), ""DESTINATION_ADDRESS_IS_NOT_A_CONTRACT"");
        emit ProxyUpdated(implementation(), _newProxyTo);
        setImplementation(_newProxyTo);
    }

    function setImplementation(address _newProxyTo) private {
        bytes32 position = IMPLEMENTATION_SLOT;
        assembly {
            sstore(position, _newProxyTo)
        }
    }

    function isContract(address _target) internal view returns (bool) {
        if (_target == address(0)) {
            return false;
        }
        uint size;
        assembly {
            size := extcodesize(_target)
        }
        return size > 0;
    }
}",304
RealWorld_BA_57_BadgerSettPeak_RealWord_20240821183826.log,57,BadgerSettPeak,27997,5701,33698,104.0,0.254005,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;
pragma experimental ABIEncoderV2;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20, SafeMath} from ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import {Math} from ""@openzeppelin/contracts/math/Math.sol"";

import {AccessControlDefended} from ""../common/AccessControlDefended.sol"";

import {ISwap} from ""../interfaces/ISwap.sol"";
import {ICore} from ""../interfaces/ICore.sol"";
import {ISett} from ""../interfaces/ISett.sol"";
import {IBadgerSettPeak} from ""../interfaces/IPeak.sol"";

contract BadgerSettPeak is AccessControlDefended, IBadgerSettPeak {
    using SafeERC20 for IERC20;
    using SafeERC20 for ISett;
    using SafeMath for uint;
    using Math for uint;

    ICore public immutable core;

    struct CurvePool {
        ISwap swap;
        ISett sett;
    }
    mapping(uint => CurvePool) public pools;
    uint public numPools;

    // END OF STORAGE VARIABLES

    event Mint(address account, uint ibBTC, uint sett);
    event Redeem(address account, uint ibBTC, uint sett);

    /**
    * @param _core Address of the the Core contract
    */
    constructor(address _core) public {
        core = ICore(_core);
    }

    /**
    * @notice Mint bBTC with Sett LP token
    * @dev Invoking pool.sett.safeTransferFrom() before core.mint(), will mess up core.totalSystemAssets() calculation
    * @param poolId System internal ID of the whitelisted curve pool
    * @param inAmount Amount of Sett LP token to mint bBTC with
    * @return outAmount Amount of bBTC minted to user's account
    */
    function mint(uint poolId, uint inAmount, bytes32[] calldata merkleProof)
        override
        external
        defend
        blockLocked
        returns(uint outAmount)
    {
        _lockForBlock(msg.sender);
        CurvePool memory pool = pools[poolId];
        outAmount = core.mint(_settToBtc(pool, inAmount), msg.sender, merkleProof);
        // will revert if user passed an unsupported poolId
        pool.sett.safeTransferFrom(msg.sender, address(this), inAmount);
        emit Mint(msg.sender, outAmount, inAmount);
    }

    /**
    * @notice Redeem bBTC in Sett LP tokens
    * @dev There might not be enough Sett LP to fulfill the request, in which case the transaction will revert
    *      Invoking pool.sett.safeTransfer() before core.redeem(), will mess up core.totalSystemAssets() calculation
    * @param poolId System internal ID of the whitelisted curve pool
    * @param inAmount Amount of bBTC to redeem
    * @return outAmount Amount of Sett LP token
    */
    function redeem(uint poolId, uint inAmount)
        override
        external
        defend
        blockLocked
        returns (uint outAmount)
    {
        _lockForBlock(msg.sender);
        CurvePool memory pool = pools[poolId];
        outAmount = _btcToSett(pool, core.redeem(inAmount, msg.sender));
        // will revert if the contract has insufficient funds.
        pool.sett.safeTransfer(msg.sender, outAmount);
        emit Redeem(msg.sender, inAmount, outAmount);
    }

    /* ##### View ##### */

    function calcMint(uint poolId, uint inAmount)
        override
        external
        view
        returns(uint bBTC, uint fee)
    {
        (bBTC, fee) = core.btcToBbtc(_settToBtc(pools[poolId], inAmount));
    }

    /**
    * @notice Determines the Sett tokens that will be received when redeeming bBTC
    * @return sett Number of sett tokens
    * @return fee Fee charges
    * @return max Max amount of bBTC redeemable for chosen sett
    */
    function calcRedeem(uint poolId, uint bBtc)
        override
        external
        view
        returns(uint sett, uint fee, uint max)
    {
        CurvePool memory pool = pools[poolId];
        uint btc;
        (btc, fee) = core.bBtcToBtc(bBtc);
        sett = _btcToSett(pool, btc);
        max = pool.sett.balanceOf(address(this))
            .mul(pool.sett.getPricePerFullShare())
            .mul(pool.swap.get_virtual_price())
            .div(core.pricePerShare())
            .div(1e18);
    }

    function portfolioValue()
        override
        external
        view
        returns (uint assets)
    {
        CurvePool memory pool;
        uint _numPools = numPools;
        // We do not expect to have more than 3-4 pools, so this loop should be fine
        for (uint i = 0; i < _numPools; i++) {
            pool = pools[i];
            assets = assets.add(
                _settToBtc(
                    pool,
                    pool.sett.balanceOf(address(this))
                )
            );
        }
    }

    /**
    * @dev Determine sett amount given btc
    * @param btc BTC amount, scaled by 1e36
    *        Will revert for > 1e41.
    *        It's not possible to supply that amount because btc supply is capped at 21e24
    */
    function _btcToSett(CurvePool memory pool, uint btc)
        internal
        view
        returns(uint)
    {
        return btc // is already scaled by 1e36
            .mul(1e18)
            .div(pool.swap.get_virtual_price())
            .div(pool.sett.getPricePerFullShare());
    }

    /**
    * @dev Determine btc amount given sett amount
    * @param amount Sett LP token amount
    *        Will revert for amount > 1e41.
    *        It's not possible to supply that amount because btc supply is capped at 21e24
    */
    function _settToBtc(CurvePool memory pool, uint amount)
        internal
        view
        returns(uint)
    {
        return amount
            .mul(pool.sett.getPricePerFullShare())
            .mul(pool.swap.get_virtual_price())
            .div(1e36);
    }

    /* ##### Governance ##### */

    /**
    * @notice Manage whitelisted curve pools and their respective sett vaults
    */
    function modifyWhitelistedCurvePools(
        CurvePool[] calldata _pools
    )
        external
        onlyGovernance
    {
        CurvePool memory pool;
        for (uint i = 0; i < _pools.length; i++) {
            pool = _pools[i];
            require(
                address(pool.swap) != address(0)
                && address(pool.sett) != address(0),
                ""NULL_ADDRESS""
            );
            pools[i] = pool;
        }

        // clear older pools
        if (numPools > _pools.length) {
            for (uint i = _pools.length; i < numPools; i++) {
                delete pools[i];
            }
        }
        numPools = _pools.length;
    }
}",1599
RealWorld_BA_57_byvWbtc_RealWord_20240821183130.log,57,byvWbtc,6223,5626,11849,127.0,0.143635,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import {ERC20} from ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import {IbyvWbtc} from ""../interfaces/IbyvWbtc.sol"";

contract byvWbtc is ERC20, IbyvWbtc {

    constructor() public ERC20(""byvWbtc"", ""byvWbtc"") {
        _setupDecimals(8);
    }

    function mint(address account, uint amount) public {
        _mint(account, amount);
    }

    function pricePerShare() override external view returns (uint) {
        return 1e8;
    }

    function deposit(bytes32[] calldata merkleProof) override external {}

    function withdraw() override external returns (uint) {}
}",169
RealWorld_BA_58_IVaultFactory_RealWord_20240821213155.log,58,IVaultFactory,4539,4470,9009,99.0,0.112095,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";
import ""./IVault.sol"";

interface IVaultFactory {
    /// @notice Deploy a new vault.
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Reserved additional deploy options. Should be 0x0
    function deployVault(address[] memory vaultTokens, bytes memory options) external returns (IVault vault);
}",96
RealWorld_BA_58_TraderExceptionsLibrary_RealWord_20240821231901.log,58,TraderExceptionsLibrary,5425,4343,9768,82.0,0.113985,"// SPDX-License-Identifier: BSL-1.1
pragma solidity =0.8.9;

library TraderExceptionsLibrary {
    string constant PROTOCOL_ADMIN_REQUIRED_EXCEPTION = ""PA"";
    string constant TRADER_ALREADY_REGISTERED_EXCEPTION = ""TE"";
    string constant TRADER_NOT_FOUND_EXCEPTION = ""UT"";
    string constant TRADE_FAILED_EXCEPTION = ""TF"";
    string constant VAULT_NOT_FOUND_EXCEPTION = ""VF"";
    string constant VAULT_TOKEN_REQUIRED_EXCEPTION = ""VT"";
    string constant AT_LEAST_STRATEGY_REQUIRED_EXCEPTION = ""SR"";
    string constant INVALID_TRADE_PATH_EXCEPTION = ""TP"";
    string constant RECURRENCE_EXCEPTION = ""RE"";
    string constant TOKEN_NOT_ALLOWED_EXCEPTION = ""TA"";
}",147
RealWorld_BA_58_FixedPoint96_RealWord_20240821203642.log,58,FixedPoint96,4524,3264,7788,71.0,0.0879,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title FixedPoint96
/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)
/// @dev Used in SqrtPriceMath.sol
library FixedPoint96 {
    uint8 internal constant RESOLUTION = 96;
    uint256 internal constant Q96 = 0x1000000000000000000000000;
}",103
RealWorld_BA_58_LpIssuerFactory_RealWord_20240821191426.log,58,LpIssuerFactory,7228,5158,12386,93.0,0.1393,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IVaultFactory.sol"";
import ""./LpIssuer.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Helper contract for LpIssuerGovernance that can create new LpIssuers.
contract LpIssuerFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind
    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    /// @inheritdoc IVaultFactory
    function deployVault(address[] memory vaultTokens, bytes memory options) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        (string memory name, string memory symbol) = abi.decode(options, (string, string));
        LpIssuer vault = new LpIssuer(vaultGovernance, vaultTokens, name, symbol);
        return IVault(address(vault));
    }
}",244
RealWorld_BA_58_WERC20Test_RealWord_20240821224915.log,58,WERC20Test,5180,5449,10629,101.0,0.13488,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

interface IWrapped {
    function deposit() external payable;

    function withdraw(uint256 wad) external;
}

contract WERC20Test is IWrapped, ERC20 {
    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {
        _mint(msg.sender, (10**18) * (10**18));
    }

    function deposit() external payable {}

    function withdraw(uint256 wad) external {}
}",125
RealWorld_BA_58_VaultRegistry_RealWord_20240821194526.log,58,VaultRegistry,25432,6352,31784,126.0,0.2542,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IVault.sol"";
import ""./interfaces/IVaultFactory.sol"";
import ""./interfaces/IVaultRegistry.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice This contract is used to manage ERC721 NFT for all Vaults.
contract VaultRegistry is IVaultRegistry, ERC721 {
    uint256 private _stagedProtocolGovernanceTimestamp;
    IProtocolGovernance private _protocolGovernance;
    IProtocolGovernance private _stagedProtocolGovernance;

    address[] private _vaults;
    mapping(address => uint256) private _nftIndex;
    mapping(uint256 => address) private _vaultIndex;
    mapping(uint256 => bool) private _locks;
    uint256 private _topNft = 1;

    /// @notice Creates a new contract.
    /// @param name ERC721 token name
    /// @param symbol ERC721 token symbol
    /// @param protocolGovernance_ Reference to ProtocolGovernance
    constructor(
        string memory name,
        string memory symbol,
        IProtocolGovernance protocolGovernance_
    ) ERC721(name, symbol) {
        _protocolGovernance = protocolGovernance_;
    }

    function vaults() external view returns (address[] memory) {
        return _vaults;
    }

    /// @inheritdoc IVaultRegistry
    function vaultForNft(uint256 nft) external view returns (address) {
        return _vaultIndex[nft];
    }

    /// @inheritdoc IVaultRegistry
    function nftForVault(address vault) external view returns (uint256) {
        return _nftIndex[vault];
    }

    /// @inheritdoc IVaultRegistry
    function isLocked(uint256 nft) external view returns (bool) {
        return _locks[nft];
    }

    /// @inheritdoc IVaultRegistry
    function registerVault(address vault, address owner) external returns (uint256 nft) {
        require(_protocolGovernance.isVaultGovernance(msg.sender), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        nft = _topNft;
        _safeMint(owner, nft);
        _vaultIndex[nft] = vault;
        _nftIndex[vault] = nft;
        _vaults.push(vault);
        _topNft += 1;
        emit VaultRegistered(tx.origin, msg.sender, nft, vault, owner);
    }

    /// @inheritdoc IVaultRegistry
    function protocolGovernance() external view returns (IProtocolGovernance) {
        return _protocolGovernance;
    }

    /// @inheritdoc IVaultRegistry
    function stagedProtocolGovernance() external view returns (IProtocolGovernance) {
        return _stagedProtocolGovernance;
    }

    /// @inheritdoc IVaultRegistry
    function stagedProtocolGovernanceTimestamp() external view returns (uint256) {
        return _stagedProtocolGovernanceTimestamp;
    }

    /// @inheritdoc IVaultRegistry
    function vaultsCount() external view returns (uint256) {
        return _vaults.length;
    }

    /// @inheritdoc IVaultRegistry
    function stageProtocolGovernance(IProtocolGovernance newProtocolGovernance) external {
        require(_isProtocolAdmin(_msgSender()), ExceptionsLibrary.ADMIN);
        _stagedProtocolGovernance = newProtocolGovernance;
        _stagedProtocolGovernanceTimestamp = (block.timestamp + _protocolGovernance.governanceDelay());
        emit StagedProtocolGovernance(tx.origin, msg.sender, newProtocolGovernance, _stagedProtocolGovernanceTimestamp);
    }

    /// @inheritdoc IVaultRegistry
    function commitStagedProtocolGovernance() external {
        require(_isProtocolAdmin(_msgSender()), ExceptionsLibrary.ADMIN);
        require(_stagedProtocolGovernanceTimestamp > 0, ExceptionsLibrary.NULL_OR_NOT_INITIALIZED);
        require(block.timestamp >= _stagedProtocolGovernanceTimestamp, ExceptionsLibrary.TIMESTAMP);
        _protocolGovernance = _stagedProtocolGovernance;
        delete _stagedProtocolGovernanceTimestamp;
        emit CommitedProtocolGovernance(tx.origin, msg.sender, _protocolGovernance);
    }

    /// @inheritdoc IVaultRegistry
    function adminApprove(address newAddress, uint256 nft) external {
        require(_isProtocolAdmin(_msgSender()), ExceptionsLibrary.ADMIN);
        IERC721(address(this)).approve(newAddress, nft);
    }

    function lockNft(uint256 nft) external {
        require(ownerOf(nft) == msg.sender, ExceptionsLibrary.TOKEN_OWNER);
        _locks[nft] = true;
        emit TokenLocked(tx.origin, msg.sender, nft);
    }

    function _isProtocolAdmin(address sender) internal view returns (bool) {
        return _protocolGovernance.isAdmin(sender);
    }

    function _beforeTokenTransfer(
        address,
        address,
        uint256 tokenId
    ) internal view override {
        require(!_locks[tokenId], ExceptionsLibrary.LOCKED_NFT);
    }

    /// @notice Emitted when token is locked for transfers
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft NFT to be locked
    event TokenLocked(address indexed origin, address indexed sender, uint256 indexed nft);

    /// @notice Emitted when new Vault is registered in VaultRegistry
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param vault Address of the Vault contract
    /// @param owner Owner of the VaultRegistry NFT
    event VaultRegistered(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        address vault,
        address owner
    );

    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param newProtocolGovernance Address of the new ProtocolGovernance
    /// @param start Timestamp of the start of the new ProtocolGovernance
    event StagedProtocolGovernance(
        address indexed origin,
        address indexed sender,
        IProtocolGovernance newProtocolGovernance,
        uint256 start
    );

    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param newProtocolGovernance Address of the new ProtocolGovernance that has been committed
    event CommitedProtocolGovernance(
        address indexed origin,
        address indexed sender,
        IProtocolGovernance newProtocolGovernance
    );
}",1400
RealWorld_BA_58_GatewayVaultTest_RealWord_20240821230559.log,58,GatewayVaultTest,6816,5303,12119,125.0,0.14014,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""../interfaces/IVaultGovernance.sol"";
import ""../interfaces/IVaultFactory.sol"";
import ""../GatewayVault.sol"";

contract GatewayVaultTest is GatewayVault {
    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)
        GatewayVault(vaultGovernance_, vaultTokens_)
    {}

    function isValidPullDestination(address to) public view returns (bool) {
        return _isValidPullDestination(to);
    }

    function setVaultGovernance(address newVaultGovernance) public {
        _vaultGovernance = IVaultGovernance(newVaultGovernance);
    }

    function setSubvaultNfts(uint256[] memory nfts) public {
        _subvaultNfts = nfts;
    }

    function isApprovedOrOwner(address sender) public view returns (bool) {
        return _isApprovedOrOwner(sender);
    }

    function setVaultTokens(address[] memory tokens) public {
        _vaultTokens = tokens;
    }
}",217
RealWorld_BA_58_LpIssuerGovernance_RealWord_20240821223917.log,58,LpIssuerGovernance,42522,5942,48464,103.0,0.33145,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/ILpIssuerGovernance.sol"";
import ""./interfaces/ILpIssuer.sol"";
import ""./libraries/CommonLibrary.sol"";
import ""./VaultGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Governance that manages all Lp Issuers params and can deploy a new LpIssuer Vault.
contract LpIssuerGovernance is IERC721Receiver, ILpIssuerGovernance, VaultGovernance {
    uint256 public immutable MAX_PROTOCOL_FEE;
    uint256 public immutable MAX_MANAGEMENT_FEE;
    uint256 public immutable MAX_PERFORMANCE_FEE;

    /// @notice Creates a new contract.
    /// @param internalParams_ Initial Internal Params
    /// @param delayedProtocolParams_ Initial Protocol Params
    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)
        VaultGovernance(internalParams_)
    {
        _delayedProtocolParams = abi.encode(delayedProtocolParams_);
        MAX_PROTOCOL_FEE = 5 * CommonLibrary.DENOMINATOR;
        MAX_MANAGEMENT_FEE = 10 * CommonLibrary.DENOMINATOR;
        MAX_PERFORMANCE_FEE = 50 * CommonLibrary.DENOMINATOR;
    }

    /// @inheritdoc ILpIssuerGovernance
    function delayedProtocolParams() public view returns (DelayedProtocolParams memory) {
        if (_delayedProtocolParams.length == 0) {
            return DelayedProtocolParams({managementFeeChargeDelay: 0});
        }
        return abi.decode(_delayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory) {
        if (_stagedDelayedProtocolParams.length == 0) {
            return DelayedProtocolParams({managementFeeChargeDelay: 0});
        }
        return abi.decode(_stagedDelayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function delayedProtocolPerVaultParams(uint256 nft) external view returns (DelayedProtocolPerVaultParams memory) {
        if (_delayedProtocolPerVaultParams[nft].length == 0) {
            return DelayedProtocolPerVaultParams({protocolFee: 0});
        }
        return abi.decode(_delayedProtocolPerVaultParams[nft], (DelayedProtocolPerVaultParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function stagedDelayedProtocolPerVaultParams(uint256 nft)
        external
        view
        returns (DelayedProtocolPerVaultParams memory)
    {
        if (_stagedDelayedProtocolPerVaultParams[nft].length == 0) {
            return DelayedProtocolPerVaultParams({protocolFee: 0});
        }
        return abi.decode(_stagedDelayedProtocolPerVaultParams[nft], (DelayedProtocolPerVaultParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function stagedDelayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory) {
        if (_stagedDelayedStrategyParams[nft].length == 0) {
            return
                DelayedStrategyParams({
                    strategyTreasury: address(0),
                    strategyPerformanceTreasury: address(0),
                    managementFee: 0,
                    performanceFee: 0
                });
        }
        return abi.decode(_stagedDelayedStrategyParams[nft], (DelayedStrategyParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function delayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory) {
        if (_delayedStrategyParams[nft].length == 0) {
            return
                DelayedStrategyParams({
                    strategyTreasury: address(0),
                    strategyPerformanceTreasury: address(0),
                    managementFee: 0,
                    performanceFee: 0
                });
        }
        return abi.decode(_delayedStrategyParams[nft], (DelayedStrategyParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function strategyParams(uint256 nft) external view returns (StrategyParams memory) {
        if (_strategyParams[nft].length == 0) {
            return StrategyParams({tokenLimitPerAddress: 0});
        }
        return abi.decode(_strategyParams[nft], (StrategyParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function stageDelayedStrategyParams(uint256 nft, DelayedStrategyParams calldata params) external {
        require(params.managementFee <= MAX_MANAGEMENT_FEE, ExceptionsLibrary.MAX_MANAGEMENT_FEE);
        require(params.performanceFee <= MAX_PERFORMANCE_FEE, ExceptionsLibrary.MAX_PERFORMANCE_FEE);
        _stageDelayedStrategyParams(nft, abi.encode(params));
        emit StageDelayedStrategyParams(tx.origin, msg.sender, nft, params, _delayedStrategyParamsTimestamp[nft]);
    }

    /// @inheritdoc ILpIssuerGovernance
    function commitDelayedStrategyParams(uint256 nft) external {
        _commitDelayedStrategyParams(nft);
        emit CommitDelayedStrategyParams(
            tx.origin,
            msg.sender,
            nft,
            abi.decode(_delayedStrategyParams[nft], (DelayedStrategyParams))
        );
    }

    /// @inheritdoc ILpIssuerGovernance
    function stageDelayedProtocolPerVaultParams(uint256 nft, DelayedProtocolPerVaultParams calldata params) external {
        require(params.protocolFee <= MAX_PROTOCOL_FEE, ExceptionsLibrary.MAX_PROTOCOL_FEE);
        _stageDelayedProtocolPerVaultParams(nft, abi.encode(params));
        emit StageDelayedProtocolPerVaultParams(
            tx.origin,
            msg.sender,
            nft,
            params,
            _delayedStrategyParamsTimestamp[nft]
        );
    }

    /// @inheritdoc ILpIssuerGovernance
    function commitDelayedProtocolPerVaultParams(uint256 nft) external {
        _commitDelayedProtocolPerVaultParams(nft);
        emit CommitDelayedProtocolPerVaultParams(
            tx.origin,
            msg.sender,
            nft,
            abi.decode(_delayedProtocolPerVaultParams[nft], (DelayedProtocolPerVaultParams))
        );
    }

    function setStrategyParams(uint256 nft, StrategyParams calldata params) external {
        _setStrategyParams(nft, abi.encode(params));
        emit SetStrategyParams(tx.origin, msg.sender, nft, params);
    }

    /// @inheritdoc ILpIssuerGovernance
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external {
        _stageDelayedProtocolParams(abi.encode(params));
        emit StageDelayedProtocolParams(tx.origin, msg.sender, params, _delayedProtocolParamsTimestamp);
    }

    /// @inheritdoc ILpIssuerGovernance
    function commitDelayedProtocolParams() external {
        _commitDelayedProtocolParams();
        emit CommitDelayedProtocolParams(
            tx.origin,
            msg.sender,
            abi.decode(_delayedProtocolParams, (DelayedProtocolParams))
        );
    }

    /// @notice Required for intermediate vault token transfer in deploy
    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external view returns (bytes4) {
        IVaultRegistry registry = _internalParams.registry;
        require(msg.sender == address(registry), ExceptionsLibrary.NFT_VAULT_REGISTRY);
        return this.onERC721Received.selector;
    }

    /// @notice Deploy a new vault.
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Abi encoded uint256 - an nfts of the gateway subvault. It is required that nft subvault is approved by the caller to this address and that it is a gateway vault
    /// @return vault Address of the new vault
    /// @return nft Nft of the vault in the vault registry
    function deployVault(
        address[] memory vaultTokens,
        bytes memory options,
        address
    ) public override(VaultGovernance, IVaultGovernance) returns (IVault vault, uint256 nft) {
        (uint256 subvaultNft, string memory name, string memory symbol) = abi.decode(
            options,
            (uint256, string, string)
        );
        (vault, nft) = super.deployVault(vaultTokens, abi.encode(name, symbol), msg.sender);
        IVaultRegistry registry = _internalParams.registry;
        ILpIssuer(address(vault)).addSubvault(subvaultNft);
        registry.safeTransferFrom(msg.sender, address(vault), subvaultNft);
    }

    /// @notice Emitted when new DelayedProtocolPerVaultParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedProtocolPerVaultParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedProtocolPerVaultParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedProtocolPerVaultParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that are committed
    event CommitDelayedProtocolPerVaultParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedProtocolPerVaultParams params
    );

    /// @notice Emitted when new DelayedStrategyParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedStrategyParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedStrategyParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedStrategyParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that are committed
    event CommitDelayedStrategyParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedStrategyParams params
    );

    /// @notice Emitted when new StrategyParams are set.
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that are set
    event SetStrategyParams(address indexed origin, address indexed sender, uint256 indexed nft, StrategyParams params);

    /// @notice Emitted when new DelayedProtocolParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedProtocolParams(
        address indexed origin,
        address indexed sender,
        DelayedProtocolParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedProtocolParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that are committed
    event CommitDelayedProtocolParams(address indexed origin, address indexed sender, DelayedProtocolParams params);
}",2468
RealWorld_BA_58_UniV3Vault_RealWord_20240821191128.log,58,UniV3Vault,39377,5397,44774,91.0,0.304825,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""./interfaces/external/univ3/INonfungiblePositionManager.sol"";
import ""./interfaces/external/univ3/IUniswapV3Pool.sol"";
import ""./interfaces/external/univ3/IUniswapV3Factory.sol"";
import ""./interfaces/IUniV3VaultGovernance.sol"";
import ""./libraries/external/TickMath.sol"";
import ""./libraries/external/LiquidityAmounts.sol"";
import ""./Vault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Vault that interfaces UniswapV3 protocol in the integration layer.
contract UniV3Vault is IERC721Receiver, Vault {
    struct Options {
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    struct Pair {
        uint256 a0;
        uint256 a1;
    }

    IUniswapV3Pool public immutable pool;

    uint256 public uniV3Nft;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance for this vault
    /// @param vaultTokens_ ERC20 tokens under Vault management
    /// @param fee Fee of the underlying UniV3 pool
    constructor(
        IVaultGovernance vaultGovernance_,
        address[] memory vaultTokens_,
        uint24 fee
    ) Vault(vaultGovernance_, vaultTokens_) {
        require(_vaultTokens.length == 2, ExceptionsLibrary.TOKEN_LENGTH);
        pool = IUniswapV3Pool(
            IUniswapV3Factory(_positionManager().factory()).getPool(_vaultTokens[0], _vaultTokens[1], fee)
        );
    }

    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory) external returns (bytes4) {
        require(msg.sender == address(_positionManager()), ""SNFT"");
        require(_isStrategy(operator), ""STR"");
        (
            , ,
            address token0,
            address token1,
            , , , , , , ,
        ) = _positionManager().positions(tokenId);
        // new position should have vault tokens
        require(
            token0 == _vaultTokens[0] && token1 == _vaultTokens[1],
            ""VT""
        );

        if (uniV3Nft != 0) {
            (
                , , , , , , ,
                uint128 liquidity,
                , ,
                uint128 tokensOwed0,
                uint128 tokensOwed1
            ) = _positionManager().positions(uniV3Nft);
            require(liquidity == 0 && tokensOwed0 == 0 && tokensOwed1 == 0, ""TVL"");
            // return previous uni v3 position nft
            _positionManager().transferFrom(address(this), from, uniV3Nft);
        }

        uniV3Nft = tokenId;
        return this.onERC721Received.selector;
    }

    function collectEarnings(address to) external nonReentrant returns (uint256[] memory collectedEarnings) {
        require(_isApprovedOrOwner(msg.sender), ExceptionsLibrary.APPROVED_OR_OWNER);
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        address owner = registry.ownerOf(_nft);
        require(owner == msg.sender || _isValidPullDestination(to), ExceptionsLibrary.VALID_PULL_DESTINATION);
        collectedEarnings = new uint256[](2);
        (uint256 collectedEarnings0, uint256 collectedEarnings1) = _positionManager().collect(
            INonfungiblePositionManager.CollectParams({
                tokenId: uniV3Nft,
                recipient: to,
                amount0Max: type(uint128).max,
                amount1Max: type(uint128).max
            })
        );
        collectedEarnings[0] = collectedEarnings0;
        collectedEarnings[1] = collectedEarnings1;
        emit CollectedEarnings(tx.origin, to, collectedEarnings0, collectedEarnings1);
    }

    /// @inheritdoc Vault
    function tvl() public view override returns (uint256[] memory tokenAmounts) {
        tokenAmounts = new uint256[](_vaultTokens.length);
        if (uniV3Nft == 0)
            return tokenAmounts;
        (
            , , , , , 
            int24 tickLower, 
            int24 tickUpper, 
            uint128 liquidity,
            , , ,
        ) = _positionManager().positions(uniV3Nft);
        (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();
        uint160 sqrtPriceAX96 = TickMath.getSqrtRatioAtTick(tickLower);
        uint160 sqrtPriceBX96 = TickMath.getSqrtRatioAtTick(tickUpper);
        (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(
            sqrtPriceX96,
            sqrtPriceAX96,
            sqrtPriceBX96,
            liquidity
        );
        tokenAmounts[0] = amount0;
        tokenAmounts[1] = amount1;
    }

    function _push(uint256[] memory tokenAmounts, bytes memory options)
        internal
        override
        returns (uint256[] memory actualTokenAmounts)
    {
        address[] memory tokens = _vaultTokens;
        for (uint256 i = 0; i < tokens.length; i++)
            _allowTokenIfNecessary(tokens[i]);

        actualTokenAmounts = new uint256[](2);
        if (uniV3Nft == 0)
            return actualTokenAmounts;

        Options memory opts = _parseOptions(options);
        Pair memory amounts = Pair({
            a0: tokenAmounts[0],
            a1: tokenAmounts[1]
        });
        Pair memory minAmounts = Pair({
            a0: opts.amount0Min,
            a1: opts.amount1Min
        });
        (, uint256 amount0, uint256 amount1) = _positionManager().increaseLiquidity(
            INonfungiblePositionManager.IncreaseLiquidityParams({
                tokenId: uniV3Nft,
                amount0Desired: amounts.a0,
                amount1Desired: amounts.a1,
                amount0Min: minAmounts.a0,
                amount1Min: minAmounts.a1,
                deadline: opts.deadline
            })
        );
        actualTokenAmounts[0] = amount0;
        actualTokenAmounts[1] = amount1;
    }

    function _pull(
        address to,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) internal override returns (uint256[] memory actualTokenAmounts) {
        actualTokenAmounts = new uint256[](2);
        if (uniV3Nft == 0)
            return actualTokenAmounts;

        Options memory opts = _parseOptions(options);
        Pair memory amounts = _pullUniV3Nft(tokenAmounts, to, opts);
        actualTokenAmounts[0] = amounts.a0;
        actualTokenAmounts[1] = amounts.a1;
    }

    function _pullUniV3Nft(
        uint256[] memory tokenAmounts,
        address to,
        Options memory opts
    ) internal returns (Pair memory) {
        uint128 liquidityToPull;
        // scope the code below to avoid stack-too-deep exception
        {
            (, , , , , int24 tickLower, int24 tickUpper, uint128 liquidity, , , , ) = _positionManager().positions(uniV3Nft);
            (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();
            uint160 sqrtPriceAX96 = TickMath.getSqrtRatioAtTick(tickLower);
            uint160 sqrtPriceBX96 = TickMath.getSqrtRatioAtTick(tickUpper);
            liquidityToPull = LiquidityAmounts.getLiquidityForAmounts(
                sqrtPriceX96, sqrtPriceAX96, sqrtPriceBX96, tokenAmounts[0], tokenAmounts[1]
            );
            liquidityToPull = liquidity < liquidityToPull ? liquidity : liquidityToPull;
            if (liquidityToPull == 0) {
                return Pair({a0: 0, a1: 0});
            }
        }
        Pair memory minAmounts = Pair({
            a0: opts.amount0Min,
            a1: opts.amount1Min
        });
        (uint256 amount0, uint256 amount1) = _positionManager().decreaseLiquidity(
            INonfungiblePositionManager.DecreaseLiquidityParams({
                tokenId: uniV3Nft,
                liquidity: liquidityToPull,
                amount0Min: minAmounts.a0,
                amount1Min: minAmounts.a1,
                deadline: opts.deadline
            })
        );
        (uint256 amount0Collected, uint256 amount1Collected) = _positionManager().collect(
            INonfungiblePositionManager.CollectParams({
                tokenId: uniV3Nft,
                recipient: to,
                amount0Max: uint128(amount0),
                amount1Max: uint128(amount1)
            })
        );
        return Pair({a0: amount0Collected, a1: amount1Collected});
    }

    function _postReclaimTokens(address, address[] memory tokens) internal view override {}

    /// TODO: make a virtual function here? Or other better approach
    function _positionManager() internal view returns (INonfungiblePositionManager) {
        return IUniV3VaultGovernance(address(_vaultGovernance)).delayedProtocolParams().positionManager;
    }

    function _allowTokenIfNecessary(address token) internal {
        if (IERC20(token).allowance(address(_positionManager()), address(this)) < type(uint256).max / 2)
            IERC20(token).approve(address(_positionManager()), type(uint256).max);
    }

    function _parseOptions(bytes memory options) internal view returns (Options memory) {
        if (options.length == 0)
            return Options({amount0Min: 0, amount1Min: 0, deadline: block.timestamp + 600});

        require(options.length == 32 * 3, ExceptionsLibrary.IO_LENGTH);
        return abi.decode(options, (Options));
    }

    function _isStrategy(address addr) internal view returns (bool) {
        return _vaultGovernance.internalParams().registry.getApproved(_nft) == addr;
    }

    event CollectedEarnings(address indexed origin, address indexed to, uint256 amount0, uint256 amount1);
}",2299
RealWorld_BA_58_GatewayVaultFactory_RealWord_20240821193336.log,58,GatewayVaultFactory,6416,4560,10976,88.0,0.12328,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IVaultFactory.sol"";
import ""./GatewayVault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Helper contract for GatewayVaultGovernance that can create new Gateway Vaults.
contract GatewayVaultFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind
    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    /// @inheritdoc IVaultFactory
    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        GatewayVault gatewayVault = new GatewayVault(vaultGovernance, vaultTokens);
        return IVault(gatewayVault);
    }
}",213
RealWorld_BA_58_GatewayVault_RealWord_20240821192507.log,58,GatewayVault,42510,5541,48051,113.0,0.32337,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""./interfaces/IVault.sol"";
import ""./interfaces/IGatewayVault.sol"";
import ""./interfaces/IGatewayVaultGovernance.sol"";
import ""./Vault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Vault that combines several integration layer Vaults into one Vault.
contract GatewayVault is IERC721Receiver, IGatewayVault, Vault {
    using SafeERC20 for IERC20;
    uint256[] internal _subvaultNfts;
    mapping(uint256 => uint256) internal _subvaultNftsIndex;

    /// @notice Creates a new contract.
    /// @dev All subvault nfts must be owned by this vault before.
    /// @param vaultGovernance_ Reference to VaultGovernance for this vault
    /// @param vaultTokens_ ERC20 tokens under Vault management
    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)
        Vault(vaultGovernance_, vaultTokens_)
    {}

    /// @inheritdoc IGatewayVault
    function subvaultNfts() external view returns (uint256[] memory) {
        return _subvaultNfts;
    }

    /// @inheritdoc Vault
    function tvl() public view override(IVault, Vault) returns (uint256[] memory tokenAmounts) {
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        tokenAmounts = new uint256[](_vaultTokens.length);
        for (uint256 i = 0; i < _subvaultNfts.length; i++) {
            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));
            uint256[] memory vTokenAmounts = vault.tvl();
            for (uint256 j = 0; j < _vaultTokens.length; j++) {
                tokenAmounts[j] += vTokenAmounts[j];
            }
        }
    }

    /// @inheritdoc IGatewayVault
    function subvaultTvl(uint256 vaultNum) public view override returns (uint256[] memory) {
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        IVault vault = IVault(registry.vaultForNft(_subvaultNfts[vaultNum]));
        return vault.tvl();
    }

    /// @inheritdoc IGatewayVault
    function subvaultsTvl() public view override returns (uint256[][] memory tokenAmounts) {
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        uint256 vaultTokensLength = _vaultTokens.length;
        tokenAmounts = new uint256[][](_subvaultNfts.length);
        for (uint256 i = 0; i < _subvaultNfts.length; i++) {
            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));
            uint256[] memory vTokenAmounts = vault.tvl();
            tokenAmounts[i] = new uint256[](vaultTokensLength);
            for (uint256 j = 0; j < vaultTokensLength; j++) {
                tokenAmounts[i][j] = vTokenAmounts[j];
            }
        }
    }

    /// @inheritdoc IGatewayVault
    function hasSubvault(address vault) external view override returns (bool) {
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        uint256 nft_ = registry.nftForVault(vault);
        return (_subvaultNftsIndex[nft_] > 0 || _subvaultNfts[0] == nft_);
    }

    /// @inheritdoc IGatewayVault
    function addSubvaults(uint256[] memory nfts) external {
        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        require(_subvaultNfts.length == 0, ExceptionsLibrary.SUB_VAULT_INITIALIZED);
        require(nfts.length > 0, ExceptionsLibrary.SUB_VAULT_LENGTH);
        address[] memory selfTokens = _vaultTokens;
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        for (uint256 i = 0; i < nfts.length; i++) {
            uint256 nft_ = nfts[i];
            require(nft_ > 0, ExceptionsLibrary.NFT_ZERO);
            IVault vault = IVault(registry.vaultForNft(nft_));
            address[] memory vTokens = vault.vaultTokens();
            require(selfTokens.length == vTokens.length, ExceptionsLibrary.INCONSISTENT_LENGTH);
            for (uint256 j = 0; j < selfTokens.length; j++) {
                require(selfTokens[j] == vTokens[j], ExceptionsLibrary.NOT_VAULT_TOKEN);
            }
            _subvaultNfts.push(nft_);
            _subvaultNftsIndex[nft_] = i;
        }
    }

    function setApprovalsForStrategy(address strategy, uint256[] memory nfts) external {
        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        require(strategy != address(0), ExceptionsLibrary.ZERO_STRATEGY_ADDRESS);
        IVaultRegistry vaultRegistry = IVaultGovernance(_vaultGovernance).internalParams().registry;
        for (uint i = 0; i < nfts.length; ++i)
            vaultRegistry.approve(strategy, nfts[i]);
    }

    function onERC721Received(
        address,
        address,
        uint256 tokenId,
        bytes calldata
    ) external nonReentrant returns (bytes4) {
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        require(msg.sender == address(registry), ExceptionsLibrary.NFT_VAULT_REGISTRY);
        registry.lockNft(tokenId);
        return this.onERC721Received.selector;
    }

    function _push(uint256[] memory tokenAmounts, bytes memory options)
        internal
        override
        returns (uint256[] memory actualTokenAmounts)
    {
        require(_subvaultNfts.length > 0, ExceptionsLibrary.INITIALIZATION);
        bool optimized;
        bytes[] memory vaultsOptions;
        (optimized, vaultsOptions) = _parseOptions(options);

        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        uint256[][] memory tvls = subvaultsTvl();
        uint256[] memory totalTvl = new uint256[](_vaultTokens.length);
        uint256[][] memory amountsByVault = CommonLibrary.splitAmounts(tokenAmounts, tvls);
        IGatewayVaultGovernance.DelayedStrategyParams memory strategyParams = IGatewayVaultGovernance(
            address(_vaultGovernance)
        ).delayedStrategyParams(_nft);
        if (optimized && strategyParams.redirects.length > 0) {
            for (uint256 i = 0; i < _subvaultNfts.length; i++) {
                if (strategyParams.redirects[i] == 0) {
                    continue;
                }
                for (uint256 j = 0; j < _vaultTokens.length; j++) {
                    uint256 vaultIndex = _subvaultNftsIndex[strategyParams.redirects[i]];
                    amountsByVault[vaultIndex][j] += amountsByVault[i][j];
                    amountsByVault[i][j] = 0;
                }
            }
        }
        actualTokenAmounts = new uint256[](_vaultTokens.length);
        for (uint256 i = 0; i < _subvaultNfts.length; i++) {
            if (optimized && (strategyParams.redirects[i] != 0)) {
                continue;
            }
            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));
            for (uint256 j = 0; j < _vaultTokens.length; j++) {
                if (amountsByVault[i][j] > 0) {
                    _allowTokenIfNecessary(_vaultTokens[j], address(vault));
                }
            }
            uint256[] memory actualVaultTokenAmounts = vault.transferAndPush(
                address(this),
                _vaultTokens,
                amountsByVault[i],
                vaultsOptions[i]
            );
            for (uint256 j = 0; j < _vaultTokens.length; j++) {
                actualTokenAmounts[j] += actualVaultTokenAmounts[j];
                totalTvl[j] += tvls[i][j];
            }
        }
        uint256[] memory _limits = IGatewayVaultGovernance(address(_vaultGovernance)).strategyParams(_nft).limits;
        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            require(totalTvl[i] + actualTokenAmounts[i] < _limits[i], ExceptionsLibrary.LIMIT_OVERFLOW);
        }
    }

    function _pull(
        address to,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) internal override returns (uint256[] memory actualTokenAmounts) {
        (bool optimized, bytes[] memory vaultsOptions) = _parseOptions(options);

        require(_subvaultNfts.length > 0, ExceptionsLibrary.INITIALIZATION);
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        uint256[][] memory tvls = subvaultsTvl();
        uint256[][] memory amountsByVault = CommonLibrary.splitAmounts(tokenAmounts, tvls);
        uint256[] memory _redirects = IGatewayVaultGovernance(address(_vaultGovernance))
            .delayedStrategyParams(_nft)
            .redirects;

        if (optimized && (_redirects.length > 0)) {
            for (uint256 i = 0; i < _subvaultNfts.length; i++) {
                if (_redirects[i] == 0) {
                    continue;
                }
                for (uint256 j = 0; j < _vaultTokens.length; j++) {
                    uint256 vaultIndex = _subvaultNftsIndex[_redirects[i]];
                    amountsByVault[vaultIndex][j] += amountsByVault[i][j];
                    amountsByVault[i][j] = 0;
                }
            }
        }
        actualTokenAmounts = new uint256[](_vaultTokens.length);
        for (uint256 i = 0; i < _subvaultNfts.length; i++) {
            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));
            uint256[] memory actualVaultTokenAmounts = vault.pull(
                to,
                _vaultTokens,
                amountsByVault[i],
                vaultsOptions[i]
            );
            for (uint256 j = 0; j < _vaultTokens.length; j++) {
                actualTokenAmounts[j] += actualVaultTokenAmounts[j];
            }
        }
    }

    function _allowTokenIfNecessary(address token, address to) internal {
        if (IERC20(token).allowance(address(this), address(to)) < type(uint256).max / 2) {
            IERC20(token).approve(address(to), type(uint256).max);
        }
    }

    function _parseOptions(bytes memory options) internal view returns (bool, bytes[] memory) {
        if (options.length == 0) {
            return (false, new bytes[](_subvaultNfts.length));
        }
        return abi.decode(options, (bool, bytes[]));
    }

    event CollectProtocolFees(address protocolTreasury, address[] tokens, uint256[] amounts);
    event CollectStrategyFees(address strategyTreasury, address[] tokens, uint256[] amounts);
}",2465
RealWorld_BA_58_YearnVaultFactory_RealWord_20240821222915.log,58,YearnVaultFactory,6726,4576,11302,95.0,0.12515,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IVaultFactory.sol"";
import ""./YearnVault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Helper contract for YearnVaultGovernance that can create new Yearn Vaults.
contract YearnVaultFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    /// @notice Creates a new contract
    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind
    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    /// @inheritdoc IVaultFactory
    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        YearnVault vault = new YearnVault(vaultGovernance, vaultTokens);
        return IVault(vault);
    }
}",217
RealWorld_BA_58_DefaultAccessControl_RealWord_20240821221210.log,58,DefaultAccessControl,7599,5120,12719,99.0,0.140395,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/access/AccessControlEnumerable.sol"";
import ""./interfaces/IDefaultAccessControl.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice This is a default access control with 2 roles -
/// ADMIN and ADMIN_DELEGATE.
contract DefaultAccessControl is IDefaultAccessControl, AccessControlEnumerable {
    bytes32 public constant ADMIN_ROLE = keccak256(""admin"");
    bytes32 public constant ADMIN_DELEGATE_ROLE = keccak256(""admin_delegate"");

    /// @notice Creates a new contract.
    /// @param admin Admin of the contract
    constructor(address admin) {
        require(admin != address(0), ExceptionsLibrary.ADMIN_ADDRESS_ZERO);
        _setupRole(ADMIN_ROLE, admin);
        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setRoleAdmin(ADMIN_DELEGATE_ROLE, ADMIN_ROLE);
    }

    /// @notice Checks if the address is contract admin.
    /// @param sender Adddress to check
    /// @return `true` if sender is an admin, `false` otherwise
    function isAdmin(address sender) public view returns (bool) {
        return hasRole(ADMIN_ROLE, sender) || hasRole(ADMIN_DELEGATE_ROLE, sender);
    }
}",277
RealWorld_BA_58_UniV3VaultGovernance_RealWord_20240821194355.log,58,UniV3VaultGovernance,13105,5098,18203,88.0,0.167485,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IUniV3VaultGovernance.sol"";
import ""./VaultGovernance.sol"";

/// @notice Governance that manages all UniV3 Vaults params and can deploy a new UniV3 Vault.
contract UniV3VaultGovernance is IUniV3VaultGovernance, VaultGovernance {
    /// @notice Creates a new contract.
    /// @param internalParams_ Initial Internal Params
    /// @param delayedProtocolParams_ Initial Protocol Params
    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)
        VaultGovernance(internalParams_)
    {
        _delayedProtocolParams = abi.encode(delayedProtocolParams_);
    }

    /// @inheritdoc IUniV3VaultGovernance
    function delayedProtocolParams() public view returns (DelayedProtocolParams memory) {
        if (_delayedProtocolParams.length == 0) {
            return DelayedProtocolParams({positionManager: INonfungiblePositionManager(address(0))});
        }
        return abi.decode(_delayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IUniV3VaultGovernance
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory) {
        if (_stagedDelayedProtocolParams.length == 0) {
            return DelayedProtocolParams({positionManager: INonfungiblePositionManager(address(0))});
        }
        return abi.decode(_stagedDelayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IUniV3VaultGovernance
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external {
        _stageDelayedProtocolParams(abi.encode(params));
        emit StageDelayedProtocolParams(tx.origin, msg.sender, params, _delayedProtocolParamsTimestamp);
    }

    /// @inheritdoc IUniV3VaultGovernance
    function commitDelayedProtocolParams() external {
        _commitDelayedProtocolParams();
        emit CommitDelayedProtocolParams(
            tx.origin,
            msg.sender,
            abi.decode(_delayedProtocolParams, (DelayedProtocolParams))
        );
    }

    /// @notice Emitted when new DelayedProtocolParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedProtocolParams(
        address indexed origin,
        address indexed sender,
        DelayedProtocolParams params,
        uint256 when
    );
    /// @notice Emitted when new DelayedProtocolParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that are committed
    event CommitDelayedProtocolParams(address indexed origin, address indexed sender, DelayedProtocolParams params);
}",615
RealWorld_BA_58_IDefaultAccessControl_RealWord_20240821203945.log,58,IDefaultAccessControl,4879,4859,9738,86.0,0.121575,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/access/IAccessControlEnumerable.sol"";

interface IDefaultAccessControl is IAccessControlEnumerable {
    /// @notice Checks that the address is contract admin.
    /// @param who Address to check
    /// @return `true` if who is admin, `false` otherwise
    function isAdmin(address who) external view returns (bool);
}",93
RealWorld_BA_58_VaultTest_RealWord_20240821230933.log,58,VaultTest,8820,5976,14796,103.0,0.16362,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../Vault.sol"";
import ""../interfaces/IVaultGovernance.sol"";
import ""../interfaces/IVault.sol"";

contract VaultTest is Vault {
    uint256[] res;

    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)
        Vault(vaultGovernance_, vaultTokens_)
    {
        res = new uint256[](1);
        res[0] = 0;
    }

    function tvl() public view override returns (uint256[] memory tokenAmounts) {
        return res;
    }

    function _push(uint256[] memory, bytes memory) internal view override returns (uint256[] memory) {
        // no-op, tokens are already on balance
        return res;
    }

    function _pull(
        address,
        uint256[] memory,
        bytes memory
    ) internal view override returns (uint256[] memory) {
        return res;
    }

    function postReclaimTokens(address to, address[] memory tokens) external {
        _postReclaimTokens(to, tokens);
    }

    function isValidPullDestination(address to) external view returns (bool) {
        return _isValidPullDestination(to);
    }

    function isApprovedOrOwner(address to) external view returns (bool) {
        return _isApprovedOrOwner(to);
    }
}",288
RealWorld_BA_58_IYearnVaultRegistry_RealWord_20240821214732.log,58,IYearnVaultRegistry,3520,3848,7368,76.0,0.09456,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.9;

interface IYearnVaultRegistry {
    function latestVault(address vault) external view returns (address);
}",37
RealWorld_BA_58_ERC20Vault_RealWord_20240821221721.log,58,ERC20Vault,19270,5662,24932,103.0,0.20959,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./trader/interfaces/IChiefTrader.sol"";
import ""./trader/interfaces/ITrader.sol"";
import ""./interfaces/IERC20VaultGovernance.sol"";
import ""./Vault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Vault that stores ERC20 tokens.
contract ERC20Vault is Vault, ITrader {
    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance for this vault
    /// @param vaultTokens_ ERC20 tokens under Vault management
    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)
        Vault(vaultGovernance_, vaultTokens_)
    {}

    /// @inheritdoc Vault
    function tvl() public view override returns (uint256[] memory tokenAmounts) {
        address[] memory tokens = _vaultTokens;
        tokenAmounts = new uint256[](tokens.length);
        for (uint256 i = 0; i < tokens.length; i++) {
            tokenAmounts[i] = IERC20(tokens[i]).balanceOf(address(this));
        }
    }

    /// @inheritdoc ITrader
    function swapExactInput(
        uint256 traderId,
        uint256 amount,
        address,
        PathItem[] memory path,
        bytes memory options
    ) external returns (uint256 amountOut) {
        require(
            path.length > 0  && isVaultToken(path[path.length - 1].token1), 
            ExceptionsLibrary.NOT_VAULT_TOKEN
        );
        require(_isStrategy(msg.sender), ExceptionsLibrary.NOT_STRATEGY_TREASURY);
        IERC20VaultGovernance vg = IERC20VaultGovernance(address(_vaultGovernance));
        ITrader trader = ITrader(vg.delayedProtocolParams().trader);
        IChiefTrader chiefTrader = IChiefTrader(address(trader));
        _approveERC20TokenIfNecessary(path[0].token0, chiefTrader.getTrader(traderId));
        return trader.swapExactInput(traderId, amount, address(0), path, options);
    }

    /// @inheritdoc ITrader
    function swapExactOutput(
        uint256 traderId,
        uint256 amount,
        address,
        PathItem[] memory path,
        bytes calldata options
    ) external returns (uint256 amountOut) {
        require(
            path.length > 0  && isVaultToken(path[path.length - 1].token1), 
            ExceptionsLibrary.NOT_VAULT_TOKEN
        );
        require(_isStrategy(msg.sender), ExceptionsLibrary.NOT_STRATEGY_TREASURY);
        IERC20VaultGovernance vg = IERC20VaultGovernance(address(_vaultGovernance));
        ITrader trader = ITrader(vg.delayedProtocolParams().trader);
        IChiefTrader chiefTrader = IChiefTrader(address(trader));
        _approveERC20TokenIfNecessary(path[0].token0, chiefTrader.getTrader(traderId));
        return trader.swapExactOutput(traderId, amount, address(0), path, options);
    }

    function _push(uint256[] memory tokenAmounts, bytes memory)
        internal
        pure
        override
        returns (uint256[] memory actualTokenAmounts)
    {
        // no-op, tokens are already on balance
        return tokenAmounts;
    }

    function _pull(
        address to,
        uint256[] memory tokenAmounts,
        bytes memory
    ) internal override returns (uint256[] memory actualTokenAmounts) {
        for (uint256 i = 0; i < tokenAmounts.length; i++) {
            IERC20(_vaultTokens[i]).transfer(to, tokenAmounts[i]);
        }
        actualTokenAmounts = tokenAmounts;
    }

    function _postReclaimTokens(address, address[] memory tokens) internal view override {
        for (uint256 i = 0; i < tokens.length; i++) {
            require(!isVaultToken(tokens[i]), ExceptionsLibrary.OTHER_VAULT_TOKENS); // vault token is part of TVL
        }
    }

    function _isStrategy(address addr) internal view returns (bool) {
        return _vaultGovernance.internalParams().registry.getApproved(_nft) == addr;
    }

    function _approveERC20TokenIfNecessary(address token, address to) internal {
        if (IERC20(token).allowance(to, address(this)) < type(uint256).max / 2)
            IERC20(token).approve(to, type(uint256).max);
    }
}",994
RealWorld_BA_58_CommonLibrary_RealWord_20240821202757.log,58,CommonLibrary,22649,6272,28921,108.0,0.238685,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

/// @notice CommonLibrary shared utilities
library CommonLibrary {
    uint256 constant DENOMINATOR = 10**9;
    uint256 constant PRICE_DENOMINATOR = 10**18;
    uint256 constant YEAR = 365 * 24 * 3600;

    /// @notice Sort addresses using bubble sort. The sorting is done in-place.
    /// @param arr Array of addresses
    function bubbleSort(address[] memory arr) internal pure {
        uint256 l = arr.length;
        for (uint256 i = 0; i < l; i++) {
            for (uint256 j = i + 1; j < l; j++) {
                if (arr[i] > arr[j]) {
                    address temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
        }
    }

    /// @notice Checks if array of addresses is sorted and all adresses are unique
    /// @param tokens A set of addresses to check
    /// @return `true` if all addresses are sorted and unique, `false` otherwise
    function isSortedAndUnique(address[] memory tokens) internal pure returns (bool) {
        if (tokens.length < 2) {
            return true;
        }
        for (uint256 i = 0; i < tokens.length - 1; i++) {
            if (tokens[i] >= tokens[i + 1]) {
                return false;
            }
        }
        return true;
    }

    /// @dev
    /// Requires both sets of tokens to be sorted. When tokens are not sorted, it's undefined behavior.
    /// If there is a token in tokensToProject that is not part of tokens and corresponding tokenAmountsToProject > 0, reverts.
    /// Zero token amount is eqiuvalent to missing token
    function projectTokenAmounts(
        address[] memory tokens,
        address[] memory tokensToProject,
        uint256[] memory tokenAmountsToProject
    ) internal pure returns (uint256[] memory) {
        uint256[] memory res = new uint256[](tokens.length);
        uint256 t = 0;
        uint256 tp = 0;
        while ((t < tokens.length) && (tp < tokensToProject.length)) {
            if (tokens[t] < tokensToProject[tp]) {
                res[t] = 0;
                t++;
            } else if (tokens[t] > tokensToProject[tp]) {
                if (tokenAmountsToProject[tp] == 0) {
                    tp++;
                } else {
                    revert(""TPS"");
                }
            } else {
                res[t] = tokenAmountsToProject[tp];
                t++;
                tp++;
            }
        }
        while (t < tokens.length) {
            res[t] = 0;
            t++;
        }
        return res;
    }

    /// @notice Splits each amount of n tokens from `amounts` into k vaults according to `weights`.
    /// @dev Requires tokens and tokenAmounts to be vector of size n and delegatedTokenAmounts to be k x n matrix
    /// so that delegatedTokenAmounts[i] is a vector of size n
    /// norm is a vector 1 x k
    /// the error is up to k tokens due to rounding
    /// @param amounts Amounts to split, vector n x 1
    /// @param weights Weights of the split, matrix n x k, weights[i] is vector n x 1.
    /// Weights do not need to sum to 1 in each column, but they will be normalized on split.
    function splitAmounts(uint256[] memory amounts, uint256[][] memory weights)
        internal
        pure
        returns (uint256[][] memory)
    {
        uint256 k = weights.length;
        require(k > 0, ""KGT0"");
        uint256 n = amounts.length;
        require(n > 0, ""NGT0"");
        uint256[] memory weightsNorm = new uint256[](n);
        for (uint256 i = 0; i < k; i++) {
            require(weights[i].length == n, ""NV"");
        }
        for (uint256 j = 0; j < n; j++) {
            weightsNorm[j] = 0;
            for (uint256 i = 0; i < k; i++) {
                weightsNorm[j] += weights[i][j];
            }
        }
        uint256[][] memory res = new uint256[][](k);
        for (uint256 i = 0; i < k; i++) {
            res[i] = new uint256[](n);
            for (uint256 j = 0; j < n; j++) {
                if (weightsNorm[j] == 0) {
                    res[i][j] = amounts[j] / k;
                } else {
                    res[i][j] = (amounts[j] * weights[i][j]) / weightsNorm[j];
                }
            }
        }
        return res;
    }

    /// @notice Determines if a given address is a contract address
    /// @param addr Address to check
    /// @return `true` if the address is a contract address, `false` otherwise
    function isContract(address addr) internal view returns (bool) {
        uint32 size;
        assembly {
            size := extcodesize(addr)
        }
        return (size > 0);
    }
}",1165
RealWorld_BA_58_TickMath_RealWord_20240821203308.log,58,TickMath,50020,5516,55536,101.0,0.36042,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title Math library for computing sqrt prices from ticks and vice versa
/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports
/// prices between 2**-128 and 2**128
library TickMath {
    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128
    int24 internal constant MIN_TICK = -887272;
    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128
    int24 internal constant MAX_TICK = -MIN_TICK;

    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
    uint160 internal constant MIN_SQRT_RATIO = 4295128739;
    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)
    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;

    /// @notice Calculates sqrt(1.0001^tick) * 2^96
    /// @dev Throws if |tick| > max tick
    /// @param tick The input tick for the above formula
    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
    /// at the given tick
    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
        // diff: original require(absTick <= uint256(MAX_TICK), ""T"");
        require(absTick <= uint256(int256(MAX_TICK)), ""T"");

        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;

        if (tick > 0) ratio = type(uint256).max / ratio;

        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint
        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent
        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
    }

    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio
    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may
    /// ever return.
    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96
    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio
    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
        // second inequality must be < because the price can never reach the price at the max tick
        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, ""R"");
        uint256 ratio = uint256(sqrtPriceX96) << 32;

        uint256 r = ratio;
        uint256 msb = 0;

        assembly {
            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(5, gt(r, 0xFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(4, gt(r, 0xFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(3, gt(r, 0xFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(2, gt(r, 0xF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(1, gt(r, 0x3))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := gt(r, 0x1)
            msb := or(msb, f)
        }

        if (msb >= 128) r = ratio >> (msb - 127);
        else r = ratio << (127 - msb);

        int256 log_2 = (int256(msb) - 128) << 64;

        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(63, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(62, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(61, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(60, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(59, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(58, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(57, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(56, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(55, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(54, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(53, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(52, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(51, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(50, f))
        }

        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number

        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);

        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
    }
}",2878
RealWorld_BA_58_TestCallStatic_RealWord_20240821200413.log,58,TestCallStatic,4424,4641,9065,83.0,0.11494,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

contract TestCallStatic {
    uint256 private _a;

    function incA() external returns (uint256) {
        _a += 1;
        return _a;
    }

    function a() external view returns (uint256) {
        return _a;
    }
}",79
RealWorld_BA_58_LiquidityAmounts_RealWord_20240821203119.log,58,LiquidityAmounts,30137,5791,35928,107.0,0.266505,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

import ""./FullMath.sol"";
import ""./FixedPoint96.sol"";

/// @title Liquidity amount functions
/// @notice Provides functions for computing liquidity amounts from token amounts and prices
library LiquidityAmounts {
    /// @notice Downcasts uint256 to uint128
    /// @param x The uint258 to be downcasted
    /// @return y The passed value, downcasted to uint128
    function toUint128(uint256 x) private pure returns (uint128 y) {
        require((y = uint128(x)) == x);
    }

    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range
    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param amount0 The amount0 being sent in
    /// @return liquidity The amount of returned liquidity
    function getLiquidityForAmount0(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint256 amount0
    ) internal pure returns (uint128 liquidity) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
        uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);
        return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));
    }

    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range
    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param amount1 The amount1 being sent in
    /// @return liquidity The amount of returned liquidity
    function getLiquidityForAmount1(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint256 amount1
    ) internal pure returns (uint128 liquidity) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
        return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));
    }

    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current
    /// pool prices and the prices at the tick boundaries
    /// @param sqrtRatioX96 A sqrt price representing the current pool prices
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param amount0 The amount of token0 being sent in
    /// @param amount1 The amount of token1 being sent in
    /// @return liquidity The maximum amount of liquidity received
    function getLiquidityForAmounts(
        uint160 sqrtRatioX96,
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint256 amount0,
        uint256 amount1
    ) internal pure returns (uint128 liquidity) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);

        if (sqrtRatioX96 <= sqrtRatioAX96) {
            liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
        } else if (sqrtRatioX96 < sqrtRatioBX96) {
            uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);
            uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);

            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
        } else {
            liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);
        }
    }

    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param liquidity The liquidity being valued
    /// @return amount0 The amount of token0
    function getAmount0ForLiquidity(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint128 liquidity
    ) internal pure returns (uint256 amount0) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);

        return
            FullMath.mulDiv(
                uint256(liquidity) << FixedPoint96.RESOLUTION,
                sqrtRatioBX96 - sqrtRatioAX96,
                sqrtRatioBX96
            ) / sqrtRatioAX96;
    }

    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param liquidity The liquidity being valued
    /// @return amount1 The amount of token1
    function getAmount1ForLiquidity(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint128 liquidity
    ) internal pure returns (uint256 amount1) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);

        return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
    }

    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current
    /// pool prices and the prices at the tick boundaries
    /// @param sqrtRatioX96 A sqrt price representing the current pool prices
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param liquidity The liquidity being valued
    /// @return amount0 The amount of token0
    /// @return amount1 The amount of token1
    function getAmountsForLiquidity(
        uint160 sqrtRatioX96,
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint128 liquidity
    ) internal pure returns (uint256 amount0, uint256 amount1) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);

        if (sqrtRatioX96 <= sqrtRatioAX96) {
            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
        } else if (sqrtRatioX96 < sqrtRatioBX96) {
            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);
            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);
        } else {
            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
        }
    }
}",1688
RealWorld_BA_58_DataTypes_RealWord_20240821210817.log,58,DataTypes,9828,5660,15488,102.0,0.16234,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

library DataTypes {
    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.
    struct ReserveData {
        //stores the reserve configuration
        ReserveConfigurationMap configuration;
        //the liquidity index. Expressed in ray
        uint128 liquidityIndex;
        //variable borrow index. Expressed in ray
        uint128 variableBorrowIndex;
        //the current supply rate. Expressed in ray
        uint128 currentLiquidityRate;
        //the current variable borrow rate. Expressed in ray
        uint128 currentVariableBorrowRate;
        //the current stable borrow rate. Expressed in ray
        uint128 currentStableBorrowRate;
        uint40 lastUpdateTimestamp;
        //tokens addresses
        address aTokenAddress;
        address stableDebtTokenAddress;
        address variableDebtTokenAddress;
        //address of the interest rate strategy
        address interestRateStrategyAddress;
        //the id of the reserve. Represents the position in the list of the active reserves
        uint8 id;
    }

    struct ReserveConfigurationMap {
        //bit 0-15: LTV
        //bit 16-31: Liq. threshold
        //bit 32-47: Liq. bonus
        //bit 48-55: Decimals
        //bit 56: Reserve is active
        //bit 57: reserve is frozen
        //bit 58: borrowing is enabled
        //bit 59: stable rate borrowing enabled
        //bit 60-63: reserved
        //bit 64-79: reserve factor
        uint256 data;
    }

    struct UserConfigurationMap {
        uint256 data;
    }

    enum InterestRateMode {
        NONE,
        STABLE,
        VARIABLE
    }
}",398
RealWorld_BA_58_IUniswapV3PoolImmutables_RealWord_20240821212000.log,58,IUniswapV3PoolImmutables,10253,4430,14683,83.0,0.139865,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Pool state that never changes
/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values
interface IUniswapV3PoolImmutables {
    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface
    /// @return The contract address
    function factory() external view returns (address);

    /// @notice The first of the two tokens of the pool, sorted by address
    /// @return The token contract address
    function token0() external view returns (address);

    /// @notice The second of the two tokens of the pool, sorted by address
    /// @return The token contract address
    function token1() external view returns (address);

    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6
    /// @return The fee
    function fee() external view returns (uint24);

    /// @notice The pool tick spacing
    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
    /// This value is an int24 to avoid casting even though it is always positive.
    /// @return The tick spacing
    function tickSpacing() external view returns (int24);

    /// @notice The maximum amount of position liquidity that can use any tick in the range
    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and
    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool
    /// @return The max amount of liquidity per tick
    function maxLiquidityPerTick() external view returns (uint128);
}",435
RealWorld_BA_58_YearnVaultFactory_RealWord_20240821193152.log,58,YearnVaultFactory,6922,5302,12224,102.0,0.14065,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IVaultFactory.sol"";
import ""./YearnVault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Helper contract for YearnVaultGovernance that can create new Yearn Vaults.
contract YearnVaultFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    /// @notice Creates a new contract
    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind
    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    /// @inheritdoc IVaultFactory
    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        YearnVault vault = new YearnVault(vaultGovernance, vaultTokens);
        return IVault(vault);
    }
}",217
RealWorld_BA_58_IERC20VaultGovernance_RealWord_20240821234527.log,58,IERC20VaultGovernance,7511,5068,12579,100.0,0.138915,"// SPDX-License-Identifier: BSL-1.1
pragma solidity 0.8.9;

import ""../trader/interfaces/ITrader.sol"";
import ""./IVaultGovernance.sol"";

interface IERC20VaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param trader Reference to internal Trader contract
    struct DelayedProtocolParams {
        ITrader trader;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",266
RealWorld_BA_58_FullMath_RealWord_20240821203451.log,58,FullMath,24742,5784,30526,109.0,0.23939,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.9;

/// @title Contains 512-bit math functions
/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision
/// @dev Handles ""phantom overflow"" i.e., allows multiplication and division where an intermediate value overflows 256 bits
library FullMath {
    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
    /// @param a The multiplicand
    /// @param b The multiplier
    /// @param denominator The divisor
    /// @return result The 256-bit result
    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv
    function mulDiv(
        uint256 a,
        uint256 b,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        // diff: original lib works under 0.7.6 with overflows enabled
        unchecked {
            // 512-bit multiply [prod1 prod0] = a * b
            // Compute the product mod 2**256 and mod 2**256 - 1
            // then use the Chinese Remainder Theorem to reconstruct
            // the 512 bit result. The result is stored in two 256
            // variables such that product = prod1 * 2**256 + prod0
            uint256 prod0; // Least significant 256 bits of the product
            uint256 prod1; // Most significant 256 bits of the product
            assembly {
                let mm := mulmod(a, b, not(0))
                prod0 := mul(a, b)
                prod1 := sub(sub(mm, prod0), lt(mm, prod0))
            }

            // Handle non-overflow cases, 256 by 256 division
            if (prod1 == 0) {
                require(denominator > 0);
                assembly {
                    result := div(prod0, denominator)
                }
                return result;
            }

            // Make sure the result is less than 2**256.
            // Also prevents denominator == 0
            require(denominator > prod1);

            ///////////////////////////////////////////////
            // 512 by 256 division.
            ///////////////////////////////////////////////

            // Make division exact by subtracting the remainder from [prod1 prod0]
            // Compute remainder using mulmod
            uint256 remainder;
            assembly {
                remainder := mulmod(a, b, denominator)
            }
            // Subtract 256 bit number from 512 bit number
            assembly {
                prod1 := sub(prod1, gt(remainder, prod0))
                prod0 := sub(prod0, remainder)
            }

            // Factor powers of two out of denominator
            // Compute largest power of two divisor of denominator.
            // Always >= 1.
            // diff: original uint256 twos = -denominator & denominator;
            uint256 twos = uint256(-int256(denominator)) & denominator;
            // Divide denominator by power of two
            assembly {
                denominator := div(denominator, twos)
            }

            // Divide [prod1 prod0] by the factors of two
            assembly {
                prod0 := div(prod0, twos)
            }
            // Shift in bits from prod1 into prod0. For this we need
            // to flip `twos` such that it is 2**256 / twos.
            // If twos is zero, then it becomes one
            assembly {
                twos := add(div(sub(0, twos), twos), 1)
            }
            prod0 |= prod1 * twos;

            // Invert denominator mod 2**256
            // Now that denominator is an odd number, it has an inverse
            // modulo 2**256 such that denominator * inv = 1 mod 2**256.
            // Compute the inverse by starting with a seed that is correct
            // correct for four bits. That is, denominator * inv = 1 mod 2**4
            uint256 inv = (3 * denominator) ^ 2;
            // Now use Newton-Raphson iteration to improve the precision.
            // Thanks to Hensel's lifting lemma, this also works in modular
            // arithmetic, doubling the correct bits in each step.
            inv *= 2 - denominator * inv; // inverse mod 2**8
            inv *= 2 - denominator * inv; // inverse mod 2**16
            inv *= 2 - denominator * inv; // inverse mod 2**32
            inv *= 2 - denominator * inv; // inverse mod 2**64
            inv *= 2 - denominator * inv; // inverse mod 2**128
            inv *= 2 - denominator * inv; // inverse mod 2**256

            // Because the division is now exact we can divide by multiplying
            // with the modular inverse of denominator. This will give us the
            // correct result modulo 2**256. Since the precoditions guarantee
            // that the outcome is less than 2**256, this is the final result.
            // We don't need to compute the high bits of the result and prod1
            // is no longer required.
            result = prod0 * inv;
            return result;
        }
    }

    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
    /// @param a The multiplicand
    /// @param b The multiplier
    /// @param denominator The divisor
    /// @return result The 256-bit result
    function mulDivRoundingUp(
        uint256 a,
        uint256 b,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        // diff: original lib works under 0.7.6 with overflows enabled
        unchecked {
            result = mulDiv(a, b, denominator);
            if (mulmod(a, b, denominator) > 0) {
                require(result < type(uint256).max);
                result++;
            }
        }
    }
}",1308
RealWorld_BA_58_ChiefTrader_RealWord_20240821201832.log,58,ChiefTrader,17590,5887,23477,99.0,0.20569,"// SPDX-License-Identifier: BSL-1.1
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import ""../interfaces/IProtocolGovernance.sol"";
import ""./interfaces/ITrader.sol"";
import ""./interfaces/IChiefTrader.sol"";
import ""./libraries/TraderExceptionsLibrary.sol"";

/// @notice Main contract that allows trading of ERC20 tokens on different Dexes
/// @dev This contract contains several subtraders that can be used for trading ERC20 tokens.
/// Examples of subtraders are UniswapV3, UniswapV2, SushiSwap, Curve, etc.
contract ChiefTrader is ERC165, IChiefTrader, ITrader {
    address public immutable protocolGovernance;
    address[] internal _traders;
    mapping(address => bool) public addedTraders;

    constructor(address _protocolGovernance) {
        protocolGovernance = _protocolGovernance;
    }

    /// @inheritdoc IChiefTrader
    function tradersCount() external view returns (uint256) {
        return _traders.length;
    }

    function getTrader(uint256 _index) external view returns (address) {
        return _traders[_index];
    }

    function traders() external view returns (address[] memory) {
        return _traders;
    }

    /// @inheritdoc IChiefTrader
    function addTrader(address traderAddress) external {
        _requireProtocolAdmin();
        require(traderAddress != address(this), TraderExceptionsLibrary.RECURRENCE_EXCEPTION);
        require(!addedTraders[traderAddress], TraderExceptionsLibrary.TRADER_ALREADY_REGISTERED_EXCEPTION);
        require(ERC165(traderAddress).supportsInterface(type(ITrader).interfaceId));
        require(!ERC165(traderAddress).supportsInterface(type(IChiefTrader).interfaceId));
        _traders.push(traderAddress);
        addedTraders[traderAddress] = true;
        emit AddedTrader(_traders.length - 1, traderAddress);
    }

    /// @inheritdoc ITrader
    function swapExactInput(
        uint256 traderId,
        uint256 amount,
        address,
        PathItem[] calldata path,
        bytes calldata options
    ) external returns (uint256) {
        require(traderId < _traders.length, TraderExceptionsLibrary.TRADER_NOT_FOUND_EXCEPTION);
        _requireAllowedTokens(path);
        address traderAddress = _traders[traderId];
        address recipient = msg.sender;
        return ITrader(traderAddress).swapExactInput(0, amount, recipient, path, options);
    }

    /// @inheritdoc ITrader
    function swapExactOutput(
        uint256 traderId,
        uint256 amount,
        address,
        PathItem[] calldata path,
        bytes calldata options
    ) external returns (uint256) {
        require(traderId < _traders.length, TraderExceptionsLibrary.TRADER_NOT_FOUND_EXCEPTION);
        _requireAllowedTokens(path);
        address traderAddress = _traders[traderId];
        address recipient = msg.sender;
        return ITrader(traderAddress).swapExactOutput(0, amount, recipient, path, options);
    }

    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {
        return (interfaceId == this.supportsInterface.selector ||
            interfaceId == type(ITrader).interfaceId ||
            interfaceId == type(IChiefTrader).interfaceId);
    }

    function _requireAllowedTokens(PathItem[] memory path) internal view {
        IProtocolGovernance pg = IProtocolGovernance(protocolGovernance);
        for (uint256 i = 1; i < path.length; ++i)
            require(
                pg.isAllowedToken(path[i].token0) && pg.isAllowedToken(path[i].token1),
                TraderExceptionsLibrary.TOKEN_NOT_ALLOWED_EXCEPTION
            );
        if (path.length > 0)
            require(pg.isAllowedToken(path[0].token1), TraderExceptionsLibrary.TOKEN_NOT_ALLOWED_EXCEPTION);
    }

    function _requireProtocolAdmin() internal view {
        require(
            IProtocolGovernance(protocolGovernance).isAdmin(msg.sender),
            TraderExceptionsLibrary.PROTOCOL_ADMIN_REQUIRED_EXCEPTION
        );
    }

    event AddedTrader(uint256 indexed traderId, address traderAddress);
}",885
RealWorld_BA_58_AaveVaultFactory_RealWord_20240821221546.log,58,AaveVaultFactory,6757,5099,11856,93.0,0.135765,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

import ""./interfaces/IVaultFactory.sol"";
import ""./AaveVault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Helper contract for AaveVaultGovernance that can create new Aave Vaults.
contract AaveVaultFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    /// @notice Creates a new contract
    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind
    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    /// @inheritdoc IVaultFactory
    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        AaveVault vault = new AaveVault(vaultGovernance, vaultTokens);
        return IVault(vault);
    }
}",217
RealWorld_BA_58_IVaultRegistry_RealWord_20240821234709.log,58,IVaultRegistry,13155,5258,18413,94.0,0.170935,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""./IProtocolGovernance.sol"";
import ""./IVaultFactory.sol"";
import ""./IVaultGovernance.sol"";

interface IVaultRegistry is IERC721 {
    /// @notice Get Vault for the giver NFT ID.
    /// @param nftId NFT ID
    /// @return vault Address of the Vault contract
    function vaultForNft(uint256 nftId) external view returns (address vault);

    /// @notice Get NFT ID for given Vault contract address.
    /// @param vault Address of the Vault contract
    /// @return nftId NFT ID
    function nftForVault(address vault) external view returns (uint256 nftId);

    /// @notice Checks if the nft is locked for all transfers
    /// @param nft NFT to check for lock
    /// @return `true` if locked, false otherwise
    function isLocked(uint256 nft) external view returns (bool);

    /// @notice Register new Vault and mint NFT.
    /// @param vault address of the vault
    /// @param owner owner of the NFT
    /// @return nft Nft minted for the given Vault
    function registerVault(address vault, address owner) external returns (uint256 nft);

    /// @notice Number of Vaults registered.
    function vaultsCount() external view returns (uint256);

    /// @notice All Vaults registered.
    function vaults() external view returns (address[] memory);

    /// @notice Address of the ProtocolGovernance.
    function protocolGovernance() external view returns (IProtocolGovernance);

    /// @notice Address of the staged ProtocolGovernance.
    function stagedProtocolGovernance() external view returns (IProtocolGovernance);

    /// @notice Minimal timestamp when staged ProtocolGovernance can be applied.
    function stagedProtocolGovernanceTimestamp() external view returns (uint256);

    /// @notice Stage new ProtocolGovernance.
    /// @param newProtocolGovernance new ProtocolGovernance
    function stageProtocolGovernance(IProtocolGovernance newProtocolGovernance) external;

    /// @notice Commit new ProtocolGovernance.
    function commitStagedProtocolGovernance() external;

    /// @notice Approve nft to new address
    /// @dev This can be called only by the Protocol Governance. It is used to disable the strategy for a vault
    /// @param newAddress address that will be approved
    /// @param nft for re-approval
    function adminApprove(address newAddress, uint256 nft) external;

    /// @notice Lock NFT for transfers
    /// @dev Use this method when vault structure is set up and should become immutable. Can be called by owner.
    /// @param nft - NFT to lock
    function lockNft(uint256 nft) external;
}",619
RealWorld_BA_58_GatewayVaultTestFactory_RealWord_20240821224557.log,58,GatewayVaultTestFactory,6294,5166,11460,96.0,0.13479,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../interfaces/IVaultFactory.sol"";
import ""../interfaces/IVaultGovernance.sol"";
import ""./GatewayVaultTest.sol"";

contract GatewayVaultTestFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    function setVaultGovernance(address newVaultGovernance) public {
        vaultGovernance = IVaultGovernance(newVaultGovernance);
    }

    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ""VG"");
        GatewayVaultTest gatewayVault = new GatewayVaultTest(vaultGovernance, vaultTokens);
        return IVault(gatewayVault);
    }
}",184
RealWorld_BA_58_ILpIssuerGovernance_RealWord_20240821212125.log,58,ILpIssuerGovernance,20462,5207,25669,100.0,0.20645,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";

interface ILpIssuerGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param strategyTreasury Reference to address that will collect strategy management fees
    /// @param strategyPerformanceTreasury Reference to address that will collect strategy performance fees
    /// @param managementFee Management fee for Strategist denominated in 10 ** 9
    /// @param performanceFee Performance fee for Strategist denominated in 10 ** 9
    struct DelayedStrategyParams {
        address strategyTreasury;
        address strategyPerformanceTreasury;
        uint256 managementFee;
        uint256 performanceFee;
    }

    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param managementFeeChargeDelay The minimal interval between management fee charges
    struct DelayedProtocolParams {
        uint256 managementFeeChargeDelay;
    }

    /// @notice Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param tokenLimitPerAddress Reference to address that will collect strategy fees
    struct StrategyParams {
        uint256 tokenLimitPerAddress;
    }

    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param protocolFee Management fee for Protocol denominated in 10 ** 9
    struct DelayedProtocolPerVaultParams {
        uint256 protocolFee;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Per Vault Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    function delayedProtocolPerVaultParams(uint256 nft) external view returns (DelayedProtocolPerVaultParams memory);

    /// @notice Delayed Protocol Per Vault Params staged for commit after delay.
    /// @param nft VaultRegistry NFT of the vault
    function stagedDelayedProtocolPerVaultParams(uint256 nft)
        external
        view
        returns (DelayedProtocolPerVaultParams memory);

    /// @notice Strategy Params.
    /// @param nft VaultRegistry NFT of the vault
    function strategyParams(uint256 nft) external view returns (StrategyParams memory);

    /// @notice Delayed Strategy Params
    /// @param nft VaultRegistry NFT of the vault
    function delayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Delayed Strategy Params staged for commit after delay.
    /// @param nft VaultRegistry NFT of the vault
    function stagedDelayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Set Strategy params, i.e. Params that could be changed by Strategy or Protocol Governance immediately.
    /// @param nft Nft of the vault
    /// @param params New params
    function setStrategyParams(uint256 nft, StrategyParams calldata params) external;

    /// @notice Stage Delayed Protocol Per Vault Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params
    function stageDelayedProtocolPerVaultParams(uint256 nft, DelayedProtocolPerVaultParams calldata params) external;

    /// @notice Commit Delayed Protocol Per Vault Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolPerVaultParamsTimestamp
    /// @param nft VaultRegistry NFT of the vault
    function commitDelayedProtocolPerVaultParams(uint256 nft) external;

    /// @notice Stage Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params
    function stageDelayedStrategyParams(uint256 nft, DelayedStrategyParams calldata params) external;

    /// @notice Commit Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedStrategyParamsTimestamp
    /// @param nft VaultRegistry NFT of the vault
    function commitDelayedStrategyParams(uint256 nft) external;

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",1089
RealWorld_BA_58_IYearnVaultRegistry_RealWord_20240821235840.log,58,IYearnVaultRegistry,3766,3989,7755,138.0,0.09861,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.9;

interface IYearnVaultRegistry {
    function latestVault(address vault) external view returns (address);
}",37
RealWorld_BA_58_ILendingPool_RealWord_20240821210430.log,58,ILendingPool,67039,6187,73226,128.0,0.458935,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;
pragma experimental ABIEncoderV2;

import {ILendingPoolAddressesProvider} from ""./ILendingPoolAddressesProvider.sol"";
import {DataTypes} from ""./DataTypes.sol"";

interface ILendingPool {
    /**
     * @dev Emitted on deposit()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address initiating the deposit
     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens
     * @param amount The amount deposited
     * @param referral The referral code used
     **/
    event Deposit(
        address indexed reserve,
        address user,
        address indexed onBehalfOf,
        uint256 amount,
        uint16 indexed referral
    );

    /**
     * @dev Emitted on withdraw()
     * @param reserve The address of the underlyng asset being withdrawn
     * @param user The address initiating the withdrawal, owner of aTokens
     * @param to Address that will receive the underlying
     * @param amount The amount to be withdrawn
     **/
    event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);

    /**
     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened
     * @param reserve The address of the underlying asset being borrowed
     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just
     * initiator of the transaction on flashLoan()
     * @param onBehalfOf The address that will be getting the debt
     * @param amount The amount borrowed out
     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable
     * @param borrowRate The numeric rate at which the user has borrowed
     * @param referral The referral code used
     **/
    event Borrow(
        address indexed reserve,
        address user,
        address indexed onBehalfOf,
        uint256 amount,
        uint256 borrowRateMode,
        uint256 borrowRate,
        uint16 indexed referral
    );

    /**
     * @dev Emitted on repay()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The beneficiary of the repayment, getting his debt reduced
     * @param repayer The address of the user initiating the repay(), providing the funds
     * @param amount The amount repaid
     **/
    event Repay(address indexed reserve, address indexed user, address indexed repayer, uint256 amount);

    /**
     * @dev Emitted on swapBorrowRateMode()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user swapping his rate mode
     * @param rateMode The rate mode that the user wants to swap to
     **/
    event Swap(address indexed reserve, address indexed user, uint256 rateMode);

    /**
     * @dev Emitted on setUserUseReserveAsCollateral()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user enabling the usage as collateral
     **/
    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on setUserUseReserveAsCollateral()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user enabling the usage as collateral
     **/
    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on rebalanceStableBorrowRate()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user for which the rebalance has been executed
     **/
    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on flashLoan()
     * @param target The address of the flash loan receiver contract
     * @param initiator The address initiating the flash loan
     * @param asset The address of the asset being flash borrowed
     * @param amount The amount flash borrowed
     * @param premium The fee flash borrowed
     * @param referralCode The referral code used
     **/
    event FlashLoan(
        address indexed target,
        address indexed initiator,
        address indexed asset,
        uint256 amount,
        uint256 premium,
        uint16 referralCode
    );

    /**
     * @dev Emitted when the pause is triggered.
     */
    event Paused();

    /**
     * @dev Emitted when the pause is lifted.
     */
    event Unpaused();

    /**
     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via
     * LendingPoolCollateral manager using a DELEGATECALL
     * This allows to have the events in the generated ABI for LendingPool.
     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation
     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation
     * @param user The address of the borrower getting liquidated
     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover
     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator
     * @param liquidator The address of the liquidator
     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants
     * to receive the underlying collateral asset directly
     **/
    event LiquidationCall(
        address indexed collateralAsset,
        address indexed debtAsset,
        address indexed user,
        uint256 debtToCover,
        uint256 liquidatedCollateralAmount,
        address liquidator,
        bool receiveAToken
    );

    /**
     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared
     * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,
     * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it
     * gets added to the LendingPool ABI
     * @param reserve The address of the underlying asset of the reserve
     * @param liquidityRate The new liquidity rate
     * @param stableBorrowRate The new stable borrow rate
     * @param variableBorrowRate The new variable borrow rate
     * @param liquidityIndex The new liquidity index
     * @param variableBorrowIndex The new variable borrow index
     **/
    event ReserveDataUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    /**
     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.
     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC
     * @param asset The address of the underlying asset to deposit
     * @param amount The amount to be deposited
     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user
     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens
     *   is a different wallet
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     **/
    function deposit(
        address asset,
        uint256 amount,
        address onBehalfOf,
        uint16 referralCode
    ) external;

    /**
     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned
     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC
     * @param asset The address of the underlying asset to withdraw
     * @param amount The underlying amount to be withdrawn
     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance
     * @param to Address that will receive the underlying, same as msg.sender if the user
     *   wants to receive it on his own wallet, or a different address if the beneficiary is a
     *   different wallet
     * @return The final amount withdrawn
     **/
    function withdraw(
        address asset,
        uint256 amount,
        address to
    ) external returns (uint256);

    /**
     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower
     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the
     * corresponding debt token (StableDebtToken or VariableDebtToken)
     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet
     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`
     * @param asset The address of the underlying asset to borrow
     * @param amount The amount to be borrowed
     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself
     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator
     * if he has been given credit delegation allowance
     **/
    function borrow(
        address asset,
        uint256 amount,
        uint256 interestRateMode,
        uint16 referralCode,
        address onBehalfOf
    ) external;

    /**
     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned
     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address
     * @param asset The address of the borrowed underlying asset previously borrowed
     * @param amount The amount to repay
     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`
     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable
     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the
     * user calling the function if he wants to reduce/remove his own debt, or the address of any other
     * other borrower whose debt should be removed
     * @return The final amount repaid
     **/
    function repay(
        address asset,
        uint256 amount,
        uint256 rateMode,
        address onBehalfOf
    ) external returns (uint256);

    /**
     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa
     * @param asset The address of the underlying asset borrowed
     * @param rateMode The rate mode that the user wants to swap to
     **/
    function swapBorrowRateMode(address asset, uint256 rateMode) external;

    /**
     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.
     * - Users can be rebalanced if the following conditions are satisfied:
     *     1. Usage ratio is above 95%
     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been
     *        borrowed at a stable rate and depositors are not earning enough
     * @param asset The address of the underlying asset borrowed
     * @param user The address of the user to be rebalanced
     **/
    function rebalanceStableBorrowRate(address asset, address user) external;

    /**
     * @dev Allows depositors to enable/disable a specific deposited asset as collateral
     * @param asset The address of the underlying asset deposited
     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise
     **/
    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;

    /**
     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1
     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives
     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk
     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation
     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation
     * @param user The address of the borrower getting liquidated
     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover
     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants
     * to receive the underlying collateral asset directly
     **/
    function liquidationCall(
        address collateralAsset,
        address debtAsset,
        address user,
        uint256 debtToCover,
        bool receiveAToken
    ) external;

    /**
     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,
     * as long as the amount taken plus a fee is returned.
     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.
     * For further details please visit https://developers.aave.com
     * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface
     * @param assets The addresses of the assets being flash-borrowed
     * @param amounts The amounts amounts being flash-borrowed
     * @param modes Types of the debt to open if the flash loan is not returned:
     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver
     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address
     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address
     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2
     * @param params Variadic packed params to pass to the receiver as extra information
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     **/
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata modes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;

    /**
     * @dev Returns the user account data across all the reserves
     * @param user The address of the user
     * @return totalCollateralETH the total collateral in ETH of the user
     * @return totalDebtETH the total debt in ETH of the user
     * @return availableBorrowsETH the borrowing power left of the user
     * @return currentLiquidationThreshold the liquidation threshold of the user
     * @return ltv the loan to value of the user
     * @return healthFactor the current health factor of the user
     **/
    function getUserAccountData(address user)
        external
        view
        returns (
            uint256 totalCollateralETH,
            uint256 totalDebtETH,
            uint256 availableBorrowsETH,
            uint256 currentLiquidationThreshold,
            uint256 ltv,
            uint256 healthFactor
        );

    function initReserve(
        address reserve,
        address aTokenAddress,
        address stableDebtAddress,
        address variableDebtAddress,
        address interestRateStrategyAddress
    ) external;

    function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;

    function setConfiguration(address reserve, uint256 configuration) external;

    /**
     * @dev Returns the configuration of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The configuration of the reserve
     **/
    function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);

    /**
     * @dev Returns the configuration of the user across all the reserves
     * @param user The user address
     * @return The configuration of the user
     **/
    function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);

    /**
     * @dev Returns the normalized income normalized income of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The reserve's normalized income
     */
    function getReserveNormalizedIncome(address asset) external view returns (uint256);

    /**
     * @dev Returns the normalized variable debt per unit of asset
     * @param asset The address of the underlying asset of the reserve
     * @return The reserve normalized variable debt
     */
    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);

    /**
     * @dev Returns the state and configuration of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The state of the reserve
     **/
    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);

    function finalizeTransfer(
        address asset,
        address from,
        address to,
        uint256 amount,
        uint256 balanceFromAfter,
        uint256 balanceToBefore
    ) external;

    function getReservesList() external view returns (address[] memory);

    function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);

    function setPause(bool val) external;

    function paused() external view returns (bool);
}",3997
RealWorld_BA_58_IYearnVault_RealWord_20240821210143.log,58,IYearnVault,5363,5257,10620,97.0,0.131955,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IYearnVault is IERC20 {
    function decimals() external view returns (uint256);

    function pricePerShare() external view returns (uint256);

    function deposit(uint256 amount, address recipient) external returns (uint256);

    // Default maxLoss = 1, i.e. 0.01% [BPS]
    function withdraw(
        uint256 maxShares,
        address recipient,
        uint256 maxLoss
    ) external returns (uint256);
}",133
RealWorld_BA_58_IVault_RealWord_20240821234146.log,58,IVault,23336,5653,28989,118.0,0.22974,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";

interface IVault {
    /// @notice VaultRegistry NFT for this vault
    function nft() external view returns (uint256);

    /// @notice Address of the Vault Governance for this contract.
    function vaultGovernance() external view returns (IVaultGovernance);

    /// @notice ERC20 tokens under Vault management.
    function vaultTokens() external view returns (address[] memory);

    /// @notice Total value locked for this contract.
    /// @dev Generally it is the underlying token value of this contract in some
    /// other DeFi protocol. For example, for USDC Yearn Vault this would be total USDC balance that could be withdrawn for Yearn to this contract.
    /// @return tokenAmounts Total available balances for multiple tokens (nth tokenAmount corresponds to nth token in vaultTokens)
    function tvl() external view returns (uint256[] memory tokenAmounts);

    /// @notice Initialize contract with vault nft
    /// @param nft VaultRegistry NFT for this vault
    function initialize(uint256 nft) external;

    /// @notice Pushes tokens on the vault balance to the underlying protocol. For example, for Yearn this operation will take USDC from
    /// the contract balance and convert it to yUSDC.
    /// @dev Can only be called but Vault Owner or Strategy. Vault owner is the owner of NFT for this vault in VaultManager.
    /// Strategy is approved address for the vault NFT.
    ///
    /// Tokens **must** be a subset of Vault Tokens. However, the convention is that if tokenAmount == 0 it is the same as token is missing.
    ///
    /// Also notice that this operation doesn't guarantee that tokenAmounts will be invested in full.
    /// @param tokens Tokens to push
    /// @param tokenAmounts Amounts of tokens to push
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param. For the exact bytes structure see concrete vault descriptions
    /// @return actualTokenAmounts The amounts actually invested. It could be less than tokenAmounts (but not higher)
    function push(
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external returns (uint256[] memory actualTokenAmounts);

    /// @notice The same as `push` method above but transfers tokens to vault balance prior to calling push.
    /// After the `push` it returns all the leftover tokens back (`push` method doesn't guarantee that tokenAmounts will be invested in full).
    /// @param tokens Tokens to push
    /// @param tokenAmounts Amounts of tokens to push
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param. For the exact bytes structure see concrete vault descriptions
    /// @return actualTokenAmounts The amounts actually invested. It could be less than tokenAmounts (but not higher)
    function transferAndPush(
        address from,
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external returns (uint256[] memory actualTokenAmounts);

    /// @notice Pulls tokens from the underlying protocol to the `to` address.
    /// For example, for Yearn this operation will take yUSDC from
    /// the Yearn protocol, convert it to USDC and send to `to` address.
    /// @dev Can only be called but Vault Owner or Strategy. Vault owner is the owner of NFT for this vault in VaultManager.
    /// Strategy is approved address for the vault NFT. There's a subtle difference however - while vault owner
    /// can pull the tokens to any address, Strategy can only pull to other vault in the Vault System (a set of vaults united by the Gateway Vault)
    ///
    /// Tokens **must** be a subset of Vault Tokens. However, the convention is that if tokenAmount == 0 it is the same as token is missing.
    ///
    /// Also notice that this operation doesn't guarantee that tokenAmounts will be invested in full.
    /// @param to Address to receive the tokens
    /// @param tokens Tokens to pull
    /// @param tokenAmounts Amounts of tokens to pull
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param. For the exact bytes structure see concrete vault descriptions
    /// @return actualTokenAmounts The amounts actually withdrawn. It could be less than tokenAmounts (but not higher)
    function pull(
        address to,
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external returns (uint256[] memory actualTokenAmounts);

    /// @notice This method is for claiming accidentally accumulated tokens on the contact's balance.
    /// @dev Can only be called by Protocol Governance.
    /// @param to Address that will receive the tokens
    /// @param tokens Tokens to claim. Each token must be other than those in vaultTokens
    function reclaimTokens(address to, address[] memory tokens) external;

    /// @notice Claim liquidity mining rewards.
    /// @dev Can only be called by Vault Owner or Strategy. Vault owner is the owner of NFT for this vault in VaultManager.
    /// Strategy is approved address for the vault NFT.
    ///
    /// Since this method allows sending arbitrary transactions, the destinations of the calls
    /// are whitelisted by Protocol Governance.
    /// @param from Address of the reward pool
    /// @param data Abi encoded call to the `from` address
    function claimRewards(address from, bytes memory data) external;

    function isVaultToken(address token) external view returns (bool);
}",1252
RealWorld_BA_58_ISwapRouter_RealWord_20240822001610.log,58,ISwapRouter,12114,5061,17175,104.0,0.16179,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.7.5;
pragma abicoder v2;

/// @title Router token swapping functionality
/// @notice Functions for swapping tokens via Uniswap V3
interface ISwapRouter {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    /// @notice Swaps `amountIn` of one token for as much as possible of another token
    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata
    /// @return amountOut The amount of the received token
    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);

    struct ExactInputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
    }

    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path
    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata
    /// @return amountOut The amount of the received token
    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);

    struct ExactOutputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
        uint160 sqrtPriceLimitX96;
    }

    /// @notice Swaps as little as possible of one token for `amountOut` of another token
    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata
    /// @return amountIn The amount of the input token
    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);

    struct ExactOutputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
    }

    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)
    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata
    /// @return amountIn The amount of the input token
    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);
}",571
RealWorld_BA_58_IYearnVault_RealWord_20240821235710.log,58,IYearnVault,5474,5153,10627,88.0,0.13043,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IYearnVault is IERC20 {
    function decimals() external view returns (uint256);

    function pricePerShare() external view returns (uint256);

    function deposit(uint256 amount, address recipient) external returns (uint256);

    // Default maxLoss = 1, i.e. 0.01% [BPS]
    function withdraw(
        uint256 maxShares,
        address recipient,
        uint256 maxLoss
    ) external returns (uint256);
}",133
RealWorld_BA_58_Trader_RealWord_20240821231553.log,58,Trader,5863,4326,10189,79.0,0.115835,"// SPDX-License-Identifier: BSL-1.1
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";

import ""./interfaces/ITrader.sol"";

/// @notice Base contract for every trader contract (a contract that can execute ERC20 swaps)
abstract contract Trader is ERC165 {
    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {
        return (interfaceId == this.supportsInterface.selector || interfaceId == type(ITrader).interfaceId);
    }

    function _approveERC20TokenIfNecessary(address token, address to) internal {
        if (IERC20(token).allowance(to, address(this)) < type(uint256).max / 2)
            IERC20(token).approve(to, type(uint256).max);
    }
}",192
RealWorld_BA_58_IUniswapV3Pool_RealWord_20240822000846.log,58,IUniswapV3Pool,5446,4981,10427,89.0,0.12685,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

import './pool/IUniswapV3PoolImmutables.sol';
import './pool/IUniswapV3PoolState.sol';

/// @title The interface for a Uniswap V3 Pool
/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform
/// to the ERC20 specification
/// @dev The pool interface is broken up into many smaller pieces
interface IUniswapV3Pool is
    IUniswapV3PoolImmutables,
    IUniswapV3PoolState
{

}",142
RealWorld_BA_58_UniV3VaultFactory_RealWord_20240821222606.log,58,UniV3VaultFactory,7783,4878,12661,87.0,0.136475,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.9;

import ""./interfaces/IVaultFactory.sol"";
import ""./UniV3Vault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Helper contract for UniV3VaultGovernance that can create new UniV3 Vaults.
contract UniV3VaultFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind
    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    /// @notice Deploy a new vault.
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Should equal UniV3 pool fee
    function deployVault(address[] memory vaultTokens, bytes memory options) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        uint256 fee = abi.decode(options, (uint256));
        UniV3Vault vault = new UniV3Vault(vaultGovernance, vaultTokens, uint24(fee));
        return IVault(vault);
    }
}",271
RealWorld_BA_58_IChiefTrader_RealWord_20240821232025.log,58,IChiefTrader,6116,4864,10980,86.0,0.12786,"// SPDX-License-Identifier: BSL-1.1
pragma solidity =0.8.9;

import ""../../interfaces/IProtocolGovernance.sol"";

interface IChiefTrader {
    /// @notice ProtocolGovernance
    /// @return the address of the protocol governance contract
    function protocolGovernance() external view returns (address);

    /// @notice Count of traders
    function tradersCount() external view returns (uint256);

    /// @notice Get the address of the trader at index
    /// @param _index The index of the trader
    function getTrader(uint256 _index) external view returns (address);

    /// @notice Get all registered traders
    function traders() external view returns (address[] memory);

    /// @notice Add new trader
    /// @param traderAddress the address of the trader
    function addTrader(address traderAddress) external;
}",179
RealWorld_BA_58_UniV3VaultGovernanceTest_RealWord_20240821200725.log,58,UniV3VaultGovernanceTest,5609,5490,11099,93.0,0.137845,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../interfaces/IUniV3VaultGovernance.sol"";
import ""../UniV3VaultGovernance.sol"";
import ""../VaultGovernance.sol"";

contract UniV3VaultGovernanceTest is UniV3VaultGovernance {
    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)
        UniV3VaultGovernance(internalParams_, delayedProtocolParams_)
    {
        delete _delayedProtocolParams;
    }
}",111
RealWorld_BA_58_ILpIssuerGovernance_RealWord_20240821233329.log,58,ILpIssuerGovernance,20491,4980,25471,86.0,0.202055,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";

interface ILpIssuerGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param strategyTreasury Reference to address that will collect strategy management fees
    /// @param strategyPerformanceTreasury Reference to address that will collect strategy performance fees
    /// @param managementFee Management fee for Strategist denominated in 10 ** 9
    /// @param performanceFee Performance fee for Strategist denominated in 10 ** 9
    struct DelayedStrategyParams {
        address strategyTreasury;
        address strategyPerformanceTreasury;
        uint256 managementFee;
        uint256 performanceFee;
    }

    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param managementFeeChargeDelay The minimal interval between management fee charges
    struct DelayedProtocolParams {
        uint256 managementFeeChargeDelay;
    }

    /// @notice Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param tokenLimitPerAddress Reference to address that will collect strategy fees
    struct StrategyParams {
        uint256 tokenLimitPerAddress;
    }

    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param protocolFee Management fee for Protocol denominated in 10 ** 9
    struct DelayedProtocolPerVaultParams {
        uint256 protocolFee;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Per Vault Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    function delayedProtocolPerVaultParams(uint256 nft) external view returns (DelayedProtocolPerVaultParams memory);

    /// @notice Delayed Protocol Per Vault Params staged for commit after delay.
    /// @param nft VaultRegistry NFT of the vault
    function stagedDelayedProtocolPerVaultParams(uint256 nft)
        external
        view
        returns (DelayedProtocolPerVaultParams memory);

    /// @notice Strategy Params.
    /// @param nft VaultRegistry NFT of the vault
    function strategyParams(uint256 nft) external view returns (StrategyParams memory);

    /// @notice Delayed Strategy Params
    /// @param nft VaultRegistry NFT of the vault
    function delayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Delayed Strategy Params staged for commit after delay.
    /// @param nft VaultRegistry NFT of the vault
    function stagedDelayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Set Strategy params, i.e. Params that could be changed by Strategy or Protocol Governance immediately.
    /// @param nft Nft of the vault
    /// @param params New params
    function setStrategyParams(uint256 nft, StrategyParams calldata params) external;

    /// @notice Stage Delayed Protocol Per Vault Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params
    function stageDelayedProtocolPerVaultParams(uint256 nft, DelayedProtocolPerVaultParams calldata params) external;

    /// @notice Commit Delayed Protocol Per Vault Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolPerVaultParamsTimestamp
    /// @param nft VaultRegistry NFT of the vault
    function commitDelayedProtocolPerVaultParams(uint256 nft) external;

    /// @notice Stage Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params
    function stageDelayedStrategyParams(uint256 nft, DelayedStrategyParams calldata params) external;

    /// @notice Commit Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedStrategyParamsTimestamp
    /// @param nft VaultRegistry NFT of the vault
    function commitDelayedStrategyParams(uint256 nft) external;

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",1089
RealWorld_BA_58_ERC20VaultFactory_RealWord_20240821193506.log,58,ERC20VaultFactory,6986,5217,12203,111.0,0.13927,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IVaultFactory.sol"";
import ""./ERC20Vault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Helper contract for ERC20VaultGovernance that can create new ERC20 Vaults.
contract ERC20VaultFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind
    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    /// @inheritdoc IVaultFactory
    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        ERC20Vault vault = new ERC20Vault(vaultGovernance, vaultTokens);
        return IVault(vault);
    }
}",217
RealWorld_BA_58_CommonLibrary_RealWord_20240821232320.log,58,CommonLibrary,21926,5724,27650,97.0,0.22411,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

/// @notice CommonLibrary shared utilities
library CommonLibrary {
    uint256 constant DENOMINATOR = 10**9;
    uint256 constant PRICE_DENOMINATOR = 10**18;
    uint256 constant YEAR = 365 * 24 * 3600;

    /// @notice Sort addresses using bubble sort. The sorting is done in-place.
    /// @param arr Array of addresses
    function bubbleSort(address[] memory arr) internal pure {
        uint256 l = arr.length;
        for (uint256 i = 0; i < l; i++) {
            for (uint256 j = i + 1; j < l; j++) {
                if (arr[i] > arr[j]) {
                    address temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
        }
    }

    /// @notice Checks if array of addresses is sorted and all adresses are unique
    /// @param tokens A set of addresses to check
    /// @return `true` if all addresses are sorted and unique, `false` otherwise
    function isSortedAndUnique(address[] memory tokens) internal pure returns (bool) {
        if (tokens.length < 2) {
            return true;
        }
        for (uint256 i = 0; i < tokens.length - 1; i++) {
            if (tokens[i] >= tokens[i + 1]) {
                return false;
            }
        }
        return true;
    }

    /// @dev
    /// Requires both sets of tokens to be sorted. When tokens are not sorted, it's undefined behavior.
    /// If there is a token in tokensToProject that is not part of tokens and corresponding tokenAmountsToProject > 0, reverts.
    /// Zero token amount is eqiuvalent to missing token
    function projectTokenAmounts(
        address[] memory tokens,
        address[] memory tokensToProject,
        uint256[] memory tokenAmountsToProject
    ) internal pure returns (uint256[] memory) {
        uint256[] memory res = new uint256[](tokens.length);
        uint256 t = 0;
        uint256 tp = 0;
        while ((t < tokens.length) && (tp < tokensToProject.length)) {
            if (tokens[t] < tokensToProject[tp]) {
                res[t] = 0;
                t++;
            } else if (tokens[t] > tokensToProject[tp]) {
                if (tokenAmountsToProject[tp] == 0) {
                    tp++;
                } else {
                    revert(""TPS"");
                }
            } else {
                res[t] = tokenAmountsToProject[tp];
                t++;
                tp++;
            }
        }
        while (t < tokens.length) {
            res[t] = 0;
            t++;
        }
        return res;
    }

    /// @notice Splits each amount of n tokens from `amounts` into k vaults according to `weights`.
    /// @dev Requires tokens and tokenAmounts to be vector of size n and delegatedTokenAmounts to be k x n matrix
    /// so that delegatedTokenAmounts[i] is a vector of size n
    /// norm is a vector 1 x k
    /// the error is up to k tokens due to rounding
    /// @param amounts Amounts to split, vector n x 1
    /// @param weights Weights of the split, matrix n x k, weights[i] is vector n x 1.
    /// Weights do not need to sum to 1 in each column, but they will be normalized on split.
    function splitAmounts(uint256[] memory amounts, uint256[][] memory weights)
        internal
        pure
        returns (uint256[][] memory)
    {
        uint256 k = weights.length;
        require(k > 0, ""KGT0"");
        uint256 n = amounts.length;
        require(n > 0, ""NGT0"");
        uint256[] memory weightsNorm = new uint256[](n);
        for (uint256 i = 0; i < k; i++) {
            require(weights[i].length == n, ""NV"");
        }
        for (uint256 j = 0; j < n; j++) {
            weightsNorm[j] = 0;
            for (uint256 i = 0; i < k; i++) {
                weightsNorm[j] += weights[i][j];
            }
        }
        uint256[][] memory res = new uint256[][](k);
        for (uint256 i = 0; i < k; i++) {
            res[i] = new uint256[](n);
            for (uint256 j = 0; j < n; j++) {
                if (weightsNorm[j] == 0) {
                    res[i][j] = amounts[j] / k;
                } else {
                    res[i][j] = (amounts[j] * weights[i][j]) / weightsNorm[j];
                }
            }
        }
        return res;
    }

    /// @notice Determines if a given address is a contract address
    /// @param addr Address to check
    /// @return `true` if the address is a contract address, `false` otherwise
    function isContract(address addr) internal view returns (bool) {
        uint32 size;
        assembly {
            size := extcodesize(addr)
        }
        return (size > 0);
    }
}",1165
RealWorld_BA_58_Trader_RealWord_20240821202013.log,58,Trader,6779,5031,11810,86.0,0.134515,"// SPDX-License-Identifier: BSL-1.1
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";

import ""./interfaces/ITrader.sol"";

/// @notice Base contract for every trader contract (a contract that can execute ERC20 swaps)
abstract contract Trader is ERC165 {
    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {
        return (interfaceId == this.supportsInterface.selector || interfaceId == type(ITrader).interfaceId);
    }

    function _approveERC20TokenIfNecessary(address token, address to) internal {
        if (IERC20(token).allowance(to, address(this)) < type(uint256).max / 2)
            IERC20(token).approve(to, type(uint256).max);
    }
}",192
RealWorld_BA_58_AaveVaultTestFactory_RealWord_20240821225644.log,58,AaveVaultTestFactory,6364,5661,12025,107.0,0.14504,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

import ""../interfaces/IVaultFactory.sol"";
import ""../interfaces/IVaultFactory.sol"";
import ""./AaveVaultTest.sol"";

contract AaveVaultTestFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    function setVaultGovernance(address newVaultGovernance) public {
        vaultGovernance = IVaultGovernance(newVaultGovernance);
    }

    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ""VG"");
        AaveVaultTest vault = new AaveVaultTest(vaultGovernance, vaultTokens);
        return IVault(vault);
    }
}",185
RealWorld_BA_58_IProtocolGovernance_RealWord_20240821212441.log,58,IProtocolGovernance,17221,5457,22678,103.0,0.195245,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IDefaultAccessControl.sol"";
import ""./IVaultRegistry.sol"";

interface IProtocolGovernance is IDefaultAccessControl {
    /// @notice CommonLibrary protocol params.
    /// @param permissionless If `true` anyone can spawn vaults, o/w only Protocol Governance Admin
    /// @param maxTokensPerVault Max different token addresses that could be managed by the protocol
    /// @param governanceDelay The delay (in secs) that must pass before setting new pending params to commiting them
    /// @param protocolTreasury Protocol treasury address for collecting management fees
    struct Params {
        bool permissionless;
        uint256 maxTokensPerVault;
        uint256 governanceDelay;
        address protocolTreasury;
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @notice Addresses allowed to claim liquidity mining rewards from.
    function claimAllowlist() external view returns (address[] memory);

    /// @notice Pending addresses to be added to claimAllowlist.
    function pendingClaimAllowlistAdd() external view returns (address[] memory);

    /// @notice Addresses of tokens allowed for vaults.
    function tokenWhitelist() external view returns (address[] memory);

    /// @notice Pending addresses to be added to tokenWhitelist.
    function pendingTokenWhitelistAdd() external view returns (address[] memory);

    /// @notice Addresses allowed to claim liquidity mining rewards from.
    function vaultGovernances() external view returns (address[] memory);

    /// @notice Pending addresses to be added to vaultGovernances.
    function pendingVaultGovernancesAdd() external view returns (address[] memory);

    /// @notice Check if address is allowed to claim.
    function isAllowedToClaim(address addr) external view returns (bool);

    /// @notice Check if address is an approved token.
    function isAllowedToken(address addr) external view returns (bool);

    /// @notice Check if address is a registered vault governance.
    function isVaultGovernance(address addr) external view returns (bool);

    /// @notice If `false` only admins can deploy new vaults, o/w anyone can deploy a new vault.
    function permissionless() external view returns (bool);

    /// @notice Max different ERC20 token addresses that could be managed by the protocol.
    function maxTokensPerVault() external view returns (uint256);

    /// @notice The delay for committing any governance params.
    function governanceDelay() external view returns (uint256);

    /// @notice The address of the protocol treasury.
    function protocolTreasury() external view returns (address);

    // -------------------  PUBLIC, MUTATING, GOVERNANCE, DELAY  -------------------

    /// @notice Set new pending params.
    /// @param newParams newParams to set
    function setPendingParams(Params memory newParams) external;

    /// @notice Stage addresses for claim allow list.
    /// @param addresses Addresses to add
    function setPendingClaimAllowlistAdd(address[] calldata addresses) external;

    /// @notice Stage addresses for token whitelist.
    /// @param addresses Addresses to add
    function setPendingTokenWhitelistAdd(address[] calldata addresses) external;

    /// @notice Stage addresses for vault governances.
    /// @param addresses Addresses to add
    function setPendingVaultGovernancesAdd(address[] calldata addresses) external;

    // -------------------  PUBLIC, MUTATING, GOVERNANCE, IMMEDIATE  -------------------

    /// @notice Commit pending params.
    function commitParams() external;

    /// @notice Commit pending ClaimAllowlistAdd params.
    function commitClaimAllowlistAdd() external;

    /// @notice Commit pending tokenWhitelistAdd params.
    function commitTokenWhitelistAdd() external;

    /// @notice Commit pending VaultGovernancesAdd params.
    function commitVaultGovernancesAdd() external;

    /// @notice Remove from claim allow list immediately.
    function removeFromClaimAllowlist(address addr) external;

    /// @notice Remove from token whitelist immediately.
    function removeFromTokenWhitelist(address addr) external;

    /// @notice Remove from vault governances immediately.
    function removeFromVaultGovernances(address addr) external;
}",867
RealWorld_BA_58_ILendingPoolAddressesProvider_RealWord_20240822000300.log,58,ILendingPoolAddressesProvider,10511,5354,15865,88.0,0.159635,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

/**
 * @title LendingPoolAddressesProvider contract
 * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles
 * - Acting also as factory of proxies and admin of those, so with right to change its implementations
 * - Owned by the Aave Governance
 * @author Aave
 **/
interface ILendingPoolAddressesProvider {
    event MarketIdSet(string newMarketId);
    event LendingPoolUpdated(address indexed newAddress);
    event ConfigurationAdminUpdated(address indexed newAddress);
    event EmergencyAdminUpdated(address indexed newAddress);
    event LendingPoolConfiguratorUpdated(address indexed newAddress);
    event LendingPoolCollateralManagerUpdated(address indexed newAddress);
    event PriceOracleUpdated(address indexed newAddress);
    event LendingRateOracleUpdated(address indexed newAddress);
    event ProxyCreated(bytes32 id, address indexed newAddress);
    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);

    function getMarketId() external view returns (string memory);

    function setMarketId(string calldata marketId) external;

    function setAddress(bytes32 id, address newAddress) external;

    function setAddressAsProxy(bytes32 id, address impl) external;

    function getAddress(bytes32 id) external view returns (address);

    function getLendingPool() external view returns (address);

    function setLendingPoolImpl(address pool) external;

    function getLendingPoolConfigurator() external view returns (address);

    function setLendingPoolConfiguratorImpl(address configurator) external;

    function getLendingPoolCollateralManager() external view returns (address);

    function setLendingPoolCollateralManager(address manager) external;

    function getPoolAdmin() external view returns (address);

    function setPoolAdmin(address admin) external;

    function getEmergencyAdmin() external view returns (address);

    function setEmergencyAdmin(address admin) external;

    function getPriceOracle() external view returns (address);

    function setPriceOracle(address priceOracle) external;

    function getLendingRateOracle() external view returns (address);

    function setLendingRateOracle(address lendingRateOracle) external;
}",462
RealWorld_BA_58_IGatewayVaultGovernance_RealWord_20240821205334.log,58,IGatewayVaultGovernance,10866,4904,15770,86.0,0.15241,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";

interface IGatewayVaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param redirects Redirects[i] is the nft of subvault that will receive deposit to i-th subvault. If the array is empty there is no redirects
    struct DelayedStrategyParams {
        uint256[] redirects;
    }
    /// @notice Params that could be changed by Strategy or Protocol Governance immediately.
    /// @param limits Token limits for the vault
    struct StrategyParams {
        uint256[] limits;
    }

    /// @notice Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    function delayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Delayed Strategy Params staged for commit after delay.
    /// @param nft VaultRegistry NFT of the vault
    function stagedDelayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Strategy Params.
    /// @param nft VaultRegistry NFT of the vault
    function strategyParams(uint256 nft) external view returns (StrategyParams memory);

    /// @notice Stage Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params
    function stageDelayedStrategyParams(uint256 nft, DelayedStrategyParams calldata params) external;

    /// @notice Commit Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedStrategyParamsTimestamp
    /// @param nft VaultRegistry NFT of the vault
    function commitDelayedStrategyParams(uint256 nft) external;

    /// @notice Set Strategy params, i.e. Params that could be changed by Strategy or Protocol Governance immediately.
    /// @param nft Nft of the vault
    /// @param params New params
    function setStrategyParams(uint256 nft, StrategyParams calldata params) external;
}",494
RealWorld_BA_58_VaultTest_RealWord_20240821201422.log,58,VaultTest,8069,5002,13071,83.0,0.140385,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../Vault.sol"";
import ""../interfaces/IVaultGovernance.sol"";
import ""../interfaces/IVault.sol"";

contract VaultTest is Vault {
    uint256[] res;

    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)
        Vault(vaultGovernance_, vaultTokens_)
    {
        res = new uint256[](1);
        res[0] = 0;
    }

    function tvl() public view override returns (uint256[] memory tokenAmounts) {
        return res;
    }

    function _push(uint256[] memory, bytes memory) internal view override returns (uint256[] memory) {
        // no-op, tokens are already on balance
        return res;
    }

    function _pull(
        address,
        uint256[] memory,
        bytes memory
    ) internal view override returns (uint256[] memory) {
        return res;
    }

    function postReclaimTokens(address to, address[] memory tokens) external {
        _postReclaimTokens(to, tokens);
    }

    function isValidPullDestination(address to) external view returns (bool) {
        return _isValidPullDestination(to);
    }

    function isApprovedOrOwner(address to) external view returns (bool) {
        return _isApprovedOrOwner(to);
    }
}",288
RealWorld_BA_58_ERC20VaultTestFactory_RealWord_20240821200537.log,58,ERC20VaultTestFactory,6404,5146,11550,106.0,0.13494,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../interfaces/IVaultFactory.sol"";
import ""../interfaces/IVaultGovernance.sol"";
import ""./ERC20VaultTest.sol"";

contract ERC20VaultTestFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    function setVaultGovernance(address newVaultGovernance) public {
        vaultGovernance = IVaultGovernance(newVaultGovernance);
    }

    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ""VG"");
        ERC20VaultTest vault = new ERC20VaultTest(vaultGovernance, vaultTokens);
        return IVault(vault);
    }
}",186
RealWorld_BA_58_IGatewayVault_RealWord_20240821204525.log,58,IGatewayVault,9506,4948,14454,93.0,0.14649,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVault.sol"";

interface IGatewayVault is IVault {
    /// @notice List of subvaults nfts
    function subvaultNfts() external view returns (uint256[] memory);

    /// @notice Checks that vault is subvault of the IGatewayVault.
    /// @param vault The vault to check
    /// @return `true` if vault is a subvault of the IGatewayVault
    function hasSubvault(address vault) external view returns (bool);

    /// @notice Breakdown of tvls by subvault.
    /// @return tokenAmounts Token amounts with subvault breakdown. If there are `k` subvaults then token `j`, `tokenAmounts[j]` would be a vector 1 x k - breakdown of token amount by subvaults
    function subvaultsTvl() external view returns (uint256[][] memory tokenAmounts);

    /// @notice A tvl of a specific subvault.
    /// @param vaultNum The number of the subvault in the subvaults array
    /// @return An array of token amounts (tvl) in the same order as vaultTokens
    function subvaultTvl(uint256 vaultNum) external view returns (uint256[] memory);

    /// @notice Adds subvaults NFTs to vault.
    /// @dev Can be called only once by GatewayVaultGovernance
    /// @param nfts Subvault NFTs to add
    function addSubvaults(uint256[] memory nfts) external;

    /// @notice Approves all NFTs to given address.
    /// @dev Can be called only once by GatewayVaultGovernance
    /// @param strategy The address to which all NFTs will be approved (strategy)
    /// @param nfts Subvault NFTs to add
    function setApprovalsForStrategy(address strategy, uint256[] memory nfts) external;
}",416
RealWorld_BA_58_Vault_RealWord_20240821193018.log,58,Vault,44184,5287,49471,92.0,0.32666,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""./interfaces/IGatewayVault.sol"";
import ""./libraries/CommonLibrary.sol"";
import ""./interfaces/IVault.sol"";
import ""./VaultGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Abstract contract that has logic common for every Vault.
/// @dev Notes:
/// ### ERC-721
///
/// Each Vault should be registered in VaultRegistry and get corresponding VaultRegistry NFT.
///
/// ### Access control
///
/// `push` and `pull` methods are only allowed for owner / approved person of the NFT. However,
/// `pull` for approved person also checks that pull destination is another vault of the Vault System.
///
/// The semantics is: NFT owner owns all Vault liquidity, Approved person is liquidity manager.
/// ApprovedForAll person cannot do anything except ERC-721 token transfers.
///
/// Both NFT owner and approved person can call claimRewards method which claims liquidity mining rewards (if any)
///
/// `reclaimTokens` for mistakenly transfered tokens (not included into vaultTokens) additionally can be withdrawn by
/// the protocol admin
abstract contract Vault is IVault, ReentrancyGuard {
    using SafeERC20 for IERC20;

    IVaultGovernance internal _vaultGovernance;
    address[] internal _vaultTokens;
    mapping(address => bool) internal _vaultTokensIndex;
    uint256 internal _nft;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance of this Vault
    /// @param vaultTokens_ ERC20 tokens that will be managed by this Vault
    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_) {
        require(CommonLibrary.isSortedAndUnique(vaultTokens_), ExceptionsLibrary.SORTED_AND_UNIQUE);
        _vaultGovernance = vaultGovernance_;
        _vaultTokens = vaultTokens_;
        for (uint256 i = 0; i < vaultTokens_.length; i++) {
            _vaultTokensIndex[vaultTokens_[i]] = true;
        }
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @inheritdoc IVault
    function vaultGovernance() external view returns (IVaultGovernance) {
        return _vaultGovernance;
    }

    /// @inheritdoc IVault
    function vaultTokens() external view returns (address[] memory) {
        return _vaultTokens;
    }

    /// @inheritdoc IVault
    function tvl() public view virtual returns (uint256[] memory tokenAmounts);

    /// @inheritdoc IVault
    function nft() external view returns (uint256) {
        return _nft;
    }

    // -------------------  PUBLIC, MUTATING, VaultGovernance  -------------------

    function initialize(uint256 nft_) external {
        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        require(nft_ > 0, ExceptionsLibrary.NFT_ZERO);
        require(_nft == 0, ExceptionsLibrary.INITIALIZATION);
        _nft = nft_;
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        registry.setApprovalForAll(address(registry), true);
    }

    // -------------------  PUBLIC, MUTATING, NFT OWNER OR APPROVED  -------------------

    /// @inheritdoc IVault
    function push(
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) public nonReentrant returns (uint256[] memory actualTokenAmounts) {
        uint256 nft_ = _nft;
        require(nft_ > 0, ExceptionsLibrary.INITIALIZATION);
        require(_isApprovedOrOwner(msg.sender), ExceptionsLibrary.APPROVED_OR_OWNER); // Also checks that the token exists
        IVaultRegistry vaultRegistry = _vaultGovernance.internalParams().registry;
        IVault ownerVault = IVault(vaultRegistry.ownerOf(nft_));
        uint256 ownerNft = vaultRegistry.nftForVault(address(ownerVault));
        require(ownerNft > 0, ExceptionsLibrary.OWNER_VAULT_NFT); // require deposits only through Vault
        uint256[] memory pTokenAmounts = _validateAndProjectTokens(tokens, tokenAmounts);
        uint256[] memory pActualTokenAmounts = _push(pTokenAmounts, options);
        actualTokenAmounts = CommonLibrary.projectTokenAmounts(tokens, _vaultTokens, pActualTokenAmounts);
        emit Push(pActualTokenAmounts);
    }

    /// @inheritdoc IVault
    function transferAndPush(
        address from,
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external returns (uint256[] memory actualTokenAmounts) {
        for (uint256 i = 0; i < tokens.length; i++) {
            if (tokenAmounts[i] > 0) {
                IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmounts[i]);
            }
        }
        actualTokenAmounts = push(tokens, tokenAmounts, options);
        for (uint256 i = 0; i < tokens.length; i++) {
            uint256 leftover = actualTokenAmounts[i] < tokenAmounts[i] ? tokenAmounts[i] - actualTokenAmounts[i] : 0;
            if (leftover > 0) {
                IERC20(tokens[i]).safeTransfer(from, leftover);
            }
        }
    }

    /// @inheritdoc IVault
    function pull(
        address to,
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external nonReentrant returns (uint256[] memory actualTokenAmounts) {
        require(_isApprovedOrOwner(msg.sender), ""IO""); // Also checks that the token exists
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        address owner = registry.ownerOf(_nft);
        require(owner == msg.sender || _isValidPullDestination(to), ExceptionsLibrary.VALID_PULL_DESTINATION); // approved can only pull to whitelisted contracts
        uint256[] memory pTokenAmounts = _validateAndProjectTokens(tokens, tokenAmounts);
        uint256[] memory pActualTokenAmounts = _pull(to, pTokenAmounts, options);
        actualTokenAmounts = CommonLibrary.projectTokenAmounts(tokens, _vaultTokens, pActualTokenAmounts);
        emit Pull(to, actualTokenAmounts);
    }

    // -------------------  PUBLIC, MUTATING, NFT OWNER OR APPROVED OR PROTOCOL ADMIN -------------------
    /// @inheritdoc IVault
    function reclaimTokens(address to, address[] memory tokens) external nonReentrant {
        require(_nft > 0, ExceptionsLibrary.INITIALIZATION);
        IProtocolGovernance governance = _vaultGovernance.internalParams().protocolGovernance;
        bool isProtocolAdmin = governance.isAdmin(msg.sender);
        require(isProtocolAdmin || _isApprovedOrOwner(msg.sender), ExceptionsLibrary.ADMIN);
        if (!isProtocolAdmin) {
            require(_isValidPullDestination(to), ExceptionsLibrary.VALID_PULL_DESTINATION);
        }
        uint256[] memory tokenAmounts = new uint256[](tokens.length);
        for (uint256 i = 0; i < tokens.length; i++) {
            IERC20 token = IERC20(tokens[i]);
            tokenAmounts[i] = token.balanceOf(address(this));
            if (tokenAmounts[i] == 0) {
                continue;
            }
            token.safeTransfer(to, tokenAmounts[i]);
        }
        _postReclaimTokens(to, tokens);
        emit ReclaimTokens(to, tokens, tokenAmounts);
    }

    /// @inheritdoc IVault
    function claimRewards(address from, bytes memory data) external override nonReentrant {
        require(_nft > 0, ExceptionsLibrary.INITIALIZATION);
        require(_isApprovedOrOwner(msg.sender), ExceptionsLibrary.APPROVED_OR_OWNER);
        IProtocolGovernance protocolGovernance = _vaultGovernance.internalParams().protocolGovernance;
        require(protocolGovernance.isAllowedToClaim(from), ExceptionsLibrary.ALLOWED_TO_CLAIM);
        (bool res, bytes memory returndata) = from.call(data);
        if (!res) {
            assembly {
                let returndata_size := mload(returndata)
                // Bubble up revert reason
                revert(add(32, returndata), returndata_size)
            }
        }
    }

    // -------------------  PUBLIC, VIEW   -------------------\

    function isVaultToken(address token) public view returns (bool) {
        return _vaultTokensIndex[token];
    }

    // -------------------  PRIVATE, VIEW  -------------------

    function _validateAndProjectTokens(address[] memory tokens, uint256[] memory tokenAmounts)
        internal
        view
        returns (uint256[] memory pTokenAmounts)
    {
        require(CommonLibrary.isSortedAndUnique(tokens), ExceptionsLibrary.SORTED_AND_UNIQUE);
        require(tokens.length == tokenAmounts.length, ExceptionsLibrary.INCONSISTENT_LENGTH);
        pTokenAmounts = CommonLibrary.projectTokenAmounts(_vaultTokens, tokens, tokenAmounts);
    }

    /// The idea is to check that `this` Vault and `to` Vault
    /// nfts are owned by the same address. Then check that nft for this address
    /// exists in registry as Vault => it's one of the vaults with trusted interface.
    /// Then check that both `this` and `to` are registered in the nft owner using hasSubvault function.
    /// Since only gateway vault has hasSubvault function this will prove correctly that
    /// the vaults belong to the same vault system.
    function _isValidPullDestination(address to) internal view returns (bool) {
        if (!CommonLibrary.isContract(to)) {
            return false;
        }
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        // make sure that this vault is a registered vault
        if (_nft == 0) {
            return false;
        }
        address thisOwner = registry.ownerOf(_nft);
        // make sure that vault has a registered owner
        uint256 thisOwnerNft = registry.nftForVault(thisOwner);
        if (thisOwnerNft == 0) {
            return false;
        }
        IGatewayVault gw = IGatewayVault(thisOwner);
        if (!gw.hasSubvault(address(this)) || !gw.hasSubvault(to)) {
            return false;
        }
        return true;
    }

    // -------------------  PRIVATE, VIEW  -------------------

    function _isApprovedOrOwner(address sender) internal view returns (bool) {
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        uint256 nft_ = _nft;
        if (nft_ == 0) {
            return false;
        }
        return registry.getApproved(nft_) == sender || registry.ownerOf(nft_) == sender;
    }

    // -------------------  PRIVATE, MUTATING  -------------------

    /// Guaranteed to have exact signature matchinn vault tokens
    function _push(uint256[] memory tokenAmounts, bytes memory options)
        internal
        virtual
        returns (uint256[] memory actualTokenAmounts);

    /// Guaranteed to have exact signature matchinn vault tokens
    function _pull(
        address to,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) internal virtual returns (uint256[] memory actualTokenAmounts);

    function _postReclaimTokens(address to, address[] memory tokens) internal virtual {}

    /// @notice Emitted on successful push
    /// @param tokenAmounts The amounts of tokens to pushed
    event Push(uint256[] tokenAmounts);

    /// @notice Emitted on successful pull
    /// @param to The target address for pulled tokens
    /// @param tokenAmounts The amounts of tokens to pull
    event Pull(address to, uint256[] tokenAmounts);

    /// @notice Emitted when tokens are reclaimed
    /// @param to The target address for pulled tokens
    /// @param tokens ERC20 tokens to be reclaimed
    /// @param tokenAmounts The amounts of reclaims
    event ReclaimTokens(address to, address[] tokens, uint256[] tokenAmounts);
}",2627
RealWorld_BA_58_DataTypes_RealWord_20240822000430.log,58,DataTypes,10172,5514,15686,89.0,0.16114,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

library DataTypes {
    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.
    struct ReserveData {
        //stores the reserve configuration
        ReserveConfigurationMap configuration;
        //the liquidity index. Expressed in ray
        uint128 liquidityIndex;
        //variable borrow index. Expressed in ray
        uint128 variableBorrowIndex;
        //the current supply rate. Expressed in ray
        uint128 currentLiquidityRate;
        //the current variable borrow rate. Expressed in ray
        uint128 currentVariableBorrowRate;
        //the current stable borrow rate. Expressed in ray
        uint128 currentStableBorrowRate;
        uint40 lastUpdateTimestamp;
        //tokens addresses
        address aTokenAddress;
        address stableDebtTokenAddress;
        address variableDebtTokenAddress;
        //address of the interest rate strategy
        address interestRateStrategyAddress;
        //the id of the reserve. Represents the position in the list of the active reserves
        uint8 id;
    }

    struct ReserveConfigurationMap {
        //bit 0-15: LTV
        //bit 16-31: Liq. threshold
        //bit 32-47: Liq. bonus
        //bit 48-55: Decimals
        //bit 56: Reserve is active
        //bit 57: reserve is frozen
        //bit 58: borrowing is enabled
        //bit 59: stable rate borrowing enabled
        //bit 60-63: reserved
        //bit 64-79: reserve factor
        uint256 data;
    }

    struct UserConfigurationMap {
        uint256 data;
    }

    enum InterestRateMode {
        NONE,
        STABLE,
        VARIABLE
    }
}",398
RealWorld_BA_58_IPeripheryImmutableState_RealWord_20240822000718.log,58,IPeripheryImmutableState,4614,3877,8491,86.0,0.10061,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title Immutable state
/// @notice Functions that return immutable state of the router
interface IPeripheryImmutableState {
    /// @return Returns the address of the Uniswap V3 factory
    function factory() external view returns (address);

    /// @return Returns the address of WETH9
    function WETH9() external view returns (address);
}",99
RealWorld_BA_58_ERC20Test_RealWord_20240821225833.log,58,ERC20Test,4184,3865,8049,86.0,0.09822,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract ERC20Test is ERC20 {
    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {
        _mint(msg.sender, (10**18) * (10**18));
    }
}",82
RealWorld_BA_58_AaveVaultGovernance_RealWord_20240821221350.log,58,AaveVaultGovernance,12748,5460,18208,114.0,0.17294,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IAaveVaultGovernance.sol"";
import ""./VaultGovernance.sol"";

/// @notice Governance that manages all Aave Vaults params and can deploy a new Aave Vault.
contract AaveVaultGovernance is IAaveVaultGovernance, VaultGovernance {
    /// @notice Creates a new contract.
    /// @param internalParams_ Initial Internal Params
    /// @param delayedProtocolParams_ Initial Protocol Params
    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)
        VaultGovernance(internalParams_)
    {
        _delayedProtocolParams = abi.encode(delayedProtocolParams_);
    }

    /// @inheritdoc IAaveVaultGovernance
    function delayedProtocolParams() public view returns (DelayedProtocolParams memory) {
        if (_delayedProtocolParams.length == 0) {
            return DelayedProtocolParams({lendingPool: ILendingPool(address(0))});
        }
        return abi.decode(_delayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IAaveVaultGovernance
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory) {
        if (_stagedDelayedProtocolParams.length == 0) {
            return DelayedProtocolParams({lendingPool: ILendingPool(address(0))});
        }
        return abi.decode(_stagedDelayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IAaveVaultGovernance
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external {
        _stageDelayedProtocolParams(abi.encode(params));
        emit StageDelayedProtocolParams(tx.origin, msg.sender, params, _delayedProtocolParamsTimestamp);
    }

    /// @inheritdoc IAaveVaultGovernance
    function commitDelayedProtocolParams() external {
        _commitDelayedProtocolParams();
        emit CommitDelayedProtocolParams(
            tx.origin,
            msg.sender,
            abi.decode(_delayedProtocolParams, (DelayedProtocolParams))
        );
    }

    /// @notice Emitted when new DelayedProtocolParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedProtocolParams(
        address indexed origin,
        address indexed sender,
        DelayedProtocolParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedProtocolParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that are committed
    event CommitDelayedProtocolParams(address indexed origin, address indexed sender, DelayedProtocolParams params);
}",597
RealWorld_BA_58_UniV3VaultTestFactory_RealWord_20240821224736.log,58,UniV3VaultTestFactory,6653,5096,11749,97.0,0.135185,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../interfaces/IVaultFactory.sol"";
import ""../interfaces/IVaultGovernance.sol"";
import ""./UniV3VaultTest.sol"";

contract UniV3VaultTestFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    function setVaultGovernance(address newVaultGovernance) public {
        vaultGovernance = IVaultGovernance(newVaultGovernance);
    }

    function deployVault(address[] memory vaultTokens, bytes memory options) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ""VG"");
        uint256 fee = abi.decode(options, (uint256));
        UniV3VaultTest vault = new UniV3VaultTest(vaultGovernance, vaultTokens, uint24(fee));
        return IVault(vault);
    }
}",209
RealWorld_BA_58_GatewayVaultGovernance_RealWord_20240821193829.log,58,GatewayVaultGovernance,23517,5469,28986,111.0,0.226965,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IGatewayVaultGovernance.sol"";
import ""./interfaces/IGatewayVault.sol"";
import ""./VaultGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Governance that manages all Gateway Vaults params and can deploy a new Gateway Vault.
contract GatewayVaultGovernance is VaultGovernance, IGatewayVaultGovernance {
    /// @notice Creates a new contract.
    /// @param internalParams_ Initial Internal Params
    constructor(InternalParams memory internalParams_) VaultGovernance(internalParams_) {}

    /// @inheritdoc IGatewayVaultGovernance
    function delayedStrategyParams(uint256 nft) public view returns (DelayedStrategyParams memory) {
        if (_delayedStrategyParams[nft].length == 0) {
            return DelayedStrategyParams({redirects: new uint256[](0)});
        }
        return abi.decode(_delayedStrategyParams[nft], (DelayedStrategyParams));
    }

    /// @inheritdoc IGatewayVaultGovernance
    function stagedDelayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory) {
        if (_stagedDelayedStrategyParams[nft].length == 0) {
            return DelayedStrategyParams({redirects: new uint256[](0)});
        }
        return abi.decode(_stagedDelayedStrategyParams[nft], (DelayedStrategyParams));
    }

    /// @inheritdoc IGatewayVaultGovernance
    function strategyParams(uint256 nft) external view returns (StrategyParams memory) {
        if (_strategyParams[nft].length == 0) {
            return StrategyParams({limits: new uint256[](0)});
        }
        return abi.decode(_strategyParams[nft], (StrategyParams));
    }

    /// @inheritdoc IGatewayVaultGovernance
    function stageDelayedStrategyParams(uint256 nft, DelayedStrategyParams calldata params) external {
        IGatewayVault vault = IGatewayVault(_internalParams.registry.vaultForNft(nft));
        require(
            (params.redirects.length == 0) || (params.redirects.length == vault.subvaultNfts().length),
            ExceptionsLibrary.REDIRECTS_AND_VAULT_TOKENS_LENGTH
        );
        _stageDelayedStrategyParams(nft, abi.encode(params));
        emit StageDelayedStrategyParams(tx.origin, msg.sender, nft, params, _delayedStrategyParamsTimestamp[nft]);
    }

    /// @notice Deploy a new vault
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Abi encoded uint256[] - an array of Nfts of subvaults. It is required that each nft subvault is approved by the caller to this address.
    /// @param strategy Strategy that will be approved to manage subvaults
    /// @return vault Address of the new vault
    /// @return nft Nft of the vault in the vault registry
    function deployVault(
        address[] memory vaultTokens,
        bytes memory options,
        address strategy
    ) public override(VaultGovernance, IVaultGovernance) returns (IVault vault, uint256 nft) {
        for (uint256 i = 0; i < vaultTokens.length; ++i) {
            require(_internalParams.protocolGovernance.isAllowedToken(vaultTokens[i]), ""TNA"");
        }
        (vault, nft) = super.deployVault(vaultTokens, """", msg.sender);
        uint256[] memory subvaultNfts = abi.decode(options, (uint256[]));
        IVaultRegistry registry = _internalParams.registry;
        IGatewayVault(address(vault)).addSubvaults(subvaultNfts);
        for (uint256 i = 0; i < subvaultNfts.length; i++) {
            registry.safeTransferFrom(msg.sender, address(vault), subvaultNfts[i]);
        }
        IGatewayVault gw = IGatewayVault(address(vault));
        gw.setApprovalsForStrategy(strategy, subvaultNfts);
    }

    /// @inheritdoc IGatewayVaultGovernance
    function commitDelayedStrategyParams(uint256 nft) external {
        _commitDelayedStrategyParams(nft);
        emit CommitDelayedStrategyParams(
            tx.origin,
            msg.sender,
            nft,
            abi.decode(_delayedStrategyParams[nft], (DelayedStrategyParams))
        );
    }

    /// @inheritdoc IGatewayVaultGovernance
    function setStrategyParams(uint256 nft, StrategyParams calldata params) external {
        _setStrategyParams(nft, abi.encode(params));
        emit SetStrategyParams(tx.origin, msg.sender, nft, params);
    }

    /// @notice Emitted when new DelayedStrategyParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedStrategyParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedStrategyParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedStrategyParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that are committed
    event CommitDelayedStrategyParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedStrategyParams params
    );

    /// @notice Emitted when new StrategyParams are set
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that are set
    event SetStrategyParams(address indexed origin, address indexed sender, uint256 indexed nft, StrategyParams params);
}",1262
RealWorld_BA_58_Vault_RealWord_20240821222735.log,58,Vault,44416,5602,50018,98.0,0.33412,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""./interfaces/IGatewayVault.sol"";
import ""./libraries/CommonLibrary.sol"";
import ""./interfaces/IVault.sol"";
import ""./VaultGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Abstract contract that has logic common for every Vault.
/// @dev Notes:
/// ### ERC-721
///
/// Each Vault should be registered in VaultRegistry and get corresponding VaultRegistry NFT.
///
/// ### Access control
///
/// `push` and `pull` methods are only allowed for owner / approved person of the NFT. However,
/// `pull` for approved person also checks that pull destination is another vault of the Vault System.
///
/// The semantics is: NFT owner owns all Vault liquidity, Approved person is liquidity manager.
/// ApprovedForAll person cannot do anything except ERC-721 token transfers.
///
/// Both NFT owner and approved person can call claimRewards method which claims liquidity mining rewards (if any)
///
/// `reclaimTokens` for mistakenly transfered tokens (not included into vaultTokens) additionally can be withdrawn by
/// the protocol admin
abstract contract Vault is IVault, ReentrancyGuard {
    using SafeERC20 for IERC20;

    IVaultGovernance internal _vaultGovernance;
    address[] internal _vaultTokens;
    mapping(address => bool) internal _vaultTokensIndex;
    uint256 internal _nft;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance of this Vault
    /// @param vaultTokens_ ERC20 tokens that will be managed by this Vault
    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_) {
        require(CommonLibrary.isSortedAndUnique(vaultTokens_), ExceptionsLibrary.SORTED_AND_UNIQUE);
        _vaultGovernance = vaultGovernance_;
        _vaultTokens = vaultTokens_;
        for (uint256 i = 0; i < vaultTokens_.length; i++) {
            _vaultTokensIndex[vaultTokens_[i]] = true;
        }
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @inheritdoc IVault
    function vaultGovernance() external view returns (IVaultGovernance) {
        return _vaultGovernance;
    }

    /// @inheritdoc IVault
    function vaultTokens() external view returns (address[] memory) {
        return _vaultTokens;
    }

    /// @inheritdoc IVault
    function tvl() public view virtual returns (uint256[] memory tokenAmounts);

    /// @inheritdoc IVault
    function nft() external view returns (uint256) {
        return _nft;
    }

    // -------------------  PUBLIC, MUTATING, VaultGovernance  -------------------

    function initialize(uint256 nft_) external {
        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        require(nft_ > 0, ExceptionsLibrary.NFT_ZERO);
        require(_nft == 0, ExceptionsLibrary.INITIALIZATION);
        _nft = nft_;
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        registry.setApprovalForAll(address(registry), true);
    }

    // -------------------  PUBLIC, MUTATING, NFT OWNER OR APPROVED  -------------------

    /// @inheritdoc IVault
    function push(
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) public nonReentrant returns (uint256[] memory actualTokenAmounts) {
        uint256 nft_ = _nft;
        require(nft_ > 0, ExceptionsLibrary.INITIALIZATION);
        require(_isApprovedOrOwner(msg.sender), ExceptionsLibrary.APPROVED_OR_OWNER); // Also checks that the token exists
        IVaultRegistry vaultRegistry = _vaultGovernance.internalParams().registry;
        IVault ownerVault = IVault(vaultRegistry.ownerOf(nft_));
        uint256 ownerNft = vaultRegistry.nftForVault(address(ownerVault));
        require(ownerNft > 0, ExceptionsLibrary.OWNER_VAULT_NFT); // require deposits only through Vault
        uint256[] memory pTokenAmounts = _validateAndProjectTokens(tokens, tokenAmounts);
        uint256[] memory pActualTokenAmounts = _push(pTokenAmounts, options);
        actualTokenAmounts = CommonLibrary.projectTokenAmounts(tokens, _vaultTokens, pActualTokenAmounts);
        emit Push(pActualTokenAmounts);
    }

    /// @inheritdoc IVault
    function transferAndPush(
        address from,
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external returns (uint256[] memory actualTokenAmounts) {
        for (uint256 i = 0; i < tokens.length; i++) {
            if (tokenAmounts[i] > 0) {
                IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmounts[i]);
            }
        }
        actualTokenAmounts = push(tokens, tokenAmounts, options);
        for (uint256 i = 0; i < tokens.length; i++) {
            uint256 leftover = actualTokenAmounts[i] < tokenAmounts[i] ? tokenAmounts[i] - actualTokenAmounts[i] : 0;
            if (leftover > 0) {
                IERC20(tokens[i]).safeTransfer(from, leftover);
            }
        }
    }

    /// @inheritdoc IVault
    function pull(
        address to,
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external nonReentrant returns (uint256[] memory actualTokenAmounts) {
        require(_isApprovedOrOwner(msg.sender), ""IO""); // Also checks that the token exists
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        address owner = registry.ownerOf(_nft);
        require(owner == msg.sender || _isValidPullDestination(to), ExceptionsLibrary.VALID_PULL_DESTINATION); // approved can only pull to whitelisted contracts
        uint256[] memory pTokenAmounts = _validateAndProjectTokens(tokens, tokenAmounts);
        uint256[] memory pActualTokenAmounts = _pull(to, pTokenAmounts, options);
        actualTokenAmounts = CommonLibrary.projectTokenAmounts(tokens, _vaultTokens, pActualTokenAmounts);
        emit Pull(to, actualTokenAmounts);
    }

    // -------------------  PUBLIC, MUTATING, NFT OWNER OR APPROVED OR PROTOCOL ADMIN -------------------
    /// @inheritdoc IVault
    function reclaimTokens(address to, address[] memory tokens) external nonReentrant {
        require(_nft > 0, ExceptionsLibrary.INITIALIZATION);
        IProtocolGovernance governance = _vaultGovernance.internalParams().protocolGovernance;
        bool isProtocolAdmin = governance.isAdmin(msg.sender);
        require(isProtocolAdmin || _isApprovedOrOwner(msg.sender), ExceptionsLibrary.ADMIN);
        if (!isProtocolAdmin) {
            require(_isValidPullDestination(to), ExceptionsLibrary.VALID_PULL_DESTINATION);
        }
        uint256[] memory tokenAmounts = new uint256[](tokens.length);
        for (uint256 i = 0; i < tokens.length; i++) {
            IERC20 token = IERC20(tokens[i]);
            tokenAmounts[i] = token.balanceOf(address(this));
            if (tokenAmounts[i] == 0) {
                continue;
            }
            token.safeTransfer(to, tokenAmounts[i]);
        }
        _postReclaimTokens(to, tokens);
        emit ReclaimTokens(to, tokens, tokenAmounts);
    }

    /// @inheritdoc IVault
    function claimRewards(address from, bytes memory data) external override nonReentrant {
        require(_nft > 0, ExceptionsLibrary.INITIALIZATION);
        require(_isApprovedOrOwner(msg.sender), ExceptionsLibrary.APPROVED_OR_OWNER);
        IProtocolGovernance protocolGovernance = _vaultGovernance.internalParams().protocolGovernance;
        require(protocolGovernance.isAllowedToClaim(from), ExceptionsLibrary.ALLOWED_TO_CLAIM);
        (bool res, bytes memory returndata) = from.call(data);
        if (!res) {
            assembly {
                let returndata_size := mload(returndata)
                // Bubble up revert reason
                revert(add(32, returndata), returndata_size)
            }
        }
    }

    // -------------------  PUBLIC, VIEW   -------------------\

    function isVaultToken(address token) public view returns (bool) {
        return _vaultTokensIndex[token];
    }

    // -------------------  PRIVATE, VIEW  -------------------

    function _validateAndProjectTokens(address[] memory tokens, uint256[] memory tokenAmounts)
        internal
        view
        returns (uint256[] memory pTokenAmounts)
    {
        require(CommonLibrary.isSortedAndUnique(tokens), ExceptionsLibrary.SORTED_AND_UNIQUE);
        require(tokens.length == tokenAmounts.length, ExceptionsLibrary.INCONSISTENT_LENGTH);
        pTokenAmounts = CommonLibrary.projectTokenAmounts(_vaultTokens, tokens, tokenAmounts);
    }

    /// The idea is to check that `this` Vault and `to` Vault
    /// nfts are owned by the same address. Then check that nft for this address
    /// exists in registry as Vault => it's one of the vaults with trusted interface.
    /// Then check that both `this` and `to` are registered in the nft owner using hasSubvault function.
    /// Since only gateway vault has hasSubvault function this will prove correctly that
    /// the vaults belong to the same vault system.
    function _isValidPullDestination(address to) internal view returns (bool) {
        if (!CommonLibrary.isContract(to)) {
            return false;
        }
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        // make sure that this vault is a registered vault
        if (_nft == 0) {
            return false;
        }
        address thisOwner = registry.ownerOf(_nft);
        // make sure that vault has a registered owner
        uint256 thisOwnerNft = registry.nftForVault(thisOwner);
        if (thisOwnerNft == 0) {
            return false;
        }
        IGatewayVault gw = IGatewayVault(thisOwner);
        if (!gw.hasSubvault(address(this)) || !gw.hasSubvault(to)) {
            return false;
        }
        return true;
    }

    // -------------------  PRIVATE, VIEW  -------------------

    function _isApprovedOrOwner(address sender) internal view returns (bool) {
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        uint256 nft_ = _nft;
        if (nft_ == 0) {
            return false;
        }
        return registry.getApproved(nft_) == sender || registry.ownerOf(nft_) == sender;
    }

    // -------------------  PRIVATE, MUTATING  -------------------

    /// Guaranteed to have exact signature matchinn vault tokens
    function _push(uint256[] memory tokenAmounts, bytes memory options)
        internal
        virtual
        returns (uint256[] memory actualTokenAmounts);

    /// Guaranteed to have exact signature matchinn vault tokens
    function _pull(
        address to,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) internal virtual returns (uint256[] memory actualTokenAmounts);

    function _postReclaimTokens(address to, address[] memory tokens) internal virtual {}

    /// @notice Emitted on successful push
    /// @param tokenAmounts The amounts of tokens to pushed
    event Push(uint256[] tokenAmounts);

    /// @notice Emitted on successful pull
    /// @param to The target address for pulled tokens
    /// @param tokenAmounts The amounts of tokens to pull
    event Pull(address to, uint256[] tokenAmounts);

    /// @notice Emitted when tokens are reclaimed
    /// @param to The target address for pulled tokens
    /// @param tokens ERC20 tokens to be reclaimed
    /// @param tokenAmounts The amounts of reclaims
    event ReclaimTokens(address to, address[] tokens, uint256[] tokenAmounts);
}",2627
RealWorld_BA_58_GatewayVault_RealWord_20240821222235.log,58,GatewayVault,42677,5688,48365,109.0,0.327145,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""./interfaces/IVault.sol"";
import ""./interfaces/IGatewayVault.sol"";
import ""./interfaces/IGatewayVaultGovernance.sol"";
import ""./Vault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Vault that combines several integration layer Vaults into one Vault.
contract GatewayVault is IERC721Receiver, IGatewayVault, Vault {
    using SafeERC20 for IERC20;
    uint256[] internal _subvaultNfts;
    mapping(uint256 => uint256) internal _subvaultNftsIndex;

    /// @notice Creates a new contract.
    /// @dev All subvault nfts must be owned by this vault before.
    /// @param vaultGovernance_ Reference to VaultGovernance for this vault
    /// @param vaultTokens_ ERC20 tokens under Vault management
    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)
        Vault(vaultGovernance_, vaultTokens_)
    {}

    /// @inheritdoc IGatewayVault
    function subvaultNfts() external view returns (uint256[] memory) {
        return _subvaultNfts;
    }

    /// @inheritdoc Vault
    function tvl() public view override(IVault, Vault) returns (uint256[] memory tokenAmounts) {
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        tokenAmounts = new uint256[](_vaultTokens.length);
        for (uint256 i = 0; i < _subvaultNfts.length; i++) {
            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));
            uint256[] memory vTokenAmounts = vault.tvl();
            for (uint256 j = 0; j < _vaultTokens.length; j++) {
                tokenAmounts[j] += vTokenAmounts[j];
            }
        }
    }

    /// @inheritdoc IGatewayVault
    function subvaultTvl(uint256 vaultNum) public view override returns (uint256[] memory) {
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        IVault vault = IVault(registry.vaultForNft(_subvaultNfts[vaultNum]));
        return vault.tvl();
    }

    /// @inheritdoc IGatewayVault
    function subvaultsTvl() public view override returns (uint256[][] memory tokenAmounts) {
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        uint256 vaultTokensLength = _vaultTokens.length;
        tokenAmounts = new uint256[][](_subvaultNfts.length);
        for (uint256 i = 0; i < _subvaultNfts.length; i++) {
            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));
            uint256[] memory vTokenAmounts = vault.tvl();
            tokenAmounts[i] = new uint256[](vaultTokensLength);
            for (uint256 j = 0; j < vaultTokensLength; j++) {
                tokenAmounts[i][j] = vTokenAmounts[j];
            }
        }
    }

    /// @inheritdoc IGatewayVault
    function hasSubvault(address vault) external view override returns (bool) {
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        uint256 nft_ = registry.nftForVault(vault);
        return (_subvaultNftsIndex[nft_] > 0 || _subvaultNfts[0] == nft_);
    }

    /// @inheritdoc IGatewayVault
    function addSubvaults(uint256[] memory nfts) external {
        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        require(_subvaultNfts.length == 0, ExceptionsLibrary.SUB_VAULT_INITIALIZED);
        require(nfts.length > 0, ExceptionsLibrary.SUB_VAULT_LENGTH);
        address[] memory selfTokens = _vaultTokens;
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        for (uint256 i = 0; i < nfts.length; i++) {
            uint256 nft_ = nfts[i];
            require(nft_ > 0, ExceptionsLibrary.NFT_ZERO);
            IVault vault = IVault(registry.vaultForNft(nft_));
            address[] memory vTokens = vault.vaultTokens();
            require(selfTokens.length == vTokens.length, ExceptionsLibrary.INCONSISTENT_LENGTH);
            for (uint256 j = 0; j < selfTokens.length; j++) {
                require(selfTokens[j] == vTokens[j], ExceptionsLibrary.NOT_VAULT_TOKEN);
            }
            _subvaultNfts.push(nft_);
            _subvaultNftsIndex[nft_] = i;
        }
    }

    function setApprovalsForStrategy(address strategy, uint256[] memory nfts) external {
        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        require(strategy != address(0), ExceptionsLibrary.ZERO_STRATEGY_ADDRESS);
        IVaultRegistry vaultRegistry = IVaultGovernance(_vaultGovernance).internalParams().registry;
        for (uint i = 0; i < nfts.length; ++i)
            vaultRegistry.approve(strategy, nfts[i]);
    }

    function onERC721Received(
        address,
        address,
        uint256 tokenId,
        bytes calldata
    ) external nonReentrant returns (bytes4) {
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        require(msg.sender == address(registry), ExceptionsLibrary.NFT_VAULT_REGISTRY);
        registry.lockNft(tokenId);
        return this.onERC721Received.selector;
    }

    function _push(uint256[] memory tokenAmounts, bytes memory options)
        internal
        override
        returns (uint256[] memory actualTokenAmounts)
    {
        require(_subvaultNfts.length > 0, ExceptionsLibrary.INITIALIZATION);
        bool optimized;
        bytes[] memory vaultsOptions;
        (optimized, vaultsOptions) = _parseOptions(options);

        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        uint256[][] memory tvls = subvaultsTvl();
        uint256[] memory totalTvl = new uint256[](_vaultTokens.length);
        uint256[][] memory amountsByVault = CommonLibrary.splitAmounts(tokenAmounts, tvls);
        IGatewayVaultGovernance.DelayedStrategyParams memory strategyParams = IGatewayVaultGovernance(
            address(_vaultGovernance)
        ).delayedStrategyParams(_nft);
        if (optimized && strategyParams.redirects.length > 0) {
            for (uint256 i = 0; i < _subvaultNfts.length; i++) {
                if (strategyParams.redirects[i] == 0) {
                    continue;
                }
                for (uint256 j = 0; j < _vaultTokens.length; j++) {
                    uint256 vaultIndex = _subvaultNftsIndex[strategyParams.redirects[i]];
                    amountsByVault[vaultIndex][j] += amountsByVault[i][j];
                    amountsByVault[i][j] = 0;
                }
            }
        }
        actualTokenAmounts = new uint256[](_vaultTokens.length);
        for (uint256 i = 0; i < _subvaultNfts.length; i++) {
            if (optimized && (strategyParams.redirects[i] != 0)) {
                continue;
            }
            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));
            for (uint256 j = 0; j < _vaultTokens.length; j++) {
                if (amountsByVault[i][j] > 0) {
                    _allowTokenIfNecessary(_vaultTokens[j], address(vault));
                }
            }
            uint256[] memory actualVaultTokenAmounts = vault.transferAndPush(
                address(this),
                _vaultTokens,
                amountsByVault[i],
                vaultsOptions[i]
            );
            for (uint256 j = 0; j < _vaultTokens.length; j++) {
                actualTokenAmounts[j] += actualVaultTokenAmounts[j];
                totalTvl[j] += tvls[i][j];
            }
        }
        uint256[] memory _limits = IGatewayVaultGovernance(address(_vaultGovernance)).strategyParams(_nft).limits;
        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            require(totalTvl[i] + actualTokenAmounts[i] < _limits[i], ExceptionsLibrary.LIMIT_OVERFLOW);
        }
    }

    function _pull(
        address to,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) internal override returns (uint256[] memory actualTokenAmounts) {
        (bool optimized, bytes[] memory vaultsOptions) = _parseOptions(options);

        require(_subvaultNfts.length > 0, ExceptionsLibrary.INITIALIZATION);
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        uint256[][] memory tvls = subvaultsTvl();
        uint256[][] memory amountsByVault = CommonLibrary.splitAmounts(tokenAmounts, tvls);
        uint256[] memory _redirects = IGatewayVaultGovernance(address(_vaultGovernance))
            .delayedStrategyParams(_nft)
            .redirects;

        if (optimized && (_redirects.length > 0)) {
            for (uint256 i = 0; i < _subvaultNfts.length; i++) {
                if (_redirects[i] == 0) {
                    continue;
                }
                for (uint256 j = 0; j < _vaultTokens.length; j++) {
                    uint256 vaultIndex = _subvaultNftsIndex[_redirects[i]];
                    amountsByVault[vaultIndex][j] += amountsByVault[i][j];
                    amountsByVault[i][j] = 0;
                }
            }
        }
        actualTokenAmounts = new uint256[](_vaultTokens.length);
        for (uint256 i = 0; i < _subvaultNfts.length; i++) {
            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));
            uint256[] memory actualVaultTokenAmounts = vault.pull(
                to,
                _vaultTokens,
                amountsByVault[i],
                vaultsOptions[i]
            );
            for (uint256 j = 0; j < _vaultTokens.length; j++) {
                actualTokenAmounts[j] += actualVaultTokenAmounts[j];
            }
        }
    }

    function _allowTokenIfNecessary(address token, address to) internal {
        if (IERC20(token).allowance(address(this), address(to)) < type(uint256).max / 2) {
            IERC20(token).approve(address(to), type(uint256).max);
        }
    }

    function _parseOptions(bytes memory options) internal view returns (bool, bytes[] memory) {
        if (options.length == 0) {
            return (false, new bytes[](_subvaultNfts.length));
        }
        return abi.decode(options, (bool, bytes[]));
    }

    event CollectProtocolFees(address protocolTreasury, address[] tokens, uint256[] amounts);
    event CollectStrategyFees(address strategyTreasury, address[] tokens, uint256[] amounts);
}",2465
RealWorld_BA_58_YearnVaultGovernance_RealWord_20240821191301.log,58,YearnVaultGovernance,17136,5576,22712,83.0,0.1972,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IYearnVaultGovernance.sol"";
import ""./VaultGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Governance that manages all Aave Vaults params and can deploy a new Aave Vault.
contract YearnVaultGovernance is IYearnVaultGovernance, VaultGovernance {
    mapping(address => address) private _yTokens;

    /// @notice Creates a new contract
    /// @param internalParams_ Initial Internal Params
    /// @param delayedProtocolParams_ Initial Protocol Params
    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)
        VaultGovernance(internalParams_)
    {
        _delayedProtocolParams = abi.encode(delayedProtocolParams_);
    }

    /// @inheritdoc IYearnVaultGovernance
    function yTokenForToken(address token) external view returns (address) {
        address yToken = _yTokens[token];
        if (yToken != address(0)) {
            return yToken;
        }
        IYearnVaultRegistry yearnRegistry = delayedProtocolParams().yearnVaultRegistry;
        try yearnRegistry.latestVault(token) returns (address _vault) {
            return _vault;
        } catch (bytes memory) {
            return address(0);
        }
    }

    /// @inheritdoc IYearnVaultGovernance
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory) {
        if (_stagedDelayedProtocolParams.length == 0) {
            return DelayedProtocolParams({yearnVaultRegistry: IYearnVaultRegistry(address(0))});
        }
        return abi.decode(_stagedDelayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IYearnVaultGovernance
    function delayedProtocolParams() public view returns (DelayedProtocolParams memory) {
        return abi.decode(_delayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IYearnVaultGovernance
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external {
        _stageDelayedProtocolParams(abi.encode(params));
        emit StageDelayedProtocolParams(tx.origin, msg.sender, params, _delayedProtocolParamsTimestamp);
    }

    /// @inheritdoc IYearnVaultGovernance
    function commitDelayedProtocolParams() external {
        _commitDelayedProtocolParams();
        emit CommitDelayedProtocolParams(
            tx.origin,
            msg.sender,
            abi.decode(_delayedProtocolParams, (DelayedProtocolParams))
        );
    }

    /// @inheritdoc IYearnVaultGovernance
    function setYTokenForToken(address token, address yToken) external {
        _requireProtocolAdmin();
        _yTokens[token] = yToken;
        emit SetYToken(tx.origin, msg.sender, token, yToken);
    }

    /// @notice Emitted when new yToken is set
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param token ERC-20 token for the yToken
    /// @param yToken yToken for ERC-20 token
    event SetYToken(address indexed origin, address indexed sender, address indexed token, address yToken);

    /// @notice Emitted when new DelayedProtocolParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedProtocolParams(
        address indexed origin,
        address indexed sender,
        DelayedProtocolParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedProtocolParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that are committed
    event CommitDelayedProtocolParams(address indexed origin, address indexed sender, DelayedProtocolParams params);
}",862
RealWorld_BA_58_TestCallStatic_RealWord_20240821230001.log,58,TestCallStatic,4266,3624,7890,72.0,0.09381,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

contract TestCallStatic {
    uint256 private _a;

    function incA() external returns (uint256) {
        _a += 1;
        return _a;
    }

    function a() external view returns (uint256) {
        return _a;
    }
}",79
RealWorld_BA_58_ERC20Test_RealWord_20240821200252.log,58,ERC20Test,4096,4139,8235,79.0,0.10326,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract ERC20Test is ERC20 {
    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {
        _mint(msg.sender, (10**18) * (10**18));
    }
}",82
RealWorld_BA_58_ERC20VaultFactory_RealWord_20240821223230.log,58,ERC20VaultFactory,6577,4480,11057,89.0,0.122485,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IVaultFactory.sol"";
import ""./ERC20Vault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Helper contract for ERC20VaultGovernance that can create new ERC20 Vaults.
contract ERC20VaultFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind
    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    /// @inheritdoc IVaultFactory
    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        ERC20Vault vault = new ERC20Vault(vaultGovernance, vaultTokens);
        return IVault(vault);
    }
}",217
RealWorld_BA_58_IYearnVault_RealWord_20240821214547.log,58,IYearnVault,5396,5376,10772,103.0,0.1345,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IYearnVault is IERC20 {
    function decimals() external view returns (uint256);

    function pricePerShare() external view returns (uint256);

    function deposit(uint256 amount, address recipient) external returns (uint256);

    // Default maxLoss = 1, i.e. 0.01% [BPS]
    function withdraw(
        uint256 maxShares,
        address recipient,
        uint256 maxLoss
    ) external returns (uint256);
}",133
RealWorld_BA_58_UniV3VaultGovernance_RealWord_20240821224102.log,58,UniV3VaultGovernance,13168,5033,18201,100.0,0.1665,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IUniV3VaultGovernance.sol"";
import ""./VaultGovernance.sol"";

/// @notice Governance that manages all UniV3 Vaults params and can deploy a new UniV3 Vault.
contract UniV3VaultGovernance is IUniV3VaultGovernance, VaultGovernance {
    /// @notice Creates a new contract.
    /// @param internalParams_ Initial Internal Params
    /// @param delayedProtocolParams_ Initial Protocol Params
    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)
        VaultGovernance(internalParams_)
    {
        _delayedProtocolParams = abi.encode(delayedProtocolParams_);
    }

    /// @inheritdoc IUniV3VaultGovernance
    function delayedProtocolParams() public view returns (DelayedProtocolParams memory) {
        if (_delayedProtocolParams.length == 0) {
            return DelayedProtocolParams({positionManager: INonfungiblePositionManager(address(0))});
        }
        return abi.decode(_delayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IUniV3VaultGovernance
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory) {
        if (_stagedDelayedProtocolParams.length == 0) {
            return DelayedProtocolParams({positionManager: INonfungiblePositionManager(address(0))});
        }
        return abi.decode(_stagedDelayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IUniV3VaultGovernance
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external {
        _stageDelayedProtocolParams(abi.encode(params));
        emit StageDelayedProtocolParams(tx.origin, msg.sender, params, _delayedProtocolParamsTimestamp);
    }

    /// @inheritdoc IUniV3VaultGovernance
    function commitDelayedProtocolParams() external {
        _commitDelayedProtocolParams();
        emit CommitDelayedProtocolParams(
            tx.origin,
            msg.sender,
            abi.decode(_delayedProtocolParams, (DelayedProtocolParams))
        );
    }

    /// @notice Emitted when new DelayedProtocolParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedProtocolParams(
        address indexed origin,
        address indexed sender,
        DelayedProtocolParams params,
        uint256 when
    );
    /// @notice Emitted when new DelayedProtocolParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that are committed
    event CommitDelayedProtocolParams(address indexed origin, address indexed sender, DelayedProtocolParams params);
}",615
RealWorld_BA_58_YearnVaultGovernance_RealWord_20240821220822.log,58,YearnVaultGovernance,17154,5499,22653,114.0,0.19575,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IYearnVaultGovernance.sol"";
import ""./VaultGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Governance that manages all Aave Vaults params and can deploy a new Aave Vault.
contract YearnVaultGovernance is IYearnVaultGovernance, VaultGovernance {
    mapping(address => address) private _yTokens;

    /// @notice Creates a new contract
    /// @param internalParams_ Initial Internal Params
    /// @param delayedProtocolParams_ Initial Protocol Params
    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)
        VaultGovernance(internalParams_)
    {
        _delayedProtocolParams = abi.encode(delayedProtocolParams_);
    }

    /// @inheritdoc IYearnVaultGovernance
    function yTokenForToken(address token) external view returns (address) {
        address yToken = _yTokens[token];
        if (yToken != address(0)) {
            return yToken;
        }
        IYearnVaultRegistry yearnRegistry = delayedProtocolParams().yearnVaultRegistry;
        try yearnRegistry.latestVault(token) returns (address _vault) {
            return _vault;
        } catch (bytes memory) {
            return address(0);
        }
    }

    /// @inheritdoc IYearnVaultGovernance
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory) {
        if (_stagedDelayedProtocolParams.length == 0) {
            return DelayedProtocolParams({yearnVaultRegistry: IYearnVaultRegistry(address(0))});
        }
        return abi.decode(_stagedDelayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IYearnVaultGovernance
    function delayedProtocolParams() public view returns (DelayedProtocolParams memory) {
        return abi.decode(_delayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IYearnVaultGovernance
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external {
        _stageDelayedProtocolParams(abi.encode(params));
        emit StageDelayedProtocolParams(tx.origin, msg.sender, params, _delayedProtocolParamsTimestamp);
    }

    /// @inheritdoc IYearnVaultGovernance
    function commitDelayedProtocolParams() external {
        _commitDelayedProtocolParams();
        emit CommitDelayedProtocolParams(
            tx.origin,
            msg.sender,
            abi.decode(_delayedProtocolParams, (DelayedProtocolParams))
        );
    }

    /// @inheritdoc IYearnVaultGovernance
    function setYTokenForToken(address token, address yToken) external {
        _requireProtocolAdmin();
        _yTokens[token] = yToken;
        emit SetYToken(tx.origin, msg.sender, token, yToken);
    }

    /// @notice Emitted when new yToken is set
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param token ERC-20 token for the yToken
    /// @param yToken yToken for ERC-20 token
    event SetYToken(address indexed origin, address indexed sender, address indexed token, address yToken);

    /// @notice Emitted when new DelayedProtocolParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedProtocolParams(
        address indexed origin,
        address indexed sender,
        DelayedProtocolParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedProtocolParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that are committed
    event CommitDelayedProtocolParams(address indexed origin, address indexed sender, DelayedProtocolParams params);
}",862
RealWorld_BA_58_ProtocolGovernance_RealWord_20240821194734.log,58,ProtocolGovernance,35672,5646,41318,112.0,0.29128,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./DefaultAccessControl.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Governance that manages all params common for Mellow Permissionless Vaults protocol.
contract ProtocolGovernance is IProtocolGovernance, DefaultAccessControl {
    using EnumerableSet for EnumerableSet.AddressSet;
    uint256 public constant MAX_GOVERNANCE_DELAY = 7 days;

    EnumerableSet.AddressSet private _claimAllowlist;
    address[] private _pendingClaimAllowlistAdd;
    uint256 public pendingClaimAllowlistAddTimestamp;

    address[] private _tokenWhitelist;
    address[] private _pendingTokenWhitelistAdd;
    uint256 private _numberOfValidTokens;
    mapping(address => bool) _tokensAllowed;
    mapping(address => bool) _tokenEverAdded;
    uint256 public pendingTokenWhitelistAddTimestamp;

    EnumerableSet.AddressSet private _vaultGovernances;
    address[] private _pendingVaultGovernancesAdd;
    uint256 public pendingVaultGovernancesAddTimestamp;

    IProtocolGovernance.Params public params;
    Params public pendingParams;

    uint256 public pendingParamsTimestamp;

    /// @notice Creates a new contract.
    /// @param admin Initial admin of the contract
    constructor(address admin) DefaultAccessControl(admin) {
        _tokenWhitelist = new address[](0);
        _numberOfValidTokens = 0;
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @inheritdoc IProtocolGovernance
    function claimAllowlist() external view returns (address[] memory) {
        uint256 l = _claimAllowlist.length();
        address[] memory res = new address[](l);
        for (uint256 i = 0; i < l; i++) {
            res[i] = _claimAllowlist.at(i);
        }
        return res;
    }

    /// @inheritdoc IProtocolGovernance
    function tokenWhitelist() external view returns (address[] memory) {
        uint256 l = _tokenWhitelist.length;
        address[] memory res = new address[](_numberOfValidTokens);
        uint256 j = 0;
        for (uint256 i = 0; i < l; i++) {
            if (!_tokensAllowed[_tokenWhitelist[i]] && _tokenEverAdded[_tokenWhitelist[i]]) {
                continue;
            }
            res[j] = _tokenWhitelist[i];
            j += 1;
        }
        return res;
    }

    /// @inheritdoc IProtocolGovernance
    function vaultGovernances() external view returns (address[] memory) {
        uint256 l = _vaultGovernances.length();
        address[] memory res = new address[](l);
        for (uint256 i = 0; i < l; i++) {
            res[i] = _vaultGovernances.at(i);
        }
        return res;
    }

    /// @inheritdoc IProtocolGovernance
    function pendingClaimAllowlistAdd() external view returns (address[] memory) {
        return _pendingClaimAllowlistAdd;
    }

    /// @inheritdoc IProtocolGovernance
    function pendingTokenWhitelistAdd() external view returns (address[] memory) {
        return _pendingTokenWhitelistAdd;
    }

    /// @inheritdoc IProtocolGovernance
    function pendingVaultGovernancesAdd() external view returns (address[] memory) {
        return _pendingVaultGovernancesAdd;
    }

    /// @inheritdoc IProtocolGovernance
    function isAllowedToClaim(address addr) external view returns (bool) {
        return _claimAllowlist.contains(addr);
    }

    /// @inheritdoc IProtocolGovernance
    function isAllowedToken(address addr) external view returns (bool) {
        return _tokenEverAdded[addr] && _tokensAllowed[addr];
    }

    /// @inheritdoc IProtocolGovernance
    function isVaultGovernance(address addr) external view returns (bool) {
        return _vaultGovernances.contains(addr);
    }

    /// @inheritdoc IProtocolGovernance
    function permissionless() external view returns (bool) {
        return params.permissionless;
    }

    /// @inheritdoc IProtocolGovernance
    function maxTokensPerVault() external view returns (uint256) {
        return params.maxTokensPerVault;
    }

    /// @inheritdoc IProtocolGovernance
    function governanceDelay() external view returns (uint256) {
        return params.governanceDelay;
    }

    /// @inheritdoc IProtocolGovernance
    function protocolTreasury() external view returns (address) {
        return params.protocolTreasury;
    }

    // -------------------  PUBLIC, MUTATING, GOVERNANCE, DELAY  -------------------

    /// @inheritdoc IProtocolGovernance
    function setPendingClaimAllowlistAdd(address[] calldata addresses) external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        _pendingClaimAllowlistAdd = addresses;
        pendingClaimAllowlistAddTimestamp = block.timestamp + params.governanceDelay;
    }

    /// @inheritdoc IProtocolGovernance
    function removeFromClaimAllowlist(address addr) external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        if (!_claimAllowlist.contains(addr)) {
            return;
        }
        _claimAllowlist.remove(addr);
    }

    /// @inheritdoc IProtocolGovernance
    function setPendingTokenWhitelistAdd(address[] calldata addresses) external {
        require(isAdmin(msg.sender), ""ADM"");
        _pendingTokenWhitelistAdd = addresses;
        pendingTokenWhitelistAddTimestamp = block.timestamp + params.governanceDelay;
    }

    /// @inheritdoc IProtocolGovernance
    function removeFromTokenWhitelist(address addr) external {
        require(isAdmin(msg.sender), ""ADM"");
        _tokensAllowed[addr] = false;
        if (_tokenEverAdded[addr]) {
            --_numberOfValidTokens;
        }
    }

    /// @inheritdoc IProtocolGovernance
    function setPendingVaultGovernancesAdd(address[] calldata addresses) external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        _pendingVaultGovernancesAdd = addresses;
        pendingVaultGovernancesAddTimestamp = block.timestamp + params.governanceDelay;
    }

    /// @inheritdoc IProtocolGovernance
    function removeFromVaultGovernances(address addr) external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        if (!_vaultGovernances.contains(addr)) {
            return;
        }
        _vaultGovernances.remove(addr);
    }

    /// @inheritdoc IProtocolGovernance
    function setPendingParams(IProtocolGovernance.Params memory newParams) external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        require(params.governanceDelay <= MAX_GOVERNANCE_DELAY, ExceptionsLibrary.MAX_GOVERNANCE_DELAY);
        pendingParams = newParams;
        pendingParamsTimestamp = block.timestamp + params.governanceDelay;
    }

    // -------------------  PUBLIC, MUTATING, GOVERNANCE, IMMEDIATE  -------------------

    /// @inheritdoc IProtocolGovernance
    function commitClaimAllowlistAdd() external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        require(
            (block.timestamp >= pendingClaimAllowlistAddTimestamp) && (pendingClaimAllowlistAddTimestamp > 0),
            ExceptionsLibrary.TIMESTAMP
        );
        for (uint256 i = 0; i < _pendingClaimAllowlistAdd.length; i++) {
            _claimAllowlist.add(_pendingClaimAllowlistAdd[i]);
        }
        delete _pendingClaimAllowlistAdd;
        delete pendingClaimAllowlistAddTimestamp;
    }

    /// @inheritdoc IProtocolGovernance
    function commitTokenWhitelistAdd() external {
        require(isAdmin(msg.sender), ""ADM"");
        require(
            (block.timestamp >= pendingTokenWhitelistAddTimestamp) && (pendingTokenWhitelistAddTimestamp > 0),
            ""TS""
        );
        for (uint256 i = 0; i < _pendingTokenWhitelistAdd.length; i++) {
            if (!_tokenEverAdded[_pendingTokenWhitelistAdd[i]]) {
                _numberOfValidTokens += 1;
                _tokensAllowed[_pendingTokenWhitelistAdd[i]] = true;
                _tokenWhitelist.push(_pendingTokenWhitelistAdd[i]);
                _tokenEverAdded[_pendingTokenWhitelistAdd[i]] = true;
            } else {
                if (!_tokensAllowed[_pendingTokenWhitelistAdd[i]]) {
                    _numberOfValidTokens += 1;
                    _tokensAllowed[_pendingTokenWhitelistAdd[i]] = true;
                }
            }
        }
        delete _pendingTokenWhitelistAdd;
        delete pendingTokenWhitelistAddTimestamp;
    }

    /// @inheritdoc IProtocolGovernance
    function commitVaultGovernancesAdd() external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        require(
            (block.timestamp >= pendingVaultGovernancesAddTimestamp) && (pendingVaultGovernancesAddTimestamp > 0),
            ExceptionsLibrary.TIMESTAMP
        );
        for (uint256 i = 0; i < _pendingVaultGovernancesAdd.length; i++) {
            _vaultGovernances.add(_pendingVaultGovernancesAdd[i]);
        }
        delete _pendingVaultGovernancesAdd;
        delete pendingVaultGovernancesAddTimestamp;
    }

    /// @inheritdoc IProtocolGovernance
    function commitParams() external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        require(block.timestamp >= pendingParamsTimestamp, ExceptionsLibrary.TIMESTAMP);
        require(pendingParams.maxTokensPerVault > 0 || pendingParams.governanceDelay > 0, ExceptionsLibrary.EMPTY_PARAMS); // sanity check for empty params
        params = pendingParams;
        delete pendingParams;
        delete pendingParamsTimestamp;
    }
}",2027
RealWorld_BA_58_AaveVaultTestFactory_RealWord_20240821200112.log,58,AaveVaultTestFactory,6341,5218,11559,98.0,0.136065,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

import ""../interfaces/IVaultFactory.sol"";
import ""../interfaces/IVaultFactory.sol"";
import ""./AaveVaultTest.sol"";

contract AaveVaultTestFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    function setVaultGovernance(address newVaultGovernance) public {
        vaultGovernance = IVaultGovernance(newVaultGovernance);
    }

    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ""VG"");
        AaveVaultTest vault = new AaveVaultTest(vaultGovernance, vaultTokens);
        return IVault(vault);
    }
}",185
RealWorld_BA_58_IUniswapV3PoolImmutables_RealWord_20240822001929.log,58,IUniswapV3PoolImmutables,10181,4264,14445,86.0,0.136185,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Pool state that never changes
/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values
interface IUniswapV3PoolImmutables {
    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface
    /// @return The contract address
    function factory() external view returns (address);

    /// @notice The first of the two tokens of the pool, sorted by address
    /// @return The token contract address
    function token0() external view returns (address);

    /// @notice The second of the two tokens of the pool, sorted by address
    /// @return The token contract address
    function token1() external view returns (address);

    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6
    /// @return The fee
    function fee() external view returns (uint24);

    /// @notice The pool tick spacing
    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
    /// This value is an int24 to avoid casting even though it is always positive.
    /// @return The tick spacing
    function tickSpacing() external view returns (int24);

    /// @notice The maximum amount of position liquidity that can use any tick in the range
    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and
    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool
    /// @return The max amount of liquidity per tick
    function maxLiquidityPerTick() external view returns (uint128);
}",435
RealWorld_BA_58_IYearnVaultGovernance_RealWord_20240821233814.log,58,IYearnVaultGovernance,9426,5508,14934,118.0,0.15729,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./external/yearn/IYearnVaultRegistry.sol"";
import ""./IVaultGovernance.sol"";

interface IYearnVaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param yearnVaultRegistry Reference to Yearn Vault Registry
    struct DelayedProtocolParams {
        IYearnVaultRegistry yearnVaultRegistry;
    }

    /// @notice Determines a corresponding Yearn vault for token
    /// @param token ERC-20 token for the yToken
    /// @return If there's a yToken returns its address, otherwise returns 0
    function yTokenForToken(address token) external view returns (address);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;

    /// @notice Sets the manual override for yToken vaults map
    /// @dev Can only be called by Protocol Admin
    /// @param token ERC-20 token for yToken
    /// @param yToken for ERC-20 token
    function setYTokenForToken(address token, address yToken) external;
}",401
RealWorld_BA_58_IVaultRegistry_RealWord_20240821213529.log,58,IVaultRegistry,13166,5468,18634,89.0,0.17519,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""./IProtocolGovernance.sol"";
import ""./IVaultFactory.sol"";
import ""./IVaultGovernance.sol"";

interface IVaultRegistry is IERC721 {
    /// @notice Get Vault for the giver NFT ID.
    /// @param nftId NFT ID
    /// @return vault Address of the Vault contract
    function vaultForNft(uint256 nftId) external view returns (address vault);

    /// @notice Get NFT ID for given Vault contract address.
    /// @param vault Address of the Vault contract
    /// @return nftId NFT ID
    function nftForVault(address vault) external view returns (uint256 nftId);

    /// @notice Checks if the nft is locked for all transfers
    /// @param nft NFT to check for lock
    /// @return `true` if locked, false otherwise
    function isLocked(uint256 nft) external view returns (bool);

    /// @notice Register new Vault and mint NFT.
    /// @param vault address of the vault
    /// @param owner owner of the NFT
    /// @return nft Nft minted for the given Vault
    function registerVault(address vault, address owner) external returns (uint256 nft);

    /// @notice Number of Vaults registered.
    function vaultsCount() external view returns (uint256);

    /// @notice All Vaults registered.
    function vaults() external view returns (address[] memory);

    /// @notice Address of the ProtocolGovernance.
    function protocolGovernance() external view returns (IProtocolGovernance);

    /// @notice Address of the staged ProtocolGovernance.
    function stagedProtocolGovernance() external view returns (IProtocolGovernance);

    /// @notice Minimal timestamp when staged ProtocolGovernance can be applied.
    function stagedProtocolGovernanceTimestamp() external view returns (uint256);

    /// @notice Stage new ProtocolGovernance.
    /// @param newProtocolGovernance new ProtocolGovernance
    function stageProtocolGovernance(IProtocolGovernance newProtocolGovernance) external;

    /// @notice Commit new ProtocolGovernance.
    function commitStagedProtocolGovernance() external;

    /// @notice Approve nft to new address
    /// @dev This can be called only by the Protocol Governance. It is used to disable the strategy for a vault
    /// @param newAddress address that will be approved
    /// @param nft for re-approval
    function adminApprove(address newAddress, uint256 nft) external;

    /// @notice Lock NFT for transfers
    /// @dev Use this method when vault structure is set up and should become immutable. Can be called by owner.
    /// @param nft - NFT to lock
    function lockNft(uint256 nft) external;
}",619
RealWorld_BA_58_IERC20VaultGovernance_RealWord_20240821205014.log,58,IERC20VaultGovernance,7228,4541,11769,87.0,0.12696,"// SPDX-License-Identifier: BSL-1.1
pragma solidity 0.8.9;

import ""../trader/interfaces/ITrader.sol"";
import ""./IVaultGovernance.sol"";

interface IERC20VaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param trader Reference to internal Trader contract
    struct DelayedProtocolParams {
        ITrader trader;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",266
RealWorld_BA_58_IPeripheryImmutableState_RealWord_20240821215605.log,58,IPeripheryImmutableState,5043,4215,9258,92.0,0.109515,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title Immutable state
/// @notice Functions that return immutable state of the router
interface IPeripheryImmutableState {
    /// @return Returns the address of the Uniswap V3 factory
    function factory() external view returns (address);

    /// @return Returns the address of WETH9
    function WETH9() external view returns (address);
}",99
RealWorld_BA_58_AaveVaultFactory_RealWord_20240821191855.log,58,AaveVaultFactory,6856,5499,12355,90.0,0.14426,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

import ""./interfaces/IVaultFactory.sol"";
import ""./AaveVault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Helper contract for AaveVaultGovernance that can create new Aave Vaults.
contract AaveVaultFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    /// @notice Creates a new contract
    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind
    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    /// @inheritdoc IVaultFactory
    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        AaveVault vault = new AaveVault(vaultGovernance, vaultTokens);
        return IVault(vault);
    }
}",217
RealWorld_BA_58_IGatewayVaultGovernance_RealWord_20240821234845.log,58,IGatewayVaultGovernance,10942,5377,16319,102.0,0.16225,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";

interface IGatewayVaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param redirects Redirects[i] is the nft of subvault that will receive deposit to i-th subvault. If the array is empty there is no redirects
    struct DelayedStrategyParams {
        uint256[] redirects;
    }
    /// @notice Params that could be changed by Strategy or Protocol Governance immediately.
    /// @param limits Token limits for the vault
    struct StrategyParams {
        uint256[] limits;
    }

    /// @notice Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    function delayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Delayed Strategy Params staged for commit after delay.
    /// @param nft VaultRegistry NFT of the vault
    function stagedDelayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Strategy Params.
    /// @param nft VaultRegistry NFT of the vault
    function strategyParams(uint256 nft) external view returns (StrategyParams memory);

    /// @notice Stage Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params
    function stageDelayedStrategyParams(uint256 nft, DelayedStrategyParams calldata params) external;

    /// @notice Commit Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedStrategyParamsTimestamp
    /// @param nft VaultRegistry NFT of the vault
    function commitDelayedStrategyParams(uint256 nft) external;

    /// @notice Set Strategy params, i.e. Params that could be changed by Strategy or Protocol Governance immediately.
    /// @param nft Nft of the vault
    /// @param params New params
    function setStrategyParams(uint256 nft, StrategyParams calldata params) external;
}",494
RealWorld_BA_58_IGatewayVault_RealWord_20240821212817.log,58,IGatewayVault,9958,5346,15304,94.0,0.15671,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVault.sol"";

interface IGatewayVault is IVault {
    /// @notice List of subvaults nfts
    function subvaultNfts() external view returns (uint256[] memory);

    /// @notice Checks that vault is subvault of the IGatewayVault.
    /// @param vault The vault to check
    /// @return `true` if vault is a subvault of the IGatewayVault
    function hasSubvault(address vault) external view returns (bool);

    /// @notice Breakdown of tvls by subvault.
    /// @return tokenAmounts Token amounts with subvault breakdown. If there are `k` subvaults then token `j`, `tokenAmounts[j]` would be a vector 1 x k - breakdown of token amount by subvaults
    function subvaultsTvl() external view returns (uint256[][] memory tokenAmounts);

    /// @notice A tvl of a specific subvault.
    /// @param vaultNum The number of the subvault in the subvaults array
    /// @return An array of token amounts (tvl) in the same order as vaultTokens
    function subvaultTvl(uint256 vaultNum) external view returns (uint256[] memory);

    /// @notice Adds subvaults NFTs to vault.
    /// @dev Can be called only once by GatewayVaultGovernance
    /// @param nfts Subvault NFTs to add
    function addSubvaults(uint256[] memory nfts) external;

    /// @notice Approves all NFTs to given address.
    /// @dev Can be called only once by GatewayVaultGovernance
    /// @param strategy The address to which all NFTs will be approved (strategy)
    /// @param nfts Subvault NFTs to add
    function setApprovalsForStrategy(address strategy, uint256[] memory nfts) external;
}",416
RealWorld_BA_58_GatewayVaultGovernance_RealWord_20240821223548.log,58,GatewayVaultGovernance,23260,5307,28567,113.0,0.22244,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IGatewayVaultGovernance.sol"";
import ""./interfaces/IGatewayVault.sol"";
import ""./VaultGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Governance that manages all Gateway Vaults params and can deploy a new Gateway Vault.
contract GatewayVaultGovernance is VaultGovernance, IGatewayVaultGovernance {
    /// @notice Creates a new contract.
    /// @param internalParams_ Initial Internal Params
    constructor(InternalParams memory internalParams_) VaultGovernance(internalParams_) {}

    /// @inheritdoc IGatewayVaultGovernance
    function delayedStrategyParams(uint256 nft) public view returns (DelayedStrategyParams memory) {
        if (_delayedStrategyParams[nft].length == 0) {
            return DelayedStrategyParams({redirects: new uint256[](0)});
        }
        return abi.decode(_delayedStrategyParams[nft], (DelayedStrategyParams));
    }

    /// @inheritdoc IGatewayVaultGovernance
    function stagedDelayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory) {
        if (_stagedDelayedStrategyParams[nft].length == 0) {
            return DelayedStrategyParams({redirects: new uint256[](0)});
        }
        return abi.decode(_stagedDelayedStrategyParams[nft], (DelayedStrategyParams));
    }

    /// @inheritdoc IGatewayVaultGovernance
    function strategyParams(uint256 nft) external view returns (StrategyParams memory) {
        if (_strategyParams[nft].length == 0) {
            return StrategyParams({limits: new uint256[](0)});
        }
        return abi.decode(_strategyParams[nft], (StrategyParams));
    }

    /// @inheritdoc IGatewayVaultGovernance
    function stageDelayedStrategyParams(uint256 nft, DelayedStrategyParams calldata params) external {
        IGatewayVault vault = IGatewayVault(_internalParams.registry.vaultForNft(nft));
        require(
            (params.redirects.length == 0) || (params.redirects.length == vault.subvaultNfts().length),
            ExceptionsLibrary.REDIRECTS_AND_VAULT_TOKENS_LENGTH
        );
        _stageDelayedStrategyParams(nft, abi.encode(params));
        emit StageDelayedStrategyParams(tx.origin, msg.sender, nft, params, _delayedStrategyParamsTimestamp[nft]);
    }

    /// @notice Deploy a new vault
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Abi encoded uint256[] - an array of Nfts of subvaults. It is required that each nft subvault is approved by the caller to this address.
    /// @param strategy Strategy that will be approved to manage subvaults
    /// @return vault Address of the new vault
    /// @return nft Nft of the vault in the vault registry
    function deployVault(
        address[] memory vaultTokens,
        bytes memory options,
        address strategy
    ) public override(VaultGovernance, IVaultGovernance) returns (IVault vault, uint256 nft) {
        for (uint256 i = 0; i < vaultTokens.length; ++i) {
            require(_internalParams.protocolGovernance.isAllowedToken(vaultTokens[i]), ""TNA"");
        }
        (vault, nft) = super.deployVault(vaultTokens, """", msg.sender);
        uint256[] memory subvaultNfts = abi.decode(options, (uint256[]));
        IVaultRegistry registry = _internalParams.registry;
        IGatewayVault(address(vault)).addSubvaults(subvaultNfts);
        for (uint256 i = 0; i < subvaultNfts.length; i++) {
            registry.safeTransferFrom(msg.sender, address(vault), subvaultNfts[i]);
        }
        IGatewayVault gw = IGatewayVault(address(vault));
        gw.setApprovalsForStrategy(strategy, subvaultNfts);
    }

    /// @inheritdoc IGatewayVaultGovernance
    function commitDelayedStrategyParams(uint256 nft) external {
        _commitDelayedStrategyParams(nft);
        emit CommitDelayedStrategyParams(
            tx.origin,
            msg.sender,
            nft,
            abi.decode(_delayedStrategyParams[nft], (DelayedStrategyParams))
        );
    }

    /// @inheritdoc IGatewayVaultGovernance
    function setStrategyParams(uint256 nft, StrategyParams calldata params) external {
        _setStrategyParams(nft, abi.encode(params));
        emit SetStrategyParams(tx.origin, msg.sender, nft, params);
    }

    /// @notice Emitted when new DelayedStrategyParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedStrategyParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedStrategyParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedStrategyParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that are committed
    event CommitDelayedStrategyParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedStrategyParams params
    );

    /// @notice Emitted when new StrategyParams are set
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that are set
    event SetStrategyParams(address indexed origin, address indexed sender, uint256 indexed nft, StrategyParams params);
}",1262
RealWorld_BA_58_YearnVault_RealWord_20240821223401.log,58,YearnVault,19387,6008,25395,104.0,0.217095,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/external/aave/ILendingPool.sol"";
import ""./interfaces/external/yearn/IYearnVault.sol"";
import ""./interfaces/IYearnVaultGovernance.sol"";
import ""./Vault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Vault that interfaces Yearn protocol in the integration layer.
/// @dev Notes:
/// ### TVL
///
/// The TVL of the vault is cached and updated after each deposit withdraw.
/// So essentially `tvl` call doesn't take into account accrued interest / donations to Yearn since the
/// last `deposit` / `withdraw`
///
/// ### yTokens
/// yTokens are fixed at the token creation and addresses are taken from YearnVault governance and if missing there
/// - in YearnVaultRegistry.
/// So essentially each yToken is fixed for life of the YearnVault. If the yToken is missing for some vaultToken,
/// the YearnVault cannot be created.
///
/// ### Push / Pull
/// There are some deposit limits imposed by Yearn vaults.
/// The contract's vaultTokens are fully allowed to corresponding yTokens.

contract YearnVault is Vault {
    address[] private _yTokens;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance for this vault
    /// @param vaultTokens_ ERC20 tokens under Vault management
    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)
        Vault(vaultGovernance_, vaultTokens_)
    {
        _yTokens = new address[](vaultTokens_.length);
        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            _yTokens[i] = IYearnVaultGovernance(address(vaultGovernance_)).yTokenForToken(_vaultTokens[i]);
            require(_yTokens[i] != address(0), ""YV"");
        }
    }

    /// @notice Yearn protocol vaults used by this contract
    function yTokens() external view returns (address[] memory) {
        return _yTokens;
    }

    /// @inheritdoc Vault
    function tvl() public view override returns (uint256[] memory tokenAmounts) {
        address[] memory tokens = _vaultTokens;
        tokenAmounts = new uint256[](tokens.length);
        for (uint256 i = 0; i < _yTokens.length; i++) {
            IYearnVault yToken = IYearnVault(_yTokens[i]);
            tokenAmounts[i] = (yToken.balanceOf(address(this)) * yToken.pricePerShare()) / (10**yToken.decimals());
        }
    }

    function _push(uint256[] memory tokenAmounts, bytes memory)
        internal
        override
        returns (uint256[] memory actualTokenAmounts)
    {
        address[] memory tokens = _vaultTokens;
        for (uint256 i = 0; i < _yTokens.length; i++) {
            if (tokenAmounts[i] == 0) {
                continue;
            }

            address token = tokens[i];
            IYearnVault yToken = IYearnVault(_yTokens[i]);
            _allowTokenIfNecessary(token, address(yToken));
            yToken.deposit(tokenAmounts[i], address(this));
        }
        actualTokenAmounts = tokenAmounts;
    }

    function _pull(
        address to,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) internal override returns (uint256[] memory actualTokenAmounts) {
        uint256 maxLoss = abi.decode(options, (uint256));
        for (uint256 i = 0; i < _yTokens.length; i++) {
            if (tokenAmounts[i] == 0) {
                continue;
            }

            IYearnVault yToken = IYearnVault(_yTokens[i]);
            uint256 yTokenAmount = ((tokenAmounts[i] * (10**yToken.decimals())) / yToken.pricePerShare());
            uint256 balance = yToken.balanceOf(address(this));
            if (yTokenAmount > balance) {
                yTokenAmount = balance;
            }
            if (yTokenAmount == 0) {
                continue;
            }
            yToken.withdraw(yTokenAmount, to, maxLoss);
            (tokenAmounts[i], address(this));
        }
        actualTokenAmounts = tokenAmounts;
    }

    function _allowTokenIfNecessary(address token, address yToken) internal {
        if (IERC20(token).allowance(address(this), yToken) < type(uint256).max / 2) {
            IERC20(token).approve(yToken, type(uint256).max);
        }
    }
}",1006
RealWorld_BA_58_ERC20VaultTest_RealWord_20240821195506.log,58,ERC20VaultTest,6010,5015,11025,84.0,0.13035,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""../interfaces/IVaultGovernance.sol"";
import ""../interfaces/IVaultFactory.sol"";
import ""../ERC20Vault.sol"";

contract ERC20VaultTest is ERC20Vault {
    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)
        ERC20Vault(vaultGovernance_, vaultTokens_)
    {}

    function setVaultGovernance(address newVaultGovernance) public {
        _vaultGovernance = IVaultGovernance(newVaultGovernance);
    }

    function __postReclaimTokens(address a, address[] memory tokens) public view {
        _postReclaimTokens(a, tokens);
    }
}",150
RealWorld_BA_58_CommonTest_RealWord_20240821231242.log,58,CommonTest,7146,5146,12292,96.0,0.13865,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""../../libraries/CommonLibrary.sol"";

contract CommonTest {
    constructor() {}

    function bubbleSort(address[] memory arr) external pure returns (address[] memory) {
        CommonLibrary.bubbleSort(arr);
        return arr;
    }

    function isSortedAndUnique(address[] memory tokens) external pure returns (bool) {
        return CommonLibrary.isSortedAndUnique(tokens);
    }

    function projectTokenAmountsTest(
        address[] memory tokens,
        address[] memory tokensToProject,
        uint256[] memory tokenAmountsToProject
    ) external pure returns (uint256[] memory) {
        return CommonLibrary.projectTokenAmounts(tokens, tokensToProject, tokenAmountsToProject);
    }

    function splitAmountsTest(uint256[] memory amounts, uint256[][] memory weights)
        external
        pure
        returns (uint256[][] memory)
    {
        return CommonLibrary.splitAmounts(amounts, weights);
    }

    function isContractTest(address addr) external view returns (bool) {
        return CommonLibrary.isContract(addr);
    }
}",239
RealWorld_BA_58_ERC20VaultGovernance_RealWord_20240821192204.log,58,ERC20VaultGovernance,12947,5218,18165,79.0,0.169095,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./trader/interfaces/ITrader.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IERC20VaultGovernance.sol"";
import ""./VaultGovernance.sol"";

/// @notice Governance that manages all ERC20 Vaults params and can deploy a new ERC20 Vault.
contract ERC20VaultGovernance is IERC20VaultGovernance, VaultGovernance {
    /// @notice Creates a new contract.
    /// @param internalParams_ Initial Internal Params
    /// @param delayedProtocolParams_ Initial Protocol Params
    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)
        VaultGovernance(internalParams_)
    {
        _delayedProtocolParams = abi.encode(delayedProtocolParams_);
    }

    /// @inheritdoc IERC20VaultGovernance
    function delayedProtocolParams() public view returns (DelayedProtocolParams memory) {
        if (_delayedProtocolParams.length == 0) return DelayedProtocolParams({trader: ITrader(address(0))});

        return abi.decode(_delayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IERC20VaultGovernance
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory) {
        if (_stagedDelayedProtocolParams.length == 0) return DelayedProtocolParams({trader: ITrader(address(0))});

        return abi.decode(_stagedDelayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IERC20VaultGovernance
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external {
        _stageDelayedProtocolParams(abi.encode(params));
        emit StageDelayedProtocolParams(tx.origin, msg.sender, params, _delayedProtocolParamsTimestamp);
    }

    /// @inheritdoc IERC20VaultGovernance
    function commitDelayedProtocolParams() external {
        _commitDelayedProtocolParams();
        emit CommitDelayedProtocolParams(
            tx.origin,
            msg.sender,
            abi.decode(_delayedProtocolParams, (DelayedProtocolParams))
        );
    }

    /// @notice Emitted when new DelayedProtocolParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedProtocolParams(
        address indexed origin,
        address indexed sender,
        DelayedProtocolParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedProtocolParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that are committed
    event CommitDelayedProtocolParams(address indexed origin, address indexed sender, DelayedProtocolParams params);
}",602
RealWorld_BA_58_ITrader_RealWord_20240821202629.log,58,ITrader,9898,5234,15132,86.0,0.15417,"// SPDX-License-Identifier: BSL-1.1
pragma solidity =0.8.9;

// When trading from a smart contract, the most important thing to keep in mind is that
// access to an external price source is required. Without this, trades can be frontrun for considerable loss.

interface ITrader {
    /// @notice Trade path element
    /// @param token0 The token to be sold
    /// @param token1 The token to be bought
    /// @param options Protocol-specific options
    struct PathItem {
        address token0;
        address token1;
        bytes options;
    }

    /// @notice Swap exact amount of input tokens for output tokens
    /// @param traderId Trader ID (used only by Chief trader)
    /// @param amount Amount of the input tokens to spend
    /// @param recipient Address of the recipient (not used by Chief trader)
    /// @param path Trade path PathItem[]
    /// @param options Protocol-speceific options
    /// @return amountOut Amount of the output tokens received
    function swapExactInput(
        uint256 traderId,
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        bytes memory options
    ) external returns (uint256 amountOut);

    /// @notice Swap exact amount of input tokens for output tokens
    /// @param traderId Trader ID (used only by Chief trader)
    /// @param amount Amount of the output tokens to receive
    /// @param recipient Address of the recipient (not used by Chief trader)
    /// @param path Trade path PathItem[]
    /// @param options Protocol-speceific options
    /// @return amountIn of the input tokens spent
    function swapExactOutput(
        uint256 traderId,
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        bytes memory options
    ) external returns (uint256 amountIn);
}",399
RealWorld_BA_58_GatewayVaultTest_RealWord_20240821201050.log,58,GatewayVaultTest,6574,4700,11274,96.0,0.12687,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""../interfaces/IVaultGovernance.sol"";
import ""../interfaces/IVaultFactory.sol"";
import ""../GatewayVault.sol"";

contract GatewayVaultTest is GatewayVault {
    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)
        GatewayVault(vaultGovernance_, vaultTokens_)
    {}

    function isValidPullDestination(address to) public view returns (bool) {
        return _isValidPullDestination(to);
    }

    function setVaultGovernance(address newVaultGovernance) public {
        _vaultGovernance = IVaultGovernance(newVaultGovernance);
    }

    function setSubvaultNfts(uint256[] memory nfts) public {
        _subvaultNfts = nfts;
    }

    function isApprovedOrOwner(address sender) public view returns (bool) {
        return _isApprovedOrOwner(sender);
    }

    function setVaultTokens(address[] memory tokens) public {
        _vaultTokens = tokens;
    }
}",217
RealWorld_BA_58_UniV3VaultGovernanceTest_RealWord_20240821230255.log,58,UniV3VaultGovernanceTest,5367,4560,9927,81.0,0.118035,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../interfaces/IUniV3VaultGovernance.sol"";
import ""../UniV3VaultGovernance.sol"";
import ""../VaultGovernance.sol"";

contract UniV3VaultGovernanceTest is UniV3VaultGovernance {
    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)
        UniV3VaultGovernance(internalParams_, delayedProtocolParams_)
    {
        delete _delayedProtocolParams;
    }
}",111
RealWorld_BA_58_IUniswapV3Factory_RealWord_20240821211001.log,58,IUniswapV3Factory,19227,5054,24281,109.0,0.197215,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title The interface for the Uniswap V3 Factory
/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees
interface IUniswapV3Factory {
    /// @notice Emitted when the owner of the factory is changed
    /// @param oldOwner The owner before the owner was changed
    /// @param newOwner The owner after the owner was changed
    event OwnerChanged(address indexed oldOwner, address indexed newOwner);

    /// @notice Emitted when a pool is created
    /// @param token0 The first token of the pool by address sort order
    /// @param token1 The second token of the pool by address sort order
    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
    /// @param tickSpacing The minimum number of ticks between initialized ticks
    /// @param pool The address of the created pool
    event PoolCreated(
        address indexed token0,
        address indexed token1,
        uint24 indexed fee,
        int24 tickSpacing,
        address pool
    );

    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory
    /// @param fee The enabled fee, denominated in hundredths of a bip
    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee
    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);

    /// @notice Returns the current owner of the factory
    /// @dev Can be changed by the current owner via setOwner
    /// @return The address of the factory owner
    function owner() external view returns (address);

    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled
    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context
    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee
    /// @return The tick spacing
    function feeAmountTickSpacing(uint24 fee) external view returns (int24);

    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist
    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order
    /// @param tokenA The contract address of either token0 or token1
    /// @param tokenB The contract address of the other token
    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
    /// @return pool The pool address
    function getPool(
        address tokenA,
        address tokenB,
        uint24 fee
    ) external view returns (address pool);

    /// @notice Creates a pool for the given two tokens and fee
    /// @param tokenA One of the two tokens in the desired pool
    /// @param tokenB The other of the two tokens in the desired pool
    /// @param fee The desired fee for the pool
    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved
    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments
    /// are invalid.
    /// @return pool The address of the newly created pool
    function createPool(
        address tokenA,
        address tokenB,
        uint24 fee
    ) external returns (address pool);

    /// @notice Updates the owner of the factory
    /// @dev Must be called by the current owner
    /// @param _owner The new owner of the factory
    function setOwner(address _owner) external;

    /// @notice Enables a fee amount with the given tickSpacing
    /// @dev Fee amounts may never be removed once enabled
    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)
    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount
    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
}",939
RealWorld_BA_58_ILpIssuer_RealWord_20240821235205.log,58,ILpIssuer,8057,4739,12796,80.0,0.135065,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVault.sol"";

interface ILpIssuer {
    /// @notice VaultRegistry NFT for this vault
    function nft() external view returns (uint256);

    /// @notice Nft of the underlying vault.
    function subvaultNft() external view returns (uint256);

    /// @notice Adds subvault nft to the vault.
    /// @dev Can be called only once.
    /// @param nft Subvault nft to add
    function addSubvault(uint256 nft) external;

    /// @notice Initialize contract with vault nft
    /// @param nft VaultRegistry NFT for this vault
    function initialize(uint256 nft) external;

    /// @notice Deposit tokens into LpIssuer
    /// @param tokenAmounts Amounts of tokens to push
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param.
    function deposit(uint256[] calldata tokenAmounts, bytes memory options) external;

    /// @notice Withdraw tokens from LpIssuer
    /// @param to Address to withdraw to
    /// @param lpTokenAmount Amount of token to withdraw
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param.
    function withdraw(
        address to,
        uint256 lpTokenAmount,
        bytes memory options
    ) external;
}",323
RealWorld_BA_58_ILpIssuer_RealWord_20240821214022.log,58,ILpIssuer,8244,5602,13846,101.0,0.15326,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVault.sol"";

interface ILpIssuer {
    /// @notice VaultRegistry NFT for this vault
    function nft() external view returns (uint256);

    /// @notice Nft of the underlying vault.
    function subvaultNft() external view returns (uint256);

    /// @notice Adds subvault nft to the vault.
    /// @dev Can be called only once.
    /// @param nft Subvault nft to add
    function addSubvault(uint256 nft) external;

    /// @notice Initialize contract with vault nft
    /// @param nft VaultRegistry NFT for this vault
    function initialize(uint256 nft) external;

    /// @notice Deposit tokens into LpIssuer
    /// @param tokenAmounts Amounts of tokens to push
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param.
    function deposit(uint256[] calldata tokenAmounts, bytes memory options) external;

    /// @notice Withdraw tokens from LpIssuer
    /// @param to Address to withdraw to
    /// @param lpTokenAmount Amount of token to withdraw
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param.
    function withdraw(
        address to,
        uint256 lpTokenAmount,
        bytes memory options
    ) external;
}",323
RealWorld_BA_58_WERC20Test_RealWord_20240821195318.log,58,WERC20Test,5404,5376,10780,106.0,0.13454,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

interface IWrapped {
    function deposit() external payable;

    function withdraw(uint256 wad) external;
}

contract WERC20Test is IWrapped, ERC20 {
    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {
        _mint(msg.sender, (10**18) * (10**18));
    }

    function deposit() external payable {}

    function withdraw(uint256 wad) external {}
}",125
RealWorld_BA_58_IYearnVaultRegistry_RealWord_20240821210322.log,58,IYearnVaultRegistry,3613,3406,7019,66.0,0.086185,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.9;

interface IYearnVaultRegistry {
    function latestVault(address vault) external view returns (address);
}",37
RealWorld_BA_58_INonfungiblePositionManager_RealWord_20240822001017.log,58,INonfungiblePositionManager,33045,5890,38935,351.0,0.283025,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.9;
pragma abicoder v2;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""./IPeripheryImmutableState.sol"";

/// @title Non-fungible token for positions
/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred
/// and authorized.
interface INonfungiblePositionManager is IPeripheryImmutableState, IERC721 {
    /// @notice Emitted when liquidity is increased for a position NFT
    /// @dev Also emitted when a token is minted
    /// @param tokenId The ID of the token for which liquidity was increased
    /// @param liquidity The amount by which liquidity for the NFT position was increased
    /// @param amount0 The amount of token0 that was paid for the increase in liquidity
    /// @param amount1 The amount of token1 that was paid for the increase in liquidity
    event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
    /// @notice Emitted when liquidity is decreased for a position NFT
    /// @param tokenId The ID of the token for which liquidity was decreased
    /// @param liquidity The amount by which liquidity for the NFT position was decreased
    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity
    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity
    event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
    /// @notice Emitted when tokens are collected for a position NFT
    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior
    /// @param tokenId The ID of the token for which underlying tokens were collected
    /// @param recipient The address of the account that received the collected tokens
    /// @param amount0 The amount of token0 owed to the position that was collected
    /// @param amount1 The amount of token1 owed to the position that was collected
    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);

    /// @notice Returns the position information associated with a given token ID.
    /// @dev Throws if the token ID is not valid.
    /// @param tokenId The ID of the token that represents the position
    /// @return nonce The nonce for permits
    /// @return operator The address that is approved for spending
    /// @return token0 The address of the token0 for a specific pool
    /// @return token1 The address of the token1 for a specific pool
    /// @return fee The fee associated with the pool
    /// @return tickLower The lower end of the tick range for the position
    /// @return tickUpper The higher end of the tick range for the position
    /// @return liquidity The liquidity of the position
    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position
    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position
    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation
    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation
    function positions(uint256 tokenId)
        external
        view
        returns (
            uint96 nonce,
            address operator,
            address token0,
            address token1,
            uint24 fee,
            int24 tickLower,
            int24 tickUpper,
            uint128 liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );

    struct MintParams {
        address token0;
        address token1;
        uint24 fee;
        int24 tickLower;
        int24 tickUpper;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        address recipient;
        uint256 deadline;
    }

    /// @notice Creates a new position wrapped in a NFT
    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized
    /// a method does not exist, i.e. the pool is assumed to be initialized.
    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata
    /// @return tokenId The ID of the token that represents the minted position
    /// @return liquidity The amount of liquidity for this position
    /// @return amount0 The amount of token0
    /// @return amount1 The amount of token1
    function mint(MintParams calldata params)
        external
        payable
        returns (
            uint256 tokenId,
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        );

    struct IncreaseLiquidityParams {
        uint256 tokenId;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`
    /// @param params tokenId The ID of the token for which liquidity is being increased,
    /// amount0Desired The desired amount of token0 to be spent,
    /// amount1Desired The desired amount of token1 to be spent,
    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,
    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,
    /// deadline The time by which the transaction must be included to effect the change
    /// @return liquidity The new liquidity amount as a result of the increase
    /// @return amount0 The amount of token0 to acheive resulting liquidity
    /// @return amount1 The amount of token1 to acheive resulting liquidity
    function increaseLiquidity(IncreaseLiquidityParams calldata params)
        external
        payable
        returns (
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        );

    struct DecreaseLiquidityParams {
        uint256 tokenId;
        uint128 liquidity;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    /// @notice Decreases the amount of liquidity in a position and accounts it to the position
    /// @param params tokenId The ID of the token for which liquidity is being decreased,
    /// amount The amount by which liquidity will be decreased,
    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,
    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,
    /// deadline The time by which the transaction must be included to effect the change
    /// @return amount0 The amount of token0 accounted to the position's tokens owed
    /// @return amount1 The amount of token1 accounted to the position's tokens owed
    function decreaseLiquidity(DecreaseLiquidityParams calldata params)
        external
        payable
        returns (uint256 amount0, uint256 amount1);

    struct CollectParams {
        uint256 tokenId;
        address recipient;
        uint128 amount0Max;
        uint128 amount1Max;
    }

    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient
    /// @param params tokenId The ID of the NFT for which tokens are being collected,
    /// recipient The account that should receive the tokens,
    /// amount0Max The maximum amount of token0 to collect,
    /// amount1Max The maximum amount of token1 to collect
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);

    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens
    /// must be collected first.
    /// @param tokenId The ID of the token that is being burned
    function burn(uint256 tokenId) external payable;
}",1833
RealWorld_BA_58_TestEncoding_RealWord_20240821195632.log,58,TestEncoding,6207,4293,10500,109.0,0.116895,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../interfaces/IProtocolGovernance.sol"";
import ""../interfaces/IVaultGovernance.sol"";
import ""../interfaces/IVaultRegistry.sol"";

contract TestEncoding {
    IProtocolGovernance.Params private data;
    address addr;

    function setDataCalldata(bytes calldata tempData) public {
        data = abi.decode(tempData, (IProtocolGovernance.Params));
    }

    function setDataMemory(bytes memory tempData) public {
        data = abi.decode(tempData, (IProtocolGovernance.Params));
    }

    function getData() public view returns (IProtocolGovernance.Params memory) {
        return data;
    }

    function setAddress(bytes calldata _addr) public {
        addr = abi.decode(_addr, (address));
    }

    function getAddress() public view returns (address) {
        return addr;
    }
}",188
RealWorld_BA_58_ExceptionsLibrary_RealWord_20240821202947.log,58,ExceptionsLibrary,13391,5548,18939,90.0,0.177915,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

/// @notice Exceptions stores project`s smart-contracts exceptions
library ExceptionsLibrary {
    string constant GOVERNANCE_OR_DELEGATE = ""GD"";
    string constant NULL = ""NULL"";
    string constant TIMESTAMP = ""TS"";
    string constant GOVERNANCE_OR_DELEGATE_ADDRESS_ZERO = ""ZMG"";
    string constant EMPTY_PARAMS = ""P0"";
    string constant ADMIN = ""ADM"";
    string constant ADMIN_ADDRESS_ZERO = ""ZADM"";
    string constant VAULT_FACTORY_ADDRESS_ZERO = ""ZVF"";
    string constant APPROVED_OR_OWNER = ""IO"";
    string constant INCONSISTENT_LENGTH = ""L"";
    string constant LIMIT_OVERFLOW = ""LIM"";
    string constant SORTED_AND_UNIQUE = ""SAU"";
    string constant ERC20_INSUFFICIENT_BALANCE = ""ERC20: transfer amount exceeds balance"";
    string constant VALID_PULL_DESTINATION = ""INTRA"";
    string constant CONTRACT_REQUIRED = ""C"";
    string constant SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE = ""VG"";
    string constant REQUIRE_AT_LEAST_ADMIN = ""RST"";
    string constant NULL_OR_NOT_INITIALIZED = ""NA"";
    string constant REDIRECTS_AND_VAULT_TOKENS_LENGTH = ""RL"";
    string constant INITIALIZATION = ""INIT"";
    string constant PERMISSIONLESS_OR_ADMIN = ""POA"";
    string constant TOKEN_NOT_IN_PROJECT = ""TPS"";
    string constant WEIGHTS_LENGTH_IS_ZERO = ""KGT0"";
    string constant AMOUNTS_LENGTH_IS_ZERO = ""NGT0"";
    string constant MATRIX_NOT_RECTANGULAR = ""NV"";
    string constant TOTAL_SUPPLY_IS_ZERO = ""TS0"";
    string constant ALLOWED_TO_CLAIM = ""AC"";
    string constant OTHER_VAULT_TOKENS = ""OWT"";
    string constant SUB_VAULT_INITIALIZED = ""SBIN"";
    string constant SUB_VAULT_LENGTH = ""SBL"";
    string constant NFT_ZERO = ""NFT0"";
    string constant YEARN_VAULTS = ""YV"";
    string constant LOCKED_NFT = ""LCKD"";
    string constant TOKEN_OWNER = ""TO"";
    string constant NOT_VAULT_TOKEN = ""VT"";
    string constant NOT_STRATEGY_TREASURY = ""ST"";
    string constant ZERO_STRATEGY_ADDRESS = ""ZS"";
    string constant NFT_VAULT_REGISTRY = ""NFTVR"";
    string constant ZERO_TOKEN = ""ZT"";
    string constant INITIALIZE_SUB_VAULT = ""INITSV"";
    string constant INITIALIZE_OWNER = ""INITOWN"";
    string constant LIMIT_PER_ADDRESS = ""LPA"";
    string constant MAX_MANAGEMENT_FEE = ""MMF"";
    string constant MAX_PERFORMANCE_FEE = ""MPFF"";
    string constant MAX_PROTOCOL_FEE = ""MPF"";
    string constant TOKEN_LENGTH = ""TL"";
    string constant IO_LENGTH = ""IOL"";
    string constant YEARN_VAULT = ""YV"";
    string constant MAX_GOVERNANCE_DELAY = ""MD"";
    string constant OWNER_VAULT_NFT = ""OWV"";
}",652
RealWorld_BA_58_IVaultGovernance_RealWord_20240821235327.log,58,IVaultGovernance,14019,5049,19068,120.0,0.171075,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""./IProtocolGovernance.sol"";
import ""./IVaultRegistry.sol"";
import ""./IVaultFactory.sol"";
import ""./IVault.sol"";

interface IVaultGovernance {
    /// @notice Internal references of the contract.
    /// @param protocolGovernance Reference to Protocol Governance
    /// @param registry Reference to Vault Registry
    struct InternalParams {
        IProtocolGovernance protocolGovernance;
        IVaultRegistry registry;
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @notice Checks if contract is initialized.
    /// @dev Uninitialized contracts cannot deploy vaults
    function initialized() external view returns (bool);

    /// @notice Vault factory for this Vault Governance.
    function factory() external view returns (IVaultFactory);

    /// @notice Timestamp in unix time seconds after which staged Delayed Strategy Params could be committed.
    /// @param nft Nft of the vault
    function delayedStrategyParamsTimestamp(uint256 nft) external view returns (uint256);

    /// @notice Timestamp in unix time seconds after which staged Delayed Protocol Params could be committed.
    function delayedProtocolParamsTimestamp() external view returns (uint256);

    /// @notice Timestamp in unix time seconds after which staged Delayed Protocol Params Per Vault could be committed.
    /// @param nft Nft of the vault
    function delayedProtocolPerVaultParamsTimestamp(uint256 nft) external view returns (uint256);

    /// @notice Timestamp in unix time seconds after which staged Internal Params could be committed.
    function internalParamsTimestamp() external view returns (uint256);

    /// @notice Internal Params of the contract.
    function internalParams() external view returns (InternalParams memory);

    /// @notice Staged new Internal Params.
    /// @dev The Internal Params could be committed after internalParamsTimestamp
    function stagedInternalParams() external view returns (InternalParams memory);

    // -------------------  PUBLIC, MUTATING  -------------------

    /// @notice Instantly initialize governance with factory.
    /// @dev Can only be called by initial deployer and only once.
    /// Required to be called before any function starts working.
    /// @param factory new factory
    function initialize(IVaultFactory factory) external;

    /// @notice Deploy a new vault.
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Reserved additional deploy options. Should be 0x0.
    /// @param owner Owner of the registry vault nft. If it is address(0) then vault will own his own nft
    /// @return vault Address of the new vault
    /// @return nft Nft of the vault in the vault registry
    function deployVault(
        address[] memory vaultTokens,
        bytes memory options,
        address owner
    ) external returns (IVault vault, uint256 nft);

    /// @notice Stage new Internal Params.
    /// @param newParams New Internal Params
    function stageInternalParams(InternalParams memory newParams) external;

    /// @notice Commit staged Internal Params.
    function commitInternalParams() external;
}",669
RealWorld_BA_58_IAaveVaultGovernance_RealWord_20240821235029.log,58,IAaveVaultGovernance,7557,4910,12467,94.0,0.135985,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

import ""./external/aave/ILendingPool.sol"";
import ""./IVaultGovernance.sol"";

interface IAaveVaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param lendingPool Reference to Aave LendingPool
    struct DelayedProtocolParams {
        ILendingPool lendingPool;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",270
RealWorld_BA_58_ERC20VaultTest_RealWord_20240821225058.log,58,ERC20VaultTest,5286,4014,9300,78.0,0.10671,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""../interfaces/IVaultGovernance.sol"";
import ""../interfaces/IVaultFactory.sol"";
import ""../ERC20Vault.sol"";

contract ERC20VaultTest is ERC20Vault {
    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)
        ERC20Vault(vaultGovernance_, vaultTokens_)
    {}

    function setVaultGovernance(address newVaultGovernance) public {
        _vaultGovernance = IVaultGovernance(newVaultGovernance);
    }

    function __postReclaimTokens(address a, address[] memory tokens) public view {
        _postReclaimTokens(a, tokens);
    }
}",150
RealWorld_BA_58_VaultGovernance_RealWord_20240821194022.log,58,VaultGovernance,38294,5222,43516,101.0,0.29591,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IVaultGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Internal contract for managing different params.
/// @dev The contract should be overriden by the concrete VaultGovernance,
/// define different params structs and use abi.decode / abi.encode to serialize
/// to bytes in this contract. It also should emit events on params change.
abstract contract VaultGovernance is IVaultGovernance {
    InternalParams internal _internalParams;
    InternalParams private _stagedInternalParams;
    uint256 internal _internalParamsTimestamp;

    mapping(uint256 => bytes) internal _delayedStrategyParams;
    mapping(uint256 => bytes) internal _stagedDelayedStrategyParams;
    mapping(uint256 => uint256) internal _delayedStrategyParamsTimestamp;

    mapping(uint256 => bytes) internal _delayedProtocolPerVaultParams;
    mapping(uint256 => bytes) internal _stagedDelayedProtocolPerVaultParams;
    mapping(uint256 => uint256) internal _delayedProtocolPerVaultParamsTimestamp;

    bytes internal _delayedProtocolParams;
    bytes internal _stagedDelayedProtocolParams;
    uint256 internal _delayedProtocolParamsTimestamp;

    mapping(uint256 => bytes) internal _strategyParams;
    bytes internal _protocolParams;

    IVaultFactory public factory;
    bool public initialized;

    /// @notice Creates a new contract.
    /// @param internalParams_ Initial Internal Params
    constructor(InternalParams memory internalParams_) {
        _internalParams = internalParams_;
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @inheritdoc IVaultGovernance
    function delayedStrategyParamsTimestamp(uint256 nft) external view returns (uint256) {
        return _delayedStrategyParamsTimestamp[nft];
    }

    /// @inheritdoc IVaultGovernance
    function delayedProtocolPerVaultParamsTimestamp(uint256 nft) external view returns (uint256) {
        return _delayedProtocolPerVaultParamsTimestamp[nft];
    }

    /// @inheritdoc IVaultGovernance
    function delayedProtocolParamsTimestamp() external view returns (uint256) {
        return _delayedProtocolParamsTimestamp;
    }

    /// @inheritdoc IVaultGovernance
    function internalParamsTimestamp() external view returns (uint256) {
        return _internalParamsTimestamp;
    }

    /// @inheritdoc IVaultGovernance
    function internalParams() external view returns (InternalParams memory) {
        return _internalParams;
    }

    /// @inheritdoc IVaultGovernance
    function stagedInternalParams() external view returns (InternalParams memory) {
        return _stagedInternalParams;
    }

    // -------------------  PUBLIC, MUTATING  -------------------

    /// @inheritdoc IVaultGovernance
    function initialize(IVaultFactory factory_) external {
        require(!initialized, ExceptionsLibrary.INITIALIZATION);
        factory = factory_;
        initialized = true;
    }

    /// @inheritdoc IVaultGovernance
    function deployVault(
        address[] memory vaultTokens,
        bytes memory options,
        address owner
    ) public virtual returns (IVault vault, uint256 nft) {
        require(initialized, ExceptionsLibrary.INITIALIZATION);
        IProtocolGovernance protocolGovernance = IProtocolGovernance(_internalParams.protocolGovernance);
        require(protocolGovernance.permissionless() || protocolGovernance.isAdmin(msg.sender), ExceptionsLibrary.PERMISSIONLESS_OR_ADMIN);
        vault = factory.deployVault(vaultTokens, options);
        address nftOwner = owner;
        nft = _internalParams.registry.registerVault(address(vault), nftOwner);
        vault.initialize(nft);
        emit DeployedVault(tx.origin, msg.sender, vaultTokens, options, nftOwner, address(vault), nft);
    }

    /// @inheritdoc IVaultGovernance
    function stageInternalParams(InternalParams memory newParams) external {
        _requireProtocolAdmin();
        _stagedInternalParams = newParams;
        _internalParamsTimestamp = block.timestamp + _internalParams.protocolGovernance.governanceDelay();
        emit StagedInternalParams(tx.origin, msg.sender, newParams, _internalParamsTimestamp);
    }

    /// @inheritdoc IVaultGovernance
    function commitInternalParams() external {
        _requireProtocolAdmin();
        require(_internalParamsTimestamp > 0, ExceptionsLibrary.NULL);
        require(block.timestamp >= _internalParamsTimestamp, ExceptionsLibrary.TIMESTAMP);
        _internalParams = _stagedInternalParams;
        delete _internalParamsTimestamp;
        emit CommitedInternalParams(tx.origin, msg.sender, _internalParams);
    }

    // -------------------  INTERNAL  -------------------

    /// @notice Set Delayed Strategy Params
    /// @param nft Nft of the vault
    /// @param params New params
    function _stageDelayedStrategyParams(uint256 nft, bytes memory params) internal {
        _requireAtLeastStrategy(nft);
        _stagedDelayedStrategyParams[nft] = params;
        uint256 delayFactor = _delayedStrategyParams[nft].length == 0 ? 0 : 1;
        _delayedStrategyParamsTimestamp[nft] =
            block.timestamp +
            _internalParams.protocolGovernance.governanceDelay() *
            delayFactor;
    }

    /// @notice Commit Delayed Strategy Params
    function _commitDelayedStrategyParams(uint256 nft) internal {
        _requireAtLeastStrategy(nft);
        require(_delayedStrategyParamsTimestamp[nft] > 0, ExceptionsLibrary.NULL);
        require(block.timestamp >= _delayedStrategyParamsTimestamp[nft], ExceptionsLibrary.TIMESTAMP);
        _delayedStrategyParams[nft] = _stagedDelayedStrategyParams[nft];
        delete _stagedDelayedStrategyParams[nft];
        delete _delayedStrategyParamsTimestamp[nft];
    }

    /// @notice Set Delayed Protocol Per Vault Params
    /// @param nft Nft of the vault
    /// @param params New params
    function _stageDelayedProtocolPerVaultParams(uint256 nft, bytes memory params) internal {
        _requireProtocolAdmin();
        _stagedDelayedProtocolPerVaultParams[nft] = params;
        uint256 delayFactor = _delayedProtocolPerVaultParams[nft].length == 0 ? 0 : 1;
        _delayedProtocolPerVaultParamsTimestamp[nft] =
            block.timestamp +
            _internalParams.protocolGovernance.governanceDelay() *
            delayFactor;
    }

    /// @notice Commit Delayed Protocol Per Vault Params
    function _commitDelayedProtocolPerVaultParams(uint256 nft) internal {
        _requireProtocolAdmin();
        require(_delayedProtocolPerVaultParamsTimestamp[nft] > 0, ExceptionsLibrary.NULL);
        require(block.timestamp >= _delayedProtocolPerVaultParamsTimestamp[nft], ExceptionsLibrary.TIMESTAMP);
        _delayedProtocolPerVaultParams[nft] = _stagedDelayedProtocolPerVaultParams[nft];
        delete _stagedDelayedProtocolPerVaultParams[nft];
        delete _delayedProtocolPerVaultParamsTimestamp[nft];
    }

    /// @notice Set Delayed Protocol Params
    /// @param params New params
    function _stageDelayedProtocolParams(bytes memory params) internal {
        _requireProtocolAdmin();
        uint256 delayFactor = _delayedProtocolParams.length == 0 ? 0 : 1;
        _stagedDelayedProtocolParams = params;
        _delayedProtocolParamsTimestamp =
            block.timestamp +
            _internalParams.protocolGovernance.governanceDelay() *
            delayFactor;
    }

    /// @notice Commit Delayed Protocol Params
    function _commitDelayedProtocolParams() internal {
        _requireProtocolAdmin();
        require(_delayedProtocolParamsTimestamp > 0, ExceptionsLibrary.NULL);
        require(block.timestamp >= _delayedProtocolParamsTimestamp, ExceptionsLibrary.TIMESTAMP);
        _delayedProtocolParams = _stagedDelayedProtocolParams;
        delete _stagedDelayedProtocolParams;
        delete _delayedProtocolParamsTimestamp;
    }

    /// @notice Set immediate strategy params
    /// @dev Should require nft > 0
    /// @param nft Nft of the vault
    /// @param params New params
    function _setStrategyParams(uint256 nft, bytes memory params) internal {
        _requireAtLeastStrategy(nft);
        _strategyParams[nft] = params;
    }

    /// @notice Set immediate protocol params
    /// @param params New params
    function _setProtocolParams(bytes memory params) internal {
        _requireProtocolAdmin();
        _protocolParams = params;
    }

    function _requireAtLeastStrategy(uint256 nft) internal view {
        require(
            (_internalParams.protocolGovernance.isAdmin(msg.sender) ||
                _internalParams.registry.getApproved(nft) == msg.sender ||
                (_internalParams.registry.ownerOf(nft) == msg.sender)),
            ExceptionsLibrary.REQUIRE_AT_LEAST_ADMIN
        );
    }

    function _requireProtocolAdmin() internal view {
        require(_internalParams.protocolGovernance.isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
    }

    /// @notice Emitted when InternalParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StagedInternalParams(address indexed origin, address indexed sender, InternalParams params, uint256 when);

    /// @notice Emitted when InternalParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    event CommitedInternalParams(address indexed origin, address indexed sender, InternalParams params);

    /// @notice Emitted when New Vault is deployed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param vaultTokens Vault tokens for this vault
    /// @param options Options for deploy. The details of the options structure are specified in subcontracts
    /// @param owner Owner of the VaultRegistry NFT for this vault
    /// @param vaultAddress Address of the new Vault
    /// @param vaultNft VaultRegistry NFT for the new Vault
    event DeployedVault(
        address indexed origin,
        address indexed sender,
        address[] vaultTokens,
        bytes options,
        address owner,
        address vaultAddress,
        uint256 vaultNft
    );
}",2217
RealWorld_BA_58_VaultGovernance_RealWord_20240821223744.log,58,VaultGovernance,38407,5276,43683,91.0,0.297555,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IVaultGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Internal contract for managing different params.
/// @dev The contract should be overriden by the concrete VaultGovernance,
/// define different params structs and use abi.decode / abi.encode to serialize
/// to bytes in this contract. It also should emit events on params change.
abstract contract VaultGovernance is IVaultGovernance {
    InternalParams internal _internalParams;
    InternalParams private _stagedInternalParams;
    uint256 internal _internalParamsTimestamp;

    mapping(uint256 => bytes) internal _delayedStrategyParams;
    mapping(uint256 => bytes) internal _stagedDelayedStrategyParams;
    mapping(uint256 => uint256) internal _delayedStrategyParamsTimestamp;

    mapping(uint256 => bytes) internal _delayedProtocolPerVaultParams;
    mapping(uint256 => bytes) internal _stagedDelayedProtocolPerVaultParams;
    mapping(uint256 => uint256) internal _delayedProtocolPerVaultParamsTimestamp;

    bytes internal _delayedProtocolParams;
    bytes internal _stagedDelayedProtocolParams;
    uint256 internal _delayedProtocolParamsTimestamp;

    mapping(uint256 => bytes) internal _strategyParams;
    bytes internal _protocolParams;

    IVaultFactory public factory;
    bool public initialized;

    /// @notice Creates a new contract.
    /// @param internalParams_ Initial Internal Params
    constructor(InternalParams memory internalParams_) {
        _internalParams = internalParams_;
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @inheritdoc IVaultGovernance
    function delayedStrategyParamsTimestamp(uint256 nft) external view returns (uint256) {
        return _delayedStrategyParamsTimestamp[nft];
    }

    /// @inheritdoc IVaultGovernance
    function delayedProtocolPerVaultParamsTimestamp(uint256 nft) external view returns (uint256) {
        return _delayedProtocolPerVaultParamsTimestamp[nft];
    }

    /// @inheritdoc IVaultGovernance
    function delayedProtocolParamsTimestamp() external view returns (uint256) {
        return _delayedProtocolParamsTimestamp;
    }

    /// @inheritdoc IVaultGovernance
    function internalParamsTimestamp() external view returns (uint256) {
        return _internalParamsTimestamp;
    }

    /// @inheritdoc IVaultGovernance
    function internalParams() external view returns (InternalParams memory) {
        return _internalParams;
    }

    /// @inheritdoc IVaultGovernance
    function stagedInternalParams() external view returns (InternalParams memory) {
        return _stagedInternalParams;
    }

    // -------------------  PUBLIC, MUTATING  -------------------

    /// @inheritdoc IVaultGovernance
    function initialize(IVaultFactory factory_) external {
        require(!initialized, ExceptionsLibrary.INITIALIZATION);
        factory = factory_;
        initialized = true;
    }

    /// @inheritdoc IVaultGovernance
    function deployVault(
        address[] memory vaultTokens,
        bytes memory options,
        address owner
    ) public virtual returns (IVault vault, uint256 nft) {
        require(initialized, ExceptionsLibrary.INITIALIZATION);
        IProtocolGovernance protocolGovernance = IProtocolGovernance(_internalParams.protocolGovernance);
        require(protocolGovernance.permissionless() || protocolGovernance.isAdmin(msg.sender), ExceptionsLibrary.PERMISSIONLESS_OR_ADMIN);
        vault = factory.deployVault(vaultTokens, options);
        address nftOwner = owner;
        nft = _internalParams.registry.registerVault(address(vault), nftOwner);
        vault.initialize(nft);
        emit DeployedVault(tx.origin, msg.sender, vaultTokens, options, nftOwner, address(vault), nft);
    }

    /// @inheritdoc IVaultGovernance
    function stageInternalParams(InternalParams memory newParams) external {
        _requireProtocolAdmin();
        _stagedInternalParams = newParams;
        _internalParamsTimestamp = block.timestamp + _internalParams.protocolGovernance.governanceDelay();
        emit StagedInternalParams(tx.origin, msg.sender, newParams, _internalParamsTimestamp);
    }

    /// @inheritdoc IVaultGovernance
    function commitInternalParams() external {
        _requireProtocolAdmin();
        require(_internalParamsTimestamp > 0, ExceptionsLibrary.NULL);
        require(block.timestamp >= _internalParamsTimestamp, ExceptionsLibrary.TIMESTAMP);
        _internalParams = _stagedInternalParams;
        delete _internalParamsTimestamp;
        emit CommitedInternalParams(tx.origin, msg.sender, _internalParams);
    }

    // -------------------  INTERNAL  -------------------

    /// @notice Set Delayed Strategy Params
    /// @param nft Nft of the vault
    /// @param params New params
    function _stageDelayedStrategyParams(uint256 nft, bytes memory params) internal {
        _requireAtLeastStrategy(nft);
        _stagedDelayedStrategyParams[nft] = params;
        uint256 delayFactor = _delayedStrategyParams[nft].length == 0 ? 0 : 1;
        _delayedStrategyParamsTimestamp[nft] =
            block.timestamp +
            _internalParams.protocolGovernance.governanceDelay() *
            delayFactor;
    }

    /// @notice Commit Delayed Strategy Params
    function _commitDelayedStrategyParams(uint256 nft) internal {
        _requireAtLeastStrategy(nft);
        require(_delayedStrategyParamsTimestamp[nft] > 0, ExceptionsLibrary.NULL);
        require(block.timestamp >= _delayedStrategyParamsTimestamp[nft], ExceptionsLibrary.TIMESTAMP);
        _delayedStrategyParams[nft] = _stagedDelayedStrategyParams[nft];
        delete _stagedDelayedStrategyParams[nft];
        delete _delayedStrategyParamsTimestamp[nft];
    }

    /// @notice Set Delayed Protocol Per Vault Params
    /// @param nft Nft of the vault
    /// @param params New params
    function _stageDelayedProtocolPerVaultParams(uint256 nft, bytes memory params) internal {
        _requireProtocolAdmin();
        _stagedDelayedProtocolPerVaultParams[nft] = params;
        uint256 delayFactor = _delayedProtocolPerVaultParams[nft].length == 0 ? 0 : 1;
        _delayedProtocolPerVaultParamsTimestamp[nft] =
            block.timestamp +
            _internalParams.protocolGovernance.governanceDelay() *
            delayFactor;
    }

    /// @notice Commit Delayed Protocol Per Vault Params
    function _commitDelayedProtocolPerVaultParams(uint256 nft) internal {
        _requireProtocolAdmin();
        require(_delayedProtocolPerVaultParamsTimestamp[nft] > 0, ExceptionsLibrary.NULL);
        require(block.timestamp >= _delayedProtocolPerVaultParamsTimestamp[nft], ExceptionsLibrary.TIMESTAMP);
        _delayedProtocolPerVaultParams[nft] = _stagedDelayedProtocolPerVaultParams[nft];
        delete _stagedDelayedProtocolPerVaultParams[nft];
        delete _delayedProtocolPerVaultParamsTimestamp[nft];
    }

    /// @notice Set Delayed Protocol Params
    /// @param params New params
    function _stageDelayedProtocolParams(bytes memory params) internal {
        _requireProtocolAdmin();
        uint256 delayFactor = _delayedProtocolParams.length == 0 ? 0 : 1;
        _stagedDelayedProtocolParams = params;
        _delayedProtocolParamsTimestamp =
            block.timestamp +
            _internalParams.protocolGovernance.governanceDelay() *
            delayFactor;
    }

    /// @notice Commit Delayed Protocol Params
    function _commitDelayedProtocolParams() internal {
        _requireProtocolAdmin();
        require(_delayedProtocolParamsTimestamp > 0, ExceptionsLibrary.NULL);
        require(block.timestamp >= _delayedProtocolParamsTimestamp, ExceptionsLibrary.TIMESTAMP);
        _delayedProtocolParams = _stagedDelayedProtocolParams;
        delete _stagedDelayedProtocolParams;
        delete _delayedProtocolParamsTimestamp;
    }

    /// @notice Set immediate strategy params
    /// @dev Should require nft > 0
    /// @param nft Nft of the vault
    /// @param params New params
    function _setStrategyParams(uint256 nft, bytes memory params) internal {
        _requireAtLeastStrategy(nft);
        _strategyParams[nft] = params;
    }

    /// @notice Set immediate protocol params
    /// @param params New params
    function _setProtocolParams(bytes memory params) internal {
        _requireProtocolAdmin();
        _protocolParams = params;
    }

    function _requireAtLeastStrategy(uint256 nft) internal view {
        require(
            (_internalParams.protocolGovernance.isAdmin(msg.sender) ||
                _internalParams.registry.getApproved(nft) == msg.sender ||
                (_internalParams.registry.ownerOf(nft) == msg.sender)),
            ExceptionsLibrary.REQUIRE_AT_LEAST_ADMIN
        );
    }

    function _requireProtocolAdmin() internal view {
        require(_internalParams.protocolGovernance.isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
    }

    /// @notice Emitted when InternalParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StagedInternalParams(address indexed origin, address indexed sender, InternalParams params, uint256 when);

    /// @notice Emitted when InternalParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    event CommitedInternalParams(address indexed origin, address indexed sender, InternalParams params);

    /// @notice Emitted when New Vault is deployed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param vaultTokens Vault tokens for this vault
    /// @param options Options for deploy. The details of the options structure are specified in subcontracts
    /// @param owner Owner of the VaultRegistry NFT for this vault
    /// @param vaultAddress Address of the new Vault
    /// @param vaultNft VaultRegistry NFT for the new Vault
    event DeployedVault(
        address indexed origin,
        address indexed sender,
        address[] vaultTokens,
        bytes options,
        address owner,
        address vaultAddress,
        uint256 vaultNft
    );
}",2217
RealWorld_BA_58_UniV3VaultTest_RealWord_20240821201547.log,58,UniV3VaultTest,5170,3969,9139,75.0,0.10523,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""../interfaces/IVaultGovernance.sol"";
import ""../interfaces/IVaultFactory.sol"";
import ""../UniV3Vault.sol"";

contract UniV3VaultTest is UniV3Vault {
    constructor(
        IVaultGovernance vaultGovernance_,
        address[] memory vaultTokens_,
        uint24 fee
    ) UniV3Vault(vaultGovernance_, vaultTokens_, fee) {}

    function setVaultGovernance(address newVaultGovernance) public {
        _vaultGovernance = IVaultGovernance(newVaultGovernance);
    }
}",133
RealWorld_BA_58_IYearnVaultGovernance_RealWord_20240821204334.log,58,IYearnVaultGovernance,9322,4837,14159,109.0,0.14335,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./external/yearn/IYearnVaultRegistry.sol"";
import ""./IVaultGovernance.sol"";

interface IYearnVaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param yearnVaultRegistry Reference to Yearn Vault Registry
    struct DelayedProtocolParams {
        IYearnVaultRegistry yearnVaultRegistry;
    }

    /// @notice Determines a corresponding Yearn vault for token
    /// @param token ERC-20 token for the yToken
    /// @return If there's a yToken returns its address, otherwise returns 0
    function yTokenForToken(address token) external view returns (address);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;

    /// @notice Sets the manual override for yToken vaults map
    /// @dev Can only be called by Protocol Admin
    /// @param token ERC-20 token for yToken
    /// @param yToken for ERC-20 token
    function setYTokenForToken(address token, address yToken) external;
}",401
RealWorld_BA_58_IVaultRegistry_RealWord_20240821205143.log,58,IVaultRegistry,13194,5952,19146,109.0,0.18501,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""./IProtocolGovernance.sol"";
import ""./IVaultFactory.sol"";
import ""./IVaultGovernance.sol"";

interface IVaultRegistry is IERC721 {
    /// @notice Get Vault for the giver NFT ID.
    /// @param nftId NFT ID
    /// @return vault Address of the Vault contract
    function vaultForNft(uint256 nftId) external view returns (address vault);

    /// @notice Get NFT ID for given Vault contract address.
    /// @param vault Address of the Vault contract
    /// @return nftId NFT ID
    function nftForVault(address vault) external view returns (uint256 nftId);

    /// @notice Checks if the nft is locked for all transfers
    /// @param nft NFT to check for lock
    /// @return `true` if locked, false otherwise
    function isLocked(uint256 nft) external view returns (bool);

    /// @notice Register new Vault and mint NFT.
    /// @param vault address of the vault
    /// @param owner owner of the NFT
    /// @return nft Nft minted for the given Vault
    function registerVault(address vault, address owner) external returns (uint256 nft);

    /// @notice Number of Vaults registered.
    function vaultsCount() external view returns (uint256);

    /// @notice All Vaults registered.
    function vaults() external view returns (address[] memory);

    /// @notice Address of the ProtocolGovernance.
    function protocolGovernance() external view returns (IProtocolGovernance);

    /// @notice Address of the staged ProtocolGovernance.
    function stagedProtocolGovernance() external view returns (IProtocolGovernance);

    /// @notice Minimal timestamp when staged ProtocolGovernance can be applied.
    function stagedProtocolGovernanceTimestamp() external view returns (uint256);

    /// @notice Stage new ProtocolGovernance.
    /// @param newProtocolGovernance new ProtocolGovernance
    function stageProtocolGovernance(IProtocolGovernance newProtocolGovernance) external;

    /// @notice Commit new ProtocolGovernance.
    function commitStagedProtocolGovernance() external;

    /// @notice Approve nft to new address
    /// @dev This can be called only by the Protocol Governance. It is used to disable the strategy for a vault
    /// @param newAddress address that will be approved
    /// @param nft for re-approval
    function adminApprove(address newAddress, uint256 nft) external;

    /// @notice Lock NFT for transfers
    /// @dev Use this method when vault structure is set up and should become immutable. Can be called by owner.
    /// @param nft - NFT to lock
    function lockNft(uint256 nft) external;
}",619
RealWorld_BA_58_IGatewayVault_RealWord_20240821234014.log,58,IGatewayVault,10147,5143,15290,90.0,0.153595,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVault.sol"";

interface IGatewayVault is IVault {
    /// @notice List of subvaults nfts
    function subvaultNfts() external view returns (uint256[] memory);

    /// @notice Checks that vault is subvault of the IGatewayVault.
    /// @param vault The vault to check
    /// @return `true` if vault is a subvault of the IGatewayVault
    function hasSubvault(address vault) external view returns (bool);

    /// @notice Breakdown of tvls by subvault.
    /// @return tokenAmounts Token amounts with subvault breakdown. If there are `k` subvaults then token `j`, `tokenAmounts[j]` would be a vector 1 x k - breakdown of token amount by subvaults
    function subvaultsTvl() external view returns (uint256[][] memory tokenAmounts);

    /// @notice A tvl of a specific subvault.
    /// @param vaultNum The number of the subvault in the subvaults array
    /// @return An array of token amounts (tvl) in the same order as vaultTokens
    function subvaultTvl(uint256 vaultNum) external view returns (uint256[] memory);

    /// @notice Adds subvaults NFTs to vault.
    /// @dev Can be called only once by GatewayVaultGovernance
    /// @param nfts Subvault NFTs to add
    function addSubvaults(uint256[] memory nfts) external;

    /// @notice Approves all NFTs to given address.
    /// @dev Can be called only once by GatewayVaultGovernance
    /// @param strategy The address to which all NFTs will be approved (strategy)
    /// @param nfts Subvault NFTs to add
    function setApprovalsForStrategy(address strategy, uint256[] memory nfts) external;
}",416
RealWorld_BA_58_AaveVaultGovernanceTest_RealWord_20240821225519.log,58,AaveVaultGovernanceTest,5391,4728,10119,83.0,0.121515,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../interfaces/IAaveVaultGovernance.sol"";
import ""../AaveVaultGovernance.sol"";
import ""../VaultGovernance.sol"";

contract AaveVaultGovernanceTest is AaveVaultGovernance {
    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)
        AaveVaultGovernance(internalParams_, delayedProtocolParams_)
    {
        delete _delayedProtocolParams;
    }
}",106
RealWorld_BA_58_IUniV3VaultGovernance_RealWord_20240821235529.log,58,IUniV3VaultGovernance,7695,5173,12868,99.0,0.141935,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.9;

import ""./external/univ3/INonfungiblePositionManager.sol"";
import ""./IVaultGovernance.sol"";

interface IUniV3VaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param positionManager Reference to UniV3 INonfungiblePositionManager
    struct DelayedProtocolParams {
        INonfungiblePositionManager positionManager;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",271
RealWorld_BA_58_IERC20VaultGovernance_RealWord_20240821213336.log,58,IERC20VaultGovernance,7423,5140,12563,111.0,0.139915,"// SPDX-License-Identifier: BSL-1.1
pragma solidity 0.8.9;

import ""../trader/interfaces/ITrader.sol"";
import ""./IVaultGovernance.sol"";

interface IERC20VaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param trader Reference to internal Trader contract
    struct DelayedProtocolParams {
        ITrader trader;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",266
RealWorld_BA_58_IUniV3VaultGovernance_RealWord_20240821205950.log,58,IUniV3VaultGovernance,7644,5160,12804,111.0,0.14142,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.9;

import ""./external/univ3/INonfungiblePositionManager.sol"";
import ""./IVaultGovernance.sol"";

interface IUniV3VaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param positionManager Reference to UniV3 INonfungiblePositionManager
    struct DelayedProtocolParams {
        INonfungiblePositionManager positionManager;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",271
RealWorld_BA_58_ERC20VaultGovernance_RealWord_20240821221906.log,58,ERC20VaultGovernance,12788,5147,17935,110.0,0.16688,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./trader/interfaces/ITrader.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IERC20VaultGovernance.sol"";
import ""./VaultGovernance.sol"";

/// @notice Governance that manages all ERC20 Vaults params and can deploy a new ERC20 Vault.
contract ERC20VaultGovernance is IERC20VaultGovernance, VaultGovernance {
    /// @notice Creates a new contract.
    /// @param internalParams_ Initial Internal Params
    /// @param delayedProtocolParams_ Initial Protocol Params
    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)
        VaultGovernance(internalParams_)
    {
        _delayedProtocolParams = abi.encode(delayedProtocolParams_);
    }

    /// @inheritdoc IERC20VaultGovernance
    function delayedProtocolParams() public view returns (DelayedProtocolParams memory) {
        if (_delayedProtocolParams.length == 0) return DelayedProtocolParams({trader: ITrader(address(0))});

        return abi.decode(_delayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IERC20VaultGovernance
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory) {
        if (_stagedDelayedProtocolParams.length == 0) return DelayedProtocolParams({trader: ITrader(address(0))});

        return abi.decode(_stagedDelayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IERC20VaultGovernance
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external {
        _stageDelayedProtocolParams(abi.encode(params));
        emit StageDelayedProtocolParams(tx.origin, msg.sender, params, _delayedProtocolParamsTimestamp);
    }

    /// @inheritdoc IERC20VaultGovernance
    function commitDelayedProtocolParams() external {
        _commitDelayedProtocolParams();
        emit CommitDelayedProtocolParams(
            tx.origin,
            msg.sender,
            abi.decode(_delayedProtocolParams, (DelayedProtocolParams))
        );
    }

    /// @notice Emitted when new DelayedProtocolParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedProtocolParams(
        address indexed origin,
        address indexed sender,
        DelayedProtocolParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedProtocolParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that are committed
    event CommitDelayedProtocolParams(address indexed origin, address indexed sender, DelayedProtocolParams params);
}",602
RealWorld_BA_58_IVaultFactory_RealWord_20240821234346.log,58,IVaultFactory,5257,5177,10434,99.0,0.129825,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";
import ""./IVault.sol"";

interface IVaultFactory {
    /// @notice Deploy a new vault.
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Reserved additional deploy options. Should be 0x0
    function deployVault(address[] memory vaultTokens, bytes memory options) external returns (IVault vault);
}",96
RealWorld_BA_58_TestEncoding_RealWord_20240821225218.log,58,TestEncoding,6120,4369,10489,81.0,0.11798,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../interfaces/IProtocolGovernance.sol"";
import ""../interfaces/IVaultGovernance.sol"";
import ""../interfaces/IVaultRegistry.sol"";

contract TestEncoding {
    IProtocolGovernance.Params private data;
    address addr;

    function setDataCalldata(bytes calldata tempData) public {
        data = abi.decode(tempData, (IProtocolGovernance.Params));
    }

    function setDataMemory(bytes memory tempData) public {
        data = abi.decode(tempData, (IProtocolGovernance.Params));
    }

    function getData() public view returns (IProtocolGovernance.Params memory) {
        return data;
    }

    function setAddress(bytes calldata _addr) public {
        addr = abi.decode(_addr, (address));
    }

    function getAddress() public view returns (address) {
        return addr;
    }
}",188
RealWorld_BA_58_GatewayVaultTestFactory_RealWord_20240821194928.log,58,GatewayVaultTestFactory,6645,4924,11569,105.0,0.131705,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../interfaces/IVaultFactory.sol"";
import ""../interfaces/IVaultGovernance.sol"";
import ""./GatewayVaultTest.sol"";

contract GatewayVaultTestFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    function setVaultGovernance(address newVaultGovernance) public {
        vaultGovernance = IVaultGovernance(newVaultGovernance);
    }

    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ""VG"");
        GatewayVaultTest gatewayVault = new GatewayVaultTest(vaultGovernance, vaultTokens);
        return IVault(gatewayVault);
    }
}",184
RealWorld_BA_58_TestFunctionEncoding_RealWord_20240821225341.log,58,TestFunctionEncoding,4697,4334,9031,96.0,0.110165,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../Vault.sol"";
import ""../interfaces/IVaultGovernance.sol"";
import ""../interfaces/IVault.sol"";

contract TestFunctionEncoding {
    Vault public vault;

    constructor(Vault _vault) {
        vault = _vault;
    }

    function encodeWithSignatureTest(address from) external {
        bytes memory data = abi.encodeWithSignature(""tvl()"");
        vault.claimRewards(from, data);
    }
}",107
RealWorld_BA_58_IUniswapV3Factory_RealWord_20240822000601.log,58,IUniswapV3Factory,18486,4918,23404,75.0,0.19079,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title The interface for the Uniswap V3 Factory
/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees
interface IUniswapV3Factory {
    /// @notice Emitted when the owner of the factory is changed
    /// @param oldOwner The owner before the owner was changed
    /// @param newOwner The owner after the owner was changed
    event OwnerChanged(address indexed oldOwner, address indexed newOwner);

    /// @notice Emitted when a pool is created
    /// @param token0 The first token of the pool by address sort order
    /// @param token1 The second token of the pool by address sort order
    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
    /// @param tickSpacing The minimum number of ticks between initialized ticks
    /// @param pool The address of the created pool
    event PoolCreated(
        address indexed token0,
        address indexed token1,
        uint24 indexed fee,
        int24 tickSpacing,
        address pool
    );

    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory
    /// @param fee The enabled fee, denominated in hundredths of a bip
    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee
    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);

    /// @notice Returns the current owner of the factory
    /// @dev Can be changed by the current owner via setOwner
    /// @return The address of the factory owner
    function owner() external view returns (address);

    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled
    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context
    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee
    /// @return The tick spacing
    function feeAmountTickSpacing(uint24 fee) external view returns (int24);

    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist
    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order
    /// @param tokenA The contract address of either token0 or token1
    /// @param tokenB The contract address of the other token
    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
    /// @return pool The pool address
    function getPool(
        address tokenA,
        address tokenB,
        uint24 fee
    ) external view returns (address pool);

    /// @notice Creates a pool for the given two tokens and fee
    /// @param tokenA One of the two tokens in the desired pool
    /// @param tokenB The other of the two tokens in the desired pool
    /// @param fee The desired fee for the pool
    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved
    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments
    /// are invalid.
    /// @return pool The address of the newly created pool
    function createPool(
        address tokenA,
        address tokenB,
        uint24 fee
    ) external returns (address pool);

    /// @notice Updates the owner of the factory
    /// @dev Must be called by the current owner
    /// @param _owner The new owner of the factory
    function setOwner(address _owner) external;

    /// @notice Enables a fee amount with the given tickSpacing
    /// @dev Fee amounts may never be removed once enabled
    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)
    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount
    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
}",939
RealWorld_BA_58_TestFunctionEncoding_RealWord_20240821195823.log,58,TestFunctionEncoding,4603,4423,9026,86.0,0.111475,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../Vault.sol"";
import ""../interfaces/IVaultGovernance.sol"";
import ""../interfaces/IVault.sol"";

contract TestFunctionEncoding {
    Vault public vault;

    constructor(Vault _vault) {
        vault = _vault;
    }

    function encodeWithSignatureTest(address from) external {
        bytes memory data = abi.encodeWithSignature(""tvl()"");
        vault.claimRewards(from, data);
    }
}",107
RealWorld_BA_58_IVaultFactory_RealWord_20240821204848.log,58,IVaultFactory,4669,4101,8770,84.0,0.105365,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";
import ""./IVault.sol"";

interface IVaultFactory {
    /// @notice Deploy a new vault.
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Reserved additional deploy options. Should be 0x0
    function deployVault(address[] memory vaultTokens, bytes memory options) external returns (IVault vault);
}",96
RealWorld_BA_58_UniV3VaultTest_RealWord_20240821231118.log,58,UniV3VaultTest,5625,4610,10235,82.0,0.120325,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""../interfaces/IVaultGovernance.sol"";
import ""../interfaces/IVaultFactory.sol"";
import ""../UniV3Vault.sol"";

contract UniV3VaultTest is UniV3Vault {
    constructor(
        IVaultGovernance vaultGovernance_,
        address[] memory vaultTokens_,
        uint24 fee
    ) UniV3Vault(vaultGovernance_, vaultTokens_, fee) {}

    function setVaultGovernance(address newVaultGovernance) public {
        _vaultGovernance = IVaultGovernance(newVaultGovernance);
    }
}",133
RealWorld_BA_58_UniV3Trader_RealWord_20240821231714.log,58,UniV3Trader,26963,6244,33207,105.0,0.259695,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../interfaces/external/univ3/ISwapRouter.sol"";
import ""./libraries/TraderExceptionsLibrary.sol"";
import ""./Trader.sol"";

/// @notice Contract that can execute ERC20 swaps on Uniswap V3
contract UniV3Trader is Trader, ITrader {
    using SafeERC20 for IERC20;

    struct Options {
        uint24 fee;
        uint160 sqrtPriceLimitX96;
        uint256 deadline;
        uint256 limitAmount;
    }

    struct PathItemOptions {
        uint24 fee;
    }

    ISwapRouter public swapRouter;

    constructor(address _swapRouter) {
        swapRouter = ISwapRouter(_swapRouter);
    }

    /// @inheritdoc ITrader
    function swapExactInput(
        uint256,
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        bytes memory options
    ) external returns (uint256) {
        Options memory options_ = abi.decode(options, (Options));
        if (path.length == 1) {
            return _swapExactInputSingle(path[0].token0, path[0].token1, amount, recipient, options_);
        } else {
            require(_validatePathLinked(path), TraderExceptionsLibrary.INVALID_TRADE_PATH_EXCEPTION);
            return _swapExactInputMultihop(amount, recipient, path, options_);
        }
    }

    /// @inheritdoc ITrader
    function swapExactOutput(
        uint256,
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        bytes memory options
    ) external returns (uint256) {
        Options memory options_ = abi.decode(options, (Options));
        if (path.length == 0) {
            return _swapExactOutputSingle(path[0].token0, path[0].token1, amount, recipient, options_);
        } else {
            require(_validatePathLinked(path), TraderExceptionsLibrary.INVALID_TRADE_PATH_EXCEPTION);
            return _swapExactOutputMultihop(amount, recipient, path, options_);
        }
    }

    function _validatePathLinked(PathItem[] memory path) internal pure returns (bool result) {
        if (path.length == 0) return false;
        for (uint256 i = 0; i < path.length - 1; ++i) if (path[0].token1 != path[i + 1].token0) return false;
        return true;
    }

    function _swapExactInputSingle(
        address input,
        address output,
        uint256 amount,
        address recipient,
        Options memory options
    ) internal returns (uint256 amountOut) {
        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({
            tokenIn: input,
            tokenOut: output,
            fee: options.fee,
            recipient: recipient,
            deadline: options.deadline,
            amountIn: amount,
            amountOutMinimum: options.limitAmount,
            sqrtPriceLimitX96: options.sqrtPriceLimitX96
        });
        IERC20(input).safeTransferFrom(msg.sender, address(this), amount);
        _approveERC20TokenIfNecessary(input, address(swapRouter));
        amountOut = swapRouter.exactInputSingle(params);
    }

    function _swapExactOutputSingle(
        address input,
        address output,
        uint256 amount,
        address recipient,
        Options memory options
    ) internal returns (uint256 amountIn) {
        ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter.ExactOutputSingleParams({
            tokenIn: input,
            tokenOut: output,
            fee: options.fee,
            recipient: recipient,
            deadline: options.deadline,
            amountOut: amount,
            amountInMaximum: options.limitAmount,
            sqrtPriceLimitX96: options.sqrtPriceLimitX96
        });
        IERC20(input).safeTransferFrom(msg.sender, address(this), options.limitAmount);
        _approveERC20TokenIfNecessary(input, address(swapRouter));
        amountIn = swapRouter.exactOutputSingle(params);
        if (amountIn < options.limitAmount)
            IERC20(input).safeTransferFrom(address(this), recipient, options.limitAmount - amountIn);
    }

    function _swapExactInputMultihop(
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        Options memory options
    ) internal returns (uint256 amountOut) {
        address input = path[0].token0;
        ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({
            path: _makeMultihopPath(path),
            recipient: recipient,
            deadline: options.deadline,
            amountIn: amount,
            amountOutMinimum: options.limitAmount
        });
        IERC20(input).safeTransferFrom(msg.sender, address(this), amount);
        _approveERC20TokenIfNecessary(input, address(swapRouter));
        amountOut = swapRouter.exactInput(params);
    }

    function _swapExactOutputMultihop(
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        Options memory options
    ) internal returns (uint256 amountIn) {
        address input = path[0].token0;
        ISwapRouter.ExactOutputParams memory params = ISwapRouter.ExactOutputParams({
            path: _reverseBytes(_makeMultihopPath(path)),
            recipient: recipient,
            deadline: options.deadline,
            amountOut: amount,
            amountInMaximum: options.limitAmount
        });
        IERC20(input).safeTransferFrom(msg.sender, address(this), options.limitAmount);
        _approveERC20TokenIfNecessary(input, address(swapRouter));
        amountIn = swapRouter.exactOutput(params);
        if (amountIn < options.limitAmount)
            IERC20(input).safeTransferFrom(address(this), recipient, options.limitAmount - amountIn);
    }

    function _reverseBytes(bytes memory input) internal pure returns (bytes memory output) {
        for (uint256 i = 0; i < input.length; ++i) output[i] = input[input.length - 1 - i];
    }

    function _makeMultihopPath(PathItem[] memory path) internal pure returns (bytes memory) {
        bytes memory result;
        for (uint256 i = 0; i < path.length; ++i) {
            PathItemOptions memory pathItemOptions = abi.decode(path[i].options, (PathItemOptions));
            result = bytes.concat(result, abi.encodePacked(path[i].token0, abi.encodePacked(pathItemOptions.fee)));
        }
        result = bytes.concat(result, abi.encodePacked(path[path.length - 1].token1));
        return result;
    }
}",1457
RealWorld_BA_58_LpIssuerGovernance_RealWord_20240821194205.log,58,LpIssuerGovernance,42329,5308,47637,108.0,0.317805,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/ILpIssuerGovernance.sol"";
import ""./interfaces/ILpIssuer.sol"";
import ""./libraries/CommonLibrary.sol"";
import ""./VaultGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Governance that manages all Lp Issuers params and can deploy a new LpIssuer Vault.
contract LpIssuerGovernance is IERC721Receiver, ILpIssuerGovernance, VaultGovernance {
    uint256 public immutable MAX_PROTOCOL_FEE;
    uint256 public immutable MAX_MANAGEMENT_FEE;
    uint256 public immutable MAX_PERFORMANCE_FEE;

    /// @notice Creates a new contract.
    /// @param internalParams_ Initial Internal Params
    /// @param delayedProtocolParams_ Initial Protocol Params
    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)
        VaultGovernance(internalParams_)
    {
        _delayedProtocolParams = abi.encode(delayedProtocolParams_);
        MAX_PROTOCOL_FEE = 5 * CommonLibrary.DENOMINATOR;
        MAX_MANAGEMENT_FEE = 10 * CommonLibrary.DENOMINATOR;
        MAX_PERFORMANCE_FEE = 50 * CommonLibrary.DENOMINATOR;
    }

    /// @inheritdoc ILpIssuerGovernance
    function delayedProtocolParams() public view returns (DelayedProtocolParams memory) {
        if (_delayedProtocolParams.length == 0) {
            return DelayedProtocolParams({managementFeeChargeDelay: 0});
        }
        return abi.decode(_delayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory) {
        if (_stagedDelayedProtocolParams.length == 0) {
            return DelayedProtocolParams({managementFeeChargeDelay: 0});
        }
        return abi.decode(_stagedDelayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function delayedProtocolPerVaultParams(uint256 nft) external view returns (DelayedProtocolPerVaultParams memory) {
        if (_delayedProtocolPerVaultParams[nft].length == 0) {
            return DelayedProtocolPerVaultParams({protocolFee: 0});
        }
        return abi.decode(_delayedProtocolPerVaultParams[nft], (DelayedProtocolPerVaultParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function stagedDelayedProtocolPerVaultParams(uint256 nft)
        external
        view
        returns (DelayedProtocolPerVaultParams memory)
    {
        if (_stagedDelayedProtocolPerVaultParams[nft].length == 0) {
            return DelayedProtocolPerVaultParams({protocolFee: 0});
        }
        return abi.decode(_stagedDelayedProtocolPerVaultParams[nft], (DelayedProtocolPerVaultParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function stagedDelayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory) {
        if (_stagedDelayedStrategyParams[nft].length == 0) {
            return
                DelayedStrategyParams({
                    strategyTreasury: address(0),
                    strategyPerformanceTreasury: address(0),
                    managementFee: 0,
                    performanceFee: 0
                });
        }
        return abi.decode(_stagedDelayedStrategyParams[nft], (DelayedStrategyParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function delayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory) {
        if (_delayedStrategyParams[nft].length == 0) {
            return
                DelayedStrategyParams({
                    strategyTreasury: address(0),
                    strategyPerformanceTreasury: address(0),
                    managementFee: 0,
                    performanceFee: 0
                });
        }
        return abi.decode(_delayedStrategyParams[nft], (DelayedStrategyParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function strategyParams(uint256 nft) external view returns (StrategyParams memory) {
        if (_strategyParams[nft].length == 0) {
            return StrategyParams({tokenLimitPerAddress: 0});
        }
        return abi.decode(_strategyParams[nft], (StrategyParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function stageDelayedStrategyParams(uint256 nft, DelayedStrategyParams calldata params) external {
        require(params.managementFee <= MAX_MANAGEMENT_FEE, ExceptionsLibrary.MAX_MANAGEMENT_FEE);
        require(params.performanceFee <= MAX_PERFORMANCE_FEE, ExceptionsLibrary.MAX_PERFORMANCE_FEE);
        _stageDelayedStrategyParams(nft, abi.encode(params));
        emit StageDelayedStrategyParams(tx.origin, msg.sender, nft, params, _delayedStrategyParamsTimestamp[nft]);
    }

    /// @inheritdoc ILpIssuerGovernance
    function commitDelayedStrategyParams(uint256 nft) external {
        _commitDelayedStrategyParams(nft);
        emit CommitDelayedStrategyParams(
            tx.origin,
            msg.sender,
            nft,
            abi.decode(_delayedStrategyParams[nft], (DelayedStrategyParams))
        );
    }

    /// @inheritdoc ILpIssuerGovernance
    function stageDelayedProtocolPerVaultParams(uint256 nft, DelayedProtocolPerVaultParams calldata params) external {
        require(params.protocolFee <= MAX_PROTOCOL_FEE, ExceptionsLibrary.MAX_PROTOCOL_FEE);
        _stageDelayedProtocolPerVaultParams(nft, abi.encode(params));
        emit StageDelayedProtocolPerVaultParams(
            tx.origin,
            msg.sender,
            nft,
            params,
            _delayedStrategyParamsTimestamp[nft]
        );
    }

    /// @inheritdoc ILpIssuerGovernance
    function commitDelayedProtocolPerVaultParams(uint256 nft) external {
        _commitDelayedProtocolPerVaultParams(nft);
        emit CommitDelayedProtocolPerVaultParams(
            tx.origin,
            msg.sender,
            nft,
            abi.decode(_delayedProtocolPerVaultParams[nft], (DelayedProtocolPerVaultParams))
        );
    }

    function setStrategyParams(uint256 nft, StrategyParams calldata params) external {
        _setStrategyParams(nft, abi.encode(params));
        emit SetStrategyParams(tx.origin, msg.sender, nft, params);
    }

    /// @inheritdoc ILpIssuerGovernance
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external {
        _stageDelayedProtocolParams(abi.encode(params));
        emit StageDelayedProtocolParams(tx.origin, msg.sender, params, _delayedProtocolParamsTimestamp);
    }

    /// @inheritdoc ILpIssuerGovernance
    function commitDelayedProtocolParams() external {
        _commitDelayedProtocolParams();
        emit CommitDelayedProtocolParams(
            tx.origin,
            msg.sender,
            abi.decode(_delayedProtocolParams, (DelayedProtocolParams))
        );
    }

    /// @notice Required for intermediate vault token transfer in deploy
    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external view returns (bytes4) {
        IVaultRegistry registry = _internalParams.registry;
        require(msg.sender == address(registry), ExceptionsLibrary.NFT_VAULT_REGISTRY);
        return this.onERC721Received.selector;
    }

    /// @notice Deploy a new vault.
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Abi encoded uint256 - an nfts of the gateway subvault. It is required that nft subvault is approved by the caller to this address and that it is a gateway vault
    /// @return vault Address of the new vault
    /// @return nft Nft of the vault in the vault registry
    function deployVault(
        address[] memory vaultTokens,
        bytes memory options,
        address
    ) public override(VaultGovernance, IVaultGovernance) returns (IVault vault, uint256 nft) {
        (uint256 subvaultNft, string memory name, string memory symbol) = abi.decode(
            options,
            (uint256, string, string)
        );
        (vault, nft) = super.deployVault(vaultTokens, abi.encode(name, symbol), msg.sender);
        IVaultRegistry registry = _internalParams.registry;
        ILpIssuer(address(vault)).addSubvault(subvaultNft);
        registry.safeTransferFrom(msg.sender, address(vault), subvaultNft);
    }

    /// @notice Emitted when new DelayedProtocolPerVaultParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedProtocolPerVaultParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedProtocolPerVaultParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedProtocolPerVaultParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that are committed
    event CommitDelayedProtocolPerVaultParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedProtocolPerVaultParams params
    );

    /// @notice Emitted when new DelayedStrategyParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedStrategyParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedStrategyParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedStrategyParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that are committed
    event CommitDelayedStrategyParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedStrategyParams params
    );

    /// @notice Emitted when new StrategyParams are set.
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that are set
    event SetStrategyParams(address indexed origin, address indexed sender, uint256 indexed nft, StrategyParams params);

    /// @notice Emitted when new DelayedProtocolParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedProtocolParams(
        address indexed origin,
        address indexed sender,
        DelayedProtocolParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedProtocolParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that are committed
    event CommitDelayedProtocolParams(address indexed origin, address indexed sender, DelayedProtocolParams params);
}",2468
RealWorld_BA_58_ChiefTrader_RealWord_20240821231420.log,58,ChiefTrader,17469,5791,23260,90.0,0.203165,"// SPDX-License-Identifier: BSL-1.1
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import ""../interfaces/IProtocolGovernance.sol"";
import ""./interfaces/ITrader.sol"";
import ""./interfaces/IChiefTrader.sol"";
import ""./libraries/TraderExceptionsLibrary.sol"";

/// @notice Main contract that allows trading of ERC20 tokens on different Dexes
/// @dev This contract contains several subtraders that can be used for trading ERC20 tokens.
/// Examples of subtraders are UniswapV3, UniswapV2, SushiSwap, Curve, etc.
contract ChiefTrader is ERC165, IChiefTrader, ITrader {
    address public immutable protocolGovernance;
    address[] internal _traders;
    mapping(address => bool) public addedTraders;

    constructor(address _protocolGovernance) {
        protocolGovernance = _protocolGovernance;
    }

    /// @inheritdoc IChiefTrader
    function tradersCount() external view returns (uint256) {
        return _traders.length;
    }

    function getTrader(uint256 _index) external view returns (address) {
        return _traders[_index];
    }

    function traders() external view returns (address[] memory) {
        return _traders;
    }

    /// @inheritdoc IChiefTrader
    function addTrader(address traderAddress) external {
        _requireProtocolAdmin();
        require(traderAddress != address(this), TraderExceptionsLibrary.RECURRENCE_EXCEPTION);
        require(!addedTraders[traderAddress], TraderExceptionsLibrary.TRADER_ALREADY_REGISTERED_EXCEPTION);
        require(ERC165(traderAddress).supportsInterface(type(ITrader).interfaceId));
        require(!ERC165(traderAddress).supportsInterface(type(IChiefTrader).interfaceId));
        _traders.push(traderAddress);
        addedTraders[traderAddress] = true;
        emit AddedTrader(_traders.length - 1, traderAddress);
    }

    /// @inheritdoc ITrader
    function swapExactInput(
        uint256 traderId,
        uint256 amount,
        address,
        PathItem[] calldata path,
        bytes calldata options
    ) external returns (uint256) {
        require(traderId < _traders.length, TraderExceptionsLibrary.TRADER_NOT_FOUND_EXCEPTION);
        _requireAllowedTokens(path);
        address traderAddress = _traders[traderId];
        address recipient = msg.sender;
        return ITrader(traderAddress).swapExactInput(0, amount, recipient, path, options);
    }

    /// @inheritdoc ITrader
    function swapExactOutput(
        uint256 traderId,
        uint256 amount,
        address,
        PathItem[] calldata path,
        bytes calldata options
    ) external returns (uint256) {
        require(traderId < _traders.length, TraderExceptionsLibrary.TRADER_NOT_FOUND_EXCEPTION);
        _requireAllowedTokens(path);
        address traderAddress = _traders[traderId];
        address recipient = msg.sender;
        return ITrader(traderAddress).swapExactOutput(0, amount, recipient, path, options);
    }

    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {
        return (interfaceId == this.supportsInterface.selector ||
            interfaceId == type(ITrader).interfaceId ||
            interfaceId == type(IChiefTrader).interfaceId);
    }

    function _requireAllowedTokens(PathItem[] memory path) internal view {
        IProtocolGovernance pg = IProtocolGovernance(protocolGovernance);
        for (uint256 i = 1; i < path.length; ++i)
            require(
                pg.isAllowedToken(path[i].token0) && pg.isAllowedToken(path[i].token1),
                TraderExceptionsLibrary.TOKEN_NOT_ALLOWED_EXCEPTION
            );
        if (path.length > 0)
            require(pg.isAllowedToken(path[0].token1), TraderExceptionsLibrary.TOKEN_NOT_ALLOWED_EXCEPTION);
    }

    function _requireProtocolAdmin() internal view {
        require(
            IProtocolGovernance(protocolGovernance).isAdmin(msg.sender),
            TraderExceptionsLibrary.PROTOCOL_ADMIN_REQUIRED_EXCEPTION
        );
    }

    event AddedTrader(uint256 indexed traderId, address traderAddress);
}",885
RealWorld_BA_58_ExceptionsLibrary_RealWord_20240821232459.log,58,ExceptionsLibrary,13295,4904,18199,86.0,0.164555,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

/// @notice Exceptions stores project`s smart-contracts exceptions
library ExceptionsLibrary {
    string constant GOVERNANCE_OR_DELEGATE = ""GD"";
    string constant NULL = ""NULL"";
    string constant TIMESTAMP = ""TS"";
    string constant GOVERNANCE_OR_DELEGATE_ADDRESS_ZERO = ""ZMG"";
    string constant EMPTY_PARAMS = ""P0"";
    string constant ADMIN = ""ADM"";
    string constant ADMIN_ADDRESS_ZERO = ""ZADM"";
    string constant VAULT_FACTORY_ADDRESS_ZERO = ""ZVF"";
    string constant APPROVED_OR_OWNER = ""IO"";
    string constant INCONSISTENT_LENGTH = ""L"";
    string constant LIMIT_OVERFLOW = ""LIM"";
    string constant SORTED_AND_UNIQUE = ""SAU"";
    string constant ERC20_INSUFFICIENT_BALANCE = ""ERC20: transfer amount exceeds balance"";
    string constant VALID_PULL_DESTINATION = ""INTRA"";
    string constant CONTRACT_REQUIRED = ""C"";
    string constant SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE = ""VG"";
    string constant REQUIRE_AT_LEAST_ADMIN = ""RST"";
    string constant NULL_OR_NOT_INITIALIZED = ""NA"";
    string constant REDIRECTS_AND_VAULT_TOKENS_LENGTH = ""RL"";
    string constant INITIALIZATION = ""INIT"";
    string constant PERMISSIONLESS_OR_ADMIN = ""POA"";
    string constant TOKEN_NOT_IN_PROJECT = ""TPS"";
    string constant WEIGHTS_LENGTH_IS_ZERO = ""KGT0"";
    string constant AMOUNTS_LENGTH_IS_ZERO = ""NGT0"";
    string constant MATRIX_NOT_RECTANGULAR = ""NV"";
    string constant TOTAL_SUPPLY_IS_ZERO = ""TS0"";
    string constant ALLOWED_TO_CLAIM = ""AC"";
    string constant OTHER_VAULT_TOKENS = ""OWT"";
    string constant SUB_VAULT_INITIALIZED = ""SBIN"";
    string constant SUB_VAULT_LENGTH = ""SBL"";
    string constant NFT_ZERO = ""NFT0"";
    string constant YEARN_VAULTS = ""YV"";
    string constant LOCKED_NFT = ""LCKD"";
    string constant TOKEN_OWNER = ""TO"";
    string constant NOT_VAULT_TOKEN = ""VT"";
    string constant NOT_STRATEGY_TREASURY = ""ST"";
    string constant ZERO_STRATEGY_ADDRESS = ""ZS"";
    string constant NFT_VAULT_REGISTRY = ""NFTVR"";
    string constant ZERO_TOKEN = ""ZT"";
    string constant INITIALIZE_SUB_VAULT = ""INITSV"";
    string constant INITIALIZE_OWNER = ""INITOWN"";
    string constant LIMIT_PER_ADDRESS = ""LPA"";
    string constant MAX_MANAGEMENT_FEE = ""MMF"";
    string constant MAX_PERFORMANCE_FEE = ""MPFF"";
    string constant MAX_PROTOCOL_FEE = ""MPF"";
    string constant TOKEN_LENGTH = ""TL"";
    string constant IO_LENGTH = ""IOL"";
    string constant YEARN_VAULT = ""YV"";
    string constant MAX_GOVERNANCE_DELAY = ""MD"";
    string constant OWNER_VAULT_NFT = ""OWV"";
}",652
RealWorld_BA_58_IYearnVaultGovernance_RealWord_20240821212626.log,58,IYearnVaultGovernance,9959,5522,15481,109.0,0.160235,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./external/yearn/IYearnVaultRegistry.sol"";
import ""./IVaultGovernance.sol"";

interface IYearnVaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param yearnVaultRegistry Reference to Yearn Vault Registry
    struct DelayedProtocolParams {
        IYearnVaultRegistry yearnVaultRegistry;
    }

    /// @notice Determines a corresponding Yearn vault for token
    /// @param token ERC-20 token for the yToken
    /// @return If there's a yToken returns its address, otherwise returns 0
    function yTokenForToken(address token) external view returns (address);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;

    /// @notice Sets the manual override for yToken vaults map
    /// @dev Can only be called by Protocol Admin
    /// @param token ERC-20 token for yToken
    /// @param yToken for ERC-20 token
    function setYTokenForToken(address token, address yToken) external;
}",401
RealWorld_BA_58_IAaveVaultGovernance_RealWord_20240821205502.log,58,IAaveVaultGovernance,7297,5041,12338,81.0,0.137305,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

import ""./external/aave/ILendingPool.sol"";
import ""./IVaultGovernance.sol"";

interface IAaveVaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param lendingPool Reference to Aave LendingPool
    struct DelayedProtocolParams {
        ILendingPool lendingPool;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",270
RealWorld_BA_58_IVaultGovernance_RealWord_20240821205801.log,58,IVaultGovernance,14005,5067,19072,107.0,0.171365,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""./IProtocolGovernance.sol"";
import ""./IVaultRegistry.sol"";
import ""./IVaultFactory.sol"";
import ""./IVault.sol"";

interface IVaultGovernance {
    /// @notice Internal references of the contract.
    /// @param protocolGovernance Reference to Protocol Governance
    /// @param registry Reference to Vault Registry
    struct InternalParams {
        IProtocolGovernance protocolGovernance;
        IVaultRegistry registry;
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @notice Checks if contract is initialized.
    /// @dev Uninitialized contracts cannot deploy vaults
    function initialized() external view returns (bool);

    /// @notice Vault factory for this Vault Governance.
    function factory() external view returns (IVaultFactory);

    /// @notice Timestamp in unix time seconds after which staged Delayed Strategy Params could be committed.
    /// @param nft Nft of the vault
    function delayedStrategyParamsTimestamp(uint256 nft) external view returns (uint256);

    /// @notice Timestamp in unix time seconds after which staged Delayed Protocol Params could be committed.
    function delayedProtocolParamsTimestamp() external view returns (uint256);

    /// @notice Timestamp in unix time seconds after which staged Delayed Protocol Params Per Vault could be committed.
    /// @param nft Nft of the vault
    function delayedProtocolPerVaultParamsTimestamp(uint256 nft) external view returns (uint256);

    /// @notice Timestamp in unix time seconds after which staged Internal Params could be committed.
    function internalParamsTimestamp() external view returns (uint256);

    /// @notice Internal Params of the contract.
    function internalParams() external view returns (InternalParams memory);

    /// @notice Staged new Internal Params.
    /// @dev The Internal Params could be committed after internalParamsTimestamp
    function stagedInternalParams() external view returns (InternalParams memory);

    // -------------------  PUBLIC, MUTATING  -------------------

    /// @notice Instantly initialize governance with factory.
    /// @dev Can only be called by initial deployer and only once.
    /// Required to be called before any function starts working.
    /// @param factory new factory
    function initialize(IVaultFactory factory) external;

    /// @notice Deploy a new vault.
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Reserved additional deploy options. Should be 0x0.
    /// @param owner Owner of the registry vault nft. If it is address(0) then vault will own his own nft
    /// @return vault Address of the new vault
    /// @return nft Nft of the vault in the vault registry
    function deployVault(
        address[] memory vaultTokens,
        bytes memory options,
        address owner
    ) external returns (IVault vault, uint256 nft);

    /// @notice Stage new Internal Params.
    /// @param newParams New Internal Params
    function stageInternalParams(InternalParams memory newParams) external;

    /// @notice Commit staged Internal Params.
    function commitInternalParams() external;
}",669
RealWorld_BA_58_AaveVault_RealWord_20240821222426.log,58,AaveVault,18846,5888,24734,98.0,0.21199,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

import ""./interfaces/external/aave/ILendingPool.sol"";
import ""./interfaces/IAaveVaultGovernance.sol"";
import ""./Vault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Vault that interfaces Aave protocol in the integration layer.
/// @dev Notes:
/// ### TVL
///
/// The TVL of the vault is cached and updated after each deposit withdraw.
/// So essentially `tvl` call doesn't take into account accrued interest / donations to Aave since the
/// last `deposit` / `withdraw`
///
/// ### aTokens
/// aTokens are fixed at the token creation and addresses are taken from Aave Lending Pool.
/// So essentially each aToken is fixed for life of the AaveVault. If the aToken is missing for some vaultToken,
/// the AaveVault cannot be created.
///
/// ### Push / Pull
/// It is assumed that any amounts of tokens can be deposited / withdrawn from Aave.
/// The contract's vaultTokens are fully allowed to Aave Lending Pool.
contract AaveVault is Vault {
    address[] internal _aTokens;
    uint256[] internal _tvls;

    /// @notice Creates a new contract.
    /// @dev Requires that aToken exists for each vaultToken
    /// @param vaultGovernance_ Reference to VaultGovernance for this vault
    /// @param vaultTokens_ ERC20 tokens under Vault management
    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)
        Vault(vaultGovernance_, vaultTokens_)
    {
        _aTokens = new address[](vaultTokens_.length);
        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            address aToken = _getAToken(_vaultTokens[i]);
            require(aToken != address(0), ExceptionsLibrary.ZERO_TOKEN);
            _aTokens[i] = aToken;
            _tvls.push(0);
        }
    }

    /// @inheritdoc Vault
    function tvl() public view override returns (uint256[] memory tokenAmounts) {
        return _tvls;
    }

    /// @notice Update all tvls to current aToken balances.
    function updateTvls() public {
        for (uint256 i = 0; i < _tvls.length; i++) {
            _tvls[i] = IERC20(_aTokens[i]).balanceOf(address(this));
        }
    }

    function _push(uint256[] memory tokenAmounts, bytes memory options)
        internal
        override
        returns (uint256[] memory actualTokenAmounts)
    {
        address[] memory tokens = _vaultTokens;
        uint256 referralCode = 0;
        if (options.length > 0) {
            referralCode = abi.decode(options, (uint256));
        }

        for (uint256 i = 0; i < _aTokens.length; i++) {
            if (tokenAmounts[i] == 0) {
                continue;
            }
            address token = tokens[i];
            _allowTokenIfNecessary(token);
            _lendingPool().deposit(tokens[i], tokenAmounts[i], address(this), uint16(referralCode));
        }
        updateTvls();
        actualTokenAmounts = tokenAmounts;
    }

    function _pull(
        address to,
        uint256[] memory tokenAmounts,
        bytes memory
    ) internal override returns (uint256[] memory actualTokenAmounts) {
        address[] memory tokens = _vaultTokens;
        for (uint256 i = 0; i < _aTokens.length; i++) {
            if ((_tvls[i] == 0) || (tokenAmounts[i] == 0)) {
                continue;
            }
            _lendingPool().withdraw(tokens[i], tokenAmounts[i], to);
        }
        updateTvls();
        actualTokenAmounts = tokenAmounts;
    }

    function _getAToken(address token) internal view returns (address) {
        DataTypes.ReserveData memory data = _lendingPool().getReserveData(token);
        return data.aTokenAddress;
    }

    function _allowTokenIfNecessary(address token) internal {
        if (IERC20(token).allowance(address(this), address(_lendingPool())) < type(uint256).max / 2) {
            IERC20(token).approve(address(_lendingPool()), type(uint256).max);
        }
    }

    function _lendingPool() internal view returns (ILendingPool) {
        return IAaveVaultGovernance(address(_vaultGovernance)).delayedProtocolParams().lendingPool;
    }
}",982
RealWorld_BA_58_ISwapRouter_RealWord_20240821211630.log,58,ISwapRouter,12381,5690,18071,105.0,0.175705,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.7.5;
pragma abicoder v2;

/// @title Router token swapping functionality
/// @notice Functions for swapping tokens via Uniswap V3
interface ISwapRouter {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    /// @notice Swaps `amountIn` of one token for as much as possible of another token
    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata
    /// @return amountOut The amount of the received token
    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);

    struct ExactInputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
    }

    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path
    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata
    /// @return amountOut The amount of the received token
    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);

    struct ExactOutputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
        uint160 sqrtPriceLimitX96;
    }

    /// @notice Swaps as little as possible of one token for `amountOut` of another token
    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata
    /// @return amountIn The amount of the input token
    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);

    struct ExactOutputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
    }

    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)
    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata
    /// @return amountIn The amount of the input token
    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);
}",571
RealWorld_BA_58_LpIssuer_RealWord_20240821222058.log,58,LpIssuer,60096,5614,65710,95.0,0.41276,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""./libraries/CommonLibrary.sol"";
import ""./interfaces/IVault.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/ILpIssuer.sol"";
import ""./DefaultAccessControl.sol"";
import ""./LpIssuerGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Contract that mints and burns LP tokens in exchange for ERC20 liquidity.
contract LpIssuer is IERC721Receiver, ILpIssuer, ERC20, ReentrancyGuard {
    using SafeERC20 for IERC20;
    uint256 private _subvaultNft;
    IVaultGovernance internal _vaultGovernance;
    address[] internal _vaultTokens;
    mapping(address => bool) internal _vaultTokensIndex;
    uint256 private _nft;
    uint256[] private _lpPriceHighWaterMarks;
    uint256[] private _existentials;

    uint256 public lastFeeCharge;

    /// @notice Creates a new contract.
    /// @dev All subvault nfts must be owned by this vault before.
    /// @param vaultGovernance_ Reference to VaultGovernance for this vault
    /// @param vaultTokens_ ERC20 tokens under Vault management
    /// @param name_ Name of the ERC-721 token
    /// @param symbol_ Symbol of the ERC-721 token
    constructor(
        IVaultGovernance vaultGovernance_,
        address[] memory vaultTokens_,
        string memory name_,
        string memory symbol_
    ) ERC20(name_, symbol_) {
        require(CommonLibrary.isSortedAndUnique(vaultTokens_), ExceptionsLibrary.SORTED_AND_UNIQUE);
        _vaultGovernance = vaultGovernance_;
        _vaultTokens = vaultTokens_;
        for (uint256 i = 0; i < vaultTokens_.length; i++) {
            address token = vaultTokens_[i];
            _vaultTokensIndex[token] = true;
            _lpPriceHighWaterMarks.push(0);
            _existentials.push(10**(ERC20(token).decimals() / 2));
        }
        lastFeeCharge = block.timestamp;
    }

    function vaultGovernance() external view returns (IVaultGovernance) {
        return _vaultGovernance;
    }

    function vaultTokens() external view returns (address[] memory) {
        return _vaultTokens;
    }

    function existentials() external view returns (uint256[] memory) {
        return _existentials;
    }

    /// @inheritdoc ILpIssuer
    function subvaultNft() external view returns (uint256) {
        return _subvaultNft;
    }

    function nft() external view returns (uint256) {
        return _nft;
    }

    function initialize(uint256 nft_) external {
        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        require(nft_> 0, ExceptionsLibrary.NFT_ZERO);
        require(_nft == 0, ExceptionsLibrary.INITIALIZATION);
        _nft = nft_;
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        registry.setApprovalForAll(address(registry), true);
    }

    /// @inheritdoc ILpIssuer
    function deposit(uint256[] calldata tokenAmounts, bytes memory options) external nonReentrant {
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        uint256 thisNft = _nft;
        require(thisNft > 0, ExceptionsLibrary.INITIALIZATION);
        require(_subvaultNft > 0, ExceptionsLibrary.INITIALIZE_SUB_VAULT);
        require(registry.ownerOf(thisNft) == address(this), ExceptionsLibrary.INITIALIZE_OWNER);
        IVault subvault = _subvault();
        uint256[] memory existentials_ = _existentials;
        uint256[] memory tvl = subvault.tvl(); //pre-money
        uint256 supply = totalSupply();
        uint256 balanceFactor = CommonLibrary.PRICE_DENOMINATOR;
        if (supply > 0) {
            // This is lpTokens if total supply == CommonLibrary.PRICE_DENOMINATOR
            balanceFactor = _getLpAmount(tvl, tokenAmounts, existentials_, CommonLibrary.PRICE_DENOMINATOR);
        }

        // If with that big supply we don't reveive any lps then it doesn't make sense to continue
        require(balanceFactor > 0, ""BF"");
        uint256[] memory balancedAmounts = new uint256[](tokenAmounts.length);

        // Making sure the proportion between tokenAmounts and tvl are the same
        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            balancedAmounts[i] = _getBalancedAmount(tvl[i], tokenAmounts[i], existentials_[i], balanceFactor, supply);
            _allowTokenIfNecessary(_vaultTokens[i], address(subvault));
            IERC20(_vaultTokens[i]).safeTransferFrom(msg.sender, address(this), balancedAmounts[i]);
        }

        uint256[] memory actualTokenAmounts = subvault.transferAndPush(
            address(this),
            _vaultTokens,
            balancedAmounts,
            options
        );
        uint256 amountToMint = _getLpAmount(tvl, actualTokenAmounts, existentials_, supply);

        require(amountToMint > 0, ""ZLP"");

        require(
            amountToMint + balanceOf(msg.sender) <=
                ILpIssuerGovernance(address(_vaultGovernance)).strategyParams(thisNft).tokenLimitPerAddress,
            ExceptionsLibrary.LIMIT_PER_ADDRESS
        );

        _chargeFees(thisNft, tvl, supply, actualTokenAmounts, amountToMint, false);
        _mint(msg.sender, amountToMint);

        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            if (balancedAmounts[i] > actualTokenAmounts[i]) {
                IERC20(_vaultTokens[i]).safeTransfer(msg.sender, balancedAmounts[i] - actualTokenAmounts[i]);
            }
        }

        emit Deposit(msg.sender, _vaultTokens, actualTokenAmounts, amountToMint);
    }

    /// @inheritdoc ILpIssuer
    function withdraw(
        address to,
        uint256 lpTokenAmount,
        bytes memory options
    ) external nonReentrant {
        uint256 supply = totalSupply();
        require(supply > 0, ExceptionsLibrary.TOTAL_SUPPLY_IS_ZERO);
        uint256[] memory tokenAmounts = new uint256[](_vaultTokens.length);
        uint256[] memory tvl = _subvault().tvl();
        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            tokenAmounts[i] = (lpTokenAmount * tvl[i]) / supply;
        }
        uint256[] memory actualTokenAmounts = _subvault().pull(address(this), _vaultTokens, tokenAmounts, options);
        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            if (actualTokenAmounts[i] == 0) {
                continue;
            }
            IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]);
        }
        _chargeFees(_nft, tvl, supply, actualTokenAmounts, lpTokenAmount, true);
        _burn(msg.sender, lpTokenAmount);
        emit Withdraw(msg.sender, _vaultTokens, actualTokenAmounts, lpTokenAmount);
    }

    /// @inheritdoc ILpIssuer
    function addSubvault(uint256 nft_) external {
        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        require(_subvaultNft == 0, ExceptionsLibrary.SUB_VAULT_INITIALIZED);
        require(nft_ > 0, ExceptionsLibrary.NFT_ZERO);
        _subvaultNft = nft_;
    }

    function onERC721Received(
        address,
        address,
        uint256 tokenId,
        bytes calldata
    ) external nonReentrant returns (bytes4) {
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        require(msg.sender == address(registry), ExceptionsLibrary.NFT_VAULT_REGISTRY);
        registry.lockNft(tokenId);
        return this.onERC721Received.selector;
    }

    function _allowTokenIfNecessary(address token, address to) internal {
        if (IERC20(token).allowance(address(to), address(this)) < type(uint256).max / 2) {
            IERC20(token).approve(address(to), type(uint256).max);
        }
    }

    function _subvault() internal view returns (IVault) {
        return IVault(_vaultGovernance.internalParams().registry.vaultForNft(_subvaultNft));
    }

    /// @dev We don't charge on any deposit / withdraw to save gas.
    /// While this introduce some error, the charge always goes for lower lp token supply (pre-deposit / post-withdraw)
    /// So the error results in slightly lower management fees than in exact case
    function _chargeFees(
        uint256 thisNft,
        uint256[] memory tvls,
        uint256 supply,
        uint256[] memory deltaTvls,
        uint256 deltaSupply,
        bool isWithdraw
    ) internal {
        ILpIssuerGovernance vg = ILpIssuerGovernance(address(_vaultGovernance));
        uint256 elapsed = block.timestamp - lastFeeCharge;
        if (elapsed < vg.delayedProtocolParams().managementFeeChargeDelay) {
            return;
        }
        lastFeeCharge = block.timestamp;
        uint256 baseSupply = supply;
        if (isWithdraw) {
            baseSupply = 0;
            if (supply > deltaSupply) {
                baseSupply = supply - deltaSupply;
            }
        }

        if (baseSupply == 0) {
            for (uint256 i = 0; i < tvls.length; i++) {
                _lpPriceHighWaterMarks[i] = (deltaTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / deltaSupply;
            }
            return;
        }

        uint256[] memory baseTvls = new uint256[](tvls.length);
        for (uint256 i = 0; i < baseTvls.length; i++) {
            if (isWithdraw) {
                baseTvls[i] = tvls[i] - deltaTvls[i];
            } else {
                baseTvls[i] = tvls[i];
            }
        }

        ILpIssuerGovernance.DelayedStrategyParams memory strategyParams = vg.delayedStrategyParams(thisNft);
        if (strategyParams.managementFee > 0) {
            uint256 toMint = (strategyParams.managementFee * baseSupply * elapsed) /
                (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);
            _mint(strategyParams.strategyTreasury, toMint);
            emit ManagementFeesCharged(strategyParams.strategyTreasury, strategyParams.managementFee, toMint);
        }
        uint256 protocolFee = vg.delayedProtocolPerVaultParams(thisNft).protocolFee;
        if (protocolFee > 0) {
            address treasury = vg.internalParams().protocolGovernance.protocolTreasury();
            uint256 toMint = (protocolFee * baseSupply * elapsed) / (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);
            _mint(treasury, toMint);
            emit ProtocolFeesCharged(treasury, protocolFee, toMint);
        }
        uint256 performanceFee = strategyParams.performanceFee;
        uint256[] memory hwms = _lpPriceHighWaterMarks;
        if (performanceFee > 0) {
            uint256 minLpPriceFactor = type(uint256).max;
            for (uint256 i = 0; i < baseTvls.length; i++) {
                uint256 hwm = hwms[i];
                uint256 lpPrice = (baseTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / baseSupply;
                if (lpPrice > hwm) {
                    uint256 delta = (lpPrice * CommonLibrary.DENOMINATOR) / hwm;
                    if (delta < minLpPriceFactor) {
                        minLpPriceFactor = delta;
                    }
                } else {
                    // not eligible for performance fees
                    return;
                }
            }
            for (uint256 i = 0; i < tvls.length; i++) {
                _lpPriceHighWaterMarks[i] += (hwms[i] * minLpPriceFactor) / CommonLibrary.DENOMINATOR;
            }
            address treasury = strategyParams.strategyPerformanceTreasury;
            uint256 toMint = (baseSupply * minLpPriceFactor) / CommonLibrary.DENOMINATOR;
            _mint(treasury, toMint);
            emit PerformanceFeesCharged(treasury, performanceFee, toMint);
        }
    }

    function _getLpAmount(
        uint256[] memory tvl,
        uint256[] memory amounts,
        uint256[] memory existentials_,
        uint256 supply
    ) internal pure returns (uint256 lpAmount) {
        lpAmount = 0;
        if (supply == 0) {
            // On init lpToken = max(tokenAmounts)
            for (uint256 i = 0; i < tvl.length; i++) {
                if (amounts[i] > lpAmount) {
                    lpAmount = amounts[i];
                }
            }
            return lpAmount;
        }
        for (uint256 i = 0; i < tvl.length; i++) {
            if (amounts[i] <= existentials_[i]) {
                // skip existential deposits for lp share calculation
                continue;
            }
            uint256 tokenLpAmount = (amounts[i] * supply) / tvl[i];
            // take min of meaningful tokenLp amounts
            if ((tokenLpAmount < lpAmount) || (lpAmount == 0)) {
                lpAmount = tokenLpAmount;
            }
        }
    }

    function _getBalancedAmount(
        uint256 tvl,
        uint256 amount,
        uint256 existential,
        uint256 balanceFactor,
        uint256 supply
    ) internal pure returns (uint256) {
        if (supply == 0) {
            // skip normalization on init
            return amount;
        }
        if (amount < existential) {
            // avoid putting small amounts as it can introduce unnecessary harsh errors
            // one should provide amount > existential deposit each time tvl is not 0
            require(tvl == 0, ""PN"");
            return 0;
        }
        // normalize amount
        uint256 res = (tvl * balanceFactor) / CommonLibrary.PRICE_DENOMINATOR;
        if (res > amount) {
            res = amount;
        }
        return res;
    }

    /// @notice Emitted when management fees are charged
    /// @param treasury Treasury receiver of the fee
    /// @param feeRate Fee percent applied denominated in 10 ** 9
    /// @param amount Amount of lp token minted
    event ManagementFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);

    /// @notice Emitted when protocol fees are charged
    /// @param treasury Treasury receiver of the fee
    /// @param feeRate Fee percent applied denominated in 10 ** 9
    /// @param amount Amount of lp token minted
    event ProtocolFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);

    /// @notice Emitted when performance fees are charged
    /// @param treasury Treasury receiver of the fee
    /// @param feeRate Fee percent applied denominated in 10 ** 9
    /// @param amount Amount of lp token minted
    event PerformanceFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);

    /// @notice Emitted when liquidity is deposited
    /// @param from The source address for the liquidity
    /// @param tokens ERC20 tokens deposited
    /// @param actualTokenAmounts Token amounts deposited
    /// @param lpTokenMinted LP tokens received by the liquidity provider
    event Deposit(address indexed from, address[] tokens, uint256[] actualTokenAmounts, uint256 lpTokenMinted);

    /// @notice Emitted when liquidity is withdrawn
    /// @param from The source address for the liquidity
    /// @param tokens ERC20 tokens withdrawn
    /// @param actualTokenAmounts Token amounts withdrawn
    /// @param lpTokenBurned LP tokens burned from the liquidity provider
    event Withdraw(address indexed from, address[] tokens, uint256[] actualTokenAmounts, uint256 lpTokenBurned);
}",3633
RealWorld_BA_58_IUniswapV3PoolState_RealWord_20240821211817.log,58,IUniswapV3PoolState,26130,5382,31512,101.0,0.23829,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title Pool state that can change
/// @notice These methods compose the pool's state, and can change with any frequency including multiple times
/// per transaction
interface IUniswapV3PoolState {
    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
    /// when accessed externally.
    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
    /// boundary.
    /// observationIndex The index of the last oracle observation that was written,
    /// observationCardinality The current maximum number of observations stored in the pool,
    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
    /// feeProtocol The protocol fee for both tokens of the pool.
    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
    /// unlocked Whether the pool is currently locked to reentrancy
    function slot0()
        external
        view
        returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        );

    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
    /// @dev This value can overflow the uint256
    function feeGrowthGlobal0X128() external view returns (uint256);

    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
    /// @dev This value can overflow the uint256
    function feeGrowthGlobal1X128() external view returns (uint256);

    /// @notice The amounts of token0 and token1 that are owed to the protocol
    /// @dev Protocol fees will never exceed uint128 max in either token
    function protocolPerformanceFees() external view returns (uint128 token0, uint128 token1);

    /// @notice The currently in range liquidity available to the pool
    /// @dev This value has no relationship to the total liquidity across all ticks
    function liquidity() external view returns (uint128);

    /// @notice Look up information about a specific tick in the pool
    /// @param tick The tick to look up
    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or
    /// tick upper,
    /// liquidityNet how much liquidity changes when the pool price crosses the tick,
    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,
    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,
    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick
    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,
    /// secondsOutside the seconds spent on the other side of the tick from the current tick,
    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.
    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.
    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for
    /// a specific position.
    function ticks(int24 tick)
        external
        view
        returns (
            uint128 liquidityGross,
            int128 liquidityNet,
            uint256 feeGrowthOutside0X128,
            uint256 feeGrowthOutside1X128,
            int56 tickCumulativeOutside,
            uint160 secondsPerLiquidityOutsideX128,
            uint32 secondsOutside,
            bool initialized
        );

    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information
    function tickBitmap(int16 wordPosition) external view returns (uint256);

    /// @notice Returns the information about a position by the position's key
    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
    /// @return _liquidity The amount of liquidity in the position,
    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
    function positions(bytes32 key)
        external
        view
        returns (
            uint128 _liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );

    /// @notice Returns data about a specific observation index
    /// @param index The element of the observations array to fetch
    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time
    /// ago, rather than at a specific index in the array.
    /// @return blockTimestamp The timestamp of the observation,
    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,
    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,
    /// Returns initialized whether the observation has been initialized and the values are safe to use
    function observations(uint256 index)
        external
        view
        returns (
            uint32 blockTimestamp,
            int56 tickCumulative,
            uint160 secondsPerLiquidityCumulativeX128,
            bool initialized
        );
}",1445
RealWorld_BA_58_TickMath_RealWord_20240821232806.log,58,TickMath,50551,5089,55640,112.0,0.354535,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title Math library for computing sqrt prices from ticks and vice versa
/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports
/// prices between 2**-128 and 2**128
library TickMath {
    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128
    int24 internal constant MIN_TICK = -887272;
    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128
    int24 internal constant MAX_TICK = -MIN_TICK;

    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
    uint160 internal constant MIN_SQRT_RATIO = 4295128739;
    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)
    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;

    /// @notice Calculates sqrt(1.0001^tick) * 2^96
    /// @dev Throws if |tick| > max tick
    /// @param tick The input tick for the above formula
    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
    /// at the given tick
    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
        // diff: original require(absTick <= uint256(MAX_TICK), ""T"");
        require(absTick <= uint256(int256(MAX_TICK)), ""T"");

        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;

        if (tick > 0) ratio = type(uint256).max / ratio;

        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint
        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent
        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
    }

    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio
    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may
    /// ever return.
    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96
    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio
    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
        // second inequality must be < because the price can never reach the price at the max tick
        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, ""R"");
        uint256 ratio = uint256(sqrtPriceX96) << 32;

        uint256 r = ratio;
        uint256 msb = 0;

        assembly {
            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(5, gt(r, 0xFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(4, gt(r, 0xFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(3, gt(r, 0xFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(2, gt(r, 0xF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(1, gt(r, 0x3))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := gt(r, 0x1)
            msb := or(msb, f)
        }

        if (msb >= 128) r = ratio >> (msb - 127);
        else r = ratio << (127 - msb);

        int256 log_2 = (int256(msb) - 128) << 64;

        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(63, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(62, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(61, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(60, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(59, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(58, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(57, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(56, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(55, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(54, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(53, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(52, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(51, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(50, f))
        }

        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number

        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);

        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
    }
}",2878
RealWorld_BA_58_LiquidityAmounts_RealWord_20240821232627.log,58,LiquidityAmounts,30364,5594,35958,96.0,0.2637,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

import ""./FullMath.sol"";
import ""./FixedPoint96.sol"";

/// @title Liquidity amount functions
/// @notice Provides functions for computing liquidity amounts from token amounts and prices
library LiquidityAmounts {
    /// @notice Downcasts uint256 to uint128
    /// @param x The uint258 to be downcasted
    /// @return y The passed value, downcasted to uint128
    function toUint128(uint256 x) private pure returns (uint128 y) {
        require((y = uint128(x)) == x);
    }

    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range
    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param amount0 The amount0 being sent in
    /// @return liquidity The amount of returned liquidity
    function getLiquidityForAmount0(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint256 amount0
    ) internal pure returns (uint128 liquidity) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
        uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);
        return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));
    }

    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range
    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param amount1 The amount1 being sent in
    /// @return liquidity The amount of returned liquidity
    function getLiquidityForAmount1(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint256 amount1
    ) internal pure returns (uint128 liquidity) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
        return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));
    }

    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current
    /// pool prices and the prices at the tick boundaries
    /// @param sqrtRatioX96 A sqrt price representing the current pool prices
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param amount0 The amount of token0 being sent in
    /// @param amount1 The amount of token1 being sent in
    /// @return liquidity The maximum amount of liquidity received
    function getLiquidityForAmounts(
        uint160 sqrtRatioX96,
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint256 amount0,
        uint256 amount1
    ) internal pure returns (uint128 liquidity) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);

        if (sqrtRatioX96 <= sqrtRatioAX96) {
            liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
        } else if (sqrtRatioX96 < sqrtRatioBX96) {
            uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);
            uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);

            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
        } else {
            liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);
        }
    }

    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param liquidity The liquidity being valued
    /// @return amount0 The amount of token0
    function getAmount0ForLiquidity(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint128 liquidity
    ) internal pure returns (uint256 amount0) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);

        return
            FullMath.mulDiv(
                uint256(liquidity) << FixedPoint96.RESOLUTION,
                sqrtRatioBX96 - sqrtRatioAX96,
                sqrtRatioBX96
            ) / sqrtRatioAX96;
    }

    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param liquidity The liquidity being valued
    /// @return amount1 The amount of token1
    function getAmount1ForLiquidity(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint128 liquidity
    ) internal pure returns (uint256 amount1) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);

        return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
    }

    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current
    /// pool prices and the prices at the tick boundaries
    /// @param sqrtRatioX96 A sqrt price representing the current pool prices
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param liquidity The liquidity being valued
    /// @return amount0 The amount of token0
    /// @return amount1 The amount of token1
    function getAmountsForLiquidity(
        uint160 sqrtRatioX96,
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint128 liquidity
    ) internal pure returns (uint256 amount0, uint256 amount1) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);

        if (sqrtRatioX96 <= sqrtRatioAX96) {
            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
        } else if (sqrtRatioX96 < sqrtRatioBX96) {
            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);
            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);
        } else {
            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
        }
    }
}",1688
RealWorld_BA_58_IUniswapV3Pool_RealWord_20240821215738.log,58,IUniswapV3Pool,5230,4183,9413,82.0,0.10981,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

import './pool/IUniswapV3PoolImmutables.sol';
import './pool/IUniswapV3PoolState.sol';

/// @title The interface for a Uniswap V3 Pool
/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform
/// to the ERC20 specification
/// @dev The pool interface is broken up into many smaller pieces
interface IUniswapV3Pool is
    IUniswapV3PoolImmutables,
    IUniswapV3PoolState
{

}",142
RealWorld_BA_58_INonfungiblePositionManager_RealWord_20240821211450.log,58,INonfungiblePositionManager,32516,5626,38142,98.0,0.2751,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.9;
pragma abicoder v2;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""./IPeripheryImmutableState.sol"";

/// @title Non-fungible token for positions
/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred
/// and authorized.
interface INonfungiblePositionManager is IPeripheryImmutableState, IERC721 {
    /// @notice Emitted when liquidity is increased for a position NFT
    /// @dev Also emitted when a token is minted
    /// @param tokenId The ID of the token for which liquidity was increased
    /// @param liquidity The amount by which liquidity for the NFT position was increased
    /// @param amount0 The amount of token0 that was paid for the increase in liquidity
    /// @param amount1 The amount of token1 that was paid for the increase in liquidity
    event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
    /// @notice Emitted when liquidity is decreased for a position NFT
    /// @param tokenId The ID of the token for which liquidity was decreased
    /// @param liquidity The amount by which liquidity for the NFT position was decreased
    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity
    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity
    event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
    /// @notice Emitted when tokens are collected for a position NFT
    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior
    /// @param tokenId The ID of the token for which underlying tokens were collected
    /// @param recipient The address of the account that received the collected tokens
    /// @param amount0 The amount of token0 owed to the position that was collected
    /// @param amount1 The amount of token1 owed to the position that was collected
    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);

    /// @notice Returns the position information associated with a given token ID.
    /// @dev Throws if the token ID is not valid.
    /// @param tokenId The ID of the token that represents the position
    /// @return nonce The nonce for permits
    /// @return operator The address that is approved for spending
    /// @return token0 The address of the token0 for a specific pool
    /// @return token1 The address of the token1 for a specific pool
    /// @return fee The fee associated with the pool
    /// @return tickLower The lower end of the tick range for the position
    /// @return tickUpper The higher end of the tick range for the position
    /// @return liquidity The liquidity of the position
    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position
    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position
    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation
    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation
    function positions(uint256 tokenId)
        external
        view
        returns (
            uint96 nonce,
            address operator,
            address token0,
            address token1,
            uint24 fee,
            int24 tickLower,
            int24 tickUpper,
            uint128 liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );

    struct MintParams {
        address token0;
        address token1;
        uint24 fee;
        int24 tickLower;
        int24 tickUpper;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        address recipient;
        uint256 deadline;
    }

    /// @notice Creates a new position wrapped in a NFT
    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized
    /// a method does not exist, i.e. the pool is assumed to be initialized.
    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata
    /// @return tokenId The ID of the token that represents the minted position
    /// @return liquidity The amount of liquidity for this position
    /// @return amount0 The amount of token0
    /// @return amount1 The amount of token1
    function mint(MintParams calldata params)
        external
        payable
        returns (
            uint256 tokenId,
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        );

    struct IncreaseLiquidityParams {
        uint256 tokenId;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`
    /// @param params tokenId The ID of the token for which liquidity is being increased,
    /// amount0Desired The desired amount of token0 to be spent,
    /// amount1Desired The desired amount of token1 to be spent,
    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,
    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,
    /// deadline The time by which the transaction must be included to effect the change
    /// @return liquidity The new liquidity amount as a result of the increase
    /// @return amount0 The amount of token0 to acheive resulting liquidity
    /// @return amount1 The amount of token1 to acheive resulting liquidity
    function increaseLiquidity(IncreaseLiquidityParams calldata params)
        external
        payable
        returns (
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        );

    struct DecreaseLiquidityParams {
        uint256 tokenId;
        uint128 liquidity;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    /// @notice Decreases the amount of liquidity in a position and accounts it to the position
    /// @param params tokenId The ID of the token for which liquidity is being decreased,
    /// amount The amount by which liquidity will be decreased,
    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,
    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,
    /// deadline The time by which the transaction must be included to effect the change
    /// @return amount0 The amount of token0 accounted to the position's tokens owed
    /// @return amount1 The amount of token1 accounted to the position's tokens owed
    function decreaseLiquidity(DecreaseLiquidityParams calldata params)
        external
        payable
        returns (uint256 amount0, uint256 amount1);

    struct CollectParams {
        uint256 tokenId;
        address recipient;
        uint128 amount0Max;
        uint128 amount1Max;
    }

    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient
    /// @param params tokenId The ID of the NFT for which tokens are being collected,
    /// recipient The account that should receive the tokens,
    /// amount0Max The maximum amount of token0 to collect,
    /// amount1Max The maximum amount of token1 to collect
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);

    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens
    /// must be collected first.
    /// @param tokenId The ID of the token that is being burned
    function burn(uint256 tokenId) external payable;
}",1833
RealWorld_BA_58_LpIssuer_RealWord_20240821192326.log,58,LpIssuer,60081,5778,65859,99.0,0.415965,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""./libraries/CommonLibrary.sol"";
import ""./interfaces/IVault.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/ILpIssuer.sol"";
import ""./DefaultAccessControl.sol"";
import ""./LpIssuerGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Contract that mints and burns LP tokens in exchange for ERC20 liquidity.
contract LpIssuer is IERC721Receiver, ILpIssuer, ERC20, ReentrancyGuard {
    using SafeERC20 for IERC20;
    uint256 private _subvaultNft;
    IVaultGovernance internal _vaultGovernance;
    address[] internal _vaultTokens;
    mapping(address => bool) internal _vaultTokensIndex;
    uint256 private _nft;
    uint256[] private _lpPriceHighWaterMarks;
    uint256[] private _existentials;

    uint256 public lastFeeCharge;

    /// @notice Creates a new contract.
    /// @dev All subvault nfts must be owned by this vault before.
    /// @param vaultGovernance_ Reference to VaultGovernance for this vault
    /// @param vaultTokens_ ERC20 tokens under Vault management
    /// @param name_ Name of the ERC-721 token
    /// @param symbol_ Symbol of the ERC-721 token
    constructor(
        IVaultGovernance vaultGovernance_,
        address[] memory vaultTokens_,
        string memory name_,
        string memory symbol_
    ) ERC20(name_, symbol_) {
        require(CommonLibrary.isSortedAndUnique(vaultTokens_), ExceptionsLibrary.SORTED_AND_UNIQUE);
        _vaultGovernance = vaultGovernance_;
        _vaultTokens = vaultTokens_;
        for (uint256 i = 0; i < vaultTokens_.length; i++) {
            address token = vaultTokens_[i];
            _vaultTokensIndex[token] = true;
            _lpPriceHighWaterMarks.push(0);
            _existentials.push(10**(ERC20(token).decimals() / 2));
        }
        lastFeeCharge = block.timestamp;
    }

    function vaultGovernance() external view returns (IVaultGovernance) {
        return _vaultGovernance;
    }

    function vaultTokens() external view returns (address[] memory) {
        return _vaultTokens;
    }

    function existentials() external view returns (uint256[] memory) {
        return _existentials;
    }

    /// @inheritdoc ILpIssuer
    function subvaultNft() external view returns (uint256) {
        return _subvaultNft;
    }

    function nft() external view returns (uint256) {
        return _nft;
    }

    function initialize(uint256 nft_) external {
        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        require(nft_> 0, ExceptionsLibrary.NFT_ZERO);
        require(_nft == 0, ExceptionsLibrary.INITIALIZATION);
        _nft = nft_;
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        registry.setApprovalForAll(address(registry), true);
    }

    /// @inheritdoc ILpIssuer
    function deposit(uint256[] calldata tokenAmounts, bytes memory options) external nonReentrant {
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        uint256 thisNft = _nft;
        require(thisNft > 0, ExceptionsLibrary.INITIALIZATION);
        require(_subvaultNft > 0, ExceptionsLibrary.INITIALIZE_SUB_VAULT);
        require(registry.ownerOf(thisNft) == address(this), ExceptionsLibrary.INITIALIZE_OWNER);
        IVault subvault = _subvault();
        uint256[] memory existentials_ = _existentials;
        uint256[] memory tvl = subvault.tvl(); //pre-money
        uint256 supply = totalSupply();
        uint256 balanceFactor = CommonLibrary.PRICE_DENOMINATOR;
        if (supply > 0) {
            // This is lpTokens if total supply == CommonLibrary.PRICE_DENOMINATOR
            balanceFactor = _getLpAmount(tvl, tokenAmounts, existentials_, CommonLibrary.PRICE_DENOMINATOR);
        }

        // If with that big supply we don't reveive any lps then it doesn't make sense to continue
        require(balanceFactor > 0, ""BF"");
        uint256[] memory balancedAmounts = new uint256[](tokenAmounts.length);

        // Making sure the proportion between tokenAmounts and tvl are the same
        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            balancedAmounts[i] = _getBalancedAmount(tvl[i], tokenAmounts[i], existentials_[i], balanceFactor, supply);
            _allowTokenIfNecessary(_vaultTokens[i], address(subvault));
            IERC20(_vaultTokens[i]).safeTransferFrom(msg.sender, address(this), balancedAmounts[i]);
        }

        uint256[] memory actualTokenAmounts = subvault.transferAndPush(
            address(this),
            _vaultTokens,
            balancedAmounts,
            options
        );
        uint256 amountToMint = _getLpAmount(tvl, actualTokenAmounts, existentials_, supply);

        require(amountToMint > 0, ""ZLP"");

        require(
            amountToMint + balanceOf(msg.sender) <=
                ILpIssuerGovernance(address(_vaultGovernance)).strategyParams(thisNft).tokenLimitPerAddress,
            ExceptionsLibrary.LIMIT_PER_ADDRESS
        );

        _chargeFees(thisNft, tvl, supply, actualTokenAmounts, amountToMint, false);
        _mint(msg.sender, amountToMint);

        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            if (balancedAmounts[i] > actualTokenAmounts[i]) {
                IERC20(_vaultTokens[i]).safeTransfer(msg.sender, balancedAmounts[i] - actualTokenAmounts[i]);
            }
        }

        emit Deposit(msg.sender, _vaultTokens, actualTokenAmounts, amountToMint);
    }

    /// @inheritdoc ILpIssuer
    function withdraw(
        address to,
        uint256 lpTokenAmount,
        bytes memory options
    ) external nonReentrant {
        uint256 supply = totalSupply();
        require(supply > 0, ExceptionsLibrary.TOTAL_SUPPLY_IS_ZERO);
        uint256[] memory tokenAmounts = new uint256[](_vaultTokens.length);
        uint256[] memory tvl = _subvault().tvl();
        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            tokenAmounts[i] = (lpTokenAmount * tvl[i]) / supply;
        }
        uint256[] memory actualTokenAmounts = _subvault().pull(address(this), _vaultTokens, tokenAmounts, options);
        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            if (actualTokenAmounts[i] == 0) {
                continue;
            }
            IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]);
        }
        _chargeFees(_nft, tvl, supply, actualTokenAmounts, lpTokenAmount, true);
        _burn(msg.sender, lpTokenAmount);
        emit Withdraw(msg.sender, _vaultTokens, actualTokenAmounts, lpTokenAmount);
    }

    /// @inheritdoc ILpIssuer
    function addSubvault(uint256 nft_) external {
        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        require(_subvaultNft == 0, ExceptionsLibrary.SUB_VAULT_INITIALIZED);
        require(nft_ > 0, ExceptionsLibrary.NFT_ZERO);
        _subvaultNft = nft_;
    }

    function onERC721Received(
        address,
        address,
        uint256 tokenId,
        bytes calldata
    ) external nonReentrant returns (bytes4) {
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        require(msg.sender == address(registry), ExceptionsLibrary.NFT_VAULT_REGISTRY);
        registry.lockNft(tokenId);
        return this.onERC721Received.selector;
    }

    function _allowTokenIfNecessary(address token, address to) internal {
        if (IERC20(token).allowance(address(to), address(this)) < type(uint256).max / 2) {
            IERC20(token).approve(address(to), type(uint256).max);
        }
    }

    function _subvault() internal view returns (IVault) {
        return IVault(_vaultGovernance.internalParams().registry.vaultForNft(_subvaultNft));
    }

    /// @dev We don't charge on any deposit / withdraw to save gas.
    /// While this introduce some error, the charge always goes for lower lp token supply (pre-deposit / post-withdraw)
    /// So the error results in slightly lower management fees than in exact case
    function _chargeFees(
        uint256 thisNft,
        uint256[] memory tvls,
        uint256 supply,
        uint256[] memory deltaTvls,
        uint256 deltaSupply,
        bool isWithdraw
    ) internal {
        ILpIssuerGovernance vg = ILpIssuerGovernance(address(_vaultGovernance));
        uint256 elapsed = block.timestamp - lastFeeCharge;
        if (elapsed < vg.delayedProtocolParams().managementFeeChargeDelay) {
            return;
        }
        lastFeeCharge = block.timestamp;
        uint256 baseSupply = supply;
        if (isWithdraw) {
            baseSupply = 0;
            if (supply > deltaSupply) {
                baseSupply = supply - deltaSupply;
            }
        }

        if (baseSupply == 0) {
            for (uint256 i = 0; i < tvls.length; i++) {
                _lpPriceHighWaterMarks[i] = (deltaTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / deltaSupply;
            }
            return;
        }

        uint256[] memory baseTvls = new uint256[](tvls.length);
        for (uint256 i = 0; i < baseTvls.length; i++) {
            if (isWithdraw) {
                baseTvls[i] = tvls[i] - deltaTvls[i];
            } else {
                baseTvls[i] = tvls[i];
            }
        }

        ILpIssuerGovernance.DelayedStrategyParams memory strategyParams = vg.delayedStrategyParams(thisNft);
        if (strategyParams.managementFee > 0) {
            uint256 toMint = (strategyParams.managementFee * baseSupply * elapsed) /
                (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);
            _mint(strategyParams.strategyTreasury, toMint);
            emit ManagementFeesCharged(strategyParams.strategyTreasury, strategyParams.managementFee, toMint);
        }
        uint256 protocolFee = vg.delayedProtocolPerVaultParams(thisNft).protocolFee;
        if (protocolFee > 0) {
            address treasury = vg.internalParams().protocolGovernance.protocolTreasury();
            uint256 toMint = (protocolFee * baseSupply * elapsed) / (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);
            _mint(treasury, toMint);
            emit ProtocolFeesCharged(treasury, protocolFee, toMint);
        }
        uint256 performanceFee = strategyParams.performanceFee;
        uint256[] memory hwms = _lpPriceHighWaterMarks;
        if (performanceFee > 0) {
            uint256 minLpPriceFactor = type(uint256).max;
            for (uint256 i = 0; i < baseTvls.length; i++) {
                uint256 hwm = hwms[i];
                uint256 lpPrice = (baseTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / baseSupply;
                if (lpPrice > hwm) {
                    uint256 delta = (lpPrice * CommonLibrary.DENOMINATOR) / hwm;
                    if (delta < minLpPriceFactor) {
                        minLpPriceFactor = delta;
                    }
                } else {
                    // not eligible for performance fees
                    return;
                }
            }
            for (uint256 i = 0; i < tvls.length; i++) {
                _lpPriceHighWaterMarks[i] += (hwms[i] * minLpPriceFactor) / CommonLibrary.DENOMINATOR;
            }
            address treasury = strategyParams.strategyPerformanceTreasury;
            uint256 toMint = (baseSupply * minLpPriceFactor) / CommonLibrary.DENOMINATOR;
            _mint(treasury, toMint);
            emit PerformanceFeesCharged(treasury, performanceFee, toMint);
        }
    }

    function _getLpAmount(
        uint256[] memory tvl,
        uint256[] memory amounts,
        uint256[] memory existentials_,
        uint256 supply
    ) internal pure returns (uint256 lpAmount) {
        lpAmount = 0;
        if (supply == 0) {
            // On init lpToken = max(tokenAmounts)
            for (uint256 i = 0; i < tvl.length; i++) {
                if (amounts[i] > lpAmount) {
                    lpAmount = amounts[i];
                }
            }
            return lpAmount;
        }
        for (uint256 i = 0; i < tvl.length; i++) {
            if (amounts[i] <= existentials_[i]) {
                // skip existential deposits for lp share calculation
                continue;
            }
            uint256 tokenLpAmount = (amounts[i] * supply) / tvl[i];
            // take min of meaningful tokenLp amounts
            if ((tokenLpAmount < lpAmount) || (lpAmount == 0)) {
                lpAmount = tokenLpAmount;
            }
        }
    }

    function _getBalancedAmount(
        uint256 tvl,
        uint256 amount,
        uint256 existential,
        uint256 balanceFactor,
        uint256 supply
    ) internal pure returns (uint256) {
        if (supply == 0) {
            // skip normalization on init
            return amount;
        }
        if (amount < existential) {
            // avoid putting small amounts as it can introduce unnecessary harsh errors
            // one should provide amount > existential deposit each time tvl is not 0
            require(tvl == 0, ""PN"");
            return 0;
        }
        // normalize amount
        uint256 res = (tvl * balanceFactor) / CommonLibrary.PRICE_DENOMINATOR;
        if (res > amount) {
            res = amount;
        }
        return res;
    }

    /// @notice Emitted when management fees are charged
    /// @param treasury Treasury receiver of the fee
    /// @param feeRate Fee percent applied denominated in 10 ** 9
    /// @param amount Amount of lp token minted
    event ManagementFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);

    /// @notice Emitted when protocol fees are charged
    /// @param treasury Treasury receiver of the fee
    /// @param feeRate Fee percent applied denominated in 10 ** 9
    /// @param amount Amount of lp token minted
    event ProtocolFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);

    /// @notice Emitted when performance fees are charged
    /// @param treasury Treasury receiver of the fee
    /// @param feeRate Fee percent applied denominated in 10 ** 9
    /// @param amount Amount of lp token minted
    event PerformanceFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);

    /// @notice Emitted when liquidity is deposited
    /// @param from The source address for the liquidity
    /// @param tokens ERC20 tokens deposited
    /// @param actualTokenAmounts Token amounts deposited
    /// @param lpTokenMinted LP tokens received by the liquidity provider
    event Deposit(address indexed from, address[] tokens, uint256[] actualTokenAmounts, uint256 lpTokenMinted);

    /// @notice Emitted when liquidity is withdrawn
    /// @param from The source address for the liquidity
    /// @param tokens ERC20 tokens withdrawn
    /// @param actualTokenAmounts Token amounts withdrawn
    /// @param lpTokenBurned LP tokens burned from the liquidity provider
    event Withdraw(address indexed from, address[] tokens, uint256[] actualTokenAmounts, uint256 lpTokenBurned);
}",3633
RealWorld_BA_58_IUniswapV3Pool_RealWord_20240821211317.log,58,IUniswapV3Pool,5264,4368,9632,91.0,0.11368,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

import './pool/IUniswapV3PoolImmutables.sol';
import './pool/IUniswapV3PoolState.sol';

/// @title The interface for a Uniswap V3 Pool
/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform
/// to the ERC20 specification
/// @dev The pool interface is broken up into many smaller pieces
interface IUniswapV3Pool is
    IUniswapV3PoolImmutables,
    IUniswapV3PoolState
{

}",142
RealWorld_BA_58_IVault_RealWord_20240821212953.log,58,IVault,23439,6041,29480,120.0,0.238015,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";

interface IVault {
    /// @notice VaultRegistry NFT for this vault
    function nft() external view returns (uint256);

    /// @notice Address of the Vault Governance for this contract.
    function vaultGovernance() external view returns (IVaultGovernance);

    /// @notice ERC20 tokens under Vault management.
    function vaultTokens() external view returns (address[] memory);

    /// @notice Total value locked for this contract.
    /// @dev Generally it is the underlying token value of this contract in some
    /// other DeFi protocol. For example, for USDC Yearn Vault this would be total USDC balance that could be withdrawn for Yearn to this contract.
    /// @return tokenAmounts Total available balances for multiple tokens (nth tokenAmount corresponds to nth token in vaultTokens)
    function tvl() external view returns (uint256[] memory tokenAmounts);

    /// @notice Initialize contract with vault nft
    /// @param nft VaultRegistry NFT for this vault
    function initialize(uint256 nft) external;

    /// @notice Pushes tokens on the vault balance to the underlying protocol. For example, for Yearn this operation will take USDC from
    /// the contract balance and convert it to yUSDC.
    /// @dev Can only be called but Vault Owner or Strategy. Vault owner is the owner of NFT for this vault in VaultManager.
    /// Strategy is approved address for the vault NFT.
    ///
    /// Tokens **must** be a subset of Vault Tokens. However, the convention is that if tokenAmount == 0 it is the same as token is missing.
    ///
    /// Also notice that this operation doesn't guarantee that tokenAmounts will be invested in full.
    /// @param tokens Tokens to push
    /// @param tokenAmounts Amounts of tokens to push
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param. For the exact bytes structure see concrete vault descriptions
    /// @return actualTokenAmounts The amounts actually invested. It could be less than tokenAmounts (but not higher)
    function push(
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external returns (uint256[] memory actualTokenAmounts);

    /// @notice The same as `push` method above but transfers tokens to vault balance prior to calling push.
    /// After the `push` it returns all the leftover tokens back (`push` method doesn't guarantee that tokenAmounts will be invested in full).
    /// @param tokens Tokens to push
    /// @param tokenAmounts Amounts of tokens to push
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param. For the exact bytes structure see concrete vault descriptions
    /// @return actualTokenAmounts The amounts actually invested. It could be less than tokenAmounts (but not higher)
    function transferAndPush(
        address from,
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external returns (uint256[] memory actualTokenAmounts);

    /// @notice Pulls tokens from the underlying protocol to the `to` address.
    /// For example, for Yearn this operation will take yUSDC from
    /// the Yearn protocol, convert it to USDC and send to `to` address.
    /// @dev Can only be called but Vault Owner or Strategy. Vault owner is the owner of NFT for this vault in VaultManager.
    /// Strategy is approved address for the vault NFT. There's a subtle difference however - while vault owner
    /// can pull the tokens to any address, Strategy can only pull to other vault in the Vault System (a set of vaults united by the Gateway Vault)
    ///
    /// Tokens **must** be a subset of Vault Tokens. However, the convention is that if tokenAmount == 0 it is the same as token is missing.
    ///
    /// Also notice that this operation doesn't guarantee that tokenAmounts will be invested in full.
    /// @param to Address to receive the tokens
    /// @param tokens Tokens to pull
    /// @param tokenAmounts Amounts of tokens to pull
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param. For the exact bytes structure see concrete vault descriptions
    /// @return actualTokenAmounts The amounts actually withdrawn. It could be less than tokenAmounts (but not higher)
    function pull(
        address to,
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external returns (uint256[] memory actualTokenAmounts);

    /// @notice This method is for claiming accidentally accumulated tokens on the contact's balance.
    /// @dev Can only be called by Protocol Governance.
    /// @param to Address that will receive the tokens
    /// @param tokens Tokens to claim. Each token must be other than those in vaultTokens
    function reclaimTokens(address to, address[] memory tokens) external;

    /// @notice Claim liquidity mining rewards.
    /// @dev Can only be called by Vault Owner or Strategy. Vault owner is the owner of NFT for this vault in VaultManager.
    /// Strategy is approved address for the vault NFT.
    ///
    /// Since this method allows sending arbitrary transactions, the destinations of the calls
    /// are whitelisted by Protocol Governance.
    /// @param from Address of the reward pool
    /// @param data Abi encoded call to the `from` address
    function claimRewards(address from, bytes memory data) external;

    function isVaultToken(address token) external view returns (bool);
}",1252
RealWorld_BA_58_AaveVaultTest_RealWord_20240821230807.log,58,AaveVaultTest,5835,4844,10679,84.0,0.126055,"// SPDX-License-Identifier: agpl-3.0
pragma solidity =0.8.9;

import ""../interfaces/IVaultGovernance.sol"";
import ""../AaveVault.sol"";

contract AaveVaultTest is AaveVault {
    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)
        AaveVault(vaultGovernance_, vaultTokens_)
    {}

    function setATokens(address[] memory aTokens) public {
        _aTokens = aTokens;
    }

    function setVaultGovernance(address newVaultGovernance) public {
        _vaultGovernance = IVaultGovernance(newVaultGovernance);
    }
}",134
RealWorld_BA_58_DefaultAccessControl_RealWord_20240821191601.log,58,DefaultAccessControl,7634,4988,12622,79.0,0.13793,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/access/AccessControlEnumerable.sol"";
import ""./interfaces/IDefaultAccessControl.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice This is a default access control with 2 roles -
/// ADMIN and ADMIN_DELEGATE.
contract DefaultAccessControl is IDefaultAccessControl, AccessControlEnumerable {
    bytes32 public constant ADMIN_ROLE = keccak256(""admin"");
    bytes32 public constant ADMIN_DELEGATE_ROLE = keccak256(""admin_delegate"");

    /// @notice Creates a new contract.
    /// @param admin Admin of the contract
    constructor(address admin) {
        require(admin != address(0), ExceptionsLibrary.ADMIN_ADDRESS_ZERO);
        _setupRole(ADMIN_ROLE, admin);
        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
        _setRoleAdmin(ADMIN_DELEGATE_ROLE, ADMIN_ROLE);
    }

    /// @notice Checks if the address is contract admin.
    /// @param sender Adddress to check
    /// @return `true` if sender is an admin, `false` otherwise
    function isAdmin(address sender) public view returns (bool) {
        return hasRole(ADMIN_ROLE, sender) || hasRole(ADMIN_DELEGATE_ROLE, sender);
    }
}",277
RealWorld_BA_58_INonfungiblePositionManager_RealWord_20240821215902.log,58,INonfungiblePositionManager,32469,5662,38131,115.0,0.275585,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.9;
pragma abicoder v2;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""./IPeripheryImmutableState.sol"";

/// @title Non-fungible token for positions
/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred
/// and authorized.
interface INonfungiblePositionManager is IPeripheryImmutableState, IERC721 {
    /// @notice Emitted when liquidity is increased for a position NFT
    /// @dev Also emitted when a token is minted
    /// @param tokenId The ID of the token for which liquidity was increased
    /// @param liquidity The amount by which liquidity for the NFT position was increased
    /// @param amount0 The amount of token0 that was paid for the increase in liquidity
    /// @param amount1 The amount of token1 that was paid for the increase in liquidity
    event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
    /// @notice Emitted when liquidity is decreased for a position NFT
    /// @param tokenId The ID of the token for which liquidity was decreased
    /// @param liquidity The amount by which liquidity for the NFT position was decreased
    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity
    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity
    event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
    /// @notice Emitted when tokens are collected for a position NFT
    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior
    /// @param tokenId The ID of the token for which underlying tokens were collected
    /// @param recipient The address of the account that received the collected tokens
    /// @param amount0 The amount of token0 owed to the position that was collected
    /// @param amount1 The amount of token1 owed to the position that was collected
    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);

    /// @notice Returns the position information associated with a given token ID.
    /// @dev Throws if the token ID is not valid.
    /// @param tokenId The ID of the token that represents the position
    /// @return nonce The nonce for permits
    /// @return operator The address that is approved for spending
    /// @return token0 The address of the token0 for a specific pool
    /// @return token1 The address of the token1 for a specific pool
    /// @return fee The fee associated with the pool
    /// @return tickLower The lower end of the tick range for the position
    /// @return tickUpper The higher end of the tick range for the position
    /// @return liquidity The liquidity of the position
    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position
    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position
    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation
    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation
    function positions(uint256 tokenId)
        external
        view
        returns (
            uint96 nonce,
            address operator,
            address token0,
            address token1,
            uint24 fee,
            int24 tickLower,
            int24 tickUpper,
            uint128 liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );

    struct MintParams {
        address token0;
        address token1;
        uint24 fee;
        int24 tickLower;
        int24 tickUpper;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        address recipient;
        uint256 deadline;
    }

    /// @notice Creates a new position wrapped in a NFT
    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized
    /// a method does not exist, i.e. the pool is assumed to be initialized.
    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata
    /// @return tokenId The ID of the token that represents the minted position
    /// @return liquidity The amount of liquidity for this position
    /// @return amount0 The amount of token0
    /// @return amount1 The amount of token1
    function mint(MintParams calldata params)
        external
        payable
        returns (
            uint256 tokenId,
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        );

    struct IncreaseLiquidityParams {
        uint256 tokenId;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`
    /// @param params tokenId The ID of the token for which liquidity is being increased,
    /// amount0Desired The desired amount of token0 to be spent,
    /// amount1Desired The desired amount of token1 to be spent,
    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,
    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,
    /// deadline The time by which the transaction must be included to effect the change
    /// @return liquidity The new liquidity amount as a result of the increase
    /// @return amount0 The amount of token0 to acheive resulting liquidity
    /// @return amount1 The amount of token1 to acheive resulting liquidity
    function increaseLiquidity(IncreaseLiquidityParams calldata params)
        external
        payable
        returns (
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        );

    struct DecreaseLiquidityParams {
        uint256 tokenId;
        uint128 liquidity;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    /// @notice Decreases the amount of liquidity in a position and accounts it to the position
    /// @param params tokenId The ID of the token for which liquidity is being decreased,
    /// amount The amount by which liquidity will be decreased,
    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,
    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,
    /// deadline The time by which the transaction must be included to effect the change
    /// @return amount0 The amount of token0 accounted to the position's tokens owed
    /// @return amount1 The amount of token1 accounted to the position's tokens owed
    function decreaseLiquidity(DecreaseLiquidityParams calldata params)
        external
        payable
        returns (uint256 amount0, uint256 amount1);

    struct CollectParams {
        uint256 tokenId;
        address recipient;
        uint128 amount0Max;
        uint128 amount1Max;
    }

    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient
    /// @param params tokenId The ID of the NFT for which tokens are being collected,
    /// recipient The account that should receive the tokens,
    /// amount0Max The maximum amount of token0 to collect,
    /// amount1Max The maximum amount of token1 to collect
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);

    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens
    /// must be collected first.
    /// @param tokenId The ID of the token that is being burned
    function burn(uint256 tokenId) external payable;
}",1833
RealWorld_BA_58_IUniV3VaultGovernance_RealWord_20240821214357.log,58,IUniV3VaultGovernance,7573,5123,12696,108.0,0.140325,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.9;

import ""./external/univ3/INonfungiblePositionManager.sol"";
import ""./IVaultGovernance.sol"";

interface IUniV3VaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param positionManager Reference to UniV3 INonfungiblePositionManager
    struct DelayedProtocolParams {
        INonfungiblePositionManager positionManager;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",271
RealWorld_BA_58_UniV3Vault_RealWord_20240821220626.log,58,UniV3Vault,39429,5745,45174,114.0,0.312045,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""./interfaces/external/univ3/INonfungiblePositionManager.sol"";
import ""./interfaces/external/univ3/IUniswapV3Pool.sol"";
import ""./interfaces/external/univ3/IUniswapV3Factory.sol"";
import ""./interfaces/IUniV3VaultGovernance.sol"";
import ""./libraries/external/TickMath.sol"";
import ""./libraries/external/LiquidityAmounts.sol"";
import ""./Vault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Vault that interfaces UniswapV3 protocol in the integration layer.
contract UniV3Vault is IERC721Receiver, Vault {
    struct Options {
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    struct Pair {
        uint256 a0;
        uint256 a1;
    }

    IUniswapV3Pool public immutable pool;

    uint256 public uniV3Nft;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance for this vault
    /// @param vaultTokens_ ERC20 tokens under Vault management
    /// @param fee Fee of the underlying UniV3 pool
    constructor(
        IVaultGovernance vaultGovernance_,
        address[] memory vaultTokens_,
        uint24 fee
    ) Vault(vaultGovernance_, vaultTokens_) {
        require(_vaultTokens.length == 2, ExceptionsLibrary.TOKEN_LENGTH);
        pool = IUniswapV3Pool(
            IUniswapV3Factory(_positionManager().factory()).getPool(_vaultTokens[0], _vaultTokens[1], fee)
        );
    }

    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory) external returns (bytes4) {
        require(msg.sender == address(_positionManager()), ""SNFT"");
        require(_isStrategy(operator), ""STR"");
        (
            , ,
            address token0,
            address token1,
            , , , , , , ,
        ) = _positionManager().positions(tokenId);
        // new position should have vault tokens
        require(
            token0 == _vaultTokens[0] && token1 == _vaultTokens[1],
            ""VT""
        );

        if (uniV3Nft != 0) {
            (
                , , , , , , ,
                uint128 liquidity,
                , ,
                uint128 tokensOwed0,
                uint128 tokensOwed1
            ) = _positionManager().positions(uniV3Nft);
            require(liquidity == 0 && tokensOwed0 == 0 && tokensOwed1 == 0, ""TVL"");
            // return previous uni v3 position nft
            _positionManager().transferFrom(address(this), from, uniV3Nft);
        }

        uniV3Nft = tokenId;
        return this.onERC721Received.selector;
    }

    function collectEarnings(address to) external nonReentrant returns (uint256[] memory collectedEarnings) {
        require(_isApprovedOrOwner(msg.sender), ExceptionsLibrary.APPROVED_OR_OWNER);
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        address owner = registry.ownerOf(_nft);
        require(owner == msg.sender || _isValidPullDestination(to), ExceptionsLibrary.VALID_PULL_DESTINATION);
        collectedEarnings = new uint256[](2);
        (uint256 collectedEarnings0, uint256 collectedEarnings1) = _positionManager().collect(
            INonfungiblePositionManager.CollectParams({
                tokenId: uniV3Nft,
                recipient: to,
                amount0Max: type(uint128).max,
                amount1Max: type(uint128).max
            })
        );
        collectedEarnings[0] = collectedEarnings0;
        collectedEarnings[1] = collectedEarnings1;
        emit CollectedEarnings(tx.origin, to, collectedEarnings0, collectedEarnings1);
    }

    /// @inheritdoc Vault
    function tvl() public view override returns (uint256[] memory tokenAmounts) {
        tokenAmounts = new uint256[](_vaultTokens.length);
        if (uniV3Nft == 0)
            return tokenAmounts;
        (
            , , , , , 
            int24 tickLower, 
            int24 tickUpper, 
            uint128 liquidity,
            , , ,
        ) = _positionManager().positions(uniV3Nft);
        (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();
        uint160 sqrtPriceAX96 = TickMath.getSqrtRatioAtTick(tickLower);
        uint160 sqrtPriceBX96 = TickMath.getSqrtRatioAtTick(tickUpper);
        (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(
            sqrtPriceX96,
            sqrtPriceAX96,
            sqrtPriceBX96,
            liquidity
        );
        tokenAmounts[0] = amount0;
        tokenAmounts[1] = amount1;
    }

    function _push(uint256[] memory tokenAmounts, bytes memory options)
        internal
        override
        returns (uint256[] memory actualTokenAmounts)
    {
        address[] memory tokens = _vaultTokens;
        for (uint256 i = 0; i < tokens.length; i++)
            _allowTokenIfNecessary(tokens[i]);

        actualTokenAmounts = new uint256[](2);
        if (uniV3Nft == 0)
            return actualTokenAmounts;

        Options memory opts = _parseOptions(options);
        Pair memory amounts = Pair({
            a0: tokenAmounts[0],
            a1: tokenAmounts[1]
        });
        Pair memory minAmounts = Pair({
            a0: opts.amount0Min,
            a1: opts.amount1Min
        });
        (, uint256 amount0, uint256 amount1) = _positionManager().increaseLiquidity(
            INonfungiblePositionManager.IncreaseLiquidityParams({
                tokenId: uniV3Nft,
                amount0Desired: amounts.a0,
                amount1Desired: amounts.a1,
                amount0Min: minAmounts.a0,
                amount1Min: minAmounts.a1,
                deadline: opts.deadline
            })
        );
        actualTokenAmounts[0] = amount0;
        actualTokenAmounts[1] = amount1;
    }

    function _pull(
        address to,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) internal override returns (uint256[] memory actualTokenAmounts) {
        actualTokenAmounts = new uint256[](2);
        if (uniV3Nft == 0)
            return actualTokenAmounts;

        Options memory opts = _parseOptions(options);
        Pair memory amounts = _pullUniV3Nft(tokenAmounts, to, opts);
        actualTokenAmounts[0] = amounts.a0;
        actualTokenAmounts[1] = amounts.a1;
    }

    function _pullUniV3Nft(
        uint256[] memory tokenAmounts,
        address to,
        Options memory opts
    ) internal returns (Pair memory) {
        uint128 liquidityToPull;
        // scope the code below to avoid stack-too-deep exception
        {
            (, , , , , int24 tickLower, int24 tickUpper, uint128 liquidity, , , , ) = _positionManager().positions(uniV3Nft);
            (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();
            uint160 sqrtPriceAX96 = TickMath.getSqrtRatioAtTick(tickLower);
            uint160 sqrtPriceBX96 = TickMath.getSqrtRatioAtTick(tickUpper);
            liquidityToPull = LiquidityAmounts.getLiquidityForAmounts(
                sqrtPriceX96, sqrtPriceAX96, sqrtPriceBX96, tokenAmounts[0], tokenAmounts[1]
            );
            liquidityToPull = liquidity < liquidityToPull ? liquidity : liquidityToPull;
            if (liquidityToPull == 0) {
                return Pair({a0: 0, a1: 0});
            }
        }
        Pair memory minAmounts = Pair({
            a0: opts.amount0Min,
            a1: opts.amount1Min
        });
        (uint256 amount0, uint256 amount1) = _positionManager().decreaseLiquidity(
            INonfungiblePositionManager.DecreaseLiquidityParams({
                tokenId: uniV3Nft,
                liquidity: liquidityToPull,
                amount0Min: minAmounts.a0,
                amount1Min: minAmounts.a1,
                deadline: opts.deadline
            })
        );
        (uint256 amount0Collected, uint256 amount1Collected) = _positionManager().collect(
            INonfungiblePositionManager.CollectParams({
                tokenId: uniV3Nft,
                recipient: to,
                amount0Max: uint128(amount0),
                amount1Max: uint128(amount1)
            })
        );
        return Pair({a0: amount0Collected, a1: amount1Collected});
    }

    function _postReclaimTokens(address, address[] memory tokens) internal view override {}

    /// TODO: make a virtual function here? Or other better approach
    function _positionManager() internal view returns (INonfungiblePositionManager) {
        return IUniV3VaultGovernance(address(_vaultGovernance)).delayedProtocolParams().positionManager;
    }

    function _allowTokenIfNecessary(address token) internal {
        if (IERC20(token).allowance(address(_positionManager()), address(this)) < type(uint256).max / 2)
            IERC20(token).approve(address(_positionManager()), type(uint256).max);
    }

    function _parseOptions(bytes memory options) internal view returns (Options memory) {
        if (options.length == 0)
            return Options({amount0Min: 0, amount1Min: 0, deadline: block.timestamp + 600});

        require(options.length == 32 * 3, ExceptionsLibrary.IO_LENGTH);
        return abi.decode(options, (Options));
    }

    function _isStrategy(address addr) internal view returns (bool) {
        return _vaultGovernance.internalParams().registry.getApproved(_nft) == addr;
    }

    event CollectedEarnings(address indexed origin, address indexed to, uint256 amount0, uint256 amount1);
}",2299
RealWorld_BA_58_AaveVault_RealWord_20240821192702.log,58,AaveVault,18581,5275,23856,92.0,0.198405,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

import ""./interfaces/external/aave/ILendingPool.sol"";
import ""./interfaces/IAaveVaultGovernance.sol"";
import ""./Vault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Vault that interfaces Aave protocol in the integration layer.
/// @dev Notes:
/// ### TVL
///
/// The TVL of the vault is cached and updated after each deposit withdraw.
/// So essentially `tvl` call doesn't take into account accrued interest / donations to Aave since the
/// last `deposit` / `withdraw`
///
/// ### aTokens
/// aTokens are fixed at the token creation and addresses are taken from Aave Lending Pool.
/// So essentially each aToken is fixed for life of the AaveVault. If the aToken is missing for some vaultToken,
/// the AaveVault cannot be created.
///
/// ### Push / Pull
/// It is assumed that any amounts of tokens can be deposited / withdrawn from Aave.
/// The contract's vaultTokens are fully allowed to Aave Lending Pool.
contract AaveVault is Vault {
    address[] internal _aTokens;
    uint256[] internal _tvls;

    /// @notice Creates a new contract.
    /// @dev Requires that aToken exists for each vaultToken
    /// @param vaultGovernance_ Reference to VaultGovernance for this vault
    /// @param vaultTokens_ ERC20 tokens under Vault management
    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)
        Vault(vaultGovernance_, vaultTokens_)
    {
        _aTokens = new address[](vaultTokens_.length);
        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            address aToken = _getAToken(_vaultTokens[i]);
            require(aToken != address(0), ExceptionsLibrary.ZERO_TOKEN);
            _aTokens[i] = aToken;
            _tvls.push(0);
        }
    }

    /// @inheritdoc Vault
    function tvl() public view override returns (uint256[] memory tokenAmounts) {
        return _tvls;
    }

    /// @notice Update all tvls to current aToken balances.
    function updateTvls() public {
        for (uint256 i = 0; i < _tvls.length; i++) {
            _tvls[i] = IERC20(_aTokens[i]).balanceOf(address(this));
        }
    }

    function _push(uint256[] memory tokenAmounts, bytes memory options)
        internal
        override
        returns (uint256[] memory actualTokenAmounts)
    {
        address[] memory tokens = _vaultTokens;
        uint256 referralCode = 0;
        if (options.length > 0) {
            referralCode = abi.decode(options, (uint256));
        }

        for (uint256 i = 0; i < _aTokens.length; i++) {
            if (tokenAmounts[i] == 0) {
                continue;
            }
            address token = tokens[i];
            _allowTokenIfNecessary(token);
            _lendingPool().deposit(tokens[i], tokenAmounts[i], address(this), uint16(referralCode));
        }
        updateTvls();
        actualTokenAmounts = tokenAmounts;
    }

    function _pull(
        address to,
        uint256[] memory tokenAmounts,
        bytes memory
    ) internal override returns (uint256[] memory actualTokenAmounts) {
        address[] memory tokens = _vaultTokens;
        for (uint256 i = 0; i < _aTokens.length; i++) {
            if ((_tvls[i] == 0) || (tokenAmounts[i] == 0)) {
                continue;
            }
            _lendingPool().withdraw(tokens[i], tokenAmounts[i], to);
        }
        updateTvls();
        actualTokenAmounts = tokenAmounts;
    }

    function _getAToken(address token) internal view returns (address) {
        DataTypes.ReserveData memory data = _lendingPool().getReserveData(token);
        return data.aTokenAddress;
    }

    function _allowTokenIfNecessary(address token) internal {
        if (IERC20(token).allowance(address(this), address(_lendingPool())) < type(uint256).max / 2) {
            IERC20(token).approve(address(_lendingPool()), type(uint256).max);
        }
    }

    function _lendingPool() internal view returns (ILendingPool) {
        return IAaveVaultGovernance(address(_vaultGovernance)).delayedProtocolParams().lendingPool;
    }
}",982
RealWorld_BA_58_AaveVaultGovernance_RealWord_20240821191723.log,58,AaveVaultGovernance,12770,5263,18033,89.0,0.16911,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IAaveVaultGovernance.sol"";
import ""./VaultGovernance.sol"";

/// @notice Governance that manages all Aave Vaults params and can deploy a new Aave Vault.
contract AaveVaultGovernance is IAaveVaultGovernance, VaultGovernance {
    /// @notice Creates a new contract.
    /// @param internalParams_ Initial Internal Params
    /// @param delayedProtocolParams_ Initial Protocol Params
    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)
        VaultGovernance(internalParams_)
    {
        _delayedProtocolParams = abi.encode(delayedProtocolParams_);
    }

    /// @inheritdoc IAaveVaultGovernance
    function delayedProtocolParams() public view returns (DelayedProtocolParams memory) {
        if (_delayedProtocolParams.length == 0) {
            return DelayedProtocolParams({lendingPool: ILendingPool(address(0))});
        }
        return abi.decode(_delayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IAaveVaultGovernance
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory) {
        if (_stagedDelayedProtocolParams.length == 0) {
            return DelayedProtocolParams({lendingPool: ILendingPool(address(0))});
        }
        return abi.decode(_stagedDelayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IAaveVaultGovernance
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external {
        _stageDelayedProtocolParams(abi.encode(params));
        emit StageDelayedProtocolParams(tx.origin, msg.sender, params, _delayedProtocolParamsTimestamp);
    }

    /// @inheritdoc IAaveVaultGovernance
    function commitDelayedProtocolParams() external {
        _commitDelayedProtocolParams();
        emit CommitDelayedProtocolParams(
            tx.origin,
            msg.sender,
            abi.decode(_delayedProtocolParams, (DelayedProtocolParams))
        );
    }

    /// @notice Emitted when new DelayedProtocolParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedProtocolParams(
        address indexed origin,
        address indexed sender,
        DelayedProtocolParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedProtocolParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that are committed
    event CommitDelayedProtocolParams(address indexed origin, address indexed sender, DelayedProtocolParams params);
}",597
RealWorld_BA_58_ILpIssuerGovernance_RealWord_20240821203755.log,58,ILpIssuerGovernance,20361,5051,25412,108.0,0.202825,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";

interface ILpIssuerGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param strategyTreasury Reference to address that will collect strategy management fees
    /// @param strategyPerformanceTreasury Reference to address that will collect strategy performance fees
    /// @param managementFee Management fee for Strategist denominated in 10 ** 9
    /// @param performanceFee Performance fee for Strategist denominated in 10 ** 9
    struct DelayedStrategyParams {
        address strategyTreasury;
        address strategyPerformanceTreasury;
        uint256 managementFee;
        uint256 performanceFee;
    }

    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param managementFeeChargeDelay The minimal interval between management fee charges
    struct DelayedProtocolParams {
        uint256 managementFeeChargeDelay;
    }

    /// @notice Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param tokenLimitPerAddress Reference to address that will collect strategy fees
    struct StrategyParams {
        uint256 tokenLimitPerAddress;
    }

    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param protocolFee Management fee for Protocol denominated in 10 ** 9
    struct DelayedProtocolPerVaultParams {
        uint256 protocolFee;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Per Vault Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    function delayedProtocolPerVaultParams(uint256 nft) external view returns (DelayedProtocolPerVaultParams memory);

    /// @notice Delayed Protocol Per Vault Params staged for commit after delay.
    /// @param nft VaultRegistry NFT of the vault
    function stagedDelayedProtocolPerVaultParams(uint256 nft)
        external
        view
        returns (DelayedProtocolPerVaultParams memory);

    /// @notice Strategy Params.
    /// @param nft VaultRegistry NFT of the vault
    function strategyParams(uint256 nft) external view returns (StrategyParams memory);

    /// @notice Delayed Strategy Params
    /// @param nft VaultRegistry NFT of the vault
    function delayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Delayed Strategy Params staged for commit after delay.
    /// @param nft VaultRegistry NFT of the vault
    function stagedDelayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Set Strategy params, i.e. Params that could be changed by Strategy or Protocol Governance immediately.
    /// @param nft Nft of the vault
    /// @param params New params
    function setStrategyParams(uint256 nft, StrategyParams calldata params) external;

    /// @notice Stage Delayed Protocol Per Vault Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params
    function stageDelayedProtocolPerVaultParams(uint256 nft, DelayedProtocolPerVaultParams calldata params) external;

    /// @notice Commit Delayed Protocol Per Vault Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolPerVaultParamsTimestamp
    /// @param nft VaultRegistry NFT of the vault
    function commitDelayedProtocolPerVaultParams(uint256 nft) external;

    /// @notice Stage Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params
    function stageDelayedStrategyParams(uint256 nft, DelayedStrategyParams calldata params) external;

    /// @notice Commit Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedStrategyParamsTimestamp
    /// @param nft VaultRegistry NFT of the vault
    function commitDelayedStrategyParams(uint256 nft) external;

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",1089
RealWorld_BA_58_IUniswapV3Factory_RealWord_20240821215419.log,58,IUniswapV3Factory,18356,4787,23143,104.0,0.18752,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title The interface for the Uniswap V3 Factory
/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees
interface IUniswapV3Factory {
    /// @notice Emitted when the owner of the factory is changed
    /// @param oldOwner The owner before the owner was changed
    /// @param newOwner The owner after the owner was changed
    event OwnerChanged(address indexed oldOwner, address indexed newOwner);

    /// @notice Emitted when a pool is created
    /// @param token0 The first token of the pool by address sort order
    /// @param token1 The second token of the pool by address sort order
    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
    /// @param tickSpacing The minimum number of ticks between initialized ticks
    /// @param pool The address of the created pool
    event PoolCreated(
        address indexed token0,
        address indexed token1,
        uint24 indexed fee,
        int24 tickSpacing,
        address pool
    );

    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory
    /// @param fee The enabled fee, denominated in hundredths of a bip
    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee
    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);

    /// @notice Returns the current owner of the factory
    /// @dev Can be changed by the current owner via setOwner
    /// @return The address of the factory owner
    function owner() external view returns (address);

    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled
    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context
    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee
    /// @return The tick spacing
    function feeAmountTickSpacing(uint24 fee) external view returns (int24);

    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist
    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order
    /// @param tokenA The contract address of either token0 or token1
    /// @param tokenB The contract address of the other token
    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
    /// @return pool The pool address
    function getPool(
        address tokenA,
        address tokenB,
        uint24 fee
    ) external view returns (address pool);

    /// @notice Creates a pool for the given two tokens and fee
    /// @param tokenA One of the two tokens in the desired pool
    /// @param tokenB The other of the two tokens in the desired pool
    /// @param fee The desired fee for the pool
    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved
    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments
    /// are invalid.
    /// @return pool The address of the newly created pool
    function createPool(
        address tokenA,
        address tokenB,
        uint24 fee
    ) external returns (address pool);

    /// @notice Updates the owner of the factory
    /// @dev Must be called by the current owner
    /// @param _owner The new owner of the factory
    function setOwner(address _owner) external;

    /// @notice Enables a fee amount with the given tickSpacing
    /// @dev Fee amounts may never be removed once enabled
    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)
    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount
    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
}",939
RealWorld_BA_58_TestVaultGovernance_RealWord_20240821230419.log,58,TestVaultGovernance,10947,5137,16084,98.0,0.157475,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../VaultGovernance.sol"";

contract TestVaultGovernance is VaultGovernance {
    constructor(InternalParams memory internalParams_) VaultGovernance(internalParams_) {}

    function stageDelayedStrategyParams(uint256 nft, bytes memory params) public {
        _stageDelayedStrategyParams(nft, params);
    }

    function stageDelayedProtocolParams(bytes memory params) public {
        _stageDelayedProtocolParams(params);
    }

    function getStagedDelayedStrategyParams(uint256 nft) public view returns (bytes memory) {
        return _stagedDelayedStrategyParams[nft];
    }

    function getStagedDelayedProtocolParams() public view returns (bytes memory) {
        return _stagedDelayedProtocolParams;
    }

    function getDelayedStrategyParamsTimestamp(uint256 nft) public view returns (uint256) {
        return _delayedStrategyParamsTimestamp[nft];
    }

    function getDelayedProtocolParamsTimestamp() public view returns (uint256) {
        return _delayedProtocolParamsTimestamp;
    }

    function getDelayedStrategyParams(uint256 nft) public view returns (bytes memory) {
        return _delayedStrategyParams[nft];
    }

    function getDelayedProtocolParams() public view returns (bytes memory) {
        return _delayedProtocolParams;
    }

    function commitDelayedStrategyParams(uint256 nft) public {
        _commitDelayedStrategyParams(nft);
    }

    function commitDelayedProtocolParams() public {
        _commitDelayedProtocolParams();
    }

    function setStrategyParams(uint256 nft, bytes memory params) public {
        _setStrategyParams(nft, params);
    }

    function setProtocolParams(bytes memory params) public {
        _setProtocolParams(params);
    }

    function getStrategyParams(uint256 nft) public view returns (bytes memory) {
        return _strategyParams[nft];
    }

    function getProtocolParams() public view returns (bytes memory) {
        return _protocolParams;
    }

    function requireProtocolAdmin() public view {
        _requireProtocolAdmin();
    }

    function requireAtLeastStrategy(uint256 nft) public view {
        _requireAtLeastStrategy(nft);
    }
}",467
RealWorld_BA_58_ISwapRouter_RealWord_20240821220059.log,58,ISwapRouter,12719,5791,18510,118.0,0.179415,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.7.5;
pragma abicoder v2;

/// @title Router token swapping functionality
/// @notice Functions for swapping tokens via Uniswap V3
interface ISwapRouter {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    /// @notice Swaps `amountIn` of one token for as much as possible of another token
    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata
    /// @return amountOut The amount of the received token
    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);

    struct ExactInputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
    }

    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path
    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata
    /// @return amountOut The amount of the received token
    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);

    struct ExactOutputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
        uint160 sqrtPriceLimitX96;
    }

    /// @notice Swaps as little as possible of one token for `amountOut` of another token
    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata
    /// @return amountIn The amount of the input token
    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);

    struct ExactOutputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
    }

    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)
    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata
    /// @return amountIn The amount of the input token
    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);
}",571
RealWorld_BA_58_ERC20Vault_RealWord_20240821192028.log,58,ERC20Vault,18953,5387,24340,94.0,0.202505,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./trader/interfaces/IChiefTrader.sol"";
import ""./trader/interfaces/ITrader.sol"";
import ""./interfaces/IERC20VaultGovernance.sol"";
import ""./Vault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Vault that stores ERC20 tokens.
contract ERC20Vault is Vault, ITrader {
    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance for this vault
    /// @param vaultTokens_ ERC20 tokens under Vault management
    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)
        Vault(vaultGovernance_, vaultTokens_)
    {}

    /// @inheritdoc Vault
    function tvl() public view override returns (uint256[] memory tokenAmounts) {
        address[] memory tokens = _vaultTokens;
        tokenAmounts = new uint256[](tokens.length);
        for (uint256 i = 0; i < tokens.length; i++) {
            tokenAmounts[i] = IERC20(tokens[i]).balanceOf(address(this));
        }
    }

    /// @inheritdoc ITrader
    function swapExactInput(
        uint256 traderId,
        uint256 amount,
        address,
        PathItem[] memory path,
        bytes memory options
    ) external returns (uint256 amountOut) {
        require(
            path.length > 0  && isVaultToken(path[path.length - 1].token1), 
            ExceptionsLibrary.NOT_VAULT_TOKEN
        );
        require(_isStrategy(msg.sender), ExceptionsLibrary.NOT_STRATEGY_TREASURY);
        IERC20VaultGovernance vg = IERC20VaultGovernance(address(_vaultGovernance));
        ITrader trader = ITrader(vg.delayedProtocolParams().trader);
        IChiefTrader chiefTrader = IChiefTrader(address(trader));
        _approveERC20TokenIfNecessary(path[0].token0, chiefTrader.getTrader(traderId));
        return trader.swapExactInput(traderId, amount, address(0), path, options);
    }

    /// @inheritdoc ITrader
    function swapExactOutput(
        uint256 traderId,
        uint256 amount,
        address,
        PathItem[] memory path,
        bytes calldata options
    ) external returns (uint256 amountOut) {
        require(
            path.length > 0  && isVaultToken(path[path.length - 1].token1), 
            ExceptionsLibrary.NOT_VAULT_TOKEN
        );
        require(_isStrategy(msg.sender), ExceptionsLibrary.NOT_STRATEGY_TREASURY);
        IERC20VaultGovernance vg = IERC20VaultGovernance(address(_vaultGovernance));
        ITrader trader = ITrader(vg.delayedProtocolParams().trader);
        IChiefTrader chiefTrader = IChiefTrader(address(trader));
        _approveERC20TokenIfNecessary(path[0].token0, chiefTrader.getTrader(traderId));
        return trader.swapExactOutput(traderId, amount, address(0), path, options);
    }

    function _push(uint256[] memory tokenAmounts, bytes memory)
        internal
        pure
        override
        returns (uint256[] memory actualTokenAmounts)
    {
        // no-op, tokens are already on balance
        return tokenAmounts;
    }

    function _pull(
        address to,
        uint256[] memory tokenAmounts,
        bytes memory
    ) internal override returns (uint256[] memory actualTokenAmounts) {
        for (uint256 i = 0; i < tokenAmounts.length; i++) {
            IERC20(_vaultTokens[i]).transfer(to, tokenAmounts[i]);
        }
        actualTokenAmounts = tokenAmounts;
    }

    function _postReclaimTokens(address, address[] memory tokens) internal view override {
        for (uint256 i = 0; i < tokens.length; i++) {
            require(!isVaultToken(tokens[i]), ExceptionsLibrary.OTHER_VAULT_TOKENS); // vault token is part of TVL
        }
    }

    function _isStrategy(address addr) internal view returns (bool) {
        return _vaultGovernance.internalParams().registry.getApproved(_nft) == addr;
    }

    function _approveERC20TokenIfNecessary(address token, address to) internal {
        if (IERC20(token).allowance(to, address(this)) < type(uint256).max / 2)
            IERC20(token).approve(to, type(uint256).max);
    }
}",994
RealWorld_BA_58_TestVaultGovernance_RealWord_20240821200900.log,58,TestVaultGovernance,10809,5371,16180,108.0,0.161465,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../VaultGovernance.sol"";

contract TestVaultGovernance is VaultGovernance {
    constructor(InternalParams memory internalParams_) VaultGovernance(internalParams_) {}

    function stageDelayedStrategyParams(uint256 nft, bytes memory params) public {
        _stageDelayedStrategyParams(nft, params);
    }

    function stageDelayedProtocolParams(bytes memory params) public {
        _stageDelayedProtocolParams(params);
    }

    function getStagedDelayedStrategyParams(uint256 nft) public view returns (bytes memory) {
        return _stagedDelayedStrategyParams[nft];
    }

    function getStagedDelayedProtocolParams() public view returns (bytes memory) {
        return _stagedDelayedProtocolParams;
    }

    function getDelayedStrategyParamsTimestamp(uint256 nft) public view returns (uint256) {
        return _delayedStrategyParamsTimestamp[nft];
    }

    function getDelayedProtocolParamsTimestamp() public view returns (uint256) {
        return _delayedProtocolParamsTimestamp;
    }

    function getDelayedStrategyParams(uint256 nft) public view returns (bytes memory) {
        return _delayedStrategyParams[nft];
    }

    function getDelayedProtocolParams() public view returns (bytes memory) {
        return _delayedProtocolParams;
    }

    function commitDelayedStrategyParams(uint256 nft) public {
        _commitDelayedStrategyParams(nft);
    }

    function commitDelayedProtocolParams() public {
        _commitDelayedProtocolParams();
    }

    function setStrategyParams(uint256 nft, bytes memory params) public {
        _setStrategyParams(nft, params);
    }

    function setProtocolParams(bytes memory params) public {
        _setProtocolParams(params);
    }

    function getStrategyParams(uint256 nft) public view returns (bytes memory) {
        return _strategyParams[nft];
    }

    function getProtocolParams() public view returns (bytes memory) {
        return _protocolParams;
    }

    function requireProtocolAdmin() public view {
        _requireProtocolAdmin();
    }

    function requireAtLeastStrategy(uint256 nft) public view {
        _requireAtLeastStrategy(nft);
    }
}",467
RealWorld_BA_58_IUniswapV3PoolState_RealWord_20240821220259.log,58,IUniswapV3PoolState,26233,5600,31833,116.0,0.243165,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title Pool state that can change
/// @notice These methods compose the pool's state, and can change with any frequency including multiple times
/// per transaction
interface IUniswapV3PoolState {
    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
    /// when accessed externally.
    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
    /// boundary.
    /// observationIndex The index of the last oracle observation that was written,
    /// observationCardinality The current maximum number of observations stored in the pool,
    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
    /// feeProtocol The protocol fee for both tokens of the pool.
    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
    /// unlocked Whether the pool is currently locked to reentrancy
    function slot0()
        external
        view
        returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        );

    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
    /// @dev This value can overflow the uint256
    function feeGrowthGlobal0X128() external view returns (uint256);

    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
    /// @dev This value can overflow the uint256
    function feeGrowthGlobal1X128() external view returns (uint256);

    /// @notice The amounts of token0 and token1 that are owed to the protocol
    /// @dev Protocol fees will never exceed uint128 max in either token
    function protocolPerformanceFees() external view returns (uint128 token0, uint128 token1);

    /// @notice The currently in range liquidity available to the pool
    /// @dev This value has no relationship to the total liquidity across all ticks
    function liquidity() external view returns (uint128);

    /// @notice Look up information about a specific tick in the pool
    /// @param tick The tick to look up
    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or
    /// tick upper,
    /// liquidityNet how much liquidity changes when the pool price crosses the tick,
    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,
    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,
    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick
    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,
    /// secondsOutside the seconds spent on the other side of the tick from the current tick,
    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.
    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.
    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for
    /// a specific position.
    function ticks(int24 tick)
        external
        view
        returns (
            uint128 liquidityGross,
            int128 liquidityNet,
            uint256 feeGrowthOutside0X128,
            uint256 feeGrowthOutside1X128,
            int56 tickCumulativeOutside,
            uint160 secondsPerLiquidityOutsideX128,
            uint32 secondsOutside,
            bool initialized
        );

    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information
    function tickBitmap(int16 wordPosition) external view returns (uint256);

    /// @notice Returns the information about a position by the position's key
    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
    /// @return _liquidity The amount of liquidity in the position,
    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
    function positions(bytes32 key)
        external
        view
        returns (
            uint128 _liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );

    /// @notice Returns data about a specific observation index
    /// @param index The element of the observations array to fetch
    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time
    /// ago, rather than at a specific index in the array.
    /// @return blockTimestamp The timestamp of the observation,
    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,
    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,
    /// Returns initialized whether the observation has been initialized and the values are safe to use
    function observations(uint256 index)
        external
        view
        returns (
            uint32 blockTimestamp,
            int56 tickCumulative,
            uint160 secondsPerLiquidityCumulativeX128,
            bool initialized
        );
}",1445
RealWorld_BA_58_IProtocolGovernance_RealWord_20240821233627.log,58,IProtocolGovernance,17363,5855,23218,105.0,0.203915,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IDefaultAccessControl.sol"";
import ""./IVaultRegistry.sol"";

interface IProtocolGovernance is IDefaultAccessControl {
    /// @notice CommonLibrary protocol params.
    /// @param permissionless If `true` anyone can spawn vaults, o/w only Protocol Governance Admin
    /// @param maxTokensPerVault Max different token addresses that could be managed by the protocol
    /// @param governanceDelay The delay (in secs) that must pass before setting new pending params to commiting them
    /// @param protocolTreasury Protocol treasury address for collecting management fees
    struct Params {
        bool permissionless;
        uint256 maxTokensPerVault;
        uint256 governanceDelay;
        address protocolTreasury;
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @notice Addresses allowed to claim liquidity mining rewards from.
    function claimAllowlist() external view returns (address[] memory);

    /// @notice Pending addresses to be added to claimAllowlist.
    function pendingClaimAllowlistAdd() external view returns (address[] memory);

    /// @notice Addresses of tokens allowed for vaults.
    function tokenWhitelist() external view returns (address[] memory);

    /// @notice Pending addresses to be added to tokenWhitelist.
    function pendingTokenWhitelistAdd() external view returns (address[] memory);

    /// @notice Addresses allowed to claim liquidity mining rewards from.
    function vaultGovernances() external view returns (address[] memory);

    /// @notice Pending addresses to be added to vaultGovernances.
    function pendingVaultGovernancesAdd() external view returns (address[] memory);

    /// @notice Check if address is allowed to claim.
    function isAllowedToClaim(address addr) external view returns (bool);

    /// @notice Check if address is an approved token.
    function isAllowedToken(address addr) external view returns (bool);

    /// @notice Check if address is a registered vault governance.
    function isVaultGovernance(address addr) external view returns (bool);

    /// @notice If `false` only admins can deploy new vaults, o/w anyone can deploy a new vault.
    function permissionless() external view returns (bool);

    /// @notice Max different ERC20 token addresses that could be managed by the protocol.
    function maxTokensPerVault() external view returns (uint256);

    /// @notice The delay for committing any governance params.
    function governanceDelay() external view returns (uint256);

    /// @notice The address of the protocol treasury.
    function protocolTreasury() external view returns (address);

    // -------------------  PUBLIC, MUTATING, GOVERNANCE, DELAY  -------------------

    /// @notice Set new pending params.
    /// @param newParams newParams to set
    function setPendingParams(Params memory newParams) external;

    /// @notice Stage addresses for claim allow list.
    /// @param addresses Addresses to add
    function setPendingClaimAllowlistAdd(address[] calldata addresses) external;

    /// @notice Stage addresses for token whitelist.
    /// @param addresses Addresses to add
    function setPendingTokenWhitelistAdd(address[] calldata addresses) external;

    /// @notice Stage addresses for vault governances.
    /// @param addresses Addresses to add
    function setPendingVaultGovernancesAdd(address[] calldata addresses) external;

    // -------------------  PUBLIC, MUTATING, GOVERNANCE, IMMEDIATE  -------------------

    /// @notice Commit pending params.
    function commitParams() external;

    /// @notice Commit pending ClaimAllowlistAdd params.
    function commitClaimAllowlistAdd() external;

    /// @notice Commit pending tokenWhitelistAdd params.
    function commitTokenWhitelistAdd() external;

    /// @notice Commit pending VaultGovernancesAdd params.
    function commitVaultGovernancesAdd() external;

    /// @notice Remove from claim allow list immediately.
    function removeFromClaimAllowlist(address addr) external;

    /// @notice Remove from token whitelist immediately.
    function removeFromTokenWhitelist(address addr) external;

    /// @notice Remove from vault governances immediately.
    function removeFromVaultGovernances(address addr) external;
}",867
RealWorld_BA_58_IDefaultAccessControl_RealWord_20240821233457.log,58,IDefaultAccessControl,4499,4042,8541,88.0,0.103335,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/access/IAccessControlEnumerable.sol"";

interface IDefaultAccessControl is IAccessControlEnumerable {
    /// @notice Checks that the address is contract admin.
    /// @param who Address to check
    /// @return `true` if who is admin, `false` otherwise
    function isAdmin(address who) external view returns (bool);
}",93
RealWorld_BA_58_ILpIssuer_RealWord_20240821205625.log,58,ILpIssuer,7992,4885,12877,94.0,0.13766,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVault.sol"";

interface ILpIssuer {
    /// @notice VaultRegistry NFT for this vault
    function nft() external view returns (uint256);

    /// @notice Nft of the underlying vault.
    function subvaultNft() external view returns (uint256);

    /// @notice Adds subvault nft to the vault.
    /// @dev Can be called only once.
    /// @param nft Subvault nft to add
    function addSubvault(uint256 nft) external;

    /// @notice Initialize contract with vault nft
    /// @param nft VaultRegistry NFT for this vault
    function initialize(uint256 nft) external;

    /// @notice Deposit tokens into LpIssuer
    /// @param tokenAmounts Amounts of tokens to push
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param.
    function deposit(uint256[] calldata tokenAmounts, bytes memory options) external;

    /// @notice Withdraw tokens from LpIssuer
    /// @param to Address to withdraw to
    /// @param lpTokenAmount Amount of token to withdraw
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param.
    function withdraw(
        address to,
        uint256 lpTokenAmount,
        bytes memory options
    ) external;
}",323
RealWorld_BA_58_IAaveVaultGovernance_RealWord_20240821213851.log,58,IAaveVaultGovernance,7326,4731,12057,90.0,0.13125,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

import ""./external/aave/ILendingPool.sol"";
import ""./IVaultGovernance.sol"";

interface IAaveVaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param lendingPool Reference to Aave LendingPool
    struct DelayedProtocolParams {
        ILendingPool lendingPool;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",270
RealWorld_BA_58_DataTypes_RealWord_20240821215231.log,58,DataTypes,9548,4901,14449,106.0,0.14576,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

library DataTypes {
    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.
    struct ReserveData {
        //stores the reserve configuration
        ReserveConfigurationMap configuration;
        //the liquidity index. Expressed in ray
        uint128 liquidityIndex;
        //variable borrow index. Expressed in ray
        uint128 variableBorrowIndex;
        //the current supply rate. Expressed in ray
        uint128 currentLiquidityRate;
        //the current variable borrow rate. Expressed in ray
        uint128 currentVariableBorrowRate;
        //the current stable borrow rate. Expressed in ray
        uint128 currentStableBorrowRate;
        uint40 lastUpdateTimestamp;
        //tokens addresses
        address aTokenAddress;
        address stableDebtTokenAddress;
        address variableDebtTokenAddress;
        //address of the interest rate strategy
        address interestRateStrategyAddress;
        //the id of the reserve. Represents the position in the list of the active reserves
        uint8 id;
    }

    struct ReserveConfigurationMap {
        //bit 0-15: LTV
        //bit 16-31: Liq. threshold
        //bit 32-47: Liq. bonus
        //bit 48-55: Decimals
        //bit 56: Reserve is active
        //bit 57: reserve is frozen
        //bit 58: borrowing is enabled
        //bit 59: stable rate borrowing enabled
        //bit 60-63: reserved
        //bit 64-79: reserve factor
        uint256 data;
    }

    struct UserConfigurationMap {
        uint256 data;
    }

    enum InterestRateMode {
        NONE,
        STABLE,
        VARIABLE
    }
}",398
RealWorld_BA_58_ITrader_RealWord_20240821232154.log,58,ITrader,9816,4999,14815,84.0,0.14906,"// SPDX-License-Identifier: BSL-1.1
pragma solidity =0.8.9;

// When trading from a smart contract, the most important thing to keep in mind is that
// access to an external price source is required. Without this, trades can be frontrun for considerable loss.

interface ITrader {
    /// @notice Trade path element
    /// @param token0 The token to be sold
    /// @param token1 The token to be bought
    /// @param options Protocol-specific options
    struct PathItem {
        address token0;
        address token1;
        bytes options;
    }

    /// @notice Swap exact amount of input tokens for output tokens
    /// @param traderId Trader ID (used only by Chief trader)
    /// @param amount Amount of the input tokens to spend
    /// @param recipient Address of the recipient (not used by Chief trader)
    /// @param path Trade path PathItem[]
    /// @param options Protocol-speceific options
    /// @return amountOut Amount of the output tokens received
    function swapExactInput(
        uint256 traderId,
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        bytes memory options
    ) external returns (uint256 amountOut);

    /// @notice Swap exact amount of input tokens for output tokens
    /// @param traderId Trader ID (used only by Chief trader)
    /// @param amount Amount of the output tokens to receive
    /// @param recipient Address of the recipient (not used by Chief trader)
    /// @param path Trade path PathItem[]
    /// @param options Protocol-speceific options
    /// @return amountIn of the input tokens spent
    function swapExactOutput(
        uint256 traderId,
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        bytes memory options
    ) external returns (uint256 amountIn);
}",399
RealWorld_BA_58_IUniswapV3PoolState_RealWord_20240822001756.log,58,IUniswapV3PoolState,26112,5442,31554,91.0,0.2394,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title Pool state that can change
/// @notice These methods compose the pool's state, and can change with any frequency including multiple times
/// per transaction
interface IUniswapV3PoolState {
    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
    /// when accessed externally.
    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
    /// boundary.
    /// observationIndex The index of the last oracle observation that was written,
    /// observationCardinality The current maximum number of observations stored in the pool,
    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
    /// feeProtocol The protocol fee for both tokens of the pool.
    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
    /// unlocked Whether the pool is currently locked to reentrancy
    function slot0()
        external
        view
        returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        );

    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
    /// @dev This value can overflow the uint256
    function feeGrowthGlobal0X128() external view returns (uint256);

    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
    /// @dev This value can overflow the uint256
    function feeGrowthGlobal1X128() external view returns (uint256);

    /// @notice The amounts of token0 and token1 that are owed to the protocol
    /// @dev Protocol fees will never exceed uint128 max in either token
    function protocolPerformanceFees() external view returns (uint128 token0, uint128 token1);

    /// @notice The currently in range liquidity available to the pool
    /// @dev This value has no relationship to the total liquidity across all ticks
    function liquidity() external view returns (uint128);

    /// @notice Look up information about a specific tick in the pool
    /// @param tick The tick to look up
    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or
    /// tick upper,
    /// liquidityNet how much liquidity changes when the pool price crosses the tick,
    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,
    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,
    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick
    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,
    /// secondsOutside the seconds spent on the other side of the tick from the current tick,
    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.
    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.
    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for
    /// a specific position.
    function ticks(int24 tick)
        external
        view
        returns (
            uint128 liquidityGross,
            int128 liquidityNet,
            uint256 feeGrowthOutside0X128,
            uint256 feeGrowthOutside1X128,
            int56 tickCumulativeOutside,
            uint160 secondsPerLiquidityOutsideX128,
            uint32 secondsOutside,
            bool initialized
        );

    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information
    function tickBitmap(int16 wordPosition) external view returns (uint256);

    /// @notice Returns the information about a position by the position's key
    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
    /// @return _liquidity The amount of liquidity in the position,
    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
    function positions(bytes32 key)
        external
        view
        returns (
            uint128 _liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );

    /// @notice Returns data about a specific observation index
    /// @param index The element of the observations array to fetch
    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time
    /// ago, rather than at a specific index in the array.
    /// @return blockTimestamp The timestamp of the observation,
    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,
    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,
    /// Returns initialized whether the observation has been initialized and the values are safe to use
    function observations(uint256 index)
        external
        view
        returns (
            uint32 blockTimestamp,
            int56 tickCumulative,
            uint160 secondsPerLiquidityCumulativeX128,
            bool initialized
        );
}",1445
RealWorld_BA_58_FullMath_RealWord_20240821233000.log,58,FullMath,24338,6271,30609,134.0,0.24711,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.9;

/// @title Contains 512-bit math functions
/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision
/// @dev Handles ""phantom overflow"" i.e., allows multiplication and division where an intermediate value overflows 256 bits
library FullMath {
    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
    /// @param a The multiplicand
    /// @param b The multiplier
    /// @param denominator The divisor
    /// @return result The 256-bit result
    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv
    function mulDiv(
        uint256 a,
        uint256 b,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        // diff: original lib works under 0.7.6 with overflows enabled
        unchecked {
            // 512-bit multiply [prod1 prod0] = a * b
            // Compute the product mod 2**256 and mod 2**256 - 1
            // then use the Chinese Remainder Theorem to reconstruct
            // the 512 bit result. The result is stored in two 256
            // variables such that product = prod1 * 2**256 + prod0
            uint256 prod0; // Least significant 256 bits of the product
            uint256 prod1; // Most significant 256 bits of the product
            assembly {
                let mm := mulmod(a, b, not(0))
                prod0 := mul(a, b)
                prod1 := sub(sub(mm, prod0), lt(mm, prod0))
            }

            // Handle non-overflow cases, 256 by 256 division
            if (prod1 == 0) {
                require(denominator > 0);
                assembly {
                    result := div(prod0, denominator)
                }
                return result;
            }

            // Make sure the result is less than 2**256.
            // Also prevents denominator == 0
            require(denominator > prod1);

            ///////////////////////////////////////////////
            // 512 by 256 division.
            ///////////////////////////////////////////////

            // Make division exact by subtracting the remainder from [prod1 prod0]
            // Compute remainder using mulmod
            uint256 remainder;
            assembly {
                remainder := mulmod(a, b, denominator)
            }
            // Subtract 256 bit number from 512 bit number
            assembly {
                prod1 := sub(prod1, gt(remainder, prod0))
                prod0 := sub(prod0, remainder)
            }

            // Factor powers of two out of denominator
            // Compute largest power of two divisor of denominator.
            // Always >= 1.
            // diff: original uint256 twos = -denominator & denominator;
            uint256 twos = uint256(-int256(denominator)) & denominator;
            // Divide denominator by power of two
            assembly {
                denominator := div(denominator, twos)
            }

            // Divide [prod1 prod0] by the factors of two
            assembly {
                prod0 := div(prod0, twos)
            }
            // Shift in bits from prod1 into prod0. For this we need
            // to flip `twos` such that it is 2**256 / twos.
            // If twos is zero, then it becomes one
            assembly {
                twos := add(div(sub(0, twos), twos), 1)
            }
            prod0 |= prod1 * twos;

            // Invert denominator mod 2**256
            // Now that denominator is an odd number, it has an inverse
            // modulo 2**256 such that denominator * inv = 1 mod 2**256.
            // Compute the inverse by starting with a seed that is correct
            // correct for four bits. That is, denominator * inv = 1 mod 2**4
            uint256 inv = (3 * denominator) ^ 2;
            // Now use Newton-Raphson iteration to improve the precision.
            // Thanks to Hensel's lifting lemma, this also works in modular
            // arithmetic, doubling the correct bits in each step.
            inv *= 2 - denominator * inv; // inverse mod 2**8
            inv *= 2 - denominator * inv; // inverse mod 2**16
            inv *= 2 - denominator * inv; // inverse mod 2**32
            inv *= 2 - denominator * inv; // inverse mod 2**64
            inv *= 2 - denominator * inv; // inverse mod 2**128
            inv *= 2 - denominator * inv; // inverse mod 2**256

            // Because the division is now exact we can divide by multiplying
            // with the modular inverse of denominator. This will give us the
            // correct result modulo 2**256. Since the precoditions guarantee
            // that the outcome is less than 2**256, this is the final result.
            // We don't need to compute the high bits of the result and prod1
            // is no longer required.
            result = prod0 * inv;
            return result;
        }
    }

    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
    /// @param a The multiplicand
    /// @param b The multiplier
    /// @param denominator The divisor
    /// @return result The 256-bit result
    function mulDivRoundingUp(
        uint256 a,
        uint256 b,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        // diff: original lib works under 0.7.6 with overflows enabled
        unchecked {
            result = mulDiv(a, b, denominator);
            if (mulmod(a, b, denominator) > 0) {
                require(result < type(uint256).max);
                result++;
            }
        }
    }
}",1308
RealWorld_BA_58_YearnVault_RealWord_20240821193700.log,58,YearnVault,19178,5425,24603,87.0,0.20439,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/external/aave/ILendingPool.sol"";
import ""./interfaces/external/yearn/IYearnVault.sol"";
import ""./interfaces/IYearnVaultGovernance.sol"";
import ""./Vault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Vault that interfaces Yearn protocol in the integration layer.
/// @dev Notes:
/// ### TVL
///
/// The TVL of the vault is cached and updated after each deposit withdraw.
/// So essentially `tvl` call doesn't take into account accrued interest / donations to Yearn since the
/// last `deposit` / `withdraw`
///
/// ### yTokens
/// yTokens are fixed at the token creation and addresses are taken from YearnVault governance and if missing there
/// - in YearnVaultRegistry.
/// So essentially each yToken is fixed for life of the YearnVault. If the yToken is missing for some vaultToken,
/// the YearnVault cannot be created.
///
/// ### Push / Pull
/// There are some deposit limits imposed by Yearn vaults.
/// The contract's vaultTokens are fully allowed to corresponding yTokens.

contract YearnVault is Vault {
    address[] private _yTokens;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance for this vault
    /// @param vaultTokens_ ERC20 tokens under Vault management
    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)
        Vault(vaultGovernance_, vaultTokens_)
    {
        _yTokens = new address[](vaultTokens_.length);
        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            _yTokens[i] = IYearnVaultGovernance(address(vaultGovernance_)).yTokenForToken(_vaultTokens[i]);
            require(_yTokens[i] != address(0), ""YV"");
        }
    }

    /// @notice Yearn protocol vaults used by this contract
    function yTokens() external view returns (address[] memory) {
        return _yTokens;
    }

    /// @inheritdoc Vault
    function tvl() public view override returns (uint256[] memory tokenAmounts) {
        address[] memory tokens = _vaultTokens;
        tokenAmounts = new uint256[](tokens.length);
        for (uint256 i = 0; i < _yTokens.length; i++) {
            IYearnVault yToken = IYearnVault(_yTokens[i]);
            tokenAmounts[i] = (yToken.balanceOf(address(this)) * yToken.pricePerShare()) / (10**yToken.decimals());
        }
    }

    function _push(uint256[] memory tokenAmounts, bytes memory)
        internal
        override
        returns (uint256[] memory actualTokenAmounts)
    {
        address[] memory tokens = _vaultTokens;
        for (uint256 i = 0; i < _yTokens.length; i++) {
            if (tokenAmounts[i] == 0) {
                continue;
            }

            address token = tokens[i];
            IYearnVault yToken = IYearnVault(_yTokens[i]);
            _allowTokenIfNecessary(token, address(yToken));
            yToken.deposit(tokenAmounts[i], address(this));
        }
        actualTokenAmounts = tokenAmounts;
    }

    function _pull(
        address to,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) internal override returns (uint256[] memory actualTokenAmounts) {
        uint256 maxLoss = abi.decode(options, (uint256));
        for (uint256 i = 0; i < _yTokens.length; i++) {
            if (tokenAmounts[i] == 0) {
                continue;
            }

            IYearnVault yToken = IYearnVault(_yTokens[i]);
            uint256 yTokenAmount = ((tokenAmounts[i] * (10**yToken.decimals())) / yToken.pricePerShare());
            uint256 balance = yToken.balanceOf(address(this));
            if (yTokenAmount > balance) {
                yTokenAmount = balance;
            }
            if (yTokenAmount == 0) {
                continue;
            }
            yToken.withdraw(yTokenAmount, to, maxLoss);
            (tokenAmounts[i], address(this));
        }
        actualTokenAmounts = tokenAmounts;
    }

    function _allowTokenIfNecessary(address token, address yToken) internal {
        if (IERC20(token).allowance(address(this), yToken) < type(uint256).max / 2) {
            IERC20(token).approve(yToken, type(uint256).max);
        }
    }
}",1006
RealWorld_BA_58_CommonTest_RealWord_20240821201704.log,58,CommonTest,6696,4607,11303,86.0,0.12562,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""../../libraries/CommonLibrary.sol"";

contract CommonTest {
    constructor() {}

    function bubbleSort(address[] memory arr) external pure returns (address[] memory) {
        CommonLibrary.bubbleSort(arr);
        return arr;
    }

    function isSortedAndUnique(address[] memory tokens) external pure returns (bool) {
        return CommonLibrary.isSortedAndUnique(tokens);
    }

    function projectTokenAmountsTest(
        address[] memory tokens,
        address[] memory tokensToProject,
        uint256[] memory tokenAmountsToProject
    ) external pure returns (uint256[] memory) {
        return CommonLibrary.projectTokenAmounts(tokens, tokensToProject, tokenAmountsToProject);
    }

    function splitAmountsTest(uint256[] memory amounts, uint256[][] memory weights)
        external
        pure
        returns (uint256[][] memory)
    {
        return CommonLibrary.splitAmounts(amounts, weights);
    }

    function isContractTest(address addr) external view returns (bool) {
        return CommonLibrary.isContract(addr);
    }
}",239
RealWorld_BA_58_ILendingPool_RealWord_20240822000100.log,58,ILendingPool,66828,5675,72503,118.0,0.44764,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;
pragma experimental ABIEncoderV2;

import {ILendingPoolAddressesProvider} from ""./ILendingPoolAddressesProvider.sol"";
import {DataTypes} from ""./DataTypes.sol"";

interface ILendingPool {
    /**
     * @dev Emitted on deposit()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address initiating the deposit
     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens
     * @param amount The amount deposited
     * @param referral The referral code used
     **/
    event Deposit(
        address indexed reserve,
        address user,
        address indexed onBehalfOf,
        uint256 amount,
        uint16 indexed referral
    );

    /**
     * @dev Emitted on withdraw()
     * @param reserve The address of the underlyng asset being withdrawn
     * @param user The address initiating the withdrawal, owner of aTokens
     * @param to Address that will receive the underlying
     * @param amount The amount to be withdrawn
     **/
    event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);

    /**
     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened
     * @param reserve The address of the underlying asset being borrowed
     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just
     * initiator of the transaction on flashLoan()
     * @param onBehalfOf The address that will be getting the debt
     * @param amount The amount borrowed out
     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable
     * @param borrowRate The numeric rate at which the user has borrowed
     * @param referral The referral code used
     **/
    event Borrow(
        address indexed reserve,
        address user,
        address indexed onBehalfOf,
        uint256 amount,
        uint256 borrowRateMode,
        uint256 borrowRate,
        uint16 indexed referral
    );

    /**
     * @dev Emitted on repay()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The beneficiary of the repayment, getting his debt reduced
     * @param repayer The address of the user initiating the repay(), providing the funds
     * @param amount The amount repaid
     **/
    event Repay(address indexed reserve, address indexed user, address indexed repayer, uint256 amount);

    /**
     * @dev Emitted on swapBorrowRateMode()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user swapping his rate mode
     * @param rateMode The rate mode that the user wants to swap to
     **/
    event Swap(address indexed reserve, address indexed user, uint256 rateMode);

    /**
     * @dev Emitted on setUserUseReserveAsCollateral()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user enabling the usage as collateral
     **/
    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on setUserUseReserveAsCollateral()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user enabling the usage as collateral
     **/
    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on rebalanceStableBorrowRate()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user for which the rebalance has been executed
     **/
    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on flashLoan()
     * @param target The address of the flash loan receiver contract
     * @param initiator The address initiating the flash loan
     * @param asset The address of the asset being flash borrowed
     * @param amount The amount flash borrowed
     * @param premium The fee flash borrowed
     * @param referralCode The referral code used
     **/
    event FlashLoan(
        address indexed target,
        address indexed initiator,
        address indexed asset,
        uint256 amount,
        uint256 premium,
        uint16 referralCode
    );

    /**
     * @dev Emitted when the pause is triggered.
     */
    event Paused();

    /**
     * @dev Emitted when the pause is lifted.
     */
    event Unpaused();

    /**
     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via
     * LendingPoolCollateral manager using a DELEGATECALL
     * This allows to have the events in the generated ABI for LendingPool.
     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation
     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation
     * @param user The address of the borrower getting liquidated
     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover
     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator
     * @param liquidator The address of the liquidator
     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants
     * to receive the underlying collateral asset directly
     **/
    event LiquidationCall(
        address indexed collateralAsset,
        address indexed debtAsset,
        address indexed user,
        uint256 debtToCover,
        uint256 liquidatedCollateralAmount,
        address liquidator,
        bool receiveAToken
    );

    /**
     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared
     * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,
     * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it
     * gets added to the LendingPool ABI
     * @param reserve The address of the underlying asset of the reserve
     * @param liquidityRate The new liquidity rate
     * @param stableBorrowRate The new stable borrow rate
     * @param variableBorrowRate The new variable borrow rate
     * @param liquidityIndex The new liquidity index
     * @param variableBorrowIndex The new variable borrow index
     **/
    event ReserveDataUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    /**
     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.
     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC
     * @param asset The address of the underlying asset to deposit
     * @param amount The amount to be deposited
     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user
     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens
     *   is a different wallet
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     **/
    function deposit(
        address asset,
        uint256 amount,
        address onBehalfOf,
        uint16 referralCode
    ) external;

    /**
     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned
     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC
     * @param asset The address of the underlying asset to withdraw
     * @param amount The underlying amount to be withdrawn
     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance
     * @param to Address that will receive the underlying, same as msg.sender if the user
     *   wants to receive it on his own wallet, or a different address if the beneficiary is a
     *   different wallet
     * @return The final amount withdrawn
     **/
    function withdraw(
        address asset,
        uint256 amount,
        address to
    ) external returns (uint256);

    /**
     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower
     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the
     * corresponding debt token (StableDebtToken or VariableDebtToken)
     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet
     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`
     * @param asset The address of the underlying asset to borrow
     * @param amount The amount to be borrowed
     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself
     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator
     * if he has been given credit delegation allowance
     **/
    function borrow(
        address asset,
        uint256 amount,
        uint256 interestRateMode,
        uint16 referralCode,
        address onBehalfOf
    ) external;

    /**
     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned
     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address
     * @param asset The address of the borrowed underlying asset previously borrowed
     * @param amount The amount to repay
     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`
     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable
     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the
     * user calling the function if he wants to reduce/remove his own debt, or the address of any other
     * other borrower whose debt should be removed
     * @return The final amount repaid
     **/
    function repay(
        address asset,
        uint256 amount,
        uint256 rateMode,
        address onBehalfOf
    ) external returns (uint256);

    /**
     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa
     * @param asset The address of the underlying asset borrowed
     * @param rateMode The rate mode that the user wants to swap to
     **/
    function swapBorrowRateMode(address asset, uint256 rateMode) external;

    /**
     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.
     * - Users can be rebalanced if the following conditions are satisfied:
     *     1. Usage ratio is above 95%
     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been
     *        borrowed at a stable rate and depositors are not earning enough
     * @param asset The address of the underlying asset borrowed
     * @param user The address of the user to be rebalanced
     **/
    function rebalanceStableBorrowRate(address asset, address user) external;

    /**
     * @dev Allows depositors to enable/disable a specific deposited asset as collateral
     * @param asset The address of the underlying asset deposited
     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise
     **/
    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;

    /**
     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1
     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives
     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk
     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation
     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation
     * @param user The address of the borrower getting liquidated
     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover
     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants
     * to receive the underlying collateral asset directly
     **/
    function liquidationCall(
        address collateralAsset,
        address debtAsset,
        address user,
        uint256 debtToCover,
        bool receiveAToken
    ) external;

    /**
     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,
     * as long as the amount taken plus a fee is returned.
     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.
     * For further details please visit https://developers.aave.com
     * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface
     * @param assets The addresses of the assets being flash-borrowed
     * @param amounts The amounts amounts being flash-borrowed
     * @param modes Types of the debt to open if the flash loan is not returned:
     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver
     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address
     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address
     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2
     * @param params Variadic packed params to pass to the receiver as extra information
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     **/
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata modes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;

    /**
     * @dev Returns the user account data across all the reserves
     * @param user The address of the user
     * @return totalCollateralETH the total collateral in ETH of the user
     * @return totalDebtETH the total debt in ETH of the user
     * @return availableBorrowsETH the borrowing power left of the user
     * @return currentLiquidationThreshold the liquidation threshold of the user
     * @return ltv the loan to value of the user
     * @return healthFactor the current health factor of the user
     **/
    function getUserAccountData(address user)
        external
        view
        returns (
            uint256 totalCollateralETH,
            uint256 totalDebtETH,
            uint256 availableBorrowsETH,
            uint256 currentLiquidationThreshold,
            uint256 ltv,
            uint256 healthFactor
        );

    function initReserve(
        address reserve,
        address aTokenAddress,
        address stableDebtAddress,
        address variableDebtAddress,
        address interestRateStrategyAddress
    ) external;

    function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;

    function setConfiguration(address reserve, uint256 configuration) external;

    /**
     * @dev Returns the configuration of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The configuration of the reserve
     **/
    function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);

    /**
     * @dev Returns the configuration of the user across all the reserves
     * @param user The user address
     * @return The configuration of the user
     **/
    function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);

    /**
     * @dev Returns the normalized income normalized income of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The reserve's normalized income
     */
    function getReserveNormalizedIncome(address asset) external view returns (uint256);

    /**
     * @dev Returns the normalized variable debt per unit of asset
     * @param asset The address of the underlying asset of the reserve
     * @return The reserve normalized variable debt
     */
    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);

    /**
     * @dev Returns the state and configuration of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The state of the reserve
     **/
    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);

    function finalizeTransfer(
        address asset,
        address from,
        address to,
        uint256 amount,
        uint256 balanceFromAfter,
        uint256 balanceToBefore
    ) external;

    function getReservesList() external view returns (address[] memory);

    function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);

    function setPause(bool val) external;

    function paused() external view returns (bool);
}",3997
RealWorld_BA_58_ERC20VaultTestFactory_RealWord_20240821230116.log,58,ERC20VaultTestFactory,6414,5502,11916,97.0,0.14211,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../interfaces/IVaultFactory.sol"";
import ""../interfaces/IVaultGovernance.sol"";
import ""./ERC20VaultTest.sol"";

contract ERC20VaultTestFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    function setVaultGovernance(address newVaultGovernance) public {
        vaultGovernance = IVaultGovernance(newVaultGovernance);
    }

    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ""VG"");
        ERC20VaultTest vault = new ERC20VaultTest(vaultGovernance, vaultTokens);
        return IVault(vault);
    }
}",186
RealWorld_BA_58_UniV3VaultFactory_RealWord_20240821192836.log,58,UniV3VaultFactory,7829,5898,13727,100.0,0.157105,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.9;

import ""./interfaces/IVaultFactory.sol"";
import ""./UniV3Vault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Helper contract for UniV3VaultGovernance that can create new UniV3 Vaults.
contract UniV3VaultFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind
    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    /// @notice Deploy a new vault.
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Should equal UniV3 pool fee
    function deployVault(address[] memory vaultTokens, bytes memory options) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        uint256 fee = abi.decode(options, (uint256));
        UniV3Vault vault = new UniV3Vault(vaultGovernance, vaultTokens, uint24(fee));
        return IVault(vault);
    }
}",271
RealWorld_BA_58_LpIssuerFactory_RealWord_20240821221018.log,58,LpIssuerFactory,7304,5262,12566,110.0,0.14176,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IVaultFactory.sol"";
import ""./LpIssuer.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Helper contract for LpIssuerGovernance that can create new LpIssuers.
contract LpIssuerFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind
    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    /// @inheritdoc IVaultFactory
    function deployVault(address[] memory vaultTokens, bytes memory options) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        (string memory name, string memory symbol) = abi.decode(options, (string, string));
        LpIssuer vault = new LpIssuer(vaultGovernance, vaultTokens, name, symbol);
        return IVault(address(vault));
    }
}",244
RealWorld_BA_58_ProtocolGovernance_RealWord_20240821224424.log,58,ProtocolGovernance,35402,5041,40443,91.0,0.27783,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./DefaultAccessControl.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Governance that manages all params common for Mellow Permissionless Vaults protocol.
contract ProtocolGovernance is IProtocolGovernance, DefaultAccessControl {
    using EnumerableSet for EnumerableSet.AddressSet;
    uint256 public constant MAX_GOVERNANCE_DELAY = 7 days;

    EnumerableSet.AddressSet private _claimAllowlist;
    address[] private _pendingClaimAllowlistAdd;
    uint256 public pendingClaimAllowlistAddTimestamp;

    address[] private _tokenWhitelist;
    address[] private _pendingTokenWhitelistAdd;
    uint256 private _numberOfValidTokens;
    mapping(address => bool) _tokensAllowed;
    mapping(address => bool) _tokenEverAdded;
    uint256 public pendingTokenWhitelistAddTimestamp;

    EnumerableSet.AddressSet private _vaultGovernances;
    address[] private _pendingVaultGovernancesAdd;
    uint256 public pendingVaultGovernancesAddTimestamp;

    IProtocolGovernance.Params public params;
    Params public pendingParams;

    uint256 public pendingParamsTimestamp;

    /// @notice Creates a new contract.
    /// @param admin Initial admin of the contract
    constructor(address admin) DefaultAccessControl(admin) {
        _tokenWhitelist = new address[](0);
        _numberOfValidTokens = 0;
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @inheritdoc IProtocolGovernance
    function claimAllowlist() external view returns (address[] memory) {
        uint256 l = _claimAllowlist.length();
        address[] memory res = new address[](l);
        for (uint256 i = 0; i < l; i++) {
            res[i] = _claimAllowlist.at(i);
        }
        return res;
    }

    /// @inheritdoc IProtocolGovernance
    function tokenWhitelist() external view returns (address[] memory) {
        uint256 l = _tokenWhitelist.length;
        address[] memory res = new address[](_numberOfValidTokens);
        uint256 j = 0;
        for (uint256 i = 0; i < l; i++) {
            if (!_tokensAllowed[_tokenWhitelist[i]] && _tokenEverAdded[_tokenWhitelist[i]]) {
                continue;
            }
            res[j] = _tokenWhitelist[i];
            j += 1;
        }
        return res;
    }

    /// @inheritdoc IProtocolGovernance
    function vaultGovernances() external view returns (address[] memory) {
        uint256 l = _vaultGovernances.length();
        address[] memory res = new address[](l);
        for (uint256 i = 0; i < l; i++) {
            res[i] = _vaultGovernances.at(i);
        }
        return res;
    }

    /// @inheritdoc IProtocolGovernance
    function pendingClaimAllowlistAdd() external view returns (address[] memory) {
        return _pendingClaimAllowlistAdd;
    }

    /// @inheritdoc IProtocolGovernance
    function pendingTokenWhitelistAdd() external view returns (address[] memory) {
        return _pendingTokenWhitelistAdd;
    }

    /// @inheritdoc IProtocolGovernance
    function pendingVaultGovernancesAdd() external view returns (address[] memory) {
        return _pendingVaultGovernancesAdd;
    }

    /// @inheritdoc IProtocolGovernance
    function isAllowedToClaim(address addr) external view returns (bool) {
        return _claimAllowlist.contains(addr);
    }

    /// @inheritdoc IProtocolGovernance
    function isAllowedToken(address addr) external view returns (bool) {
        return _tokenEverAdded[addr] && _tokensAllowed[addr];
    }

    /// @inheritdoc IProtocolGovernance
    function isVaultGovernance(address addr) external view returns (bool) {
        return _vaultGovernances.contains(addr);
    }

    /// @inheritdoc IProtocolGovernance
    function permissionless() external view returns (bool) {
        return params.permissionless;
    }

    /// @inheritdoc IProtocolGovernance
    function maxTokensPerVault() external view returns (uint256) {
        return params.maxTokensPerVault;
    }

    /// @inheritdoc IProtocolGovernance
    function governanceDelay() external view returns (uint256) {
        return params.governanceDelay;
    }

    /// @inheritdoc IProtocolGovernance
    function protocolTreasury() external view returns (address) {
        return params.protocolTreasury;
    }

    // -------------------  PUBLIC, MUTATING, GOVERNANCE, DELAY  -------------------

    /// @inheritdoc IProtocolGovernance
    function setPendingClaimAllowlistAdd(address[] calldata addresses) external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        _pendingClaimAllowlistAdd = addresses;
        pendingClaimAllowlistAddTimestamp = block.timestamp + params.governanceDelay;
    }

    /// @inheritdoc IProtocolGovernance
    function removeFromClaimAllowlist(address addr) external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        if (!_claimAllowlist.contains(addr)) {
            return;
        }
        _claimAllowlist.remove(addr);
    }

    /// @inheritdoc IProtocolGovernance
    function setPendingTokenWhitelistAdd(address[] calldata addresses) external {
        require(isAdmin(msg.sender), ""ADM"");
        _pendingTokenWhitelistAdd = addresses;
        pendingTokenWhitelistAddTimestamp = block.timestamp + params.governanceDelay;
    }

    /// @inheritdoc IProtocolGovernance
    function removeFromTokenWhitelist(address addr) external {
        require(isAdmin(msg.sender), ""ADM"");
        _tokensAllowed[addr] = false;
        if (_tokenEverAdded[addr]) {
            --_numberOfValidTokens;
        }
    }

    /// @inheritdoc IProtocolGovernance
    function setPendingVaultGovernancesAdd(address[] calldata addresses) external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        _pendingVaultGovernancesAdd = addresses;
        pendingVaultGovernancesAddTimestamp = block.timestamp + params.governanceDelay;
    }

    /// @inheritdoc IProtocolGovernance
    function removeFromVaultGovernances(address addr) external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        if (!_vaultGovernances.contains(addr)) {
            return;
        }
        _vaultGovernances.remove(addr);
    }

    /// @inheritdoc IProtocolGovernance
    function setPendingParams(IProtocolGovernance.Params memory newParams) external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        require(params.governanceDelay <= MAX_GOVERNANCE_DELAY, ExceptionsLibrary.MAX_GOVERNANCE_DELAY);
        pendingParams = newParams;
        pendingParamsTimestamp = block.timestamp + params.governanceDelay;
    }

    // -------------------  PUBLIC, MUTATING, GOVERNANCE, IMMEDIATE  -------------------

    /// @inheritdoc IProtocolGovernance
    function commitClaimAllowlistAdd() external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        require(
            (block.timestamp >= pendingClaimAllowlistAddTimestamp) && (pendingClaimAllowlistAddTimestamp > 0),
            ExceptionsLibrary.TIMESTAMP
        );
        for (uint256 i = 0; i < _pendingClaimAllowlistAdd.length; i++) {
            _claimAllowlist.add(_pendingClaimAllowlistAdd[i]);
        }
        delete _pendingClaimAllowlistAdd;
        delete pendingClaimAllowlistAddTimestamp;
    }

    /// @inheritdoc IProtocolGovernance
    function commitTokenWhitelistAdd() external {
        require(isAdmin(msg.sender), ""ADM"");
        require(
            (block.timestamp >= pendingTokenWhitelistAddTimestamp) && (pendingTokenWhitelistAddTimestamp > 0),
            ""TS""
        );
        for (uint256 i = 0; i < _pendingTokenWhitelistAdd.length; i++) {
            if (!_tokenEverAdded[_pendingTokenWhitelistAdd[i]]) {
                _numberOfValidTokens += 1;
                _tokensAllowed[_pendingTokenWhitelistAdd[i]] = true;
                _tokenWhitelist.push(_pendingTokenWhitelistAdd[i]);
                _tokenEverAdded[_pendingTokenWhitelistAdd[i]] = true;
            } else {
                if (!_tokensAllowed[_pendingTokenWhitelistAdd[i]]) {
                    _numberOfValidTokens += 1;
                    _tokensAllowed[_pendingTokenWhitelistAdd[i]] = true;
                }
            }
        }
        delete _pendingTokenWhitelistAdd;
        delete pendingTokenWhitelistAddTimestamp;
    }

    /// @inheritdoc IProtocolGovernance
    function commitVaultGovernancesAdd() external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        require(
            (block.timestamp >= pendingVaultGovernancesAddTimestamp) && (pendingVaultGovernancesAddTimestamp > 0),
            ExceptionsLibrary.TIMESTAMP
        );
        for (uint256 i = 0; i < _pendingVaultGovernancesAdd.length; i++) {
            _vaultGovernances.add(_pendingVaultGovernancesAdd[i]);
        }
        delete _pendingVaultGovernancesAdd;
        delete pendingVaultGovernancesAddTimestamp;
    }

    /// @inheritdoc IProtocolGovernance
    function commitParams() external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        require(block.timestamp >= pendingParamsTimestamp, ExceptionsLibrary.TIMESTAMP);
        require(pendingParams.maxTokensPerVault > 0 || pendingParams.governanceDelay > 0, ExceptionsLibrary.EMPTY_PARAMS); // sanity check for empty params
        params = pendingParams;
        delete pendingParams;
        delete pendingParamsTimestamp;
    }
}",2027
RealWorld_BA_58_IGatewayVaultGovernance_RealWord_20240821213659.log,58,IGatewayVaultGovernance,10913,5475,16388,110.0,0.164065,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";

interface IGatewayVaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param redirects Redirects[i] is the nft of subvault that will receive deposit to i-th subvault. If the array is empty there is no redirects
    struct DelayedStrategyParams {
        uint256[] redirects;
    }
    /// @notice Params that could be changed by Strategy or Protocol Governance immediately.
    /// @param limits Token limits for the vault
    struct StrategyParams {
        uint256[] limits;
    }

    /// @notice Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    function delayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Delayed Strategy Params staged for commit after delay.
    /// @param nft VaultRegistry NFT of the vault
    function stagedDelayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Strategy Params.
    /// @param nft VaultRegistry NFT of the vault
    function strategyParams(uint256 nft) external view returns (StrategyParams memory);

    /// @notice Stage Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params
    function stageDelayedStrategyParams(uint256 nft, DelayedStrategyParams calldata params) external;

    /// @notice Commit Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedStrategyParamsTimestamp
    /// @param nft VaultRegistry NFT of the vault
    function commitDelayedStrategyParams(uint256 nft) external;

    /// @notice Set Strategy params, i.e. Params that could be changed by Strategy or Protocol Governance immediately.
    /// @param nft Nft of the vault
    /// @param params New params
    function setStrategyParams(uint256 nft, StrategyParams calldata params) external;
}",494
RealWorld_BA_58_UniV3Trader_RealWord_20240821202141.log,58,UniV3Trader,27118,6225,33343,113.0,0.26009,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../interfaces/external/univ3/ISwapRouter.sol"";
import ""./libraries/TraderExceptionsLibrary.sol"";
import ""./Trader.sol"";

/// @notice Contract that can execute ERC20 swaps on Uniswap V3
contract UniV3Trader is Trader, ITrader {
    using SafeERC20 for IERC20;

    struct Options {
        uint24 fee;
        uint160 sqrtPriceLimitX96;
        uint256 deadline;
        uint256 limitAmount;
    }

    struct PathItemOptions {
        uint24 fee;
    }

    ISwapRouter public swapRouter;

    constructor(address _swapRouter) {
        swapRouter = ISwapRouter(_swapRouter);
    }

    /// @inheritdoc ITrader
    function swapExactInput(
        uint256,
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        bytes memory options
    ) external returns (uint256) {
        Options memory options_ = abi.decode(options, (Options));
        if (path.length == 1) {
            return _swapExactInputSingle(path[0].token0, path[0].token1, amount, recipient, options_);
        } else {
            require(_validatePathLinked(path), TraderExceptionsLibrary.INVALID_TRADE_PATH_EXCEPTION);
            return _swapExactInputMultihop(amount, recipient, path, options_);
        }
    }

    /// @inheritdoc ITrader
    function swapExactOutput(
        uint256,
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        bytes memory options
    ) external returns (uint256) {
        Options memory options_ = abi.decode(options, (Options));
        if (path.length == 0) {
            return _swapExactOutputSingle(path[0].token0, path[0].token1, amount, recipient, options_);
        } else {
            require(_validatePathLinked(path), TraderExceptionsLibrary.INVALID_TRADE_PATH_EXCEPTION);
            return _swapExactOutputMultihop(amount, recipient, path, options_);
        }
    }

    function _validatePathLinked(PathItem[] memory path) internal pure returns (bool result) {
        if (path.length == 0) return false;
        for (uint256 i = 0; i < path.length - 1; ++i) if (path[0].token1 != path[i + 1].token0) return false;
        return true;
    }

    function _swapExactInputSingle(
        address input,
        address output,
        uint256 amount,
        address recipient,
        Options memory options
    ) internal returns (uint256 amountOut) {
        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({
            tokenIn: input,
            tokenOut: output,
            fee: options.fee,
            recipient: recipient,
            deadline: options.deadline,
            amountIn: amount,
            amountOutMinimum: options.limitAmount,
            sqrtPriceLimitX96: options.sqrtPriceLimitX96
        });
        IERC20(input).safeTransferFrom(msg.sender, address(this), amount);
        _approveERC20TokenIfNecessary(input, address(swapRouter));
        amountOut = swapRouter.exactInputSingle(params);
    }

    function _swapExactOutputSingle(
        address input,
        address output,
        uint256 amount,
        address recipient,
        Options memory options
    ) internal returns (uint256 amountIn) {
        ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter.ExactOutputSingleParams({
            tokenIn: input,
            tokenOut: output,
            fee: options.fee,
            recipient: recipient,
            deadline: options.deadline,
            amountOut: amount,
            amountInMaximum: options.limitAmount,
            sqrtPriceLimitX96: options.sqrtPriceLimitX96
        });
        IERC20(input).safeTransferFrom(msg.sender, address(this), options.limitAmount);
        _approveERC20TokenIfNecessary(input, address(swapRouter));
        amountIn = swapRouter.exactOutputSingle(params);
        if (amountIn < options.limitAmount)
            IERC20(input).safeTransferFrom(address(this), recipient, options.limitAmount - amountIn);
    }

    function _swapExactInputMultihop(
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        Options memory options
    ) internal returns (uint256 amountOut) {
        address input = path[0].token0;
        ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({
            path: _makeMultihopPath(path),
            recipient: recipient,
            deadline: options.deadline,
            amountIn: amount,
            amountOutMinimum: options.limitAmount
        });
        IERC20(input).safeTransferFrom(msg.sender, address(this), amount);
        _approveERC20TokenIfNecessary(input, address(swapRouter));
        amountOut = swapRouter.exactInput(params);
    }

    function _swapExactOutputMultihop(
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        Options memory options
    ) internal returns (uint256 amountIn) {
        address input = path[0].token0;
        ISwapRouter.ExactOutputParams memory params = ISwapRouter.ExactOutputParams({
            path: _reverseBytes(_makeMultihopPath(path)),
            recipient: recipient,
            deadline: options.deadline,
            amountOut: amount,
            amountInMaximum: options.limitAmount
        });
        IERC20(input).safeTransferFrom(msg.sender, address(this), options.limitAmount);
        _approveERC20TokenIfNecessary(input, address(swapRouter));
        amountIn = swapRouter.exactOutput(params);
        if (amountIn < options.limitAmount)
            IERC20(input).safeTransferFrom(address(this), recipient, options.limitAmount - amountIn);
    }

    function _reverseBytes(bytes memory input) internal pure returns (bytes memory output) {
        for (uint256 i = 0; i < input.length; ++i) output[i] = input[input.length - 1 - i];
    }

    function _makeMultihopPath(PathItem[] memory path) internal pure returns (bytes memory) {
        bytes memory result;
        for (uint256 i = 0; i < path.length; ++i) {
            PathItemOptions memory pathItemOptions = abi.decode(path[i].options, (PathItemOptions));
            result = bytes.concat(result, abi.encodePacked(path[i].token0, abi.encodePacked(pathItemOptions.fee)));
        }
        result = bytes.concat(result, abi.encodePacked(path[path.length - 1].token1));
        return result;
    }
}",1457
RealWorld_BA_58_GatewayVaultFactory_RealWord_20240821223052.log,58,GatewayVaultFactory,6799,4937,11736,95.0,0.132735,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IVaultFactory.sol"";
import ""./GatewayVault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Helper contract for GatewayVaultGovernance that can create new Gateway Vaults.
contract GatewayVaultFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind
    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    /// @inheritdoc IVaultFactory
    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        GatewayVault gatewayVault = new GatewayVault(vaultGovernance, vaultTokens);
        return IVault(gatewayVault);
    }
}",213
RealWorld_BA_58_ILendingPoolAddressesProvider_RealWord_20240821215049.log,58,ILendingPoolAddressesProvider,10578,4888,15466,100.0,0.15065,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

/**
 * @title LendingPoolAddressesProvider contract
 * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles
 * - Acting also as factory of proxies and admin of those, so with right to change its implementations
 * - Owned by the Aave Governance
 * @author Aave
 **/
interface ILendingPoolAddressesProvider {
    event MarketIdSet(string newMarketId);
    event LendingPoolUpdated(address indexed newAddress);
    event ConfigurationAdminUpdated(address indexed newAddress);
    event EmergencyAdminUpdated(address indexed newAddress);
    event LendingPoolConfiguratorUpdated(address indexed newAddress);
    event LendingPoolCollateralManagerUpdated(address indexed newAddress);
    event PriceOracleUpdated(address indexed newAddress);
    event LendingRateOracleUpdated(address indexed newAddress);
    event ProxyCreated(bytes32 id, address indexed newAddress);
    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);

    function getMarketId() external view returns (string memory);

    function setMarketId(string calldata marketId) external;

    function setAddress(bytes32 id, address newAddress) external;

    function setAddressAsProxy(bytes32 id, address impl) external;

    function getAddress(bytes32 id) external view returns (address);

    function getLendingPool() external view returns (address);

    function setLendingPoolImpl(address pool) external;

    function getLendingPoolConfigurator() external view returns (address);

    function setLendingPoolConfiguratorImpl(address configurator) external;

    function getLendingPoolCollateralManager() external view returns (address);

    function setLendingPoolCollateralManager(address manager) external;

    function getPoolAdmin() external view returns (address);

    function setPoolAdmin(address admin) external;

    function getEmergencyAdmin() external view returns (address);

    function setEmergencyAdmin(address admin) external;

    function getPriceOracle() external view returns (address);

    function setPriceOracle(address priceOracle) external;

    function getLendingRateOracle() external view returns (address);

    function setLendingRateOracle(address lendingRateOracle) external;
}",462
RealWorld_BA_58_AaveVaultGovernanceTest_RealWord_20240821195950.log,58,AaveVaultGovernanceTest,4967,4461,9428,81.0,0.114055,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../interfaces/IAaveVaultGovernance.sol"";
import ""../AaveVaultGovernance.sol"";
import ""../VaultGovernance.sol"";

contract AaveVaultGovernanceTest is AaveVaultGovernance {
    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)
        AaveVaultGovernance(internalParams_, delayedProtocolParams_)
    {
        delete _delayedProtocolParams;
    }
}",106
RealWorld_BA_58_ILendingPool_RealWord_20240821214850.log,58,ILendingPool,66604,5540,72144,117.0,0.44382,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;
pragma experimental ABIEncoderV2;

import {ILendingPoolAddressesProvider} from ""./ILendingPoolAddressesProvider.sol"";
import {DataTypes} from ""./DataTypes.sol"";

interface ILendingPool {
    /**
     * @dev Emitted on deposit()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address initiating the deposit
     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens
     * @param amount The amount deposited
     * @param referral The referral code used
     **/
    event Deposit(
        address indexed reserve,
        address user,
        address indexed onBehalfOf,
        uint256 amount,
        uint16 indexed referral
    );

    /**
     * @dev Emitted on withdraw()
     * @param reserve The address of the underlyng asset being withdrawn
     * @param user The address initiating the withdrawal, owner of aTokens
     * @param to Address that will receive the underlying
     * @param amount The amount to be withdrawn
     **/
    event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);

    /**
     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened
     * @param reserve The address of the underlying asset being borrowed
     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just
     * initiator of the transaction on flashLoan()
     * @param onBehalfOf The address that will be getting the debt
     * @param amount The amount borrowed out
     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable
     * @param borrowRate The numeric rate at which the user has borrowed
     * @param referral The referral code used
     **/
    event Borrow(
        address indexed reserve,
        address user,
        address indexed onBehalfOf,
        uint256 amount,
        uint256 borrowRateMode,
        uint256 borrowRate,
        uint16 indexed referral
    );

    /**
     * @dev Emitted on repay()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The beneficiary of the repayment, getting his debt reduced
     * @param repayer The address of the user initiating the repay(), providing the funds
     * @param amount The amount repaid
     **/
    event Repay(address indexed reserve, address indexed user, address indexed repayer, uint256 amount);

    /**
     * @dev Emitted on swapBorrowRateMode()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user swapping his rate mode
     * @param rateMode The rate mode that the user wants to swap to
     **/
    event Swap(address indexed reserve, address indexed user, uint256 rateMode);

    /**
     * @dev Emitted on setUserUseReserveAsCollateral()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user enabling the usage as collateral
     **/
    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on setUserUseReserveAsCollateral()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user enabling the usage as collateral
     **/
    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on rebalanceStableBorrowRate()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user for which the rebalance has been executed
     **/
    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on flashLoan()
     * @param target The address of the flash loan receiver contract
     * @param initiator The address initiating the flash loan
     * @param asset The address of the asset being flash borrowed
     * @param amount The amount flash borrowed
     * @param premium The fee flash borrowed
     * @param referralCode The referral code used
     **/
    event FlashLoan(
        address indexed target,
        address indexed initiator,
        address indexed asset,
        uint256 amount,
        uint256 premium,
        uint16 referralCode
    );

    /**
     * @dev Emitted when the pause is triggered.
     */
    event Paused();

    /**
     * @dev Emitted when the pause is lifted.
     */
    event Unpaused();

    /**
     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via
     * LendingPoolCollateral manager using a DELEGATECALL
     * This allows to have the events in the generated ABI for LendingPool.
     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation
     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation
     * @param user The address of the borrower getting liquidated
     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover
     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator
     * @param liquidator The address of the liquidator
     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants
     * to receive the underlying collateral asset directly
     **/
    event LiquidationCall(
        address indexed collateralAsset,
        address indexed debtAsset,
        address indexed user,
        uint256 debtToCover,
        uint256 liquidatedCollateralAmount,
        address liquidator,
        bool receiveAToken
    );

    /**
     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared
     * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,
     * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it
     * gets added to the LendingPool ABI
     * @param reserve The address of the underlying asset of the reserve
     * @param liquidityRate The new liquidity rate
     * @param stableBorrowRate The new stable borrow rate
     * @param variableBorrowRate The new variable borrow rate
     * @param liquidityIndex The new liquidity index
     * @param variableBorrowIndex The new variable borrow index
     **/
    event ReserveDataUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    /**
     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.
     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC
     * @param asset The address of the underlying asset to deposit
     * @param amount The amount to be deposited
     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user
     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens
     *   is a different wallet
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     **/
    function deposit(
        address asset,
        uint256 amount,
        address onBehalfOf,
        uint16 referralCode
    ) external;

    /**
     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned
     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC
     * @param asset The address of the underlying asset to withdraw
     * @param amount The underlying amount to be withdrawn
     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance
     * @param to Address that will receive the underlying, same as msg.sender if the user
     *   wants to receive it on his own wallet, or a different address if the beneficiary is a
     *   different wallet
     * @return The final amount withdrawn
     **/
    function withdraw(
        address asset,
        uint256 amount,
        address to
    ) external returns (uint256);

    /**
     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower
     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the
     * corresponding debt token (StableDebtToken or VariableDebtToken)
     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet
     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`
     * @param asset The address of the underlying asset to borrow
     * @param amount The amount to be borrowed
     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself
     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator
     * if he has been given credit delegation allowance
     **/
    function borrow(
        address asset,
        uint256 amount,
        uint256 interestRateMode,
        uint16 referralCode,
        address onBehalfOf
    ) external;

    /**
     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned
     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address
     * @param asset The address of the borrowed underlying asset previously borrowed
     * @param amount The amount to repay
     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`
     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable
     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the
     * user calling the function if he wants to reduce/remove his own debt, or the address of any other
     * other borrower whose debt should be removed
     * @return The final amount repaid
     **/
    function repay(
        address asset,
        uint256 amount,
        uint256 rateMode,
        address onBehalfOf
    ) external returns (uint256);

    /**
     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa
     * @param asset The address of the underlying asset borrowed
     * @param rateMode The rate mode that the user wants to swap to
     **/
    function swapBorrowRateMode(address asset, uint256 rateMode) external;

    /**
     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.
     * - Users can be rebalanced if the following conditions are satisfied:
     *     1. Usage ratio is above 95%
     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been
     *        borrowed at a stable rate and depositors are not earning enough
     * @param asset The address of the underlying asset borrowed
     * @param user The address of the user to be rebalanced
     **/
    function rebalanceStableBorrowRate(address asset, address user) external;

    /**
     * @dev Allows depositors to enable/disable a specific deposited asset as collateral
     * @param asset The address of the underlying asset deposited
     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise
     **/
    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;

    /**
     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1
     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives
     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk
     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation
     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation
     * @param user The address of the borrower getting liquidated
     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover
     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants
     * to receive the underlying collateral asset directly
     **/
    function liquidationCall(
        address collateralAsset,
        address debtAsset,
        address user,
        uint256 debtToCover,
        bool receiveAToken
    ) external;

    /**
     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,
     * as long as the amount taken plus a fee is returned.
     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.
     * For further details please visit https://developers.aave.com
     * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface
     * @param assets The addresses of the assets being flash-borrowed
     * @param amounts The amounts amounts being flash-borrowed
     * @param modes Types of the debt to open if the flash loan is not returned:
     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver
     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address
     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address
     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2
     * @param params Variadic packed params to pass to the receiver as extra information
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     **/
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata modes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;

    /**
     * @dev Returns the user account data across all the reserves
     * @param user The address of the user
     * @return totalCollateralETH the total collateral in ETH of the user
     * @return totalDebtETH the total debt in ETH of the user
     * @return availableBorrowsETH the borrowing power left of the user
     * @return currentLiquidationThreshold the liquidation threshold of the user
     * @return ltv the loan to value of the user
     * @return healthFactor the current health factor of the user
     **/
    function getUserAccountData(address user)
        external
        view
        returns (
            uint256 totalCollateralETH,
            uint256 totalDebtETH,
            uint256 availableBorrowsETH,
            uint256 currentLiquidationThreshold,
            uint256 ltv,
            uint256 healthFactor
        );

    function initReserve(
        address reserve,
        address aTokenAddress,
        address stableDebtAddress,
        address variableDebtAddress,
        address interestRateStrategyAddress
    ) external;

    function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;

    function setConfiguration(address reserve, uint256 configuration) external;

    /**
     * @dev Returns the configuration of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The configuration of the reserve
     **/
    function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);

    /**
     * @dev Returns the configuration of the user across all the reserves
     * @param user The user address
     * @return The configuration of the user
     **/
    function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);

    /**
     * @dev Returns the normalized income normalized income of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The reserve's normalized income
     */
    function getReserveNormalizedIncome(address asset) external view returns (uint256);

    /**
     * @dev Returns the normalized variable debt per unit of asset
     * @param asset The address of the underlying asset of the reserve
     * @return The reserve normalized variable debt
     */
    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);

    /**
     * @dev Returns the state and configuration of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The state of the reserve
     **/
    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);

    function finalizeTransfer(
        address asset,
        address from,
        address to,
        uint256 amount,
        uint256 balanceFromAfter,
        uint256 balanceToBefore
    ) external;

    function getReservesList() external view returns (address[] memory);

    function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);

    function setPause(bool val) external;

    function paused() external view returns (bool);
}",3997
RealWorld_BA_58_FixedPoint96_RealWord_20240821233216.log,58,FixedPoint96,4725,2923,7648,71.0,0.082085,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title FixedPoint96
/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)
/// @dev Used in SqrtPriceMath.sol
library FixedPoint96 {
    uint8 internal constant RESOLUTION = 96;
    uint256 internal constant Q96 = 0x1000000000000000000000000;
}",103
RealWorld_BA_58_UniV3VaultTestFactory_RealWord_20240821195115.log,58,UniV3VaultTestFactory,6788,5735,12523,121.0,0.14864,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../interfaces/IVaultFactory.sol"";
import ""../interfaces/IVaultGovernance.sol"";
import ""./UniV3VaultTest.sol"";

contract UniV3VaultTestFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    function setVaultGovernance(address newVaultGovernance) public {
        vaultGovernance = IVaultGovernance(newVaultGovernance);
    }

    function deployVault(address[] memory vaultTokens, bytes memory options) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ""VG"");
        uint256 fee = abi.decode(options, (uint256));
        UniV3VaultTest vault = new UniV3VaultTest(vaultGovernance, vaultTokens, uint24(fee));
        return IVault(vault);
    }
}",209
RealWorld_BA_58_IPeripheryImmutableState_RealWord_20240821211152.log,58,IPeripheryImmutableState,4624,3811,8435,83.0,0.09934,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title Immutable state
/// @notice Functions that return immutable state of the router
interface IPeripheryImmutableState {
    /// @return Returns the address of the Uniswap V3 factory
    function factory() external view returns (address);

    /// @return Returns the address of WETH9
    function WETH9() external view returns (address);
}",99
RealWorld_BA_58_VaultRegistry_RealWord_20240821224244.log,58,VaultRegistry,24995,5762,30757,97.0,0.240215,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IVault.sol"";
import ""./interfaces/IVaultFactory.sol"";
import ""./interfaces/IVaultRegistry.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice This contract is used to manage ERC721 NFT for all Vaults.
contract VaultRegistry is IVaultRegistry, ERC721 {
    uint256 private _stagedProtocolGovernanceTimestamp;
    IProtocolGovernance private _protocolGovernance;
    IProtocolGovernance private _stagedProtocolGovernance;

    address[] private _vaults;
    mapping(address => uint256) private _nftIndex;
    mapping(uint256 => address) private _vaultIndex;
    mapping(uint256 => bool) private _locks;
    uint256 private _topNft = 1;

    /// @notice Creates a new contract.
    /// @param name ERC721 token name
    /// @param symbol ERC721 token symbol
    /// @param protocolGovernance_ Reference to ProtocolGovernance
    constructor(
        string memory name,
        string memory symbol,
        IProtocolGovernance protocolGovernance_
    ) ERC721(name, symbol) {
        _protocolGovernance = protocolGovernance_;
    }

    function vaults() external view returns (address[] memory) {
        return _vaults;
    }

    /// @inheritdoc IVaultRegistry
    function vaultForNft(uint256 nft) external view returns (address) {
        return _vaultIndex[nft];
    }

    /// @inheritdoc IVaultRegistry
    function nftForVault(address vault) external view returns (uint256) {
        return _nftIndex[vault];
    }

    /// @inheritdoc IVaultRegistry
    function isLocked(uint256 nft) external view returns (bool) {
        return _locks[nft];
    }

    /// @inheritdoc IVaultRegistry
    function registerVault(address vault, address owner) external returns (uint256 nft) {
        require(_protocolGovernance.isVaultGovernance(msg.sender), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        nft = _topNft;
        _safeMint(owner, nft);
        _vaultIndex[nft] = vault;
        _nftIndex[vault] = nft;
        _vaults.push(vault);
        _topNft += 1;
        emit VaultRegistered(tx.origin, msg.sender, nft, vault, owner);
    }

    /// @inheritdoc IVaultRegistry
    function protocolGovernance() external view returns (IProtocolGovernance) {
        return _protocolGovernance;
    }

    /// @inheritdoc IVaultRegistry
    function stagedProtocolGovernance() external view returns (IProtocolGovernance) {
        return _stagedProtocolGovernance;
    }

    /// @inheritdoc IVaultRegistry
    function stagedProtocolGovernanceTimestamp() external view returns (uint256) {
        return _stagedProtocolGovernanceTimestamp;
    }

    /// @inheritdoc IVaultRegistry
    function vaultsCount() external view returns (uint256) {
        return _vaults.length;
    }

    /// @inheritdoc IVaultRegistry
    function stageProtocolGovernance(IProtocolGovernance newProtocolGovernance) external {
        require(_isProtocolAdmin(_msgSender()), ExceptionsLibrary.ADMIN);
        _stagedProtocolGovernance = newProtocolGovernance;
        _stagedProtocolGovernanceTimestamp = (block.timestamp + _protocolGovernance.governanceDelay());
        emit StagedProtocolGovernance(tx.origin, msg.sender, newProtocolGovernance, _stagedProtocolGovernanceTimestamp);
    }

    /// @inheritdoc IVaultRegistry
    function commitStagedProtocolGovernance() external {
        require(_isProtocolAdmin(_msgSender()), ExceptionsLibrary.ADMIN);
        require(_stagedProtocolGovernanceTimestamp > 0, ExceptionsLibrary.NULL_OR_NOT_INITIALIZED);
        require(block.timestamp >= _stagedProtocolGovernanceTimestamp, ExceptionsLibrary.TIMESTAMP);
        _protocolGovernance = _stagedProtocolGovernance;
        delete _stagedProtocolGovernanceTimestamp;
        emit CommitedProtocolGovernance(tx.origin, msg.sender, _protocolGovernance);
    }

    /// @inheritdoc IVaultRegistry
    function adminApprove(address newAddress, uint256 nft) external {
        require(_isProtocolAdmin(_msgSender()), ExceptionsLibrary.ADMIN);
        IERC721(address(this)).approve(newAddress, nft);
    }

    function lockNft(uint256 nft) external {
        require(ownerOf(nft) == msg.sender, ExceptionsLibrary.TOKEN_OWNER);
        _locks[nft] = true;
        emit TokenLocked(tx.origin, msg.sender, nft);
    }

    function _isProtocolAdmin(address sender) internal view returns (bool) {
        return _protocolGovernance.isAdmin(sender);
    }

    function _beforeTokenTransfer(
        address,
        address,
        uint256 tokenId
    ) internal view override {
        require(!_locks[tokenId], ExceptionsLibrary.LOCKED_NFT);
    }

    /// @notice Emitted when token is locked for transfers
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft NFT to be locked
    event TokenLocked(address indexed origin, address indexed sender, uint256 indexed nft);

    /// @notice Emitted when new Vault is registered in VaultRegistry
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param vault Address of the Vault contract
    /// @param owner Owner of the VaultRegistry NFT
    event VaultRegistered(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        address vault,
        address owner
    );

    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param newProtocolGovernance Address of the new ProtocolGovernance
    /// @param start Timestamp of the start of the new ProtocolGovernance
    event StagedProtocolGovernance(
        address indexed origin,
        address indexed sender,
        IProtocolGovernance newProtocolGovernance,
        uint256 start
    );

    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param newProtocolGovernance Address of the new ProtocolGovernance that has been committed
    event CommitedProtocolGovernance(
        address indexed origin,
        address indexed sender,
        IProtocolGovernance newProtocolGovernance
    );
}",1400
RealWorld_BA_58_IUniswapV3PoolImmutables_RealWord_20240821220457.log,58,IUniswapV3PoolImmutables,10210,4496,14706,87.0,0.14097,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Pool state that never changes
/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values
interface IUniswapV3PoolImmutables {
    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface
    /// @return The contract address
    function factory() external view returns (address);

    /// @notice The first of the two tokens of the pool, sorted by address
    /// @return The token contract address
    function token0() external view returns (address);

    /// @notice The second of the two tokens of the pool, sorted by address
    /// @return The token contract address
    function token1() external view returns (address);

    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6
    /// @return The fee
    function fee() external view returns (uint24);

    /// @notice The pool tick spacing
    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
    /// This value is an int24 to avoid casting even though it is always positive.
    /// @return The tick spacing
    function tickSpacing() external view returns (int24);

    /// @notice The maximum amount of position liquidity that can use any tick in the range
    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and
    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool
    /// @return The max amount of liquidity per tick
    function maxLiquidityPerTick() external view returns (uint128);
}",435
RealWorld_BA_58_IProtocolGovernance_RealWord_20240821204113.log,58,IProtocolGovernance,17151,5552,22703,139.0,0.196795,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IDefaultAccessControl.sol"";
import ""./IVaultRegistry.sol"";

interface IProtocolGovernance is IDefaultAccessControl {
    /// @notice CommonLibrary protocol params.
    /// @param permissionless If `true` anyone can spawn vaults, o/w only Protocol Governance Admin
    /// @param maxTokensPerVault Max different token addresses that could be managed by the protocol
    /// @param governanceDelay The delay (in secs) that must pass before setting new pending params to commiting them
    /// @param protocolTreasury Protocol treasury address for collecting management fees
    struct Params {
        bool permissionless;
        uint256 maxTokensPerVault;
        uint256 governanceDelay;
        address protocolTreasury;
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @notice Addresses allowed to claim liquidity mining rewards from.
    function claimAllowlist() external view returns (address[] memory);

    /// @notice Pending addresses to be added to claimAllowlist.
    function pendingClaimAllowlistAdd() external view returns (address[] memory);

    /// @notice Addresses of tokens allowed for vaults.
    function tokenWhitelist() external view returns (address[] memory);

    /// @notice Pending addresses to be added to tokenWhitelist.
    function pendingTokenWhitelistAdd() external view returns (address[] memory);

    /// @notice Addresses allowed to claim liquidity mining rewards from.
    function vaultGovernances() external view returns (address[] memory);

    /// @notice Pending addresses to be added to vaultGovernances.
    function pendingVaultGovernancesAdd() external view returns (address[] memory);

    /// @notice Check if address is allowed to claim.
    function isAllowedToClaim(address addr) external view returns (bool);

    /// @notice Check if address is an approved token.
    function isAllowedToken(address addr) external view returns (bool);

    /// @notice Check if address is a registered vault governance.
    function isVaultGovernance(address addr) external view returns (bool);

    /// @notice If `false` only admins can deploy new vaults, o/w anyone can deploy a new vault.
    function permissionless() external view returns (bool);

    /// @notice Max different ERC20 token addresses that could be managed by the protocol.
    function maxTokensPerVault() external view returns (uint256);

    /// @notice The delay for committing any governance params.
    function governanceDelay() external view returns (uint256);

    /// @notice The address of the protocol treasury.
    function protocolTreasury() external view returns (address);

    // -------------------  PUBLIC, MUTATING, GOVERNANCE, DELAY  -------------------

    /// @notice Set new pending params.
    /// @param newParams newParams to set
    function setPendingParams(Params memory newParams) external;

    /// @notice Stage addresses for claim allow list.
    /// @param addresses Addresses to add
    function setPendingClaimAllowlistAdd(address[] calldata addresses) external;

    /// @notice Stage addresses for token whitelist.
    /// @param addresses Addresses to add
    function setPendingTokenWhitelistAdd(address[] calldata addresses) external;

    /// @notice Stage addresses for vault governances.
    /// @param addresses Addresses to add
    function setPendingVaultGovernancesAdd(address[] calldata addresses) external;

    // -------------------  PUBLIC, MUTATING, GOVERNANCE, IMMEDIATE  -------------------

    /// @notice Commit pending params.
    function commitParams() external;

    /// @notice Commit pending ClaimAllowlistAdd params.
    function commitClaimAllowlistAdd() external;

    /// @notice Commit pending tokenWhitelistAdd params.
    function commitTokenWhitelistAdd() external;

    /// @notice Commit pending VaultGovernancesAdd params.
    function commitVaultGovernancesAdd() external;

    /// @notice Remove from claim allow list immediately.
    function removeFromClaimAllowlist(address addr) external;

    /// @notice Remove from token whitelist immediately.
    function removeFromTokenWhitelist(address addr) external;

    /// @notice Remove from vault governances immediately.
    function removeFromVaultGovernances(address addr) external;
}",867
RealWorld_BA_58_IVault_RealWord_20240821204700.log,58,IVault,23063,5567,28630,106.0,0.226655,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";

interface IVault {
    /// @notice VaultRegistry NFT for this vault
    function nft() external view returns (uint256);

    /// @notice Address of the Vault Governance for this contract.
    function vaultGovernance() external view returns (IVaultGovernance);

    /// @notice ERC20 tokens under Vault management.
    function vaultTokens() external view returns (address[] memory);

    /// @notice Total value locked for this contract.
    /// @dev Generally it is the underlying token value of this contract in some
    /// other DeFi protocol. For example, for USDC Yearn Vault this would be total USDC balance that could be withdrawn for Yearn to this contract.
    /// @return tokenAmounts Total available balances for multiple tokens (nth tokenAmount corresponds to nth token in vaultTokens)
    function tvl() external view returns (uint256[] memory tokenAmounts);

    /// @notice Initialize contract with vault nft
    /// @param nft VaultRegistry NFT for this vault
    function initialize(uint256 nft) external;

    /// @notice Pushes tokens on the vault balance to the underlying protocol. For example, for Yearn this operation will take USDC from
    /// the contract balance and convert it to yUSDC.
    /// @dev Can only be called but Vault Owner or Strategy. Vault owner is the owner of NFT for this vault in VaultManager.
    /// Strategy is approved address for the vault NFT.
    ///
    /// Tokens **must** be a subset of Vault Tokens. However, the convention is that if tokenAmount == 0 it is the same as token is missing.
    ///
    /// Also notice that this operation doesn't guarantee that tokenAmounts will be invested in full.
    /// @param tokens Tokens to push
    /// @param tokenAmounts Amounts of tokens to push
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param. For the exact bytes structure see concrete vault descriptions
    /// @return actualTokenAmounts The amounts actually invested. It could be less than tokenAmounts (but not higher)
    function push(
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external returns (uint256[] memory actualTokenAmounts);

    /// @notice The same as `push` method above but transfers tokens to vault balance prior to calling push.
    /// After the `push` it returns all the leftover tokens back (`push` method doesn't guarantee that tokenAmounts will be invested in full).
    /// @param tokens Tokens to push
    /// @param tokenAmounts Amounts of tokens to push
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param. For the exact bytes structure see concrete vault descriptions
    /// @return actualTokenAmounts The amounts actually invested. It could be less than tokenAmounts (but not higher)
    function transferAndPush(
        address from,
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external returns (uint256[] memory actualTokenAmounts);

    /// @notice Pulls tokens from the underlying protocol to the `to` address.
    /// For example, for Yearn this operation will take yUSDC from
    /// the Yearn protocol, convert it to USDC and send to `to` address.
    /// @dev Can only be called but Vault Owner or Strategy. Vault owner is the owner of NFT for this vault in VaultManager.
    /// Strategy is approved address for the vault NFT. There's a subtle difference however - while vault owner
    /// can pull the tokens to any address, Strategy can only pull to other vault in the Vault System (a set of vaults united by the Gateway Vault)
    ///
    /// Tokens **must** be a subset of Vault Tokens. However, the convention is that if tokenAmount == 0 it is the same as token is missing.
    ///
    /// Also notice that this operation doesn't guarantee that tokenAmounts will be invested in full.
    /// @param to Address to receive the tokens
    /// @param tokens Tokens to pull
    /// @param tokenAmounts Amounts of tokens to pull
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param. For the exact bytes structure see concrete vault descriptions
    /// @return actualTokenAmounts The amounts actually withdrawn. It could be less than tokenAmounts (but not higher)
    function pull(
        address to,
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external returns (uint256[] memory actualTokenAmounts);

    /// @notice This method is for claiming accidentally accumulated tokens on the contact's balance.
    /// @dev Can only be called by Protocol Governance.
    /// @param to Address that will receive the tokens
    /// @param tokens Tokens to claim. Each token must be other than those in vaultTokens
    function reclaimTokens(address to, address[] memory tokens) external;

    /// @notice Claim liquidity mining rewards.
    /// @dev Can only be called by Vault Owner or Strategy. Vault owner is the owner of NFT for this vault in VaultManager.
    /// Strategy is approved address for the vault NFT.
    ///
    /// Since this method allows sending arbitrary transactions, the destinations of the calls
    /// are whitelisted by Protocol Governance.
    /// @param from Address of the reward pool
    /// @param data Abi encoded call to the `from` address
    function claimRewards(address from, bytes memory data) external;

    function isVaultToken(address token) external view returns (bool);
}",1252
RealWorld_BA_58_IDefaultAccessControl_RealWord_20240821212307.log,58,IDefaultAccessControl,4498,4058,8556,92.0,0.10365,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/access/IAccessControlEnumerable.sol"";

interface IDefaultAccessControl is IAccessControlEnumerable {
    /// @notice Checks that the address is contract admin.
    /// @param who Address to check
    /// @return `true` if who is admin, `false` otherwise
    function isAdmin(address who) external view returns (bool);
}",93
RealWorld_BA_58_IVaultGovernance_RealWord_20240821214205.log,58,IVaultGovernance,13891,5852,19743,110.0,0.186495,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""./IProtocolGovernance.sol"";
import ""./IVaultRegistry.sol"";
import ""./IVaultFactory.sol"";
import ""./IVault.sol"";

interface IVaultGovernance {
    /// @notice Internal references of the contract.
    /// @param protocolGovernance Reference to Protocol Governance
    /// @param registry Reference to Vault Registry
    struct InternalParams {
        IProtocolGovernance protocolGovernance;
        IVaultRegistry registry;
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @notice Checks if contract is initialized.
    /// @dev Uninitialized contracts cannot deploy vaults
    function initialized() external view returns (bool);

    /// @notice Vault factory for this Vault Governance.
    function factory() external view returns (IVaultFactory);

    /// @notice Timestamp in unix time seconds after which staged Delayed Strategy Params could be committed.
    /// @param nft Nft of the vault
    function delayedStrategyParamsTimestamp(uint256 nft) external view returns (uint256);

    /// @notice Timestamp in unix time seconds after which staged Delayed Protocol Params could be committed.
    function delayedProtocolParamsTimestamp() external view returns (uint256);

    /// @notice Timestamp in unix time seconds after which staged Delayed Protocol Params Per Vault could be committed.
    /// @param nft Nft of the vault
    function delayedProtocolPerVaultParamsTimestamp(uint256 nft) external view returns (uint256);

    /// @notice Timestamp in unix time seconds after which staged Internal Params could be committed.
    function internalParamsTimestamp() external view returns (uint256);

    /// @notice Internal Params of the contract.
    function internalParams() external view returns (InternalParams memory);

    /// @notice Staged new Internal Params.
    /// @dev The Internal Params could be committed after internalParamsTimestamp
    function stagedInternalParams() external view returns (InternalParams memory);

    // -------------------  PUBLIC, MUTATING  -------------------

    /// @notice Instantly initialize governance with factory.
    /// @dev Can only be called by initial deployer and only once.
    /// Required to be called before any function starts working.
    /// @param factory new factory
    function initialize(IVaultFactory factory) external;

    /// @notice Deploy a new vault.
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Reserved additional deploy options. Should be 0x0.
    /// @param owner Owner of the registry vault nft. If it is address(0) then vault will own his own nft
    /// @return vault Address of the new vault
    /// @return nft Nft of the vault in the vault registry
    function deployVault(
        address[] memory vaultTokens,
        bytes memory options,
        address owner
    ) external returns (IVault vault, uint256 nft);

    /// @notice Stage new Internal Params.
    /// @param newParams New Internal Params
    function stageInternalParams(InternalParams memory newParams) external;

    /// @notice Commit staged Internal Params.
    function commitInternalParams() external;
}",669
RealWorld_BA_58_AaveVaultTest_RealWord_20240821201228.log,58,AaveVaultTest,5146,4779,9925,112.0,0.12131,"// SPDX-License-Identifier: agpl-3.0
pragma solidity =0.8.9;

import ""../interfaces/IVaultGovernance.sol"";
import ""../AaveVault.sol"";

contract AaveVaultTest is AaveVault {
    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)
        AaveVault(vaultGovernance_, vaultTokens_)
    {}

    function setATokens(address[] memory aTokens) public {
        _aTokens = aTokens;
    }

    function setVaultGovernance(address newVaultGovernance) public {
        _vaultGovernance = IVaultGovernance(newVaultGovernance);
    }
}",134
RealWorld_BA_58_IChiefTrader_RealWord_20240821202501.log,58,IChiefTrader,6534,4974,11508,86.0,0.13215,"// SPDX-License-Identifier: BSL-1.1
pragma solidity =0.8.9;

import ""../../interfaces/IProtocolGovernance.sol"";

interface IChiefTrader {
    /// @notice ProtocolGovernance
    /// @return the address of the protocol governance contract
    function protocolGovernance() external view returns (address);

    /// @notice Count of traders
    function tradersCount() external view returns (uint256);

    /// @notice Get the address of the trader at index
    /// @param _index The index of the trader
    function getTrader(uint256 _index) external view returns (address);

    /// @notice Get all registered traders
    function traders() external view returns (address[] memory);

    /// @notice Add new trader
    /// @param traderAddress the address of the trader
    function addTrader(address traderAddress) external;
}",179
RealWorld_BA_58_ILendingPoolAddressesProvider_RealWord_20240821210640.log,58,ILendingPoolAddressesProvider,10639,5210,15849,95.0,0.157395,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

/**
 * @title LendingPoolAddressesProvider contract
 * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles
 * - Acting also as factory of proxies and admin of those, so with right to change its implementations
 * - Owned by the Aave Governance
 * @author Aave
 **/
interface ILendingPoolAddressesProvider {
    event MarketIdSet(string newMarketId);
    event LendingPoolUpdated(address indexed newAddress);
    event ConfigurationAdminUpdated(address indexed newAddress);
    event EmergencyAdminUpdated(address indexed newAddress);
    event LendingPoolConfiguratorUpdated(address indexed newAddress);
    event LendingPoolCollateralManagerUpdated(address indexed newAddress);
    event PriceOracleUpdated(address indexed newAddress);
    event LendingRateOracleUpdated(address indexed newAddress);
    event ProxyCreated(bytes32 id, address indexed newAddress);
    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);

    function getMarketId() external view returns (string memory);

    function setMarketId(string calldata marketId) external;

    function setAddress(bytes32 id, address newAddress) external;

    function setAddressAsProxy(bytes32 id, address impl) external;

    function getAddress(bytes32 id) external view returns (address);

    function getLendingPool() external view returns (address);

    function setLendingPoolImpl(address pool) external;

    function getLendingPoolConfigurator() external view returns (address);

    function setLendingPoolConfiguratorImpl(address configurator) external;

    function getLendingPoolCollateralManager() external view returns (address);

    function setLendingPoolCollateralManager(address manager) external;

    function getPoolAdmin() external view returns (address);

    function setPoolAdmin(address admin) external;

    function getEmergencyAdmin() external view returns (address);

    function setEmergencyAdmin(address admin) external;

    function getPriceOracle() external view returns (address);

    function setPriceOracle(address priceOracle) external;

    function getLendingRateOracle() external view returns (address);

    function setLendingRateOracle(address lendingRateOracle) external;
}",462
RealWorld_BA_58_TraderExceptionsLibrary_RealWord_20240821202336.log,58,TraderExceptionsLibrary,6036,5026,11062,83.0,0.1307,"// SPDX-License-Identifier: BSL-1.1
pragma solidity =0.8.9;

library TraderExceptionsLibrary {
    string constant PROTOCOL_ADMIN_REQUIRED_EXCEPTION = ""PA"";
    string constant TRADER_ALREADY_REGISTERED_EXCEPTION = ""TE"";
    string constant TRADER_NOT_FOUND_EXCEPTION = ""UT"";
    string constant TRADE_FAILED_EXCEPTION = ""TF"";
    string constant VAULT_NOT_FOUND_EXCEPTION = ""VF"";
    string constant VAULT_TOKEN_REQUIRED_EXCEPTION = ""VT"";
    string constant AT_LEAST_STRATEGY_REQUIRED_EXCEPTION = ""SR"";
    string constant INVALID_TRADE_PATH_EXCEPTION = ""TP"";
    string constant RECURRENCE_EXCEPTION = ""RE"";
    string constant TOKEN_NOT_ALLOWED_EXCEPTION = ""TA"";
}",147
RealWorld_BA_59_LiquidityExtension_RealWord_20240822080741.log,59,LiquidityExtension,24125,5587,29712,96.0,0.232365,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import '@uniswap/lib/contracts/libraries/Babylonian.sol';

import ""./Permissions.sol"";
import ""./interfaces/IAuction.sol"";
import ""./interfaces/IDexHandler.sol"";
import ""./interfaces/IMaltDataLab.sol"";
import ""./libraries/UniswapV2Library.sol"";
import ""./interfaces/IBurnMintableERC20.sol"";


/// @title Liquidity Extension
/// @author 0xScotch <scotch@malt.money>
/// @notice In charge of facilitating a premium with net supply contraction during auctions
contract LiquidityExtension is Initializable, Permissions {
  ERC20 public collateralToken;
  IBurnMintableERC20 public malt;
  IAuction public auction;
  IDexHandler public dexHandler;
  IMaltDataLab public maltDataLab;
  address public uniswapV2Factory;

  uint256 public minReserveRatio = 40;

  event SetAuction(address auction);
  event SetDexHandler(address dexHandler);
  event SetMaltDataLab(address dataLab);
  event SetMinReserveRatio(uint256 ratio);
  event BurnMalt(uint256 purchased);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _auction,
    address _collateralToken,
    address _malt,
    address _dexHandler,
    address _maltDataLab,
    address _uniswapV2Factory
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);
    _setupRole(AUCTION_ROLE, _auction);

    collateralToken = ERC20(_collateralToken);
    malt = IBurnMintableERC20(_malt);
    auction = IAuction(_auction);
    dexHandler = IDexHandler(_dexHandler);
    maltDataLab = IMaltDataLab(_maltDataLab);
    uniswapV2Factory = _uniswapV2Factory;
  }

  /*
   * PUBLIC VIEW METHODS
   */
  function hasMinimumReserves() public view returns (bool) {
    (uint256 rRatio, uint256 decimals) = reserveRatio();
    return rRatio >= minReserveRatio.mul(10**decimals).div(100);
  }

  function collateralDeficit() public view returns (uint256 deficit, uint256 decimals) {
    // Returns the amount of collateral token required to reach minimum reserves
    // Returns 0 if liquidity extension contains minimum reserves.
    uint256 balance = collateralToken.balanceOf(address(this));
    uint256 collateralDecimals = collateralToken.decimals();

    // TODO use data lab Mon 11 Oct 2021 16:48:08 BST
    (uint256 maltSupply, uint256 collateralSupply) = UniswapV2Library.getReserves(
      uniswapV2Factory,
      address(malt),
      address(collateralToken)
    );

    uint256 k = maltSupply.mul(collateralSupply);
    uint256 priceTarget = maltDataLab.priceTarget();

    uint256 fullCollateral = Babylonian.sqrt(k.mul(10**collateralDecimals).div(priceTarget));

    uint256 minReserves = fullCollateral.mul(minReserveRatio).div(100);

    if (minReserves > balance) {
      return (minReserves - balance, collateralDecimals);
    }

    return (0, collateralDecimals);
  }

  function reserveRatio() public view returns (uint256, uint256) {
    uint256 balance = collateralToken.balanceOf(address(this));
    uint256 collateralDecimals = collateralToken.decimals();

    // TODO use data lab Mon 11 Oct 2021 16:48:08 BST
    (uint256 maltSupply, uint256 collateralSupply) = UniswapV2Library.getReserves(
      uniswapV2Factory,
      address(malt),
      address(collateralToken)
    );

    uint256 k = maltSupply.mul(collateralSupply);
    uint256 priceTarget = maltDataLab.priceTarget();

    uint256 fullCollateral = Babylonian.sqrt(k.mul(10**collateralDecimals).div(priceTarget));

    uint256 rRatio = balance.mul(10**collateralDecimals).div(fullCollateral);
    return (rRatio, collateralDecimals);
  }

  /*
   * PRIVILEDGED METHODS
   */
  function purchaseAndBurn(uint256 amount)
    external
    onlyRole(AUCTION_ROLE, ""Must have auction privs"")
    returns (uint256 purchased)
  {
    require(collateralToken.balanceOf(address(this)) >= amount, ""Insufficient balance"");
    collateralToken.safeTransfer(address(dexHandler), amount);
    purchased = dexHandler.buyMalt();
    malt.burn(address(this), purchased);

    emit BurnMalt(purchased);
  }

  function setAuction(address _auction)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_auction != address(0), ""Not address 0"");
    auction = IAuction(_auction);
    emit SetAuction(_auction);
  }

  function setDexHandler(address _dexHandler)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_dexHandler != address(0), ""Not address 0"");
    dexHandler = IDexHandler(_dexHandler);
    emit SetDexHandler(_dexHandler);
  }

  function setMaltDataLab(address _dataLab)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_dataLab != address(0), ""Not address 0"");
    maltDataLab = IMaltDataLab(_dataLab);
    emit SetMaltDataLab(_dataLab);
  }

  function setMinReserveRatio(uint256 _ratio)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_ratio > 0 && _ratio <= 100, ""Must be between 0 and 100"");
    minReserveRatio = _ratio;
    emit SetMinReserveRatio(_ratio);
  }
}",1341
RealWorld_BA_59_MovingAverage_RealWord_20240822082410.log,59,MovingAverage,57974,5324,63298,75.0,0.39635,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@uniswap/lib/contracts/libraries/FixedPoint.sol"";

import ""./Permissions.sol"";


/// @title Moving Average
/// @author 0xScotch <scotch@malt.money>
/// @notice For tracking the average of a data stream over time
/// @dev Based on the cumulativeValue mechanism for TWAP in uniswapV2
contract MovingAverage is Initializable, Permissions {
  using FixedPoint for *;
  using SafeMath for uint256;

  struct Sample {
    uint64 timestamp;
    uint256 value;
    uint256 cumulativeValue;
    uint256 lastValue;
  }

  bytes32 public constant UPDATER_ROLE = keccak256(""UPDATER_ROLE"");

  uint256 public sampleLength;
  uint256 public cumulativeValue;
  uint256 public sampleMemory;
  uint256 public defaultValue;

  uint64 public blockTimestampLast;

  uint256 private counter;
  uint256 private activeSamples;

  Sample[] private samples;

  event Update(uint256 value, uint256 cumulativeValue);

  function initialize(
    address _timelock,
    address initialAdmin,
    uint256 _sampleLength, // eg 5min represented as seconds
    uint256 _sampleMemory,
    address _updater,
    uint256 _defaultValue
  ) external initializer {
    require(_sampleMemory > 1, 'MA: SampleMemory > 1');

    _adminSetup(_timelock);
    _setupRole(ADMIN_ROLE, initialAdmin);
    _roleSetup(UPDATER_ROLE, _updater);
    _roleSetup(UPDATER_ROLE, initialAdmin);

    sampleLength = _sampleLength;
    sampleMemory = _sampleMemory;
    defaultValue = _defaultValue;

    for (uint i = 0; i < sampleMemory; i++) {
      samples.push();
    }
  }

  /*
   * PUBLIC VIEW METHODS
   */
  function getValue() public view returns (uint256) {
    if (activeSamples < 2) {
      return defaultValue;
    } else if (activeSamples == 2) {
      Sample storage currentSample = _getCurrentSample();
      return currentSample.value;
    } else if (activeSamples < sampleMemory) {
      // Subtract 2 because this is a lookback from the current sample.
      // activeSamples - 1 is the in progress sample. - 2 is the active sample
      // IE if there are 2 samples, we are on one and want to lookback 1.
      // If there are 3 samples, we are on one and want to lookback 2 etc
      uint256 lookback = (activeSamples - 2) * sampleLength;
      return getValueWithLookback(lookback);
    }
    Sample storage currentSample = _getCurrentSample();
    Sample storage firstSample = _getFirstSample();

    uint256 timeElapsed = currentSample.timestamp - firstSample.timestamp;
    uint256 sampleDiff = currentSample.cumulativeValue - firstSample.cumulativeValue;

    if (timeElapsed == 0) {
      return currentSample.value;
    } 

    FixedPoint.uq112x112 memory sampleAverage = FixedPoint.fraction(sampleDiff, timeElapsed);

    return sampleAverage.decode();
  }

  function getValueWithLookback(uint256 _lookbackTime) public view returns (uint256) {
    // _lookbackTime in is seconds
    uint256 lookbackSamples;
    if (_lookbackTime % sampleLength == 0) {
      // If it divides equally just divide down
      lookbackSamples = _lookbackTime / sampleLength;

      if (lookbackSamples == 0) {
        lookbackSamples = 1;
      }
    } else {
      // If it doesn't divide equally, divide and add 1.
      // Creates a Math.ceil() situation
      lookbackSamples = (_lookbackTime / sampleLength) + 1;
    }

    if (activeSamples < 2) {
      return defaultValue;
    } else if (activeSamples == 2) {
      Sample storage currentSample = _getCurrentSample();
      return currentSample.value;
    } else if (lookbackSamples >= activeSamples - 1) {
      // Looking for longer lookback than sampleMemory allows.
      // Just return the full memory average
      return getValue();
    }

    Sample storage currentSample = _getCurrentSample();
    Sample storage nthSample = _getNthSample(lookbackSamples);

    uint256 timeElapsed = currentSample.timestamp - nthSample.timestamp;
    uint256 sampleDiff = currentSample.cumulativeValue - nthSample.cumulativeValue;

    if (timeElapsed == 0) {
      return currentSample.value;
    } 

    FixedPoint.uq112x112 memory sampleAverage = FixedPoint.fraction(sampleDiff, timeElapsed);

    return sampleAverage.decode();
  }

  /*
   * MUTATION METHODS
   */
  function update(uint256 newValue)
    external 
    onlyRole(UPDATER_ROLE, ""Must have updater privs"")
  {
    /* 
     * This function only creates a sample at the end of the sample period.
     * The current sample period just updates the cumulativeValue but doesn't
     * Actually create a sample until the end of the period.
     * This is to protect against flashloan attacks that could try manipulate
     * the samples.
     */
    Sample storage liveSample = samples[_getIndexOfSample(counter)];
    uint64 blockTimestamp = uint64(block.timestamp % 2**64); 

    // Deal with first ever sample
    if (liveSample.timestamp == 0) {
      liveSample.timestamp = uint64(block.timestamp);
      liveSample.value = newValue;
      liveSample.lastValue = newValue;
      liveSample.cumulativeValue = newValue;

      cumulativeValue = newValue;
      blockTimestampLast = blockTimestamp;

      activeSamples = activeSamples + 1;
      return;
    }

    uint64 timeElapsed = blockTimestamp - liveSample.timestamp;

    if (timeElapsed < sampleLength) {
      cumulativeValue += liveSample.lastValue.mul(blockTimestamp - blockTimestampLast);
      liveSample.cumulativeValue = cumulativeValue;
      liveSample.lastValue = newValue;

      blockTimestampLast = blockTimestamp;
      return;
    } else if (timeElapsed >= (sampleLength - 1) * sampleMemory) {
      // More than total sample memory has elapsed. Reset with new values
      uint256 addition = liveSample.lastValue.mul(sampleLength);

      uint256 currentCumulative = cumulativeValue;
      uint64 currentTimestamp = blockTimestamp - uint64(sampleLength * sampleMemory);

      uint256 tempCount = counter;
      for (uint256 i = 0; i < sampleMemory; i++ ) {
        tempCount += 1;
        liveSample = samples[_getIndexOfSample(tempCount)];
        liveSample.timestamp = currentTimestamp;
        liveSample.cumulativeValue = currentCumulative;

        currentCumulative += addition;
        currentTimestamp += uint64(sampleLength);
      }

      // Reset the adding of 'addition' in the final loop
      currentCumulative = liveSample.cumulativeValue;

      tempCount += 1;
      liveSample = samples[_getIndexOfSample(tempCount)];
      liveSample.timestamp = blockTimestamp;
      // Only the most recent values really matter here
      liveSample.value = newValue;
      liveSample.lastValue = newValue;
      liveSample.cumulativeValue = currentCumulative;

      counter = tempCount;
      cumulativeValue = currentCumulative;
      blockTimestampLast = blockTimestamp;
      activeSamples = sampleMemory;
      return;
    }

    uint64 nextSampleTime = liveSample.timestamp + uint64(sampleLength);

    // Finish out the current sample
    cumulativeValue += liveSample.lastValue.mul(nextSampleTime - blockTimestampLast);
    liveSample.cumulativeValue = cumulativeValue;

    liveSample = _createNewSample(nextSampleTime, cumulativeValue);
    timeElapsed = timeElapsed - uint64(sampleLength);

    uint256 elapsedSamples = timeElapsed / sampleLength;

    for (uint256 i = 1; i <= elapsedSamples; i = i + 1) {
      // update
      cumulativeValue += liveSample.lastValue.mul(sampleLength);
      liveSample.cumulativeValue = cumulativeValue;

      uint64 sampleTime = liveSample.timestamp + uint64(sampleLength);

      liveSample = _createNewSample(sampleTime, cumulativeValue);
    }

    cumulativeValue += liveSample.lastValue.mul(timeElapsed % sampleLength);

    // Now set the value of the current sample to the new value
    liveSample.value = newValue;
    liveSample.lastValue = newValue;
    liveSample.cumulativeValue = cumulativeValue;

    blockTimestampLast = blockTimestamp;

    emit Update(newValue, cumulativeValue);
  }

  function updateCumulative(uint256 _cumulative)
    external 
    onlyRole(UPDATER_ROLE, ""Must have updater privs"")
  {
    require(_cumulative >= cumulativeValue, ""Cumulative value can only go up"");

    Sample storage liveSample = samples[_getIndexOfSample(counter)];
    uint64 blockTimestamp = uint64(block.timestamp % 2**64); 

    if (liveSample.timestamp == 0) {
      cumulativeValue = _cumulative;
      blockTimestampLast = blockTimestamp;

      liveSample.timestamp = blockTimestamp;
      liveSample.cumulativeValue = _cumulative;
      liveSample.value = _cumulative;
      liveSample.lastValue = _cumulative;

      activeSamples = activeSamples + 1;
      return;
    }

    uint64 timeElapsed = blockTimestamp - liveSample.timestamp;
    uint64 timeElapsedSinceUpdate = blockTimestamp - blockTimestampLast;
    uint256 newLastValue = (_cumulative - cumulativeValue).div(timeElapsedSinceUpdate);

    if (timeElapsed < sampleLength) {
      // The current sample isn't over. Just update
      liveSample.cumulativeValue = _cumulative;
      liveSample.value = newLastValue;
      liveSample.lastValue = newLastValue;

      blockTimestampLast = blockTimestamp;
      cumulativeValue = _cumulative;
      return;
    } else if (timeElapsed >= sampleLength * (sampleMemory - 1)) {
      // More than total sample memory has elapsed. Reset with new values

      uint256 addition = newLastValue.mul(sampleLength);

      uint256 currentCumulative = _cumulative.sub(addition * (sampleMemory - 1));
      uint64 currentTimestamp = blockTimestamp - uint64(sampleLength * (sampleMemory));

      uint256 tempCount = counter;
      for (uint256 i = 0; i < sampleMemory; i++ ) {
        tempCount += 1;
        liveSample = samples[_getIndexOfSample(tempCount)];
        liveSample.timestamp = currentTimestamp;
        liveSample.cumulativeValue = currentCumulative;

        currentCumulative += addition;
        currentTimestamp += uint64(sampleLength);
      }

      tempCount += 1;
      liveSample = samples[_getIndexOfSample(tempCount)];
      liveSample.timestamp = blockTimestamp;
      // Only the most recent values really matter here
      liveSample.value = newLastValue;
      liveSample.lastValue = newLastValue;
      liveSample.cumulativeValue = _cumulative;

      counter = tempCount;
      cumulativeValue = _cumulative;
      blockTimestampLast = blockTimestamp;
      activeSamples = sampleMemory;
      return;
    }

    // One or more sample boundaries have been crossed.
    uint64 nextSampleTime = liveSample.timestamp + uint64(sampleLength);
    // Finish out the current sample
    cumulativeValue += newLastValue.mul(nextSampleTime - blockTimestampLast);
    liveSample.cumulativeValue = cumulativeValue;
    liveSample.lastValue = newLastValue;

    liveSample = _createNewSample(nextSampleTime, cumulativeValue);
    timeElapsed = timeElapsed - uint64(sampleLength);

    uint256 elapsedSamples = timeElapsed / sampleLength;

    for (uint256 i = 1; i <= elapsedSamples; i = i + 1) {
      // update
      cumulativeValue += newLastValue.mul(sampleLength);
      liveSample.cumulativeValue = cumulativeValue;

      uint64 sampleTime = liveSample.timestamp + uint64(sampleLength);

      liveSample = _createNewSample(sampleTime, cumulativeValue);
    }

    liveSample.value = newLastValue;
    liveSample.lastValue = newLastValue;
    liveSample.cumulativeValue = _cumulative;

    cumulativeValue = _cumulative;
    blockTimestampLast = blockTimestamp;

    emit Update(newLastValue, cumulativeValue);
  }

  /*
   * INTERNAL VIEW METHODS
   */
  function _getIndexOfSample(uint _count) internal view returns (uint32 index) {
    return uint32(_count % sampleMemory);
  }

  function _getCurrentSample() private view returns (Sample storage currentSample) {
    // Active sample is always counter - 1. Counter is the in progress sample
    uint32 currentSampleIndex = _getIndexOfSample(counter - 1);
    currentSample = samples[currentSampleIndex];
  }

  function _getFirstSample() private view returns (Sample storage firstSample) {
    uint32 sampleIndex = _getIndexOfSample(counter);
    // no overflow issue. if sampleIndex + 1 overflows, result is still zero.
    uint32 firstSampleIndex = uint32((sampleIndex + 1) % sampleMemory);
    firstSample = samples[firstSampleIndex];
  }

  function _getNthSample(uint256 n) private view returns (Sample storage sample) {
    require(n < activeSamples - 1, ""Not enough samples"");
    uint32 sampleIndex = _getIndexOfSample(counter - 1 - n);
    sample = samples[sampleIndex];
  }

  /*
   * INTERNAL METHODS
   */
  function _createNewSample(uint64 sampleTime, uint256 cumulativeValue)
    internal
    returns(Sample storage liveSample)
  {
    Sample storage oldSample = samples[_getIndexOfSample(counter - 1)];
    Sample storage previousSample = samples[_getIndexOfSample(counter)];

    if (oldSample.timestamp > 0 && activeSamples > 1) {
      previousSample.value = (previousSample.cumulativeValue - oldSample.cumulativeValue).div(sampleLength);
    }

    counter += 1;
    liveSample = samples[_getIndexOfSample(counter)];
    liveSample.timestamp = sampleTime;
    liveSample.cumulativeValue = cumulativeValue;
    liveSample.value = previousSample.value;
    liveSample.lastValue = previousSample.lastValue;

    if (activeSamples < sampleMemory) {
      // Active samples is how we keep track of how many real samples we have vs default 0 values
      // This is useful for providing data even when full sample set isn't populated yet
      activeSamples = activeSamples + 1;
    }

    blockTimestampLast = sampleTime;
  }

  /*
   * PRIVILEDGED METHODS
   */
  function setSampleLength(uint256 _sampleLength)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_sampleLength > 0, ""Cannot have 0 second sample length"");
    sampleLength = _sampleLength;
  }

  function resetLiveSampleTime()
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    Sample storage liveSample = samples[_getIndexOfSample(counter)];
    liveSample.timestamp = uint64(block.timestamp % 2**64); 
  }

  function setSampleMemory(uint256 _sampleMemory)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_sampleMemory > 0, ""Cannot have sample memroy of 0"");

    if (_sampleMemory > sampleMemory) {
      for (uint i = sampleMemory; i < _sampleMemory; i++) {
        samples.push();
      }
      counter = counter % _sampleMemory;
    } else {
      activeSamples = _sampleMemory;

      // TODO handle when list is smaller Tue 21 Sep 2021 22:29:41 BST
    }

    sampleMemory = _sampleMemory;
  }
}",3391
RealWorld_BA_59_IMalt_RealWord_20240822090314.log,59,IMalt,5644,5178,10822,94.0,0.13178,"pragma solidity >=0.6.6;

interface IMalt {
  function balanceOf(address account) external view returns (uint256);
  function transfer(address recipient, uint256 amount) external returns (bool);
  function allowance(address owner, address spender) external view returns (uint256);
  function approve(address spender, uint256 amount) external returns (bool);
  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
  function mint(address to, uint256 amount) external;
  function burn(address from, uint256 amount) external;

  event Transfer(address indexed from, address indexed to, uint256 value);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}",147
RealWorld_BA_59_ForfeitHandler_RealWord_20240822082254.log,59,ForfeitHandler,13092,5217,18309,74.0,0.1698,"pragma solidity >=0.6.6;

import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""./Permissions.sol"";


/// @title Forfeit Handler
/// @author 0xScotch <scotch@malt.money>
/// @notice When a user unbonds, their unvested rewards are forfeited. This contract decides what to do with those funds
contract ForfeitHandler is Initializable, Permissions {
  ERC20 public rewardToken;
  address public treasuryMultisig;
  address public swingTrader;

  uint256 public swingTraderRewardCut = 500;
  uint256 public treasuryRewardCut = 500;

  event Forfeit(address sender, uint256 amount);
  event SetRewardCut(uint256 treasuryCut, uint256 swingTraderCut);
  event SetTreasury(address treasury);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _rewardToken,
    address _treasuryMultisig,
    address _swingTrader
  ) external initializer {
    _adminSetup(_timelock);
    _setupRole(ADMIN_ROLE, initialAdmin);

    rewardToken = ERC20(_rewardToken);
    treasuryMultisig = _treasuryMultisig;
    swingTrader = _swingTrader;
  }

  function handleForfeit() public {
    uint256 balance = rewardToken.balanceOf(address(this));

    if (balance == 0) {
      return;
    }

    uint256 swingTraderCut = balance.mul(swingTraderRewardCut).div(1000);
    uint256 treasuryCut = balance - swingTraderCut;

    if (swingTraderCut > 0) {
      rewardToken.safeTransfer(swingTrader, swingTraderCut);
    }

    if (treasuryCut > 0) {
      rewardToken.safeTransfer(treasuryMultisig, treasuryCut);
    }

    emit Forfeit(msg.sender, balance);
  }

  /*
   * PRIVILEDGED METHODS
   */
  function setRewardCut(
    uint256 _treasuryCut,
    uint256 _swingTraderCut
  )
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_treasuryCut.add(_swingTraderCut) == 1000, ""Reward cut must add to 100%"");

    treasuryRewardCut = _treasuryCut;
    swingTraderRewardCut = _swingTraderCut;

    emit SetRewardCut(_treasuryCut, _swingTraderCut);
  }

  function setTreasury(address _treasury)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_treasury != address(0), ""Cannot set 0 address"");

    treasuryMultisig = _treasury;

    emit SetTreasury(_treasury);
  }
}",594
RealWorld_BA_59_IAuctionPool_RealWord_20240822090920.log,59,IAuctionPool,7433,5593,13026,76.0,0.149025,"pragma solidity >=0.6.6;

interface IAuctionPool {
  function onUnbond(address account, uint256 amount) external;
  function totalBonded() external view returns (uint256);
  function balanceOfBonded(address account) external view returns (uint256);
  function totalDeclaredReward() external view returns (uint256);
  function totalReleasedReward() external view returns (uint256);

  function purchaseArbitrageTokens(uint256 maxAmount)
    external returns (uint256 remaining);
  function claim() external;
  function outstandingArbTokens() external view returns (uint256 outstanding);

  function onBond(address account, uint256 amount) external;
  function withdrawAll() external;
  function withdraw(uint256 rewardAmount) external;
  function totalStakePadding() external view returns(uint256);
  function balanceOfStakePadding(address account) external view returns (uint256);
  function getRewardOwnershipFraction(address account) external view returns(uint256 numerator, uint256 denominator);
  function balanceOfRewards(address account) external view returns (uint256);
  function earned(address account) external view returns (uint256 earnedReward);
  function withdrawForAccount(address account, uint256 amount, address to) external returns (uint256);
}",257
RealWorld_BA_59_SwingTrader_RealWord_20240822081201.log,59,SwingTrader,23339,5709,29048,77.0,0.230875,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";

import ""./Permissions.sol"";
import ""./interfaces/IAuction.sol"";
import ""./interfaces/IRewardThrottle.sol"";
import ""./interfaces/IDexHandler.sol"";


/// @title Swing Trader
/// @author 0xScotch <scotch@malt.money>
/// @notice The sole aim of this contract is to defend peg and try to profit in the process.
/// @dev It does so from a privileged internal position where it is allowed to purchase on the AMM even in recovery mode
contract SwingTrader is Initializable, Permissions {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  ERC20 public collateralToken;
  ERC20 public malt;
  IDexHandler public dexHandler;
  IRewardThrottle public rewardThrottle;

  uint256 internal deployedCapital;
  uint256 public lpProfitCut = 500; // 50%

  function initialize(
    address _timelock,
    address initialAdmin,
    address _collateralToken,
    address _malt,
    address _dexHandler,
    address _stabilizerNode,
    address _rewardThrottle
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);
    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);

    collateralToken = ERC20(_collateralToken);
    malt = ERC20(_malt);
    dexHandler = IDexHandler(_dexHandler);
    rewardThrottle = IRewardThrottle(_rewardThrottle);
  }

  function buyMalt(uint256 maxCapital)
    external
    onlyRole(STABILIZER_NODE_ROLE, ""Must have stabilizer node privs"")
    returns (uint256 capitalUsed)
  {
    if (maxCapital == 0) {
      return 0;
    }

    uint256 balance = collateralToken.balanceOf(address(this));

    if (balance == 0) {
      return 0;
    }

    if (maxCapital < balance) {
      balance = maxCapital;
    }

    collateralToken.safeTransfer(address(dexHandler), balance);
    dexHandler.buyMalt();

    deployedCapital = deployedCapital + balance;

    return balance;
  }

  function sellMalt(uint256 maxAmount)
    external
    onlyRole(STABILIZER_NODE_ROLE, ""Must have stabilizer node privs"")
    returns (uint256 amountSold)
  {
    if (maxAmount == 0) {
      return 0;
    }

    uint256 totalMaltBalance = malt.balanceOf(address(this));
    uint256 balance = totalMaltBalance;

    if (balance == 0) {
      return 0;
    }

    (uint256 basis,) = costBasis();

    if (maxAmount < totalMaltBalance) {
      balance = maxAmount;
    }

    malt.safeTransfer(address(dexHandler), balance);
    uint256 rewards = dexHandler.sellMalt();

    if (rewards <= deployedCapital && maxAmount != totalMaltBalance) {
      // If all malt is spent we want to reset deployed capital
      deployedCapital = deployedCapital - rewards;
    } else {
      deployedCapital = 0;
    }

    uint256 maltDecimals = malt.decimals();
    uint256 decimals = collateralToken.decimals();    

    uint256 profit = 0;

    if (maltDecimals == decimals) {
      uint256 soldBasis = basis.mul(balance).div(10**decimals);

      if (rewards > soldBasis) {
        profit = rewards.sub(soldBasis);
      }
    } else if (maltDecimals > decimals) {
      uint256 diff = maltDecimals - decimals;
      uint256 soldBasis = basis.mul(balance.div(10**diff)).div(10**decimals);

      if (rewards > soldBasis) {
        profit = rewards.sub(soldBasis);
      }
    } else {
      uint256 diff = decimals - maltDecimals;
      uint256 soldBasis = basis.mul(balance.mul(10**diff)).div(10**decimals);

      if (rewards > soldBasis) {
        profit = rewards.sub(soldBasis);
      }
    }

    if (profit > 0) {
      uint256 lpCut = profit.mul(lpProfitCut).div(1000);

      collateralToken.safeTransfer(address(rewardThrottle), lpCut);
      rewardThrottle.handleReward();
    }

    return balance;
  }

  function costBasis() public view returns (uint256 cost, uint256 decimals) {
    // Always returns using the decimals of the collateralToken as that is the 
    // currency costBasis is calculated in
    decimals = collateralToken.decimals();    
    uint256 maltBalance = malt.balanceOf(address(this));

    if (deployedCapital == 0 || maltBalance == 0) {
      return (0, decimals);
    }

    uint256 maltDecimals = malt.decimals();    

    if (maltDecimals == decimals) {
      return (deployedCapital.mul(10**decimals).div(maltBalance), decimals);
    } else if (maltDecimals > decimals) {
      uint256 diff = maltDecimals - decimals;
      return (deployedCapital.mul(10**decimals).div(maltBalance.div(10**diff)), decimals);
    } else {
      uint256 diff = decimals - maltDecimals;
      return (deployedCapital.mul(10**decimals).div(maltBalance.mul(10**diff)), decimals);
    }
  }

  function setLpProfitCut(uint256 _profitCut) public onlyRole(ADMIN_ROLE, ""Must have admin privs"") {
    require(_profitCut >= 0 && _profitCut <= 1000, ""Must be between 0 and 100%"");
    lpProfitCut = _profitCut;  
  }
}",1297
RealWorld_BA_59_IBurnMintableERC20_RealWord_20240822085957.log,59,IBurnMintableERC20,13455,5276,18731,79.0,0.172795,"// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IBurnMintableERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    function decimals() external view returns (uint256);

    function burn(address account, uint256 amount) external;
    function mint(address account, uint256 amount) external;

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",656
RealWorld_BA_59_ISwingTrader_RealWord_20240822085620.log,59,ISwingTrader,4157,4444,8601,71.0,0.109665,"pragma solidity >=0.6.6;

interface ISwingTrader {
  function buyMalt(uint256 maxCapital) external returns (uint256 capitalUsed);
  function sellMalt(uint256 maxAmount) external returns (uint256 amountSold);
  function costBasis() external view returns (uint256 cost, uint256 decimals);
}",69
RealWorld_BA_59_Bonding_RealWord_20240822083035.log,59,Bonding,44181,5347,49528,89.0,0.327845,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";

import ""./interfaces/IDAO.sol"";
import ""./interfaces/IMiningService.sol"";
import ""./interfaces/IDexHandler.sol"";
import ""./interfaces/IMaltDataLab.sol"";

import ""./Permissions.sol"";


struct UserState {
  uint256 bonded;

  // TODO calculate average bonded period for log calc Tue 03 Aug 2021 11:22:39 BST
  uint256 bondedEpoch;
}

struct EpochState {
  uint256 lastTotalBonded;
  uint256 lastUpdateTime;
  uint256 cumulativeTotalBonded;
}


/// @title LP Bonding
/// @author 0xScotch <scotch@malt.money>
/// @notice The contract which LP tokens are bonded to to make a user eligible for protocol rewards
contract Bonding is Initializable, Permissions {
  ERC20 public malt;
  ERC20 public rewardToken;
  ERC20 public stakeToken;
  IDAO public dao;
  IMiningService public miningService;
  IDexHandler public dexHandler;
  IMaltDataLab public maltDataLab;

  uint256 internal _globalBonded;
  uint256 internal _currentEpoch;
  address internal offering;
  mapping(address => UserState) internal userState;
  mapping(uint256 => EpochState) internal epochState;

  event Bond(address indexed account, uint256 value);
  event Unbond(address indexed account, uint256 value);
  event UnbondAndBreak(address indexed account, uint256 amountLPToken, uint256 amountMalt, uint256 amountReward);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _malt,
    address _rewardToken,
    address _stakeToken,
    address _dao,
    address _miningService,
    address _offering,
    address _dexHandler,
    address _maltDataLab
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);

    dao = IDAO(_dao);
    offering = _offering;
    stakeToken = ERC20(_stakeToken);
    miningService = IMiningService(_miningService);
    dexHandler = IDexHandler(_dexHandler);
    malt = ERC20(_malt);
    rewardToken = ERC20(_rewardToken);
    maltDataLab = IMaltDataLab(_maltDataLab);
  }

  function bond(uint256 amount) external {
    bondToAccount(msg.sender, amount);
  }

  function bondToAccount(address account, uint256 amount)
    public
  {
    if (msg.sender != offering) {
      _notSameBlock();
    }
    require(amount > 0, ""Cannot bond 0"");

    miningService.onBond(account, amount);

    _bond(account, amount);
  }

  function unbond(uint256 amount)
    external
  {
    require(amount > 0, ""Cannot unbond 0"");

    uint256 bondedBalance = balanceOfBonded(msg.sender);

    require(bondedBalance > 0, ""< bonded balance"");
    require(amount <= bondedBalance, ""< bonded balance"");

    // Avoid leaving dust behind
    if (amount.add(1e16) > bondedBalance) {
      amount = bondedBalance;
    }

    miningService.onUnbond(msg.sender, amount);

    _unbond(amount);
  }

  function unbondAndBreak(uint256 amount)
    external
  {
    require(amount > 0, ""Cannot unbond 0"");

    uint256 bondedBalance = balanceOfBonded(msg.sender);

    require(bondedBalance > 0, ""< bonded balance"");
    require(amount <= bondedBalance, ""< bonded balance"");

    // Avoid leaving dust behind
    if (amount.add(1e16) > bondedBalance) {
      amount = bondedBalance;
    }

    miningService.onUnbond(msg.sender, amount);

    _unbondAndBreak(amount);
  }

  /*
   * PUBLIC VIEW FUNCTIONS
   */
  function averageBondedValue(uint256 epoch) public view returns (uint256) {
    EpochState storage state = epochState[epoch];
    uint256 epochLength = dao.epochLength();
    uint256 timeElapsed = epochLength;
    uint256 epochStartTime = dao.getEpochStartTime(epoch);
    uint256 diff;
    uint256 lastUpdateTime = state.lastUpdateTime;
    uint256 lastTotalBonded = state.lastTotalBonded;

    if (lastUpdateTime == 0) {
      lastUpdateTime = epochStartTime;
    }

    if (lastTotalBonded == 0) {
      lastTotalBonded = _globalBonded;
    }

    if (block.timestamp < epochStartTime) {
      return 0;
    }

    if (epochStartTime + epochLength <= lastUpdateTime) {
      return maltDataLab.realValueOfLPToken((state.cumulativeTotalBonded) / epochLength);
    }

    if (epochStartTime + epochLength < block.timestamp) {
      // The desired epoch is in the past
      diff = (epochStartTime + epochLength) - lastUpdateTime;
    } else {
      diff = block.timestamp - lastUpdateTime;
      timeElapsed = block.timestamp - epochStartTime;
    }

    if (timeElapsed == 0) {
      // Only way timeElapsed should == 0 is when block.timestamp == epochStartTime
      // Therefore just return the lastTotalBonded value
      return maltDataLab.realValueOfLPToken(lastTotalBonded);
    }

    uint256 endValue = state.cumulativeTotalBonded + (lastTotalBonded.mul(diff));
    return maltDataLab.realValueOfLPToken((endValue) / timeElapsed);
  }

  function totalBonded() public view returns (uint256) {
    return _globalBonded;
  }

  function balanceOfBonded(address account) public view returns (uint256) {
    return userState[account].bonded;
  }

  function bondedEpoch(address account) public view returns (uint256) {
    return userState[account].bondedEpoch;
  }

  function epochData(uint256 epoch) public view returns(uint256, uint256, uint256) {
    return (epochState[epoch].lastTotalBonded, epochState[epoch].lastUpdateTime, epochState[epoch].cumulativeTotalBonded);
  }

  /*
   * INTERNAL VIEW FUNCTIONS
   */
  function _balanceCheck() internal view {
    require(stakeToken.balanceOf(address(this)) >= totalBonded(), ""Balance inconsistency"");
  }

  /*
   * INTERNAL FUNCTIONS
   */
  function _bond(address account, uint256 amount) internal {
    stakeToken.safeTransferFrom(msg.sender, address(this), amount);

    _addToBonded(account, amount);

    _balanceCheck();

    emit Bond(account, amount);
  }

  function _unbond(uint256 amountLPToken) internal notSameBlock {
    _removeFromBonded(msg.sender, amountLPToken, ""LP: Insufficient bonded balance"");

    stakeToken.safeTransfer(msg.sender, amountLPToken);

    _balanceCheck();

    emit Unbond(msg.sender, amountLPToken);
  }

  function _unbondAndBreak(uint256 amountLPToken) internal notSameBlock {
    _removeFromBonded(msg.sender, amountLPToken, ""LP: Insufficient bonded balance"");

    stakeToken.safeTransfer(address(dexHandler), amountLPToken);

    (uint256 amountMalt, uint256 amountReward) = dexHandler.removeLiquidity();

    malt.safeTransfer(msg.sender, amountMalt);
    rewardToken.safeTransfer(msg.sender, amountReward);

    _balanceCheck();

    emit UnbondAndBreak(msg.sender, amountLPToken, amountMalt, amountReward);
  }

  function _addToBonded(address account, uint256 amount) internal {
    userState[account].bonded = userState[account].bonded.add(amount);

    _updateEpochState(_globalBonded.add(amount));

    if (userState[account].bondedEpoch == 0) {
      userState[account].bondedEpoch = dao.epoch();
    }
  }

  function _removeFromBonded(address account, uint256 amount, string memory reason) internal {
    userState[account].bonded = userState[account].bonded.sub(amount, reason);

    _updateEpochState(_globalBonded.sub(amount, reason));
  }

  function _updateEpochState(uint256 newTotalBonded) internal {
    EpochState storage state = epochState[_currentEpoch];
    uint256 epoch = dao.epoch();
    uint256 epochStartTime = dao.getEpochStartTime(_currentEpoch);
    uint256 lastUpdateTime = state.lastUpdateTime;
    uint256 lengthOfEpoch = dao.epochLength();
    uint256 epochEndTime = epochStartTime + lengthOfEpoch;

    if (lastUpdateTime == 0) {
      lastUpdateTime = epochStartTime;
    }

    if (lastUpdateTime > epochEndTime) {
      lastUpdateTime = epochEndTime;
    }

    if (epoch == _currentEpoch) {
      // We are still in the same epoch. Just update
      uint256 finalTime = block.timestamp;
      if (block.timestamp > epochEndTime) {
        // We are past the end of the epoch so cap to end of epoch
        finalTime = epochEndTime;
      } 

      uint256 diff = finalTime - lastUpdateTime;

      if (diff > 0) {
        state.cumulativeTotalBonded = state.cumulativeTotalBonded + (state.lastTotalBonded.mul(diff));

        state.lastUpdateTime = finalTime;
        state.lastTotalBonded = newTotalBonded;
      }
    } else {
      // We have crossed at least 1 epoch boundary

      // Won't underflow due to check on lastUpdateTime above
      uint256 diff = epochEndTime - lastUpdateTime;

      state.cumulativeTotalBonded = state.cumulativeTotalBonded + (state.lastTotalBonded.mul(diff));
      state.lastUpdateTime = epochEndTime;
      state.lastTotalBonded = _globalBonded;

      for (uint256 i = _currentEpoch + 1; i <= epoch; i += 1) {
        state = epochState[i];
        epochStartTime = dao.getEpochStartTime(i);
        epochEndTime = epochStartTime + lengthOfEpoch;
        state.lastTotalBonded = _globalBonded;

        if (epochEndTime < block.timestamp) {
          // The desired epoch is in the past
          diff = lengthOfEpoch;
          state.lastUpdateTime = epochEndTime;
        } else {
          diff = block.timestamp - epochStartTime;
          state.lastUpdateTime = block.timestamp;
        }

        state.cumulativeTotalBonded = state.lastTotalBonded.mul(diff);
      }

      state.lastTotalBonded = newTotalBonded;
      _currentEpoch = epoch;
    } 

    _globalBonded = newTotalBonded;
  }

  /*
   * PRIVILEDGED FUNCTIONS
   */
  function setMiningService(address _miningService)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_miningService != address(0), ""Cannot set 0 address"");
    miningService = IMiningService(_miningService);
  }

  function setDAO(address _dao)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_dao != address(0), ""Cannot set 0 address"");
    dao = IDAO(_dao);
  }

  function setDexHandler(address _dexHandler)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_dexHandler != address(0), ""Cannot set 0 address"");
    dexHandler = IDexHandler(_dexHandler);
  }

  function setCurrentEpoch(uint256 _epoch)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    _currentEpoch = _epoch;
  }
}",2523
RealWorld_BA_59_ITransferService_RealWord_20240822085335.log,59,ITransferService,4057,4112,8169,74.0,0.102525,"pragma solidity >=0.6.6;

interface ITransferService {
  function verifyTransfer(address, address, uint256) external view returns (bool, string memory);
  function numberOfVerifiers() external view returns (uint256);
  function addVerifier(address, address) external;
  function removeVerifier(address) external;
}",66
RealWorld_BA_59_TransferService_RealWord_20240822080158.log,59,TransferService,14415,5359,19774,87.0,0.179255,"pragma solidity >=0.6.6;

import ""@openzeppelin/upgrades/contracts/Initializable.sol"";

import ""./interfaces/IMaltDataLab.sol"";
import ""./Permissions.sol"";

import ""./interfaces/ITransferVerification.sol"";


/// @title Transfer Service
/// @author 0xScotch <scotch@malt.money>
/// @notice A contract that acts like a traffic warden to ensure tranfer verification requests get routed correctly
contract TransferService is Initializable, Permissions {
  address[] public verifierList;
  mapping(address => address) public verifiers;

  event AddVerifier(address indexed source, address verifier);
  event RemoveVerifier(address indexed source, address verifier);

  function initialize(
    address _timelock,
    address initialAdmin
  ) external initializer {
    _adminSetup(_timelock);
    _setupRole(ADMIN_ROLE, initialAdmin);
  }

  function verifyTransfer(address from, address to, uint256 amount) public view returns (bool, string memory) {
    if (verifiers[from] != address(0)) {
      (bool valid, string memory reason) = ITransferVerification(verifiers[from]).verifyTransfer(from, to, amount);
      if (!valid) {
        return (false, reason);
      }
    } 

    if (verifiers[to] != address(0)) {
      (bool valid, string memory reason) = ITransferVerification(verifiers[to]).verifyTransfer(from, to, amount);
      if (!valid) {
        return (false, reason);
      }
    } 

    return (true, """");
  }

  function numberOfVerifiers() public view returns(uint256) {
    return verifierList.length;
  }

  /*
   * PRIVILEDGED METHODS
   */
  function addVerifier(address _address, address _verifier) 
    public
    onlyRole(ADMIN_ROLE, ""Must have admin role"") 
  {
    require(_verifier != address(0), ""Cannot use address 0"");
    require(_address != address(0), ""Cannot use address 0"");

    if (verifiers[_address] != address(0)) {
      return;
    }

    verifiers[_address] = _verifier;
    verifierList.push(_address);

    emit AddVerifier(_address, _verifier);
  }

  function removeVerifier(address _address) 
    public
    onlyRole(ADMIN_ROLE, ""Must have admin role"")  
  {
    require(_address != address(0), ""Cannot use address 0"");

    if (verifiers[_address] == address(0)) {
      return;
    }

    address verifier = verifiers[_address];
    verifiers[_address] = address(0);

    emit RemoveVerifier(_address, verifier);

    // Loop until the second last element
    for (uint i = 0; i < verifierList.length - 1; i = i + 1) {
      if (verifierList[i] == _address) {
        // Replace the current item with the last and pop the last away.
        verifierList[i] = verifierList[verifierList.length - 1];
        verifierList.pop();
        return;
      }
    }

    // If we made it here then the verifierList being removed is the last item
    verifierList.pop();
  }
}",684
RealWorld_BA_59_ERC20VestedMine_RealWord_20240822081319.log,59,ERC20VestedMine,20367,5198,25565,78.0,0.205795,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";

import ""./AbstractRewardMine.sol"";
import ""./interfaces/IDistributor.sol"";
import ""./interfaces/IBonding.sol"";


/// @title ERC20 Vested Mine
/// @author 0xScotch <scotch@malt.money>
/// @notice An implementation of AbstractRewardMine to handle rewards being vested by the RewardDistributor
contract ERC20VestedMine is Initializable, AbstractRewardMine {
  IDistributor public distributor;
  IBonding public bonding;

  function initialize(
    address _timelock,
    address initialAdmin,
    address _miningService,
    address _distributor,
    address _bonding,
    address _rewardToken
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);

    distributor = IDistributor(_distributor);
    bonding = IBonding(_bonding);

    _initialSetup(_rewardToken, _miningService);
  }

  function onUnbond(address account, uint256 amount)
    override
    public
    onlyRole(MINING_SERVICE_ROLE, ""Must having mining service privilege"")
  {
    // Withdraw all current rewards
    // Done now before we change stake padding below
    uint256 rewardEarned = earned(account);
    _handleWithdrawForAccount(account, rewardEarned, account);

    uint256 bondedBalance = balanceOfBonded(account);

    if (bondedBalance == 0) {
      return;
    }

    _checkForForfeit(account, amount, bondedBalance);

    uint256 lessStakePadding = balanceOfStakePadding(account).mul(amount).div(bondedBalance);

    _reconcileWithdrawn(account, amount, bondedBalance);
    _removeFromStakePadding(account, lessStakePadding, ""< stake padding"");
  }

  function totalBonded() override public view returns (uint256) {
    return bonding.totalBonded();
  }

  function balanceOfBonded(address account) override public view returns (uint256) {
    return bonding.balanceOfBonded(account);
  }

  /*
   * totalReleasedReward and totalDeclaredReward will often be the same. However, in the case
   * of vesting rewards they are different. In that case totalDeclaredReward is total
   * reward, including unvested. totalReleasedReward is just the rewards that have completed
   * the vesting schedule.
   */
  function totalDeclaredReward() override public view returns (uint256) {
    return distributor.totalDeclaredReward();
  }

  function totalReleasedReward() override public view returns (uint256) {
    return rewardToken.balanceOf(address(this)) + _globalWithdrawn;
  }

  /*
   * INTERNAL FUNCTIONS
   */
  function _checkForForfeit(address account, uint256 amount, uint256 bondedBalance) internal {
    // This is the user's share of total rewards
    uint256 userReward = balanceOfRewards(account);
    uint256 globalRewarded = totalDeclaredReward();

    uint256 earnedReward = 0;
    
    // This is done inline instead of using earned() to save gas
    if (globalRewarded > 0 && userReward > 0) {
      // Note this doesn't factor in withdrawn as it is working
      // on absolute reward terms
      earnedReward = totalReleasedReward().mul(userReward) / globalRewarded;
    }

    // The user is unbonding so we should reduce declaredReward
    // proportional to the unbonded amount
    // At any given point in time, every user has rewards allocated
    // to them. balanceOfRewards(account) will tell you this value.
    // If a user unbonds x% of their LP then declaredReward should
    // reduce by exactly x% of that user's allocated rewards

    // However, this has to be done in 2 parts. First forfeit x%
    // Of unvested rewards. This decrements declaredReward automatically.
    // Then we call decrementRewards using x% of rewards that have 
    // already been released. The net effect is declaredReward decreases
    // by x% of the users allocated reward

    uint256 forfeitReward = userReward.sub(earnedReward).mul(amount) / bondedBalance;
    uint256 declaredRewardDecrease = earnedReward.mul(amount) / bondedBalance;

    if (forfeitReward > 0) {
      distributor.forfeit(forfeitReward);
    }

    if (declaredRewardDecrease > 0) {
      distributor.decrementRewards(declaredRewardDecrease);
    }
  }

  /*
   * PRIVILEDGED FUNCTIONS
   */
  function setDistributor(address _distributor)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    distributor = IDistributor(_distributor);
  }

  function setBonding(address _bonding)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    bonding = IBonding(_bonding);
  }
}",1080
RealWorld_BA_59_Auction_RealWord_20240822083206.log,59,Auction,121050,5754,126804,124.0,0.72033,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/math/Math.sol"";

import ""./Permissions.sol"";
import ""./interfaces/IAuction.sol"";
import ""./interfaces/IBurnMintableERC20.sol"";
import ""./interfaces/IMaltDataLab.sol"";
import ""./interfaces/IDexHandler.sol"";
import ""./interfaces/ILiquidityExtension.sol"";
import ""./interfaces/IImpliedCollateralService.sol"";
import ""./interfaces/IAuctionBurnReserveSkew.sol"";
import ""./interfaces/IAuctionStartController.sol"";


struct AccountCommitment {
  uint256 commitment;
  uint256 redeemed;
  uint256 maltPurchased;
}

struct AuctionData {
  // The full amount of commitments required to return to peg
  uint256 fullRequirement;
  // total maximum desired commitments to this auction
  uint256 maxCommitments;
  // Quantity of sale currency committed to this auction
  uint256 commitments;
  // Malt purchased and burned using current commitments
  uint256 maltPurchased;
  // Desired starting price for the auction
  uint256 startingPrice;
  // Desired lowest price for the arbitrage token
  uint256 endingPrice;
  // Price of arbitrage tokens at conclusion of auction. This is either
  // when the duration elapses or the maxCommitments is reached
  uint256 finalPrice;
  // The peg price for the liquidity pool
  uint256 pegPrice;
  // Time when auction started
  uint256 startingTime;
  uint256 endingTime;
  // Is the auction currently accepting commitments?
  bool active;
  // The reserve ratio at the start of the auction
  uint256 preAuctionReserveRatio;
  // Has this auction been finalized? Meaning any additional stabilizing
  // has been done
  bool finalized;
  // The amount of arb tokens that have been executed and are now claimable
  uint256 claimableTokens;
  // The finally calculated realBurnBudget
  uint256 finalBurnBudget;
  // The amount of Malt purchased with realBurnBudget
  uint256 finalPurchased;
  // A map of all commitments to this auction by specific accounts
  mapping(address => AccountCommitment) accountCommitments;
}


/// @title Malt Arbitrage Auction
/// @author 0xScotch <scotch@malt.money>
/// @notice The under peg Malt mechanism of dutch arbitrage auctions is implemented here
contract Auction is Initializable, Permissions {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  bytes32 public constant AUCTION_AMENDER_ROLE = keccak256(""AUCTION_AMENDER_ROLE"");

  address public stabilizerNode;
  address public amender;
  IMaltDataLab public maltDataLab;
  ERC20 public collateralToken;
  IBurnMintableERC20 public malt;
  IDexHandler public dexHandler;
  ILiquidityExtension public liquidityExtension;
  IImpliedCollateralService public impliedCollateralService;
  IAuctionBurnReserveSkew public auctionBurnReserveSkew;

  uint256 public unclaimedArbTokens;
  uint256 public replenishingAuctionId;
  uint256 public currentAuctionId;
  uint256 public claimableArbitrageRewards;
  uint256 public nextCommitmentId;
  uint256 public auctionLength = 600; // 10 minutes
  uint256 public arbTokenReplenishSplit = 7000; // 70%
  uint256 public maxAuctionEnd = 900; // 90% of target price
  uint256 public auctionEndReserveBps = 900; // 90% of collateral
  uint256 public priceLookback = 2 minutes;
  uint256 public reserveRatioLookback = 30; // 30 seconds
  uint256 public dustThreshold = 1e4;

  address public auctionStartController;

  mapping (uint256 => AuctionData) internal idToAuction;
  mapping(address => uint256[]) internal accountCommitmentEpochs;

  event AuctionCommitment(
    uint256 commitmentId,
    uint256 auctionId,
    address account,
    uint256 commitment,
    uint256 purchased
  );

  event ClaimArbTokens(
    uint256 auctionId,
    address account,
    uint256 amountTokens
  );

  event AuctionEnded(
    uint256 id,
    uint256 commitments,
    uint256 startingPrice,
    uint256 finalPrice,
    uint256 maltPurchased
  );

  event AuctionStarted(
    uint256 id,
    uint256 maxCommitments,
    uint256 startingPrice,
    uint256 endingPrice,
    uint256 startingTime,
    uint256 endingTime
  );

  event ArbTokenAllocation(
    uint256 replenishingAuctionId,
    uint256 maxArbAllocation
  );

  event SetAuctionLength(uint256 length);
  event SetStabilizerNode(address stabilizerNode);
  event SetMaltDataLab(address dataLab);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _collateralToken,
    address _malt,
    uint256 _auctionLength,
    address _stabilizerNode,
    address _maltDataLab,
    address _dexHandler,
    address _liquidityExtension,
    address _impliedCollateralService,
    address _auctionBurnReserveSkew,
    address _amender
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);
    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);
    _roleSetup(AUCTION_AMENDER_ROLE, _amender);

    collateralToken = ERC20(_collateralToken);
    malt = IBurnMintableERC20(_malt);
    auctionLength = _auctionLength;
    stabilizerNode = _stabilizerNode;
    maltDataLab = IMaltDataLab(_maltDataLab);
    dexHandler = IDexHandler(_dexHandler);
    liquidityExtension = ILiquidityExtension(_liquidityExtension);
    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);
    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);
    amender = _amender;
  }

  /*
   * PUBLIC METHODS
   */
  function purchaseArbitrageTokens(uint256 amount) external notSameBlock {
    require(auctionActive(currentAuctionId), ""No auction running"");

    uint256 realCommitment = _capCommitment(currentAuctionId, amount);

    collateralToken.safeTransferFrom(msg.sender, address(liquidityExtension), realCommitment);

    uint256 purchased = liquidityExtension.purchaseAndBurn(realCommitment);
    
    AuctionData storage auction = idToAuction[currentAuctionId];

    require(auction.startingTime <= now, ""Auction hasn't started yet"");
    require(auction.endingTime >= now, ""Auction is already over"");
    require(auction.active == true, ""Auction is not active"");

    auction.commitments = auction.commitments.add(realCommitment);

    if (auction.accountCommitments[msg.sender].commitment == 0) {
      accountCommitmentEpochs[msg.sender].push(currentAuctionId);
    }
    auction.accountCommitments[msg.sender].commitment = auction.accountCommitments[msg.sender].commitment.add(realCommitment);
    auction.accountCommitments[msg.sender].maltPurchased = auction.accountCommitments[msg.sender].maltPurchased.add(purchased);
    auction.maltPurchased = auction.maltPurchased.add(purchased);

    emit AuctionCommitment(
      nextCommitmentId,
      currentAuctionId,
      msg.sender,
      realCommitment,
      purchased
    );

    nextCommitmentId = nextCommitmentId + 1;

    if (auction.commitments >= auction.maxCommitments) {
      _endAuction(currentAuctionId) ;
    }
  }

  function claimArbitrage(uint256 _auctionId) external notSameBlock {
    uint256 amountTokens = userClaimableArbTokens(msg.sender, _auctionId);

    require(amountTokens > 0, ""No claimable Arb tokens"");

    AuctionData storage auction = idToAuction[_auctionId];

    require(!auction.active, ""Cannot claim tokens on an active auction"");

    AccountCommitment storage commitment = auction.accountCommitments[msg.sender];

    uint256 redemption = amountTokens.mul(auction.finalPrice).div(auction.pegPrice);
    uint256 remaining = commitment.commitment.sub(commitment.redeemed);

    require(redemption <= remaining.add(1), ""Cannot claim more tokens than available"");

    commitment.redeemed = commitment.redeemed.add(redemption);

    // Unclaimed represents total outstanding, but not necessarily
    // claimable yet.
    // claimableArbitrageRewards represents total amount that is now
    // available to be claimed
    if (amountTokens > unclaimedArbTokens) {
      unclaimedArbTokens = 0;
    } else {
      unclaimedArbTokens = unclaimedArbTokens.sub(amountTokens);
    }

    if (amountTokens > claimableArbitrageRewards) {
      claimableArbitrageRewards = 0;
    } else {
      claimableArbitrageRewards = claimableArbitrageRewards.sub(amountTokens);
    }

    collateralToken.safeTransfer(msg.sender, amountTokens);

    emit ClaimArbTokens(
      _auctionId,
      msg.sender,
      amountTokens
    );
  }

  /*
   * PUBLIC VIEW FUNCTIONS
   */
  function isAuctionFinished(uint256 _id) public view returns(bool) {
    AuctionData storage auction = idToAuction[_id];

    return auction.endingTime > 0 && (now >= auction.endingTime || auction.finalPrice > 0 || auction.commitments >= auction.maxCommitments);
  }

  function auctionActive(uint256 _id) public view returns (bool) {
    AuctionData storage auction = idToAuction[_id];
    
    return auction.active && now >= auction.startingTime;
  }

  function isAuctionFinalized(uint256 _id) public view returns (bool) {
    AuctionData storage auction = idToAuction[_id];
    return auction.finalized;
  }

  function userClaimableArbTokens(
    address account,
    uint256 auctionId
  ) public view returns (uint256) {
    AuctionData storage auction = idToAuction[auctionId];

    if (auction.claimableTokens == 0 || auction.finalPrice == 0 || auction.commitments == 0) {
      return 0;
    }

    AccountCommitment storage commitment = auction.accountCommitments[account];

    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);


    uint256 claimablePerc = auction.claimableTokens.mul(auction.pegPrice).div(totalTokens);

    uint256 price = auction.finalPrice;

    if (auction.finalPrice == 0) {
      price = currentPrice(auctionId);
    }

    uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price);
    uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price);

    uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens);

    // Avoid leaving dust behind
    if (amountOut < dustThreshold) {
      return 0;
    }

    return amountOut;
  }

  function balanceOfArbTokens(
    uint256 _auctionId,
    address account
  ) public view returns (uint256) {
    AuctionData storage auction = idToAuction[_auctionId];

    AccountCommitment storage commitment = auction.accountCommitments[account];

    uint256 remaining = commitment.commitment.sub(commitment.redeemed);

    uint256 price = auction.finalPrice;

    if (auction.finalPrice == 0) {
      price = currentPrice(_auctionId);
    }

    return remaining.mul(auction.pegPrice).div(price);
  }

  function averageMaltPrice(uint256 _id) external view returns (uint256) {
    AuctionData storage auction = idToAuction[_id];

    if (auction.maltPurchased == 0) {
      return 0;
    }

    return auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);
  }

  function currentPrice(uint256 _id) public view returns (uint256) {
    AuctionData storage auction = idToAuction[_id];

    if (auction.startingTime == 0) {
      return maltDataLab.priceTarget();
    }

    uint256 secondsSinceStart = 0;

    if (now > auction.startingTime) {
      secondsSinceStart = now - auction.startingTime;
    }

    uint256 auctionDuration = auction.endingTime - auction.startingTime;

    if (secondsSinceStart >= auctionDuration) {
      return auction.endingPrice;
    }

    uint256 totalPriceDelta = auction.startingPrice.sub(auction.endingPrice);

    uint256 currentPriceDelta = totalPriceDelta.mul(secondsSinceStart).div(auctionDuration);

    return auction.startingPrice.sub(currentPriceDelta);
  }

  function getAuctionCommitments(uint256 _id) public view returns (uint256 commitments, uint256 maxCommitments) {
    AuctionData storage auction = idToAuction[_id];

    return (auction.commitments, auction.maxCommitments);
  }

  function getAuctionPrices(uint256 _id) public view returns (uint256 startingPrice, uint256 endingPrice, uint256 finalPrice) {
    AuctionData storage auction = idToAuction[_id];

    return (auction.startingPrice, auction.endingPrice, auction.finalPrice);
  }

  function auctionExists(uint256 _id) public view returns (bool) {
    AuctionData storage auction = idToAuction[_id];

    return auction.startingTime > 0;
  }

  function getAccountCommitments(address account) external view returns (
    uint256[] memory auctions,
    uint256[] memory commitments,
    uint256[] memory awardedTokens,
    uint256[] memory redeemedTokens,
    uint256[] memory finalPrice,
    uint256[] memory claimable,
    bool[] memory finished
  ) {
    uint256[] memory epochCommitments = accountCommitmentEpochs[account];

    auctions = new uint256[](epochCommitments.length);
    commitments = new uint256[](epochCommitments.length);
    awardedTokens = new uint256[](epochCommitments.length);
    redeemedTokens = new uint256[](epochCommitments.length);
    finalPrice = new uint256[](epochCommitments.length);
    claimable = new uint256[](epochCommitments.length);
    finished = new bool[](epochCommitments.length);

    for (uint i = 0; i < epochCommitments.length; ++i) {
      AuctionData storage auction = idToAuction[epochCommitments[i]];

      AccountCommitment storage commitment = auction.accountCommitments[account];

      uint256 price = auction.finalPrice;

      if (auction.finalPrice == 0) {
        price = currentPrice(epochCommitments[i]);
      }

      auctions[i] = epochCommitments[i];
      commitments[i] = commitment.commitment;
      awardedTokens[i] = commitment.commitment.mul(auction.pegPrice).div(price);
      redeemedTokens[i] = commitment.redeemed.mul(auction.pegPrice).div(price);
      finalPrice[i] = price;
      claimable[i] = userClaimableArbTokens(account, epochCommitments[i]);
      finished[i] = isAuctionFinished(epochCommitments[i]);
    }
  }

  function getAccountCommitmentAuctions(address account) external view returns (uint[] memory) {
    return accountCommitmentEpochs[account];
  }

  function getAuctionParticipationForAccount(address account, uint256 auctionId) external view returns (
    uint256 commitment,
    uint256 redeemed,
    uint256 maltPurchased
  ) {
    AccountCommitment storage commitment = idToAuction[auctionId].accountCommitments[account];

    return (commitment.commitment, commitment.redeemed, commitment.maltPurchased);
  }

  function getActiveAuction() external view returns (
    uint256 auctionId,
    uint256 maxCommitments,
    uint256 commitments,
    uint256 maltPurchased,
    uint256 startingPrice,
    uint256 endingPrice,
    uint256 finalPrice,
    uint256 pegPrice,
    uint256 startingTime,
    uint256 endingTime,
    uint256 finalBurnBudget,
    uint256 finalPurchased
  ) {
    AuctionData storage auction = idToAuction[currentAuctionId];

    return (
      currentAuctionId,
      auction.maxCommitments,
      auction.commitments,
      auction.maltPurchased,
      auction.startingPrice,
      auction.endingPrice,
      auction.finalPrice,
      auction.pegPrice,
      auction.startingTime,
      auction.endingTime,
      auction.finalBurnBudget,
      auction.finalPurchased
    );
  }

  function getAuction(uint256 _id) public view returns (
    uint256 fullRequirement,
    uint256 maxCommitments,
    uint256 commitments,
    uint256 startingPrice,
    uint256 endingPrice,
    uint256 finalPrice,
    uint256 pegPrice,
    uint256 startingTime,
    uint256 endingTime,
    uint256 finalBurnBudget,
    uint256 finalPurchased
  ) {
    AuctionData storage auction = idToAuction[_id];

    return (
      auction.fullRequirement,
      auction.maxCommitments,
      auction.commitments,
      auction.startingPrice,
      auction.endingPrice,
      auction.finalPrice,
      auction.pegPrice,
      auction.startingTime,
      auction.endingTime,
      auction.finalBurnBudget,
      auction.finalPurchased
    );
  }

  function getAuctionCore(uint256 _id) public view returns (
    uint256 auctionId,
    uint256 commitments,
    uint256 maltPurchased,
    uint256 startingPrice,
    uint256 finalPrice,
    uint256 pegPrice,
    uint256 startingTime,
    uint256 endingTime,
    uint256 preAuctionReserveRatio,
    bool active
  ) {
    AuctionData storage auction = idToAuction[_id];

    return (
      _id,
      auction.commitments,
      auction.maltPurchased,
      auction.startingPrice,
      auction.finalPrice,
      auction.pegPrice,
      auction.startingTime,
      auction.endingTime,
      auction.preAuctionReserveRatio,
      auction.active
    );
  }

  /*
   * INTERNAL FUNCTIONS
   */
  function _triggerAuction(
    uint256 pegPrice,
    uint256 rRatio,
    uint256 purchaseAmount
  ) internal {
    if (auctionStartController != address(0)) {
      bool success = IAuctionStartController(auctionStartController).checkForStart();
      if (!success) {
        return;
      }
    }
    (uint256 startingPrice, uint256 endingPrice) = _calculateAuctionPricing(rRatio);

    AuctionData memory auction = AuctionData(
      purchaseAmount, // fullRequirement
      purchaseAmount, // maxCommitments
      0, // commitments
      0, // maltPurchased
      startingPrice,
      endingPrice,
      0, // finalPrice
      pegPrice,
      now, // startingTime
      now.add(auctionLength), // endingTime
      true, // active
      rRatio, // preAuctionReserveRatio
      false, // finalized
      0, // claimableTokens
      0, // finalBurnBudget
      0 // finalPurchased
    );

    _createAuction(
      currentAuctionId,
      auction
    );
  }

  function _capCommitment(uint256 _id, uint256 _commitment) internal view returns (uint256 realCommitment) {
    AuctionData storage auction = idToAuction[_id];

    realCommitment = _commitment;

    if (auction.commitments.add(_commitment) >= auction.maxCommitments) {
      realCommitment = auction.maxCommitments.sub(auction.commitments);
    }
  }

  function _endAuction(uint256 _id) internal {
    AuctionData storage auction = idToAuction[_id];

    require(auction.active == true, ""Auction is already over"");

    auction.active = false;
    auction.finalPrice = currentPrice(_id);

    uint256 amountArbTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);
    unclaimedArbTokens = unclaimedArbTokens.add(amountArbTokens);

    emit AuctionEnded(
      _id,
      auction.commitments,
      auction.startingPrice,
      auction.finalPrice,
      auction.maltPurchased
    );
  }

  function _finalizeAuction(uint256 auctionId) internal {
    (
      uint256 avgMaltPrice,
      uint256 commitments,
      uint256 fullRequirement,
      uint256 maltPurchased,
      uint256 finalPrice,
      uint256 preAuctionReserveRatio
    ) = _setupAuctionFinalization(auctionId);

    if (commitments >= fullRequirement) {
      return;
    }

    uint256 priceTarget = maltDataLab.priceTarget();

    // priceTarget.sub(preAuctionReserveRatio) represents maximum deficit per token
    // priceTarget divided by the max deficit is equivalent to 1 over the max deficit given we are in uint decimal
    // (commitments * 1/maxDeficit) - commitments
    uint256 maxBurnSpend = (commitments.mul(priceTarget).div(priceTarget.sub(preAuctionReserveRatio))).sub(commitments);

    uint256 totalTokens = commitments.mul(priceTarget).div(finalPrice);

    uint256 premiumExcess = 0;

    // The assumption here is that each token will be worth 1 Malt when redeemed.
    // Therefore if totalTokens is greater than the malt purchased then there is a net supply growth
    // After the tokens are repaid. We want this process to be neutral to supply at the very worst.
    if (totalTokens >= maltPurchased) {
      // This also assumes current purchase price of Malt is $1, which is higher than it will be in practice.
      // So the premium excess will actually ensure slight net negative supply growth.
      premiumExcess = totalTokens - maltPurchased;
    }

    uint256 realBurnBudget = auctionBurnReserveSkew.getRealBurnBudget(maxBurnSpend, premiumExcess);

    if (realBurnBudget > 0) {
      AuctionData storage auction = idToAuction[auctionId];

      auction.finalBurnBudget = realBurnBudget;
      auction.finalPurchased = liquidityExtension.purchaseAndBurn(realBurnBudget);
    }
  }

  function _setupAuctionFinalization(uint256 auctionId)
    internal
    returns (
      uint256 avgMaltPrice,
      uint256 commitments,
      uint256 fullRequirement,
      uint256 maltPurchased,
      uint256 finalPrice,
      uint256 preAuctionReserveRatio
    )
  {
    AuctionData storage auction = idToAuction[auctionId];
    require(auction.startingTime > 0, ""No auction available for the given id"");

    auction.finalized = true;

    if (auction.maltPurchased > 0) {
      avgMaltPrice = auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);
    }
    
    return (
      avgMaltPrice,
      auction.commitments,
      auction.fullRequirement,
      auction.maltPurchased,
      auction.finalPrice,
      auction.preAuctionReserveRatio
    );
  }

  function _createAuction(
    uint256 _id,
    AuctionData memory auction
  ) internal {
    require(auction.endingTime == uint256(uint64(auction.endingTime)));

    idToAuction[_id] = auction;

    emit AuctionStarted(
      _id,
      auction.maxCommitments,
      auction.startingPrice,
      auction.endingPrice,
      auction.startingTime,
      auction.endingTime
    );
  }

  function _calcRealMaxRaise(uint256 purchaseAmount, uint256 rRatio, uint256 decimals) internal pure returns (uint256) {
    uint256 realBurn = purchaseAmount.mul(
      Math.min(
        rRatio,
        10**decimals
      )
    ).div(10**decimals);

    return purchaseAmount.sub(realBurn);
  }

  function _calculateAuctionPricing(uint256 rRatio) internal view returns (
    uint256 startingPrice,
    uint256 endingPrice
  ) {
    startingPrice = maltDataLab.maltPriceAverage(priceLookback);

    if (startingPrice < rRatio) {
      startingPrice = rRatio;
    }

    // TODO use global intrinsic value instead of rRatio Fri 12 Nov 2021 11:51:28 GMT

    // rRatio should never be large enough for this to overflow
    uint256 absoluteBottom = rRatio * auctionEndReserveBps / 1000;

    uint256 priceTarget = maltDataLab.priceTarget();
    uint256 idealBottom = 1; // 1wei just to avoid any issues with it being 0

    // This should always be true
    if (priceTarget > rRatio) {
      idealBottom = priceTarget - rRatio;
    }

    assert(priceTarget >= startingPrice);
    assert(startingPrice > endingPrice);

    if (idealBottom < startingPrice) {
      endingPrice = idealBottom;
    } else {
      endingPrice = absoluteBottom;
    } 

    // priceTarget should never be large enough to overflow here
    uint256 maxPrice = priceTarget * maxAuctionEnd / 1000;

    if (endingPrice > maxPrice) {
      endingPrice = maxPrice;
    }
  }

  function _checkAuctionFinalization(bool isInternal) internal {
    if (isInternal && !isAuctionFinished(currentAuctionId)) {
      // Auction is still in progress after internal auction purchasing.
      _resetAuctionMaxCommitments();
    }

    if (isAuctionFinished(currentAuctionId)) {
      if (auctionActive(currentAuctionId)) {
        _endAuction(currentAuctionId);
      }

      if (!isAuctionFinalized(currentAuctionId)) {
        _finalizeAuction(currentAuctionId);
      }
      currentAuctionId = currentAuctionId + 1;
    }
  }

  function _resetAuctionMaxCommitments() internal {
    AuctionData storage auction = idToAuction[currentAuctionId];

    uint256 decimals = collateralToken.decimals();

    uint256 realMaxRaise = _calcRealMaxRaise(auction.fullRequirement, auction.preAuctionReserveRatio, decimals);

    if (auction.commitments <= realMaxRaise) {
      auction.maxCommitments = realMaxRaise;
    }
  }

  /*
   * PRIVILEDGED FUNCTIONS
   */
  function checkAuctionFinalization()
    external
    onlyRole(STABILIZER_NODE_ROLE, ""Must be stabilizer node"")
  {
    _checkAuctionFinalization(false);
  }

  function amendAccountParticipation(address account, uint256 auctionId, uint256 amount, uint256 maltPurchase)
    external
    onlyRole(AUCTION_AMENDER_ROLE, ""Only auction amender"")
  {
    AuctionData storage auction = idToAuction[auctionId];
    require(auction.accountCommitments[account].commitment >= amount, ""amend: amount underflows"");
    require(auction.accountCommitments[account].maltPurchased >= maltPurchase, ""amend: maltPurchase underflows"");

    auction.commitments = auction.commitments - amount;
    auction.maltPurchased = auction.maltPurchased - maltPurchase;

    auction.accountCommitments[account].commitment = auction.accountCommitments[account].commitment - amount; 
    auction.accountCommitments[account].maltPurchased = auction.accountCommitments[account].maltPurchased - maltPurchase;

    uint256 amountArbTokens = amount.mul(auction.pegPrice).div(auction.finalPrice);

    if (amountArbTokens > unclaimedArbTokens) {
      unclaimedArbTokens = 0;
    } else {
      unclaimedArbTokens = unclaimedArbTokens.sub(amountArbTokens);
    }
  }

  function allocateArbRewards(uint256 rewarded)
    external
    onlyRole(STABILIZER_NODE_ROLE, ""Must be stabilizer node"")
    returns (uint256)
  {
    AuctionData storage auction = idToAuction[replenishingAuctionId];

    if (auction.finalPrice == 0 || auction.startingTime == 0) {
      return rewarded;
    }

    if (auction.commitments == 0) {
      replenishingAuctionId = replenishingAuctionId + 1;
      return rewarded;
    }

    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);

    if (auction.claimableTokens < totalTokens) {
      uint256 requirement = totalTokens.sub(auction.claimableTokens);
      uint256 maxArbAllocation = rewarded.mul(arbTokenReplenishSplit).div(10000);

      if (requirement >= maxArbAllocation) {
        auction.claimableTokens = auction.claimableTokens.add(maxArbAllocation);
        rewarded = rewarded.sub(maxArbAllocation);
        claimableArbitrageRewards = claimableArbitrageRewards.add(maxArbAllocation);

        collateralToken.safeTransferFrom(stabilizerNode, address(this), maxArbAllocation);

        emit ArbTokenAllocation(
          replenishingAuctionId,
          maxArbAllocation
        );
      } else {
        auction.claimableTokens = auction.claimableTokens.add(requirement);
        rewarded = rewarded.sub(requirement);
        claimableArbitrageRewards = claimableArbitrageRewards.add(requirement);

        collateralToken.safeTransferFrom(stabilizerNode, address(this), requirement);

        emit ArbTokenAllocation(
          replenishingAuctionId,
          requirement
        );
      }

      if (auction.claimableTokens == totalTokens) {
        uint256 count = 1;

        while (true) {
          auction = idToAuction[replenishingAuctionId + count];

          if (auction.commitments > 0 || !auction.finalized) {
            replenishingAuctionId = replenishingAuctionId + count;
            break;
          }
          count += 1;
        }
      }
    }

    return rewarded;
  }

  function triggerAuction(uint256 pegPrice, uint256 purchaseAmount)
    external
    onlyRole(STABILIZER_NODE_ROLE, ""Must be stabilizer node"")
  {
    if (purchaseAmount == 0 || auctionExists(currentAuctionId)) {
      return;
    }

    uint256 rRatio = maltDataLab.reserveRatioAverage(reserveRatioLookback);

    _triggerAuction(pegPrice, rRatio, purchaseAmount);

    impliedCollateralService.handleDeficit(purchaseAmount);

    _checkAuctionFinalization(true);
  }

  function setAuctionLength(uint256 _length)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    require(_length > 0, ""Length must be larger than 0"");
    auctionLength = _length;
    emit SetAuctionLength(_length);
  }

  function setStabilizerNode(address _stabilizerNode)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    _swapRole(_stabilizerNode, stabilizerNode, STABILIZER_NODE_ROLE);
    stabilizerNode = _stabilizerNode;
    emit SetStabilizerNode(_stabilizerNode);
  }

  function setMaltDataLab(address _dataLab)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    maltDataLab = IMaltDataLab(_dataLab);
    emit SetMaltDataLab(_dataLab);
  }

  function setAuctionReplenishId(uint256 _id)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    replenishingAuctionId = _id;
  }

  function setDexHandler(address _handler)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    dexHandler = IDexHandler(_handler);
  }

  function setLiquidityExtension(address _liquidityExtension)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    liquidityExtension = ILiquidityExtension(_liquidityExtension);
  }

  function setImpliedCollateralService(address _impliedCollateralService)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);
  }

  function setAuctionBurnReserveSkew(address _reserveSkew)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_reserveSkew);
  }

  function setAuctionAmender(address _amender)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    require(_amender != address(0), ""Cannot set 0 address"");
    _swapRole(_amender, amender, AUCTION_AMENDER_ROLE);
    amender = _amender;
  }

  function setAuctionStartController(address _controller)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    // This is allowed to be set to address(0) as its checked before calling methods on it
    auctionStartController = _controller;
  }

  function setTokenReplenishSplit(uint256 _split)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    require(_split > 0 && _split <= 10000, ""Must be between 0-100%"");
    arbTokenReplenishSplit = _split;
  }

  function setMaxAuctionEnd(uint256 _maxEnd)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    require(_maxEnd > 0 && _maxEnd <= 1000, ""Must be between 0-100%"");
    maxAuctionEnd = _maxEnd;
  }

  function setPriceLookback(uint256 _lookback)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    require(_lookback > 0, ""Must be above 0"");
    priceLookback = _lookback;
  }

  function setReserveRatioLookback(uint256 _lookback)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    require(_lookback > 0, ""Must be above 0"");
    reserveRatioLookback = _lookback;
  }

  function setAuctionEndReserveBps(uint256 _bps)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    require(_bps > 0 && _bps < 1000, ""Must be between 0-100%"");
    auctionEndReserveBps = _bps;
  }

  function setDustThreshold(uint256 _threshold)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    require(_threshold > 0, ""Must be between greater than 0"");
    dustThreshold = _threshold;
  }
}",7604
RealWorld_BA_59_MiningService_RealWord_20240822082527.log,59,MiningService,22574,5693,28267,83.0,0.22673,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";

import ""./Permissions.sol"";
import ""./interfaces/IRewardMine.sol"";


/// @title Malt Mining Service
/// @author 0xScotch <scotch@malt.money>
/// @notice A contract that abstracts one or more implementations of AbstractRewardMine
contract MiningService is Initializable, Permissions {
  address[] public mines;
  mapping(address => bool) internal mineActive;
  address public reinvestor;
  address public bonding;

  bytes32 public constant REINVESTOR_ROLE = keccak256(""REINVESTOR_ROLE"");
  bytes32 public constant BONDING_ROLE = keccak256(""BONDING_ROLE"");

  function initialize(
    address _timelock,
    address initialAdmin,
    address _rewardToken,
    address _reinvestor,
    address _bonding
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);
    _roleSetup(REINVESTOR_ROLE, _reinvestor);
    _roleSetup(BONDING_ROLE, _bonding);

    bonding = _bonding;
    reinvestor = _reinvestor;
  }

  function withdrawAccountRewards(uint256 amount)
    public
  {
    _withdrawMultiple(msg.sender, amount);
  }

  function balanceOfRewards(address account) public view returns (uint256) {
    uint256 total;
    for (uint i = 0; i < mines.length; i = i + 1) {
      if (!mineActive[mines[i]]) {
        continue;
      }
      total += IRewardMine(mines[i]).balanceOfRewards(account);
    }

    return total;
  }

  function numberOfMines() public view returns(uint256) {
    return mines.length;
  }

  function isMineActive(address mine) public view returns(bool) {
    return mineActive[mine];
  }

  function earned(address account) public view returns (uint256) {
    uint256 total;

    for (uint i = 0; i < mines.length; i = i + 1) {
      if (!mineActive[mines[i]]) {
        continue;
      }
      total += IRewardMine(mines[i]).earned(account);
    }

    return total;
  }

  /*
   * PRIVILEDGED FUNCTIONS
   */
  function onBond(address account, uint256 amount)
    public
    onlyRole(BONDING_ROLE, ""Must have bonding privs"")
  {
    for (uint i = 0; i < mines.length; i = i + 1) {
      IRewardMine mine = IRewardMine(mines[i]);
      mine.onBond(account, amount);
    }
  }

  function onUnbond(address account, uint256 amount)
    public
    onlyRole(BONDING_ROLE, ""Must have bonding privs"")
  {
    for (uint i = 0; i < mines.length; i = i + 1) {
      IRewardMine mine = IRewardMine(mines[i]);
      mine.onUnbond(account, amount);
    }
  }

  function setReinvestor(address _reinvestor)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_reinvestor != address(0), ""Cannot use address 0"");
    _swapRole(_reinvestor, reinvestor, REINVESTOR_ROLE);
    reinvestor = _reinvestor;
  }

  function setBonding(address _bonding)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_bonding != address(0), ""Cannot use address 0"");
    _swapRole(_bonding, bonding, REINVESTOR_ROLE);
    bonding = _bonding;
  }

  function addRewardMine(address mine)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    if (mineActive[mine]) {
      return;
    }
    mineActive[mine] = true;

    mines.push(mine);
  }

  function removeRewardMine(address mine)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    if (!mineActive[mine]) {
      return;
    }
    mineActive[mine] = false;

    // Loop until the second last element
    for (uint i = 0; i < mines.length - 1; i = i + 1) {
      if (mines[i] == mine) {
        // Replace the current item with the last and pop the last away.
        mines[i] = mines[mines.length - 1];
        mines.pop();
        return;
      }
    }

    // If we made it here then the mine being removed is the last item
    mines.pop();
  }

  function withdrawRewardsForAccount(address account, uint256 amount)
    public
    onlyRole(REINVESTOR_ROLE, ""Must have reinvestor privs"")
  {
    _withdrawMultiple(account, amount);
  }

  /*
   * INTERNAL FUNCTIONS
   */
  function _withdrawMultiple(address account, uint256 amount) internal {
    for (uint i = 0; i < mines.length; i = i + 1) {
      if (!mineActive[mines[i]]) {
        continue;
      }

      uint256 withdrawnAmount = IRewardMine(mines[i]).withdrawForAccount(account, amount, msg.sender);

      amount = amount.sub(withdrawnAmount);

      if (amount == 0) {
        break;
      }
    }
  }
}",1213
RealWorld_BA_59_RewardDistributor_RealWord_20240822084517.log,59,RewardDistributor,43837,5121,48958,73.0,0.321605,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../Permissions.sol"";
import ""../interfaces/IBonding.sol"";
import ""../interfaces/IForfeit.sol"";
import ""../interfaces/IRewardMine.sol"";

import ""hardhat/console.sol"";

struct State {
  uint256 declaredBalance;
}

struct FocalPoint {
  uint256 id;
  uint256 focalLength;
  uint256 endTime;

  uint256 rewarded;
  uint256 vested;

  uint256 lastVestingTime;
}

/// @title Reward Vesting Distributor
/// @author 0xScotch <scotch@malt.money>
/// @notice The contract in charge of implementing the focal vesting scheme for rewards
contract RewardDistributor is Initializable, Permissions {
  uint256 public focalID = 1; // Avoid issues with defaulting to 0
  uint256 public focalLength = 2 days;

  bytes32 public constant THROTTLER_ROLE = keccak256(""THROTTLER_ROLE"");
  bytes32 public constant REWARD_MINE_ROLE = keccak256(""REWARD_MINE_ROLE"");
  bytes32 public constant FOCAL_LENGTH_UPDATER_ROLE = keccak256(""FOCAL_LENGTH_UPDATER_ROLE"");

  address public throttler;
  IRewardMine public rewardMine;
  IForfeit public forfeitor;
  ERC20 public rewardToken;
  IBonding public bonding;

  State internal _globals;
  FocalPoint[] internal focalPoints;

  event DeclareReward(
    uint256 amount,
    address rewardToken
  );
  event Forfeit(address account, address rewardToken, uint256 forfeited);
  event RewardFocal(
    uint256 id,
    uint256 focalLength,
    uint256 endTime,
    uint256 rewarded
  );

  function initialize(
    address _timelock,
    address initialAdmin,
    address _rewardMine,
    address _bonding,
    address _throttler,
    address _forfeitor,
    address _rewardToken
  ) external initializer {
    _adminSetup(_timelock);
    _setupRole(FOCAL_LENGTH_UPDATER_ROLE, _timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);

    _roleSetup(THROTTLER_ROLE, _throttler);
    _roleSetup(FOCAL_LENGTH_UPDATER_ROLE, initialAdmin);
    _roleSetup(REWARD_MINE_ROLE, _rewardMine);

    rewardToken = ERC20(_rewardToken);

    throttler = _throttler;
    rewardMine = IRewardMine(_rewardMine);
    forfeitor = IForfeit(_forfeitor);
    bonding = IBonding(_bonding);

    focalPoints.push();
    focalPoints.push();
  }

  function vest() public {
    if (_globals.declaredBalance == 0) {
      return;
    }
    uint256 vestedReward = 0;

    FocalPoint storage vestingFocal = _getVestingFocal();
    FocalPoint storage activeFocal = _getActiveFocal();

    vestedReward = _getVestableQuantity(vestingFocal);
    uint256 activeReward = _getVestableQuantity(activeFocal);

    vestedReward = vestedReward.add(activeReward);

    // Send vested amount to liquidity mine
    rewardToken.safeTransfer(address(rewardMine), vestedReward);

    // increment focalID if time is past the halfway mark
    // through a focal period
    if (block.timestamp >= _getNextFocalStart(activeFocal)) {
      _incrementFocalPoint();
    }
  }

  /* PUBLIC VIEW FUNCTIONS */
  function totalDeclaredReward() public view returns (uint256) {
    return _globals.declaredBalance;
  }

  /* INTERNAL VIEW FUNCTIONS */
  function _getFocalIndex(uint256 id) internal pure returns (uint8 index) {
    return uint8(id % 2);
  }

  function _getVestingFocal() internal view returns (FocalPoint storage) {
    // Can add 1 as the modulo ensures we wrap correctly
    uint8 index = _getFocalIndex(focalID + 1);
    return focalPoints[index];
  }

  /* INTERNAL FUNCTIONS */
  function _getActiveFocal() internal returns (FocalPoint storage) {
    uint8 index = _getFocalIndex(focalID);
    FocalPoint storage focal = focalPoints[index];

    if (focal.id != focalID) {
      // If id is not focalID then reinitialize the struct
      _resetFocalPoint(focalID, block.timestamp + focalLength);
    }

    return focal;
  }

  function _rewardCheck(uint256 reward) internal {
    require(reward > 0, ""Cannot declare 0 reward"");

    _globals.declaredBalance = _globals.declaredBalance.add(reward);

    uint256 totalReward = rewardToken.balanceOf(address(this)) + rewardMine.totalReleasedReward();

    require(_globals.declaredBalance <= totalReward, ""Insufficient balance"");
  }

  function _forfeit(uint256 forfeited) internal {
    require(forfeited <= _globals.declaredBalance, ""Cannot forfeit more than declared"");

    _globals.declaredBalance = _globals.declaredBalance.sub(forfeited);

    rewardToken.safeTransfer(address(forfeitor), forfeited);
    forfeitor.handleForfeit();

    uint256 totalReward = rewardToken.balanceOf(address(this)) + rewardMine.totalReleasedReward();

    require(_globals.declaredBalance <= totalReward, ""Insufficient balance"");

    emit Forfeit(msg.sender, address(rewardToken), forfeited);
  }

  function _resetFocalPoint(uint256 id, uint256 endTime) internal {
    uint8 index = _getFocalIndex(id);
    FocalPoint storage newFocal = focalPoints[index];
    
    newFocal.id = id;
    newFocal.focalLength = focalLength;
    newFocal.endTime = endTime;
    newFocal.rewarded = 0;
    newFocal.vested = 0;
    newFocal.lastVestingTime = endTime - focalLength;
  }

  function _incrementFocalPoint() internal {
    FocalPoint storage oldFocal = _getActiveFocal();

    // This will increment every 24 hours so overflow on uint256
    // isn't an issue.
    focalID = focalID + 1;

    // Emit event that documents the focalPoint that has just ended
    emit RewardFocal(
      oldFocal.id,
      oldFocal.focalLength,
      oldFocal.endTime,
      oldFocal.rewarded
    );

    uint256 newEndTime = oldFocal.endTime + focalLength / 2;

    _resetFocalPoint(focalID, newEndTime);
  }

  function _getNextFocalStart(FocalPoint storage focal) internal view returns (uint256) {
    return focal.endTime - (focal.focalLength / 2);
  }

  function _getVestableQuantity(FocalPoint storage focal) internal returns (
    uint256 vestedReward
  ) {
    uint256 currentTime = block.timestamp;

    if (focal.lastVestingTime >= currentTime) {
      return 0;
    }

    if (currentTime > focal.endTime) {
      currentTime = focal.endTime;
    }

    // Time in between last vesting call and end of focal period
    uint256 timeRemaining = focal.endTime - focal.lastVestingTime;

    if (timeRemaining == 0) {
      return 0;
    }

    // Time since last vesting call
    uint256 vestedTime = currentTime - focal.lastVestingTime;

    uint256 remainingReward = focal.rewarded - focal.vested;

    vestedReward = remainingReward.mul(vestedTime).div(timeRemaining);

    focal.vested = focal.vested.add(vestedReward);
    focal.lastVestingTime = currentTime;

    return vestedReward;
  }

  /*
   * PRIVILEDGED METHODS
   */
  function declareReward(uint256 amount)
    external
    onlyRole(THROTTLER_ROLE, ""Only throttler role"")
  {
    _rewardCheck(amount);

    if (bonding.totalBonded() == 0) {
      // There is no accounts to distribute the rewards to so forfeit it
      _forfeit(amount);
      return;
    } 

    // Vest current reward before adding new reward to ensure
    // Everything is up to date before we add new reward
    vest();

    FocalPoint storage activeFocal = _getActiveFocal();
    activeFocal.rewarded = activeFocal.rewarded.add(amount);

    emit DeclareReward(amount, address(rewardToken));
  }

  function forfeit(uint256 amount)
    public
    onlyRole(REWARD_MINE_ROLE, ""Only reward mine"")
  {
    if (amount > 0) {
      _forfeit(amount);
    }
  }

  function decrementRewards(uint256 amount)
    public
    onlyRole(REWARD_MINE_ROLE, ""Only reward mine"")
  {
    require(amount <= _globals.declaredBalance, ""Can't decrement more than total reward balance"");

    if (amount > 0) {
      _globals.declaredBalance = _globals.declaredBalance.sub(amount);
    }
  }

  function setFocalLength(uint256 _focalLength)
    public 
    onlyRole(FOCAL_LENGTH_UPDATER_ROLE, ""Only focal length updater"")
  {
    // Cannot have focal length under 1 hour
    require(_focalLength >= 3600, ""Focal length too small"");
    focalLength = _focalLength;
  }

  function setThrottler(address _throttler)
    public 
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_throttler != address(0), ""Cannot set 0 address as throttler"");
    _swapRole(_throttler, address(throttler), THROTTLER_ROLE);
    throttler = _throttler;
  }

  function setRewardMine(address _rewardMine)
    public 
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_rewardMine != address(0), ""Cannot set 0 address as rewardMine"");
    _swapRole(_rewardMine, address(rewardMine), REWARD_MINE_ROLE);
    rewardMine = IRewardMine(_rewardMine);
  }

  function setForfeitor(address _forfeitor)
    public 
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_forfeitor != address(0), ""Cannot set 0 address as forfeitor"");
    forfeitor = IForfeit(_forfeitor);
  }

  function setRewardToken(address _rewardToken)
    public 
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_rewardToken != address(0), ""Cannot set 0 address as reward Token"");
    rewardToken = ERC20(_rewardToken);
  }

  function setBonding(address _bonding)
    public 
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_bonding != address(0), ""Cannot set 0 address as bonding"");
    bonding = IBonding(_bonding);
  }

  function addFocalLengthUpdater(address _updater)
    public 
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_updater != address(0), ""Cannot set 0 address as focal length updater"");
    _roleSetup(FOCAL_LENGTH_UPDATER_ROLE, _updater);
  }

  function removeFocalLengthUpdater(address _updater)
    public 
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    revokeRole(FOCAL_LENGTH_UPDATER_ROLE, _updater);
  }
}",2511
RealWorld_BA_59_StabilizerNode_RealWord_20240822081439.log,59,StabilizerNode,72808,5645,78453,94.0,0.47694,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";

import ""./Permissions.sol"";
import ""./interfaces/IAuction.sol"";
import ""./interfaces/IMaltDataLab.sol"";
import ""./interfaces/IDAO.sol"";
import ""./interfaces/IRewardThrottle.sol"";
import ""./interfaces/IAuctionBurnReserveSkew.sol"";
import ""./interfaces/ILiquidityExtension.sol"";
import ""./interfaces/IImpliedCollateralService.sol"";
import ""./interfaces/IDexHandler.sol"";
import ""./interfaces/ISwingTrader.sol"";
import ""./interfaces/IBurnMintableERC20.sol"";
import ""./interfaces/ISupplyDistributionController.sol"";
import ""./interfaces/IAuctionStartController.sol"";


/// @title Stabilizer Node
/// @author 0xScotch <scotch@malt.money>
/// @notice The backbone of the Malt stability system. In charge of triggering actions to stabilize price
contract StabilizerNode is Initializable, Permissions {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  uint256 internal stabilizeWindowEnd;
  uint256 public stabilizeBackoffPeriod = 5 * 60; // 5 minutes
  uint256 public upperStabilityThreshold = (10**18) / 100; // 1%
  uint256 public lowerStabilityThreshold = (10**18) / 100;
  uint256 public maxContributionBps = 70;
  uint256 public priceAveragePeriod = 5 minutes;
  uint256 public fastAveragePeriod = 30; // 30 seconds
  uint256 public overrideDistance = 20; // 2%

  uint256 public expansionDampingFactor = 1;

  uint256 public defaultIncentive = 100;

  uint256 public daoRewardCut;
  uint256 public lpRewardCut = 417;
  uint256 public auctionPoolRewardCut = 113;
  uint256 public swingTraderRewardCut = 417;
  uint256 public treasuryRewardCut = 50;
  uint256 public callerRewardCut = 3;

  uint256 public lastStabilize;

  ERC20 public rewardToken;
  IBurnMintableERC20 public malt;
  IAuction public auction;
  IDexHandler public dexHandler;
  IDAO public dao;
  address public uniswapV2Factory;
  ILiquidityExtension public liquidityExtension;
  IMaltDataLab public maltDataLab;
  IAuctionBurnReserveSkew public auctionBurnReserveSkew;
  IRewardThrottle public rewardThrottle;
  ISwingTrader public swingTrader;
  IImpliedCollateralService public impliedCollateralService;

  address payable public treasuryMultisig;
  address public auctionPool;
  address public supplyDistributionController;
  address public auctionStartController;

  event MintMalt(uint256 amount);
  event Stabilize(uint256 timestamp, uint256 exchangeRate);
  event RewardDistribution(uint256 rewarded);
  event SetAnnualYield(uint256 yield);
  event SetStabilizeBackoff(uint256 period);
  event SetAuctionBurnSkew(address auctionBurnReserveSkew);
  event SetRewardCut(uint256 daoCut, uint256 lpCut, uint256 callerCut, uint256 treasuryCut, uint256 auctionPoolCut, uint256 swingTraderCut);
  event SetTreasury(address newTreasury);
  event SetDefaultIncentive(uint256 incentive);
  event SetExpansionDamping(uint256 amount);
  event SetNewMaltDataLab(address dataLab);
  event SetAuctionContract(address auction);
  event SetDexHandler(address dexHandler);
  event SetDao(address dao);
  event SetLiquidityExtension(address liquidityExtension);
  event SetRewardThrottle(address rewardThrottle);
  event SetSwingTrader(address swingTrader);
  event SetPriceAveragePeriod(uint256 period);
  event SetOverrideDistance(uint256 distance);
  event SetFastAveragePeriod(uint256 period);
  event SetStabilityThresholds(uint256 upper, uint256 lower);
  event SetAuctionPool(address auctionPool);
  event SetMaxContribution(uint256 maxContribution);
  event SetImpliedCollateralService(address impliedCollateralService);
  event SetSupplyDistributionController(address _controller);
  event SetAuctionStartController(address _controller);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _rewardToken,
    address _malt,
    address _auction,
    address _uniswapV2Factory,
    address payable _treasuryMultisig,
    address _auctionPool
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);
    _setupRole(AUCTION_ROLE, _auction);

    rewardToken = ERC20(_rewardToken);
    malt = IBurnMintableERC20(_malt);
    auction = IAuction(_auction);

    uniswapV2Factory = _uniswapV2Factory;
    treasuryMultisig = _treasuryMultisig;
    auctionPool = _auctionPool;

    lastStabilize = block.timestamp;
  }

  function setupContracts(
    address _dexHandler,
    address _maltDataLab,
    address _auctionBurnReserveSkew,
    address _rewardThrottle,
    address _dao,
    address _swingTrader,
    address _liquidityExtension,
    address _impliedCollateralService
  ) external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    dexHandler = IDexHandler(_dexHandler);
    maltDataLab = IMaltDataLab(_maltDataLab);
    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);
    rewardThrottle = IRewardThrottle(_rewardThrottle);
    dao = IDAO(_dao);
    swingTrader = ISwingTrader(_swingTrader);
    liquidityExtension = ILiquidityExtension(_liquidityExtension);
    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);
  }

  function stabilize() external notSameBlock {
    auction.checkAuctionFinalization();

    require(
      block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),
      ""Can't call stabilize""
    );
    stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;

    rewardThrottle.checkRewardUnderflow();

    uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);

    if (!_shouldAdjustSupply(exchangeRate)) {
      maltDataLab.trackReserveRatio();

      lastStabilize = block.timestamp;
      return;
    }

    emit Stabilize(block.timestamp, exchangeRate);

    if (exchangeRate > maltDataLab.priceTarget()) {
      _distributeSupply();
    } else {
      _startAuction();
    }

    lastStabilize = block.timestamp;
  }

  /*
   * INTERNAL VIEW FUNCTIONS
   */
  function _stabilityWindowOverride() internal view returns (bool) {
    if (hasRole(ADMIN_ROLE, _msgSender())) {
      // Admin can always stabilize
      return true;
    }
    // Must have elapsed at least one period of the moving average before we stabilize again
    if (block.timestamp < lastStabilize + fastAveragePeriod) {
      return false;
    }

    uint256 priceTarget = maltDataLab.priceTarget();
    uint256 exchangeRate = maltDataLab.maltPriceAverage(fastAveragePeriod);

    uint256 upperThreshold = priceTarget.mul(1000 + overrideDistance).div(1000);
    uint256 lowerThreshold = priceTarget.mul(1000 - overrideDistance).div(1000);

    return exchangeRate <= lowerThreshold || exchangeRate >= upperThreshold;
  }

  function _shouldAdjustSupply(uint256 exchangeRate) internal view returns (bool) {
    uint256 decimals = rewardToken.decimals();
    uint256 priceTarget = maltDataLab.priceTarget();

    uint256 upperThreshold = priceTarget.mul(upperStabilityThreshold).div(10**decimals);
    uint256 lowerThreshold = priceTarget.mul(lowerStabilityThreshold).div(10**decimals);

    return (exchangeRate <= priceTarget.sub(lowerThreshold) && !auction.auctionActive(auction.currentAuctionId())) || exchangeRate >= priceTarget.add(upperThreshold);
  }

  /*
   * INTERNAL FUNCTIONS
   */
  function _distributeSupply() internal {
    if (supplyDistributionController != address(0)) {
      bool success = ISupplyDistributionController(supplyDistributionController).check();
      if (!success) {
        return;
      }
    }

    uint256 priceTarget = maltDataLab.priceTarget();
    uint256 tradeSize = dexHandler.calculateMintingTradeSize(priceTarget).div(expansionDampingFactor);

    if (tradeSize == 0) {
      return;
    }

    uint256 swingAmount = swingTrader.sellMalt(tradeSize);

    if (swingAmount >= tradeSize) {
      return;
    }

    tradeSize = tradeSize - swingAmount;

    malt.mint(address(dexHandler), tradeSize);
    emit MintMalt(tradeSize);
    uint256 rewards = dexHandler.sellMalt();

    auctionBurnReserveSkew.addAbovePegObservation(tradeSize);

    uint256 remaining = _replenishLiquidityExtension(rewards);

    _distributeRewards(remaining);

    maltDataLab.trackReserveRatio();
    impliedCollateralService.claim();
  }

  function _distributeRewards(uint256 rewarded) internal {
    if (rewarded == 0) {
      return;
    }
    rewardToken.approve(address(auction), rewarded);
    rewarded = auction.allocateArbRewards(rewarded);

    if (rewarded == 0) {
      return;
    }

    uint256 callerCut = rewarded.mul(callerRewardCut).div(1000);
    uint256 lpCut = rewarded.mul(lpRewardCut).div(1000);
    uint256 daoCut = rewarded.mul(daoRewardCut).div(1000);
    uint256 auctionPoolCut = rewarded.mul(auctionPoolRewardCut).div(1000);
    uint256 swingTraderCut = rewarded.mul(swingTraderRewardCut).div(1000);

    // Treasury gets paid after everyone else
    uint256 treasuryCut = rewarded - daoCut - lpCut - callerCut - auctionPoolCut - swingTraderCut;

    assert(treasuryCut <= rewarded);

    if (callerCut > 0) {
      rewardToken.safeTransfer(msg.sender, callerCut);
    }

    if (auctionPoolCut > 0) {
      rewardToken.safeTransfer(auctionPool, auctionPoolCut);
    }

    if (swingTraderCut > 0) {
      rewardToken.safeTransfer(address(swingTrader), swingTraderCut);
    }

    if (treasuryCut > 0) {
      rewardToken.safeTransfer(treasuryMultisig, treasuryCut);
    }

    if (daoCut > 0) {
      rewardToken.safeTransfer(address(dao), daoCut);
    }

    if (lpCut > 0) {
      rewardToken.safeTransfer(address(rewardThrottle), lpCut);
      rewardThrottle.handleReward();
    }

    emit RewardDistribution(rewarded);
  }

  function _replenishLiquidityExtension(uint256 rewards) internal returns (uint256 remaining) {
    if (liquidityExtension.hasMinimumReserves() || rewards == 0) {
      return rewards;
    }

    (uint256 deficit,) = liquidityExtension.collateralDeficit();

    uint256 maxContrib = rewards.mul(maxContributionBps).div(100);

    if (deficit >= maxContrib) {
      rewardToken.safeTransfer(address(liquidityExtension), maxContrib);
      return rewards - maxContrib;
    }

    rewardToken.safeTransfer(address(liquidityExtension), deficit);

    return rewards - deficit;
  }

  function _startAuction() internal {
    if (auctionStartController != address(0)) {
      bool success = IAuctionStartController(auctionStartController).checkForStart();
      if (!success) {
        return;
      }
    }

    uint256 priceTarget = maltDataLab.priceTarget();
    uint256 purchaseAmount = dexHandler.calculateBurningTradeSize(priceTarget);

    if (purchaseAmount == 0) {
      return;
    }

    uint256 decimals = rewardToken.decimals();

    uint256 amountUsed = swingTrader.buyMalt(purchaseAmount);

    purchaseAmount = purchaseAmount - amountUsed;

    if (purchaseAmount < 10**decimals) {
      return;
    }

    auction.triggerAuction(priceTarget, purchaseAmount);

    malt.mint(msg.sender, defaultIncentive*10**18);
    emit MintMalt(defaultIncentive*10**18);

    auctionBurnReserveSkew.addBelowPegObservation(purchaseAmount);

    maltDataLab.trackReserveRatio();
  }

  /*
   * PRIVILEDGED FUNCTIONS
   */
  function setStabilizeBackoff(uint256 _period)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_period > 0, ""Must be greater than 0"");
    stabilizeBackoffPeriod = _period;
    emit SetStabilizeBackoff(_period);
  }

  function setAuctionBurnSkew(address _auctionBurnReserveSkew)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);
    emit SetAuctionBurnSkew(_auctionBurnReserveSkew);
  }

  function setRewardCut(
    uint256 _daoCut,
    uint256 _lpCut,
    uint256 _callerCut,
    uint256 _auctionPoolCut,
    uint256 _swingTraderCut
  )
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    uint256 sum = _daoCut.add(_lpCut).add(_callerCut).add(_auctionPoolCut).add(_swingTraderCut);
    require(sum <= 1000, ""Reward cut must be <= 100%"");
    daoRewardCut = _daoCut;
    lpRewardCut = _lpCut;
    callerRewardCut = _callerCut;
    auctionPoolRewardCut = _auctionPoolCut;
    swingTraderRewardCut = _swingTraderCut;
    treasuryRewardCut = 1000 - sum;

    emit SetRewardCut(_daoCut, _lpCut, _callerCut, treasuryRewardCut, _auctionPoolCut, _swingTraderCut);
  }

  function setTreasury(address payable _newTreasury)
    external
    onlyRole(TIMELOCK_ROLE, ""Must have timelock role"")
  {
    treasuryMultisig = _newTreasury;
    emit SetTreasury(_newTreasury);
  }

  function setDefaultIncentive(uint256 _incentive)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_incentive > 0, ""No negative incentive"");

    defaultIncentive = _incentive;

    emit SetDefaultIncentive(_incentive);
  }

  function setExpansionDamping(uint256 amount)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(amount > 0, ""No negative damping"");

    expansionDampingFactor = amount;
    emit SetExpansionDamping(amount);
  }

  function setNewDataLab(address _dataLab)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    maltDataLab = IMaltDataLab(_dataLab);
    emit SetNewMaltDataLab(_dataLab);
  }

  function setAuctionContract(address _auction)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {

    if (address(auction) != address(0)) {
      revokeRole(AUCTION_ROLE, address(auction));
    }

    auction = IAuction(_auction);
    _setupRole(AUCTION_ROLE, _auction);
    emit SetAuctionContract(_auction);
  }

  function setStabilityThresholds(uint256 _upper, uint256 _lower)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_upper > 0 && _lower > 0, ""Must be above 0"");

    upperStabilityThreshold = _upper;
    lowerStabilityThreshold = _lower;
    emit SetStabilityThresholds(_upper, _lower);
  }

  function setAuctionPool(address _auctionPool)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_auctionPool != address(0), ""Not address 0"");

    auctionPool = _auctionPool;
    emit SetAuctionPool(_auctionPool);
  }

  function setSupplyDistributionController(address _controller)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    // This is allowed to be set to address(0) as its checked before calling methods on it
    supplyDistributionController = _controller;
    emit SetSupplyDistributionController(_controller);
  }

  function setAuctionStartController(address _controller)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    // This is allowed to be set to address(0) as its checked before calling methods on it
    auctionStartController = _controller;
    emit SetAuctionStartController(_controller);
  }

  function setMaxContribution(uint256 _maxContribution)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_maxContribution > 0 && _maxContribution <= 100, ""Must be between 0 and 100"");

    maxContributionBps = _maxContribution;
    emit SetMaxContribution(_maxContribution);
  }

  function setDexHandler(address _dexHandler)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_dexHandler != address(0), ""Not address 0"");
    dexHandler = IDexHandler(_dexHandler);
    emit SetDexHandler(_dexHandler);
  }

  function setDao(address _dao)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_dao != address(0), ""Not address 0"");
    dao = IDAO(_dao);
    emit SetDao(_dao);
  }

  function setLiquidityExtension(address _liquidityExtension)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_liquidityExtension != address(0), ""Not address 0"");
    liquidityExtension = ILiquidityExtension(_liquidityExtension);
    emit SetLiquidityExtension(_liquidityExtension);
  }

  function setRewardThrottle(address _rewardThrottle)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_rewardThrottle != address(0), ""Not address 0"");
    rewardThrottle = IRewardThrottle(_rewardThrottle);
    emit SetRewardThrottle(_rewardThrottle);
  }

  function setSwingTrader(address _swingTrader)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_swingTrader != address(0), ""Not address 0"");
    swingTrader = ISwingTrader(_swingTrader);
    emit SetSwingTrader(_swingTrader);
  }

  function setImpliedCollateralService(address _impliedCollateralService)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_impliedCollateralService != address(0), ""Not address 0"");
    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);
    emit SetImpliedCollateralService(_impliedCollateralService);
  }

  function setPriceAveragePeriod(uint256 _period)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_period > 0, ""Cannot have 0 period"");
    priceAveragePeriod = _period;
    emit SetPriceAveragePeriod(_period);
  }

  function setOverrideDistance(uint256 _distance)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_distance > 0 && _distance < 1000, ""Override must be between 0-100%"");
    overrideDistance = _distance;
    emit SetOverrideDistance(_distance);
  }

  function setFastAveragePeriod(uint256 _period)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_period > 0, ""Cannot have 0 period"");
    fastAveragePeriod = _period;
    emit SetFastAveragePeriod(_period);
  }
}",4441
RealWorld_BA_59_FaucetTwo_RealWord_20240822081614.log,59,FaucetTwo,6893,4830,11723,67.0,0.131065,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""./interfaces/IBurnMintableERC20.sol"";

interface IFaucet {
  function faucet() external;
}

contract TestFaucetTwo is Initializable {
  using SafeMath for uint256;

  IFaucet public faucetContract;
  IBurnMintableERC20 public token;

  function initialize(address _faucet, address _token) external initializer {
    faucetContract = IFaucet(_faucet);
    token = IBurnMintableERC20(_token);
  }
  
  function faucet(uint256 _amount) external {
    uint256 balance = 0;
    while (true) {
      faucetContract.faucet();
      balance = token.balanceOf(address(this));

      if (balance > _amount) {
        break;
      }
    }

    token.transfer(msg.sender, balance);
  }
}",225
RealWorld_BA_59_PoolTransferVerification_RealWord_20240822083541.log,59,PoolTransferVerification,15945,5475,21420,73.0,0.189225,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";

import ""./interfaces/IMaltDataLab.sol"";
import ""./Permissions.sol"";
import ""./AbstractTransferVerification.sol"";


/// @title Pool Transfer Verification
/// @author 0xScotch <scotch@malt.money>
/// @notice Implements ability to block Malt transfers
contract PoolTransferVerification is AbstractTransferVerification, Initializable {
  uint256 public thresholdBps;
  IMaltDataLab public maltDataLab;
  uint256 public priceLookback;
  address public pool;

  mapping(address => bool) public whitelist;

  event AddToWhitelist(address indexed _address);
  event RemoveFromWhitelist(address indexed _address);
  event SetPool(address indexed pool);
  event SetPriceLookback(uint256 lookback);
  event SetThreshold(uint256 newThreshold);

  function initialize(
    address _timelock,
    address initialAdmin,
    uint256 _thresholdBps,
    address _maltDataLab,
    uint256 _lookback,
    address _pool
  ) external initializer {
    _adminSetup(_timelock);
    _setupRole(ADMIN_ROLE, initialAdmin);

    thresholdBps = _thresholdBps;
    maltDataLab = IMaltDataLab(_maltDataLab);
    priceLookback = _lookback;
    pool = _pool;
  }

  function verifyTransfer(address from, address to, uint256 amount) 
    public view override returns (bool, string memory) 
  {
    // This contract only cares about transfers out of the pool
    if (from != pool) {
      return (true, """");
    }

    if (isWhitelisted(to)) {
      return (true, """");
    }

    uint256 priceTarget = maltDataLab.priceTarget();

    return (
      maltDataLab.maltPriceAverage(priceLookback) > priceTarget * (10000 - thresholdBps) / 10000,
      ""The price of Malt is below peg. Wait for peg to be regained or purchase arbitrage tokens.""
    );
  }

  function isWhitelisted(address _address) public view returns(bool) {
    return whitelist[_address];
  }

  /*
   * PRIVILEDGED METHODS
   */
  function setThreshold(uint256 newThreshold)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(newThreshold > 0 && newThreshold < 10000, ""Threshold must be between 0-100%"");
    thresholdBps = newThreshold;
    emit SetThreshold(newThreshold);
  }

  function setPriceLookback(uint256 lookback)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(lookback > 0, ""Cannot have 0 lookback"");
    priceLookback = lookback;
    emit SetPriceLookback(lookback);
  }

  function setPool(address _pool)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_pool != address(0), ""Cannot have 0 lookback"");
    pool = _pool;
    emit SetPool(_pool);
  }

  function addToWhitelist(address _address) 
    public
    onlyRole(ADMIN_ROLE, ""Must have admin role"") 
  {
    whitelist[_address] = true;
    emit AddToWhitelist(_address);
  }

  function removeFromWhitelist(address _address) 
    public
    onlyRole(ADMIN_ROLE, ""Must have admin role"")  
  {
    if (!whitelist[_address]) {
      return;
    }
    whitelist[_address] = false;
    emit RemoveFromWhitelist(_address);
  }
}",790
RealWorld_BA_59_IMiningService_RealWord_20240822091708.log,59,IMiningService,4614,4914,9528,70.0,0.12135,"pragma solidity >=0.6.6;

interface IMiningService {
  function withdrawAccountRewards(uint256 amount) external;
  function balanceOfRewards(address account) external view returns (uint256);
  function earned(address account) external view returns (uint256);
  function onBond(address account, uint256 amount) external;
  function onUnbond(address account, uint256 amount) external;
  function withdrawRewardsForAccount(address account, uint256 amount) external;
}",99
RealWorld_BA_59_IOverflow_RealWord_20240822091314.log,59,IOverflow,4053,5020,9073,75.0,0.120665,"pragma solidity >=0.6.6;

interface IOverflow {
  function requestCapital(uint256 amount) external returns (uint256 fulfilledAmount);
  function purchaseArbitrageTokens(uint256 maxAmount)
    external returns (uint256 remaining);
  function claim() external;
  function outstandingArbTokens() external view returns (uint256 outstanding);
}",71
RealWorld_BA_59_Permissions_RealWord_20240822081723.log,59,Permissions,23308,5715,29023,78.0,0.23084,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";


/// @title Permissions
/// @author 0xScotch <scotch@malt.money>
/// @notice Inherited by almost all Malt contracts to provide access control
contract Permissions is AccessControl {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  // Timelock has absolute power across the system
  bytes32 public constant TIMELOCK_ROLE = keccak256(""TIMELOCK_ROLE"");
  bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
  bytes32 public constant GOVERNOR_ROLE = keccak256(""GOVERNOR_ROLE"");

  // Can mint/burn Malt
  bytes32 public constant MONETARY_BURNER_ROLE = keccak256(""MONETARY_BURNER_ROLE"");
  bytes32 public constant MONETARY_MINTER_ROLE = keccak256(""MONETARY_MINTER_ROLE"");

  // Contract types
  bytes32 public constant STABILIZER_NODE_ROLE = keccak256(""STABILIZER_NODE_ROLE"");
  bytes32 public constant LIQUIDITY_MINE_ROLE = keccak256(""LIQUIDITY_MINE_ROLE"");
  bytes32 public constant AUCTION_ROLE = keccak256(""AUCTION_ROLE"");
  bytes32 public constant REWARD_THROTTLE_ROLE = keccak256(""REWARD_THROTTLE_ROLE"");

  address internal globalAdmin;

  mapping(address => uint256) public lastBlock; // protect against reentrancy

  function _adminSetup(address _timelock) internal {
    _roleSetup(TIMELOCK_ROLE, _timelock);
    _roleSetup(ADMIN_ROLE, _timelock);
    _roleSetup(GOVERNOR_ROLE, _timelock);
    _roleSetup(MONETARY_BURNER_ROLE, _timelock);
    _roleSetup(MONETARY_MINTER_ROLE, _timelock);
    _roleSetup(STABILIZER_NODE_ROLE, _timelock);
    _roleSetup(LIQUIDITY_MINE_ROLE, _timelock);
    _roleSetup(AUCTION_ROLE, _timelock);
    _roleSetup(REWARD_THROTTLE_ROLE, _timelock);

    globalAdmin = _timelock;
  }

  function assignRole(bytes32 role, address _assignee)
    external
    onlyRole(TIMELOCK_ROLE, ""Only timelock can assign roles"")
  {
    _setupRole(role, _assignee);
  }

  function removeRole(bytes32 role, address _entity)
    external
    onlyRole(TIMELOCK_ROLE, ""Only timelock can revoke roles"")
  {
    revokeRole(role, _entity);
  }

  function reassignGlobalAdmin(address _admin)
    external
    onlyRole(TIMELOCK_ROLE, ""Only timelock can assign roles"")
  {
    _swapRole(_admin, globalAdmin, TIMELOCK_ROLE);
    _swapRole(_admin, globalAdmin, ADMIN_ROLE);
    _swapRole(_admin, globalAdmin, GOVERNOR_ROLE);
    _swapRole(_admin, globalAdmin, MONETARY_BURNER_ROLE);
    _swapRole(_admin, globalAdmin, MONETARY_MINTER_ROLE);
    _swapRole(_admin, globalAdmin, STABILIZER_NODE_ROLE);
    _swapRole(_admin, globalAdmin, LIQUIDITY_MINE_ROLE);
    _swapRole(_admin, globalAdmin, AUCTION_ROLE);
    _swapRole(_admin, globalAdmin, REWARD_THROTTLE_ROLE);

    globalAdmin = _admin;
  }

  function emergencyWithdrawGAS(address payable destination)
    external 
    onlyRole(TIMELOCK_ROLE, ""Only timelock can assign roles"")
  {
    // Transfers the entire balance of the Gas token to destination
    destination.call{value: address(this).balance}('');
  }

  function emergencyWithdraw(address _token, address destination)
    external 
    onlyRole(TIMELOCK_ROLE, ""Must have timelock role"")
  {
    // Transfers the entire balance of an ERC20 token at _token to destination
    ERC20 token = ERC20(_token);
    token.safeTransfer(destination, token.balanceOf(address(this)));
  }

  function partialWithdrawGAS(address payable destination, uint256 amount)
    external 
    onlyRole(TIMELOCK_ROLE, ""Must have timelock role"")
  {
    destination.call{value: amount}('');
  }

  function partialWithdraw(address _token, address destination, uint256 amount)
    external 
    onlyRole(TIMELOCK_ROLE, ""Only timelock can assign roles"")
  {
    ERC20 token = ERC20(_token);
    token.safeTransfer(destination, amount);
  }

  /*
   * INTERNAL METHODS
   */
  function _swapRole(address newAccount, address oldAccount, bytes32 role) internal {
    revokeRole(role, oldAccount);
    _setupRole(role, newAccount);
  }

  function _roleSetup(bytes32 role, address account) internal {
    _setupRole(role, account);
    _setRoleAdmin(role, ADMIN_ROLE);
  }

  function _onlyRole(bytes32 role, string memory reason) internal view {
    require(
      hasRole(
        role,
        _msgSender()
      ),
      reason
    );
  }

  function _notSameBlock() internal {
    require(
      block.number > lastBlock[_msgSender()],
      ""Can't carry out actions in the same block""
    );
    lastBlock[_msgSender()] = block.number;
  }

  // Using internal function calls here reduces compiled bytecode size
  modifier onlyRole(bytes32 role, string memory reason) {
    _onlyRole(role, reason);
    _;
  }

  modifier notSameBlock() {
    _notSameBlock();
    _;
  }
}",1272
RealWorld_BA_59_IAuction_RealWord_20240822090118.log,59,IAuction,14613,6232,20845,114.0,0.197705,"pragma solidity >=0.6.6;

interface IAuction {
  function replenishingAuctionId() external view returns(uint256);
  function currentAuctionId() external view returns(uint256);
  function purchaseArbitrageTokens(uint256 amount) external;
  function claimArbitrage(uint256 _auctionId) external;
  function isAuctionFinished(uint256 _id) external view returns(bool);
  function auctionActive(uint256 _id) external view returns (bool);
  function isAuctionFinalized(uint256 _id) external view returns (bool);
  function userClaimableArbTokens(
    address account,
    uint256 auctionId
  ) external view returns (uint256);
  function balanceOfArbTokens(
    uint256 _auctionId,
    address account
  ) external view returns (uint256);
  function averageMaltPrice(uint256 _id) external view returns (uint256);
  function currentPrice(uint256 _id) external view returns (uint256);
  function getAuctionCommitments(uint256 _id) external view returns (uint256 commitments, uint256 maxCommitments);
  function getAuctionPrices(uint256 _id) external view returns (uint256 startingPrice, uint256 endingPrice, uint256 finalPrice);
  function auctionExists(uint256 _id) external view returns (bool);
  function getAccountCommitments(address account) external view returns (
    uint256[] memory auctions,
    uint256[] memory commitments,
    uint256[] memory awardedTokens,
    uint256[] memory redeemedTokens,
    uint256[] memory finalPrice,
    uint256[] memory claimable,
    bool[] memory finished
  );
  function getAccountCommitmentAuctions(address account) external view returns (uint[] memory);
  function getActiveAuction() external view returns (
    uint256 auctionId,
    uint256 maxCommitments,
    uint256 commitments,
    uint256 maltPurchased,
    uint256 startingPrice,
    uint256 endingPrice,
    uint256 finalPrice,
    uint256 pegPrice,
    uint256 startingTime,
    uint256 endingTime,
    uint256 finalBurnBudget,
    uint256 finalPurchased
  );
  function getAuction(uint256 _id) external view returns (
    uint256 maxCommitments,
    uint256 commitments,
    uint256 startingPrice,
    uint256 endingPrice,
    uint256 finalPrice,
    uint256 pegPrice,
    uint256 startingTime,
    uint256 endingTime,
    uint256 finalBurnBudget,
    uint256 finalPurchased
  );
  function getAuctionCore(uint256 _id) external view returns (
    uint256 auctionId,
    uint256 commitments,
    uint256 maltPurchased,
    uint256 startingPrice,
    uint256 finalPrice,
    uint256 pegPrice,
    uint256 startingTime,
    uint256 endingTime,
    bool active
  );
  function checkAuctionFinalization() external;
  function allocateArbRewards(uint256 rewarded) external returns (uint256);
  function triggerAuction(uint256 pegPrice, uint256 purchaseAmount) external;
  function getAuctionParticipationForAccount(address account, uint256 auctionId) external view returns(uint256, uint256, uint256);
  function amendAccountParticipation(address account, uint256 auctionId, uint256 amount, uint256 maltQuantity) external;
}",697
RealWorld_BA_59_AbstractRewardMine_RealWord_20240822083948.log,59,AbstractRewardMine,36410,5120,41530,71.0,0.28445,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""./Permissions.sol"";


/// @title Abstract Reward Mine
/// @author 0xScotch <scotch@malt.money>
/// @notice The base functionality for tracking user reward ownership, withdrawals etc
/// @dev The contract is abstract so needs to be inherited
abstract contract AbstractRewardMine is Permissions {
  using SafeMath for uint256;

  bytes32 public constant REWARD_MANAGER_ROLE = keccak256(""REWARD_MANAGER_ROLE"");
  bytes32 public constant MINING_SERVICE_ROLE = keccak256(""MINING_SERVICE_ROLE"");

  ERC20 public rewardToken;
  address public miningService;

  uint256 internal _globalStakePadding;
  uint256 internal _globalWithdrawn;
  mapping(address => uint256) internal _userStakePadding;
  mapping(address => uint256) internal _userWithdrawn;

  event Withdraw(address indexed account, uint256 rewarded, address indexed to);

  function onBond(address account, uint256 amount)
    virtual
    public
    onlyRole(MINING_SERVICE_ROLE, ""Must having mining service privilege"")
  {
    _beforeBond(account, amount);
    _handleStakePadding(account, amount);
    _afterBond(account, amount);
  }

  function onUnbond(address account, uint256 amount)
    virtual
    public
    onlyRole(MINING_SERVICE_ROLE, ""Must having mining service privilege"")
  {
    _beforeUnbond(account, amount);
    // Withdraw all current rewards
    // Done now before we change stake padding below
    uint256 rewardEarned = earned(account);
    _handleWithdrawForAccount(account, rewardEarned, account);

    uint256 bondedBalance = balanceOfBonded(account);

    if (bondedBalance == 0) {
      return;
    }

    uint256 lessStakePadding = balanceOfStakePadding(account).mul(amount).div(bondedBalance);

    _reconcileWithdrawn(account, amount, bondedBalance);
    _removeFromStakePadding(account, lessStakePadding, ""< stake padding"");
    _afterUnbond(account, amount);
  }

  function _initialSetup(address _rewardToken, address _miningService) internal {
    _roleSetup(MINING_SERVICE_ROLE, _miningService);
    _roleSetup(REWARD_MANAGER_ROLE, _miningService);

    rewardToken = ERC20(_rewardToken);
    miningService = _miningService;
  }

  function withdrawAll() public {
    uint256 rewardEarned = earned(msg.sender);

    _handleWithdrawForAccount(msg.sender, rewardEarned, msg.sender);
  }

  function withdraw(uint256 rewardAmount) external {
    uint256 rewardEarned = earned(msg.sender);

    require(rewardAmount <= rewardEarned, ""< earned"");
    
    _handleWithdrawForAccount(msg.sender, rewardAmount, msg.sender);
  }

  /*
   * METHODS TO OVERRIDE
   */
  function totalBonded() virtual public view returns (uint256);
  function balanceOfBonded(address account) virtual public view returns (uint256);

  /*
   * totalReleasedReward and totalDeclaredReward will often be the same. However, in the case
   * of vesting rewards they are different. In that case totalDeclaredReward is total
   * reward, including unvested. totalReleasedReward is just the rewards that have completed
   * the vesting schedule.
   */
  function totalDeclaredReward() virtual public view returns (uint256) {
    return rewardToken.balanceOf(address(this));
  }
  function totalReleasedReward() virtual public view returns (uint256) {
    return rewardToken.balanceOf(address(this)) + _globalWithdrawn;
  }

  /*
   * PUBLIC VIEW FUNCTIONS
   */
  function totalStakePadding() public view returns(uint256) {
    return _globalStakePadding;  
  }

  function balanceOfStakePadding(address account) public view returns (uint256) {
    return _userStakePadding[account];
  }

  function totalWithdrawn() public view returns (uint256) {
    return _globalWithdrawn;
  }

  function withdrawnBalance(address account) public view returns (uint256) {
    return _userWithdrawn[account];
  }

  function getRewardOwnershipFraction(address account) public view returns(uint256 numerator, uint256 denominator) {
    numerator = balanceOfRewards(account);
    denominator = totalDeclaredReward();
  }

  function balanceOfRewards(address account) public view returns (uint256) {
    /*
     * This represents the rewards allocated to a given account but does not
     * mean all these rewards are unlocked yet. The earned method will
     * fetch the balance that is unlocked for an account
     */
    uint256 balanceOfRewardedWithStakePadding = _getFullyPaddedReward(account);

    uint256 stakePaddingBalance = balanceOfStakePadding(account);

    if (balanceOfRewardedWithStakePadding > stakePaddingBalance) {
      return balanceOfRewardedWithStakePadding - stakePaddingBalance;
    }
    return 0;
  }

  function earned(address account) public view returns (uint256 earnedReward) {
    (uint256 rewardNumerator, uint256 rewardDenominator) = getRewardOwnershipFraction(account);

    if (rewardDenominator > 0) {
      earnedReward = totalReleasedReward().mul(rewardNumerator).div(rewardDenominator).sub(_userWithdrawn[account]);
    }
  }

  /*
   * INTERNAL VIEW FUNCTIONS
   */
  function _getFullyPaddedReward(address account) internal view returns (uint256) {
    uint256 globalBondedTotal = totalBonded();
    if (globalBondedTotal == 0) {
      return 0;
    }

    uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());
    
    return totalRewardedWithStakePadding
      .mul(balanceOfBonded(account))
      .div(globalBondedTotal);
  }

  /*
   * INTERNAL FUNCTIONS
   */
  function _withdraw(address account, uint256 amountReward, address to) internal {
    rewardToken.safeTransfer(to, amountReward);
    _userWithdrawn[account] += amountReward;
    _globalWithdrawn += amountReward;

    emit Withdraw(account, amountReward, to);
  }

  function _handleStakePadding(address account, uint256 amount) internal {
    uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());

    uint256 INITIAL_STAKE_SHARE_MULTIPLE = 1e6;

    uint256 bondedTotal = totalBonded();

    uint256 newStakePadding = bondedTotal == 0 ?
      totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 :
      totalRewardedWithStakePadding.mul(amount).div(bondedTotal);

    _addToStakePadding(account, newStakePadding);
  }

  function _addToStakePadding(address account, uint256 amount) internal {
    _userStakePadding[account] = _userStakePadding[account].add(amount);

    _globalStakePadding = _globalStakePadding.add(amount);
  }

  function _removeFromStakePadding(
    address account,
    uint256 amount,
    string memory reason
  ) internal {
    _userStakePadding[account] = _userStakePadding[account].sub(amount, reason);

    _globalStakePadding = _globalStakePadding.sub(amount, reason);
  }

  function _reconcileWithdrawn(
    address account,
    uint256 amount,
    uint256 bondedBalance
  ) internal {
    uint256 withdrawDiff = _userWithdrawn[account].mul(amount) / bondedBalance;
    _userWithdrawn[account] = _userWithdrawn[account].sub(withdrawDiff, ""< withdrawn"");
    _globalWithdrawn = _globalWithdrawn.sub(withdrawDiff, ""< global withdrawn"");
  }

  function _handleWithdrawForAccount(address account, uint256 rewardAmount, address to) internal {
    _beforeWithdraw(account, rewardAmount);

    _withdraw(account, rewardAmount, to);

    _afterWithdraw(account, rewardAmount);
  }

  /*
   * HOOKS
   */
  function _beforeWithdraw(address account, uint256 amount) virtual internal {
    // hook
  }

  function _afterWithdraw(address account, uint256 amount) virtual internal {
    // hook
  }

  function _beforeBond(address account, uint256 amount) virtual internal {
    // hook
  }

  function _afterBond(address account, uint256 amount) virtual internal {
    // hook
  }

  function _beforeUnbond(address account, uint256 amount) virtual internal {
    // hook
  }

  function _afterUnbond(address account, uint256 amount) virtual internal {
    // hook
  }

  /*
   * PRIVILEDGED METHODS
   */
  function withdrawForAccount(address account, uint256 amount, address to)
    external
    onlyRole(REWARD_MANAGER_ROLE, ""Must have reward manager privs"")
    returns (uint256)
  {
    uint256 rewardEarned = earned(account);

    if (rewardEarned < amount) {
      amount = rewardEarned;
    }
    
    _handleWithdrawForAccount(account, amount, to);

    return amount;
  }

  function setRewardToken(address _token)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    rewardToken = ERC20(_token);
  }

  function setMiningService(address _miningService)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    _swapRole(_miningService, miningService, MINING_SERVICE_ROLE);
    _swapRole(_miningService, miningService, REWARD_MANAGER_ROLE);
    miningService = _miningService;
  }
}",2095
RealWorld_BA_59_IBonding_RealWord_20240822091431.log,59,IBonding,5069,5571,10640,79.0,0.136765,"pragma solidity >=0.6.6;

interface IBonding {
  function bond(uint256 amount) external;
  function bondToAccount(address account, uint256 amount) external;
  function unbond(uint256 amount) external;
  function totalBonded() external view returns (uint256);
  function balanceOfBonded(address account) external view returns (uint256);
  function averageBondedValue(uint256 epoch) external view returns (uint256);
}",94
RealWorld_BA_59_AbstractTransferVerification_RealWord_20240822082652.log,59,AbstractTransferVerification,4328,3946,8274,66.0,0.10056,"pragma solidity >=0.6.6;

import ""./Permissions.sol"";

/// @title AbstractTransferVerification
/// @author 0xScotch <scotch@malt.money>
/// @notice Implements a single method that can block a particular transfer
abstract contract AbstractTransferVerification is Permissions {
  function verifyTransfer(address from, address to, uint256 amount) public view virtual returns (bool, string memory) {
    return (true, """");
  }
}",92
RealWorld_BA_59_Timelock_RealWord_20240822082012.log,59,Timelock,23586,5454,29040,83.0,0.22701,"// SPDX-License-Identifier: MIT
pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""./Permissions.sol"";


/// @title Timelock
/// @author 0xScotch <scotch@malt.money>
/// @notice Fairly basic timelock contract
contract Timelock is Initializable, Permissions {
  using SafeMath for uint256;

  // The amount of delay after which a delay can a queued can be executed.
  uint256 public delay = 2 days;
  // The the period within which an queued proposal can be executed.
  uint256 public gracePeriod = 7 days;

  mapping(bytes32 => bool) public queuedTransactions;

  event NewDelay(uint256 indexed newDelay_);
  event NewGracePeriod(uint256 indexed newGracePerios_);
  event NewGovernor(address newGovernor);
  event CancelTransaction(
    bytes32 indexed txHash_,
    address indexed target_,
    uint256 value_,
    string signature_,
    bytes data_,
    uint256 eta_
  );
  event ExecuteTransaction(
    bytes32 indexed txHash_,
    address indexed target_,
    uint256 value_,
    string signature_,
    bytes data_,
    uint256 eta_
  );
  event QueueTransaction(
    bytes32 indexed txHash_,
    address indexed target_,
    uint256 value_,
    string signature_,
    bytes data_,
    uint256 eta_
  );

  address public governor;

  function initialize(address _admin, address _governor) external initializer {
    _adminSetup(_admin);
    _setupRole(GOVERNOR_ROLE, address(this));
    _setupRole(GOVERNOR_ROLE, _governor);
    _setRoleAdmin(GOVERNOR_ROLE, TIMELOCK_ROLE);

    governor = _governor;
  }

  receive() external payable {}

  /**
   * @notice Sets the amount of time after which a proposal that has been queued can be executed.
   */
  function setDelay(uint256 _delay)
    public
    onlyRole(GOVERNOR_ROLE, ""Must have timelock role"")
  {
    require(
      _delay >= 0 && _delay < gracePeriod,
      ""Timelock::setDelay: Delay must not be greater equal to zero and less than gracePeriod""
    );
    delay = _delay;

    emit NewDelay(delay);
  }

  /**
   * @notice Sets the amount of time within which a queued proposal can be executed.
   */
  function setGracePeriod(uint256 _gracePeriod)
    public
    onlyRole(GOVERNOR_ROLE, ""Must have timelock role"")
  {
    require(
      _gracePeriod > delay,
      ""Timelock::gracePeriod: Grace period must be greater than delay""
    );
    gracePeriod = _gracePeriod;

    emit NewGracePeriod(gracePeriod);
  }

  /**
   * @notice Sets the governor address that is allowed to make proposals
   */
  function setGovernor(address _governor)
    public
    onlyRole(GOVERNOR_ROLE, ""Must have timelock role"")
  {
    _swapRole(_governor, governor, GOVERNOR_ROLE);
    governor = _governor;
    emit NewGovernor(_governor);
  }

  function queueTransaction(
    address target,
    uint256 value,
    string memory signature,
    bytes memory data,
    uint256 eta
  )
    public
    onlyRole(GOVERNOR_ROLE, ""Timelock::queueTransaction: Call must come from governor."")
    returns (bytes32)
  {
    require(
      eta >= block.timestamp.add(delay),
      ""Timelock::queueTransaction: Estimated execution block must satisfy delay.""
    );

    bytes32 txHash = keccak256(
      abi.encode(target, value, signature, data, eta)
    );
    queuedTransactions[txHash] = true;

    emit QueueTransaction(txHash, target, value, signature, data, eta);
    return txHash;
  }

  function cancelTransaction(
    address target,
    uint256 value,
    string memory signature,
    bytes memory data,
    uint256 eta
  )
    public
    onlyRole(GOVERNOR_ROLE, ""Timelock::cancelTransaction: Call must come from governor."")
  {
    bytes32 txHash = keccak256(
      abi.encode(target, value, signature, data, eta)
    );
    queuedTransactions[txHash] = false;

    emit CancelTransaction(txHash, target, value, signature, data, eta);
  }

  function executeTransaction(
    address target,
    uint256 value,
    string memory signature,
    bytes memory data,
    uint256 eta
  )
    public
    payable
    onlyRole(GOVERNOR_ROLE, ""Timelock::executeTransaction: Call must come from governor."")
    returns (bytes memory)
  {
    bytes32 txHash = keccak256(
      abi.encode(target, value, signature, data, eta)
    );
    require(
      queuedTransactions[txHash],
      ""Timelock::executeTransaction: Transaction hasn't been queued.""
    );
    require(
      block.timestamp >= eta,
      ""Timelock::executeTransaction: Transaction hasn't surpassed time lock.""
    );
    require(
      block.timestamp <= eta.add(gracePeriod),
      ""Timelock::executeTransaction: Transaction is stale.""
    );

    queuedTransactions[txHash] = false;

    bytes memory callData;

    if (bytes(signature).length == 0) {
      callData = data;
    } else {
      callData = abi.encodePacked(
        bytes4(keccak256(bytes(signature))),
        data
      );
    }

    (bool success, bytes memory returnData) = target.call{value: value}(
      callData
    );

    require(
      success,
      ""Timelock::executeTransaction: Transaction execution reverted.""
    );

    emit ExecuteTransaction(txHash, target, value, signature, data, eta);

    return returnData;
  }
}",1275
RealWorld_BA_59_DAO_RealWord_20240822080619.log,59,DAO,16123,5600,21723,80.0,0.192615,"pragma solidity >=0.6.6;
pragma experimental ABIEncoderV2;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""./interfaces/IBurnMintableERC20.sol"";
import ""./Permissions.sol"";


/// @title Malt DAO
/// @author 0xScotch <scotch@malt.money>
/// @notice In essence a contract that is the oracle for the current epoch
contract MaltDAO is Initializable, Permissions {
  using SafeMath for uint256;

  IBurnMintableERC20 public malt;
  uint256 public epoch = 0;
  uint256 public epochLength;
  uint256 public genesisTime;
  uint256 public advanceIncentive = 100; // 100 Malt

  event Advance(uint256 indexed epoch, uint256 block, uint256 timestamp);
  event Mint(address recipient, uint256 amount);
  event SetMaltToken(address maltToken);
  event SetEpochLength(uint256 length);
  event SetAdvanceIncentive(uint256 incentive);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _malt,
    uint256 _epochLength,
    uint256 _genesisTime,
    address offering,
    uint256 offeringMint
  ) external initializer {
    _setMaltToken(_malt);
    _setEpochLength(_epochLength);

    _adminSetup(_timelock);
    _setupRole(ADMIN_ROLE, initialAdmin);

    genesisTime = _genesisTime;

    if (offeringMint > 0) {
      // Tokens minted to Community Whitelist contract
      malt.mint(offering, offeringMint);
    }
  }

  receive() external payable {}

  function advance() external {
    require(block.timestamp >= getEpochStartTime(epoch + 1), ""Cannot advance epoch until start of new epoch"");

    incrementEpoch();

    malt.mint(msg.sender, advanceIncentive * 1e18);

    emit Advance(epoch, block.number, block.timestamp);
  }

  function getEpochStartTime(uint256 _epoch) public view returns (uint256) {
    return genesisTime.add(epochLength.mul(_epoch));
  }

  function epochsPerYear() public view returns (uint256) {
    // 31557600 = seconds in a year
    return 31557600 / epochLength;
  }

  function mint(address to, uint256 amount)
    public
    onlyRole(TIMELOCK_ROLE, ""Must have timelock role"")
  {
    require(amount > 0, ""Cannot have zero amount"");
    malt.mint(to, amount);
    emit Mint(to, amount);
  }

  function setMaltToken(address _malt)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    _setMaltToken(_malt);
  }

  function setEpochLength(uint256 _length)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_length > 0, ""Cannot have zero length epochs"");
    _setEpochLength(_length);
  }

  function setAdvanceIncentive(uint256 incentive)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    advanceIncentive = incentive;
    emit SetAdvanceIncentive(incentive);
  }

  /* Internal methods */
  function incrementEpoch() internal {
    epoch = epoch.add(1);
  }
  
  function _setEpochLength(uint256 length) internal {
    epochLength = length;
    emit SetEpochLength(length);
  }

  function _setMaltToken(address _malt) internal {
    malt = IBurnMintableERC20(_malt);
    emit SetMaltToken(_malt);
  }
}",813
RealWorld_BA_59_RewardReinvestor_RealWord_20240822081843.log,59,RewardReinvestor,21462,5745,27207,87.0,0.22221,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import ""./interfaces/IDexHandler.sol"";
import ""./interfaces/IBonding.sol"";
import ""./interfaces/IMiningService.sol"";
import ""./libraries/UniswapV2Library.sol"";
import ""./Permissions.sol"";


/// @title Reward Reinvestor
/// @author 0xScotch <scotch@malt.money>
/// @notice Provide a way to programmatically reinvest Malt rewards
contract RewardReinvestor is Initializable, Permissions {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  ERC20 public malt;
  ERC20 public rewardToken;
  ERC20 public stakeToken;

  IDexHandler public dexHandler;
  IBonding public bonding;
  IMiningService public miningService;
  address public treasury;

  event ProvideReinvest(address account, uint256 reward);
  event SplitReinvest(address account, uint256 amountReward);
  event SetDexHandler(address dexHandler);
  event SetBonding(address bonding);
  event SetMiningService(address miningService);
  event SetTreasury(address _treasury);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _maltToken,
    address _rewardToken,
    address _dexHandler,
    address _bonding,
    address _miningService,
    address _uniswapV2Factory,
    address _treasury
  ) external initializer {
    _adminSetup(_timelock);
    _setupRole(ADMIN_ROLE, initialAdmin);

    malt = ERC20(_maltToken);
    rewardToken = ERC20(_rewardToken);
    dexHandler = IDexHandler(_dexHandler);
    bonding = IBonding(_bonding);
    miningService = IMiningService(_miningService);
    treasury = _treasury;

    stakeToken = ERC20(UniswapV2Library.pairFor(_uniswapV2Factory, _maltToken, _rewardToken));
  }

  function provideReinvest(uint256 rewardLiquidity) external {
    _retrieveReward(rewardLiquidity);

    uint256 rewardBalance = rewardToken.balanceOf(address(this));

    // This is how much malt is required
    uint256 maltLiquidity = dexHandler.getOptimalLiquidity(address(malt), address(rewardToken), rewardBalance);

    // Transfer the remaining Malt required
    malt.safeTransferFrom(msg.sender, address(this), maltLiquidity);

    _bondAccount(msg.sender);

    emit ProvideReinvest(msg.sender, rewardLiquidity);
  }

  function splitReinvest(uint256 rewardLiquidity) external {
    _retrieveReward(rewardLiquidity);

    uint256 rewardBalance = rewardToken.balanceOf(address(this));

    rewardToken.safeTransfer(address(dexHandler), rewardBalance.div(2));

    dexHandler.buyMalt();

    _bondAccount(msg.sender);

    emit SplitReinvest(msg.sender, rewardLiquidity);
  }

  function _retrieveReward(uint256 rewardLiquidity) internal {
    require(rewardLiquidity > 0, ""Cannot reinvest 0"");

    miningService.withdrawRewardsForAccount(
      msg.sender,
      rewardLiquidity
    );
  }

  function _bondAccount(address account) internal {
    malt.safeTransfer(address(dexHandler), malt.balanceOf(address(this)));
    rewardToken.safeTransfer(address(dexHandler), rewardToken.balanceOf(address(this)));

    (,,uint256 liquidityCreated) = dexHandler.addLiquidity();

    stakeToken.approve(address(bonding), liquidityCreated);

    bonding.bondToAccount(account, liquidityCreated);

    // If there is any carry / left overs then send to treasury
    uint256 maltBalance = malt.balanceOf(address(this));
    uint256 rewardTokenBalance = rewardToken.balanceOf(address(this));

    if (maltBalance > 0) {
      malt.safeTransfer(treasury, maltBalance);
    }

    if (rewardTokenBalance > 0) {
      rewardToken.safeTransfer(treasury, rewardTokenBalance);
    }
  }

  function setDexHandler(address _dexHandler)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_dexHandler != address(0), ""Not address 0"");
    dexHandler = IDexHandler(_dexHandler);
    emit SetDexHandler(_dexHandler);
  }

  function setBonding(address _bonding)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_bonding != address(0), ""Not address 0"");
    bonding = IBonding(_bonding);
    emit SetBonding(_bonding);
  }

  function setMiningService(address _miningService)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_miningService != address(0), ""Not address 0"");
    miningService = IMiningService(_miningService);
    emit SetMiningService(_miningService);
  }

  function setTreasury(address _treasury)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_treasury != address(0), ""Not address 0"");
    treasury = _treasury;
    emit SetTreasury(_treasury);
  }
}",1172
RealWorld_BA_59_AuctionPool_RealWord_20240822082914.log,59,AuctionPool,23001,5463,28464,79.0,0.224265,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";

import ""./AuctionParticipant.sol"";
import ""./AbstractRewardMine.sol"";
import ""./interfaces/IAuction.sol"";
import ""./interfaces/IBurnMintableERC20.sol"";
import ""./interfaces/IDexHandler.sol"";
import ""./interfaces/IBonding.sol"";


/// @title LP Auction Pool
/// @author 0xScotch <scotch@malt.money>
/// @notice A portion of above peg profit is directed here and the capital is deployed into arbitrage auctions when possible.
/// @notice The core functionality is implemented in AuctionParticipant and AbstractRewardMine. But together they make new composite functionality.
contract AuctionPool is Initializable, AuctionParticipant, AbstractRewardMine {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  uint256 public forfeitedRewards;

  IBonding public bonding;
  address public forfeitDestination;

  function initialize(
    address _timelock,
    address initialAdmin,
    address _rewardToken,
    address _auction,
    address _impliedCollateralService,
    address _bonding,
    address _miningService,
    address _forfeitDestination
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);

    bonding = IBonding(_bonding);

    _initialSetup(_rewardToken, _miningService);

    setupParticipant(
      _impliedCollateralService,
      _rewardToken,
      _auction
    );
    forfeitDestination = _forfeitDestination;
  }

  function onUnbond(address account, uint256 amount)
    override
    public
    onlyRole(MINING_SERVICE_ROLE, ""Must having mining service privilege"")
  {
    // Withdraw all current rewards
    // Done now before we change stake padding below
    uint256 rewardEarned = earned(account);
    _handleWithdrawForAccount(account, rewardEarned, account);

    uint256 bondedBalance = balanceOfBonded(account);

    if (bondedBalance == 0) {
      return;
    }

    _checkForForfeit(account, amount, bondedBalance);

    uint256 lessStakePadding = balanceOfStakePadding(account).mul(amount).div(bondedBalance);

    _reconcileWithdrawn(account, amount, bondedBalance);
    _removeFromStakePadding(account, lessStakePadding, ""< stake padding"");
  }

  function totalBonded() override public view returns (uint256) {
    return bonding.totalBonded();
  }

  function balanceOfBonded(address account) override public view returns (uint256) {
    return bonding.balanceOfBonded(account);
  }

  function totalDeclaredReward() override public view returns (uint256) {
    // Outstanding Arb tokens + the claimable arb tokens that have been redeemed
    // minus rewards that have been forfeited
    return outstandingArbTokens() + claimableRewards - forfeitedRewards;
  }

  function totalReleasedReward() override public view returns (uint256) {
    return claimableRewards + _globalWithdrawn;
  }

  function usableBalance() override public view returns(uint256) {
    uint256 totalBalance = auctionRewardToken.balanceOf(address(this));

    if (totalBalance > claimableRewards) {
      return totalBalance - claimableRewards;
    }

    return 0;
  }

  /*
   * INTERNAL FUNCTIONS
   */
  function _checkForForfeit(address account, uint256 amount, uint256 bondedBalance) internal {
    // This is the user's share of total rewards
    uint256 userReward = balanceOfRewards(account);
    uint256 globalRewarded = totalDeclaredReward();

    uint256 earnedReward = 0;
    
    // This is done inline instead of using earned() to save gas
    if (globalRewarded > 0 && userReward > 0) {
      earnedReward = totalReleasedReward().mul(userReward).div(globalRewarded);
    }

    uint256 forfeitAmount = userReward.sub(earnedReward).mul(amount) / bondedBalance;
    uint256 declaredRewardDecrease = earnedReward.mul(amount) / bondedBalance;

    if (forfeitAmount > 0) {
      forfeitedRewards = forfeitedRewards + forfeitAmount;
    }

    if (declaredRewardDecrease > 0) {
      claimableRewards = claimableRewards.sub(
        declaredRewardDecrease
      );
    }
  }

  function _afterWithdraw(address account, uint256 amount) override internal {
    claimableRewards = claimableRewards.sub(amount);
  }

  function _handleRewardDistribution(uint256 rewarded) override internal {
    if (forfeitedRewards > 0) {
      uint256 coverage;
      // Need to pay down some of the forfeited amount
      if (rewarded > forfeitedRewards) {
        // Can cover everything
        coverage = forfeitedRewards;
      } else {
        coverage = rewarded;
      }

      forfeitedRewards = forfeitedRewards - coverage;
      claimableRewards = claimableRewards.sub(coverage);

      rewardToken.safeTransfer(forfeitDestination, coverage);
    }
  }

  /*
   * PRIVILEDGED FUNCTIONS
   */
  function setBonding(address _bonding)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_bonding != address(0), ""Not zero address"");
    bonding = IBonding(_bonding);
  }

  function setForfeitDestination(address _forfeitDestination)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_forfeitDestination != address(0), ""Not zero address"");
    forfeitDestination = _forfeitDestination;
  }
}",1272
RealWorld_BA_59_IRewardMine_RealWord_20240822090732.log,59,IRewardMine,7105,5461,12566,106.0,0.144745,"pragma solidity >=0.6.6;

interface IRewardMine {
  function rewardToken() external view returns (address);
  function onBond(address account, uint256 amount) external;
  function onUnbond(address account, uint256 amount) external;
  function withdrawAll() external;
  function withdraw(uint256 rewardAmount) external;
  function totalBonded() external view returns (uint256);
  function balanceOfBonded(address account) external view returns (uint256);
  function totalDeclaredReward() external view returns (uint256);
  function totalReleasedReward() external view returns (uint256);
  function totalStakePadding() external view returns(uint256);
  function balanceOfStakePadding(address account) external view returns (uint256);
  function getRewardOwnershipFraction(address account) external view returns(uint256 numerator, uint256 denominator);
  function balanceOfRewards(address account) external view returns (uint256);
  function earned(address account) external view returns (uint256 earnedReward);
  function withdrawForAccount(address account, uint256 amount, address to) external returns (uint256);
}",227
RealWorld_BA_59_AuctionEscapeHatch_RealWord_20240822080327.log,59,AuctionEscapeHatch,33735,4938,38673,87.0,0.267435,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/math/Math.sol"";

import ""./Permissions.sol"";
import ""./interfaces/IAuction.sol"";
import ""./interfaces/IDexHandler.sol"";
import ""./interfaces/IBurnMintableERC20.sol"";
import ""./Auction.sol"";


struct EarlyExitData {
  uint256 exitedEarly;
  uint256 earlyExitReturn;
  uint256 maltUsed;
}

struct AuctionExits {
  uint256 exitedEarly;
  uint256 earlyExitReturn;
  uint256 maltUsed;
  mapping(address => EarlyExitData) accountExits;
}


/// @title Auction Escape Hatch
/// @author 0xScotch <scotch@malt.money>
/// @notice Functionality to reduce risk profile of holding arbitrage tokens by allowing early exit
contract AuctionEscapeHatch is Initializable, Permissions {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  IAuction public auction;
  IDexHandler public dexHandler;
  ERC20 public collateralToken;
  IBurnMintableERC20 public malt;
  uint256 public maxEarlyExitBps = 200; // 20%
  uint256 public cooloffPeriod = 60 * 60 * 24; // 24 hours

  mapping(uint256 => AuctionExits) internal auctionEarlyExits;

  event EarlyExit(address account, uint256 amount, uint256 received);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _collateralToken,
    address _malt,
    address _auction,
    address _handler
  ) external initializer {
    _adminSetup(_timelock);
    _setupRole(ADMIN_ROLE, initialAdmin);

    collateralToken = ERC20(_collateralToken);
    malt = IBurnMintableERC20(_malt);
    auction = IAuction(_auction);
    dexHandler = IDexHandler(_handler);
  }

  function exitEarly(uint256 _auctionId, uint256 amount, uint256 minOut) external notSameBlock {
    uint256 maltQuantity = _calculateMaltRequiredForExit(_auctionId, amount);

    // TODO ensure this contract is added as a mint requester Sat 06 Nov 2021 20:13:49 GMT
    malt.mint(address(dexHandler), maltQuantity);
    uint256 amountOut = dexHandler.sellMalt();

    require(amountOut > minOut, ""EarlyExit: Insufficient output"");

    AuctionExits storage auctionExits = auctionEarlyExits[_auctionId];

    auctionExits.exitedEarly = auctionExits.exitedEarly + amount;
    auctionExits.earlyExitReturn = auctionExits.earlyExitReturn + amountOut;
    auctionExits.maltUsed = auctionExits.maltUsed + maltQuantity;
    auctionExits.accountExits[msg.sender].exitedEarly = auctionExits.accountExits[msg.sender].exitedEarly + amount; 
    auctionExits.accountExits[msg.sender].earlyExitReturn = auctionExits.accountExits[msg.sender].earlyExitReturn + amountOut; 
    auctionExits.accountExits[msg.sender].maltUsed = auctionExits.accountExits[msg.sender].maltUsed + maltQuantity; 

    auction.amendAccountParticipation(
      msg.sender,
      _auctionId,
      amount,
      maltQuantity
    );

    collateralToken.safeTransfer(msg.sender, amountOut);
    emit EarlyExit(msg.sender, amount, amountOut);
  }

  function earlyExitReturn(address account, uint256 _auctionId, uint256 amount) public view returns(uint256) {
    // We don't need all the values
    (,,,,,
     uint256 pegPrice,
     ,
     uint256 auctionEndTime,
     bool active
    ) = auction.getAuctionCore(_auctionId);

    if(active || block.timestamp < auctionEndTime) {
      return 0;
    }

    (
      uint256 userCommitment,
      uint256 userRedeemed,
      uint256 userMaltPurchased
    ) = auction.getAuctionParticipationForAccount(account, _auctionId);

    // This should never overflow due to guards in redemption code
    uint256 userOutstanding = userCommitment - userRedeemed;

    if (amount > userOutstanding) {
      amount = userOutstanding;
    }

    if (amount == 0) {
      return 0;
    }

    (uint256 currentPrice,) = dexHandler.maltMarketPrice();

    uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);

    uint256 fullReturn = maltQuantity.mul(currentPrice) / pegPrice;

    // setCooloffPeriod guards against cooloffPeriod ever being 0
    uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;
    if (progressionBps > 10000) {
      progressionBps = 10000;
    }

    if (fullReturn > amount) {
      // Allow a % of profit to be realised
      uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;
      return amount + maxProfit;
    } 

    return fullReturn;
  }

  function accountAuctionExits(address account, uint256 auctionId) external view returns (
    uint256 exitedEarly,
    uint256 earlyExitReturn,
    uint256 maltUsed
  ) {
    EarlyExitData storage accountExits = auctionEarlyExits[auctionId].accountExits[account];

    return (accountExits.exitedEarly, accountExits.earlyExitReturn, accountExits.maltUsed);
  }

  function globalAuctionExits(uint256 auctionId) external view returns (
    uint256 exitedEarly,
    uint256 earlyExitReturn,
    uint256 maltUsed
  ) {
    AuctionExits storage auctionExits = auctionEarlyExits[auctionId];

    return (auctionExits.exitedEarly, auctionExits.earlyExitReturn, auctionExits.maltUsed);
  }

  /*
   * INTERNAL METHODS
   */
  function _calculateMaltRequiredForExit(uint256 _auctionId, uint256 amount) internal returns(uint256) {
    // We don't need all the values
    (,,,,,
     uint256 pegPrice,
     ,
     uint256 auctionEndTime,
     bool active
    ) = auction.getAuctionCore(_auctionId);

    require(!active, ""Cannot exit early on an active auction"");
    require(block.timestamp > auctionEndTime, ""Auction not over"");

    (
      uint256 userCommitment,
      uint256 userRedeemed,
      uint256 userMaltPurchased
    ) = auction.getAuctionParticipationForAccount(msg.sender, _auctionId);

    // This should never overflow due to guards in redemption code
    if (amount > (userCommitment - userRedeemed)) {
      amount = userCommitment - userRedeemed;
    }

    require(amount > 0, ""Nothing to claim"");

    (uint256 currentPrice,) = dexHandler.maltMarketPrice();

    uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);

    uint256 fullReturn = maltQuantity.mul(currentPrice) / pegPrice;

    // setCooloffPeriod guards against cooloffPeriod ever being 0
    uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;
    if (progressionBps > 10000) {
      progressionBps = 10000;
    }

    if (fullReturn > amount) {
      // Allow a % of profit to be realised
      uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;
      uint256 desiredReturn = amount + maxProfit;
      maltQuantity = desiredReturn.mul(pegPrice) / currentPrice;
    } 

    return maltQuantity;
  }

  /*
   * PRIVILEDGED METHODS
   */
  function setEarlyExitBps(uint256 _earlyExitBps)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    require(_earlyExitBps > 0 && _earlyExitBps <= 1000, ""Must be between 0-100%"");
    maxEarlyExitBps = _earlyExitBps;
  }

  function setCooloffPeriod(uint256 _period)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    require(_period > 0, ""Cannot have 0 lookback period"");
    cooloffPeriod = _period;
  }

  function setDexHandler(address _handler)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    dexHandler = IDexHandler(_handler);
  }
}",1930
RealWorld_BA_59_IERC20Permit_RealWord_20240822085451.log,59,IERC20Permit,11879,5036,16915,87.0,0.160115,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.6;

/**
 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
 *
 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 * need to send a transaction, and thus is not required to hold Ether at all.;
 */
interface IERC20Permit {
    /**
     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
     * given ``owner``'s signed approval.
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `deadline` must be a timestamp in the future.
     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
     * over the EIP712-formatted function arguments.
     * - the signature must use ``owner``'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     */
    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;

    /**
     * @dev Returns the current nonce for `owner`. This value must be
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases ``owner``'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address owner) external view returns (uint256);

    /**
     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
     */
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}",532
RealWorld_BA_59_ISupplyDistributionController_RealWord_20240822084938.log,59,ISupplyDistributionController,3330,4014,7344,73.0,0.09693,"pragma solidity >=0.6.6;

interface ISupplyDistributionController {
  function check() external view returns (bool);
}",26
RealWorld_BA_59_IDexHandler_RealWord_20240822085052.log,59,IDexHandler,6001,5465,11466,79.0,0.139305,"pragma solidity >=0.6.6;

interface IDexHandler {
  function buyMalt() external returns (uint256 purchased);
  function sellMalt() external returns (uint256 rewards);
  function addLiquidity() external returns (
    uint256 maltUsed,
    uint256 rewardUsed,
    uint256 liquidityCreated
  );
  function removeLiquidity() external returns (uint256 amountMalt, uint256 amountReward);
  function calculateMintingTradeSize(uint256 priceTarget) external view returns (uint256);
  function calculateBurningTradeSize(uint256 priceTarget) external view returns (uint256);
  function reserves() external view returns (uint256 maltSupply, uint256 rewardSupply);
  function maltMarketPrice() external view returns (uint256 price, uint256 decimals);
  function getOptimalLiquidity(address tokenA, address tokenB, uint256 liquidityB)
    external view returns (uint256 liquidityA);
}",198
RealWorld_BA_59_IForfeit_RealWord_20240822091156.log,59,IForfeit,3194,4947,8141,75.0,0.11491,"pragma solidity >=0.6.6;

interface IForfeit {
  function handleForfeit() external;
}",23
RealWorld_BA_59_RewardThrottle_RealWord_20240822084632.log,59,RewardThrottle,45549,5743,51292,76.0,0.342605,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/math/Math.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../Permissions.sol"";
import ""../interfaces/IDAO.sol"";
import ""../interfaces/IOverflow.sol"";
import ""../interfaces/IBonding.sol"";
import ""../interfaces/IDistributor.sol"";

import ""hardhat/console.sol"";

struct State {
  uint256 profit;
  uint256 rewarded;
  uint256 bondedValue;
  uint256 throttle;
}

/// @title Reward Throttle
/// @author 0xScotch <scotch@malt.money>
/// @notice The contract in charge of smoothing out rewards and attempting to find a steady APR
/// @dev The use of smoothingPeriod has some flaws. At the very least the length should be longer
contract RewardThrottle is Initializable, Permissions {
  ERC20 public rewardToken;
  IDAO public dao;
  IBonding public bonding;
  IOverflow public overflowPool;
  IDistributor public distributor;

  uint256 public throttle = 200; // 20%
  uint256 public smoothingPeriod = 48; // 48 epochs = 24 hours

  uint256 internal _activeEpoch;
  mapping(uint256 => State) internal _state;

  event RewardOverflow(uint256 epoch, uint256 overflow);
  event HandleReward(uint256 epoch, uint256 amount);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _dao,
    address _overflowPool,
    address _bonding,
    address _distributor,
    address _rewardToken
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);

    dao = IDAO(_dao);
    overflowPool = IOverflow(_overflowPool);
    bonding = IBonding(_bonding);
    distributor = IDistributor(_distributor);
    rewardToken = ERC20(_rewardToken);
  }

  function handleReward() public {
    uint256 balance = rewardToken.balanceOf(address(this));

    uint256 epoch = dao.epoch();

    checkRewardUnderflow();

    if (epoch > _activeEpoch) {
      _activeEpoch = epoch;
      _state[_activeEpoch].bondedValue = bonding.averageBondedValue(_activeEpoch); 
      _state[_activeEpoch].profit = balance;
      _state[_activeEpoch].rewarded = 0;
      _state[_activeEpoch].throttle = throttle;
    } else {
      _state[_activeEpoch].profit = _state[_activeEpoch].profit.add(balance);
      _state[_activeEpoch].throttle = throttle; 
    }

    // Fetch targetAPR before we update current epoch state
    uint256 aprTarget = targetAPR();

    // Distribute balance to the correct places
    if (aprTarget > 0 && _epochAprGivenReward(epoch, balance) > aprTarget) {
      uint256 remainder = _getRewardOverflow(balance, aprTarget);
      emit RewardOverflow(_activeEpoch, remainder);

      if (remainder > 0) {
        rewardToken.safeTransfer(address(overflowPool), remainder);

        if (balance > remainder) {
          _sendToDistributor(balance - remainder, _activeEpoch);
        }
      }
    } else {
      _sendToDistributor(balance, _activeEpoch);
    }

    emit HandleReward(epoch, balance);
  }

  /*
   * PUBLIC VIEW FUNCTIONS
   */
  function epochAPR(uint256 epoch) public view returns (uint256) {
    // This returns an implied APR based on the distributed rewards and bonded LP at the given epoch
    State memory epochState = _state[epoch];

    uint256 bondedValue = epochState.bondedValue;
    if (bondedValue == 0) {
      bondedValue = bonding.averageBondedValue(epoch); 
      if (bondedValue == 0) {
        return 0;
      }
    }

    // 10000 = 100%
    return epochState.rewarded.mul(10000).mul(dao.epochsPerYear()).div(bondedValue);
  }

  function averageAPR(uint256 startEpoch, uint256 endEpoch) public view returns (uint256) {
    require(startEpoch < endEpoch, ""Start cannot be before the end"");

    uint256 totalAPR = 0;
    for (uint256 i = startEpoch; i < endEpoch; i += 1) {
      totalAPR = totalAPR.add(epochAPR(i));
    }

    return totalAPR / (endEpoch - startEpoch);
  }

  function targetAPR() public view returns (uint256) {
    uint256 epoch = dao.epoch();
    (uint256 target,) = getTargets(epoch, smoothingPeriod);
    return target;
  }

  function targetEpochProfit() public view returns (uint256) {
    uint256 epoch = dao.epoch();
    (, uint256 epochProfitTarget) = getTargets(epoch, smoothingPeriod);
    return epochProfitTarget;
  }

  function getTargets(uint256 epoch, uint256 smoothing) public view returns (uint256, uint256) {
    // Average full APR over smoothingPeriod. Throttled by throttle
    uint256 maxPeriod = Math.min(epoch, smoothing);

    uint256 totalProfit = 0;
    uint256 totalBondedValue = 0;

    // Don't use the current epoch as part of the target calculations
    for (uint256 i = 1; i <= maxPeriod; i = i + 1) {
      totalProfit = totalProfit + _state[epoch - i].profit;
      totalBondedValue = totalBondedValue + _state[epoch - i].bondedValue;
    }

    if (totalBondedValue == 0) {
      return (0, 0);
    }

    totalProfit = totalProfit / maxPeriod;
    totalBondedValue = totalBondedValue / maxPeriod;

    // 10k is used here for more granularity on the APR %
    uint256 fullAPR = totalProfit.mul(10000).mul(dao.epochsPerYear()).div(totalBondedValue);
    // throttle is up to 1000. 1000 = 100%
    uint256 aprTarget = fullAPR.mul(throttle).div(1000);

    // (Target APR, Target profit per epoch)
    return (aprTarget, _desiredProfit(aprTarget, _state[epoch].bondedValue));
  }

  function epochData(uint256 epoch) public view returns (
    uint256 profit,
    uint256 rewarded,
    uint256 bondedValue,
    uint256 throttleAmount
  ) {
    return (
      _state[epoch].profit,
      _state[epoch].rewarded,
      _state[epoch].bondedValue,
      _state[epoch].throttle
    );
  }

  /*
   * INTERNAL VIEW FUNCTIONS
   */
  function _desiredProfit(uint256 apr, uint256 bondedValue) internal view returns (uint256) {
    return apr.mul(bondedValue).div(dao.epochsPerYear()).div(10000);
  }

  function _epochAprGivenReward(uint256 epoch, uint256 reward) internal view returns (uint256) {
    // This returns an implied APR based on the distributed rewards and bonded LP at the given epoch
    State memory epochState = _state[epoch];
    
    if (epochState.bondedValue == 0) {
      return 0;
    }

    // 10000 = 100%
    return (epochState.rewarded.add(reward)).mul(10000).mul(dao.epochsPerYear()).div(epochState.bondedValue);
  }

  function _getRewardOverflow(uint256 declaredReward, uint256 desiredAPR) internal view returns (uint256 remainder) {
    State memory epochState = _state[_activeEpoch];

    if (desiredAPR == 0) {
      // If desired APR is zero then just allow all rewards through
      return 0;
    }

    uint256 targetProfit = desiredAPR.mul(epochState.bondedValue).div(dao.epochsPerYear()).div(10000);

    if (targetProfit <= epochState.rewarded) {
      return declaredReward;
    }

    uint256 undeclaredReward = targetProfit - epochState.rewarded;

    if (undeclaredReward >= declaredReward) {
      // Declared reward doesn't make up for the difference yet
      return 0;
    }

    remainder = declaredReward - undeclaredReward;
  }

  function _getRewardUnderflow(uint256 desiredAPR, uint256 epoch) internal view returns (uint256 amount) {
    State memory epochState = _state[epoch];

    uint256 targetProfit = desiredAPR.mul(epochState.bondedValue).div(dao.epochsPerYear()).div(10000);

    if (targetProfit <= epochState.rewarded) {
      // Rewarded more than target already. 0 underflow
      return 0;
    }

    return targetProfit - epochState.rewarded;
  }

  /*
   * INTERNAL FUNCTIONS
   */
  function _sendToDistributor(uint256 amount, uint256 epoch) internal {
    if (amount == 0) {
      return;
    }
    rewardToken.safeTransfer(address(distributor), amount);
    distributor.declareReward(amount);

    _state[epoch].rewarded = _state[epoch].rewarded.add(amount);
    _state[epoch].bondedValue = bonding.averageBondedValue(epoch); 
  }

  function checkRewardUnderflow() public {
    uint256 epoch = dao.epoch();

    // Fill in gaps so APR target is correct
    _fillInEpochGaps(epoch);

    if (epoch > _activeEpoch) {
      for (uint256 i = _activeEpoch; i < epoch; i = i + 1) {
        (uint256 desiredAPR,) = getTargets(i, smoothingPeriod);

        if (epochAPR(i) < desiredAPR) {
          uint256 underflow = _getRewardUnderflow(desiredAPR, i);

          if (underflow > 0) {
            uint256 balance = overflowPool.requestCapital(underflow);

            _sendToDistributor(balance, i);
          }
        } 
      }
    }
  }

  function _fillInEpochGaps(uint256 epoch) internal {
    _state[_activeEpoch].bondedValue = bonding.averageBondedValue(_activeEpoch); 
    // Avoid issues if gap between rewards is greater than one epoch
    for (uint256 i = _activeEpoch + 1; i < epoch; i = i + 1) {
      if (_state[i].rewarded == 0 && _state[i].bondedValue == 0) {
        _state[i].bondedValue = bonding.averageBondedValue(i); 
        _state[i].profit = 0;
        _state[i].rewarded = 0;
        _state[i].throttle = throttle;
      }
    }
  }

  /*
   * PRIVILEDGED FUNCTIONS
   */
  function setDao(address _dao) external onlyRole(ADMIN_ROLE, ""Must have admin privs"") {
    require(_dao != address(0), ""Not address 0"");
    dao = IDAO(_dao);
  }

  function setBonding(address _bonding) external onlyRole(ADMIN_ROLE, ""Must have admin privs"") {
    require(_bonding != address(0), ""Not address 0"");
    bonding = IBonding(_bonding);
  }

  function setDistributor(address _distributor) external onlyRole(ADMIN_ROLE, ""Must have admin privs"") {
    require(_distributor != address(0), ""Not address 0"");
    distributor = IDistributor(_distributor);
  }

  function setOverflowPool(address _overflowPool) external onlyRole(ADMIN_ROLE, ""Must have admin privs"") {
    require(_overflowPool != address(0), ""Not address 0"");
    overflowPool = IOverflow(_overflowPool);
  }

  function setThrottle(uint256 _throttle) external onlyRole(ADMIN_ROLE, ""Must have admin privs"") {
    require(_throttle <= 1000, ""Cannot have throttle above 100%"");
    throttle = _throttle;
  }

  function setSmoothingPeriod(uint256 _smoothingPeriod) external onlyRole(ADMIN_ROLE, ""Must have admin privs"") {
    require(_smoothingPeriod > 0, ""No zero smoothing period"");
    smoothingPeriod = _smoothingPeriod;
  }
}",2662
RealWorld_BA_59_UniswapV2Library_RealWord_20240822084101.log,59,UniswapV2Library,21569,5208,26777,75.0,0.212005,"pragma solidity >=0.5.0;

import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';

import ""@openzeppelin/contracts/math/SafeMath.sol"";

library UniswapV2Library {
    using SafeMath for uint;

    // returns sorted token addresses, used to handle return values from pairs sorted in this order
    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
    }

    // calculates the CREATE2 address for a pair without making any external calls
    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {
        (address token0, address token1) = sortTokens(tokenA, tokenB);
        pair = address(uint(keccak256(abi.encodePacked(
                hex'ff',
                factory,
                keccak256(abi.encodePacked(token0, token1)),
                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash
            ))));
    }

    // fetches and sorts the reserves for a pair
    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {
        (address token0,) = sortTokens(tokenA, tokenB);
        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();
        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
    }

    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset
    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {
        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');
        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        amountB = amountA.mul(reserveB) / reserveA;
    }

    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {
        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint amountInWithFee = amountIn.mul(997);
        uint numerator = amountInWithFee.mul(reserveOut);
        uint denominator = reserveIn.mul(1000).add(amountInWithFee);
        amountOut = numerator / denominator;
    }

    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {
        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint numerator = reserveIn.mul(amountOut).mul(1000);
        uint denominator = reserveOut.sub(amountOut).mul(997);
        amountIn = (numerator / denominator).add(1);
    }

    // performs chained getAmountOut calculations on any number of pairs
    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[0] = amountIn;
        for (uint i; i < path.length - 1; i++) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);
            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);
        }
    }

    // performs chained getAmountIn calculations on any number of pairs
    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[amounts.length - 1] = amountOut;
        for (uint i = path.length - 1; i > 0; i--) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);
            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);
        }
    }
}",1160
RealWorld_BA_59_IRewardThrottle_RealWord_20240822092248.log,59,IRewardThrottle,4562,4626,9188,89.0,0.11533,"pragma solidity >=0.6.6;

interface IRewardThrottle {
  function handleReward() external;
  function epochAPR(uint256 epoch) external view returns (uint256);
  function targetAPR() external view returns (uint256);
  function epochData(uint256 epoch) external view returns (
    uint256 profit,
    uint256 rewarded,
    uint256 bondedValue,
    uint256 throttle
  );
  function checkRewardUnderflow() external;
}",96
RealWorld_BA_59_AuctionParticipant_RealWord_20240822082800.log,59,AuctionParticipant,17947,5405,23352,72.0,0.197835,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""./Permissions.sol"";
import ""./interfaces/IAuction.sol"";


/// @title Auction Participant
/// @author 0xScotch <scotch@malt.money>
/// @notice Will generally be inherited to give another contract the ability to use its capital to buy arbitrage tokens
contract AuctionParticipant is Permissions {
  bytes32 public constant IMPLIED_COLLATERAL_SERVICE_ROLE = keccak256(""IMPLIED_COLLATERAL_SERVICE_ROLE"");

  IAuction public auction;
  ERC20 public auctionRewardToken;

  uint256 public replenishingIndex;
  uint256[] public auctionIds;
  uint256 public claimableRewards;

  bool internal setupCompleted;

  function setupParticipant(
    address _impliedCollateralService,
    address _rewardToken,
    address _auction
  ) public {
    require(!setupCompleted, ""Can only call setup once"");

    _roleSetup(IMPLIED_COLLATERAL_SERVICE_ROLE, _impliedCollateralService);
    auctionRewardToken = ERC20(_rewardToken);
    auction = IAuction(_auction);

    setupCompleted = true;
  }

  function purchaseArbitrageTokens(uint256 maxAmount)
    external
    onlyRole(IMPLIED_COLLATERAL_SERVICE_ROLE, ""Must have implied collateral service privs"")
    returns (uint256 remaining)
  {
    uint256 balance = usableBalance();

    if (maxAmount < balance) {
      balance = maxAmount;
    }

    uint256 currentAuction = auction.currentAuctionId();
    
    if (!auction.auctionActive(currentAuction)) {
      return maxAmount;
    }

    auctionIds.push(currentAuction);

    auctionRewardToken.approve(address(auction), balance);
    auction.purchaseArbitrageTokens(balance);
    
    return maxAmount - balance;
  }

  function claim() external {
    if (auctionIds.length == 0 || replenishingIndex >= auctionIds.length) {
      return;
    }

    uint256 auctionId = auctionIds[replenishingIndex];
    uint256 replenishingId = auction.replenishingAuctionId();

    if (auctionId > replenishingId) {
      // Not yet replenishing this auction
      return;
    }
    uint256 claimableTokens = auction.userClaimableArbTokens(address(this), auctionId);

    if (claimableTokens == 0) {
      // Nothing to claim yet
      return;
    }

    uint256 balance = auctionRewardToken.balanceOf(address(this));

    auction.claimArbitrage(auctionId);

    uint256 finalBalance = auctionRewardToken.balanceOf(address(this));
    uint256 rewardedAmount = finalBalance - balance;

    claimableRewards = claimableRewards.add(rewardedAmount);

    uint256 claimable = auction.userClaimableArbTokens(address(this), auctionId);

    if (replenishingId > auctionId && claimable == 0) {
      // Don't increment replenishingIndex if replenishingAuctionId == auctionId as
      // claimable could be 0 due to the debt not being 100% replenished.
      replenishingIndex = replenishingIndex + 1;
    }

    _handleRewardDistribution(rewardedAmount);
  }

  function outstandingArbTokens() public view returns (uint256 outstanding) {
    outstanding = 0;

    for (uint256 i = replenishingIndex; i < auctionIds.length; i = i + 1) {
      uint256 claimable = auction.balanceOfArbTokens(
        auctionIds[i],
        address(this)
      );

      outstanding = outstanding + claimable;
    }

    return outstanding;
  }

  function getAllAuctionIds() public view returns (uint256[] memory) {
    return auctionIds;
  }

  function usableBalance() virtual public view returns(uint256) {
    return auctionRewardToken.balanceOf(address(this));
  }

  function _handleRewardDistribution(uint256 rewarded) virtual internal {
    // Do nothing
    return;
  }

  function setReplenishingIndex(uint256 _index)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_index > replenishingIndex, ""Cannot replenishingIndex to old value"");
    replenishingIndex = _index;
  }
}",925
RealWorld_BA_59_IAuctionStartController_RealWord_20240822092128.log,59,IAuctionStartController,3303,3548,6851,77.0,0.087475,"pragma solidity >=0.6.6;

interface IAuctionStartController {
  function checkForStart() external view returns(bool);
}",27
RealWorld_BA_59_IAuctionBurnReserveSkew_RealWord_20240822091820.log,59,IAuctionBurnReserveSkew,5721,5801,11522,109.0,0.144625,"pragma solidity >=0.6.6;

interface IAuctionBurnReserveSkew {
  function consult(uint256 excess) external view returns (uint256);
  function getAverageParticipation() external view;
  function getPegDeltaFrequency() external view;
  function addAbovePegObservation(uint256 amount) external;
  function addBelowPegObservation(uint256 amount) external;
  function setNewStabilizerNode() external;
  function removeStabilizerNode() external;
  function getRealBurnBudget(
    uint256 maxBurnSpend,
    uint256 premiumExcess
  ) external view returns(uint256);
}",132
RealWorld_BA_59_Create2Deployer_RealWord_20240822080456.log,59,Create2Deployer,5010,5172,10182,81.0,0.12849,"pragma solidity >=0.6.6;

contract Create2Deployer {
  event Deployed(address addr, uint256 salt);

  function deploy(bytes memory code, uint256 salt) public {
    address addr;
    assembly {
      addr := create2(0, add(code, 0x20), mload(code), salt)
      if iszero(extcodesize(addr)) {
        revert(0, 0)
      }
    }

    emit Deployed(addr, salt);
  }
}",101
RealWorld_BA_59_RewardOverflowPool_RealWord_20240822084357.log,59,RewardOverflowPool,12966,5065,18031,78.0,0.16613,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";

import ""../AuctionParticipant.sol"";

/// @title Reward Overflow Pool
/// @author 0xScotch <scotch@malt.money>
/// @notice Allows throttler contract to request capital when the current epoch underflows desired reward
contract RewardOverflowPool is Initializable, AuctionParticipant {
  uint256 public maxFulfillment = 500; // 50%
  address public throttler;

  event FulfilledRequest(uint256 amount);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _rewardThrottle,
    address _rewardToken,
    address _auction,
    address _impliedCollateralService
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);
    _setupRole(REWARD_THROTTLE_ROLE, _rewardThrottle);

    throttler = _rewardThrottle;

    setupParticipant(
      _impliedCollateralService,
      _rewardToken,
      _auction
    );
  }

  function requestCapital(uint256 amount)
    external
    onlyRole(REWARD_THROTTLE_ROLE, ""Must have Reward throttle privs"")
    returns (uint256 fulfilledAmount)
  {
    uint256 balance = auctionRewardToken.balanceOf(address(this));

    if (balance == 0) {
      return 0;
    }

    // This is the max amount allowable
    fulfilledAmount = balance.mul(maxFulfillment).div(1000);

    if (amount <= fulfilledAmount) {
      fulfilledAmount = amount;
    } 

    auctionRewardToken.safeTransfer(throttler, fulfilledAmount);

    emit FulfilledRequest(fulfilledAmount);

    return fulfilledAmount;
  }

  /*
   * INTERNAL FUNCTIONS
   */
  function _handleRewardDistribution(uint256 amount) override internal {
    // reset claimable rewards as all rewards stay here
    claimableRewards = 0;
  }

  /*
   * PRIVILEDGED FUNCTIONS
   */
  function setMaxFulfillment(uint256 _maxFulfillment) external onlyRole(ADMIN_ROLE, ""Must have admin privs"") {
    require(_maxFulfillment > 0, ""Can't have 0 max fulfillment"");
    require(_maxFulfillment <= 1000, ""Can't have above 100% max fulfillment"");

    maxFulfillment = _maxFulfillment;
  }

  function setThrottler(address _throttler) external onlyRole(ADMIN_ROLE, ""Must have admin privs"") {
    require(_throttler != address(0), ""Not address 0"");

    revokeRole(REWARD_THROTTLE_ROLE, throttler);
    _setupRole(REWARD_THROTTLE_ROLE, _throttler);

    throttler = _throttler;
  }
}",616
RealWorld_BA_59_Malt_RealWord_20240822080919.log,59,Malt,11487,4931,16418,67.0,0.156055,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""./ERC20Permit.sol"";
import ""./Permissions.sol"";
import ""./interfaces/ITransferService.sol"";


/// @title Malt V2 Token
/// @author 0xScotch <scotch@malt.money>
/// @notice The ERC20 token contract for Malt V2
contract Malt is ERC20Permit, Initializable, Permissions {
  using SafeMath for uint256;

  ITransferService public transferService;

  constructor(string memory name, string memory ticker) public ERC20Permit(name, ticker) {}

  event SetTransferService(address service);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _transferService,
    address[] calldata minters,
    address[] calldata burners
  ) external initializer {
    _adminSetup(_timelock);
    _setupRole(ADMIN_ROLE, initialAdmin);

    transferService = ITransferService(_transferService);

    for (uint256 i = 0; i < minters.length; i = i + 1) {
      _setupRole(MONETARY_MINTER_ROLE, minters[i]);
    }
    for (uint256 i = 0; i < burners.length; i = i + 1) {
      _setupRole(MONETARY_BURNER_ROLE, burners[i]);
    }
  }

  function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {
    (bool success, string memory reason) = transferService.verifyTransfer(from, to, amount);
    require(success, reason);
  }

  function mint(address to, uint256 amount)
    public
    onlyRole(MONETARY_MINTER_ROLE, ""Must have monetary minter role"")
  {
    _mint(to, amount);
  }

  function burn(address from, uint256 amount)
    public
    onlyRole(MONETARY_BURNER_ROLE, ""Must have monetary burner role"")
  {
    _burn(from, amount);
  }

  function setTransferService(address _service)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_service != address(0), ""Cannot use address 0 as transfer service"");
    transferService = ITransferService(_service);
    emit SetTransferService(_service);
  }
}",516
RealWorld_BA_59_ILiquidityExtension_RealWord_20240822092011.log,59,ILiquidityExtension,4527,4543,9070,75.0,0.113495,"pragma solidity >=0.6.6;

interface ILiquidityExtension {
  function hasMinimumReserves() external view returns (bool);
  function collateralDeficit() external view returns (uint256, uint256);
  function reserveRatio() external view returns (uint256, uint256);
  function purchaseAndBurn(uint256 amount) external returns (uint256 purchased);
  function buyBack(uint256 maltAmount) external;
}",87
RealWorld_BA_59_IMovingAverage_RealWord_20240822091552.log,59,IMovingAverage,4225,4476,8701,74.0,0.110645,"pragma solidity >=0.6.6;

interface IMovingAverage {
  function getValue() external view returns (uint256);
  function getValueWithLookback(uint256 _lookbackTime) external view returns (uint256);
  function update(uint256 newValue) external;
  function updateCumulative(uint256 _cumulative) external;
}",68
RealWorld_BA_59_ERC20Permit_RealWord_20240822081028.log,59,ERC20Permit,20929,5575,26504,91.0,0.216145,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""./interfaces/IERC20Permit.sol"";


interface ITransferReceiver {
  function onTokenTransfer(address, uint, bytes calldata) external returns (bool);
}

interface IApprovalReceiver {
  function onTokenApproval(address, uint, bytes calldata) external returns (bool);
}

contract ERC20Permit is ERC20, IERC20Permit {
  bytes32 public constant PERMIT_TYPEHASH = keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
  bytes32 public constant TRANSFER_TYPEHASH = keccak256(""Transfer(address owner,address to,uint256 value,uint256 nonce,uint256 deadline)"");
  bytes32 public override immutable DOMAIN_SEPARATOR;

  /// Every successful call to {permit} increases account's nonce by one. This prevents signature from being used multiple times.
  mapping (address => uint256) public override nonces;

  constructor(string memory name, string memory ticker) public ERC20(name, ticker) {
    uint256 chainId;
    assembly {chainId := chainid()}
    DOMAIN_SEPARATOR = keccak256(
      abi.encode(
        keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
        keccak256(bytes(name)),
        keccak256(bytes(""1"")),
        chainId,
        address(this)
      )
    );
  }

  /// Requirements:
  ///   - `deadline` must be timestamp in future.
  ///   - `v`, `r` and `s` must be valid `secp256k1` signature from `owner` account over EIP712-formatted function arguments.
  ///   - the signature must use `owner` account's current nonce (see {nonces}).
  ///   - the signer cannot be zero address and must be `owner` account.
  function permit(address target, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external override {
    require(block.timestamp <= deadline, ""ERC20Permit: Expired permit"");

    bytes32 hashStruct = keccak256(
      abi.encode(
        PERMIT_TYPEHASH,
        target,
        spender,
        value,
        nonces[target]++,
        deadline
      )
    );

    require(verifyEIP712(target, hashStruct, v, r, s) || verifyPersonalSign(target, hashStruct, v, r, s));

    _approve(target, spender, value);
    emit Approval(target, spender, value);
  }

  function transferWithPermit(address target, address to, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool) {
    require(block.timestamp <= deadline, ""ERC20Permit: Expired permit"");

    bytes32 hashStruct = keccak256(
      abi.encode(
        TRANSFER_TYPEHASH,
        target,
        to,
        value,
        nonces[target]++,
        deadline
      )
    );

    require(verifyEIP712(target, hashStruct, v, r, s) || verifyPersonalSign(target, hashStruct, v, r, s));

    require(to != address(0) || to != address(this));

    uint256 balance = balanceOf(target);
    require(balance >= value, ""ERC20Permit: transfer amount exceeds balance"");

    _transfer(target, to, value);

    return true;
  }

  function verifyEIP712(address target, bytes32 hashStruct, uint8 v, bytes32 r, bytes32 s) internal view returns (bool) {
    bytes32 hash = keccak256(
      abi.encodePacked(
        ""\x19\x01"",
        DOMAIN_SEPARATOR,
        hashStruct
      )
    );

    address signer = ecrecover(hash, v, r, s);
    return (signer != address(0) && signer == target);
  }

  function verifyPersonalSign(address target, bytes32 hashStruct, uint8 v, bytes32 r, bytes32 s) internal pure returns (bool) {
    bytes32 hash = prefixed(hashStruct);
    address signer = ecrecover(hash, v, r, s);
    return (signer != address(0) && signer == target);
  }

  // Builds a prefixed hash to mimic the behavior of eth_sign.
  function prefixed(bytes32 hash) internal pure returns (bytes32) {
    return keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash));
  }

  function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool) {
    _approve(msg.sender, spender, value);

    return IApprovalReceiver(spender).onTokenApproval(msg.sender, value, data);
  }

  function transferAndCall(address to, uint value, bytes calldata data) external returns (bool) {
    require(to != address(0) || to != address(this));

    uint256 balance = balanceOf(msg.sender);
    require(balance >= value, ""ERC20Permit: transfer amount exceeds balance"");

    _transfer(msg.sender, to, value);

    return ITransferReceiver(to).onTokenTransfer(msg.sender, value, data);
  }
}",1101
RealWorld_BA_59_MaltDataLab_RealWord_20240822083809.log,59,MaltDataLab,41614,5563,47177,97.0,0.31933,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol"";

import ""./interfaces/IStabilizerNode.sol"";
import ""./interfaces/IMovingAverage.sol"";
import ""./interfaces/IDAO.sol"";
import ""./interfaces/IBurnMintableERC20.sol"";
import ""./interfaces/ILiquidityExtension.sol"";

import ""./libraries/UniswapV2Library.sol"";
import ""./libraries/SafeBurnMintableERC20.sol"";

import ""./Permissions.sol"";


/// @title Malt Data Lab
/// @author 0xScotch <scotch@malt.money>
/// @notice The central source of all of Malt protocol's internal data needs
/// @dev Over time usage of MovingAverage will likely be replaced with more reliable oracles
contract MaltDataLab is Initializable, Permissions {
  using SafeMath for uint256;
  using SafeBurnMintableERC20 for IBurnMintableERC20;

  bytes32 public constant UPDATER_ROLE = keccak256(""UPDATER_ROLE"");

  IBurnMintableERC20 public rewardToken;
  IBurnMintableERC20 public malt;
  ILiquidityExtension public liquidityExtension;
  IUniswapV2Pair public stakeToken;

  IMovingAverage public reserveRatioMA;
  IMovingAverage public maltPriceMA;
  IMovingAverage public poolMaltReserveMA;

  uint256 public priceTarget = 10**18; // $1
  uint256 public reserveRatioLookback = 10 minutes;
  uint256 public maltPriceLookback = 10 minutes;
  uint256 public reserveLookback = 10 minutes;

  event TrackMaltPrice(uint256 price);
  event TrackPoolReserves(uint256 maltReserves, uint256 rewardReserves);
  event TrackReserveRatio(uint256 rRatio, uint256 decimals);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _malt,
    address _rewardToken,
    address _stakeToken,
    uint256 _priceTarget,
    address _liquidityExtension,
    address _reserveRatioMA,
    address _maltPriceMA,
    address _poolMaltReserveMA,
    address _updater
  ) external initializer {
    _adminSetup(_timelock);
    _setupRole(ADMIN_ROLE, initialAdmin);
    _roleSetup(UPDATER_ROLE, _updater);
    _roleSetup(UPDATER_ROLE, initialAdmin);

    stakeToken = IUniswapV2Pair(_stakeToken);
    malt = IBurnMintableERC20(_malt);
    rewardToken = IBurnMintableERC20(_rewardToken);
    priceTarget = _priceTarget;
    liquidityExtension = ILiquidityExtension(_liquidityExtension);
    reserveRatioMA = IMovingAverage(_reserveRatioMA);
    maltPriceMA = IMovingAverage(_maltPriceMA);
    poolMaltReserveMA = IMovingAverage(_poolMaltReserveMA);
  }

  function smoothedReserveRatio() public view returns (uint256) {
    return reserveRatioMA.getValueWithLookback(reserveRatioLookback);
  }

  function smoothedMaltPrice() public view returns (uint256) {
    return maltPriceMA.getValueWithLookback(maltPriceLookback);
  }

  function smoothedMaltInPool() public view returns (uint256) {
    return poolMaltReserveMA.getValueWithLookback(reserveLookback);
  }

  function smoothedReserves() public view returns (uint256 maltReserves, uint256 collateralReserves) {
    maltReserves = poolMaltReserveMA.getValueWithLookback(reserveLookback);
    uint256 price = smoothedMaltPrice();
    return (maltReserves, maltReserves.mul(price).div(priceTarget));
  }

  function reserveRatioAverage(uint256 _lookback) public view returns (uint256) {
    return reserveRatioMA.getValueWithLookback(_lookback);
  }

  function maltPriceAverage(uint256 _lookback) public view returns (uint256) {
    return maltPriceMA.getValueWithLookback(_lookback);
  }

  function maltInPoolAverage(uint256 _lookback) public view returns (uint256) {
    return poolMaltReserveMA.getValueWithLookback(_lookback);
  }

  function realValueOfLPToken(uint256 amount) external view returns (uint256) {
    uint256 maltPrice = smoothedMaltPrice();
    (uint256 maltReserves, uint256 rewardReserves) = smoothedReserves();

    if (maltReserves == 0) {
      return 0;
    }

    uint256 totalLPSupply = stakeToken.totalSupply();

    uint256 maltValue = amount.mul(maltReserves).div(totalLPSupply);
    uint256 rewardValue = amount.mul(rewardReserves).div(totalLPSupply);

    return rewardValue.add(maltValue.mul(maltPrice).div(priceTarget));
  }

  /*
   * Public mutation methods
   */
  function trackReserveRatio() public {
    (uint256 reserveRatio, uint256 decimals) = liquidityExtension.reserveRatio();

    reserveRatioMA.update(reserveRatio);

    emit TrackReserveRatio(reserveRatio, decimals);
  }

  function trackMaltPrice()
    external 
    onlyRole(UPDATER_ROLE, ""Must have updater role"")
  {
    (uint256 reserve0, uint256 reserve1,) = stakeToken.getReserves();
    (address token0,) = UniswapV2Library.sortTokens(address(malt), address(rewardToken));
    uint256 rewardDecimals = rewardToken.decimals();

    if (token0 == address(rewardToken)) {
      uint256 price = _normalizedPrice(reserve0, reserve1, rewardDecimals);
      maltPriceMA.update(price);
      emit TrackMaltPrice(price);
    } else {
      uint256 price = _normalizedPrice(reserve1, reserve0, rewardDecimals);
      maltPriceMA.update(price);

      emit TrackMaltPrice(price);
    }
  }

  function trackPoolReserves()
    external 
    onlyRole(UPDATER_ROLE, ""Must have updater role"")
  {
    (uint256 reserve0, uint256 reserve1,) = stakeToken.getReserves();
    (address token0,) = UniswapV2Library.sortTokens(address(malt), address(rewardToken));
    uint256 rewardDecimals = rewardToken.decimals();

    if (token0 == address(rewardToken)) {
      // Args are (maltReserve)
      poolMaltReserveMA.update(reserve1);
      emit TrackPoolReserves(reserve1, reserve0);
    } else {
      // Args are (maltReserve)
      poolMaltReserveMA.update(reserve0);
      emit TrackPoolReserves(reserve0, reserve1);
    }
  }

  function trackPool()
    external 
    onlyRole(UPDATER_ROLE, ""Must have updater role"")
  {
    (uint256 reserve0, uint256 reserve1,) = stakeToken.getReserves();
    (address token0,) = UniswapV2Library.sortTokens(address(malt), address(rewardToken));
    uint256 rewardDecimals = rewardToken.decimals();

    if (token0 == address(rewardToken)) {
      uint256 price = _normalizedPrice(reserve0, reserve1, rewardDecimals);
      maltPriceMA.update(price);

      // Args are (maltReserve)
      poolMaltReserveMA.update(reserve1);
      emit TrackMaltPrice(price);
      emit TrackPoolReserves(reserve1, reserve0);
    } else {
      uint256 price = _normalizedPrice(reserve1, reserve0, rewardDecimals);
      maltPriceMA.update(price);

      // Args are (maltReserve)
      poolMaltReserveMA.update(reserve0);
      emit TrackMaltPrice(price);
      emit TrackPoolReserves(reserve0, reserve1);
    }
  }

  /*
   * INTERNAL METHODS
   */
  function _normalizedPrice(
    uint256 numerator,
    uint256 denominator,
    uint256 decimals
  ) internal view returns(uint256 price) {
    // Malt is 18 decimals
    if (decimals > 18) {
      uint256 diff = decimals - 18;
      price = numerator.mul(10**decimals).div(denominator.mul(10**diff));
    } else if (decimals < 18) {
      uint256 diff = 18 - decimals;
      price = (numerator.mul(10**diff)).mul(10**decimals).div(denominator);
    } else {
      price = numerator.mul(10**decimals).div(denominator);
    }
  }

  /*
   * PRIVILEDGED METHODS
   */
  function setLiquidityExtension(address _liquidityExtension) 
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_liquidityExtension != address(0), ""Must be a valid address"");
    liquidityExtension = ILiquidityExtension(_liquidityExtension);
  }

  function setPriceTarget(uint256 _price)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_price > 0, ""Cannot have 0 price"");
    priceTarget = _price;
  }

  function setReserveRatioLookback(uint256 _lookback)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_lookback > 0, ""Cannot have 0 lookback"");
    reserveRatioLookback = _lookback;
  }

  function setMaltPriceLookback(uint256 _lookback)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_lookback > 0, ""Cannot have 0 lookback"");
    maltPriceLookback = _lookback;
  }

  function setReserveLookback(uint256 _lookback)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_lookback > 0, ""Cannot have 0 lookback"");
    reserveLookback = _lookback;
  }

  function setReserveAverageContract(address _reserveRatioMA)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_reserveRatioMA != address(0), ""Cannot use 0 address"");
    reserveRatioMA = IMovingAverage(_reserveRatioMA);
  }

  function setMaltPriceAverageContract(address _maltPriceMA)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_maltPriceMA != address(0), ""Cannot use 0 address"");
    maltPriceMA = IMovingAverage(_maltPriceMA);
  }

  function setMaltReservesAverageContract(address _poolMaltReserveMA)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_poolMaltReserveMA != address(0), ""Cannot use 0 address"");
    poolMaltReserveMA = IMovingAverage(_poolMaltReserveMA);
  }
}",2420
RealWorld_BA_59_ImpliedCollateralService_RealWord_20240822082137.log,59,ImpliedCollateralService,20640,5200,25840,75.0,0.2072,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";

import ""./Permissions.sol"";
import ""./interfaces/IAuction.sol"";
import ""./interfaces/IAuctionPool.sol"";
import ""./interfaces/IOverflow.sol"";
import ""./interfaces/IBurnMintableERC20.sol"";
import ""./interfaces/IRewardThrottle.sol"";
import ""./interfaces/ISwingTrader.sol"";
import ""./interfaces/ILiquidityExtension.sol"";
import ""./interfaces/IMaltDataLab.sol"";


/// @title Implied Collateral Service
/// @author 0xScotch <scotch@malt.money>
/// @notice A contract that provides an abstraction above individual implied collateral sources
contract ImpliedCollateralService is Initializable, Permissions {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  ERC20 public collateralToken;
  IBurnMintableERC20 public malt;
  IAuctionPool public auctionPool;
  IOverflow public rewardOverflow;
  ISwingTrader public swingTrader;
  ILiquidityExtension public liquidityExtension;
  IMaltDataLab public maltDataLab;

  event SetAuctionPool(address auctionPool);
  event SetRewardOverflow(address rewardOverflow);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _collateralToken,
    address _malt,
    address _auction,
    address _auctionPool,
    address _rewardOverflow,
    address _swingTrader,
    address _liquidityExtension,
    address _maltDataLab
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);
    _setupRole(AUCTION_ROLE, _auction);

    collateralToken = ERC20(_collateralToken);
    malt = IBurnMintableERC20(_malt);
    auctionPool = IAuctionPool(_auctionPool);
    rewardOverflow = IOverflow(_rewardOverflow);
    swingTrader = ISwingTrader(_swingTrader);
    liquidityExtension = ILiquidityExtension(_liquidityExtension);
    maltDataLab = IMaltDataLab(_maltDataLab);
  }

  function handleDeficit(uint256 maxAmount) external onlyRole(AUCTION_ROLE, ""Must have auction role privs"") {
    if (maxAmount > 0) {
      maxAmount = auctionPool.purchaseArbitrageTokens(maxAmount);
    }

    if (maxAmount > 0) {
      maxAmount = rewardOverflow.purchaseArbitrageTokens(maxAmount);

      // if (maxAmount > 0) {
      //   // TODO IDEA: pull reward out of distributor into auction Pool Tue 16 Nov 2021 00:16:03 GMT
      //   maxAmount = distributor.requestCapital(maxAmount);
      //   if (maxAmount > 0) {
      //     maxAmount = rewardOverflow.purchaseArbitrageTokens(maxAmount);
      //   }
      // }
    }
  }

  function claim() external {
    auctionPool.claim();
    rewardOverflow.claim();
  }

  function setAuctionPool(address _auctionPool)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_auctionPool != address(0), ""Not 0 address"");
    auctionPool = IAuctionPool(_auctionPool);
    emit SetAuctionPool(_auctionPool);
  }

  function setRewardOverflow(address _rewardOverflow)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_rewardOverflow != address(0), ""Not 0 address"");
    rewardOverflow = IOverflow(_rewardOverflow);
    emit SetRewardOverflow(_rewardOverflow);
  }

  function getCollateralValueInMalt() public view returns (uint256 collateral) {
    uint256 maltPrice = maltDataLab.smoothedMaltPrice();
    uint256 target = maltDataLab.priceTarget();

    uint256 auctionPoolBalance = collateralToken.balanceOf(address(auctionPool)).mul(target).div(maltPrice);
    uint256 overflowBalance = collateralToken.balanceOf(address(rewardOverflow)).mul(target).div(maltPrice);
    uint256 liquidityExtensionBalance = collateralToken.balanceOf(address(liquidityExtension)).mul(target).div(maltPrice);
    uint256 swingTraderBalance = collateralToken.balanceOf(address(swingTrader)).mul(target).div(maltPrice);
    uint256 swingTraderMaltBalance = malt.balanceOf(address(swingTrader));

    return auctionPoolBalance + overflowBalance + liquidityExtensionBalance + swingTraderBalance + swingTraderMaltBalance;
  }

  function totalUsefulCollateral() public view returns (uint256 collateral) {
    uint256 auctionPoolBalance = collateralToken.balanceOf(address(auctionPool));
    uint256 overflowBalance = collateralToken.balanceOf(address(rewardOverflow));
    uint256 liquidityExtensionBalance = collateralToken.balanceOf(address(liquidityExtension));
    uint256 swingTraderBalance = collateralToken.balanceOf(address(swingTrader));

    return auctionPoolBalance + overflowBalance + liquidityExtensionBalance + swingTraderBalance;
  }
}",1095
RealWorld_BA_59_SafeBurnMintableERC20_RealWord_20240822084218.log,59,SafeBurnMintableERC20,18208,5539,23747,97.0,0.20182,"// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

import ""../interfaces/IBurnMintableERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeBurnMintableERC20 for IBurnMintableERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeBurnMintableERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IBurnMintableERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IBurnMintableERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IBurnMintableERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(IBurnMintableERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            ""SafeERC20: approve from non-zero to non-zero allowance""
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IBurnMintableERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IBurnMintableERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, ""SafeERC20: decreased allowance below zero"");
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IBurnMintableERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, ""SafeERC20: low-level call failed"");
        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), ""SafeERC20: ERC20 operation did not succeed"");
        }
    }
}",904
RealWorld_BA_59_AuctionBurnReserveSkew_RealWord_20240822083412.log,59,AuctionBurnReserveSkew,27625,5877,33502,87.0,0.255665,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""./interfaces/IStabilizerNode.sol"";
import ""./Auction.sol"";
import ""./Permissions.sol"";


/// @title Auction Burn Reserve Skew
/// @author 0xScotch <scotch@malt.money>
/// @notice This contract makes decisions about what do to with excess Liquidity Extension balance at the end of an auction. Burn additional Malt or retain capital in LE
contract AuctionBurnReserveSkew is Initializable, Permissions {
  using SafeMath for uint256;

  // An array of 0s or 1s that track if active stabilization was 
  // needed above or below peg.
  // 0 = below peg
  // 1 = above peg
  //
  // By doing this we can average the array to get a value that
  // indicates if we are more frequently over or under peg.
  uint256[] public pegObservations;
  uint256 public auctionAverageLookback = 10;

  IStabilizerNode public stabilizerNode;
  IAuction public auction;

  // This is the total number of stabilization observation we have seen
  uint256 public count;

  event SetAuctionAverageLookback(uint256 lookback);
  event SetStabilizerNode(address stabilizerNode);
  event SetAuction(address auction);
  event AbovePegObservation(uint256 amount);
  event BelowPegObservation(uint256 amount);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _stabilizerNode,
    address _auction,
    uint256 _period
  ) external initializer {
    _adminSetup(_timelock);
    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);
    _setupRole(ADMIN_ROLE, initialAdmin);

    stabilizerNode = IStabilizerNode(_stabilizerNode);
    auction = IAuction(_auction);
    auctionAverageLookback = _period;

    for (uint i = 0; i < _period; i++) {
      pegObservations.push(0);
    }
  }

  function consult(uint256 excess) public view returns (uint256) {
    uint256 frequency = getPegDeltaFrequency();
    uint256 participation = getAverageParticipation();

    // Weight participation higher than frequency
    uint256 skew = (frequency + (participation * 2)) / 3;

    return excess.mul(skew).div(10000);
  }

  function getRealBurnBudget(
    uint256 maxBurnSpend,
    uint256 premiumExcess
  ) public view returns(uint256) {
    // Returning maxBurnSpend = maximum supply burn with no reserve ratio improvement
    // Returning premiumExcess = maximum reserve ratio improvement with no real supply burn

    if (premiumExcess > maxBurnSpend) {
      return premiumExcess;
    }

    uint256 usableExcess = maxBurnSpend.sub(premiumExcess);

    if (usableExcess == 0) {
      return premiumExcess;
    }

    uint256 burnable = consult(usableExcess);

    return premiumExcess + burnable;
  }

  function getAverageParticipation() public view returns (uint256) {
    uint256 initialAuction = 0;
    uint256 currentAuctionId = auction.currentAuctionId();

    if (currentAuctionId > auctionAverageLookback) {
      initialAuction = currentAuctionId - auctionAverageLookback;
    }

    // Use the existing struct to avoid filling the stack with temp vars
    AuctionData memory aggregate;

    for (uint256 i = initialAuction; i < currentAuctionId; ++i) {
      (uint256 commitments, uint256 maxCommitments) = auction.getAuctionCommitments(i);
      aggregate.maxCommitments = aggregate.maxCommitments + maxCommitments;
      aggregate.commitments = aggregate.commitments + commitments;
    }

    uint256 participation = 0;
    if (aggregate.maxCommitments > 0) {
      participation = aggregate.commitments.mul(10000).div(aggregate.maxCommitments);
    }

    return participation;
  }

  function getPegDeltaFrequency() public view returns (uint256) {
    uint256 initialIndex = 0;
    uint256 index;

    if (count > auctionAverageLookback) {
      initialIndex = count - auctionAverageLookback;
    }

    uint256 total = 0;

    for (uint256 i = initialIndex; i < count; ++i) {
      index = _getIndexOfObservation(i);
      total = total + pegObservations[index];
    }

    return total * 10000 / auctionAverageLookback;
  }

  function _getIndexOfObservation(uint _index) internal view returns (uint index) {
    return _index % auctionAverageLookback;
  }

  /*
   * The arguments passed into these observation functions are not currently used but they are added
   * incase future versions to this contract want to use them. In that case the stabilizernode
   * won't have to be changed as it is already passing in this argument.
   */
  function addAbovePegObservation(uint256 amount)
    public
    onlyRole(STABILIZER_NODE_ROLE, ""Must be a stabilizer node to call this method"")
  {
    uint256 index = _getIndexOfObservation(count);
    // above peg
    pegObservations[index] = 1;

    count = count + 1;
    emit AbovePegObservation(amount);
  }

  function addBelowPegObservation(uint256 amount)
    public
    onlyRole(STABILIZER_NODE_ROLE, ""Must be a stabilizer node to call this method"")
  {
    uint256 index = _getIndexOfObservation(count);
    // below peg
    pegObservations[index] = 0;

    count = count + 1;
    emit BelowPegObservation(amount);
  }

  function setNewStabilizerNode(address _node)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_node != address(0), ""Cannot set 0 address"");
    _swapRole(_node, address(stabilizerNode), STABILIZER_NODE_ROLE);
    stabilizerNode = IStabilizerNode(_node);
    emit SetStabilizerNode(_node);
  }

  function setNewAuction(address _auction)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_auction != address(0), ""Cannot set 0 address"");
    auction = IAuction(_auction);
    emit SetAuction(_auction);
  }

  function setAuctionAverageLookback(uint256 _lookback)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_lookback > 0, ""Cannot have zero lookback period"");

    if (_lookback > auctionAverageLookback) {
      for (uint i = auctionAverageLookback; i < _lookback; i++) {
        pegObservations.push(0);
      }
    }

    auctionAverageLookback = _lookback;
    emit SetAuctionAverageLookback(_lookback);
  }
}",1554
RealWorld_BA_59_IDistributor_RealWord_20240822091038.log,59,IDistributor,4271,4857,9128,76.0,0.118495,"pragma solidity >=0.6.6;

interface IDistributor {
  function vest() external;
  function totalDeclaredReward() external view returns (uint256);
  function decrementRewards(uint256 amount) external;
  function forfeit(uint256 amount) external;
  function declareReward(uint256 amount) external;
}",64
RealWorld_BA_59_UniswapHandler_RealWord_20240822084750.log,59,UniswapHandler,41161,5576,46737,106.0,0.317325,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';
import '@uniswap/lib/contracts/libraries/Babylonian.sol';
import '@uniswap/lib/contracts/libraries/FullMath.sol';

import ""../Permissions.sol"";
import ""../libraries/UniswapV2Library.sol"";


/// @title Uniswap Interaction Handler
/// @author 0xScotch <scotch@malt.money>
/// @notice A simple contract to make interacting with UniswapV2 pools easier.
/// @notice The buyMalt method is locked down to avoid circumventing recovery mode
/// @dev Makes use of UniswapV2Router02. Would be more efficient to go direct
contract UniswapHandler is Initializable, Permissions {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  bytes32 public constant BUYER_ROLE = keccak256(""BUYER_ROLE"");

  ERC20 public malt;
  ERC20 public rewardToken;
  ERC20 public lpToken;
  IUniswapV2Router02 public router;
  address public uniswapV2Factory;

  address[] public buyers;
  mapping(address => bool) public buyersActive;

  event AddMaltBuyer(address buyer);
  event RemoveMaltBuyer(address buyer);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _maltToken,
    address _rewardToken,
    address _lpToken,
    address _router,
    address _uniswapV2Factory
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);
    _setRoleAdmin(BUYER_ROLE, ADMIN_ROLE);

    malt = ERC20(_maltToken);
    rewardToken = ERC20(_rewardToken);
    router = IUniswapV2Router02(_router);

    lpToken = ERC20(_lpToken);
    uniswapV2Factory = _uniswapV2Factory;
  }

  /*
   * PUBLIC VIEW FUNCTIONS
   */
  function calculateMintingTradeSize(uint256 priceTarget) external view returns (uint256) {
    return _calculateTradeSize(address(malt), address(rewardToken), priceTarget);
  }

  function calculateBurningTradeSize(uint256 priceTarget) external view returns (uint256) {
    return _calculateTradeSize(address(rewardToken), address(malt), priceTarget);
  }

  function reserves() public view returns (uint256 maltSupply, uint256 rewardSupply) {
    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST
    (maltSupply, rewardSupply) = UniswapV2Library.getReserves(
      uniswapV2Factory,
      address(malt),
      address(rewardToken)
    );
  }

  function maltMarketPrice() public view returns (uint256 price, uint256 decimals) {
    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST
    (uint256 maltReserves, uint256 rewardReserves) = UniswapV2Library.getReserves(
      uniswapV2Factory,
      address(malt),
      address(rewardToken)
    );

    if (maltReserves == 0 || rewardReserves == 0) {
      price = 0;
      decimals = 18;
      return (price, decimals);
    }

    uint256 rewardDecimals = rewardToken.decimals();
    uint256 maltDecimals = malt.decimals();

    if (rewardDecimals > maltDecimals) {
      uint256 diff = rewardDecimals - maltDecimals;
      price = rewardReserves.mul(10**rewardDecimals).div(maltReserves.mul(10**diff));
      decimals = rewardDecimals;
    } else if (rewardDecimals < maltDecimals) {
      uint256 diff = maltDecimals - rewardDecimals;
      price = (rewardReserves.mul(10**diff)).mul(10**rewardDecimals).div(maltReserves);
      decimals = maltDecimals;
    } else {
      price = rewardReserves.mul(10**rewardDecimals).div(maltReserves);
      decimals = rewardDecimals;
    }
  }

  function getOptimalLiquidity(address tokenA, address tokenB, uint256 liquidityB)
    external view returns (uint256 liquidityA)
  {
    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST
    (uint256 reservesA, uint256 reservesB) = UniswapV2Library.getReserves(
      uniswapV2Factory,
      tokenA,
      tokenB
    );

    liquidityA = UniswapV2Library.quote(
      liquidityB,
      reservesB,
      reservesA
    );
  }

  /*
   * MUTATION FUNCTIONS
   */
  function buyMalt()
    external
    onlyRole(BUYER_ROLE, ""Must have buyer privs"")
    returns (uint256 purchased)
  {
    uint256 rewardBalance = rewardToken.balanceOf(address(this));

    if (rewardBalance == 0) {
      return 0;
    }

    rewardToken.approve(address(router), rewardBalance);

    address[] memory path = new address[](2);
    path[0] = address(rewardToken);
    path[1] = address(malt);

    router.swapExactTokensForTokens(
      rewardBalance,
      0, // amountOutMin
      path,
      address(this),
      now
    );

    purchased = malt.balanceOf(address(this));
    malt.safeTransfer(msg.sender, purchased);
  }

  function sellMalt() external returns (uint256 rewards) {
    uint256 maltBalance = malt.balanceOf(address(this));

    if (maltBalance == 0) {
      return 0;
    }

    malt.approve(address(router), maltBalance);

    address[] memory path = new address[](2);
    path[0] = address(malt);
    path[1] = address(rewardToken);

    router.swapExactTokensForTokens(
      maltBalance,
      0,
      path,
      address(this),
      now
    );

    rewards = rewardToken.balanceOf(address(this));
    rewardToken.safeTransfer(msg.sender, rewards);
  }

  function addLiquidity() external returns (
    uint256 maltUsed,
    uint256 rewardUsed,
    uint256 liquidityCreated
  ) {
    uint256 maltBalance = malt.balanceOf(address(this));
    uint256 rewardBalance = rewardToken.balanceOf(address(this));

    if (maltBalance == 0 || rewardBalance == 0) {
      return (0, 0, 0);
    }

    rewardToken.approve(address(router), rewardBalance);
    malt.approve(address(router), maltBalance);

    // TODO maybe make slippage tolerance here adjustable Fri 19 Nov 2021 16:45:57 GMT
    (maltUsed, rewardUsed, liquidityCreated) = router.addLiquidity(
      address(malt),
      address(rewardToken),
      maltBalance,
      rewardBalance,
      maltBalance.mul(95).div(100),
      rewardBalance.mul(95).div(100),
      msg.sender, // transfer LP tokens to sender
      now
    );

    if (maltUsed < maltBalance) {
      malt.safeTransfer(msg.sender, maltBalance.sub(maltUsed));
    }

    if (rewardUsed < rewardBalance) {
      rewardToken.safeTransfer(msg.sender, rewardBalance.sub(rewardUsed));
    }
  }

  function removeLiquidity() external returns (uint256 amountMalt, uint256 amountReward) {
    uint256 liquidityBalance = lpToken.balanceOf(address(this));

    if (liquidityBalance == 0) {
      return (0, 0);
    }

    lpToken.approve(address(router), liquidityBalance);

    (amountMalt, amountReward) = router.removeLiquidity(
      address(malt),
      address(rewardToken),
      liquidityBalance,
      0,
      0,
      msg.sender, // transfer broken LP tokens to sender
      now
    );

    if (amountMalt == 0 || amountReward == 0) {
      liquidityBalance = lpToken.balanceOf(address(this));
      lpToken.safeTransfer(msg.sender, liquidityBalance);
      return (amountMalt, amountReward);
    }
  }

  /*
   * PRIVATE METHODS
   */
  function _calculateTradeSize(address sellToken, address buyToken, uint256 priceTarget) private view returns (uint256) {
    // TODO use data lab average Tue 05 Oct 2021 20:40:23 BST
    (uint256 sellReserves, uint256 buyReserves) = UniswapV2Library.getReserves(
      uniswapV2Factory,
      sellToken,
      buyToken
    );

    uint256 invariant = sellReserves.mul(buyReserves);

    uint256 buyBase = 10**uint256(ERC20(buyToken).decimals());

    uint256 leftSide = Babylonian.sqrt(
      FullMath.mulDiv(
        invariant.mul(1000),
        priceTarget,
        buyBase.div(priceTarget).mul(buyBase).mul(997)
      )
    );

    uint256 rightSide = sellReserves.mul(1000).div(997);

    if (leftSide < rightSide) return 0;

    return leftSide.sub(rightSide);
  }

  /*
   * PRIVILEDGED METHODS
   */
  function addNewBuyer(address _buyer)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
    notSameBlock
  {
    require(_buyer != address(0), ""Cannot use address 0"");

    if (buyersActive[_buyer]) {
      return;
    }

    buyersActive[_buyer] = true;
    buyers.push(_buyer);

    _setupRole(BUYER_ROLE, _buyer);

    emit AddMaltBuyer(_buyer);
  }

  function removeBuyer(address _buyer)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
    notSameBlock
  {
    if (buyers.length == 0 || !buyersActive[_buyer]) {
      return;
    }

    address buyer;
    buyersActive[_buyer] = false;

    emit RemoveMaltBuyer(_buyer);
    revokeRole(BUYER_ROLE, _buyer);

    // Loop until the second last element
    for (uint i = 0; i < buyers.length - 1; i = i + 1) {
      if (buyers[i] == _buyer) {
        // Replace the current item with the last and pop the last away.
        buyers[i] = buyers[buyers.length - 1];
        buyers.pop();
        return;
      }
    }

    // If we made it here then the buyers being removed is the last item
    buyers.pop();
  }

  // TODO ensure this contract is whitelisted for under peg transfers Mon 06 Sep 2021 23:49:31 BST
}",2420
RealWorld_BA_59_IDAO_RealWord_20240822090450.log,59,IDAO,4901,4200,9101,72.0,0.108505,"pragma solidity >=0.6.6;

interface IDAO {
  function epoch() external view returns (uint256);
  function epochLength() external view returns (uint256);
  function genesisTime() external view returns (uint256);
  function getEpochStartTime(uint256 _epoch) external view returns (uint256);
  function getLockedMalt(address account) external view returns (uint256);
  function epochsPerYear() external view returns (uint256);
}",95
RealWorld_BA_59_IStabilizerNode_RealWord_20240822085840.log,59,IStabilizerNode,3785,4419,8204,75.0,0.107305,"pragma solidity >=0.6.6;

import ""./IAuction.sol"";

interface IStabilizerNode {
  function stabilize() external;
  function auction() external view returns (IAuction);
}",40
RealWorld_BA_59_Faucet_RealWord_20240822083656.log,59,Faucet,5573,5132,10705,71.0,0.130505,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""./interfaces/IBurnMintableERC20.sol"";


contract TestFaucet is Initializable {
  using SafeMath for uint256;

  IBurnMintableERC20 public token;

  function initialize(address _token) external initializer {
    token = IBurnMintableERC20(_token);
  }
  
  function faucet() external {
    uint256 decimals = token.decimals();
    token.mint(msg.sender, 10000*10**decimals);
  }
}",153
RealWorld_BA_59_ITransferVerification_RealWord_20240822085733.log,59,ITransferVerification,3509,4231,7740,65.0,0.102165,"pragma solidity >=0.6.6;

interface ITransferVerification {
  function verifyTransfer(address, address, uint256) external view returns (bool, string memory);
}",35
RealWorld_BA_59_IMaltDataLab_RealWord_20240822090604.log,59,IMaltDataLab,5920,5778,11698,86.0,0.14516,"pragma solidity >=0.6.6;

interface IMaltDataLab {
  function priceTarget() external view returns (uint256);
  function smoothedReserveRatio() external view returns (uint256);
  function smoothedMaltPrice() external view returns (uint256);
  function smoothedMaltInPool() external view returns (uint256);
  function reserveRatioAverage(uint256 _lookback) external view returns (uint256);
  function maltPriceAverage(uint256 _lookback) external view returns (uint256);
  function maltInPoolAverage(uint256 _lookback) external view returns (uint256);
  function realValueOfLPToken(uint256 amount) external view returns (uint256);
  function trackReserveRatio() external;
  function trackPool() external;
}",161
RealWorld_BA_59_IImpliedCollateralService_RealWord_20240822085213.log,59,IImpliedCollateralService,4277,4916,9193,80.0,0.119705,"pragma solidity >=0.6.6;

interface IImpliedCollateralService {
  function handleDeficit(uint256 maxAmount) external;
  function claim() external;
  function getCollateralValueInMalt() external view returns(uint256);
}",52
RealWorld_BA_60_UReentrancyGuard_RealWord_20240822093955.log,60,UReentrancyGuard,16568,4926,21494,81.0,0.18136,"// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 *
 * NOTE: This contract has been extended from the Open Zeppelin library to include an
 *       unstructured storage pattern, so that it can be safely mixed in with upgradeable
 *       contracts without affecting their storage patterns through inheritance.
 */
abstract contract UReentrancyGuard {
    error UReentrancyGuardReentrantCallError();

    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    /**
     * @dev unstructured storage slot for the reentrancy status
     */
    bytes32 private constant STATUS_SLOT = keccak256(""equilibria.utils.UReentrancyGuard.status"");

    /**
     * @dev Initializes the contract setting the status to _NOT_ENTERED.
     */
    function UReentrancyGuard__initialize() internal {
        _setStatus(_NOT_ENTERED);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function _status() private view returns (uint256 result) {
        bytes32 slot = STATUS_SLOT;
        assembly {
            result := sload(slot)
        }
    }

    function _setStatus(uint256 newStatus) private {
        bytes32 slot = STATUS_SLOT;
        assembly {
            sstore(slot, newStatus)
        }
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        if (_status() == _ENTERED) revert UReentrancyGuardReentrantCallError();

        // Any calls to nonReentrant after this point will fail
        _setStatus(_ENTERED);

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _setStatus(_NOT_ENTERED);
    }
}",831
RealWorld_BA_60_Token18_RealWord_20240822093420.log,60,Token18,25617,5467,31084,76.0,0.237425,"// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""./UFixed18.sol"";

/// @dev Token18
type Token18 is address;

/**
 * @title Token18Lib
 * @notice Library to manager Ether and ERC20s that is compliant with the fixed-decimal types.
 * @dev Normalizes token operations with Ether operations (using a magic Ether address).
 */
library Token18Lib {
    using UFixed18Lib for UFixed18;
    using Address for address;
    using SafeERC20 for IERC20;

    error Token18PullEtherError();

    Token18 public constant ETHER = Token18.wrap(address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE));

    /**
     * @notice Returns whether a token is the Ether address
     * @param self Token to check for
     * @return Whether the token is Ether
     */
    function isEther(Token18 self) internal pure returns (bool) {
        return Token18.unwrap(self) == Token18.unwrap(ETHER);
    }

    /**
     * @notice Transfers all held tokens from the caller to the `recipient`
     * @param self Token to transfer
     * @param recipient Address to receive the tokens
     */
    function push(Token18 self, address recipient) internal {
        push(self, recipient, balanceOf(self, address(this)));
    }

    /**
     * @notice Transfers `amount` tokens from the caller to the `recipient`
     * @param self Token to transfer
     * @param recipient Address to transfer tokens to
     * @param amount Amount of tokens to transfer
     */
    function push(
        Token18 self,
        address recipient,
        UFixed18 amount
    ) internal {
        isEther(self)
            ? Address.sendValue(payable(recipient), toTokenAmount(self, amount))
            : IERC20(Token18.unwrap(self)).safeTransfer(recipient, toTokenAmount(self, amount));
    }

    /**
     * @notice Transfers `amount` tokens from the `benefactor` to the caller
     * @dev Reverts if trying to pull Ether
     * @param self Token to transfer
     * @param benefactor Address to transfer tokens from
     * @param amount Amount of tokens to transfer
     */
    function pull(
        Token18 self,
        address benefactor,
        UFixed18 amount
    ) internal {
        if (isEther(self)) revert Token18PullEtherError();
        IERC20(Token18.unwrap(self)).safeTransferFrom(benefactor, address(this), toTokenAmount(self, amount));
    }

    /**
     * @notice Transfers `amount` tokens from the `benefactor` to `recipient`
     * @dev Reverts if trying to pull Ether
     * @param self Token to transfer
     * @param benefactor Address to transfer tokens from
     * @param recipient Address to transfer tokens to
     * @param amount Amount of tokens to transfer
     */
    function pullTo(
        Token18 self,
        address benefactor,
        address recipient,
        UFixed18 amount
    ) internal {
        if (isEther(self)) revert Token18PullEtherError();
        IERC20(Token18.unwrap(self)).safeTransferFrom(benefactor, recipient, toTokenAmount(self, amount));
    }

    /**
     * @notice Returns the name of the token
     * @param self Token to check for
     * @return Token name
     */
    function name(Token18 self) internal view returns (string memory) {
        return isEther(self) ? ""Ether"" : IERC20Metadata(Token18.unwrap(self)).name();
    }

    /**
     * @notice Returns the symbol of the token
     * @param self Token to check for
     * @return Token symbol
     */
    function symbol(Token18 self) internal view returns (string memory) {
        return isEther(self) ? ""ETH"" : IERC20Metadata(Token18.unwrap(self)).symbol();
    }

    /**
     * @notice Returns the decimals of the token
     * @param self Token to check for
     * @return Token decimals
     */
    function decimals(Token18 self) internal view returns (uint8) {
        return isEther(self) ? 18 : IERC20Metadata(Token18.unwrap(self)).decimals();
    }

    /**
     * @notice Returns the `self` token balance of the caller
     * @param self Token to check for
     * @return Token balance of the caller
     */
    function balanceOf(Token18 self) internal view returns (UFixed18) {
        return balanceOf(self, address(this));
    }

    /**
     * @notice Returns the `self` token balance of `account`
     * @param self Token to check for
     * @param account Account to check
     * @return Token balance of the account
     */
    function balanceOf(Token18 self, address account) internal view returns (UFixed18) {
        uint256 tokenAmount = isEther(self) ?
            account.balance :
            IERC20(Token18.unwrap(self)).balanceOf(account);
        return fromTokenAmount(self, tokenAmount);
    }

    /**
     * @notice Converts the unsigned fixed-decimal amount into the token amount according to
     *         it's defined decimals
     * @param self Token to check for
     * @param amount Amount to convert
     * @return Normalized token amount
     */
    function toTokenAmount(Token18 self, UFixed18 amount) private view returns (uint256) {
        UFixed18 conversion = UFixed18Lib.ratio(10 ** uint256(decimals(self)), 10 ** 18);
        return UFixed18.unwrap(amount.mul(conversion));
    }

    /**
     * @notice Converts the token amount into the unsigned fixed-decimal amount according to
     *         it's defined decimals
     * @param self Token to check for
     * @param amount Token amount to convert
     * @return Normalized unsigned fixed-decimal amount
     */
    function fromTokenAmount(Token18 self, uint256 amount) private view returns (UFixed18) {
        UFixed18 conversion = UFixed18Lib.ratio(10 ** 18, 10 ** uint256(decimals(self)));
        return UFixed18.wrap(amount).mul(conversion);
    }
}",1405
RealWorld_BA_60_IIncentivizer_RealWord_20240822101556.log,60,IIncentivizer,13455,6127,19582,96.0,0.189815,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.10;

import ""../interfaces/IFactory.sol"";
import ""../interfaces/IProduct.sol"";
import ""../product/types/position/Position.sol"";
import ""../utils/types/Token18.sol"";
import ""../utils/types/UFixed18.sol"";
import ""../utils/types/Fixed18.sol"";
import ""../incentivizer/types/ProgramInfo.sol"";

interface IIncentivizer {
    event ProgramsPerProductUpdated(uint256 newProgramsPerProduct);
    event FeeUpdated(UFixed18 newFee);
    event ProgramCompleted(uint256 indexed programId, uint256 versionComplete);
    event ProgramClosed(uint256 indexed programId, UFixed18 amount);
    event ProgramCreated(uint256 indexed programId, IProduct product, Token18 token, UFixed18 amountMaker, UFixed18 amountTaker, uint256 start, uint256 duration, uint256 grace, UFixed18 fee);
    event Claim(address indexed account, uint256 indexed programId, UFixed18 amount);
    event FeeClaim(Token18 indexed token, UFixed18 amount);

    error IncentivizerProgramNotClosableError();
    error IncentivizerTooManyProgramsError();
    error IncentivizerNotProgramOwnerError(address sender, uint256 programId);
    error IncentivizerInvalidProgramError(uint256 programId);

    function programsPerProduct() external view returns (uint256);
    function fee() external view returns (UFixed18);
    function programInfos(uint256 programId) external view returns (ProgramInfo memory);
    function fees(Token18 token) external view returns (UFixed18);
    function initialize(IFactory factory_) external;
    function create(ProgramInfo calldata info) external returns (uint256);
    function end(uint256 programId) external;
    function close(uint256 programId) external;
    function sync() external;
    function syncAccount(address account) external;
    function claim(IProduct product) external;
    function claim(uint256 programId) external;
    function claimFee(Token18[] calldata tokens) external;
    function unclaimed(address account, uint256 programId) external view returns (UFixed18);
    function latestVersion(address account, uint256 programId) external view returns (uint256);
    function settled(address account, uint256 programId) external view returns (UFixed18);
    function available(uint256 programId) external view returns (UFixed18);
    function versionComplete(uint256 programId) external view returns (uint256);
    function closed(uint256 programId) external view returns (bool);
    function programsForLength(IProduct product) external view returns (uint256);
    function programsForAt(IProduct product, uint256 index) external view returns (uint256);
    function owner(uint256 programId) external view returns (address);
    function treasury(uint256 programId) external view returns (address);
    function updateProgramsPerProduct(uint256 newProgramsPerProduct) external;
    function updateFee(UFixed18 newFee) external;
}",628
RealWorld_BA_60_ProductProviderBase_RealWord_20240822094238.log,60,ProductProviderBase,9800,5440,15240,76.0,0.1578,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.10;

import ""../interfaces/IProductProvider.sol"";
import ""../interfaces/IOracle.sol"";

/**
 * @title ProductProviderBase
 * @notice Abstract contract that implements the oracle and payoff function portion of the product provider.
 * @dev Should be extended when implemented a new product.
 */
abstract contract ProductProviderBase is IProductProvider {
    IOracle public oracle;

    /**
     * @notice Initializes the contract state
     * @param oracle_ Oracle price provider contract address
     */
    constructor(IOracle oracle_) {
        oracle = oracle_;
    }

    /**
     * @notice Returns the payoff function given a raw oracle price
     * @param price Raw oracle price
     * @return Payoff value
     */
    function payoff(Fixed18 price) public view virtual override returns (Fixed18);

    /**
     * @notice Pass-through hook to call sync() on the oracle provider
     */
    function sync() external override {
        return oracle.sync();
    }

    /**
     * @notice Returns the payoff value at oracle version `version`
     * @param version Oracle version to return for
     * @return Payoff value at oracle version
     */
    function priceAtVersion(uint256 version) external override view returns (Fixed18) {
        return payoff(oracle.priceAtVersion(version));
    }

    /**
     * @notice Returns the timestamp at oracle version `version`
     * @param version Oracle version to return for
     * @return Timestamp at oracle version
     */
    function timestampAtVersion(uint256 version) external override view returns (uint256) {
        return oracle.timestampAtVersion(version);
    }

    /**
     * @notice Returns the current oracle version
     * @return Current oracle version
     */
    function currentVersion() external override view returns (uint256) {
        return oracle.currentVersion();
    }
}",395
RealWorld_BA_60_ShortEther_RealWord_20240822095635.log,60,ShortEther,8758,5020,13778,69.0,0.14419,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.10;

import ""../product/ProductProviderBase.sol"";

contract ShortEther is ProductProviderBase {
    using UFixed18Lib for UFixed18;
    using Fixed18Lib for Fixed18;

    constructor(IOracle oracle) ProductProviderBase(oracle) { }

    // Implementation

    function rate(Position memory position) external pure override returns (Fixed18) {
        if (position.maker.isZero()) return Fixed18Lib.ZERO;

        UFixed18 utilization = position.taker.div(position.maker);
        UFixed18 capped = UFixed18Lib.min(utilization, UFixed18Lib.ONE);
        Fixed18 centered = (Fixed18Lib.from(capped).sub(Fixed18Lib.ratio(1, 2))).mul(Fixed18Lib.from(2));

        return centered.div(Fixed18Lib.from(365 days));
    }

    function payoff(Fixed18 price) public pure override returns (Fixed18) {
        return Fixed18Lib.from(-1).mul(price);
    }

    function maintenance() external pure override returns (UFixed18) {
        return UFixed18Lib.ratio(30, 100);
    }

    function fundingFee() external pure override returns (UFixed18) {
        return UFixed18Lib.ratio(10, 100);
    }

    function makerFee() external pure override returns (UFixed18) {
        return UFixed18Lib.ZERO;
    }

    function takerFee() external pure override returns (UFixed18) {
        return UFixed18Lib.ZERO;
    }

    function makerLimit() external pure override returns (UFixed18) {
        return UFixed18Lib.from(1000);
    }
}",361
RealWorld_BA_60_MockUReentrancyGuard_RealWord_20240822093028.log,60,MockUReentrancyGuard,6344,5036,11380,75.0,0.13244,"// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import ""../unstructured/UReentrancyGuard.sol"";

contract MockUReentrancyGuard is UReentrancyGuard {
    bytes32 private constant STATUS_SLOT = keccak256(""equilibria.utils.UReentrancyGuard.status"");

    event NoOp();

    function __initialize() external {
        super.UReentrancyGuard__initialize();
    }

    function __status() external view returns (uint256 result) {
        bytes32 slot = STATUS_SLOT;
        assembly {
            result := sload(slot)
        }
    }

    function noReenter() nonReentrant public { emit NoOp(); }
    function reenterRecursive() nonReentrant public { reenterRecursive(); }
    function reenterDifferent() nonReentrant public { noReenter(); }
}",177
RealWorld_BA_60_Accumulator_RealWord_20240822095359.log,60,Accumulator,12222,5276,17498,72.0,0.16663,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""../../../utils/types/Fixed18.sol"";

/// @dev Accumulator type
struct Accumulator {
    /// @dev maker accumulator per share
    Fixed18 maker;
    /// @dev taker accumulator per share
    Fixed18 taker;
}

/**
 * @title AccountAccumulatorLib
 * @notice Library that surfaces math operations for the Accumulator type.
 * @dev Accumulators track the cumulative change in position value over time for the maker and taker positions
 *      respectively. Account-level accumulators can then use two of these values `a` and `a'` to compute the
 *      change in position value since last sync. This change in value is then used to compute P&L and fees.
 */
library AccumulatorLib {
    using Fixed18Lib for Fixed18;

    /**
     * @notice Adds two accumulators together
     * @param a The first accumulator to sum
     * @param b The second accumulator to sum
     * @return The resulting summed accumulator
     */
    function add(Accumulator memory a, Accumulator memory b) internal pure returns (Accumulator memory) {
        return Accumulator({maker: a.maker.add(b.maker), taker: a.taker.add(b.taker)});
    }

    /**
     * @notice Subtracts accumulator `b` from `a`
     * @param a The accumulator to subtract from
     * @param b The accumulator to subtract
     * @return The resulting subtracted accumulator
     */
    function sub(Accumulator memory a, Accumulator memory b) internal pure returns (Accumulator memory) {
        return Accumulator({maker: a.maker.sub(b.maker), taker: a.taker.sub(b.taker)});
    }

    /**
     * @notice Multiplies two accumulators together
     * @param a The first accumulator to multiply
     * @param b The second accumulator to multiply
     * @return The resulting multiplied accumulator
     */
    function mul(Accumulator memory a, Accumulator memory b) internal pure returns (Accumulator memory) {
        return Accumulator({maker: a.maker.mul(b.maker), taker: a.taker.mul(b.taker)});
    }

    /**
     * @notice Sums the maker and taker together from a single accumulator
     * @param self The struct to operate on
     * @return The sum of its maker and taker
     */
    function sum(Accumulator memory self) internal pure returns (Fixed18) {
        return self.maker.add(self.taker);
    }
}",560
RealWorld_BA_60_LeveragedEther_RealWord_20240822095514.log,60,LeveragedEther,9139,5383,14522,78.0,0.153355,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.10;

import ""../product/ProductProviderBase.sol"";

contract LeveragedEther is ProductProviderBase {
    using UFixed18Lib for UFixed18;
    using Fixed18Lib for Fixed18;

    constructor(IOracle oracle) ProductProviderBase(oracle) { }

    // Implementation

    function rate(Position memory position) external pure override returns (Fixed18) {
        if (position.maker.isZero()) return Fixed18Lib.ZERO;

        UFixed18 utilization = position.taker.div(position.maker);
        UFixed18 capped = UFixed18Lib.min(utilization, UFixed18Lib.ONE);
        Fixed18 centered = (Fixed18Lib.from(capped).sub(Fixed18Lib.ratio(1, 2))).mul(Fixed18Lib.from(2));

        return centered.div(Fixed18Lib.from(365 days));
    }

    function payoff(Fixed18 price) public pure override returns (Fixed18) {
        return Fixed18Lib.from(3).mul(price);
    }

    function maintenance() external pure override returns (UFixed18) {
        return UFixed18Lib.ratio(100, 100);
    }

    function fundingFee() external pure override returns (UFixed18) {
        return UFixed18Lib.ratio(10, 100);
    }

    function makerFee() external pure override returns (UFixed18) {
        return UFixed18Lib.ratio(1, 10000);
    }

    function takerFee() external pure override returns (UFixed18) {
        return UFixed18Lib.ratio(1, 10000);
    }

    function makerLimit() external pure override returns (UFixed18) {
        return UFixed18Lib.from(1000);
    }
}",376
RealWorld_BA_60_PrePosition_RealWord_20240822094544.log,60,PrePosition,31983,6340,38323,90.0,0.286715,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""./Position.sol"";
import ""../ProductProvider.sol"";

/// @dev PrePosition type
struct PrePosition {
    /// @dev Oracle version at which the new position delta was recorded
    uint256 oracleVersion;

    /// @dev Size of position to open at oracle version
    Position openPosition;

    /// @dev Size of position to close at oracle version
    Position closePosition;
}

/**
 * @title PrePositionLib
 * @notice Library that manages a pre-settlement position delta.
 * @dev PrePositions track the currently awaiting-settlement deltas to a settled Position. These are
 *      Primarily necessary to introduce lag into the settlement system such that oracle lag cannot be
 *      gamed to a user's advantage. When a user opens or closes a new position, it sits as a PrePosition
 *      for one oracle version until it's settle into the Position, making it then effective. PrePositions
 *      are automatically settled at the correct oracle version even if a flywheel call doesn't happen until
 *      several version into the future by using the historical version lookups in the corresponding ""Versioned""
 *      global state types.
 */
library PrePositionLib {
    using UFixed18Lib for UFixed18;
    using Fixed18Lib for Fixed18;
    using PositionLib for Position;
    using ProductProviderLib for IProductProvider;

    /**
     * @notice Returns whether there is no pending-settlement position delta
     * @dev Can be ""empty"" even with a non-zero oracleVersion if a position is opened and
     *      closed in the same version netting out to a zero position delta
     * @param self The struct to operate on
     * @return Whether the pending-settlement position delta is empty
     */
    function isEmpty(PrePosition memory self) internal pure returns (bool) {
        return self.openPosition.isEmpty() && self.closePosition.isEmpty();
    }

    /**
     * @notice Increments the maker side of the open position delta
     * @dev Nets out open and close deltas to minimize the size of each
     * @param self The struct to operate on
     * @param oracle The price oracle provider
     * @param amount The position amount to open
     */
    function openMake(PrePosition storage self, IOracle oracle, UFixed18 amount) internal {
        self.openPosition.maker = self.openPosition.maker.add(amount);
        self.oracleVersion = oracle.currentVersion();
        netMake(self);
    }

    /**
     * @notice Increments the maker side of the close position delta
     * @dev Nets out open and close deltas to minimize the size of each
     * @param self The struct to operate on
     * @param oracle The price oracle provider
     * @param amount The maker position amount to close
     */
    function closeMake(PrePosition storage self, IOracle oracle, UFixed18 amount) internal {
        self.closePosition.maker = self.closePosition.maker.add(amount);
        self.oracleVersion = oracle.currentVersion();
        netMake(self);
    }

    /**
     * @notice Increments the taker side of the open position delta
     * @dev Nets out open and close deltas to minimize the size of each
     * @param self The struct to operate on
     * @param oracle The price oracle provider
     * @param amount The taker position amount to open
     */
    function openTake(PrePosition storage self, IOracle oracle, UFixed18 amount) internal {
        self.openPosition.taker = self.openPosition.taker.add(amount);
        self.oracleVersion = oracle.currentVersion();
        netTake(self);
    }

    /**
     * @notice Increments the taker side of the close position delta
     * @dev Nets out open and close deltas to minimize the size of each
     * @param self The struct to operate on
     * @param oracle The price oracle provider
     * @param amount The taker position amount to close
     */
    function closeTake(PrePosition storage self, IOracle oracle, UFixed18 amount) internal {
        self.closePosition.taker = self.closePosition.taker.add(amount);
        self.oracleVersion = oracle.currentVersion();
        netTake(self);
    }

    /**
     * @notice Nets out the open and close on the maker side of the position delta
     * @param self The struct to operate on
     */
    function netMake(PrePosition storage self) private {
        if (self.openPosition.maker.gt(self.closePosition.maker)) {
            self.openPosition.maker = self.openPosition.maker.sub(self.closePosition.maker);
            self.closePosition.maker = UFixed18Lib.ZERO;
        } else {
            self.closePosition.maker = self.closePosition.maker.sub(self.openPosition.maker);
            self.openPosition.maker = UFixed18Lib.ZERO;
        }
    }

    /**
     * @notice Nets out the open and close on the taker side of the position delta
     * @param self The struct to operate on
     */
    function netTake(PrePosition storage self) private {
        if (self.openPosition.taker.gt(self.closePosition.taker)) {
            self.openPosition.taker = self.openPosition.taker.sub(self.closePosition.taker);
            self.closePosition.taker = UFixed18Lib.ZERO;
        } else {
            self.closePosition.taker = self.closePosition.taker.sub(self.openPosition.taker);
            self.openPosition.taker = UFixed18Lib.ZERO;
        }
    }

    /**
     * @notice Returns whether the the pending position delta can be settled at version `toOracleVersion`
     * @dev Pending-settlement positions deltas can be settled (1) oracle version after they are recorded
     * @param self The struct to operate on
     * @param toOracleVersion The potential oracle version to settle
     * @return Whether the position delta can be settled
     */
    function canSettle(PrePosition memory self, uint256 toOracleVersion) internal pure returns (bool) {
        return !isEmpty(self) && toOracleVersion > self.oracleVersion;
    }

    /**
     * @notice Computes the fee incurred for opening or closing the pending-settlement position
     * @param self The struct to operate on
     * @param provider The parameter provider of the product
     * @param toOracleVersion The oracle version at which settlement takes place
     * @return positionFee The maker / taker fee incurred
     */
    function computeFee(PrePosition memory self, IProductProvider provider, uint256 toOracleVersion) internal view returns (UFixed18 positionFee) {
        Fixed18 oraclePrice = provider.priceAtVersion(toOracleVersion);
        Position memory positionDelta = self.openPosition.add(self.closePosition);

        (UFixed18 makerNotional, UFixed18 takerNotional) = (
            Fixed18Lib.from(positionDelta.maker).mul(oraclePrice).abs(),
            Fixed18Lib.from(positionDelta.taker).mul(oraclePrice).abs()
        );

        positionFee = positionFee.add(makerNotional.mul(provider.safeMakerFee()));
        positionFee = positionFee.add(takerNotional.mul(provider.safeTakerFee()));
    }

    /**
     * @notice Computes the next oracle version to settle
     * @dev - If there is no pending-settlement position delta, returns the current oracle version
     *      - If the pending-settlement position delta is not yet ready to be settled, returns the current oracle version
     *      - Otherwise returns the oracle version at which the pending-settlement position delta can be first settled
     *
     *      Corresponds to point (b) in the Position settlement flow
     * @param self The struct to operate on
     * @param oracle The price oracle provider
     * @return Next oracle version to settle
     */
    function oracleVersionToSettle(PrePosition storage self, IOracle oracle) internal view returns (uint256) {
        uint256 current = oracle.currentVersion();
        uint256 next = self.oracleVersion + 1;

        if (next == 1) return current;      // no pre position
        if (next > current) return current; // pre in future
        return next;                        // settle pre
    }
}",1747
RealWorld_BA_60_Factory_RealWord_20240822100612.log,60,Factory,36470,5293,41763,79.0,0.28821,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""@openzeppelin/contracts/proxy/Clones.sol"";
import ""../interfaces/IFactory.sol"";
import ""../interfaces/ICollateral.sol"";
import ""../interfaces/IIncentivizer.sol"";
import ""../interfaces/IProduct.sol"";

/**
 * @title Factory
 * @notice Manages creating new products and global protocol parameters.
 */
contract Factory is IFactory {

    /// @dev Whether the factory has been initialized
    bool public initialized;

    /// @dev Secondary pauser address (not owner, but has permission to update isPaused)
    address public pauser;

    /// @dev Whether the protocol is currently paused
    bool public isPaused;

    /// @dev Collateral contract address for the protocol
    ICollateral public collateral;

    /// @dev Incentivizer contract address for the protocol
    IIncentivizer public incentivizer;

    /// @dev Base Product implementation contract address for the protocol
    IProduct public productBase;

    /// @dev List of product controllers
    Controller[] private _controllers;

    /// @dev Mapping of the controller for each  product
    mapping(IProduct => uint256) public controllerFor;

    /// @dev Whether a specific controller is allowed to create a new product
    mapping(uint256 => bool) public allowed;

    /// @dev Percent of the fee that goes to the protocol treasury vs the product treasury
    UFixed18 public fee;

    /// @dev Minimum allowable funding fee for a product
    UFixed18 public minFundingFee;

    /// @dev Minimum allowable collateral amount per user account
    UFixed18 public minCollateral;

    /**
     * @notice Initializes the contract state
     * @param collateral_ Collateral contract address
     * @param incentivizer_ Incentivizer contract address
     * @param productBase_ Base Product implementation contract address
     * @param treasury_ Protocol treasury address
     */
    function initialize(
        ICollateral collateral_,
        IIncentivizer incentivizer_,
        IProduct productBase_,
        address treasury_
    ) external {
        if (initialized) revert FactoryAlreadyInitializedError();

        createController(treasury_);

        updatePauser(msg.sender);
        updateCollateral(collateral_);
        updateIncentivizer(incentivizer_);
        updateProductBase(productBase_);
        updateFee(UFixed18Lib.ratio(50, 100));
        updateMinFundingFee(UFixed18Lib.ratio(10, 100));

        initialized = true;
    }

    /**
     * @notice Creates a new controller with `msg.sender` as the owner
     * @param controllerTreasury Treasury address for the controller
     * @return New controller ID
     */
    function createController(address controllerTreasury) public returns (uint256) {
        uint256 controllerId = _controllers.length;

        _controllers.push(Controller({
            owner: msg.sender,
            treasury: controllerTreasury
        }));

        emit ControllerCreated(controllerId, msg.sender, controllerTreasury);

        return controllerId;
    }

    /**
     * @notice Updates the owner and treasury of an existing controller
     * @dev Must be called by the controller's current owner
     * @param controllerId Controller to update
     * @param newController New controller owner and treasury
     */
    function updateController(uint256 controllerId, Controller memory newController) onlyOwner(controllerId) external {
        _controllers[controllerId] = newController;
        emit ControllerUpdated(controllerId, newController.owner, newController.treasury);
    }

    /**
     * @notice Creates a new product market with `provider`
     * @dev Controller caller must be allowed
     * @param controllerId Controller that will own the product
     * @param provider Provider that will service the market
     * @return New product contract address
     */
    function createProduct(uint256 controllerId, IProductProvider provider) onlyOwner(controllerId) external returns (IProduct) {
        if (controllerId == 0) revert FactoryNoZeroControllerError();
        if (!allowed[0] && !allowed[controllerId]) revert FactoryNotAllowedError();

        IProduct newProduct = IProduct(Clones.clone(address(productBase)));
        newProduct.initialize(provider);
        controllerFor[newProduct] = controllerId;
        emit ProductCreated(newProduct, provider);

        return newProduct;
    }

    /**
     * @notice Updates the Collateral contract address
     * @param newCollateral New Collateral contract address
     */
    function updateCollateral(ICollateral newCollateral) onlyOwner(0) public {
        collateral = newCollateral;
        emit CollateralUpdated(newCollateral);
    }

    /**
     * @notice Updates the Incentivizer contract address
     * @param newIncentivizer New Incentivizer contract address
     */
    function updateIncentivizer(IIncentivizer newIncentivizer) onlyOwner(0) public {
        incentivizer = newIncentivizer;
        emit IncentivizerUpdated(newIncentivizer);
    }

    /**
     * @notice Updates the base Product contract address
     * @param newProductBase New base Product contract address
     */
    function updateProductBase(IProduct newProductBase) onlyOwner(0) public {
        productBase = newProductBase;
        emit ProductBaseUpdated(newProductBase);
    }

    /**
     * @notice Updates the protocol-product fee split
     * @param newFee New protocol-product fee split
     */
    function updateFee(UFixed18 newFee) onlyOwner(0) public {
        fee = newFee;
        emit FeeUpdated(newFee);
    }

    /**
     * @notice Updates the minimum allowed funding fee
     * @param newMinFundingFee New minimum allowed funding fee
     */
    function updateMinFundingFee(UFixed18 newMinFundingFee) onlyOwner(0) public {
        minFundingFee = newMinFundingFee;
        emit MinFundingFeeUpdated(newMinFundingFee);
    }

    /**
     * @notice Updates the minimum allowed collateral amount per user account
     * @param newMinCollateral New minimum allowed collateral amount
     */
    function updateMinCollateral(UFixed18 newMinCollateral) onlyOwner(0) public {
        minCollateral = newMinCollateral;
        emit MinCollateralUpdated(newMinCollateral);
    }

    /**
     * @notice Updates the secondary pauser address
     * @param newPauser New secondary pauser address
     */
    function updatePauser(address newPauser) onlyOwner(0) public {
        pauser = newPauser;
        emit PauserUpdated(newPauser);
    }

    /**
     * @notice Updates the protocol pause status
     * @param newIsPaused New protocol pause status
     */
    function updateIsPaused(bool newIsPaused) public {
        if (msg.sender != owner() && msg.sender != pauser) revert FactoryNotPauserError(msg.sender);

        isPaused = newIsPaused;
        emit IsPausedUpdated(newIsPaused);
    }

    /**
     * @notice Updates whether `controllerId` is allowed to create new products
     * @param controllerId Controller to update
     * @param newAllowed New allowed status for `controllerId`
     */
    function updateAllowed(uint256 controllerId, bool newAllowed) onlyOwner(0) external {
        allowed[controllerId] = newAllowed;
        emit AllowedUpdated(controllerId, newAllowed);
    }

    /**
     * @notice Returns whether a contract is a product
     * @param product Contract address to check
     * @return Whether a contract is a product
     */
    function isProduct(IProduct product) public view returns (bool) {
        return controllerFor[product] != 0;
    }

    /**
     * @notice Returns controller state for controller `controllerId`
     * @param controllerId Controller to return for
     * @return Controller state
     */
    function controllers(uint256 controllerId) external view returns (Controller memory) {
        return _controllers[controllerId];
    }

    /**
     * @notice Returns the owner of the protocol
     * @return Owner of the protocol
     */
    function owner() public view returns (address) {
        return owner(0);
    }

    /**
     * @notice Returns the owner of the controller `controllerId`
     * @param controllerId Controller to return for
     * @return Owner of the controller
     */
    function owner(uint256 controllerId) public view returns (address) {
        return _controllers[controllerId].owner;
    }

    /**
     * @notice Returns the owner of the product `product`
     * @param product Product to return for
     * @return Owner of the product
     */
    function owner(IProduct product) public view returns (address) {
        return owner(controllerFor[product]);
    }

    /**
     * @notice Returns the treasury of the protocol
     * @return Treasury of the protocol
     */
    function treasury() public view returns (address) {
        return treasury(0);
    }

    /**
     * @notice Returns the treasury of the controller `controllerId`
     * @param controllerId Controller to return for
     * @return Treasury of the controller
     */
    function treasury(uint256 controllerId) public view returns (address) {
        return _controllers[controllerId].treasury;
    }

    /**
     * @notice Returns the treasury of the product `product`
     * @param product Product to return for
     * @return Treasury of the product
     */
    function treasury(IProduct product) public view returns (address) {
        return treasury(controllerFor[product]);
    }

    // @dev Only allow owner of `controllerId` to call
    modifier onlyOwner(uint256 controllerId) {
        if (msg.sender != owner(controllerId)) revert FactoryNotOwnerError(controllerId);

        _;
    }
}",2094
RealWorld_BA_60_AccountAccumulator_RealWord_20240822095241.log,60,AccountAccumulator,7710,4888,12598,75.0,0.13631,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""./Accumulator.sol"";
import ""./VersionedAccumulator.sol"";
import ""../position/AccountPosition.sol"";

/// @dev AccountAccumulator type
struct AccountAccumulator {
    /// @dev latest version that the account was synced too
    uint256 latestVersion;
}

/**
 * @title AccountAccumulatorLib
 * @notice Library that manages syncing an account-level accumulator.
 */
library AccountAccumulatorLib {
    using PositionLib for Position;
    using AccumulatorLib for Accumulator;

    /**
     * @notice Syncs the account to oracle version `versionTo`
     * @param self The struct to operate on
     * @param global Pointer to global accumulator
     * @param position Pointer to global position
     * @param versionTo Oracle version to sync account to
     * @return value The value accumulated sync last sync
     */
    function syncTo(
        AccountAccumulator storage self,
        VersionedAccumulator storage global,
        AccountPosition storage position,
        uint256 versionTo
    ) internal returns (Accumulator memory value) {
        Accumulator memory valueAccumulated =
            global.valueAtVersion[versionTo].sub(global.valueAtVersion[self.latestVersion]);
        value = position.position.mul(valueAccumulated);
        self.latestVersion = versionTo;
    }
}",296
RealWorld_BA_60_Product_RealWord_20240822094118.log,60,Product,51911,5342,57253,77.0,0.366395,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""../interfaces/IProduct.sol"";
import ""../interfaces/IProductProvider.sol"";
import ""./types/position/AccountPosition.sol"";
import ""./types/accumulator/AccountAccumulator.sol"";
import ""../utils/unstructured/UReentrancyGuard.sol"";
import ""../factory/UFactoryProvider.sol"";

/**
 * @title Product
 * @notice Manages logic and state for a single product market.
 * @dev Cloned by the Factory contract to launch new product markets.
 */
contract Product is IProduct, UFactoryProvider, UReentrancyGuard {
    using UFixed18Lib for UFixed18;
    using Fixed18Lib for Fixed18;
    using AccumulatorLib for Accumulator;
    using PositionLib for Position;
    using PrePositionLib for PrePosition;
    using AccountAccumulatorLib for AccountAccumulator;
    using VersionedAccumulatorLib for VersionedAccumulator;
    using AccountPositionLib for AccountPosition;
    using VersionedPositionLib for VersionedPosition;

    /// @dev The parameter provider of the product market
    IProductProvider public provider;

    /// @dev The individual position state for each account
    mapping(address => AccountPosition) private _positions;

    /// @dev The global position state for the product
    VersionedPosition private _position;

    /// @dev The individual accumulator state for each account
    mapping(address => AccountAccumulator) private _accumulators;

    /// @dev The global accumulator state for the product
    VersionedAccumulator private _accumulator;

    /**
     * @notice Initializes the contract state
     * @param provider_ Product provider contract address
     */
    function initialize(IProductProvider provider_) external {
        UFactoryProvider__initialize(IFactory(msg.sender));
        UReentrancyGuard__initialize();

        provider = provider_;
    }

    /**
     * @notice Surfaces global settlement externally
     */
    function settle() nonReentrant notPaused external {
        settleInternal();
    }

    /**
     * @notice Core global settlement flywheel
     * @dev
     *  a) last settle oracle version
     *  b) latest pre position oracle version
     *  c) current oracle version
     *
     *  Settles from a->b then from b->c if either interval is non-zero to account for a change
     *  in position quantity at (b).
     *
     *  Syncs each to instantaneously after the oracle update.
     */
    function settleInternal() internal {
        provider.sync();
        factory().incentivizer().sync();

        uint256 oracleVersionPreSettle = _position.pre.oracleVersionToSettle(provider);
        uint256 oracleVersionCurrent = provider.currentVersion();
        UFixed18 accumulatedFee;

        // value a->b
        accumulatedFee = accumulatedFee.add(_accumulator.accumulate(_position, factory(), provider, oracleVersionPreSettle));

        // position a->b
        accumulatedFee = accumulatedFee.add(_position.settle(provider, oracleVersionPreSettle));

        // short-circuit if a->c
        if (oracleVersionPreSettle != oracleVersionCurrent) {

            // value b->c
            accumulatedFee = accumulatedFee.add(_accumulator.accumulate(_position, factory(), provider, oracleVersionCurrent));

            // position b->c (stamp c, does not settle pre position)
            _position.settle(provider, oracleVersionCurrent);
        }

        // settle collateral
        factory().collateral().settleProduct(accumulatedFee);

        emit Settle(oracleVersionPreSettle, oracleVersionCurrent);
    }

    /**
     * @notice Surfaces account settlement externally
     * @param account Account to settle
     */
    function settleAccount(address account) notPaused nonReentrant external {
        settleAccountInternal(account);
    }

    /**
     * @notice Core account settlement flywheel
     * @param account Account to settle
     * @dev
     *  a) last settle oracle version
     *  b) latest pre position oracle version
     *  c) current oracle version
     *
     *  Settles from a->b then from b->c if either interval is non-zero to account for a change
     *  in position quantity at (b).
     *
     *  Syncs each to instantaneously after the oracle update.
     */
    function settleAccountInternal(address account) internal {
        (IIncentivizer incentivizer, ICollateral collateral) = (factory().incentivizer(), factory().collateral());
        uint256 oracleVersionPreSettle = _positions[account].pre.oracleVersionToSettle(provider);
        uint256 oracleVersionCurrent = provider.currentVersion();
        Fixed18 accumulated;

        // value a->b
        accumulated = accumulated.add(_accumulators[account].syncTo(_accumulator, _positions[account], oracleVersionPreSettle).sum());

        // sync incentivizer before position update
        incentivizer.syncAccount(account);

        // position a->b
        accumulated = accumulated.sub(Fixed18Lib.from(_positions[account].settle(provider, oracleVersionPreSettle)));

        // short-circuit if a->c
        if (oracleVersionPreSettle != oracleVersionCurrent) {

            // value b->c
            accumulated = accumulated.add(_accumulators[account].syncTo(_accumulator, _positions[account], oracleVersionCurrent).sum());

            // position b->c (stamp c, does not settle pre position)
            _positions[account].settle(provider, oracleVersionCurrent);
        }

        // settle collateral
        collateral.settleAccount(account, accumulated);

        emit AccountSettle(account, oracleVersionPreSettle, oracleVersionCurrent);
    }

    /**
     * @notice Opens a taker position for `msg.sender`
     * @param amount Amount of the position to open
     */
    function openTake(UFixed18 amount)
    notPaused
    nonReentrant
    settleForAccount(msg.sender)
    takerInvariant
    positionInvariant
    liquidationInvariant
    maintenanceInvariant
    external {
        _positions[msg.sender].pre.openTake(provider, amount);
        _position.pre.openTake(provider, amount);

        emit TakeOpened(msg.sender, amount);
    }

    /**
     * @notice Closes a taker position for `msg.sender`
     * @param amount Amount of the position to close
     */
    function closeTake(UFixed18 amount)
    notPaused
    nonReentrant
    settleForAccount(msg.sender)
    closeInvariant
    liquidationInvariant
    external {
        closeTakeInternal(msg.sender, amount);
    }

    function closeTakeInternal(address account, UFixed18 amount) internal {
        _positions[account].pre.closeTake(provider, amount);
        _position.pre.closeTake(provider, amount);

        emit TakeClosed(account, amount);
    }

    /**
     * @notice Opens a maker position for `msg.sender`
     * @param amount Amount of the position to open
     */
    function openMake(UFixed18 amount)
    notPaused
    nonReentrant
    settleForAccount(msg.sender)
    makerInvariant
    positionInvariant
    liquidationInvariant
    maintenanceInvariant
    external {
        _positions[msg.sender].pre.openMake(provider, amount);
        _position.pre.openMake(provider, amount);

        emit MakeOpened(msg.sender, amount);
    }

    /**
     * @notice Closes a maker position for `msg.sender`
     * @param amount Amount of the position to close
     */
    function closeMake(UFixed18 amount)
    notPaused
    nonReentrant
    settleForAccount(msg.sender)
    takerInvariant
    closeInvariant
    liquidationInvariant
    external {
        closeMakeInternal(msg.sender, amount);
    }

    function closeMakeInternal(address account, UFixed18 amount) internal {
        _positions[account].pre.closeMake(provider, amount);
        _position.pre.closeMake(provider, amount);

        emit MakeClosed(account, amount);
    }

    /**
     * @notice Closes all open and pending positions, locking for liquidation
     * @dev Only callable by the Collateral contract as part of the liquidation flow
     * @param account Account to close out
     */
    function closeAll(address account) onlyCollateral settleForAccount(account) external {
        Position memory p = _positions[account].position.next(_positions[account].pre);

        // Close all positions
        closeMakeInternal(account, p.maker);
        closeTakeInternal(account, p.taker);

        // Mark liquidation to lock position
        _positions[account].liquidation = true;
    }

    /**
     * @notice Returns the maintenance requirement for `account`
     * @param account Account to return for
     * @return The current maintenance requirement
     */
    function maintenance(address account) public view returns (UFixed18) {
        return _positions[account].maintenance(provider);
    }

    /**
     * @notice Returns the maintenance requirement for `account` after next settlement
     * @dev Assumes no price change and no funding, used to protect user from over-opening
     * @param account Account to return for
     * @return The next maintenance requirement
     */
    function maintenanceNext(address account) public view returns (UFixed18) {
        return _positions[account].maintenanceNext(provider);
    }

    /**
     * @notice Returns whether `account` has a completely zero'd position
     * @param account Account to return for
     * @return The the account is closed
     */
    function isClosed(address account) external view returns (bool) {
        return _positions[account].isClosed();
    }

    /**
     * @notice Returns whether `account` is currently locked for an in-progress liquidation
     * @param account Account to return for
     * @return Whether the account is in liquidation
     */
    function isLiquidating(address account) external view returns (bool) {
        return _positions[account].liquidation;
    }

    /**
     * @notice Returns `account`'s current position
     * @param account Account to return for
     * @return Current position of the account
     */
    function position(address account) external view returns (Position memory) {
        return _positions[account].position;
    }

    /**
     * @notice Returns `account`'s current pending-settlement position
     * @param account Account to return for
     * @return Current pre-position of the account
     */
    function pre(address account) external view returns (PrePosition memory) {
        return _positions[account].pre;
    }

    /**
     * @notice Returns the global latest settled oracle version
     * @return Latest settled oracle version of the product
     */
    function latestVersion() external view returns (uint256) {
        return _position.latestVersion;
    }

    /**
     * @notice Returns the global position at oracleVersion `oracleVersion`
     * @dev Only valid for the version at which a global settlement occurred
     * @param oracleVersion Oracle version to return for
     * @return Global position at oracle version
     */
    function positionAtVersion(uint256 oracleVersion) external view returns (Position memory) {
        return _position.positionAtVersion[oracleVersion];
    }

    /**
     * @notice Returns the current global pending-settlement position
     * @return Global pending-settlement position
     */
    function pre() external view returns (PrePosition memory) {
        return _position.pre;
    }

    /**
     * @notice Returns the global accumulator value at oracleVersion `oracleVersion`
     * @dev Only valid for the version at which a global settlement occurred
     * @param oracleVersion Oracle version to return for
     * @return Global accumulator value at oracle version
     */
    function valueAtVersion(uint256 oracleVersion) external view returns (Accumulator memory) {
        return _accumulator.valueAtVersion[oracleVersion];
    }

    /**
     * @notice Returns the global accumulator share at oracleVersion `oracleVersion`
     * @dev Only valid for the version at which a global settlement occurred
     * @param oracleVersion Oracle version to return for
     * @return Global accumulator share at oracle version
     */
    function shareAtVersion(uint256 oracleVersion) external view returns (Accumulator memory) {
        return _accumulator.shareAtVersion[oracleVersion];
    }

    /**
     * @notice Returns `account`'s latest settled oracle version
     * @param account Account to return for
     * @return Latest settled oracle version of the account
     */
    function latestVersion(address account) external view returns (uint256) {
        return _accumulators[account].latestVersion;
    }

    /// @dev Limit total maker for guarded rollouts
    modifier makerInvariant {
        _;

        Position memory next = _position.position().next(_position.pre);

        if (next.maker.gt(provider.makerLimit())) revert ProductMakerOverLimitError();
    }

    /// @dev Limit maker short exposure to the range 0.0-1.0x of their position
    modifier takerInvariant {
        _;

        Position memory next = _position.position().next(_position.pre);
        UFixed18 socializationFactor = next.socializationFactor();

        if (socializationFactor.lt(UFixed18Lib.ONE)) revert ProductInsufficientLiquidityError(socializationFactor);
    }

    /// @dev Ensure that the user has only taken a maker or taker position, but not both
    modifier positionInvariant {
        _;

        if (_positions[msg.sender].isDoubleSided()) revert ProductDoubleSidedError();
    }

    /// @dev Ensure that the user hasn't closed more than is open
    modifier closeInvariant {
        _;

        if (_positions[msg.sender].isOverClosed()) revert ProductOverClosedError();
    }

    /// @dev Ensure that the user will have sufficient margin for maintenance after next settlement
    modifier maintenanceInvariant {
        _;

        if (factory().collateral().liquidatableNext(msg.sender, IProduct(this)))
            revert ProductInsufficientCollateralError();
    }

    /// @dev Ensure that the user is not currently being liquidated
    modifier liquidationInvariant {
        if (_positions[msg.sender].liquidation) revert ProductInLiquidationError();

        _;
    }

    /// @dev Helper to fully settle an account's state
    modifier settleForAccount(address account) {
        settleInternal();
        settleAccountInternal(account);

        _;
    }
}",3043
RealWorld_BA_60_MockUOwnable_RealWord_20240822093145.log,60,MockUOwnable,3943,4042,7985,69.0,0.100555,"// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import ""../unstructured/UOwnable.sol"";

contract MockUOwnable is UOwnable {
    function __initialize() external {
        super.UOwnable__initialize();
    }
}",57
RealWorld_BA_60_IFactory_RealWord_20240822101141.log,60,IFactory,15596,5795,21391,76.0,0.19388,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.10;

import ""./ICollateral.sol"";
import ""./IIncentivizer.sol"";
import ""./IProduct.sol"";
import ""./IProductProvider.sol"";
import ""../utils/types/UFixed18.sol"";

interface IFactory {
    /// @dev Controller of a one or many products
    struct Controller {
        /// @dev Owner of the product, allowed to update select parameters
        address owner;

        /// @dev Treasury of the product, collects fees
        address treasury;
    }

    event CollateralUpdated(ICollateral newCollateral);
    event IncentivizerUpdated(IIncentivizer newIncentivizer);
    event ProductBaseUpdated(IProduct newProductBase);
    event FeeUpdated(UFixed18 newFee);
    event MinFundingFeeUpdated(UFixed18 newMinFundingFee);
    event MinCollateralUpdated(UFixed18 newMinCollateral);
    event ControllerUpdated(uint256 indexed controllerId, address newOwner, address newTreasury);
    event AllowedUpdated(uint256 indexed controllerId, bool allowed);
    event PauserUpdated(address pauser);
    event IsPausedUpdated(bool isPaused);
    event ControllerCreated(uint256 indexed controllerId, address owner, address treasury);
    event ProductCreated(IProduct indexed product, IProductProvider provider);

    error FactoryAlreadyInitializedError();
    error FactoryNoZeroControllerError();
    error FactoryNotAllowedError();
    error FactoryNotPauserError(address sender);
    error FactoryNotOwnerError(uint256 controllerId);

    function initialized() external view returns (bool);
    function pauser() external view returns (address);
    function isPaused() external view returns (bool);
    function collateral() external view returns (ICollateral);
    function incentivizer() external view returns (IIncentivizer);
    function productBase() external view returns (IProduct);
    function controllers(uint256 collateralId) external view returns (Controller memory);
    function controllerFor(IProduct product) external view returns (uint256);
    function allowed(uint256 collateralId) external view returns (bool);
    function fee() external view returns (UFixed18);
    function minFundingFee() external view returns (UFixed18);
    function minCollateral() external view returns (UFixed18);
    function initialize(ICollateral collateral_, IIncentivizer incentivizer_, IProduct productBase_, address treasury_) external;
    function createController(address controllerTreasury) external returns (uint256);
    function updateController(uint256 controllerId, Controller memory newController) external;
    function createProduct(uint256 controllerId, IProductProvider provider) external returns (IProduct);
    function updateCollateral(ICollateral newCollateral) external;
    function updateIncentivizer(IIncentivizer newIncentivizer) external;
    function updateProductBase(IProduct newProductBase) external;
    function updateFee(UFixed18 newFee) external;
    function updateMinFundingFee(UFixed18 newMinFundingFee) external;
    function updateMinCollateral(UFixed18 newMinCollateral) external;
    function updatePauser(address newPauser) external;
    function updateIsPaused(bool newIsPaused) external;
    function updateAllowed(uint256 controllerId, bool newAllowed) external;
    function isProduct(IProduct product) external view returns (bool);
    function owner() external view returns (address);
    function owner(uint256 controllerId) external view returns (address);
    function owner(IProduct product) external view returns (address);
    function treasury() external view returns (address);
    function treasury(uint256 controllerId) external view returns (address);
    function treasury(IProduct product) external view returns (address);
}",772
RealWorld_BA_60_VersionedPosition_RealWord_20240822094953.log,60,VersionedPosition,10578,5054,15632,76.0,0.15397,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""./PrePosition.sol"";

//// @dev VersionedPosition type
struct VersionedPosition {
    /// @dev Latest synced oracle version
    uint256 latestVersion;

    /// @dev Mapping of global position at each version
    mapping(uint256 => Position) positionAtVersion;

    /// @dev Current global pending-settlement position delta
    PrePosition pre;
}

/**
 * @title VersionedPositionLib
 * @notice Library that manages global position state.
 * @dev Global position state is used to compute utilization rate and socialization, and to account for and
 *      distribute fees globally.
 *
 *      Positions are stamped for historical lookup anytime there is a global settlement, which services
 *      the delayed-position accounting. It is not guaranteed that every version will have a value stamped, but
 *      only versions when a settlement occurred are needed for this historical computation.
 */
library VersionedPositionLib {
    using PositionLib for Position;
    using PrePositionLib for PrePosition;

    /**
     * @notice Returns the current global position
     * @return Current global position
     */
    function position(VersionedPosition storage self) internal view returns (Position memory) {
        return self.positionAtVersion[self.latestVersion];
    }

    /**
     * @notice Settled the global position to oracle version `toOracleVersion`
     * @param self The struct to operate on
     * @param provider The parameter provider of the product
     * @param toOracleVersion The oracle version to accumulate to
     * @return positionFee The fee accrued from opening or closing a new position
     */
    function settle(VersionedPosition storage self, IProductProvider provider, uint256 toOracleVersion) internal returns (UFixed18 positionFee) {
        if (toOracleVersion <= self.latestVersion) return UFixed18Lib.ZERO;

        bool settled;
        (self.positionAtVersion[toOracleVersion], positionFee, settled) = position(self).settled(self.pre, provider, toOracleVersion);
        if (settled) delete self.pre;

        self.latestVersion = toOracleVersion;
    }
}",455
RealWorld_BA_60_UOwnable_RealWord_20240822093837.log,60,UOwnable,13472,5462,18934,75.0,0.1766,"// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 *
 * NOTE: This contract has been extended from the Open Zeppelin library to include an
 *       unstructured storage pattern, so that it can be safely mixed in with upgradeable
 *       contracts without affecting their storage patterns through inheritance.
 */
abstract contract UOwnable {
    /**
     * @dev unstructured storage slot for the owner address
     */
    bytes32 private constant OWNER_SLOT = keccak256(""equilibria.utils.UOwnable.owner"");

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    error UOwnableNotOwnerError(address sender);
    error UOwnableZeroAddressError();

    /**
     * @dev Initializes the contract setting the caller as the initial owner.
     */
    function UOwnable__initialize() internal {
        _setOwner(msg.sender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address result) {
        bytes32 slot = OWNER_SLOT;
        assembly {
            result := sload(slot)
        }
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        if (owner() != msg.sender) revert UOwnableNotOwnerError(msg.sender);
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        if (newOwner == address(0)) revert UOwnableZeroAddressError();
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner;
        bytes32 slot = OWNER_SLOT;
        assembly {
            oldOwner := sload(slot)
            sstore(slot, newOwner)
        }

        emit OwnershipTransferred(oldOwner, newOwner);
    }
}",617
RealWorld_BA_60_IOracle_RealWord_20240822101259.log,60,IOracle,5022,5010,10032,82.0,0.12531,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.10;

import ""../utils/types/Fixed18.sol"";

interface IOracle {
    event Version(uint256 version, uint256 timestamp, Fixed18 price);

    function sync() external;
    function priceAtVersion(uint256 version) external view returns (Fixed18);
    function timestampAtVersion(uint256 version) external view returns (uint256);
    function currentVersion() external view returns (uint256);
}",99
RealWorld_BA_60_IProductProvider_RealWord_20240822100852.log,60,IProductProvider,5783,4978,10761,74.0,0.128475,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.10;

import ""./IOracle.sol"";
import ""../product/types/position/Position.sol"";
import ""../utils/types/UFixed18.sol"";
import ""../utils/types/Fixed18.sol"";

interface IProductProvider is IOracle {
    function rate(Position memory position) external view returns (Fixed18);
    function payoff(Fixed18 price) external view returns (Fixed18);
    function maintenance() external view returns (UFixed18);
    function fundingFee() external view returns (UFixed18);
    function makerFee() external view returns (UFixed18);
    function takerFee() external view returns (UFixed18);
    function makerLimit() external view returns (UFixed18);
}",157
RealWorld_BA_60_Program_RealWord_20240822100454.log,60,Program,26293,5444,31737,76.0,0.240345,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""../../product/types/position/Position.sol"";
import ""../../utils/types/Token18.sol"";
import ""./ProgramInfo.sol"";

struct Program {
    /// @dev Mapping of latest synced oracle version for each account
    mapping(address => uint256) latestVersion;

    /// @dev Mapping of latest rewards settled for each account
    mapping(address => UFixed18) settled;

    /// @dev Total amount of rewards yet to be claimed
    UFixed18 available;

    /// @dev Oracle version that the program completed, 0 is still ongoing
    uint256 versionComplete;

    /// @dev Whether the program is closed
    bool closed;

    /// @dev Whether the program is owned by the protocol (true) or by the product owner (false)
    bool protocolOwned;
}

library ProgramLib {
    using UFixed18Lib for UFixed18;
    using PositionLib for Position;
    using AccumulatorLib for Accumulator;
    using ProgramInfoLib for ProgramInfo;

    /**
     * @notice Initializes the program state
     * @param self Static The Program to operate on
     * @param programInfo Static program information
     * @param protocolOwned Whether the program is protocol owned
     */
    function initialize(Program storage self, ProgramInfo memory programInfo, bool protocolOwned) internal {
        self.available = programInfo.amount.sum();
        self.protocolOwned = protocolOwned;
    }

    /**
     * @notice Returns whether a program can be closed
     * @dev Programs must wait to be closed until after their grace period has concluded whether
     *      or not it was completed early
     * @param self Static The Program to operate on
     * @param programInfo Static program information
     * @param timestamp The effective timestamp to check
     * @return Whether the program can be closed
     */
    function canClose(Program storage self, ProgramInfo memory programInfo, uint256 timestamp) internal view returns (bool) {
        uint256 end = self.versionComplete == 0 ?
            programInfo.start + programInfo.duration :
            programInfo.product.provider().timestampAtVersion(self.versionComplete);
        return timestamp >= (end + programInfo.grace);
    }

    /**
     * @notice Closes the program
     * @param self Static The Program to operate on
     * @return amountToReturn Amount of remaining unclaimed reward tokens to be returned
     */
    function close(Program storage self) internal returns (UFixed18 amountToReturn) {
        amountToReturn = self.available;
        self.available = UFixed18Lib.ZERO;
        self.closed = true;
    }

    /**
     * @notice Completes the program
     * @dev Completion prevents anymore rewards from accruing, but users may still claim during the
     *      grace period until a program is closed
     * @param self Static The Program to operate on
     * @param oracleVersion The effective oracle version of completion
     */
    function complete(Program storage self, uint256 oracleVersion) internal {
        self.versionComplete = oracleVersion;
    }

    /**
     * @notice Settles unclaimed rewards for account `account`
     * @param self Static The Program to operate on
     * @param programInfo Static program information
     * @param account The account to settle for
     */
    function settle(Program storage self, ProgramInfo memory programInfo, address account) internal {
        (UFixed18 unsettledAmount, uint256 unsettledVersion) = unsettled(self, programInfo, account);

        self.settled[account] = self.settled[account].add(unsettledAmount);
        self.available = self.available.sub(unsettledAmount);
        self.latestVersion[account] = unsettledVersion;
    }

    /**
     * @notice Claims settled rewards for account `account`
     * @param self Static The Program to operate on
     * @param account The account to claim for
     */
    function claim(Program storage self, address account)
    internal returns (UFixed18 claimedAmount) {
        claimedAmount = self.settled[account];
        self.settled[account] = UFixed18Lib.ZERO;
    }

    /**
     * @notice Returns the total amount of unclaimed rewards for account `account`
     * @dev This includes both settled and unsettled unclaimed rewards
     * @param self Static The Program to operate on
     * @param programInfo Static program information
     * @param account The account to claim for
     * @return Total amount of unclaimed rewards for account
     */
    function unclaimed(Program storage self, ProgramInfo memory programInfo, address account)
    internal view returns (UFixed18) {
        (UFixed18 unsettledAmount, ) = unsettled(self, programInfo, account);
        return unsettledAmount.add(self.settled[account]);
    }

    /**
     * @notice Returns the unsettled amount of unclaimed rewards for account `account`
     * @dev Clears when a program is closed
     *      Assumes that position is unchanged since last settlement, must be settled prior to user position update
     * @param self Static The Program to operate on
     * @param programInfo Static program information
     * @param account The account to claim for
     * @return amount Amount of unsettled rewards for account
     * @return latestVersion Effective oracle version for computation
     */
    function unsettled(Program storage self, ProgramInfo memory programInfo, address account)
    private view returns (UFixed18 amount, uint256 latestVersion) {
        IProduct product = programInfo.product;

        uint256 userLatestVersion = self.latestVersion[account];
        Position memory userPosition = product.position(account);
        uint256 userSyncedTo = product.latestVersion(account);

        // compute version to sync to
        latestVersion = self.versionComplete == 0 ? userSyncedTo : Math.min(userSyncedTo, self.versionComplete);
        uint256 latestTimestamp = product.provider().timestampAtVersion(latestVersion);

        // check initialization conditions
        if (!programInfo.isStarted(latestTimestamp)) return (UFixed18Lib.ZERO, 0); // program hasn't started
        if (self.closed) return (UFixed18Lib.ZERO, latestVersion);                 // program has closed
        if (userLatestVersion == 0) return (UFixed18Lib.ZERO, latestVersion);      // user has not been initialized

        // compute unsettled amount
        Accumulator memory userShareDelta =
            userPosition.mul(product.shareAtVersion(latestVersion).sub(product.shareAtVersion(userLatestVersion)));
        amount = UFixed18Lib.from(programInfo.amountPerShare().mul(userShareDelta).sum());
    }
}",1411
RealWorld_BA_60_Incentivizer_RealWord_20240822100159.log,60,Incentivizer,50313,5408,55721,95.0,0.359725,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""../interfaces/IIncentivizer.sol"";
import ""../interfaces/IFactory.sol"";
import ""./types/Program.sol"";
import ""../utils/unstructured/UReentrancyGuard.sol"";
import ""../product/types/position/Position.sol"";
import ""../product/types/accumulator/Accumulator.sol"";
import ""../factory/UFactoryProvider.sol"";

contract Incentivizer is IIncentivizer, UFactoryProvider, UReentrancyGuard {
    using UFixed18Lib for UFixed18;
    using EnumerableSet for EnumerableSet.UintSet;
    using Token18Lib for Token18;
    using PositionLib for Position;
    using AccumulatorLib for Accumulator;
    using ProgramInfoLib for ProgramInfo;
    using ProgramLib for Program;

    /// @dev Maximum programs per product allowed
    uint256 public programsPerProduct;

    /// @dev Fee taken from total program amount
    UFixed18 public fee;

    /// @dev Static program state
    ProgramInfo[] private _programInfos;

    /// @dev Dynamic program state
    mapping(uint256 => Program) private _programs;

    /// @dev Mapping of all programs for each product
    mapping(IProduct => EnumerableSet.UintSet) private _registry;

    /// @dev Fees that have been collected, but remain unclaimed
    mapping(Token18 => UFixed18) public fees;

    /**
     * @notice Initializes the contract state
     * @param factory_ Factory contract address
     */
    function initialize(IFactory factory_) external {
        UFactoryProvider__initialize(factory_);
        UReentrancyGuard__initialize();

        programsPerProduct = 2;
        fee = UFixed18Lib.ZERO;
    }

    /**
     * @notice Creates a new incentive program
     * @dev Must be called as the product or protocol owner
     * @param info Parameters for the new program
     * @return new program's ID
     */
    function create(ProgramInfo calldata info)
    nonReentrant
    isProduct(info.product)
    notPaused
    external returns (uint256) {
        bool protocolOwned = msg.sender == factory().owner();

        if (_registry[info.product].length() >= programsPerProduct) revert IncentivizerTooManyProgramsError();
        if (!protocolOwned && msg.sender != factory().owner(info.product))
            revert NotProductOwnerError(msg.sender, info.product);

        uint256 programId = _programInfos.length;
        (ProgramInfo memory programInfo, UFixed18 programFee) = ProgramInfoLib.create(fee, info);

        _programInfos.push(programInfo);
        _programs[programId].initialize(programInfo, protocolOwned);
        _registry[info.product].add(programId);
        fees[info.token] = fees[info.token].add(programFee);

        info.token.pull(msg.sender, info.amount.sum());

        emit ProgramCreated(
            programId,
            programInfo.product,
            programInfo.token,
            programInfo.amount.maker,
            programInfo.amount.taker,
            programInfo.start,
            programInfo.duration,
            programInfo.grace,
            programFee
        );

        return programId;
    }

    /**
     * @notice Completes an in-progress program early
     * @dev Must be called as the program owner
     * @param programId Program to end
     */
    function end(uint256 programId)
    notPaused
    validProgram(programId)
    onlyProgramOwner(programId)
    external {
        completeInternal(programId);
    }

    /**
     * @notice Closes a program, returning all unclaimed rewards
     * @param programId Program to end
     */
    function close(uint256 programId)
    notPaused
    validProgram(programId)
    external {
        Program storage program = _programs[programId];
        ProgramInfo storage programInfo = _programInfos[programId];

        if (!program.canClose(programInfo, block.timestamp)) revert IncentivizerProgramNotClosableError();

        // complete if not yet completed
        if (program.versionComplete == 0) {
            completeInternal(programId);
        }

        // close
        UFixed18 amountToReturn = _programs[programId].close();
        programInfo.token.push(treasury(programId), amountToReturn);
        _registry[programInfo.product].remove(programId);

        emit ProgramClosed(programId, amountToReturn);
    }

    /**
     * @notice Completes any in-progress programs that newly completable
     * @dev Called every settle() from each product
     */
    function sync() onlyProduct external {
        IProduct product = IProduct(msg.sender);
        IProductProvider provider = product.provider();

        uint256 currentTimestamp = provider.timestampAtVersion(provider.currentVersion());

        for (uint256 i; i < _registry[product].length(); i++) {
            uint256 programId = _registry[product].at(i);

            if (_programs[programId].versionComplete != 0) continue;
            if (!_programInfos[programId].isComplete(currentTimestamp)) continue;

            completeInternal(programId);
        }
    }

    /**
     * @notice Completes a program
     * @dev Internal helper
     * @param programId Program to complete
     */
    function completeInternal(uint256 programId) private {
        uint256 version = _programInfos[programId].product.latestVersion();
        _programs[programId].complete(version);

        emit ProgramCompleted(programId, version);
    }

    /**
     * @notice Settles unsettled balance for `account`
     * @dev Called immediately proceeding a position update in the corresponding product
     * @param account Account to sync
     */
    function syncAccount(address account) onlyProduct external {
        IProduct product = IProduct(msg.sender);

        for (uint256 i; i < _registry[product].length(); i++) {
            uint256 programId = _registry[product].at(i);
            _programs[programId].settle(_programInfos[programId], account);
        }
    }

    /**
     * @notice Claims all of `msg.sender`'s rewards for `product` programs
     * @param product Product to claim rewards for
     */
    function claim(IProduct product) notPaused nonReentrant isProduct(product) public {
        // settle product markets
        product.settle();
        product.settleAccount(msg.sender);

        // claim
        for (uint256 i; i < _registry[product].length(); i++) {
            claimInternal(msg.sender, _registry[product].at(i));
        }
    }

    /**
     * @notice Claims all of `msg.sender`'s rewards for a specific program
     * @param programId Program to claim rewards for
     */
    function claim(uint256 programId) notPaused nonReentrant validProgram(programId) public {
        IProduct product = _programInfos[programId].product;

        // settle product markets
        product.settle();
        product.settleAccount(msg.sender);

        // claim
        claimInternal(msg.sender, programId);
    }

    /**
     * @notice Claims all of `account`'s rewards for a specific program
     * @dev Internal helper, assumes account has already been product-settled prior to calling
     * @param account Account to claim rewards for
     * @param programId Program to claim rewards for
     */
    function claimInternal(address account, uint256 programId) private {
        Program storage program = _programs[programId];
        ProgramInfo memory programInfo = _programInfos[programId];

        program.settle(programInfo, account);
        UFixed18 claimedAmount = program.claim(account);

        programInfo.token.push(account, claimedAmount);

        emit Claim(account, programId, claimedAmount);
    }

    /**
     * @notice Claims all `tokens` fees to the protocol treasury
     * @param tokens Tokens to claim fees for
     */
    function claimFee(Token18[] calldata tokens) notPaused external {
        for(uint256 i; i < tokens.length; i++) {
            Token18 token = tokens[i];
            UFixed18 amount = fees[token];

            fees[token] = UFixed18Lib.ZERO;
            tokens[i].push(factory().treasury(), amount);

            emit FeeClaim(token, amount);
        }
    }

    /**
     * @notice Returns program info for program `programId`
     * @param programId Program to return for
     * @return Program info
     */
    function programInfos(uint256 programId) external view returns (ProgramInfo memory) {
        return _programInfos[programId];
    }

    /**
     * @notice Returns `account`'s total unclaimed rewards for a specific program
     * @param account Account to return for
     * @param programId Program to return for
     * @return `account`'s total unclaimed rewards for `programId`
     */
    function unclaimed(address account, uint256 programId) external view returns (UFixed18) {
        if (programId >= _programInfos.length) return (UFixed18Lib.ZERO);

        ProgramInfo memory programInfo = _programInfos[programId];
        return _programs[programId].unclaimed(programInfo, account);
    }

    /**
     * @notice Returns `account`'s latest synced version for a specific program
     * @param account Account to return for
     * @param programId Program to return for
     * @return `account`'s latest synced version for `programId`
     */
    function latestVersion(address account, uint256 programId) external view returns (uint256) {
        return _programs[programId].latestVersion[account];
    }

    /**
     * @notice Returns `account`'s settled rewards for a specific program
     * @param account Account to return for
     * @param programId Program to return for
     * @return `account`'s settled rewards for `programId`
     */
    function settled(address account, uint256 programId) external view returns (UFixed18) {
        return _programs[programId].settled[account];
    }

    /**
     * @notice Returns available rewards for a specific program
     * @param programId Program to return for
     * @return Available rewards for `programId`
     */
    function available(uint256 programId) external view returns (UFixed18) {
        return _programs[programId].available;
    }

    /**
     * @notice Returns the version completed for a specific program
     * @param programId Program to return for
     * @return The version completed for `programId`
     */
    function versionComplete(uint256 programId) external view returns (uint256) {
        return _programs[programId].versionComplete;
    }

    /**
     * @notice Returns whether closed for a specific program
     * @param programId Program to return for
     * @return whether closed for `programId`
     */
    function closed(uint256 programId) external view returns (bool) {
        return _programs[programId].closed;
    }

    /**
     * @notice Returns quantity of programs for a specific product
     * @param product Product to return for
     * @return Quantity of programs for `product`
     */
    function programsForLength(IProduct product) external view returns (uint256) {
        return _registry[product].length();
    }

    /**
     * @notice Returns the program at index `index` for a specific product
     * @param product Product to return for
     * @param index Index to return for
     * @return The program at index `index` for `product`
     */
    function programsForAt(IProduct product, uint256 index) external view returns (uint256) {
        return _registry[product].at(index);
    }

    /**
     * @notice Returns the owner of a specific program
     * @param programId Program to return for
     * @return The owner of `programId`
     */
    function owner(uint256 programId) public view returns (address) {
        Program storage program = _programs[programId];
        ProgramInfo storage programInfo = _programInfos[programId];
        return program.protocolOwned ? factory().owner() : factory().owner(programInfo.product);
    }

    /**
     * @notice Returns the treasury of a specific program
     * @param programId Program to return for
     * @return The treasury of `programId`
     */
    function treasury(uint256 programId) public view returns (address) {
        Program storage program = _programs[programId];
        ProgramInfo storage programInfo = _programInfos[programId];
        return program.protocolOwned ? factory().treasury() : factory().treasury(programInfo.product);
    }

    /**
     * @notice Updates the maximum programs per product
     * @param newProgramsPerProduct New maximum programs per product value
     */
    function updateProgramsPerProduct(uint256 newProgramsPerProduct) onlyOwner external {
        programsPerProduct = newProgramsPerProduct;

        emit ProgramsPerProductUpdated(newProgramsPerProduct);
    }

    /**
     * @notice Updates the fee
     * @param newFee New fee value
     */
    function updateFee(UFixed18 newFee) onlyOwner external {
        fee = newFee;

        emit FeeUpdated(newFee);
    }

    /// @dev Only allow the owner of `programId` to call
    modifier onlyProgramOwner(uint256 programId) {
        if (msg.sender != owner(programId)) revert IncentivizerNotProgramOwnerError(msg.sender, programId);

        _;
    }

    /// @dev Only allow a valid `programId`
    modifier validProgram(uint256 programId) {
        if (programId >= _programInfos.length) revert IncentivizerInvalidProgramError(programId);

        _;
    }
}",2948
RealWorld_BA_60_AccountPosition_RealWord_20240822094834.log,60,AccountPosition,20010,5372,25382,76.0,0.20749,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""./PrePosition.sol"";
import ""../accumulator/Accumulator.sol"";

/// @dev AccountPosition type
struct AccountPosition {
    /// @dev The current settled position of the account
    Position position;

    /// @dev The current position delta pending-settlement
    PrePosition pre;

    /// @dev Whether the account is currently locked for liquidation
    bool liquidation;
}

/**
 * @title AccountPositionLib
 * @notice Library that manages an account-level position.
 */
library AccountPositionLib {
    using UFixed18Lib for UFixed18;
    using Fixed18Lib for Fixed18;
    using PositionLib for Position;
    using PrePositionLib for PrePosition;

    /**
     * @notice Settled the account's position to oracle version `toOracleVersion`
     * @param self The struct to operate on
     * @param provider The parameter provider of the product
     * @param toOracleVersion The oracle version to accumulate to
     * @return positionFee The fee accrued from opening or closing a new position
     */
    function settle(AccountPosition storage self, IProductProvider provider, uint256 toOracleVersion) internal returns (UFixed18 positionFee) {
        bool settled;
        (self.position, positionFee, settled) = self.position.settled(self.pre, provider, toOracleVersion);
        if (settled) delete self.pre;
    }

    /**
     * @notice Returns the current maintenance requirement for the account
     * @param self The struct to operate on
     * @param provider The parameter provider of the product
     * @return Current maintenance requirement for the account
     */
    function maintenance(AccountPosition storage self, IProductProvider provider) internal view returns (UFixed18) {
        if (self.liquidation) return UFixed18Lib.ZERO;
        return maintenanceInternal(self.position, provider);
    }

    /**
     * @notice Returns the maintenance requirement after the next oracle version settlement
     * @dev Includes the current pending-settlement position delta, assumes no price change
     * @param self The struct to operate on
     * @param provider The parameter provider of the product
     * @return Next maintenance requirement for the account
     */
    function maintenanceNext(AccountPosition storage self, IProductProvider provider) internal view returns (UFixed18) {
        return maintenanceInternal(self.position.next(self.pre), provider);
    }

    /**
      @notice Returns the maintenance requirement for a given `position`
     * @dev Internal helper
     * @param position The position to compete the maintenance requirement for
     * @param provider The parameter provider of the product
     * @return Next maintenance requirement for the account
     */
    function maintenanceInternal(Position memory position, IProductProvider provider) private view returns (UFixed18) {
        Fixed18 oraclePrice = provider.priceAtVersion(provider.currentVersion());
        UFixed18 notionalMax = Fixed18Lib.from(position.max()).mul(oraclePrice).abs();
        return notionalMax.mul(provider.maintenance());
    }

    /**
     * @notice Returns whether an account is completely closed, i.e. no position or pre-position
     * @param self The struct to operate on
     * @return Whether the account is closed
     */
    function isClosed(AccountPosition memory self) internal pure returns (bool) {
        return self.pre.isEmpty() && self.position.isEmpty();
    }

    /**
     * @notice Returns whether an account has opened position on both sides of the market (maker vs taker)
     * @dev Used to verify the invariant that a single account can only have a position on one side of the
     *      market at a time
     * @param self The struct to operate on
     * @return Whether the account is currently doubled sided
     */
    function isDoubleSided(AccountPosition storage self) internal view returns (bool) {
        bool makerEmpty = self.position.maker.isZero() && self.pre.openPosition.maker.isZero() && self.pre.closePosition.maker.isZero();
        bool takerEmpty = self.position.taker.isZero() && self.pre.openPosition.taker.isZero() && self.pre.closePosition.taker.isZero();

        return !makerEmpty && !takerEmpty;
    }

    /**
     * @notice Returns whether the account's pending-settlement delta closes more position than is open
     * @dev Used to verify the invariant that an account cannot settle into having a negative position
     * @param self The struct to operate on
     * @return Whether the account is currently over closed
     */
    function isOverClosed(AccountPosition storage self) internal view returns (bool) {
        Position memory nextOpen = self.position.add(self.pre.openPosition);

        return  self.pre.closePosition.maker.gt(nextOpen.maker) || self.pre.closePosition.taker.gt(nextOpen.taker);
    }
}",1028
RealWorld_BA_60_ProductProvider_RealWord_20240822094357.log,60,ProductProvider,10895,5224,16119,105.0,0.158955,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""../../interfaces/IProductProvider.sol"";
import ""../../interfaces/IFactory.sol"";
import ""../../utils/types/UFixed18.sol"";

/**
 * @title ProductProviderLib
 * @notice Library that adds a safeguard wrapper to certain product parameters.
 * @dev Product providers are semi-untrusted as they contain custom code from the product owners. Owners
 *      have full control over this parameter-setting code, however there are some ""known ranges"" that
 *      a parameter cannot be outside of (i.e. a fee being over 100%).
 */
library ProductProviderLib {
    using UFixed18Lib for UFixed18;

    /**
     * @notice Returns the minimum funding fee parameter with a capped range for safety
     * @dev Caps factory.minFundingFee() <= self.minFundingFee() <= 1
     * @param self The parameter provider to operate on
     * @param factory The protocol Factory contract
     * @return Safe minimum funding fee parameter
     */
    function safeFundingFee(IProductProvider self, IFactory factory) internal view returns (UFixed18) {
        return self.fundingFee().max(factory.minFundingFee()).min(UFixed18Lib.ONE);
    }

    /**
     * @notice Returns the maker fee parameter with a capped range for safety
     * @dev Caps self.makerFee() <= 1
     * @param self The parameter provider to operate on
     * @return Safe maker fee parameter
     */
    function safeMakerFee(IProductProvider self) internal view returns (UFixed18) {
        return self.makerFee().min(UFixed18Lib.ONE);
    }

    /**
     * @notice Returns the taker fee parameter with a capped range for safety
     * @dev Caps self.takerFee() <= 1
     * @param self The parameter provider to operate on
     * @return Safe taker fee parameter
     */
    function safeTakerFee(IProductProvider self) internal view returns (UFixed18) {
        return self.takerFee().min(UFixed18Lib.ONE);
    }
}",453
RealWorld_BA_60_IProduct_RealWord_20240822101008.log,60,IProduct,11083,6260,17343,91.0,0.180615,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.10;

import ""../product/types/position/Position.sol"";
import ""../product/types/position/PrePosition.sol"";
import ""../product/types/accumulator/Accumulator.sol"";
import ""../utils/types/UFixed18.sol"";

interface IProduct {
    event Settle(uint256 preVersion, uint256 toVersion);
    event AccountSettle(address indexed account, uint256 preVersion, uint256 toVersion);
    event MakeOpened(address indexed account, UFixed18 amount);
    event TakeOpened(address indexed account, UFixed18 amount);
    event MakeClosed(address indexed account, UFixed18 amount);
    event TakeClosed(address indexed account, UFixed18 amount);

    error ProductInsufficientLiquidityError(UFixed18 socializationFactor);
    error ProductDoubleSidedError();
    error ProductOverClosedError();
    error ProductInsufficientCollateralError();
    error ProductInLiquidationError();
    error ProductMakerOverLimitError();

    function provider() external view returns (IProductProvider);
    function initialize(IProductProvider provider_) external;
    function settle() external;
    function settleAccount(address account) external;
    function openTake(UFixed18 amount) external;
    function closeTake(UFixed18 amount) external;
    function openMake(UFixed18 amount) external;
    function closeMake(UFixed18 amount) external;
    function closeAll(address account) external;
    function maintenance(address account) external view returns (UFixed18);
    function maintenanceNext(address account) external view returns (UFixed18);
    function isClosed(address account) external view returns (bool);
    function isLiquidating(address account) external view returns (bool);
    function position(address account) external view returns (Position memory);
    function pre(address account) external view returns (PrePosition memory);
    function latestVersion() external view returns (uint256);
    function positionAtVersion(uint256 oracleVersion) external view returns (Position memory);
    function pre() external view returns (PrePosition memory);
    function valueAtVersion(uint256 oracleVersion) external view returns (Accumulator memory);
    function shareAtVersion(uint256 oracleVersion) external view returns (Accumulator memory);
    function latestVersion(address account) external view returns (uint256);
}",474
RealWorld_BA_60_VersionedAccumulator_RealWord_20240822095111.log,60,VersionedAccumulator,30552,6328,36880,87.0,0.27932,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""./Accumulator.sol"";
import ""../position/VersionedPosition.sol"";
import ""../ProductProvider.sol"";

/// @dev VersionedAccumulator type
struct VersionedAccumulator {
    /// @dev Latest synced oracle version
    uint256 latestVersion;

    /// @dev Mapping of accumulator value at each settled oracle version
    mapping(uint256 => Accumulator) valueAtVersion;

    /// @dev Mapping of accumulator share at each settled oracle version
    mapping(uint256 => Accumulator) shareAtVersion;
}

/**
 * @title VersionedAccumulatorLib
 * @notice Library that manages global versioned accumulator state.
 * @dev Manages two accumulators: value and share. The value accumulator measures the change in position value
 *      over time. The share accumulator measures the change in liquidity ownership over time (for tracking
 *      incentivization rewards).
 *
 *      Both accumulators are stamped for historical lookup anytime there is a global settlement, which services
 *      the delayed-position accounting. It is not guaranteed that every version will have a value stamped, but
 *      only versions when a settlement occurred are needed for this historical computation.
 */
library VersionedAccumulatorLib {
    using Fixed18Lib for Fixed18;
    using UFixed18Lib for UFixed18;
    using PositionLib for Position;
    using VersionedPositionLib for VersionedPosition;
    using AccumulatorLib for Accumulator;
    using ProductProviderLib for IProductProvider;

    /**
     * @notice Globally accumulates all value (position + funding) and share since last oracle update
     * @param self The struct to operate on
     * @param position Pointer to global position
     * @param factory The Factory contract of the protocol
     * @param provider The parameter provider of the product
     * @param toOracleVersion The oracle version to accumulate to
     * @return accumulatedFee The total fee accrued from accumulation
     */
    function accumulate(
        VersionedAccumulator storage self,
        VersionedPosition storage position,
        IFactory factory,
        IProductProvider provider,
        uint256 toOracleVersion
    ) internal returns (UFixed18 accumulatedFee) {
        // accumulate funding
        Accumulator memory accumulatedFunding;
        (accumulatedFunding, accumulatedFee) =
            accumulateFunding(self, position, factory, provider, toOracleVersion);

        // accumulate position
        Accumulator memory accumulatedPosition =
            accumulatePosition(self, position, provider, toOracleVersion);

        // accumulate share
        Accumulator memory accumulatedShare =
            accumulateShare(self, position, provider, toOracleVersion);

        // save update
        self.valueAtVersion[toOracleVersion] = self.valueAtVersion[self.latestVersion]
            .add(accumulatedFunding)
            .add(accumulatedPosition);
        self.shareAtVersion[toOracleVersion] = self.shareAtVersion[self.latestVersion].add(accumulatedShare);
        self.latestVersion = toOracleVersion;
    }

    /**
     * @notice Globally accumulates all funding since last oracle update
     * @dev If an oracle version is skipped due to no pre positions, funding will continue to be
     *      pegged to the price of the last snapshotted oracleVersion until a new one is accumulated.
     *      This is an acceptable approximation.
     * @param self The struct to operate on
     * @param position Pointer to global position
     * @param factory The Factory contract of the protocol
     * @param provider The parameter provider of the product
     * @param toOracleVersion The oracle version to accumulate to
     * @return accumulatedFunding The total amount accumulated from funding
     * @return accumulatedFee The total fee accrued from funding accumulation
     */
    function accumulateFunding(
        VersionedAccumulator storage self,
        VersionedPosition storage position,
        IFactory factory,
        IProductProvider provider,
        uint256 toOracleVersion
    ) private view returns (Accumulator memory accumulatedFunding, UFixed18 accumulatedFee) {
        Position memory p = position.position();
        if (p.taker.isZero()) return (Accumulator({maker: Fixed18Lib.ZERO, taker: Fixed18Lib.ZERO}), UFixed18Lib.ZERO);
        if (p.maker.isZero()) return (Accumulator({maker: Fixed18Lib.ZERO, taker: Fixed18Lib.ZERO}), UFixed18Lib.ZERO);

        uint256 elapsed = provider.timestampAtVersion(toOracleVersion) - provider.timestampAtVersion(self.latestVersion);

        UFixed18 takerNotional = Fixed18Lib.from(p.taker).mul(provider.priceAtVersion(self.latestVersion)).abs();
        UFixed18 socializedNotional = takerNotional.mul(p.socializationFactor());

        Fixed18 rateAccumulated = provider.rate(p).mul(Fixed18Lib.from(UFixed18Lib.from(elapsed)));
        Fixed18 fundingAccumulated = rateAccumulated.mul(Fixed18Lib.from(socializedNotional));
        accumulatedFee = fundingAccumulated.abs().mul(provider.safeFundingFee(factory));

        Fixed18 fundingIncludingFee = Fixed18Lib.from(
            fundingAccumulated.sign(),
            fundingAccumulated.abs().sub(accumulatedFee)
        );

        accumulatedFunding.maker = fundingIncludingFee.div(Fixed18Lib.from(p.maker));
        accumulatedFunding.taker = fundingIncludingFee.div(Fixed18Lib.from(p.taker)).mul(Fixed18Lib.NEG_ONE);
    }

    /**
     * @notice Globally accumulates position PNL since last oracle update
     * @param self The struct to operate on
     * @param position Pointer to global position
     * @param provider The parameter provider of the product
     * @param toOracleVersion The oracle version to accumulate to
     * @return accumulatedPosition The total amount accumulated from position PNL
     */
    function accumulatePosition(
        VersionedAccumulator storage self,
        VersionedPosition storage position,
        IProductProvider provider,
        uint256 toOracleVersion
    ) private view returns (Accumulator memory accumulatedPosition) {
        Position memory p = position.position();
        if (p.taker.isZero()) return Accumulator({maker: Fixed18Lib.ZERO, taker: Fixed18Lib.ZERO});
        if (p.maker.isZero()) return Accumulator({maker: Fixed18Lib.ZERO, taker: Fixed18Lib.ZERO});

        Fixed18 oracleDelta = provider.priceAtVersion(toOracleVersion).sub(provider.priceAtVersion(self.latestVersion));
        Fixed18 totalTakerDelta = oracleDelta.mul(Fixed18Lib.from(p.taker));
        Fixed18 socializedTakerDelta = totalTakerDelta.mul(Fixed18Lib.from(p.socializationFactor()));

        accumulatedPosition.maker = socializedTakerDelta.div(Fixed18Lib.from(p.maker)).mul(Fixed18Lib.NEG_ONE);
        accumulatedPosition.taker = socializedTakerDelta.div(Fixed18Lib.from(p.taker));
    }

    /**
     * @notice Globally accumulates position's share of the total market since last oracle update
     * @dev This is used to compute incentivization rewards based on market participation
     * @param self The struct to operate on
     * @param position Pointer to global position
     * @param provider The parameter provider of the product
     * @param toOracleVersion The oracle version to accumulate to
     * @return accumulatedShare The total share amount accumulated per position
     */
    function accumulateShare(
        VersionedAccumulator storage self,
        VersionedPosition storage position,
        IProductProvider provider,
        uint256 toOracleVersion
    ) private view returns (Accumulator memory accumulatedShare) {
        Position memory p = position.position();
        uint256 elapsed = provider.timestampAtVersion(toOracleVersion) - provider.timestampAtVersion(self.latestVersion);

        accumulatedShare.maker = p.maker.isZero() ? Fixed18Lib.ZERO : Fixed18Lib.from(UFixed18Lib.from(elapsed).div(p.maker));
        accumulatedShare.taker = p.taker.isZero() ? Fixed18Lib.ZERO : Fixed18Lib.from(UFixed18Lib.from(elapsed).div(p.taker));
    }
}",1727
RealWorld_BA_60_MockUFixed18_RealWord_20240822092844.log,60,MockUFixed18,13963,5924,19887,102.0,0.188295,"// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import ""../types/UFixed18.sol"";

contract MockUFixed18 {
    function zero() external pure returns (UFixed18) {
        return UFixed18Lib.ZERO;
    }

    function one() external pure returns (UFixed18) {
        return UFixed18Lib.ONE;
    }

    function from(Fixed18 a) external pure returns (UFixed18) {
        return UFixed18Lib.from(a);
    }

    function from(uint256 a) external pure returns (UFixed18) {
        return UFixed18Lib.from(a);
    }

    function isZero(UFixed18 a) external pure returns (bool) {
        return UFixed18Lib.isZero(a);
    }

    function add(UFixed18 a, UFixed18 b) external pure returns (UFixed18) {
        return UFixed18Lib.add(a, b);
    }

    function sub(UFixed18 a, UFixed18 b) external pure returns (UFixed18) {
        return UFixed18Lib.sub(a, b);
    }

    function mul(UFixed18 a, UFixed18 b) external pure returns (UFixed18) {
        return UFixed18Lib.mul(a, b);
    }

    function div(UFixed18 a, UFixed18 b) external pure returns (UFixed18) {
        return UFixed18Lib.div(a, b);
    }

    function eq(UFixed18 a, UFixed18 b) external pure returns (bool) {
        return UFixed18Lib.eq(a, b);
    }

    function gt(UFixed18 a, UFixed18 b) external pure returns (bool) {
        return UFixed18Lib.gt(a, b);
    }

    function lt(UFixed18 a, UFixed18 b) external pure returns (bool) {
        return UFixed18Lib.lt(a, b);
    }

    function gte(UFixed18 a, UFixed18 b) external pure returns (bool) {
        return UFixed18Lib.gte(a, b);
    }

    function lte(UFixed18 a, UFixed18 b) external pure returns (bool) {
        return UFixed18Lib.lte(a, b);
    }

    function compare(UFixed18 a, UFixed18 b) external pure returns (uint256) {
        return UFixed18Lib.compare(a, b);
    }

    function ratio(uint256 a, uint256 b) external pure returns (UFixed18) {
        return UFixed18Lib.ratio(a, b);
    }

    function min(UFixed18 a, UFixed18 b) external pure returns (UFixed18) {
        return UFixed18Lib.min(a, b);
    }

    function max(UFixed18 a, UFixed18 b) external pure returns (UFixed18) {
        return UFixed18Lib.max(a, b);
    }

    function truncate(UFixed18 a) external pure returns (uint256) {
        return UFixed18Lib.truncate(a);
    }
}",639
RealWorld_BA_60_ProgramInfo_RealWord_20240822100336.log,60,ProgramInfo,15283,5220,20503,75.0,0.180815,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""../../interfaces/IProduct.sol"";
import ""../../product/types/position/Position.sol"";
import ""../../product/types/accumulator/Accumulator.sol"";
import ""../../utils/types/Token18.sol"";

struct ProgramInfo {
    /// @dev Product market contract to be incentivized
    IProduct product;

    /// @dev Amount of total maker and taker rewards
    Position amount;

    /// @dev start timestamp of the program
    uint256 start;

    /// @dev duration of the program (in seconds)
    uint256 duration;

    /// @dev grace period the program where funds can still be claimed (in seconds)
    uint256 grace;

    /// @dev Reward ERC20 token contract
    Token18 token;
}

library ProgramInfoLib {
    using UFixed18Lib for UFixed18;
    using PositionLib for Position;

    uint256 private constant MIN_DURATION = 1 days;
    uint256 private constant MAX_DURATION = 2 * 365 days;
    uint256 private constant MIN_GRACE = 7 days;
    uint256 private constant MAX_GRACE = 30 days;

    error ProgramAlreadyStartedError();
    error ProgramInvalidDurationError();
    error ProgramInvalidGraceError();

    /**
     * @notice Validates and creates a new Program
     * @param fee Global Incentivizer fee
     * @param info Un-sanitized static program information
     * @return programInfo Validated static program information with fee excluded
     * @return programFee Fee amount for the program
     */
    function create(UFixed18 fee, ProgramInfo memory info)
    internal view returns (ProgramInfo memory programInfo, UFixed18 programFee) {
        if (isStarted(info, block.timestamp)) revert ProgramAlreadyStartedError();
        if (info.duration < MIN_DURATION || info.duration > MAX_DURATION) revert ProgramInvalidDurationError();
        if (info.grace < MIN_GRACE || info.grace > MAX_GRACE) revert ProgramInvalidGraceError();

        Position memory amountAfterFee = info.amount.mul(UFixed18Lib.ONE.sub(fee));

        programInfo = ProgramInfo({
            start: info.start,
            duration: info.duration,
            grace: info.grace,

            product: info.product,
            token: info.token,
            amount: amountAfterFee
        });
        programFee = info.amount.sub(amountAfterFee).sum();
    }

    /**
     * @notice Returns the maker and taker amounts per position share
     * @param self The ProgramInfo to operate on
     * @return programFee Amounts per share
     */
    function amountPerShare(ProgramInfo memory self) internal pure returns (Accumulator memory) {
        return self.amount.div(self.duration);
    }

    /**
     * @notice Returns whether the program has started by timestamp `timestamp`
     * @param self The ProgramInfo to operate on
     * @param timestamp Timestamp to check for
     * @return Whether the program has started
     */
    function isStarted(ProgramInfo memory self, uint256 timestamp) internal pure returns (bool) {
        return timestamp >= self.start;
    }

    /**
     * @notice Returns whether the program is completed by timestamp `timestamp`
     * @param self The ProgramInfo to operate on
     * @param timestamp Timestamp to check for
     * @return Whether the program is completed
     */
    function isComplete(ProgramInfo memory self, uint256 timestamp) internal pure returns (bool) {
        return timestamp >= (self.start + self.duration);
    }
}",742
RealWorld_BA_60_UFactoryProvider_RealWord_20240822100734.log,60,UFactoryProvider,12851,5609,18460,76.0,0.176435,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""../interfaces/IFactory.sol"";
import ""../interfaces/IProduct.sol"";

/**
 * @title UFactoryProvider
 * @notice Mix-in that manages a factory pointer and associated permissioning modifiers.
 * @dev Uses unstructured storage so that it is safe to mix-in to upgreadable contracts without modifying
 *      their storage layout.
 */
abstract contract UFactoryProvider {
    error AlreadyInitializedError();
    error NotOwnerError(address sender);
    error NotProductError(address sender);
    error NotCollateralError(address sender);
    error NotControllerOwnerError(address sender, uint256 controllerId);
    error NotProductOwnerError(address sender, IProduct product);
    error PausedError();

    /// @dev unstructured storage slot for the factory address
    bytes32 private constant FACTORY_SLOT = keccak256(""equilibria.perennial.UFactoryProvider.factory"");

    /**
     * @notice Initializes the contract state
     * @param factory_ Protocol Factory contract address
     */
    function UFactoryProvider__initialize(IFactory factory_) internal {
        if (address(factory()) != address(0)) revert AlreadyInitializedError();

        _setFactory(factory_);
    }

    /**
     * @notice Reads the protocol Factory contract address from unstructured state
     * @return result Protocol Factory contract address
     */
    function factory() public view virtual returns (IFactory result) {
        bytes32 slot = FACTORY_SLOT;
        assembly {
            result := sload(slot)
        }
    }

    /**
     * @notice Sets the protocol Factory contract address in unstructured state
     * @dev Internal helper
     */
    function _setFactory(IFactory newFactory) private {
        bytes32 slot = FACTORY_SLOT;
        assembly {
            sstore(slot, newFactory)
        }
    }

    /// @dev Only allow a valid product contract to call
    modifier onlyProduct {
        if (!factory().isProduct(IProduct(msg.sender))) revert NotProductError(msg.sender);

        _;
    }

    /// @dev Verify that `product` is a valid product contract
    modifier isProduct(IProduct product) {
        if (!factory().isProduct(product)) revert NotProductError(address(product));

        _;
    }

    /// @dev Only allow the Collateral contract to call
    modifier onlyCollateral {
        if (msg.sender != address(factory().collateral())) revert NotCollateralError(msg.sender);

        _;
    }

    /// @dev Only allow the protocol owner contract to call
    modifier onlyOwner() {
        if (msg.sender != factory().owner()) revert NotOwnerError(msg.sender);

        _;
    }

    /// @dev Only allow if the the protocol is currently unpaused
    modifier notPaused() {
        if (factory().isPaused()) revert PausedError();

        _;
    }
}",598
RealWorld_BA_60_ChainlinkOracle_RealWord_20240822092517.log,60,ChainlinkOracle,13782,6065,19847,100.0,0.19021,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.10;

import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""../interfaces/IOracle.sol"";
import ""../utils/types/UFixed18.sol"";
import ""../utils/unstructured/UOwnable.sol"";

/**
 * @title ChainlinkOracle
 * @notice Chainlink implementation of the IOracle interface.
 * @dev One instance per Chainlink price feed should be deployed. Multiple products may use the same
 *      ChainlinkOracle instance if their payoff functions are based on the same underlying oracle.
 */
contract ChainlinkOracle is IOracle, UOwnable {

    event MinDelayUpdated(uint256 newMinDelay);

    /// @dev Chainlink price feed to read from
    IChainlinkFeed public feed;

    /// @dev Mapping of historical price at each oracle version
    Fixed18[] public priceAtVersion;

    /// @dev Mapping of historical timestamp at each oracle version
    uint256[] public timestampAtVersion;

    /// @dev Decimal offset used to normalize chainlink price to 18 decimals
    uint256 private _decimalOffset;

    /// @dev Minimum timestamp delay before committed a new version
    uint256 public minDelay;

    /**
     * @notice Initializes the contract state
     * @param feed_ Chainlink price feed
     */
    constructor(IChainlinkFeed feed_) {
        feed = feed_;
        _decimalOffset = 10 ** feed_.decimals();
        minDelay = 30 minutes;

        sync();
        UOwnable__initialize();
    }

    /**
     * @notice Checks for a new price and updates the oracle version if one is found
     */
    function sync() public {
        (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();
        Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));

        if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {
            priceAtVersion.push(price);
            timestampAtVersion.push(timestamp);

            emit Version(currentVersion(), timestamp, price);
        }
    }

    /**
     * @notice Returns the current oracle version
     * @return Current oracle version
     */
    function currentVersion() public view returns (uint256) {
        return priceAtVersion.length - 1;
    }

    /**
     * @notice Updates the minimum delay before a new version can be committed
     * @param newMinDelay New minimum delay
     */
    function updateMinDelay(uint256 newMinDelay) onlyOwner external {
        minDelay = newMinDelay;
        emit MinDelayUpdated(newMinDelay);
    }
}

interface IChainlinkFeed {
    function decimals() external view returns (uint8);
    function latestRoundData() external view returns (
        uint80 roundID,
        int price,
        uint startedAt,
        uint timeStamp,
        uint80 answeredInRound
    );
}",614
RealWorld_BA_60_Collateral_RealWord_20240822095908.log,60,Collateral,36223,5637,41860,84.0,0.293855,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""../interfaces/ICollateral.sol"";
import ""./types/OptimisticLedger.sol"";
import ""../utils/unstructured/UReentrancyGuard.sol"";
import ""../factory/UFactoryProvider.sol"";

/**
 * @title Collateral
 * @notice Manages logic and state for all collateral accounts in the protocol.
 */
contract Collateral is ICollateral, UFactoryProvider, UReentrancyGuard {
    using UFixed18Lib for UFixed18;
    using Token18Lib for Token18;
    using OptimisticLedgerLib for OptimisticLedger;

    /// @dev ERC20 stablecoin for collateral
    Token18 public token;

    /// @dev Fee on maintenance for liquidation
    UFixed18 public liquidationFee;

    /// @dev Per product collateral state
    mapping(IProduct => OptimisticLedger) private _products;

    /// @dev Protocol and product fees collected, but not yet claimed
    mapping(address => UFixed18) public fees;

    /**
     * @notice Initializes the contract state
     * @param factory_ Factory contract address
     * @param token_ Collateral ERC20 stablecoin address
     */
    function initialize(IFactory factory_, Token18 token_) external {
        UFactoryProvider__initialize(factory_);
        UReentrancyGuard__initialize();

        token = token_;
        liquidationFee = UFixed18Lib.ratio(50, 100);
    }

    /**
     * @notice Deposits `amount` collateral from `msg.sender` to `account`'s `product`
     *         account
     * @param account Account to deposit the collateral for
     * @param product Product to credit the collateral to
     * @param amount Amount of collateral to deposit
     */
    function depositTo(address account, IProduct product, UFixed18 amount)
    notPaused
    collateralInvariant(account, product)
    external {
        _products[product].creditAccount(account, amount);
        token.pull(msg.sender, amount);

        emit Deposit(account, product, amount);
    }

    /**
     * @notice Withdraws `amount` collateral from `msg.sender`'s `product` account
     *         and sends it to `account`
     * @param account Account to withdraw the collateral to
     * @param product Product to withdraw the collateral from
     * @param amount Amount of collateral to withdraw
     */
    function withdrawTo(address account, IProduct product, UFixed18 amount)
    notPaused
    collateralInvariant(msg.sender, product)
    maintenanceInvariant(msg.sender, product)
    external {
        _products[product].debitAccount(msg.sender, amount);
        token.push(account, amount);

        emit Withdrawal(msg.sender, product, amount);
    }

    /**
     * @notice Liquidates `account`'s `product` collateral account
     * @dev Account must be under-collateralized, fee returned immediately to `msg.sender`
     * @param account Account to liquidate
     * @param product Product to liquidate for
     */
    function liquidate(address account, IProduct product) notPaused nonReentrant external {
        // settle
        product.settle();
        product.settleAccount(account);

        // liquidate
        UFixed18 totalMaintenance = product.maintenance(account);
        UFixed18 totalCollateral = collateral(account, product);

        if (!totalMaintenance.gt(totalCollateral))
            revert CollateralCantLiquidate(totalMaintenance, totalCollateral);

        product.closeAll(account);

        // claim fee
        UFixed18 fee = UFixed18Lib.min(totalCollateral, totalMaintenance.mul(liquidationFee));

        _products[product].debitAccount(account, fee);
        token.push(msg.sender, fee);

        emit Liquidation(account, product, msg.sender, fee);
    }

    /**
     * @notice Credits `amount` to `account`'s collateral account
     * @dev Callable only by the corresponding product as part of the settlement flywheel.
     *      Moves collateral within a product, any collateral leaving the product due to
     *      fees has already been accounted for in the settleProduct flywheel.
     *      Debits in excess of the account balance get recorded as shortfall, and can be
     *      resolved by the product owner as needed.
     * @param account Account to credit
     * @param amount Amount to credit the account (can be negative)
     */
    function settleAccount(address account, Fixed18 amount) onlyProduct external {
        IProduct product = IProduct(msg.sender);

        UFixed18 newShortfall = _products[product].settleAccount(account, amount);

        emit AccountSettle(product, account, amount, newShortfall);
    }

    /**
     * @notice Debits `amount` from product's total collateral account
     * @dev Callable only by the corresponding product as part of the settlement flywheel
     *      Removes collateral from the product as fees.
     * @param amount Amount to debit from the account
     */
    function settleProduct(UFixed18 amount) onlyProduct external {
        IProduct product = IProduct(msg.sender);

        address protocolTreasury = factory().treasury();
        address productTreasury = factory().treasury(product);

        UFixed18 protocolFee = amount.mul(factory().fee());
        UFixed18 productFee = amount.sub(protocolFee);

        _products[product].debit(amount);
        fees[protocolTreasury] = fees[protocolTreasury].add(protocolFee);
        fees[productTreasury] = fees[productTreasury].add(productFee);

        emit ProductSettle(product, protocolFee, productFee);
    }

    /**
     * @notice Returns the balance of `account`'s `product` collateral account
     * @param account Account to return for
     * @param product Product to return for
     * @return The balance of the collateral account
     */
    function collateral(address account, IProduct product) public view returns (UFixed18) {
        return _products[product].balances[account];
    }

    /**
     * @notice Returns the total balance of `product`'s collateral
     * @param product Product to return for
     * @return The total balance of collateral in the product
     */
    function collateral(IProduct product) public view returns (UFixed18) {
        return _products[product].total;
    }

    /**
     * @notice Returns the current shortfall of `product`'s collateral
     * @param product Product to return for
     * @return The current shortfall of the product
     */
    function shortfall(IProduct product) public view returns (UFixed18) {
        return _products[product].shortfall;
    }

    /**
     * @notice Returns whether `account`'s `product` collateral account can be liquidated
     * @param account Account to return for
     * @param product Product to return for
     * @return Whether the account can be liquidated
     */
    function liquidatable(address account, IProduct product) external view returns (bool) {
        return product.maintenance(account).gt(collateral(account, product));
    }

    /**
     * @notice Returns whether `account`'s `product` collateral account can be liquidated
     *         after the next oracle version settlement
     * @dev Takes into account the current pre-position on the account
     * @param account Account to return for
     * @param product Product to return for
     * @return Whether the account can be liquidated
     */
    function liquidatableNext(address account, IProduct product) external view returns (bool) {
        return product.maintenanceNext(account).gt(collateral(account, product));
    }

    /**
     * @notice Injects additional collateral into a product to resolve shortfall
     * @dev Shortfall is a measure of settled insolvency in the market
     *      This hook can be used by the product owner or an insurance fund to re-capitalize an insolvent market
     * @param product Product to resolve shortfall for
     * @param amount Amount of shortfall to resolve
     */
    function resolveShortfall(IProduct product, UFixed18 amount) notPaused external {
        _products[product].resolve(amount);
        token.pull(msg.sender, amount);

        emit ShortfallResolution(product, amount);
    }

    /**
     * @notice Claims all of `msg.sender`'s fees
     */
    function claimFee() notPaused external {
        UFixed18 amount = fees[msg.sender];

        fees[msg.sender] = UFixed18Lib.ZERO;
        token.push(msg.sender, amount);

        emit FeeClaim(msg.sender, amount);
    }

    /**
     * @notice Updates the liquidation fee
     * @param newLiquidationFee New liquidation fee
     */
    function updateLiquidationFee(UFixed18 newLiquidationFee) onlyOwner external {
        liquidationFee = newLiquidationFee;
        emit LiquidationFeeUpdated(newLiquidationFee);
    }

    /// @dev Ensure that the user has sufficient margin for both current and next maintenance
    modifier maintenanceInvariant(address account, IProduct product) {
        _;

        UFixed18 maintenance = product.maintenance(account);
        UFixed18 maintenanceNext = product.maintenanceNext(account);

        if (UFixed18Lib.max(maintenance, maintenanceNext).gt(collateral(account, product)))
            revert CollateralInsufficientCollateralError();
    }

    /// @dev Ensure that the account is either empty or above the collateral minimum
    modifier collateralInvariant(address account, IProduct product) {
        _;

        UFixed18 accountCollateral = collateral(account, product);
        if (!accountCollateral.isZero() && accountCollateral.lt(factory().minCollateral()))
            revert CollateralUnderLimitError();
    }
}",2053
RealWorld_BA_60_Position_RealWord_20240822094717.log,60,Position,25479,5487,30966,75.0,0.237135,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""@openzeppelin/contracts/utils/math/Math.sol"";
import ""../../../utils/types/UFixed18.sol"";
import ""../accumulator/Accumulator.sol"";
import ""./PrePosition.sol"";

/// @dev Position type
struct Position {
    /// @dev Quantity of the maker position
    UFixed18 maker;
    /// @dev Quantity of the taker position
    UFixed18 taker;
}

/**
 * @title PositionLib
 * @notice Library that surfaces math and settlement computations for the Position type.
 * @dev Positions track the current quantity of the account's maker and taker positions respectively
 *      denominated as a unit of the product's payoff function.
 */
library PositionLib {
    using UFixed18Lib for UFixed18;
    using Fixed18Lib for Fixed18;
    using PrePositionLib for PrePosition;

    function isEmpty(Position memory self) internal pure returns (bool) {
        return self.maker.isZero() && self.taker.isZero();
    }

    /**
     * @notice Adds position `a` and `b` together, returning the result
     * @param a The first position to sum
     * @param b The second position to sum
     * @return Resulting summed position
     */
    function add(Position memory a, Position memory b) internal pure returns (Position memory) {
        return Position({maker: a.maker.add(b.maker), taker: a.taker.add(b.taker)});
    }

    /**
     * @notice Subtracts position `b` from `a`, returning the result
     * @param a The position to subtract from
     * @param b The position to subtract
     * @return Resulting subtracted position
     */
    function sub(Position memory a, Position memory b) internal pure returns (Position memory) {
        return Position({maker: a.maker.sub(b.maker), taker: a.taker.sub(b.taker)});
    }

    /**
     * @notice Multiplies position `self` by accumulator `accumulator` and returns the resulting accumulator
     * @param self The Position to operate on
     * @param accumulator The accumulator to multiply by
     * @return Resulting multiplied accumulator
     */
    function mul(Position memory self, Accumulator memory accumulator) internal pure returns (Accumulator memory) {
        return Accumulator({
            maker: Fixed18Lib.from(self.maker).mul(accumulator.maker),
            taker: Fixed18Lib.from(self.taker).mul(accumulator.taker)
        });
    }

    /**
     * @notice Scales position `self` by fixed-decimal `scale` and returns the resulting position
     * @param self The Position to operate on
     * @param scale The Fixed-decimal to scale by
     * @return Resulting scaled position
     */
    function mul(Position memory self, UFixed18 scale) internal pure returns (Position memory) {
        return Position({maker: self.maker.mul(scale), taker: self.taker.mul(scale)});
    }

    /**
     * @notice Divides position `self` by `b` and returns the resulting accumulator
     * @param self The Position to operate on
     * @param b The number to divide by
     * @return Resulting divided accumulator
     */
    function div(Position memory self, uint256 b) internal pure returns (Accumulator memory) {
        return Accumulator({
            maker: Fixed18Lib.from(self.maker).div(Fixed18Lib.from(UFixed18Lib.from(b))),
            taker: Fixed18Lib.from(self.taker).div(Fixed18Lib.from(UFixed18Lib.from(b)))
        });
    }

    /**
     * @notice Returns the maximum of `self`'s maker and taker values
     * @param self The struct to operate on
     * @return Resulting maximum value
     */
    function max(Position memory self) internal pure returns (UFixed18) {
        return UFixed18Lib.max(self.maker, self.taker);
    }

    /**
     * @notice Sums the maker and taker together from a single position
     * @param self The struct to operate on
     * @return The sum of its maker and taker
     */
    function sum(Position memory self) internal pure returns (UFixed18) {
        return self.maker.add(self.taker);
    }

    /**
     * @notice Computes the next position after the pending-settlement position delta is included
     * @param self The current Position
     * @param pre The pending-settlement position delta
     * @return Next Position
     */
    function next(Position memory self, PrePosition memory pre) internal pure returns (Position memory) {
        return sub(add(self, pre.openPosition), pre.closePosition);
    }

    /**
     * @notice Returns the settled position at oracle version `toOracleVersion`
     * @dev Checks if a new position is ready to be settled based on the provided `toOracleVersion`
     *      and `pre` and returns accordingly
     * @param self The current Position
     * @param pre The pending-settlement position delta
     * @param provider The parameter provider of the product
     * @param toOracleVersion The oracle version to settle to
     * @return Settled position at oracle version
     * @return Fee accrued from opening or closing the position
     * @return Whether a new position was settled
     */
    function settled(Position memory self, PrePosition memory pre, IProductProvider provider, uint256 toOracleVersion) internal view returns (Position memory, UFixed18, bool) {
        return pre.canSettle(toOracleVersion) ? (next(self, pre), pre.computeFee(provider, toOracleVersion), true) : (self, UFixed18Lib.ZERO, false);
    }

    /**
     * @notice Returns the socialization factor for the current position
     * @dev Socialization account for the case where `taker` > `maker` temporarily due to a liquidation
     *      on the maker side. This dampens the taker's exposure pro-rata to ensure that the maker side
     *      is never exposed over 1 x short.
     * @param self The Position to operate on
     * @return Socialization factor
     */
    function socializationFactor(Position memory self) internal pure returns (UFixed18) {
        return self.taker.isZero() ? UFixed18Lib.ONE : UFixed18Lib.min(UFixed18Lib.ONE, self.maker.div(self.taker));
    }
}",1386
RealWorld_BA_60_Fixed18_RealWord_20240822093538.log,60,Fixed18,37103,4991,42094,83.0,0.285335,"// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import ""./UFixed18.sol"";

/// @dev Fixed18 type
type Fixed18 is int256;

/**
 * @title Fixed18Lib
 * @notice Library for the signed fixed-decimal type.
 */
library Fixed18Lib {
    error Fixed18OverflowError(uint256 value);

    int256 private constant BASE = 1e18;
    Fixed18 public constant ZERO = Fixed18.wrap(0);
    Fixed18 public constant ONE = Fixed18.wrap(BASE);
    Fixed18 public constant NEG_ONE = Fixed18.wrap(-1 * BASE);

    /**
     * @notice Creates a signed fixed-decimal from an unsigned fixed-decimal
     * @param a Unsigned fixed-decimal
     * @return New signed fixed-decimal
     */
    function from(UFixed18 a) internal pure returns (Fixed18) {
        uint256 value = UFixed18.unwrap(a);
        if (value > uint256(type(int256).max)) revert Fixed18OverflowError(value);
        return Fixed18.wrap(int256(value));
    }

    /**
     * @notice Creates a signed fixed-decimal from a sign and an unsigned fixed-decimal
     * @param s Sign
     * @param m Unsigned fixed-decimal magnitude
     * @return New signed fixed-decimal
     */
    function from(int256 s, UFixed18 m) internal pure returns (Fixed18) {
        if (s > 0) return from(m);
        if (s < 0) return mul(from(m), NEG_ONE);
        return ZERO;
    }

    /**
     * @notice Creates a signed fixed-decimal from a signed integer
     * @param a Signed number
     * @return New signed fixed-decimal
     */
    function from(int256 a) internal pure returns (Fixed18) {
        return Fixed18.wrap(a * BASE);
    }

    /**
     * @notice Returns whether the signed fixed-decimal is equal to zero.
     * @param a Signed fixed-decimal
     * @return Whether the signed fixed-decimal is zero.
     */
    function isZero(Fixed18 a) internal pure returns (bool) {
        return Fixed18.unwrap(a) == 0;
    }

    /**
     * @notice Adds two signed fixed-decimals `a` and `b` together
     * @param a First signed fixed-decimal
     * @param b Second signed fixed-decimal
     * @return Resulting summed signed fixed-decimal
     */
    function add(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {
        return Fixed18.wrap(Fixed18.unwrap(a) + Fixed18.unwrap(b));
    }

    /**
     * @notice Subtracts signed fixed-decimal `b` from `a`
     * @param a Signed fixed-decimal to subtract from
     * @param b Signed fixed-decimal to subtract
     * @return Resulting subtracted signed fixed-decimal
     */
    function sub(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {
        return Fixed18.wrap(Fixed18.unwrap(a) - Fixed18.unwrap(b));
    }

    /**
     * @notice Multiplies two signed fixed-decimals `a` and `b` together
     * @param a First signed fixed-decimal
     * @param b Second signed fixed-decimal
     * @return Resulting multiplied signed fixed-decimal
     */
    function mul(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {
        return Fixed18.wrap(Fixed18.unwrap(a) * Fixed18.unwrap(b) / BASE);
    }

    /**
     * @notice Divides signed fixed-decimal `a` by `b`
     * @param a Signed fixed-decimal to divide
     * @param b Signed fixed-decimal to divide by
     * @return Resulting subtracted signed fixed-decimal
     */
    function div(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {
        return Fixed18.wrap(Fixed18.unwrap(a) * BASE / Fixed18.unwrap(b));
    }

    /**
     * @notice Returns whether signed fixed-decimal `a` is equal to `b`
     * @param a First signed fixed-decimal
     * @param b Second signed fixed-decimal
     * @return Whether `a` is equal to `b`
     */
    function eq(Fixed18 a, Fixed18 b) internal pure returns (bool) {
        return compare(a, b) == 1;
    }

    /**
     * @notice Returns whether signed fixed-decimal `a` is greater than `b`
     * @param a First signed fixed-decimal
     * @param b Second signed fixed-decimal
     * @return Whether `a` is greater than `b`
     */
    function gt(Fixed18 a, Fixed18 b) internal pure returns (bool) {
        return compare(a, b) == 2;
    }

    /**
     * @notice Returns whether signed fixed-decimal `a` is less than `b`
     * @param a First signed fixed-decimal
     * @param b Second signed fixed-decimal
     * @return Whether `a` is less than `b`
     */
    function lt(Fixed18 a, Fixed18 b) internal pure returns (bool) {
        return compare(a, b) == 0;
    }

    /**
     * @notice Returns whether signed fixed-decimal `a` is greater than or equal to `b`
     * @param a First signed fixed-decimal
     * @param b Second signed fixed-decimal
     * @return Whether `a` is greater than or equal to `b`
     */
    function gte(Fixed18 a, Fixed18 b) internal pure returns (bool) {
        return gt(a, b) || eq(a, b);
    }

    /**
     * @notice Returns whether signed fixed-decimal `a` is less than or equal to `b`
     * @param a First signed fixed-decimal
     * @param b Second signed fixed-decimal
     * @return Whether `a` is less than or equal to `b`
     */
    function lte(Fixed18 a, Fixed18 b) internal pure returns (bool) {
        return lt(a, b) || eq(a, b);
    }

    /**
     * @notice Compares the signed fixed-decimals `a` and `b`
     * @dev Returns: 2 for greater than
     *               1 for equal to
     *               0 for less than
     * @param a First signed fixed-decimal
     * @param b Second signed fixed-decimal
     * @return Compare result of `a` and `b`
     */
    function compare(Fixed18 a, Fixed18 b) internal pure returns (uint256) {
        (int256 au, int256 bu) = (Fixed18.unwrap(a), Fixed18.unwrap(b));
        if (au > bu) return 2;
        if (au < bu) return 0;
        return 1;
    }

    /**
     * @notice Returns a signed fixed-decimal representing the ratio of `a` over `b`
     * @param a First signed number
     * @param b Second signed number
     * @return Ratio of `a` over `b`
     */
    function ratio(int256 a, int256 b) internal pure returns (Fixed18) {
        return Fixed18.wrap(a * BASE / b);
    }

    /**
     * @notice Returns the minimum of signed fixed-decimals `a` and `b`
     * @param a First signed fixed-decimal
     * @param b Second signed fixed-decimal
     * @return Minimum of `a` and `b`
     */
    function min(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {
        (int256 au, int256 bu) = (Fixed18.unwrap(a), Fixed18.unwrap(b));
        return Fixed18.wrap(au < bu ? au : bu);
    }

    /**
     * @notice Returns the maximum of signed fixed-decimals `a` and `b`
     * @param a First signed fixed-decimal
     * @param b Second signed fixed-decimal
     * @return Maximum of `a` and `b`
     */
    function max(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {
        (int256 au, int256 bu) = (Fixed18.unwrap(a), Fixed18.unwrap(b));
        return Fixed18.wrap(au > bu ? au : bu);
    }

    /**
     * @notice Converts the signed fixed-decimal into an integer, truncating any decimal portion
     * @param a Signed fixed-decimal
     * @return Truncated signed number
     */
    function truncate(Fixed18 a) internal pure returns (int256) {
        return Fixed18.unwrap(a) / BASE;
    }

    /**
     * @notice Returns the sign of the signed fixed-decimal
     * @dev Returns: -1 for negative
     *                0 for zero
     *                1 for positive
     * @param a Signed fixed-decimal
     * @return Sign of the signed fixed-decimal
     */
    function sign(Fixed18 a) internal pure returns (int256) {
        if (Fixed18.unwrap(a) > 0) return 1;
        if (Fixed18.unwrap(a) < 0) return -1;
        return 0;
    }

    /**
     * @notice Returns the absolute value of the signed fixed-decimal
     * @param a Signed fixed-decimal
     * @return Absolute value of the signed fixed-decimal
     */
    function abs(Fixed18 a) internal pure returns (UFixed18) {
        return sign(a) == -1 ? UFixed18Lib.from(mul(a, NEG_ONE)) : UFixed18Lib.from(a);
    }
}",2105
RealWorld_BA_60_Squeeth_RealWord_20240822095746.log,60,Squeeth,9378,5328,14706,79.0,0.15345,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.10;

import ""../product/ProductProviderBase.sol"";

contract Squeeth is ProductProviderBase {
    using UFixed18Lib for UFixed18;
    using Fixed18Lib for Fixed18;

    constructor(IOracle oracle) ProductProviderBase(oracle) { }

    // Implementation

    function rate(Position memory position) external pure override returns (Fixed18) {
        if (position.maker.isZero()) return Fixed18Lib.ZERO;

        UFixed18 utilization = position.taker.div(position.maker);
        UFixed18 capped = UFixed18Lib.min(utilization, UFixed18Lib.ONE);
        Fixed18 centered = (Fixed18Lib.from(capped).sub(Fixed18Lib.ratio(1, 2))).mul(Fixed18Lib.from(2));

        return centered.div(Fixed18Lib.from(365 days));
    }

    function payoff(Fixed18 price) public pure override returns (Fixed18) {
        return price.mul(price);
    }

    function maintenance() external pure override returns (UFixed18) {
        return UFixed18Lib.ratio(30, 100);
    }

    function fundingFee() external pure override returns (UFixed18) {
        return UFixed18Lib.ratio(10, 100);
    }

    function makerFee() external pure override returns (UFixed18) {
        return UFixed18Lib.ZERO;
    }

    function takerFee() external pure override returns (UFixed18) {
        return UFixed18Lib.ZERO;
    }

    function makerLimit() external pure override returns (UFixed18) {
        return UFixed18Lib.from(1);
    }
}",355
RealWorld_BA_60_ICollateral_RealWord_20240822101424.log,60,ICollateral,11175,5592,16767,90.0,0.167715,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.10;

import ""./IProduct.sol"";
import ""../utils/types/UFixed18.sol"";
import ""../utils/types/Fixed18.sol"";
import ""../utils/types/Token18.sol"";

interface ICollateral {
    event Deposit(address indexed user, IProduct indexed product, UFixed18 amount);
    event Withdrawal(address indexed user, IProduct indexed product, UFixed18 amount);
    event AccountSettle(IProduct indexed product, address indexed account, Fixed18 amount, UFixed18 newShortfall);
    event ProductSettle(IProduct indexed product, UFixed18 protocolFee, UFixed18 productFee);
    event Liquidation(address indexed user, IProduct indexed product, address liquidator, UFixed18 fee);
    event ShortfallResolution(IProduct indexed product, UFixed18 amount);
    event LiquidationFeeUpdated(UFixed18 newLiquidationFeeUpdated);
    event FeeClaim(address indexed account, UFixed18 amount);

    error CollateralCantLiquidate(UFixed18 totalMaintenance, UFixed18 totalCollateral);
    error CollateralInsufficientCollateralError();
    error CollateralUnderLimitError();

    function token() external view returns (Token18);
    function liquidationFee() external view returns (UFixed18);
    function fees(address account) external view returns (UFixed18);
    function initialize(IFactory factory_, Token18 token_) external;
    function depositTo(address account, IProduct product, UFixed18 amount) external;
    function withdrawTo(address account, IProduct product, UFixed18 amount) external;
    function liquidate(address account, IProduct product) external;
    function settleAccount(address account, Fixed18 amount) external;
    function settleProduct(UFixed18 amount) external;
    function collateral(address account, IProduct product) external view returns (UFixed18);
    function collateral(IProduct product) external view returns (UFixed18);
    function shortfall(IProduct product) external view returns (UFixed18);
    function liquidatable(address account, IProduct product) external view returns (bool);
    function liquidatableNext(address account, IProduct product) external view returns (bool);
    function resolveShortfall(IProduct product, UFixed18 amount) external;
    function claimFee() external;
    function updateLiquidationFee(UFixed18 newLiquidationFee) external;
}",492
RealWorld_BA_60_MockToken18_RealWord_20240822092700.log,60,MockToken18,8856,5084,13940,102.0,0.14596,"// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import ""../types/Token18.sol"";

contract MockToken18 {
    function etherToken() external pure returns (Token18) {
        return Token18Lib.ETHER;
    }

    function isEther(Token18 token) external pure returns (bool) {
        return Token18Lib.isEther(token);
    }

    function push(Token18 self, address recipient) external {
        Token18Lib.push(self, recipient);
    }

    function push(Token18 self, address recipient, UFixed18 amount) external {
        Token18Lib.push(self, recipient, amount);
    }

    function pull(Token18 self, address benefactor, UFixed18 amount) external {
        Token18Lib.pull(self, benefactor, amount);
    }

    function pullTo(Token18 self, address benefactor, address recipient, UFixed18 amount) external {
        Token18Lib.pullTo(self, benefactor, recipient, amount);
    }

    function name(Token18 self) external view returns (string memory) {
        return Token18Lib.name(self);
    }

    function symbol(Token18 self) external view returns (string memory) {
        return Token18Lib.symbol(self);
    }

    function decimals(Token18 self) external view returns (uint8) {
        return Token18Lib.decimals(self);
    }

    function balanceOf(Token18 self) external view returns (UFixed18) {
        return Token18Lib.balanceOf(self);
    }

    function balanceOf(Token18 self, address account) external view returns (UFixed18) {
        return Token18Lib.balanceOf(self, account);
    }

    receive() external payable { }
}",351
RealWorld_BA_60_UFixed18_RealWord_20240822093703.log,60,UFixed18,32553,6048,38601,91.0,0.283725,"// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import ""./Fixed18.sol"";

/// @dev UFixed18 type
type UFixed18 is uint256;

/**
 * @title UFixed18Lib
 * @notice Library for the unsigned fixed-decimal type.
 */
library UFixed18Lib {
    error UFixed18UnderflowError(int256 value);

    uint256 private constant BASE = 1e18;
    UFixed18 public constant ZERO = UFixed18.wrap(0);
    UFixed18 public constant ONE = UFixed18.wrap(BASE);

    /**
     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal
     * @param a Signed fixed-decimal
     * @return New unsigned fixed-decimal
     */
    function from(Fixed18 a) internal pure returns (UFixed18) {
        int256 value = Fixed18.unwrap(a);
        if (value < 0) revert UFixed18UnderflowError(value);
        return UFixed18.wrap(uint256(value));
    }

    /**
     * @notice Creates a unsigned fixed-decimal from a unsigned integer
     * @param a Unsigned number
     * @return New unsigned fixed-decimal
     */
    function from(uint256 a) internal pure returns (UFixed18) {
        return UFixed18.wrap(a * BASE);
    }

    /**
     * @notice Returns whether the unsigned fixed-decimal is equal to zero.
     * @param a Unsigned fixed-decimal
     * @return Whether the unsigned fixed-decimal is zero.
     */
    function isZero(UFixed18 a) internal pure returns (bool) {
        return UFixed18.unwrap(a) == 0;
    }

    /**
     * @notice Adds two unsigned fixed-decimals `a` and `b` together
     * @param a First unsigned fixed-decimal
     * @param b Second unsigned fixed-decimal
     * @return Resulting summed unsigned fixed-decimal
     */
    function add(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {
        return UFixed18.wrap(UFixed18.unwrap(a) + UFixed18.unwrap(b));
    }

    /**
     * @notice Subtracts unsigned fixed-decimal `b` from `a`
     * @param a Unsigned fixed-decimal to subtract from
     * @param b Unsigned fixed-decimal to subtract
     * @return Resulting subtracted unsigned fixed-decimal
     */
    function sub(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {
        return UFixed18.wrap(UFixed18.unwrap(a) - UFixed18.unwrap(b));
    }

    /**
     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together
     * @param a First unsigned fixed-decimal
     * @param b Second unsigned fixed-decimal
     * @return Resulting multiplied unsigned fixed-decimal
     */
    function mul(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {
        return UFixed18.wrap(UFixed18.unwrap(a) * UFixed18.unwrap(b) / BASE);
    }

    /**
     * @notice Divides unsigned fixed-decimal `a` by `b`
     * @param a Unsigned fixed-decimal to divide
     * @param b Unsigned fixed-decimal to divide by
     * @return Resulting subtracted unsigned fixed-decimal
     */
    function div(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {
        return UFixed18.wrap(UFixed18.unwrap(a) * BASE / UFixed18.unwrap(b));
    }

    /**
     * @notice Returns whether unsigned fixed-decimal `a` is equal to `b`
     * @param a First unsigned fixed-decimal
     * @param b Second unsigned fixed-decimal
     * @return Whether `a` is equal to `b`
     */
    function eq(UFixed18 a, UFixed18 b) internal pure returns (bool) {
        return compare(a, b) == 1;
    }

    /**
     * @notice Returns whether unsigned fixed-decimal `a` is greater than `b`
     * @param a First unsigned fixed-decimal
     * @param b Second unsigned fixed-decimal
     * @return Whether `a` is greater than `b`
     */
    function gt(UFixed18 a, UFixed18 b) internal pure returns (bool) {
        return compare(a, b) == 2;
    }

    /**
     * @notice Returns whether unsigned fixed-decimal `a` is less than `b`
     * @param a First unsigned fixed-decimal
     * @param b Second unsigned fixed-decimal
     * @return Whether `a` is less than `b`
     */
    function lt(UFixed18 a, UFixed18 b) internal pure returns (bool) {
        return compare(a, b) == 0;
    }

    /**
     * @notice Returns whether unsigned fixed-decimal `a` is greater than or equal to `b`
     * @param a First unsigned fixed-decimal
     * @param b Second unsigned fixed-decimal
     * @return Whether `a` is greater than or equal to `b`
     */
    function gte(UFixed18 a, UFixed18 b) internal pure returns (bool) {
        return gt(a, b) || eq(a, b);
    }

    /**
     * @notice Returns whether unsigned fixed-decimal `a` is less than or equal to `b`
     * @param a First unsigned fixed-decimal
     * @param b Second unsigned fixed-decimal
     * @return Whether `a` is less than or equal to `b`
     */
    function lte(UFixed18 a, UFixed18 b) internal pure returns (bool) {
        return lt(a, b) || eq(a, b);
    }

    /**
     * @notice Compares the unsigned fixed-decimals `a` and `b`
     * @dev Returns: 2 for greater than
     *               1 for equal to
     *               0 for less than
     * @param a First unsigned fixed-decimal
     * @param b Second unsigned fixed-decimal
     * @return Compare result of `a` and `b`
     */
    function compare(UFixed18 a, UFixed18 b) internal pure returns (uint256) {
        (uint256 au, uint256 bu) = (UFixed18.unwrap(a), UFixed18.unwrap(b));
        if (au > bu) return 2;
        if (au < bu) return 0;
        return 1;
    }

    /**
     * @notice Returns a unsigned fixed-decimal representing the ratio of `a` over `b`
     * @param a First unsigned number
     * @param b Second unsigned number
     * @return Ratio of `a` over `b`
     */
    function ratio(uint256 a, uint256 b) internal pure returns (UFixed18) {
        return UFixed18.wrap(a * BASE / b);
    }

    /**
     * @notice Returns the minimum of unsigned fixed-decimals `a` and `b`
     * @param a First unsigned fixed-decimal
     * @param b Second unsigned fixed-decimal
     * @return Minimum of `a` and `b`
     */
    function min(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {
        (uint256 au, uint256 bu) = (UFixed18.unwrap(a), UFixed18.unwrap(b));
        return UFixed18.wrap(au < bu ? au : bu);
    }

    /**
     * @notice Returns the maximum of unsigned fixed-decimals `a` and `b`
     * @param a First unsigned fixed-decimal
     * @param b Second unsigned fixed-decimal
     * @return Maximum of `a` and `b`
     */
    function max(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {
        (uint256 au, uint256 bu) = (UFixed18.unwrap(a), UFixed18.unwrap(b));
        return UFixed18.wrap(au > bu ? au : bu);
    }

    /**
     * @notice Converts the unsigned fixed-decimal into an integer, truncating any decimal portion
     * @param a Unsigned fixed-decimal
     * @return Truncated unsigned number
     */
    function truncate(UFixed18 a) internal pure returns (uint256) {
        return UFixed18.unwrap(a) / BASE;
    }
}",1818
RealWorld_BA_60_MockFixed18_RealWord_20240822093256.log,60,MockFixed18,15064,5801,20865,82.0,0.19134,"// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import ""../types/Fixed18.sol"";

contract MockFixed18 {
    function zero() external pure returns (Fixed18) {
        return Fixed18Lib.ZERO;
    }

    function one() external pure returns (Fixed18) {
        return Fixed18Lib.ONE;
    }

    function negOne() external pure returns (Fixed18) {
        return Fixed18Lib.NEG_ONE;
    }

    function from(UFixed18 a) external pure returns (Fixed18) {
        return Fixed18Lib.from(a);
    }

    function from(int256 s, UFixed18 m) external pure returns (Fixed18) {
        return Fixed18Lib.from(s, m);
    }

    function from(int256 a) external pure returns (Fixed18) {
        return Fixed18Lib.from(a);
    }

    function isZero(Fixed18 a) external pure returns (bool) {
        return Fixed18Lib.isZero(a);
    }

    function add(Fixed18 a, Fixed18 b) external pure returns (Fixed18) {
        return Fixed18Lib.add(a, b);
    }

    function sub(Fixed18 a, Fixed18 b) external pure returns (Fixed18) {
        return Fixed18Lib.sub(a, b);
    }

    function mul(Fixed18 a, Fixed18 b) external pure returns (Fixed18) {
        return Fixed18Lib.mul(a, b);
    }

    function div(Fixed18 a, Fixed18 b) external pure returns (Fixed18) {
        return Fixed18Lib.div(a, b);
    }

    function eq(Fixed18 a, Fixed18 b) external pure returns (bool) {
        return Fixed18Lib.eq(a, b);
    }

    function gt(Fixed18 a, Fixed18 b) external pure returns (bool) {
        return Fixed18Lib.gt(a, b);
    }

    function lt(Fixed18 a, Fixed18 b) external pure returns (bool) {
        return Fixed18Lib.lt(a, b);
    }

    function gte(Fixed18 a, Fixed18 b) external pure returns (bool) {
        return Fixed18Lib.gte(a, b);
    }

    function lte(Fixed18 a, Fixed18 b) external pure returns (bool) {
        return Fixed18Lib.lte(a, b);
    }

    function compare(Fixed18 a, Fixed18 b) external pure returns (uint256) {
        return Fixed18Lib.compare(a, b);
    }

    function ratio(int256 a, int256 b) external pure returns (Fixed18) {
        return Fixed18Lib.ratio(a, b);
    }

    function min(Fixed18 a, Fixed18 b) external pure returns (Fixed18) {
        return Fixed18Lib.min(a, b);
    }

    function max(Fixed18 a, Fixed18 b) external pure returns (Fixed18) {
        return Fixed18Lib.max(a, b);
    }

    function truncate(Fixed18 a) external pure returns (int256) {
        return Fixed18Lib.truncate(a);
    }

    function sign(Fixed18 a) external pure returns (int256) {
        return Fixed18Lib.sign(a);
    }

    function abs(Fixed18 a) external pure returns (UFixed18) {
        return Fixed18Lib.abs(a);
    }
}",705
RealWorld_BA_60_OptimisticLedger_RealWord_20240822100034.log,60,OptimisticLedger,17299,5611,22910,83.0,0.198715,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""../../utils/types/UFixed18.sol"";

/// @dev OptimisticLedger type
struct OptimisticLedger {
    /// @dev Individual account collateral balances
    mapping(address => UFixed18) balances;

    /// @dev Total ledger collateral balance
    UFixed18 total;

    /// @dev Total ledger collateral shortfall
    UFixed18 shortfall;
}

/**
 * @title OptimisticLedgerLib
 * @notice Library that manages a global vs account ledger where the global ledger is settled separately,
 *         and ahead of, the user-level accounts.
 * @dev    Ensures that no more collateral leaves the ledger than goes it, while allowing user-level accounts
 *         to settle as a follow up step. Overdrafts on the user-level are accounted as ""shortall"". Shortfall
 *         in the system is the quantity of insolvency that can be optionally resolved by the ledger owner.
 *         Until the shortfall is resolved, collateral may be withdrawn from the ledger on a FCFS basis. However
 *         once the ledger total has been depleted, users will not be able to withdraw even if they have non-zero
 *         user level balances until the shortfall is resolved, recapitalizing the ledger.
 */
library OptimisticLedgerLib {
    using UFixed18Lib for UFixed18;
    using Fixed18Lib for Fixed18;

    /**
     * @notice Credits `account` with `amount` collateral
     * @param self The struct to operate on
     * @param account Account to credit collateral to
     * @param amount Amount of collateral to credit
     */
    function creditAccount(OptimisticLedger storage self, address account, UFixed18 amount) internal {
        self.balances[account] = self.balances[account].add(amount);
        self.total = self.total.add(amount);
    }

    /**
     * @notice Debits `account` `amount` collateral
     * @param self The struct to operate on
     * @param account Account to debit collateral from
     * @param amount Amount of collateral to debit
     */
    function debitAccount(OptimisticLedger storage self, address account, UFixed18 amount) internal {
        self.balances[account] = self.balances[account].sub(amount);
        self.total = self.total.sub(amount);
    }

    /**
     * @notice Credits `account` with `amount` collateral
     * @dev Funds come from inside the product, not totals are updated
     *      Shortfall is created if more funds are debited from an account than exist
     * @param self The struct to operate on
     * @param account Account to credit collateral to
     * @param amount Amount of collateral to credit
     */
    function settleAccount(OptimisticLedger storage self, address account, Fixed18 amount)
    internal returns (UFixed18 shortfall) {
        Fixed18 newBalance = Fixed18Lib.from(self.balances[account]).add(amount);

        if (newBalance.sign() == -1) {
            shortfall = self.shortfall.add(newBalance.abs());
            newBalance = Fixed18Lib.ZERO;
        }

        self.balances[account] = newBalance.abs();
        self.shortfall = self.shortfall.add(shortfall);
    }

    /**
     * @notice Debits ledger globally `amount` collateral
     * @dev Removes balance from total that is accounted for elsewhere (e.g. product-level accumulators)
     * @param self The struct to operate on
     * @param amount Amount of collateral to debit
     */
    function debit(OptimisticLedger storage self, UFixed18 amount) internal {
        self.total = self.total.sub(amount);
    }

    /**
     * @notice Reduces the amount of collateral shortfall in the ledger
     * @param self The struct to operate on
     * @param amount Amount of shortfall to resolve
     */
    function resolve(OptimisticLedger storage self, UFixed18 amount) internal {
        self.shortfall = self.shortfall.sub(amount);
        self.total = self.total.add(amount);
    }
}",877
RealWorld_BA_61_AaveLendingPool_RealWord_20240822122232.log,61,AaveLendingPool,5898,4613,10511,65.0,0.12175,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.7.6;
pragma experimental ABIEncoderV2;

import './DataTypes.sol';
import './ILendingPoolAddressesProvider.sol';

interface AaveLendingPool {
    function deposit(
        address asset,
        uint256 amount,
        address onBehalfOf,
        uint16 referralCode
    ) external;

    function withdraw(
        address asset,
        uint256 amount,
        address to
    ) external returns (uint256);

    /**
     * @dev Returns the state and configuration of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The state of the reserve
     **/
    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);

    function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);
}",185
RealWorld_BA_61_ICToken_RealWord_20240822121619.log,61,ICToken,6270,5084,11354,74.0,0.13303,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

interface ICToken {
    function underlying() external view returns (address);

    function mint(uint256 mintAmount) external returns (uint256);

    function redeem(uint256 redeemTokens) external returns (uint256);

    function liquidateBorrow(
        address borrower,
        uint256 amount,
        address collateral
    ) external returns (uint256);

    function repayBorrow(uint256 repayAmount) external returns (uint256);

    function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);

    function balanceOfUnderlying(address account) external returns (uint256);

    function exchangeRateCurrent() external returns (uint256);

    function exchangeRateStored() external view returns (uint256);

    function supplyRatePerBlock() external returns (uint256);

    function redeemUnderlying(uint256) external returns (uint256);
}",193
RealWorld_BA_61_FluxAggregator_RealWord_20240822113219.log,61,FluxAggregator,6773,4984,11757,69.0,0.133545,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

contract FluxAggregator {
    uint256 public version = 3;
    uint8 public decimals;
    string public description;

    int256 public value = 1;
    uint80 latestRoundId = 5;

    function setValue(int256 newVal) public {
        value = newVal;
    }

    function getRoundData(uint80 _roundId)
        external
        view
        returns (
            uint80,
            int256,
            uint256,
            uint256,
            uint80
        )
    {
        return (0, value, 0, 0, 0);
    }

    function latestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        return (0, value, 0, 0, 0);
    }
}",205
RealWorld_BA_61_ICEther_RealWord_20240822122339.log,61,ICEther,3992,4340,8332,65.0,0.10676,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

interface ICEther {
    function mint() external payable;

    function repayBorrow() external payable;

    function repayBorrowBehalf(address borrower) external payable;

    function liquidateBorrow(address borrower, address cTokenCollateral) external payable;
}",70
RealWorld_BA_61_adminVerifier_RealWord_20240822114533.log,61,adminVerifier,12652,5830,18482,85.0,0.17986,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IVerifier.sol';

contract AdminVerifier is Initializable, IVerifier, OwnableUpgradeable {
    /**
     * @notice stores the verification contract instance
     */
    IVerification public verification;

    /**
     * @notice stores the user metadata against their address
     */
    mapping(address => string) public userData;

    /**
     * @notice emitted when verification contract address is updated
     * @param verification address of the updated verification contract
     */
    event VerificationUpdated(address indexed verification);

    /// @notice Initializes the variables of the contract
    /// @dev Contract follows proxy pattern and this function is used to initialize the variables for the contract in the proxy
    /// @param _admin Admin of the verification contract who can add verifiers and remove masterAddresses deemed invalid
    function initialize(address _admin, address _verification) external initializer {
        super.__Ownable_init();
        super.transferOwnership(_admin);
        _updateVerification(_verification);
    }

    /**
     * @notice used to register user
     * @dev ohly owner can register users
     * @param _user address of the user being registered
     * @param _metadata metadata related to the user
     * @param _isMasterLinked should master address be linked to itself
     */
    function registerUser(
        address _user,
        string memory _metadata,
        bool _isMasterLinked
    ) external onlyOwner {
        require(bytes(userData[_user]).length == 0, 'User already exists');
        verification.registerMasterAddress(_user, _isMasterLinked);
        userData[_user] = _metadata;
        emit UserRegistered(_user, _isMasterLinked, _metadata);
    }

    /**
     * @notice used to unregister user
     * @dev ohly owner can unregister users
     * @param _user address of the user being unregistered
     */
    function unregisterUser(address _user) external onlyOwner {
        require(bytes(userData[_user]).length != 0, 'User doesnt exists');
        delete userData[_user];
        verification.unregisterMasterAddress(_user, address(this));
        emit UserUnregistered(_user);
    }

    /**
     * @notice used to update verification contract address
     * @dev ohly owner can update
     * @param _verification address of the verification contract
     */
    function updateVerification(address _verification) external onlyOwner {
        _updateVerification(_verification);
    }

    function _updateVerification(address _verification) internal {
        verification = IVerification(_verification);
        emit VerificationUpdated(_verification);
    }
}",574
RealWorld_BA_61_CreditLine_RealWord_20240822114256.log,61,CreditLine,0,0,0,,0.0,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            ""Only Borrower or Lender who hasn't requested can accept""
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, ""CreditLine::_depositCollateral - value to transfer doesn't match argument"");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, ""CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount"");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}",10034
RealWorld_BA_61_AaveYield_RealWord_20240822114700.log,61,AaveYield,47412,5481,52893,83.0,0.34668,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/IWETHGateway.sol';
import '../interfaces/Invest/AaveLendingPool.sol';
import '../interfaces/Invest/IScaledBalanceToken.sol';
import '../interfaces/Invest/IProtocolDataProvider.sol';

/**
 * @title Yield contract
 * @notice Implements the functions to lock/unlock tokens into Aave protocol
 * @author Sublime
 **/
contract AaveYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    /**
     * @notice address of wethGateway used to deposit ETH to aave
     */
    address public wethGateway;

    /**
     * @notice address of protocolDataProvider which provides info about aTokens related to any token
     */
    address public protocolDataProvider;

    /**
     * @notice address of lendingPoolAddressesProvider used to get the pool related to any token
     */
    address public lendingPoolAddressesProvider;

    /**
     * @notice address of savings account contract
     */
    address payable public savingsAccount;

    /**
     * @notice aave referral code to represent sublime
     */
    uint16 public referralCode;

    /**
     * @notice emitted when aave protocol related addresses are updated
     * @param wethGateway address of wethGateway
     * @param protocolDataProvider address of protocol data provider
     * @param lendingPoolAddressesProvider address of lending pool addresses provider
     */
    event AaveAddressesUpdated(
        address indexed wethGateway,
        address indexed protocolDataProvider,
        address indexed lendingPoolAddressesProvider
    );

    /**
     * @notice emitted when aave referral code is updated
     * @param referralCode updated referral code
     */
    event ReferralCodeUpdated(uint16 referralCode);

    /**
     * @notice verifies if savings account invoked the contract
     */
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    /**
     * @notice To initialize the contract addresses interacting with this contract
     * @dev can only be initialized once
     * @param _owner address of owner
     * @param _savingsAccount address of the savings account contract
     * @param _wethGateway address of wethGateway
     * @param _protocolDataProvider the address of ProtocolDataProvider
     * @param _lendingPoolAddressesProvider the address of LendingPoolAddressesProvider
     **/
    function initialize(
        address _owner,
        address payable _savingsAccount,
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    /**
     * @notice Used to get liquidity token address from asset address
     * @param asset the address of underlying token
     * @return aToken address of liquidity token
     **/
    function liquidityToken(address asset) public view override returns (address aToken) {
        if (asset == address(0)) {
            aToken = IWETHGateway(wethGateway).getAWETHAddress();
        } else {
            (aToken, , ) = IProtocolDataProvider(protocolDataProvider).getReserveTokensAddresses(asset);
        }
    }

    /**
     * @notice used to update savings account address
     * @dev only owner can update
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update aave protocol related addresses
     * @dev only owner can update
     * @param _wethGateway address of wethGateway
     * @param _protocolDataProvider address of protocol data provider
     * @param _lendingPoolAddressesProvider address of lending pool addresses provider
     */
    function updateAaveAddresses(
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) external onlyOwner {
        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    function _updateAaveAddresses(
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) internal {
        require(_wethGateway != address(0), 'Invest: WETHGateway:: zero address');
        require(_protocolDataProvider != address(0), 'Invest: protocolDataProvider:: zero address');
        require(_lendingPoolAddressesProvider != address(0), 'Invest: lendingPoolAddressesProvider:: zero address');
        wethGateway = _wethGateway;
        protocolDataProvider = _protocolDataProvider;
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        emit AaveAddressesUpdated(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    /**
     * @notice used to update referral code
     * @dev only owner can update
     * @param _referralCode updated referral code
     */
    function updateReferralCode(uint16 _referralCode) external onlyOwner {
        referralCode = _referralCode;
        emit ReferralCodeUpdated(_referralCode);
    }

    /**
     * @notice used to withdraw all tokens of a type in case of emergencies
     * @dev only owner can withdraw
     * @param _asset address of the token being withdrawn
     * @param _wallet address to which tokens are withdrawn
     */
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        uint256 amount = IERC20(liquidityToken(_asset)).balanceOf(address(this));

        if (_asset == address(0)) {
            received = _withdrawETH(amount);
            (bool success, ) = _wallet.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(_asset, amount);
            IERC20(_asset).safeTransfer(_wallet, received);
        }
    }

    /**
     * @notice Used to lock tokens in protocol
     * @dev Asset Tokens to be locked must be approved to this contract by user
     * @param asset the address of token to invest
     * @param amount the amount of asset
     * @return sharesReceived amount of shares received
     **/
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');

        address investedTo;
        if (asset == address(0)) {
            require(msg.value == amount, 'Invest: ETH amount');
            (investedTo, sharesReceived) = _depositETH(amount);
        } else {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
            (investedTo, sharesReceived) = _depositERC20(asset, amount);
        }

        emit LockedTokens(user, investedTo, sharesReceived);
    }

    /**
     * @notice Used to unlock tokens from available protocol
     * @param asset the address of underlying token
     * @param amount the amount of asset
     * @return received amount of tokens received
     **/
    function unlockTokens(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        require(amount != 0, 'Invest: amount');

        if (asset == address(0)) {
            received = _withdrawETH(amount);
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(asset, amount);
            IERC20(asset).safeTransfer(savingsAccount, received);
        }

        emit UnlockedTokens(asset, received);
    }

    /**
     * @notice Used to unlock shares
     * @param asset the address of underlying token
     * @param amount the amount of shares to unlock
     * @return received amount of shares received
     **/
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {
        if (amount == 0) {
            return 0;
        }

        require(asset != address(0), 'Asset address cannot be address(0)');
        IERC20(asset).safeTransfer(savingsAccount, amount);

        emit UnlockedShares(asset, amount);
        return amount;
    }

    /**
     * @notice Used to get amount of underlying tokens for current number of shares
     * @param shares the amount of shares
     * @param asset the address of token locked
     * @return amount amount of underlying tokens
     **/
    function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {
        if (shares == 0) return 0;
        address aToken = liquidityToken(asset);

        (, , , , , , , uint256 liquidityIndex, , ) = IProtocolDataProvider(protocolDataProvider).getReserveData(asset);

        amount = IScaledBalanceToken(aToken).scaledBalanceOf(address(this)).mul(liquidityIndex).mul(shares).div(
            IERC20(aToken).balanceOf(address(this))
        );
    }

    /**
     * @notice Used to get number of shares from an amount of underlying tokens
     * @param amount the amount of tokens
     * @param asset the address of token
     * @return shares amount of shares for given tokens
     **/
    function getSharesForTokens(uint256 amount, address asset) external view override returns (uint256 shares) {
        shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));
    }

    function _depositETH(uint256 amount) internal returns (address aToken, uint256 sharesReceived) {
        aToken = IWETHGateway(wethGateway).getAWETHAddress();

        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        //lock collateral
        IWETHGateway(wethGateway).depositETH{value: amount}(lendingPool, address(this), referralCode);

        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);
    }

    function _depositERC20(address asset, uint256 amount) internal returns (address aToken, uint256 sharesReceived) {
        aToken = liquidityToken(asset);
        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        //approve collateral to vault
        IERC20(asset).approve(lendingPool, 0);
        IERC20(asset).approve(lendingPool, amount);

        //lock collateral in vault
        AaveLendingPool(lendingPool).deposit(asset, amount, address(this), referralCode);

        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);
    }

    function _withdrawETH(uint256 amount) internal returns (uint256 received) {
        IERC20(IWETHGateway(wethGateway).getAWETHAddress()).approve(wethGateway, amount);

        uint256 ethBalance = address(this).balance;

        //lock collateral
        IWETHGateway(wethGateway).withdrawETH(amount, address(this));

        received = address(this).balance.sub(ethBalance);
    }

    function _withdrawERC(address asset, uint256 amount) internal returns (uint256 tokensReceived) {
        address aToken = liquidityToken(asset);

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        uint256 tokensBefore = IERC20(asset).balanceOf(address(this));

        IERC20(aToken).approve(lendingPool, amount);

        //withdraw collateral from vault
        AaveLendingPool(lendingPool).withdraw(asset, amount, address(this));

        tokensReceived = IERC20(asset).balanceOf(address(this)).sub(tokensBefore);
    }

    receive() external payable {}
}",2772
RealWorld_BA_61_IExtension_RealWord_20240822120940.log,61,IExtension,8767,5645,14412,86.0,0.156735,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface IExtension {
    /**
     * @notice emitted when the Voting Pass Ratio parameter for Pools is updated
     * @param votingPassRatio the new value of the voting pass threshold for  Pools
     */
    event VotingPassRatioUpdated(uint256 votingPassRatio);

    /**
     * @notice emitted when the pool factory is updated in extension
     * @param poolFactory updated address of pool factory
     */
    event PoolFactoryUpdated(address indexed poolFactory);

    /**
     * @notice emitted when an extension is requested by a borrower for Pools
     * @param extensionVoteEndTime the value of the vote end time for the requested extension
     */
    event ExtensionRequested(uint256 extensionVoteEndTime);

    /**
     * @notice emitted when the requested extension for Pools is approved
     * @param poolID the address of the pool for which extension passed
     */
    event ExtensionPassed(address poolID);

    /**
     * @notice emitted when the lender for Pools has voted on extension request
     * @param lender address of the lender who voted
     * @param totalExtensionSupport the value of the total extension support for the Pools
     * @param lastVoteTime the last time the lender has voted on an extension request
     */
    event LenderVoted(address indexed lender, uint256 totalExtensionSupport, uint256 lastVoteTime);

    function initializePoolExtension(uint256 _repaymentInterval) external;

    function closePoolExtension() external;

    function removeVotes(
        address _from,
        address _to,
        uint256 _amount
    ) external;
}",347
RealWorld_BA_61_Extension_RealWord_20240822115734.log,61,Extension,32681,5910,38591,83.0,0.281605,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IRepayment.sol';

/**
 * @title Extension contract with methods related to Extension period
 * @notice Implements the functions related to Extension period of the pool
 * @author Sublime
 */
contract Extension is Initializable, IExtension {
    using SafeMath for uint256;

    struct ExtensionVariables {
        bool hasExtensionPassed;
        uint256 totalExtensionSupport;
        uint256 extensionVoteEndTime;
        uint256 repaymentInterval;
        mapping(address => uint256) lastVotedExtension;
    }

    /**
     * @notice used to keep track of extension details against a pool
     */
    mapping(address => ExtensionVariables) public extensions;
    IPoolFactory poolFactory;
    /**
     * @notice used to store voting pass ratio for approving extension
     */
    uint256 public votingPassRatio;

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == poolFactory.owner(), 'Not owner');
        _;
    }

    /**
     * @notice checks if the address is pool's valid borrower
     * @param _pool address of the borrower
     */
    modifier onlyBorrower(address _pool) {
        require(IPool(_pool).borrower() == msg.sender, 'Not Borrower');
        _;
    }

    /**
     * @notice initializing the Pool and the voting pass ratio
     * @param _poolFactory address of the Pool
     * @param _votingPassRatio the value of the voting pass ratio
     */
    function initialize(address _poolFactory, uint256 _votingPassRatio) external initializer {
        _updatePoolFactory(_poolFactory);
        _updateVotingPassRatio(_votingPassRatio);
    }

    /**
     * @notice initializing the pool extension for the Pool
     * @param _repaymentInterval value of the repayment interval
     */
    function initializePoolExtension(uint256 _repaymentInterval) external override {
        IPoolFactory _poolFactory = poolFactory;
        require(extensions[msg.sender].repaymentInterval == 0, 'Extension::initializePoolExtension - already initialized');
        require(_poolFactory.poolRegistry(msg.sender), 'Repayments::onlyValidPool - Invalid Pool');
        extensions[msg.sender].repaymentInterval = _repaymentInterval;
    }

    /**
     * @notice used for requesting an extension by a borrower
     * @param _pool address of the Pool
     */
    function requestExtension(address _pool) external onlyBorrower(_pool) {
        uint256 _repaymentInterval = extensions[_pool].repaymentInterval;
        require(_repaymentInterval != 0, 'Extension::requestExtension - Uninitialized pool');
        uint256 _extensionVoteEndTime = extensions[_pool].extensionVoteEndTime;
        require(block.timestamp > _extensionVoteEndTime, 'Extension::requestExtension - Extension requested already'); // _extensionVoteEndTime is 0 when no extension is active

        // This check is required so that borrower doesn't ask for more extension if previously an extension is already granted
        require(!extensions[_pool].hasExtensionPassed, 'Extension::requestExtension: Extension already availed');

        extensions[_pool].totalExtensionSupport = 0; // As we can multiple voting every time new voting start we have to make previous votes 0
        IRepayment _repayment = IRepayment(poolFactory.repaymentImpl());
        uint256 _nextDueTime = _repayment.getNextInstalmentDeadline(_pool);
        _extensionVoteEndTime = (_nextDueTime).div(10**30);
        extensions[_pool].extensionVoteEndTime = _extensionVoteEndTime; // this makes extension request single use
        emit ExtensionRequested(_extensionVoteEndTime);
    }

    /**
     * @notice used to rebalance votes of from and to addresses when pool tokens are transferred
     * @dev only pool can change its votes
     * @param _from address of user from whom pool tokens are transferred
     * @param _to address of user to whom pool tokens are transferred
     * @param _amount amount of pool tokens transferred
     */
    function removeVotes(
        address _from,
        address _to,
        uint256 _amount
    ) external override {
        address _pool = msg.sender;
        if (extensions[_pool].hasExtensionPassed) {
            return;
        }

        uint256 _extensionVoteEndTime = extensions[_pool].extensionVoteEndTime;

        if (_extensionVoteEndTime != 0 && _extensionVoteEndTime <= block.timestamp) {
            if (extensions[_pool].lastVotedExtension[_from] == _extensionVoteEndTime) {
                extensions[_pool].totalExtensionSupport = extensions[_pool].totalExtensionSupport.sub(_amount);
            }

            if (extensions[_pool].lastVotedExtension[_to] == _extensionVoteEndTime) {
                extensions[_pool].totalExtensionSupport = extensions[_pool].totalExtensionSupport.add(_amount);
            }
        }
    }

    /**
     * @notice used for requesting an extension by a borrower
     * @param _pool address of the Pool
     */
    function voteOnExtension(address _pool) external {
        uint256 _extensionVoteEndTime = extensions[_pool].extensionVoteEndTime;
        require(block.timestamp < _extensionVoteEndTime, 'Pool::voteOnExtension - Voting is over');

        (uint256 _balance, uint256 _totalSupply) = IPool(_pool).getBalanceDetails(msg.sender);
        require(_balance != 0, 'Pool::voteOnExtension - Not a valid lender for pool');

        uint256 _votingPassRatio = votingPassRatio;

        uint256 _lastVotedExtension = extensions[_pool].lastVotedExtension[msg.sender]; //Lender last vote time need to store it as it checks that a lender only votes once
        require(_lastVotedExtension != _extensionVoteEndTime, 'Pool::voteOnExtension - you have already voted');

        uint256 _extensionSupport = extensions[_pool].totalExtensionSupport;
        _lastVotedExtension = _extensionVoteEndTime;
        _extensionSupport = _extensionSupport.add(_balance);

        extensions[_pool].lastVotedExtension[msg.sender] = _lastVotedExtension;
        emit LenderVoted(msg.sender, _extensionSupport, _lastVotedExtension);
        extensions[_pool].totalExtensionSupport = _extensionSupport;

        if (((_extensionSupport)) >= (_totalSupply.mul(_votingPassRatio)).div(10**30)) {
            grantExtension(_pool);
        }
    }

    /**
     * @notice used for granting an extension for the repayment of loan
     * @param _pool address of the Pool
     */
    function grantExtension(address _pool) internal {
        IPoolFactory _poolFactory = poolFactory;
        IRepayment _repayment = IRepayment(_poolFactory.repaymentImpl());

        extensions[_pool].hasExtensionPassed = true;
        extensions[_pool].extensionVoteEndTime = block.timestamp; // voting is over

        _repayment.instalmentDeadlineExtended(_pool);

        emit ExtensionPassed(_pool);
    }

    /**
     * @notice used for closing the pool extension
     */
    function closePoolExtension() external override {
        delete extensions[msg.sender];
    }

    /**
     * @notice used for updating the voting pass ratio of the Pool
     * @param _votingPassRatio the value of the new voting pass ratio
     */
    function updateVotingPassRatio(uint256 _votingPassRatio) external onlyOwner {
        _updateVotingPassRatio(_votingPassRatio);
    }

    function _updateVotingPassRatio(uint256 _votingPassRatio) internal {
        votingPassRatio = _votingPassRatio;
        emit VotingPassRatioUpdated(_votingPassRatio);
    }

    /**
     * @notice used to update the pool factory contract address
     * @dev only owner can update
     * @param _poolFactory updated pool factory contract address
     */
    function updatePoolFactory(address _poolFactory) external onlyOwner {
        _updatePoolFactory(_poolFactory);
    }

    function _updatePoolFactory(address _poolFactory) internal {
        require(_poolFactory != address(0), 'Zero address not allowed');
        poolFactory = IPoolFactory(_poolFactory);
        emit PoolFactoryUpdated(_poolFactory);
    }
}",1806
RealWorld_BA_61_Controller_RealWord_20240822113442.log,61,Controller,30183,6282,36465,86.0,0.276555,"/**
 *Submitted for verification at Etherscan.io on 2020-08-11
 */

// SPDX-License-Identifier: MIT

pragma solidity 0.7.6;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';

interface IStrategy {
    function want() external view returns (address);

    function deposit() external;

    function withdraw(address) external;

    function withdraw(uint256) external;

    function withdrawAll() external returns (uint256);

    function balanceOf() external view returns (uint256);
}

interface Converter {
    function convert(address) external returns (uint256);
}

interface OneSplitAudit {
    function swap(
        address fromToken,
        address destToken,
        uint256 amount,
        uint256 minReturn,
        uint256[] calldata distribution,
        uint256 flags
    ) external payable returns (uint256 returnAmount);

    function getExpectedReturn(
        address fromToken,
        address destToken,
        uint256 amount,
        uint256 parts,
        uint256 flags // See constants in IOneSplit.sol
    ) external view returns (uint256 returnAmount, uint256[] memory distribution);
}

contract Controller {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    address public governance;
    address public strategist;

    address public onesplit;
    address public rewards;
    mapping(address => address) public vaults;
    mapping(address => address) public strategies;
    mapping(address => mapping(address => address)) public converters;

    mapping(address => mapping(address => bool)) public approvedStrategies;

    uint256 public split = 500;
    uint256 public constant max = 10000;

    constructor(address _rewards) {
        governance = msg.sender;
        strategist = msg.sender;
        onesplit = address(0x50FDA034C0Ce7a8f7EFDAebDA7Aa7cA21CC1267e);
        rewards = _rewards;
    }

    function setRewards(address _rewards) public {
        require(msg.sender == governance, '!governance');
        rewards = _rewards;
    }

    function setStrategist(address _strategist) public {
        require(msg.sender == governance, '!governance');
        strategist = _strategist;
    }

    function setSplit(uint256 _split) public {
        require(msg.sender == governance, '!governance');
        split = _split;
    }

    function setOneSplit(address _onesplit) public {
        require(msg.sender == governance, '!governance');
        onesplit = _onesplit;
    }

    function setGovernance(address _governance) public {
        require(msg.sender == governance, '!governance');
        governance = _governance;
    }

    function setVault(address _token, address _vault) public {
        require(msg.sender == strategist || msg.sender == governance, '!strategist');
        require(vaults[_token] == address(0), 'vault');
        vaults[_token] = _vault;
    }

    function approveStrategy(address _token, address _strategy) public {
        require(msg.sender == governance, '!governance');
        approvedStrategies[_token][_strategy] = true;
    }

    function revokeStrategy(address _token, address _strategy) public {
        require(msg.sender == governance, '!governance');
        approvedStrategies[_token][_strategy] = false;
    }

    function setConverter(
        address _input,
        address _output,
        address _converter
    ) public {
        require(msg.sender == strategist || msg.sender == governance, '!strategist');
        converters[_input][_output] = _converter;
    }

    function setStrategy(address _token, address _strategy) public {
        require(msg.sender == strategist || msg.sender == governance, '!strategist');
        require(approvedStrategies[_token][_strategy], '!approved');

        address _current = strategies[_token];
        if (_current != address(0)) {
            IStrategy(_current).withdrawAll();
        }
        strategies[_token] = _strategy;
    }

    function earn(address _token, uint256 _amount) public {
        address _strategy = strategies[_token];
        address _want = IStrategy(_strategy).want();
        if (_want != _token) {
            address converter = converters[_token][_want];
            IERC20(_token).safeTransfer(converter, _amount);
            _amount = Converter(converter).convert(_strategy);
            IERC20(_want).safeTransfer(_strategy, _amount);
        } else {
            IERC20(_token).safeTransfer(_strategy, _amount);
        }
        IStrategy(_strategy).deposit();
    }

    function balanceOf(address _token) external view returns (uint256) {
        return IStrategy(strategies[_token]).balanceOf();
    }

    function withdrawAll(address _token) public {
        require(msg.sender == strategist || msg.sender == governance, '!strategist');
        IStrategy(strategies[_token]).withdrawAll();
    }

    function inCaseTokensGetStuck(address _token, uint256 _amount) public {
        require(msg.sender == strategist || msg.sender == governance, '!governance');
        IERC20(_token).safeTransfer(msg.sender, _amount);
    }

    function inCaseStrategyTokenGetStuck(address _strategy, address _token) public {
        require(msg.sender == strategist || msg.sender == governance, '!governance');
        IStrategy(_strategy).withdraw(_token);
    }

    function getExpectedReturn(
        address _strategy,
        address _token,
        uint256 parts
    ) public view returns (uint256 expected) {
        uint256 _balance = IERC20(_token).balanceOf(_strategy);
        address _want = IStrategy(_strategy).want();
        (expected, ) = OneSplitAudit(onesplit).getExpectedReturn(_token, _want, _balance, parts, 0);
    }

    // Only allows to withdraw non-core strategy tokens ~ this is over and above normal yield
    function yearn(
        address _strategy,
        address _token,
        uint256 parts
    ) public {
        require(msg.sender == strategist || msg.sender == governance, '!governance');
        // This contract should never have value in it, but just incase since this is a public call
        uint256 _before = IERC20(_token).balanceOf(address(this));
        IStrategy(_strategy).withdraw(_token);
        uint256 _after = IERC20(_token).balanceOf(address(this));
        if (_after > _before) {
            uint256 _amount = _after.sub(_before);
            address _want = IStrategy(_strategy).want();
            uint256[] memory _distribution;
            uint256 _expected;
            _before = IERC20(_want).balanceOf(address(this));
            IERC20(_token).safeApprove(onesplit, 0);
            IERC20(_token).safeApprove(onesplit, _amount);
            (_expected, _distribution) = OneSplitAudit(onesplit).getExpectedReturn(_token, _want, _amount, parts, 0);
            OneSplitAudit(onesplit).swap(_token, _want, _amount, _expected, _distribution, 0);
            _after = IERC20(_want).balanceOf(address(this));
            if (_after > _before) {
                _amount = _after.sub(_before);
                uint256 _reward = _amount.mul(split).div(max);
                earn(_want, _amount.sub(_reward));
                IERC20(_want).safeTransfer(rewards, _reward);
            }
        }
    }

    function withdraw(address _token, uint256 _amount) public {
        require(msg.sender == vaults[_token], '!vault');
        IStrategy(strategies[_token]).withdraw(_amount);
    }
}",1671
RealWorld_BA_61_GovernanceTester_RealWord_20240822113330.log,61,GovernanceTester,5510,5093,10603,70.0,0.12941,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

contract GovernanceTester {
    address public gov;
    uint256 public value;

    event valueUpdated(address indexed governance, address indexed sender, uint256 v);

    modifier onlyGov() {
        require(msg.sender == gov, 'Only Governance should be able to hit');
        _;
    }

    constructor(address _gov, uint256 _val) {
        gov = _gov;
        value = _val;
    }

    function update(uint256 _value) public onlyGov {
        value = _value;
        emit valueUpdated(gov, msg.sender, _value);
    }
}",134
RealWorld_BA_61_CompoundYield_RealWord_20240822115014.log,61,CompoundYield,35591,5357,40948,98.0,0.285095,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/ICEther.sol';
import '../interfaces/Invest/ICToken.sol';

/**
 * @title Yield contract
 * @notice Implements the functions to lock/unlock tokens into available exchanges
 * @author Sublime
 **/
contract CompoundYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    /**
     * @notice stores the address of savings account contract
     **/
    address payable public savingsAccount;

    /**
     * @notice stores the address of liquidity token for a given base token
     */
    mapping(address => address) public override liquidityToken;

    /**
     * @notice emitted when liquidity token address of an asset is updated
     * @param asset the address of asset
     * @param protocolToken address of the liquidity token for the asset
     **/
    event ProtocolAddressesUpdated(address indexed asset, address indexed protocolToken);

    /**
     * @notice checks if contract is invoked by savings account
     **/
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    /**
     * @notice used to initialize the variables in the contract
     * @dev can only be called once
     * @param _owner address of the owner
     * @param _savingsAccount address of the savings account contract
     **/
    function initialize(address _owner, address payable _savingsAccount) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
    }

    /**
     * @notice used to update savings account contract address
     * @dev can only be called by owner
     * @param _savingsAccount address of updated savings account contract
     **/
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update liquidity token for a asset
     * @dev can only be called by owner
     * @param _asset address of the token
     * @param _liquidityToken address of the liquidityToken for the given token
     **/
    function updateProtocolAddresses(address _asset, address _liquidityToken) external onlyOwner {
        liquidityToken[_asset] = _liquidityToken;
        emit ProtocolAddressesUpdated(_asset, _liquidityToken);
    }

    /**
     * @notice used to withdraw all tokens of a type in case of emergencies
     * @dev only owner can withdraw
     * @param _asset address of the token being withdrawn
     * @param _wallet address to which tokens are withdrawn
     */
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        address investedTo = liquidityToken[_asset];
        uint256 amount = IERC20(investedTo).balanceOf(address(this));

        if (_asset == address(0)) {
            received = _withdrawETH(investedTo, amount);
            (bool success, ) = _wallet.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(_asset, investedTo, amount);
            IERC20(_asset).safeTransfer(_wallet, received);
        }
    }

    /**
     * @notice Used to lock tokens in available protocol
     * @dev Asset Tokens to be locked must be approved to this contract by user
     * @param user the address of user
     * @param asset the address of token to invest
     * @param amount the amount of asset
     * @return sharesReceived amount of shares received
     **/
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');
        address investedTo = liquidityToken[asset];
        if (asset == address(0)) {
            require(msg.value == amount, 'Invest: ETH amount');
            sharesReceived = _depositETH(investedTo, amount);
        } else {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
            sharesReceived = _depositERC20(asset, investedTo, amount);
        }
        emit LockedTokens(user, investedTo, sharesReceived);
    }

    /**
     * @notice Used to unlock tokens from available protocol
     * @param asset the address of underlying token
     * @param amount the amount of asset
     * @return received amount of tokens received
     **/
    function unlockTokens(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        require(amount != 0, 'Invest: amount');
        address investedTo = liquidityToken[asset];

        if (asset == address(0)) {
            received = _withdrawETH(investedTo, amount);
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(asset, investedTo, amount);
            IERC20(asset).safeTransfer(savingsAccount, received);
        }

        emit UnlockedTokens(asset, received);
    }

    /**
     * @notice Used to unlock shares
     * @param asset the address of underlying token
     * @param amount the amount of shares to unlock
     * @return received amount of shares received
     **/
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {
        if (amount == 0) {
            return 0;
        }

        require(asset != address(0), 'Asset address cannot be address(0)');
        IERC20(asset).safeTransfer(savingsAccount, amount);

        emit UnlockedShares(asset, amount);
        return amount;
    }

    /**
     * @dev Used to get amount of underlying tokens for given number of shares
     * @param shares the amount of shares
     * @param asset the address of token locked
     * @return amount amount of underlying tokens
     **/
    function getTokensForShares(uint256 shares, address asset) public override returns (uint256 amount) {
        //balanceOfUnderlying returns underlying balance for total shares
        if (shares == 0) return 0;
        address cToken = liquidityToken[asset];
        amount = ICToken(cToken).balanceOfUnderlying(address(this)).mul(shares).div(IERC20(cToken).balanceOf(address(this)));
    }

    /**
     * @notice Used to get number of shares from an amount of underlying tokens
     * @param amount the amount of tokens
     * @param asset the address of token
     * @return shares amount of shares for given tokens
     **/
    function getSharesForTokens(uint256 amount, address asset) external override returns (uint256 shares) {
        shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));
    }

    function _depositETH(address cToken, uint256 amount) internal returns (uint256 sharesReceived) {
        uint256 initialCTokenBalance = IERC20(cToken).balanceOf(address(this));

        //mint cToken
        ICEther(cToken).mint{value: amount}();

        sharesReceived = IERC20(cToken).balanceOf(address(this)).sub(initialCTokenBalance);
    }

    function _depositERC20(
        address asset,
        address cToken,
        uint256 amount
    ) internal returns (uint256 sharesReceived) {
        uint256 initialCTokenBalance = IERC20(cToken).balanceOf(address(this));
        //mint cToken
        IERC20(asset).approve(cToken, 0);
        IERC20(asset).approve(cToken, amount);
        require(ICToken(cToken).mint(amount) == 0, 'Error in minting tokens');
        sharesReceived = IERC20(cToken).balanceOf(address(this)).sub(initialCTokenBalance);
    }

    function _withdrawETH(address cToken, uint256 amount) internal returns (uint256 received) {
        uint256 ethBalance = address(this).balance;

        require(ICToken(cToken).redeem(amount) == 0, 'Error in unwrapping');

        received = address(this).balance.sub(ethBalance);
    }

    function _withdrawERC(
        address asset,
        address cToken,
        uint256 amount
    ) internal returns (uint256 tokensReceived) {
        uint256 initialAssetBalance = IERC20(asset).balanceOf(address(this));
        require(ICToken(cToken).redeem(amount) == 0, 'Error in unwrapping');
        tokensReceived = IERC20(asset).balanceOf(address(this)).sub(initialAssetBalance);
    }

    //to apply check
    receive() external payable {}
}",2039
RealWorld_BA_61_IController_RealWord_20240822113838.log,61,IController,4921,5025,9946,77.0,0.125105,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface IController {
    function vaults(address) external view returns (address);

    function strategies(address) external view returns (address);

    function rewards() external view returns (address);

    function approveStrategy(address, address) external;

    function setStrategy(address, address) external;

    function withdraw(address, uint256) external;

    function balanceOf(address) external view returns (uint256);

    function earn(address, uint256) external;
}",107
RealWorld_BA_61_DataTypes_RealWord_20240822121955.log,61,DataTypes,9179,4466,13645,75.0,0.135215,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.7.6;

library DataTypes {
    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.
    struct ReserveData {
        //stores the reserve configuration
        ReserveConfigurationMap configuration;
        //the liquidity index. Expressed in ray
        uint128 liquidityIndex;
        //variable borrow index. Expressed in ray
        uint128 variableBorrowIndex;
        //the current supply rate. Expressed in ray
        uint128 currentLiquidityRate;
        //the current variable borrow rate. Expressed in ray
        uint128 currentVariableBorrowRate;
        //the current stable borrow rate. Expressed in ray
        uint128 currentStableBorrowRate;
        uint40 lastUpdateTimestamp;
        //tokens addresses
        address aTokenAddress;
        address stableDebtTokenAddress;
        address variableDebtTokenAddress;
        //address of the interest rate strategy
        address interestRateStrategyAddress;
        //the id of the reserve. Represents the position in the list of the active reserves
        uint8 id;
    }

    struct ReserveConfigurationMap {
        //bit 0-15: LTV
        //bit 16-31: Liq. threshold
        //bit 32-47: Liq. bonus
        //bit 48-55: Decimals
        //bit 56: Reserve is active
        //bit 57: reserve is frozen
        //bit 58: borrowing is enabled
        //bit 59: stable rate borrowing enabled
        //bit 60-63: reserved
        //bit 64-79: reserve factor
        uint256 data;
    }

    struct UserConfigurationMap {
        uint256 data;
    }

    enum InterestRateMode {
        NONE,
        STABLE,
        VARIABLE
    }
}",398
