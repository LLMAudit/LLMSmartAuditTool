filename,contest_id,contract_name,input_token,completion_token,total_token,execution_time,cost,contract_content,contract_size
RealWorld_BA_102_RateLimited_RealWord_20240827220454.log,102,RateLimited,21646,5673,27319,87.0,0.22169,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""../refs/CoreRef.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

/// @title abstract contract for putting a rate limit on how fast a contract can perform an action e.g. Minting
/// @author Fei Protocol
abstract contract RateLimited is CoreRef {
    /// @notice maximum rate limit per second governance can set for this contract
    uint256 public immutable MAX_RATE_LIMIT_PER_SECOND;

    /// @notice the rate per second for this contract
    uint256 public rateLimitPerSecond;

    /// @notice the last time the buffer was used by the contract
    uint256 public lastBufferUsedTime;

    /// @notice the cap of the buffer that can be used at once
    uint256 public bufferCap;

    /// @notice a flag for whether to allow partial actions to complete if the buffer is less than amount
    bool public doPartialAction;

    /// @notice the buffer at the timestamp of lastBufferUsedTime
    uint256 public bufferStored;

    event BufferUsed(uint256 amountUsed, uint256 bufferRemaining);
    event BufferCapUpdate(uint256 oldBufferCap, uint256 newBufferCap);
    event RateLimitPerSecondUpdate(
        uint256 oldRateLimitPerSecond,
        uint256 newRateLimitPerSecond
    );

    constructor(
        uint256 _maxRateLimitPerSecond,
        uint256 _rateLimitPerSecond,
        uint256 _bufferCap,
        bool _doPartialAction
    ) {
        lastBufferUsedTime = block.timestamp;

        _setBufferCap(_bufferCap);
        bufferStored = _bufferCap;

        require(
            _rateLimitPerSecond <= _maxRateLimitPerSecond,
            ""RateLimited: rateLimitPerSecond too high""
        );
        _setRateLimitPerSecond(_rateLimitPerSecond);

        MAX_RATE_LIMIT_PER_SECOND = _maxRateLimitPerSecond;
        doPartialAction = _doPartialAction;
    }

    /// @notice set the rate limit per second
    function setRateLimitPerSecond(uint256 newRateLimitPerSecond)
        external
        virtual
        onlyGovernorOrAdmin
    {
        require(
            newRateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,
            ""RateLimited: rateLimitPerSecond too high""
        );
        _updateBufferStored();

        _setRateLimitPerSecond(newRateLimitPerSecond);
    }

    /// @notice set the buffer cap
    function setBufferCap(uint256 newBufferCap)
        external
        virtual
        onlyGovernorOrAdmin
    {
        _setBufferCap(newBufferCap);
    }

    /// @notice the amount of action used before hitting limit
    /// @dev replenishes at rateLimitPerSecond per second up to bufferCap
    function buffer() public view returns (uint256) {
        uint256 elapsed = block.timestamp - lastBufferUsedTime;
        return
            Math.min(bufferStored + (rateLimitPerSecond * elapsed), bufferCap);
    }

    /** 
        @notice the method that enforces the rate limit. Decreases buffer by ""amount"". 
        If buffer is <= amount either
        1. Does a partial mint by the amount remaining in the buffer or
        2. Reverts
        Depending on whether doPartialAction is true or false
    */
    function _depleteBuffer(uint256 amount) internal virtual returns (uint256) {
        uint256 newBuffer = buffer();

        uint256 usedAmount = amount;
        if (doPartialAction && usedAmount > newBuffer) {
            usedAmount = newBuffer;
        }

        require(newBuffer != 0, ""RateLimited: no rate limit buffer"");
        require(usedAmount <= newBuffer, ""RateLimited: rate limit hit"");

        bufferStored = newBuffer - usedAmount;

        lastBufferUsedTime = block.timestamp;

        emit BufferUsed(usedAmount, bufferStored);

        return usedAmount;
    }

    /// @notice function to replenish buffer
    /// @param amount to increase buffer by if under buffer cap
    function _replenishBuffer(uint256 amount) internal {
        uint256 newBuffer = buffer();

        uint256 _bufferCap = bufferCap; /// gas opti, save an SLOAD

        /// cannot replenish any further if already at buffer cap
        if (newBuffer == _bufferCap) {
            return;
        }

        /// ensure that bufferStored cannot be gt buffer cap
        bufferStored = Math.min(newBuffer + amount, _bufferCap);
    }

    function _setRateLimitPerSecond(uint256 newRateLimitPerSecond) internal {
        uint256 oldRateLimitPerSecond = rateLimitPerSecond;
        rateLimitPerSecond = newRateLimitPerSecond;

        emit RateLimitPerSecondUpdate(
            oldRateLimitPerSecond,
            newRateLimitPerSecond
        );
    }

    function _setBufferCap(uint256 newBufferCap) internal {
        _updateBufferStored();

        uint256 oldBufferCap = bufferCap;
        bufferCap = newBufferCap;

        emit BufferCapUpdate(oldBufferCap, newBufferCap);
    }

    function _resetBuffer() internal {
        bufferStored = bufferCap;
    }

    function _updateBufferStored() internal {
        bufferStored = buffer();
        lastBufferUsedTime = block.timestamp;
    }
}",1125
RealWorld_BA_102_MockScalingPriceOracle_RealWord_20240827214956.log,102,MockScalingPriceOracle,5645,4561,10206,75.0,0.119445,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {CoreRef} from ""./../refs/CoreRef.sol"";
import {ScalingPriceOracle} from ""./../oracle/ScalingPriceOracle.sol"";

/// @notice Testing contract that allows for updates without mocking chainlink calls
contract MockScalingPriceOracle is ScalingPriceOracle {
    constructor(
        address _oracle,
        bytes32 _jobid,
        uint256 _fee,
        uint128 _currentMonth,
        uint128 _previousMonth
    )
        ScalingPriceOracle(_oracle, _jobid, _fee, _currentMonth, _previousMonth)
    {}

    function fulfill(uint256 _cpiData) external {
        _updateCPIData(_cpiData);
    }
}",163
RealWorld_BA_102_Permissions_RealWord_20240827212009.log,102,Permissions,26414,5183,31597,81.0,0.23573,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/access/AccessControlEnumerable.sol"";
import ""./IPermissions.sol"";

/// @title Access control module for Core
/// @author Fei Protocol
contract Permissions is IPermissions, AccessControlEnumerable {
    bytes32 public constant override BURNER_ROLE = keccak256(""BURNER_ROLE"");
    bytes32 public constant override MINTER_ROLE = keccak256(""MINTER_ROLE"");
    bytes32 public constant override PCV_CONTROLLER_ROLE =
        keccak256(""PCV_CONTROLLER_ROLE"");
    bytes32 public constant override GOVERN_ROLE = keccak256(""GOVERN_ROLE"");
    bytes32 public constant override GUARDIAN_ROLE = keccak256(""GUARDIAN_ROLE"");

    constructor() {
        // Appointed as a governor so guardian can have indirect access to revoke ability
        _setupGovernor(address(this));

        _setRoleAdmin(MINTER_ROLE, GOVERN_ROLE);
        _setRoleAdmin(BURNER_ROLE, GOVERN_ROLE);
        _setRoleAdmin(PCV_CONTROLLER_ROLE, GOVERN_ROLE);
        _setRoleAdmin(GOVERN_ROLE, GOVERN_ROLE);
        _setRoleAdmin(GUARDIAN_ROLE, GOVERN_ROLE);
    }

    modifier onlyGovernor() {
        require(
            isGovernor(msg.sender),
            ""Permissions: Caller is not a governor""
        );
        _;
    }

    modifier onlyGuardian() {
        require(
            isGuardian(msg.sender),
            ""Permissions: Caller is not a guardian""
        );
        _;
    }

    /// @notice creates a new role to be maintained
    /// @param role the new role id
    /// @param adminRole the admin role id for `role`
    /// @dev can also be used to update admin of existing role
    function createRole(bytes32 role, bytes32 adminRole)
        external
        override
        onlyGovernor
    {
        _setRoleAdmin(role, adminRole);
    }

    /// @notice grants minter role to address
    /// @param minter new minter
    function grantMinter(address minter) external override onlyGovernor {
        grantRole(MINTER_ROLE, minter);
    }

    /// @notice grants burner role to address
    /// @param burner new burner
    function grantBurner(address burner) external override onlyGovernor {
        grantRole(BURNER_ROLE, burner);
    }

    /// @notice grants controller role to address
    /// @param pcvController new controller
    function grantPCVController(address pcvController)
        external
        override
        onlyGovernor
    {
        grantRole(PCV_CONTROLLER_ROLE, pcvController);
    }

    /// @notice grants governor role to address
    /// @param governor new governor
    function grantGovernor(address governor) external override onlyGovernor {
        grantRole(GOVERN_ROLE, governor);
    }

    /// @notice grants guardian role to address
    /// @param guardian new guardian
    function grantGuardian(address guardian) external override onlyGovernor {
        grantRole(GUARDIAN_ROLE, guardian);
    }

    /// @notice revokes minter role from address
    /// @param minter ex minter
    function revokeMinter(address minter) external override onlyGovernor {
        revokeRole(MINTER_ROLE, minter);
    }

    /// @notice revokes burner role from address
    /// @param burner ex burner
    function revokeBurner(address burner) external override onlyGovernor {
        revokeRole(BURNER_ROLE, burner);
    }

    /// @notice revokes pcvController role from address
    /// @param pcvController ex pcvController
    function revokePCVController(address pcvController)
        external
        override
        onlyGovernor
    {
        revokeRole(PCV_CONTROLLER_ROLE, pcvController);
    }

    /// @notice revokes governor role from address
    /// @param governor ex governor
    function revokeGovernor(address governor) external override onlyGovernor {
        revokeRole(GOVERN_ROLE, governor);
    }

    /// @notice revokes guardian role from address
    /// @param guardian ex guardian
    function revokeGuardian(address guardian) external override onlyGovernor {
        revokeRole(GUARDIAN_ROLE, guardian);
    }

    /// @notice revokes a role from address
    /// @param role the role to revoke
    /// @param account the address to revoke the role from
    function revokeOverride(bytes32 role, address account)
        external
        override
        onlyGuardian
    {
        require(
            role != GOVERN_ROLE,
            ""Permissions: Guardian cannot revoke governor""
        );

        // External call because this contract is appointed as a governor and has access to revoke
        this.revokeRole(role, account);
    }

    /// @notice checks if address is a minter
    /// @param _address address to check
    /// @return true _address is a minter
    // only virtual for testing mock override
    function isMinter(address _address)
        external
        view
        virtual
        override
        returns (bool)
    {
        return hasRole(MINTER_ROLE, _address);
    }

    /// @notice checks if address is a burner
    /// @param _address address to check
    /// @return true _address is a burner
    // only virtual for testing mock override
    function isBurner(address _address)
        external
        view
        virtual
        override
        returns (bool)
    {
        return hasRole(BURNER_ROLE, _address);
    }

    /// @notice checks if address is a controller
    /// @param _address address to check
    /// @return true _address is a controller
    // only virtual for testing mock override
    function isPCVController(address _address)
        external
        view
        virtual
        override
        returns (bool)
    {
        return hasRole(PCV_CONTROLLER_ROLE, _address);
    }

    /// @notice checks if address is a governor
    /// @param _address address to check
    /// @return true _address is a governor
    // only virtual for testing mock override
    function isGovernor(address _address)
        public
        view
        virtual
        override
        returns (bool)
    {
        return hasRole(GOVERN_ROLE, _address);
    }

    /// @notice checks if address is a guardian
    /// @param _address address to check
    /// @return true _address is a guardian
    // only virtual for testing mock override
    function isGuardian(address _address)
        public
        view
        virtual
        override
        returns (bool)
    {
        return hasRole(GUARDIAN_ROLE, _address);
    }

    function _setupGovernor(address governor) internal {
        _setupRole(GOVERN_ROLE, governor);
    }
}",1463
RealWorld_BA_102_ScalingPriceOracle.t_RealWord_20240827213211.log,102,ScalingPriceOracle.t,19288,5476,24764,81.0,0.20596,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {Vm} from ""./../utils/Vm.sol"";
import {DSTest} from ""./../utils/DSTest.sol"";
import {getCore, getAddresses, FeiTestAddresses} from ""./../utils/Fixtures.sol"";
import {MockScalingPriceOracle} from ""../../../mock/MockScalingPriceOracle.sol"";
import {Decimal} from ""./../../../external/Decimal.sol"";

contract ScalingPriceOracleTest is DSTest {
    using Decimal for Decimal.D256;

    MockScalingPriceOracle private scalingPriceOracle;

    /// @notice increase price by 3.09% per month
    int256 public constant monthlyChangeRateBasisPoints = 309;

    /// @notice the current month's CPI data
    uint128 public constant currentMonth = 270000;

    /// @notice the previous month's CPI data
    uint128 public constant previousMonth = 261900;

    /// @notice address of chainlink oracle to send request
    address public immutable oracle = address(0);

    /// @notice job id that retrieves the latest CPI data
    bytes32 public immutable jobId =
        keccak256(abi.encodePacked(""Chainlink CPI-U job""));

    /// @notice fee of 10 link
    uint256 public immutable fee = 1e19;

    Vm public constant vm = Vm(HEVM_ADDRESS);
    FeiTestAddresses public addresses = getAddresses();

    function setUp() public {
        /// warp to 1 to set isTimeStarted to true
        vm.warp(1);

        scalingPriceOracle = new MockScalingPriceOracle(
            oracle,
            jobId,
            fee,
            currentMonth,
            previousMonth
        );
    }

    function testSetup() public {
        assertEq(scalingPriceOracle.oracle(), oracle);
        assertEq(scalingPriceOracle.jobId(), jobId);
        assertEq(scalingPriceOracle.fee(), fee);
        assertEq(scalingPriceOracle.currentMonth(), currentMonth);
        assertEq(scalingPriceOracle.previousMonth(), previousMonth);
        assertEq(
            scalingPriceOracle.getMonthlyAPR(),
            monthlyChangeRateBasisPoints
        );
    }

    /// positive price action from oracle -- inflation case
    function testReadGetCurrentOraclePriceAfterInterpolation() public {
        vm.warp(block.timestamp + 28 days);
        assertEq(10309e14, scalingPriceOracle.getCurrentOraclePrice());
    }

    /// negative price action from oracle -- deflation case
    function testPriceDecreaseAfterInterpolation() public {
        scalingPriceOracle = new MockScalingPriceOracle(
            oracle,
            jobId,
            fee,
            previousMonth, /// flip current and previous months so that rate is -3%
            currentMonth
        );

        vm.warp(block.timestamp + 28 days);
        assertEq(97e16, scalingPriceOracle.getCurrentOraclePrice());
    }

    function testFulfillFailureTimed() public {
        assertTrue(!scalingPriceOracle.isTimeEnded());

        vm.expectRevert(bytes(""Timed: time not ended, init""));

        scalingPriceOracle.requestCPIData();
    }

    function testFulfillMaxDeviationExceededFailureUp() public {
        vm.expectRevert(
            bytes(
                ""ScalingPriceOracle: Chainlink data outside of deviation threshold""
            )
        );

        /// this will fail as it is 21% inflation and max allowable is 20%
        scalingPriceOracle.fulfill((currentMonth * 121) / 100);
    }

    function testFulfillMaxDeviationExceededFailureDown() public {
        vm.expectRevert(
            bytes(
                ""ScalingPriceOracle: Chainlink data outside of deviation threshold""
            )
        );

        /// this will fail as it is 21% inflation and max allowable is 20%
        scalingPriceOracle.fulfill((currentMonth * 79) / 100);
    }

    function testFulfillSucceedsTwentyPercent() public {
        uint256 storedCurrentMonth = scalingPriceOracle.currentMonth();
        uint256 newCurrentMonth = (currentMonth * 120) / 100;

        /// this will succeed as max allowable is 20%
        scalingPriceOracle.fulfill(newCurrentMonth);

        assertEq(scalingPriceOracle.monthlyChangeRateBasisPoints(), 2_000);
        /// assert that all state transitions were done correctly with current and previous month
        assertEq(scalingPriceOracle.previousMonth(), storedCurrentMonth);
        assertEq(scalingPriceOracle.currentMonth(), newCurrentMonth);
    }

    function testFulfillFailureCalendar() public {
        vm.warp(block.timestamp + 1647240109);

        vm.expectRevert(
            bytes(""ScalingPriceOracle: cannot request data before the 15th"")
        );

        scalingPriceOracle.requestCPIData();
    }
}",1007
RealWorld_BA_102_Vcon_RealWord_20240827212550.log,102,Vcon,68364,5671,74035,98.0,0.45524,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

// Forked from Uniswap's UNI
// Reference: https://etherscan.io/address/0x1f9840a85d5af5bf1d1762f925bdaddc4201f984#code

contract Vcon {
    /// @notice EIP-20 token name for this token
    // solhint-disable-next-line const-name-snakecase
    string public constant name = ""Volt Controller"";

    /// @notice EIP-20 token symbol for this token
    // solhint-disable-next-line const-name-snakecase
    string public constant symbol = ""VCON"";

    /// @notice EIP-20 token decimals for this token
    // solhint-disable-next-line const-name-snakecase
    uint8 public constant decimals = 18;

    /// @notice Total number of tokens in circulation
    // solhint-disable-next-line const-name-snakecase
    uint256 public totalSupply = 1_000_000_000e18; // 1 billion Vcon

    /// @notice Address which may mint new tokens
    address public minter;

    /// @notice Allowance amounts on behalf of others
    mapping(address => mapping(address => uint96)) internal allowances;

    /// @notice Official record of token balances for each account
    mapping(address => uint96) internal balances;

    /// @notice A record of each accounts delegate
    mapping(address => address) public delegates;

    /// @notice A checkpoint for marking number of votes from a given block
    struct Checkpoint {
        uint32 fromBlock;
        uint96 votes;
    }

    /// @notice A record of votes checkpoints for each account, by index
    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;

    /// @notice The number of checkpoints for each account
    mapping(address => uint32) public numCheckpoints;

    /// @notice The EIP-712 typehash for the contract's domain
    bytes32 public constant DOMAIN_TYPEHASH =
        keccak256(
            ""EIP712Domain(string name,uint256 chainId,address verifyingContract)""
        );

    /// @notice The EIP-712 typehash for the delegation struct used by the contract
    bytes32 public constant DELEGATION_TYPEHASH =
        keccak256(""Delegation(address delegatee,uint256 nonce,uint256 expiry)"");

    /// @notice The EIP-712 typehash for the permit struct used by the contract
    bytes32 public constant PERMIT_TYPEHASH =
        keccak256(
            ""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)""
        );

    /// @notice A record of states for signing / validating signatures
    mapping(address => uint256) public nonces;

    /// @notice An event thats emitted when the minter address is changed
    event MinterChanged(address minter, address newMinter);

    /// @notice An event thats emitted when an account changes its delegate
    event DelegateChanged(
        address indexed delegator,
        address indexed fromDelegate,
        address indexed toDelegate
    );

    /// @notice An event thats emitted when a delegate account's vote balance changes
    event DelegateVotesChanged(
        address indexed delegate,
        uint256 previousBalance,
        uint256 newBalance
    );

    /// @notice The standard EIP-20 transfer event
    event Transfer(address indexed from, address indexed to, uint256 amount);

    /// @notice The standard EIP-20 approval event
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 amount
    );

    /**
     * @notice Construct a new Vcon token
     * @param account The initial account to grant all the tokens
     * @param minter_ The account with minting ability
     */
    constructor(address account, address minter_) {
        balances[account] = uint96(totalSupply);
        emit Transfer(address(0), account, totalSupply);
        minter = minter_;
        emit MinterChanged(address(0), minter);
    }

    /**
     * @notice Change the minter address
     * @param minter_ The address of the new minter
     */
    function setMinter(address minter_) external {
        require(
            msg.sender == minter,
            ""Vcon: only the minter can change the minter address""
        );
        emit MinterChanged(minter, minter_);
        minter = minter_;
    }

    /**
     * @notice Mint new tokens
     * @param dst The address of the destination account
     * @param rawAmount The number of tokens to be minted
     */
    function mint(address dst, uint256 rawAmount) external {
        require(msg.sender == minter, ""Vcon: only the minter can mint"");
        require(dst != address(0), ""Vcon: cannot transfer to the zero address"");

        // mint the amount
        uint96 amount = safe96(rawAmount, ""Vcon: amount exceeds 96 bits"");
        uint96 safeSupply = safe96(
            totalSupply,
            ""Vcon: totalSupply exceeds 96 bits""
        );
        totalSupply = add96(
            safeSupply,
            amount,
            ""Vcon: totalSupply exceeds 96 bits""
        );

        // transfer the amount to the recipient
        balances[dst] = add96(
            balances[dst],
            amount,
            ""Vcon: transfer amount overflows""
        );
        emit Transfer(address(0), dst, amount);

        // move delegates
        _moveDelegates(address(0), delegates[dst], amount);
    }

    /**
     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`
     * @param account The address of the account holding the funds
     * @param spender The address of the account spending the funds
     * @return The number of tokens approved
     */
    function allowance(address account, address spender)
        external
        view
        returns (uint256)
    {
        return allowances[account][spender];
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 rawAmount)
        external
        returns (bool)
    {
        uint96 amount;
        if (rawAmount == type(uint256).max) {
            amount = type(uint96).max;
        } else {
            amount = safe96(rawAmount, ""Vcon: amount exceeds 96 bits"");
        }

        allowances[msg.sender][spender] = amount;

        emit Approval(msg.sender, spender, amount);
        return true;
    }

    /**
     * @notice Triggers an approval from owner to spends
     * @param owner The address to approve from
     * @param spender The address to be approved
     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)
     * @param deadline The time at which to expire the signature
     * @param v The recovery byte of the signature
     * @param r Half of the ECDSA signature pair
     * @param s Half of the ECDSA signature pair
     */
    function permit(
        address owner,
        address spender,
        uint256 rawAmount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        uint96 amount;
        if (rawAmount == type(uint256).max) {
            amount = type(uint96).max;
        } else {
            amount = safe96(rawAmount, ""Vcon: amount exceeds 96 bits"");
        }

        bytes32 domainSeparator = keccak256(
            abi.encode(
                DOMAIN_TYPEHASH,
                keccak256(bytes(name)),
                getChainId(),
                address(this)
            )
        );
        bytes32 structHash = keccak256(
            abi.encode(
                PERMIT_TYPEHASH,
                owner,
                spender,
                rawAmount,
                nonces[owner]++,
                deadline
            )
        );
        bytes32 digest = keccak256(
            abi.encodePacked(""\x19\x01"", domainSeparator, structHash)
        );
        address signatory = ecrecover(digest, v, r, s);
        require(signatory != address(0), ""Vcon: invalid signature"");
        require(signatory == owner, ""Vcon: unauthorized"");
        require(block.timestamp <= deadline, ""Vcon: signature expired"");

        allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);
    }

    /**
     * @notice Get the number of tokens held by the `account`
     * @param account The address of the account to get the balance of
     * @return The number of tokens held
     */
    function balanceOf(address account) external view returns (uint256) {
        return balances[account];
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param rawAmount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 rawAmount) external returns (bool) {
        uint96 amount = safe96(rawAmount, ""Vcon: amount exceeds 96 bits"");
        _transferTokens(msg.sender, dst, amount);
        return true;
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param rawAmount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(
        address src,
        address dst,
        uint256 rawAmount
    ) external returns (bool) {
        address spender = msg.sender;
        uint96 spenderAllowance = allowances[src][spender];
        uint96 amount = safe96(rawAmount, ""Vcon: amount exceeds 96 bits"");

        if (spender != src && spenderAllowance != type(uint96).max) {
            uint96 newAllowance = sub96(
                spenderAllowance,
                amount,
                ""Vcon: transfer amount exceeds spender allowance""
            );
            allowances[src][spender] = newAllowance;

            emit Approval(src, spender, newAllowance);
        }

        _transferTokens(src, dst, amount);
        return true;
    }

    /**
     * @notice Delegate votes from `msg.sender` to `delegatee`
     * @param delegatee The address to delegate votes to
     */
    function delegate(address delegatee) public {
        return _delegate(msg.sender, delegatee);
    }

    /**
     * @notice Delegates votes from signatory to `delegatee`
     * @param delegatee The address to delegate votes to
     * @param nonce The contract state required to match the signature
     * @param expiry The time at which to expire the signature
     * @param v The recovery byte of the signature
     * @param r Half of the ECDSA signature pair
     * @param s Half of the ECDSA signature pair
     */
    function delegateBySig(
        address delegatee,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        bytes32 domainSeparator = keccak256(
            abi.encode(
                DOMAIN_TYPEHASH,
                keccak256(bytes(name)),
                getChainId(),
                address(this)
            )
        );
        bytes32 structHash = keccak256(
            abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry)
        );
        bytes32 digest = keccak256(
            abi.encodePacked(""\x19\x01"", domainSeparator, structHash)
        );
        address signatory = ecrecover(digest, v, r, s);
        require(signatory != address(0), ""Vcon: invalid signature"");
        require(nonce == nonces[signatory]++, ""Vcon: invalid nonce"");
        require(block.timestamp <= expiry, ""Vcon: signature expired"");
        return _delegate(signatory, delegatee);
    }

    /**
     * @notice Gets the current votes balance for `account`
     * @param account The address to get votes balance
     * @return The number of current votes for `account`
     */
    function getCurrentVotes(address account) external view returns (uint96) {
        uint32 nCheckpoints = numCheckpoints[account];
        return
            nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;
    }

    /**
     * @notice Determine the prior number of votes for an account as of a block number
     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.
     * @param account The address of the account to check
     * @param blockNumber The block number to get the vote balance at
     * @return The number of votes the account had as of the given block
     */
    function getPriorVotes(address account, uint256 blockNumber)
        public
        view
        returns (uint96)
    {
        require(blockNumber < block.number, ""Vcon: not yet determined"");

        uint32 nCheckpoints = numCheckpoints[account];
        if (nCheckpoints == 0) {
            return 0;
        }

        // First check most recent balance
        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nCheckpoints - 1].votes;
        }

        // Next check implicit zero balance
        if (checkpoints[account][0].fromBlock > blockNumber) {
            return 0;
        }

        uint32 lower = 0;
        uint32 upper = nCheckpoints - 1;
        while (upper > lower) {
            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow
            Checkpoint memory cp = checkpoints[account][center];
            if (cp.fromBlock == blockNumber) {
                return cp.votes;
            } else if (cp.fromBlock < blockNumber) {
                lower = center;
            } else {
                upper = center - 1;
            }
        }
        return checkpoints[account][lower].votes;
    }

    function _delegate(address delegator, address delegatee) internal {
        address currentDelegate = delegates[delegator];
        uint96 delegatorBalance = balances[delegator];
        delegates[delegator] = delegatee;

        emit DelegateChanged(delegator, currentDelegate, delegatee);

        _moveDelegates(currentDelegate, delegatee, delegatorBalance);
    }

    function _transferTokens(
        address src,
        address dst,
        uint96 amount
    ) internal {
        require(
            src != address(0),
            ""Vcon: cannot transfer from the zero address""
        );
        require(dst != address(0), ""Vcon: cannot transfer to the zero address"");

        balances[src] = sub96(
            balances[src],
            amount,
            ""Vcon: transfer amount exceeds balance""
        );
        balances[dst] = add96(
            balances[dst],
            amount,
            ""Vcon: transfer amount overflows""
        );
        emit Transfer(src, dst, amount);

        _moveDelegates(delegates[src], delegates[dst], amount);
    }

    function _moveDelegates(
        address srcRep,
        address dstRep,
        uint96 amount
    ) internal {
        if (srcRep != dstRep && amount > 0) {
            if (srcRep != address(0)) {
                uint32 srcRepNum = numCheckpoints[srcRep];
                uint96 srcRepOld = srcRepNum > 0
                    ? checkpoints[srcRep][srcRepNum - 1].votes
                    : 0;
                uint96 srcRepNew = sub96(
                    srcRepOld,
                    amount,
                    ""Vcon: vote amount underflows""
                );
                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);
            }

            if (dstRep != address(0)) {
                uint32 dstRepNum = numCheckpoints[dstRep];
                uint96 dstRepOld = dstRepNum > 0
                    ? checkpoints[dstRep][dstRepNum - 1].votes
                    : 0;
                uint96 dstRepNew = add96(
                    dstRepOld,
                    amount,
                    ""Vcon: vote amount overflows""
                );
                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);
            }
        }
    }

    function _writeCheckpoint(
        address delegatee,
        uint32 nCheckpoints,
        uint96 oldVotes,
        uint96 newVotes
    ) internal {
        uint32 blockNumber = safe32(
            block.number,
            ""Vcon: block number exceeds 32 bits""
        );

        if (
            nCheckpoints > 0 &&
            checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber
        ) {
            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;
        } else {
            checkpoints[delegatee][nCheckpoints] = Checkpoint(
                blockNumber,
                newVotes
            );
            numCheckpoints[delegatee] = nCheckpoints + 1;
        }

        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);
    }

    function safe32(uint256 n, string memory errorMessage)
        internal
        pure
        returns (uint32)
    {
        require(n < 2**32, errorMessage);
        return uint32(n);
    }

    function safe96(uint256 n, string memory errorMessage)
        internal
        pure
        returns (uint96)
    {
        require(n < 2**96, errorMessage);
        return uint96(n);
    }

    function add96(
        uint96 a,
        uint96 b,
        string memory errorMessage
    ) internal pure returns (uint96) {
        uint96 c = a + b;
        require(c >= a, errorMessage);
        return c;
    }

    function sub96(
        uint96 a,
        uint96 b,
        string memory errorMessage
    ) internal pure returns (uint96) {
        require(b <= a, errorMessage);
        return a - b;
    }

    function getChainId() internal view returns (uint256) {
        uint256 chainId;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            chainId := chainid()
        }
        return chainId;
    }
}",4041
RealWorld_BA_102_Volt.t_RealWord_20240827212730.log,102,Volt.t,8177,5195,13372,88.0,0.144785,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import {IVolt} from ""../../volt/Volt.sol"";
import {Volt} from ""../../volt/Volt.sol"";
import {ICore} from ""../../core/ICore.sol"";
import {Core} from ""../../core/Core.sol"";
import {Vm} from ""./utils/Vm.sol"";
import {DSTest} from ""./utils/DSTest.sol"";
import {getCore, getAddresses, FeiTestAddresses} from ""./utils/Fixtures.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";

contract VoltTest is DSTest {
    IVolt private volt;
    ICore private core;

    Vm public constant vm = Vm(HEVM_ADDRESS);
    FeiTestAddresses public addresses = getAddresses();

    function setUp() public {
        core = getCore();

        volt = core.volt();
    }

    function testDeployedMetaData() public {
        assertEq(volt.totalSupply(), 0);
        assertTrue(core.isGovernor(addresses.governorAddress));
    }

    function testMintsVolt() public {
        uint256 mintAmount = 100;

        vm.prank(addresses.minterAddress);
        volt.mint(addresses.userAddress, mintAmount);

        assertEq(volt.balanceOf(addresses.userAddress), mintAmount);
    }
}",312
RealWorld_BA_102_MockCoreRef_RealWord_20240827214602.log,102,MockCoreRef,5570,5056,10626,80.0,0.12897,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""../refs/CoreRef.sol"";

contract MockCoreRef is CoreRef {
    constructor(address core) CoreRef(core) {
        _setContractAdminRole(keccak256(""MOCK_CORE_REF_ADMIN""));
    }

    function testMinter() public view onlyMinter {}

    function testBurner() public view onlyBurner {}

    function testPCVController() public view onlyPCVController {}

    function testGovernor() public view onlyGovernor {}

    function testGuardian() public view onlyGuardianOrGovernor {}

    function testOnlyGovernorOrAdmin() public view onlyGovernorOrAdmin {}
}",150
RealWorld_BA_102_OracleRef_RealWord_20240827223033.log,102,OracleRef,23757,5792,29549,103.0,0.234625,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""./IOracleRef.sol"";
import ""./CoreRef.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";

/// @title Reference to an Oracle
/// @author Fei Protocol
/// @notice defines some utilities around interacting with the referenced oracle
abstract contract OracleRef is IOracleRef, CoreRef {
    using Decimal for Decimal.D256;
    using SafeCast for int256;

    /// @notice the oracle reference by the contract
    IOracle public override oracle;

    /// @notice the backup oracle reference by the contract
    IOracle public override backupOracle;

    /// @notice number of decimals to scale oracle price by, i.e. multiplying by 10^(decimalsNormalizer)
    int256 public override decimalsNormalizer;

    bool public override doInvert;

    /// @notice OracleRef constructor
    /// @param _core Fei Core to reference
    /// @param _oracle oracle to reference
    /// @param _backupOracle backup oracle to reference
    /// @param _decimalsNormalizer number of decimals to normalize the oracle feed if necessary
    /// @param _doInvert invert the oracle price if this flag is on
    constructor(
        address _core,
        address _oracle,
        address _backupOracle,
        int256 _decimalsNormalizer,
        bool _doInvert
    ) CoreRef(_core) {
        _setOracle(_oracle);
        if (_backupOracle != address(0) && _backupOracle != _oracle) {
            _setBackupOracle(_backupOracle);
        }
        _setDoInvert(_doInvert);
        _setDecimalsNormalizer(_decimalsNormalizer);
    }

    /// @notice sets the referenced oracle
    /// @param newOracle the new oracle to reference
    function setOracle(address newOracle) external override onlyGovernor {
        _setOracle(newOracle);
    }

    /// @notice sets the flag for whether to invert or not
    /// @param newDoInvert the new flag for whether to invert
    function setDoInvert(bool newDoInvert) external override onlyGovernor {
        _setDoInvert(newDoInvert);
    }

    /// @notice sets the new decimalsNormalizer
    /// @param newDecimalsNormalizer the new decimalsNormalizer
    function setDecimalsNormalizer(int256 newDecimalsNormalizer)
        external
        override
        onlyGovernor
    {
        _setDecimalsNormalizer(newDecimalsNormalizer);
    }

    /// @notice sets the referenced backup oracle
    /// @param newBackupOracle the new backup oracle to reference
    function setBackupOracle(address newBackupOracle)
        external
        override
        onlyGovernorOrAdmin
    {
        _setBackupOracle(newBackupOracle);
    }

    /// @notice invert a peg price
    /// @param price the peg price to invert
    /// @return the inverted peg as a Decimal
    /// @dev the inverted peg would be X per FEI
    function invert(Decimal.D256 memory price)
        public
        pure
        override
        returns (Decimal.D256 memory)
    {
        return Decimal.one().div(price);
    }

    /// @notice updates the referenced oracle
    function updateOracle() public override {
        oracle.update();
    }

    /// @notice the peg price of the referenced oracle
    /// @return the peg as a Decimal
    /// @dev the peg is defined as FEI per X with X being ETH, dollars, etc
    function readOracle() public view override returns (Decimal.D256 memory) {
        (Decimal.D256 memory _peg, bool valid) = oracle.read();
        if (!valid && address(backupOracle) != address(0)) {
            (_peg, valid) = backupOracle.read();
        }
        require(valid, ""OracleRef: oracle invalid"");

        // Scale the oracle price by token decimals delta if necessary
        uint256 scalingFactor;
        if (decimalsNormalizer < 0) {
            scalingFactor = 10**(-1 * decimalsNormalizer).toUint256();
            _peg = _peg.div(scalingFactor);
        } else {
            scalingFactor = 10**decimalsNormalizer.toUint256();
            _peg = _peg.mul(scalingFactor);
        }

        // Invert the oracle price if necessary
        if (doInvert) {
            _peg = invert(_peg);
        }
        return _peg;
    }

    function _setOracle(address newOracle) internal {
        require(newOracle != address(0), ""OracleRef: zero address"");
        address oldOracle = address(oracle);
        oracle = IOracle(newOracle);
        emit OracleUpdate(oldOracle, newOracle);
    }

    // Supports zero address if no backup
    function _setBackupOracle(address newBackupOracle) internal {
        address oldBackupOracle = address(backupOracle);
        backupOracle = IOracle(newBackupOracle);
        emit BackupOracleUpdate(oldBackupOracle, newBackupOracle);
    }

    function _setDoInvert(bool newDoInvert) internal {
        bool oldDoInvert = doInvert;
        doInvert = newDoInvert;

        if (oldDoInvert != newDoInvert) {
            _setDecimalsNormalizer(-1 * decimalsNormalizer);
        }

        emit InvertUpdate(oldDoInvert, newDoInvert);
    }

    function _setDecimalsNormalizer(int256 newDecimalsNormalizer) internal {
        int256 oldDecimalsNormalizer = decimalsNormalizer;
        decimalsNormalizer = newDecimalsNormalizer;
        emit DecimalsNormalizerUpdate(
            oldDecimalsNormalizer,
            newDecimalsNormalizer
        );
    }

    function _setDecimalsNormalizerFromToken(address token) internal {
        int256 feiDecimals = 18;
        int256 _decimalsNormalizer = feiDecimals -
            int256(uint256(IERC20Metadata(token).decimals()));

        if (doInvert) {
            _decimalsNormalizer = -1 * _decimalsNormalizer;
        }

        _setDecimalsNormalizer(_decimalsNormalizer);
    }
}",1337
RealWorld_BA_102_TribeRoles_RealWord_20240827212415.log,102,TribeRoles,16041,5374,21415,93.0,0.187685,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

/**
 @title Tribe DAO ACL Roles
 @notice Holds a complete list of all roles which can be held by contracts inside Tribe DAO.
         Roles are broken up into 3 categories:
         * Major Roles - the most powerful roles in the Tribe DAO which should be carefully managed.
         * Admin Roles - roles with management capability over critical functionality. Should only be held by automated or optimistic mechanisms
         * Minor Roles - operational roles. May be held or managed by shorter optimistic timelocks or trusted multisigs.
 */
library TribeRoles {
    /*///////////////////////////////////////////////////////////////
                                 Major Roles
    //////////////////////////////////////////////////////////////*/

    /// @notice the ultimate role of Tribe. Controls all other roles and protocol functionality.
    bytes32 internal constant GOVERNOR = keccak256(""GOVERN_ROLE"");

    /// @notice the protector role of Tribe. Admin of pause, veto, revoke, and minor roles
    bytes32 internal constant GUARDIAN = keccak256(""GUARDIAN_ROLE"");

    /// @notice the role which can arbitrarily move PCV in any size from any contract
    bytes32 internal constant PCV_CONTROLLER = keccak256(""PCV_CONTROLLER_ROLE"");

    /// @notice can mint FEI arbitrarily
    bytes32 internal constant MINTER = keccak256(""MINTER_ROLE"");

    /*///////////////////////////////////////////////////////////////
                                 Admin Roles
    //////////////////////////////////////////////////////////////*/

    /// @notice can manage the majority of Tribe protocol parameters. Sets boundaries for MINOR_PARAM_ROLE.
    bytes32 internal constant PARAMETER_ADMIN = keccak256(""PARAMETER_ADMIN"");

    /// @notice manages the Collateralization Oracle as well as other protocol oracles.
    bytes32 internal constant ORACLE_ADMIN = keccak256(""ORACLE_ADMIN_ROLE"");

    /// @notice manages TribalChief incentives and related functionality.
    bytes32 internal constant TRIBAL_CHIEF_ADMIN =
        keccak256(""TRIBAL_CHIEF_ADMIN_ROLE"");

    /// @notice admin of PCVGuardian
    bytes32 internal constant PCV_GUARDIAN_ADMIN =
        keccak256(""PCV_GUARDIAN_ADMIN_ROLE"");

    /// @notice admin of all Minor Roles
    bytes32 internal constant MINOR_ROLE_ADMIN = keccak256(""MINOR_ROLE_ADMIN"");

    /// @notice admin of the Fuse protocol
    bytes32 internal constant FUSE_ADMIN = keccak256(""FUSE_ADMIN"");

    /// @notice capable of vetoing DAO votes or optimistic timelocks
    bytes32 internal constant VETO_ADMIN = keccak256(""VETO_ADMIN"");

    /// @notice capable of setting FEI Minters within global rate limits and caps
    bytes32 internal constant MINTER_ADMIN = keccak256(""MINTER_ADMIN"");

    /// @notice manages the constituents of Optimistic Timelocks, including Proposers and Executors
    bytes32 internal constant OPTIMISTIC_ADMIN = keccak256(""OPTIMISTIC_ADMIN"");

    /*///////////////////////////////////////////////////////////////
                                 Minor Roles
    //////////////////////////////////////////////////////////////*/

    /// @notice capable of poking existing LBP auctions to exchange tokens.
    bytes32 internal constant LBP_SWAP_ROLE = keccak256(""SWAP_ADMIN_ROLE"");

    /// @notice capable of engaging with Votium for voting incentives.
    bytes32 internal constant VOTIUM_ROLE = keccak256(""VOTIUM_ADMIN_ROLE"");

    /// @notice capable of changing parameters within non-critical ranges
    bytes32 internal constant MINOR_PARAM_ROLE = keccak256(""MINOR_PARAM_ROLE"");

    /// @notice capable of adding an address to multi rate limited
    bytes32 internal constant ADD_MINTER_ROLE = keccak256(""ADD_MINTER_ROLE"");

    /// @notice capable of changing PCV Deposit and Global Rate Limited Minter in the PSM
    bytes32 internal constant PSM_ADMIN_ROLE = keccak256(""PSM_ADMIN_ROLE"");
}",796
RealWorld_BA_102_OraclePassThrough_RealWord_20240827215715.log,102,OraclePassThrough,11539,5145,16684,85.0,0.160595,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {Decimal} from ""../external/Decimal.sol"";
import {CoreRef} from ""./../refs/CoreRef.sol"";
import {IScalingPriceOracle} from ""./IScalingPriceOracle.sol"";
import {IOraclePassThrough} from ""./IOraclePassThrough.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

/// @notice contract that passes all price calls to the Scaling Price Oracle
/// The Scaling Price Oracle can be changed if there is a decision to change how data is interpolated
/// without needing all contracts in the system to be upgraded, only this contract will have to change where it points
/// @author Elliot Friedman
contract OraclePassThrough is IOraclePassThrough, Ownable {
    using Decimal for Decimal.D256;

    /// @notice reference to the scaling price oracle
    IScalingPriceOracle public override scalingPriceOracle;

    constructor(IScalingPriceOracle _scalingPriceOracle) Ownable() {
        scalingPriceOracle = _scalingPriceOracle;
    }

    /// @notice updates the oracle price
    /// @dev no-op, ScalingPriceOracle is updated automatically
    /// added for backwards compatibility with OracleRef
    function update() public {}

    // ----------- Getters -----------

    /// @notice function to get the current oracle price for the OracleRef contract
    function read()
        external
        view
        override
        returns (Decimal.D256 memory price, bool valid)
    {
        uint256 currentPrice = scalingPriceOracle.getCurrentOraclePrice();

        price = Decimal.from(currentPrice).div(1e18);
        valid = true;
    }

    /// @notice function to get the current oracle price for the entire system
    function getCurrentOraclePrice() external view override returns (uint256) {
        return scalingPriceOracle.getCurrentOraclePrice();
    }

    // ----------- Governance only state changing api -----------

    /// @notice function to update the pointer to the scaling price oracle
    /// requires approval from all parties on multisig to update
    function updateScalingPriceOracle(IScalingPriceOracle newScalingPriceOracle)
        external
        override
        onlyOwner
    {
        IScalingPriceOracle oldScalingPriceOracle = scalingPriceOracle;
        scalingPriceOracle = newScalingPriceOracle;

        emit ScalingPriceOracleUpdate(
            oldScalingPriceOracle,
            newScalingPriceOracle
        );
    }
}",508
RealWorld_BA_102_MockERC20_RealWord_20240827214844.log,102,MockERC20,5874,4358,10232,70.0,0.11653,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MockERC20 is ERC20, ERC20Burnable {
    constructor() ERC20(""MockToken"", ""MCT"") {}

    function mint(address account, uint256 amount) public returns (bool) {
        _mint(account, amount);
        return true;
    }

    function mockBurn(address account, uint256 amount) public returns (bool) {
        _burn(account, amount);
        return true;
    }

    function approveOverride(
        address owner,
        address spender,
        uint256 amount
    ) public {
        _approve(owner, spender, amount);
    }
}",178
RealWorld_BA_102_MockMinter_RealWord_20240827214442.log,102,MockMinter,5378,5300,10678,78.0,0.13289,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""./../utils/GlobalRateLimitedMinter.sol"";

contract MockMinter {
    GlobalRateLimitedMinter globalRateLimitedMinter;

    constructor(GlobalRateLimitedMinter _globalRateLimitedMinter) {
        globalRateLimitedMinter = _globalRateLimitedMinter;
    }

    function mintFei(address to, uint256 amount) external {
        globalRateLimitedMinter.mintVolt(to, amount);
    }

    function mintAllFei(address to) external {
        globalRateLimitedMinter.mintMaxAllowableVolt(to);
    }
}",140
RealWorld_BA_102_ScalingPriceOracle_RealWord_20240827215842.log,102,ScalingPriceOracle,34480,5848,40328,96.0,0.28936,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {Timed} from ""./../utils/Timed.sol"";
import {CoreRef} from ""./../refs/CoreRef.sol"";
import {Decimal} from ""../external/Decimal.sol"";
import {Constants} from ""./../Constants.sol"";
import {Deviation} from ""./../utils/Deviation.sol"";
import {IScalingPriceOracle} from ""./IScalingPriceOracle.sol"";
import {BokkyPooBahsDateTimeContract} from ""./../external/calendar/BokkyPooBahsDateTimeContract.sol"";
import {Math} from ""@openzeppelin/contracts/utils/math/Math.sol"";
import {SafeCast} from ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import {ERC20, IERC20} from ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import {ChainlinkClient, Chainlink} from ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";

/// @notice contract that receives a chainlink price feed and then linearly interpolates that rate over
/// a 28 day period into the VOLT price. Interest is compounded monthly when the rate is updated
/// @author Elliot Friedman
contract ScalingPriceOracle is
    Timed,
    ChainlinkClient,
    IScalingPriceOracle,
    BokkyPooBahsDateTimeContract
{
    using SafeCast for *;
    using Deviation for *;
    using Decimal for Decimal.D256;
    using Chainlink for Chainlink.Request;

    /// ---------- Mutable Price Variables ----------

    /// @notice current amount that oracle price is inflating/deflating by monthly in basis points
    int256 public override monthlyChangeRateBasisPoints;

    /// @notice oracle price. starts off at 1e18 and compounds monthly
    uint256 public override oraclePrice = 1e18;

    /// ---------- Mutable CPI Variables Packed Into Single Storage Slot to Save an SSTORE & SLOAD ----------

    /// @notice the current month's CPI data
    uint128 public currentMonth;

    /// @notice the previous month's CPI data
    uint128 public previousMonth;

    /// ---------- Immutable Variables ----------

    /// @notice the time frame over which all changes in CPI data are applied
    /// 28 days was chosen as that is the shortest length of a month
    uint256 public constant override TIMEFRAME = 28 days;

    /// @notice the maximum allowable deviation in basis points for a new chainlink oracle update
    /// only allow price changes by 20% in a month.
    /// Any change over this threshold in either direction will be rejected
    uint256 public constant override MAXORACLEDEVIATION = 2_000;

    /// @notice address of chainlink oracle to send request
    address public immutable oracle;

    /// @notice job id that retrieves the latest CPI data
    bytes32 public immutable jobId;

    /// @notice amount in LINK paid to node operator for each request
    uint256 public immutable fee;

    /// @param _oracle address of chainlink data provider
    /// @param _jobid job id
    /// @param _fee maximum fee paid to chainlink data provider
    /// @param _currentMonth current month's inflation data
    /// @param _previousMonth previous month's inflation data
    constructor(
        address _oracle,
        bytes32 _jobid,
        uint256 _fee,
        uint128 _currentMonth,
        uint128 _previousMonth
    ) Timed(TIMEFRAME) {
        uint256 chainId;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            chainId := chainid()
        }

        if (chainId == 1 || chainId == 42) {
            setPublicChainlinkToken();
        }

        oracle = _oracle;
        jobId = _jobid;
        fee = _fee;

        currentMonth = _currentMonth;
        previousMonth = _previousMonth;

        _initTimed();

        /// calculate new monthly CPI-U rate in basis points based on current and previous month
        int256 aprBasisPoints = getMonthlyAPR();

        /// store data and apply the change rate over the next month to the VOLT price
        _oracleUpdateChangeRate(aprBasisPoints);
    }

    // ----------- Getters -----------

    /// @notice get the current scaled oracle price
    /// applies the change smoothly over a 28 day period
    /// scaled by 18 decimals
    // prettier-ignore
    function getCurrentOraclePrice() public view override returns (uint256) {
        int256 oraclePriceInt = oraclePrice.toInt256();

        int256 timeDelta = Math.min(block.timestamp - startTime, TIMEFRAME).toInt256();
        int256 pricePercentageChange = oraclePriceInt * monthlyChangeRateBasisPoints / Constants.BP_INT;
        int256 priceDelta = pricePercentageChange * timeDelta / TIMEFRAME.toInt256();

        return (oraclePriceInt + priceDelta).toUint256();
    }

    /// @notice get APR from chainlink data by measuring (current month - previous month) / previous month
    /// @return percentageChange percentage change in basis points over past month
    function getMonthlyAPR() public view returns (int256 percentageChange) {
        int256 delta = int128(currentMonth) - int128(previousMonth);
        percentageChange = (delta * Constants.BP_INT) / int128(previousMonth);
    }

    /// ------------- Public API To Request Chainlink Data -------------

    /// @notice Create a Chainlink request to retrieve API response, find the target
    /// data, then multiply by 1000 (to remove decimal places from data).
    /// @return requestId for this request
    /// only allows 1 request per month after the 14th day
    /// callable by anyone after time period and 14th day of the month
    function requestCPIData()
        external
        afterTimeInit
        returns (bytes32 requestId)
    {
        require(
            getDay(block.timestamp) > 14,
            ""ScalingPriceOracle: cannot request data before the 15th""
        );

        Chainlink.Request memory request = buildChainlinkRequest(
            jobId,
            address(this),
            this.fulfill.selector
        );

        return sendChainlinkRequestTo(oracle, request, fee);
    }

    /// ------------- Chainlink Node Operator API -------------

    /// @notice Receive the response in the form of uint256
    /// @param _requestId of the chainlink request
    /// @param _cpiData latest CPI data from BLS
    /// called by the chainlink oracle
    function fulfill(bytes32 _requestId, uint256 _cpiData)
        external
        recordChainlinkFulfillment(_requestId)
    {
        _updateCPIData(_cpiData);
    }

    // ----------- Internal state changing api -----------

    /// @notice helper function to store and validate new chainlink data
    /// @param _cpiData latest CPI data from BLS
    /// update will fail if new values exceed deviation threshold of 20% monthly
    function _updateCPIData(uint256 _cpiData) internal {
        require(
            MAXORACLEDEVIATION.isWithinDeviationThreshold(
                currentMonth.toInt256(),
                _cpiData.toInt256()
            ),
            ""ScalingPriceOracle: Chainlink data outside of deviation threshold""
        );

        /// store CPI data, removes stale data
        _addNewMonth(uint128(_cpiData));

        /// calculate new monthly CPI-U rate in basis points
        int256 aprBasisPoints = getMonthlyAPR();

        /// pass data to VOLT Price Oracle
        _oracleUpdateChangeRate(aprBasisPoints);
    }

    /// @notice function for chainlink oracle to be able to call in and change the rate
    /// @param newChangeRateBasisPoints the new monthly interest rate applied to the chainlink oracle price
    ///
    /// function effects:
    ///   compounds interest accumulated over period
    ///   set new change rate in basis points for next period
    function _oracleUpdateChangeRate(int256 newChangeRateBasisPoints) internal {
        /// compound the interest with the current rate
        oraclePrice = getCurrentOraclePrice();

        int256 currentChangeRateBasisPoints = monthlyChangeRateBasisPoints; /// save 1 SSLOAD

        /// emit even if there isn't an update
        emit CPIMonthlyChangeRateUpdate(
            currentChangeRateBasisPoints,
            newChangeRateBasisPoints
        );

        /// if the oracle change rate is the same as last time, save an SSTORE
        if (newChangeRateBasisPoints == currentChangeRateBasisPoints) {
            return;
        }

        monthlyChangeRateBasisPoints = newChangeRateBasisPoints;
    }

    /// @notice this is the only method needed as we will be storing the most recent 2 months of data
    /// @param newMonth the new month to store
    function _addNewMonth(uint128 newMonth) internal {
        previousMonth = currentMonth;

        currentMonth = newMonth;
    }
}",1922
RealWorld_BA_102_NonCustodialPSM_RealWord_20240827221812.log,102,NonCustodialPSM,66013,5531,71544,106.0,0.440685,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {Decimal} from ""../external/Decimal.sol"";
import {Constants} from ""../Constants.sol"";
import {OracleRef} from ""./../refs/OracleRef.sol"";
import {TribeRoles} from ""./../core/TribeRoles.sol"";
import {RateLimited} from ""./../utils/RateLimited.sol"";
import {IPCVDeposit, PCVDeposit} from ""./../pcv/PCVDeposit.sol"";
import {INonCustodialPSM} from ""./INonCustodialPSM.sol"";
import {GlobalRateLimitedMinter} from ""./../utils/GlobalRateLimitedMinter.sol"";
import {Math} from ""@openzeppelin/contracts/utils/math/Math.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeCast} from ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import {ReentrancyGuard} from ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

/// @notice Peg Stability Module that holds no funds.
/// On a mint, it transfers all proceeds to a PCV Deposit
/// When funds are needed for a redemption, they are simply pulled from the PCV Deposit
contract NonCustodialPSM is
    OracleRef,
    RateLimited,
    ReentrancyGuard,
    INonCustodialPSM
{
    using Decimal for Decimal.D256;
    using SafeCast for *;
    using SafeERC20 for IERC20;

    /// @notice the fee in basis points for selling an asset into VOLT
    uint256 public override mintFeeBasisPoints;

    /// @notice the fee in basis points for buying the asset for VOLT
    uint256 public override redeemFeeBasisPoints;

    /// @notice the PCV deposit target to deposit and withdraw from
    IPCVDeposit public override pcvDeposit;

    /// @notice the token this PSM will exchange for VOLT
    /// Must be a stable token pegged to $1
    IERC20 public immutable override underlyingToken;

    /// @notice Rate Limited Minter contract that will be called when VOLT needs to be minted
    GlobalRateLimitedMinter public override rateLimitedMinter;

    /// @notice the max mint and redeem fee in basis points
    /// Governance cannot change the maximum fee
    uint256 public immutable override MAX_FEE = 300;

    /// @notice boolean switch that indicates whether redeeming is paused
    bool public redeemPaused;

    /// @notice boolean switch that indicates whether minting is paused
    bool public mintPaused;

    /// @notice struct for passing constructor parameters related to OracleRef
    struct OracleParams {
        address coreAddress;
        address oracleAddress;
        address backupOracle;
        int256 decimalsNormalizer;
    }

    /// @notice struct for passing constructor parameters related to MultiRateLimited
    struct RateLimitedParams {
        uint256 maxRateLimitPerSecond;
        uint256 rateLimitPerSecond;
        uint256 bufferCap;
    }

    /// @notice struct for passing constructor parameters related to the non custodial PSM
    struct PSMParams {
        uint256 mintFeeBasisPoints;
        uint256 redeemFeeBasisPoints;
        IERC20 underlyingToken;
        IPCVDeposit pcvDeposit;
        GlobalRateLimitedMinter rateLimitedMinter;
    }

    /// @notice construct the non custodial PSM. Structs are used to prevent stack too deep errors
    /// @param params oracle ref constructor data
    /// @param rateLimitedParams rate limited constructor data
    /// @param psmParams non custodial PSM constructor data
    constructor(
        OracleParams memory params,
        RateLimitedParams memory rateLimitedParams,
        PSMParams memory psmParams
    )
        OracleRef(
            params.coreAddress,
            params.oracleAddress,
            params.backupOracle,
            params.decimalsNormalizer,
            true /// hardcode doInvert to true to allow swaps to work correctly
        )
        /// rate limited replenishable passes false as the last param as there can be no partial actions
        RateLimited(
            rateLimitedParams.maxRateLimitPerSecond,
            rateLimitedParams.rateLimitPerSecond,
            rateLimitedParams.bufferCap,
            false
        )
    {
        underlyingToken = psmParams.underlyingToken;

        _setGlobalRateLimitedMinter(psmParams.rateLimitedMinter);
        _setMintFee(psmParams.mintFeeBasisPoints);
        _setRedeemFee(psmParams.redeemFeeBasisPoints);
        _setPCVDeposit(psmParams.pcvDeposit);
    }

    // ----------- Mint & Redeem pausing modifiers -----------

    /// @notice modifier that allows execution when redemptions are not paused
    modifier whileRedemptionsNotPaused() {
        require(!redeemPaused, ""PegStabilityModule: Redeem paused"");
        _;
    }

    /// @notice modifier that allows execution when minting is not paused
    modifier whileMintingNotPaused() {
        require(!mintPaused, ""PegStabilityModule: Minting paused"");
        _;
    }

    // ----------- Governor & Guardian only pausing api -----------

    /// @notice set secondary pausable methods to paused
    function pauseRedeem() external onlyGuardianOrGovernor {
        redeemPaused = true;
        emit RedemptionsPaused(msg.sender);
    }

    /// @notice set secondary pausable methods to unpaused
    function unpauseRedeem() external onlyGuardianOrGovernor {
        redeemPaused = false;
        emit RedemptionsUnpaused(msg.sender);
    }

    /// @notice set secondary pausable methods to paused
    function pauseMint() external onlyGuardianOrGovernor {
        mintPaused = true;
        emit MintingPaused(msg.sender);
    }

    /// @notice set secondary pausable methods to unpaused
    function unpauseMint() external onlyGuardianOrGovernor {
        mintPaused = false;
        emit MintingUnpaused(msg.sender);
    }

    // ----------- Governor, psm admin and parameter admin only state changing api -----------

    /// @notice set the mint fee vs oracle price in basis point terms
    /// @param newMintFeeBasisPoints the new fee in basis points for minting
    function setMintFee(uint256 newMintFeeBasisPoints)
        external
        override
        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PARAMETER_ADMIN)
    {
        _setMintFee(newMintFeeBasisPoints);
    }

    /// @notice set the redemption fee vs oracle price in basis point terms
    /// @param newRedeemFeeBasisPoints the new fee in basis points for redemptions
    function setRedeemFee(uint256 newRedeemFeeBasisPoints)
        external
        override
        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PARAMETER_ADMIN)
    {
        _setRedeemFee(newRedeemFeeBasisPoints);
    }

    /// @notice set the target for sending all PCV
    /// @param newTarget new PCV Deposit target for this PSM
    function setPCVDeposit(IPCVDeposit newTarget)
        external
        override
        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PSM_ADMIN_ROLE)
    {
        _setPCVDeposit(newTarget);
    }

    /// @notice set the target to call for VOLT minting
    /// @param newMinter new Global Rate Limited Minter for this PSM
    function setGlobalRateLimitedMinter(GlobalRateLimitedMinter newMinter)
        external
        override
        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PSM_ADMIN_ROLE)
    {
        _setGlobalRateLimitedMinter(newMinter);
    }

    // ----------- PCV Controller only state changing api -----------

    /// @notice withdraw ERC20 from the contract
    /// @param token address of the ERC20 to send
    /// @param to address destination of the ERC20
    /// @param amount quantity of ERC20 to send
    function withdrawERC20(
        address token,
        address to,
        uint256 amount
    ) external override onlyPCVController {
        IERC20(token).safeTransfer(to, amount);
        emit WithdrawERC20(msg.sender, token, to, amount);
    }

    // ----------- Public State Changing API -----------

    /// @notice function to redeem VOLT for an underlying asset
    /// We do not burn VOLT; this allows the contract's balance of VOLT to be used before the buffer is used
    /// In practice, this helps prevent artificial cycling of mint-burn cycles and prevents DOS attacks.
    /// This function will deplete the buffer based on the amount of VOLT that is being redeemed.
    /// @param to the destination address for proceeds
    /// @param amountVoltIn the amount of VOLT to sell
    /// @param minAmountOut the minimum amount out otherwise the TX will fail
    function redeem(
        address to,
        uint256 amountVoltIn,
        uint256 minAmountOut
    )
        external
        virtual
        override
        nonReentrant
        whenNotPaused
        whileRedemptionsNotPaused
        returns (uint256 amountOut)
    {
        _depleteBuffer(amountVoltIn); /// deplete buffer first to save gas on buffer exhaustion sad path

        updateOracle();

        amountOut = _getRedeemAmountOut(amountVoltIn);
        require(
            amountOut >= minAmountOut,
            ""PegStabilityModule: Redeem not enough out""
        );

        IERC20(volt()).safeTransferFrom(
            msg.sender,
            address(this),
            amountVoltIn
        );

        pcvDeposit.withdraw(to, amountOut);

        emit Redeem(to, amountVoltIn, amountOut);
    }

    /// @notice function to buy VOLT for an underlying asset that is pegged to $1
    /// We first transfer any contract-owned VOLT, then mint the remaining if necessary
    /// This function will replenish the buffer based on the amount of VOLT that is being sent out.
    /// @param to the destination address for proceeds
    /// @param amountIn the amount of external asset to sell to the PSM
    /// @param minVoltAmountOut the minimum amount of VOLT out otherwise the TX will fail
    function mint(
        address to,
        uint256 amountIn,
        uint256 minVoltAmountOut
    )
        external
        virtual
        override
        nonReentrant
        whenNotPaused
        whileMintingNotPaused
        returns (uint256 amountVoltOut)
    {
        updateOracle();

        amountVoltOut = _getMintAmountOut(amountIn);
        require(
            amountVoltOut >= minVoltAmountOut,
            ""PegStabilityModule: Mint not enough out""
        );

        underlyingToken.safeTransferFrom(
            msg.sender,
            address(pcvDeposit),
            amountIn
        );

        uint256 amountFeiToTransfer = Math.min(
            volt().balanceOf(address(this)),
            amountVoltOut
        );
        uint256 amountFeiToMint = amountVoltOut - amountFeiToTransfer;

        if (amountFeiToTransfer != 0) {
            IERC20(volt()).safeTransfer(to, amountFeiToTransfer);
        }

        if (amountFeiToMint != 0) {
            rateLimitedMinter.mintVolt(to, amountFeiToMint);
        }

        _replenishBuffer(amountVoltOut);

        emit Mint(to, amountIn, amountVoltOut);
    }

    // ----------- Public View-Only API ----------

    /// @notice calculate the amount of VOLT out for a given `amountIn` of underlying
    /// First get oracle price of token
    /// Then figure out how many dollars that amount in is worth by multiplying price * amount.
    /// ensure decimals are normalized if on underlying they are not 18
    /// @param amountIn the amount of external asset to sell to the PSM
    /// @return amountVoltOut the amount of VOLT received for the amountIn of external asset
    function getMintAmountOut(uint256 amountIn)
        public
        view
        override
        returns (uint256 amountVoltOut)
    {
        amountVoltOut = _getMintAmountOut(amountIn);
    }

    /// @notice calculate the amount of underlying out for a given `amountVoltIn` of VOLT
    /// First get oracle price of token
    /// Then figure out how many dollars that amount in is worth by multiplying price * amount.
    /// ensure decimals are normalized if on underlying they are not 18
    /// @param amountVoltIn the amount of VOLT to redeem
    /// @return amountTokenOut the amount of the external asset received in exchange for the amount of VOLT redeemed
    function getRedeemAmountOut(uint256 amountVoltIn)
        public
        view
        override
        returns (uint256 amountTokenOut)
    {
        amountTokenOut = _getRedeemAmountOut(amountVoltIn);
    }

    /// @notice getter to return the maximum amount of VOLT that could be purchased at once
    /// @return the maximum amount of VOLT available for purchase at once through this PSM
    function getMaxMintAmountOut() external view override returns (uint256) {
        return
            volt().balanceOf(address(this)) +
            rateLimitedMinter.individualBuffer(address(this));
    }

    // ----------- Internal Methods -----------

    /// @notice helper function to get mint amount out based on current market prices
    /// @dev will revert if price is outside of bounds and price bound PSM is being used
    /// @param amountIn the amount of stable asset in
    /// @return amountVoltOut the amount of VOLT received for the amountIn of stable assets
    function _getMintAmountOut(uint256 amountIn)
        internal
        view
        virtual
        returns (uint256 amountVoltOut)
    {
        Decimal.D256 memory price = readOracle();
        _validatePriceRange(price);

        Decimal.D256 memory adjustedAmountIn = price.mul(amountIn);

        amountVoltOut = adjustedAmountIn
            .mul(Constants.BASIS_POINTS_GRANULARITY - mintFeeBasisPoints)
            .div(Constants.BASIS_POINTS_GRANULARITY)
            .asUint256();
    }

    /// @notice helper function to get redeem amount out based on current market prices
    /// @dev will revert if price is outside of bounds and price bound PSM is being used
    /// @param amountVoltIn the amount of VOLT to redeem
    /// @return amountTokenOut the amount of the external asset received in exchange for the amount of VOLT redeemed
    function _getRedeemAmountOut(uint256 amountVoltIn)
        internal
        view
        virtual
        returns (uint256 amountTokenOut)
    {
        Decimal.D256 memory price = readOracle();
        _validatePriceRange(price);

        /// get amount of VOLT being provided being redeemed after fees
        Decimal.D256 memory adjustedAmountIn = Decimal.from(
            (amountVoltIn *
                (Constants.BASIS_POINTS_GRANULARITY - redeemFeeBasisPoints)) /
                Constants.BASIS_POINTS_GRANULARITY
        );

        /// now turn the VOLT into the underlying token amounts
        /// amount VOLT in / VOLT you receive for $1 = how much stable token to pay out
        amountTokenOut = adjustedAmountIn.div(price).asUint256();
    }

    // ----------- Helper methods to change state -----------

    /// @notice set the global rate limited minter this PSM calls to mint VOLT
    /// @param newMinter the new minter contract that this PSM will reference
    function _setGlobalRateLimitedMinter(GlobalRateLimitedMinter newMinter)
        internal
    {
        require(
            address(newMinter) != address(0),
            ""PegStabilityModule: Invalid new GlobalRateLimitedMinter""
        );
        GlobalRateLimitedMinter oldMinter = rateLimitedMinter;
        rateLimitedMinter = newMinter;

        emit GlobalRateLimitedMinterUpdate(oldMinter, newMinter);
    }

    /// @notice set the mint fee vs oracle price in basis point terms
    /// @param newMintFeeBasisPoints the new fee for minting in basis points
    function _setMintFee(uint256 newMintFeeBasisPoints) internal {
        require(
            newMintFeeBasisPoints <= MAX_FEE,
            ""PegStabilityModule: Mint fee exceeds max fee""
        );
        uint256 _oldMintFee = mintFeeBasisPoints;
        mintFeeBasisPoints = newMintFeeBasisPoints;

        emit MintFeeUpdate(_oldMintFee, newMintFeeBasisPoints);
    }

    /// @notice internal helper function to set the redemption fee
    /// @param newRedeemFeeBasisPoints the new fee for redemptions in basis points
    function _setRedeemFee(uint256 newRedeemFeeBasisPoints) internal {
        require(
            newRedeemFeeBasisPoints <= MAX_FEE,
            ""PegStabilityModule: Redeem fee exceeds max fee""
        );
        uint256 _oldRedeemFee = redeemFeeBasisPoints;
        redeemFeeBasisPoints = newRedeemFeeBasisPoints;

        emit RedeemFeeUpdate(_oldRedeemFee, newRedeemFeeBasisPoints);
    }

    /// @notice helper function to set the PCV deposit
    /// @param newPCVDeposit the new PCV deposit that this PSM will pull assets from and deposit assets into
    function _setPCVDeposit(IPCVDeposit newPCVDeposit) internal {
        require(
            address(newPCVDeposit) != address(0),
            ""PegStabilityModule: Invalid new PCVDeposit""
        );
        require(
            newPCVDeposit.balanceReportedIn() == address(underlyingToken),
            ""PegStabilityModule: Underlying token mismatch""
        );
        IPCVDeposit oldTarget = pcvDeposit;
        pcvDeposit = newPCVDeposit;

        emit PCVDepositUpdate(oldTarget, newPCVDeposit);
    }

    // ----------- Hooks -----------

    /// @notice overriden function in the price bound PSM
    function _validatePriceRange(Decimal.D256 memory price)
        internal
        view
        virtual
    {}
}",3992
RealWorld_BA_102_MockPCVDepositV2_RealWord_20240827215538.log,102,MockPCVDepositV2,10507,4983,15490,95.0,0.152195,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""../refs/CoreRef.sol"";
import ""../pcv/IPCVDeposit.sol"";

contract MockPCVDepositV2 is IPCVDeposit, CoreRef {
    address public override balanceReportedIn;

    uint256 private resistantBalance;
    uint256 private resistantProtocolOwnedFei;

    constructor(
        address _core,
        address _token,
        uint256 _resistantBalance,
        uint256 _resistantProtocolOwnedFei
    ) CoreRef(_core) {
        balanceReportedIn = _token;
        resistantBalance = _resistantBalance;
        resistantProtocolOwnedFei = _resistantProtocolOwnedFei;
    }

    receive() external payable {}

    function set(uint256 _resistantBalance, uint256 _resistantProtocolOwnedFei)
        public
    {
        resistantBalance = _resistantBalance;
        resistantProtocolOwnedFei = _resistantProtocolOwnedFei;
    }

    // gets the resistant token balance and protocol owned fei of this deposit
    function resistantBalanceAndVolt()
        external
        view
        override
        returns (uint256, uint256)
    {
        return (resistantBalance, resistantProtocolOwnedFei);
    }

    // IPCVDeposit V1
    function deposit() external override {
        resistantBalance = IERC20(balanceReportedIn).balanceOf(address(this));
    }

    function withdraw(address to, uint256 amount) external override {
        IERC20(balanceReportedIn).transfer(to, amount);
        resistantBalance = IERC20(balanceReportedIn).balanceOf(address(this));
    }

    function withdrawERC20(
        address token,
        address to,
        uint256 amount
    ) external override {
        IERC20(token).transfer(to, amount);
    }

    function withdrawETH(address payable to, uint256 amount)
        external
        override
        onlyPCVController
    {
        to.transfer(amount);
    }

    function balance() external view override returns (uint256) {
        return IERC20(balanceReportedIn).balanceOf(address(this));
    }
}",451
RealWorld_BA_102_PCVDeposit_RealWord_20240827222000.log,102,PCVDeposit,9476,5106,14582,75.0,0.1495,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""../refs/CoreRef.sol"";
import ""./IPCVDeposit.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

/// @title abstract contract for withdrawing ERC-20 tokens using a PCV Controller
/// @author Fei Protocol
abstract contract PCVDeposit is IPCVDeposit, CoreRef {
    using SafeERC20 for IERC20;

    /// @notice withdraw ERC20 from the contract
    /// @param token address of the ERC20 to send
    /// @param to address destination of the ERC20
    /// @param amount quantity of ERC20 to send
    function withdrawERC20(
        address token,
        address to,
        uint256 amount
    ) public virtual override onlyPCVController {
        _withdrawERC20(token, to, amount);
    }

    function _withdrawERC20(
        address token,
        address to,
        uint256 amount
    ) internal {
        IERC20(token).safeTransfer(to, amount);
        emit WithdrawERC20(msg.sender, token, to, amount);
    }

    /// @notice withdraw ETH from the contract
    /// @param to address to send ETH
    /// @param amountOut amount of ETH to send
    function withdrawETH(address payable to, uint256 amountOut)
        external
        virtual
        override
        onlyPCVController
    {
        Address.sendValue(to, amountOut);
        emit WithdrawETH(msg.sender, to, amountOut);
    }

    function balance() public view virtual override returns (uint256);

    function resistantBalanceAndVolt()
        public
        view
        virtual
        override
        returns (uint256, uint256)
    {
        return (balance(), 0);
    }
}",383
RealWorld_BA_102_WETH9_RealWord_20240827224010.log,102,WETH9,12754,5538,18292,93.0,0.17453,"/**
 *Submitted for verification at Etherscan.io on 2017-12-12
 */

// Copyright (C) 2015, 2016, 2017 Dapphub

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity ^0.4.18;

contract WETH9 {
    string public name = ""Wrapped Ether"";
    string public symbol = ""WETH"";
    uint8 public decimals = 18;

    event Approval(address indexed src, address indexed guy, uint256 wad);
    event Transfer(address indexed src, address indexed dst, uint256 wad);
    event Deposit(address indexed dst, uint256 wad);
    event Withdrawal(address indexed src, uint256 wad);

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    function() public payable {
        deposit();
    }

    function init() external {
        decimals = 18;
        name = ""Wrapped Ether"";
        symbol = ""WETH"";
    }

    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
        Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 wad) public {
        require(balanceOf[msg.sender] >= wad);
        balanceOf[msg.sender] -= wad;
        msg.sender.transfer(wad);
        Withdrawal(msg.sender, wad);
    }

    function totalSupply() public view returns (uint256) {
        return this.balance;
    }

    function approve(address guy, uint256 wad) public returns (bool) {
        allowance[msg.sender][guy] = wad;
        Approval(msg.sender, guy, wad);
        return true;
    }

    function transfer(address dst, uint256 wad) public returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }

    function transferFrom(
        address src,
        address dst,
        uint256 wad
    ) public returns (bool) {
        require(balanceOf[src] >= wad);

        if (src != msg.sender && allowance[src][msg.sender] != uint256(-1)) {
            require(allowance[src][msg.sender] >= wad);
            allowance[src][msg.sender] -= wad;
        }

        balanceOf[src] -= wad;
        balanceOf[dst] += wad;

        Transfer(src, dst, wad);

        return true;
    }
}",631
RealWorld_BA_102_Volt_RealWord_20240827223346.log,102,Volt,14523,5326,19849,108.0,0.179135,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"";
import ""../refs/CoreRef.sol"";

/// @title FEI stablecoin
/// @author Fei Protocol
contract Volt is IVolt, ERC20Burnable, CoreRef {
    // solhint-disable-next-line var-name-mixedcase
    bytes32 public DOMAIN_SEPARATOR;
    // keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    bytes32 public constant PERMIT_TYPEHASH =
        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
    mapping(address => uint256) public nonces;

    /// @notice Fei token constructor
    /// @param core Fei Core address to reference
    constructor(address core) ERC20(""VOLT"", ""VOLT"") CoreRef(core) {
        uint256 chainId;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            chainId := chainid()
        }
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256(
                    ""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""
                ),
                keccak256(bytes(name())),
                keccak256(bytes(""1"")),
                chainId,
                address(this)
            )
        );
    }

    /// @notice mint FEI tokens
    /// @param account the account to mint to
    /// @param amount the amount to mint
    function mint(address account, uint256 amount)
        external
        override
        onlyMinter
        whenNotPaused
    {
        _mint(account, amount);
        emit Minting(account, msg.sender, amount);
    }

    /// @notice burn FEI tokens from caller
    /// @param amount the amount to burn
    function burn(uint256 amount) public override(IVolt, ERC20Burnable) {
        super.burn(amount);
        emit Burning(msg.sender, msg.sender, amount);
    }

    /// @notice permit spending of FEI
    /// @param owner the FEI holder
    /// @param spender the approved operator
    /// @param value the amount approved
    /// @param deadline the deadline after which the approval is no longer valid
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external override {
        require(deadline >= block.timestamp, ""Fei: EXPIRED"");
        bytes32 digest = keccak256(
            abi.encodePacked(
                ""\x19\x01"",
                DOMAIN_SEPARATOR,
                keccak256(
                    abi.encode(
                        PERMIT_TYPEHASH,
                        owner,
                        spender,
                        value,
                        nonces[owner]++,
                        deadline
                    )
                )
            )
        );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(
            recoveredAddress != address(0) && recoveredAddress == owner,
            ""Fei: INVALID_SIGNATURE""
        );
        _approve(owner, spender, value);
    }
}",694
RealWorld_BA_102_MockCore_RealWord_20240827215402.log,102,MockCore,12648,5327,17975,94.0,0.16978,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import ""./../core/Permissions.sol"";
import ""../vcon/Vcon.sol"";
import ""../volt/Volt.sol"";

import ""@openzeppelin/contracts/proxy/utils/Initializable.sol"";

/// @title Mock Source of truth for Fei Protocol
/// @author Fei Protocol
/// @notice maintains roles, access control, fei, tribe, genesisGroup, and the TRIBE treasury
contract MockCore is Permissions, Initializable {
    /// @notice the address of the FEI contract
    IVolt public volt;

    /// @notice the address of the TRIBE contract
    IERC20 public vcon;

    constructor() {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }

        require(chainId != 1, ""MockCore: cannot deploy to mainnet"");
    }

    function init(address recipient) external initializer {
        /// emulate the real core as much as possible
        _setupGovernor(msg.sender);

        Volt _volt = new Volt(address(this));
        volt = IVolt(_volt);

        /// give all VCON to the recipient
        /// grant timelock the minter role
        Vcon _vcon = new Vcon(recipient, msg.sender);
        vcon = IERC20(address(_vcon));

        _setupGovernor(msg.sender);
    }

    /// @notice checks if address is a minter
    /// @return true _address is a minter
    // only virtual for testing mock override
    function isMinter(address) external view virtual override returns (bool) {
        return true;
    }

    /// @notice checks if address is a burner
    /// @return true _address is a burner
    // only virtual for testing mock override
    function isBurner(address) external view virtual override returns (bool) {
        return true;
    }

    /// @notice checks if address is a controller
    /// @return true _address is a controller
    // only virtual for testing mock override
    function isPCVController(address)
        external
        view
        virtual
        override
        returns (bool)
    {
        return true;
    }

    /// @notice checks if address is a governor
    /// @return true _address is a governor
    // only virtual for testing mock override
    function isGovernor(address) public view virtual override returns (bool) {
        return true;
    }

    /// @notice checks if address is a guardian
    /// @return true _address is a guardian
    // only virtual for testing mock override
    function isGuardian(address) public view virtual override returns (bool) {
        return true;
    }
}",576
RealWorld_BA_102_StdLib_RealWord_20240827214033.log,102,StdLib,47479,5139,52618,82.0,0.340175,"// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import ""./Vm.sol"";

// Wrappers around Cheatcodes to avoid footguns
abstract contract StdLib {
    // we use a custom name that is unlikely to cause collisions so this contract
    // can be inherited easily
    Vm constant vm_std_cheats =
        Vm(address(uint160(uint256(keccak256(""hevm cheat code"")))));

    // Skip forward or rewind time by the specified number of seconds
    function skip(uint256 time) public {
        vm_std_cheats.warp(block.timestamp + time);
    }

    function rewind(uint256 time) public {
        vm_std_cheats.warp(block.timestamp - time);
    }

    // Setup a prank from an address that has some ether
    function hoax(address who) public {
        vm_std_cheats.deal(who, 1 << 128);
        vm_std_cheats.prank(who);
    }

    function hoax(address who, uint256 give) public {
        vm_std_cheats.deal(who, give);
        vm_std_cheats.prank(who);
    }

    function hoax(address who, address) public {
        vm_std_cheats.deal(who, 1 << 128);
        vm_std_cheats.prank(who, who);
    }

    function hoax(
        address who,
        address,
        uint256 give
    ) public {
        vm_std_cheats.deal(who, give);
        vm_std_cheats.prank(who, who);
    }

    // Start perpetual prank from an address that has some ether
    function startHoax(address who) public {
        vm_std_cheats.deal(who, 1 << 128);
        vm_std_cheats.startPrank(who);
    }

    function startHoax(address who, uint256 give) public {
        vm_std_cheats.deal(who, give);
        vm_std_cheats.startPrank(who);
    }

    // Start perpetual prank from an address that has some ether
    // tx.origin is set to the origin parameter
    function startHoax(address who, address origin) public {
        vm_std_cheats.deal(who, 1 << 128);
        vm_std_cheats.startPrank(who, origin);
    }

    function startHoax(
        address who,
        address origin,
        uint256 give
    ) public {
        vm_std_cheats.deal(who, give);
        vm_std_cheats.startPrank(who, origin);
    }

    // Deploys a contract by fetching the contract bytecode from
    // the artifacts directory
    function deployCode(string memory what, bytes memory args)
        public
        returns (address addr)
    {
        bytes memory bytecode = abi.encodePacked(
            vm_std_cheats.getCode(what),
            args
        );
        assembly {
            addr := create(0, add(bytecode, 0x20), mload(bytecode))
        }
    }

    function deployCode(string memory what) public returns (address addr) {
        bytes memory bytecode = vm_std_cheats.getCode(what);
        assembly {
            addr := create(0, add(bytecode, 0x20), mload(bytecode))
        }
    }
}

library stdError {
    bytes public constant assertionError =
        abi.encodeWithSignature(""Panic(uint256)"", 0x01);
    bytes public constant arithmeticError =
        abi.encodeWithSignature(""Panic(uint256)"", 0x11);
    bytes public constant divisionError =
        abi.encodeWithSignature(""Panic(uint256)"", 0x12);
    bytes public constant enumConversionError =
        abi.encodeWithSignature(""Panic(uint256)"", 0x21);
    bytes public constant encodeStorageError =
        abi.encodeWithSignature(""Panic(uint256)"", 0x22);
    bytes public constant popError =
        abi.encodeWithSignature(""Panic(uint256)"", 0x31);
    bytes public constant indexOOBError =
        abi.encodeWithSignature(""Panic(uint256)"", 0x32);
    bytes public constant memOverflowError =
        abi.encodeWithSignature(""Panic(uint256)"", 0x41);
    bytes public constant zeroVarError =
        abi.encodeWithSignature(""Panic(uint256)"", 0x51);
}

struct StdStorage {
    mapping(address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;
    mapping(address => mapping(bytes4 => mapping(bytes32 => bool))) finds;
    bytes32[] _keys;
    bytes4 _sig;
    uint256 _depth;
    address _target;
    bytes32 _set;
}

library stdStorage {
    error NotFound(bytes4);
    error NotStorage(bytes4);
    error PackedSlot(bytes32);

    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);
    event WARNING_UninitedSlot(address who, uint256 slot);

    Vm constant stdstore_vm =
        Vm(address(uint160(uint256(keccak256(""hevm cheat code"")))));

    function sigs(string memory sigStr) internal pure returns (bytes4) {
        return bytes4(keccak256(bytes(sigStr)));
    }

    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against
    // slot complexity:
    //  if flat, will be bytes32(uint256(uint));
    //  if map, will be keccak256(abi.encode(key, uint(slot)));
    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));
    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);
    function find(StdStorage storage self) internal returns (uint256) {
        address who = self._target;
        bytes4 fsig = self._sig;
        uint256 field_depth = self._depth;
        bytes32[] memory ins = self._keys;

        // calldata to test against
        if (
            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]
        ) {
            return
                self.slots[who][fsig][
                    keccak256(abi.encodePacked(ins, field_depth))
                ];
        }
        bytes memory cald = abi.encodePacked(fsig, flatten(ins));
        stdstore_vm.record();
        bytes32 fdat;
        {
            (, bytes memory rdat) = who.staticcall(cald);
            fdat = bytesToBytes32(rdat, 32 * field_depth);
        }

        (bytes32[] memory reads, ) = stdstore_vm.accesses(address(who));
        if (reads.length == 1) {
            bytes32 curr = stdstore_vm.load(who, reads[0]);
            if (curr == bytes32(0)) {
                emit WARNING_UninitedSlot(who, uint256(reads[0]));
            }
            if (fdat != curr) {
                revert PackedSlot(reads[0]);
            }
            emit SlotFound(
                who,
                fsig,
                keccak256(abi.encodePacked(ins, field_depth)),
                uint256(reads[0])
            );
            self.slots[who][fsig][
                keccak256(abi.encodePacked(ins, field_depth))
            ] = uint256(reads[0]);
            self.finds[who][fsig][
                keccak256(abi.encodePacked(ins, field_depth))
            ] = true;
        } else if (reads.length > 1) {
            for (uint256 i = 0; i < reads.length; i++) {
                bytes32 prev = stdstore_vm.load(who, reads[i]);
                if (prev == bytes32(0)) {
                    emit WARNING_UninitedSlot(who, uint256(reads[i]));
                }
                // store
                stdstore_vm.store(who, reads[i], bytes32(hex""1337""));
                {
                    (, bytes memory rdat) = who.staticcall(cald);
                    fdat = bytesToBytes32(rdat, 32 * field_depth);
                }

                if (fdat == bytes32(hex""1337"")) {
                    // we found which of the slots is the actual one
                    emit SlotFound(
                        who,
                        fsig,
                        keccak256(abi.encodePacked(ins, field_depth)),
                        uint256(reads[i])
                    );
                    self.slots[who][fsig][
                        keccak256(abi.encodePacked(ins, field_depth))
                    ] = uint256(reads[i]);
                    self.finds[who][fsig][
                        keccak256(abi.encodePacked(ins, field_depth))
                    ] = true;
                    stdstore_vm.store(who, reads[i], prev);
                    break;
                }
                stdstore_vm.store(who, reads[i], prev);
            }
        } else {
            revert NotStorage(fsig);
        }

        if (
            !self.finds[who][fsig][
                keccak256(abi.encodePacked(ins, field_depth))
            ]
        ) revert NotFound(fsig);

        delete self._target;
        delete self._sig;
        delete self._keys;
        delete self._depth;

        return
            self.slots[who][fsig][
                keccak256(abi.encodePacked(ins, field_depth))
            ];
    }

    function target(StdStorage storage self, address _target)
        internal
        returns (StdStorage storage)
    {
        self._target = _target;
        return self;
    }

    function sig(StdStorage storage self, bytes4 _sig)
        internal
        returns (StdStorage storage)
    {
        self._sig = _sig;
        return self;
    }

    function sig(StdStorage storage self, string memory _sig)
        internal
        returns (StdStorage storage)
    {
        self._sig = sigs(_sig);
        return self;
    }

    function with_key(StdStorage storage self, address who)
        internal
        returns (StdStorage storage)
    {
        self._keys.push(bytes32(uint256(uint160(who))));
        return self;
    }

    function with_key(StdStorage storage self, uint256 amt)
        internal
        returns (StdStorage storage)
    {
        self._keys.push(bytes32(amt));
        return self;
    }

    function with_key(StdStorage storage self, bytes32 key)
        internal
        returns (StdStorage storage)
    {
        self._keys.push(key);
        return self;
    }

    function depth(StdStorage storage self, uint256 _depth)
        internal
        returns (StdStorage storage)
    {
        self._depth = _depth;
        return self;
    }

    function checked_write(StdStorage storage self, address who) internal {
        checked_write(self, bytes32(uint256(uint160(who))));
    }

    function checked_write(StdStorage storage self, uint256 amt) internal {
        checked_write(self, bytes32(amt));
    }

    function checked_write(StdStorage storage self, bytes32 set) internal {
        address who = self._target;
        bytes4 fsig = self._sig;
        uint256 field_depth = self._depth;
        bytes32[] memory ins = self._keys;

        bytes memory cald = abi.encodePacked(fsig, flatten(ins));
        if (
            !self.finds[who][fsig][
                keccak256(abi.encodePacked(ins, field_depth))
            ]
        ) {
            find(self);
        }
        bytes32 slot = bytes32(
            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]
        );

        bytes32 fdat;
        {
            (, bytes memory rdat) = who.staticcall(cald);
            fdat = bytesToBytes32(rdat, 32 * field_depth);
        }
        bytes32 curr = stdstore_vm.load(who, slot);

        if (fdat != curr) {
            revert PackedSlot(slot);
        }
        stdstore_vm.store(who, slot, set);
        delete self._target;
        delete self._sig;
        delete self._keys;
        delete self._depth;
    }

    function bytesToBytes32(bytes memory b, uint256 offset)
        public
        pure
        returns (bytes32)
    {
        bytes32 out;

        for (uint256 i = 0; i < 32; i++) {
            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);
        }
        return out;
    }

    function flatten(bytes32[] memory b) private pure returns (bytes memory) {
        bytes memory result = new bytes(b.length * 32);
        for (uint256 i = 0; i < b.length; i++) {
            bytes32 k = b[i];
            assembly {
                mstore(add(result, add(32, mul(32, i))), k)
            }
        }

        return result;
    }
}",2776
RealWorld_BA_102_OraclePassThrough.t_RealWord_20240827213334.log,102,OraclePassThrough.t,14820,5219,20039,90.0,0.17848,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {Vm} from ""./../utils/Vm.sol"";
import {DSTest} from ""./../utils/DSTest.sol"";
import {getCore, getAddresses, FeiTestAddresses} from ""./../utils/Fixtures.sol"";
import {MockScalingPriceOracle} from ""../../../mock/MockScalingPriceOracle.sol"";
import {OraclePassThrough} from ""../../../oracle/OraclePassThrough.sol"";
import {ScalingPriceOracle} from ""../../../oracle/ScalingPriceOracle.sol"";
import {Decimal} from ""./../../../external/Decimal.sol"";

contract OraclePassThroughTest is DSTest {
    using Decimal for Decimal.D256;

    MockScalingPriceOracle private scalingPriceOracle;

    OraclePassThrough private oraclePassThrough;

    /// @notice increase price by 3.09% per month
    int256 public constant monthlyChangeRateBasisPoints = 309;

    /// @notice the current month's CPI data
    uint128 public constant currentMonth = 270000;

    /// @notice the previous month's CPI data
    uint128 public constant previousMonth = 261900;

    /// @notice address of chainlink oracle to send request
    address public immutable oracle = address(0);

    /// @notice job id that retrieves the latest CPI data
    bytes32 public immutable jobId =
        keccak256(abi.encodePacked(""Chainlink CPI-U job""));

    /// @notice fee of 10 link
    uint256 public immutable fee = 1e19;

    Vm public constant vm = Vm(HEVM_ADDRESS);
    FeiTestAddresses public addresses = getAddresses();

    function setUp() public {
        /// warp to 1 to set isTimeStarted to true
        vm.warp(1);

        scalingPriceOracle = new MockScalingPriceOracle(
            oracle,
            jobId,
            fee,
            currentMonth,
            previousMonth
        );

        oraclePassThrough = new OraclePassThrough(
            ScalingPriceOracle(address(scalingPriceOracle))
        );
    }

    function testSetup() public {
        assertEq(
            address(oraclePassThrough.scalingPriceOracle()),
            address(scalingPriceOracle)
        );
        assertEq(oraclePassThrough.owner(), address(this));
    }

    function testDataPassThroughSync() public {
        assertEq(
            oraclePassThrough.getCurrentOraclePrice(),
            scalingPriceOracle.getCurrentOraclePrice()
        );

        (Decimal.D256 memory oPrice, bool oValid) = oraclePassThrough.read();
        assertEq(oPrice.value, scalingPriceOracle.getCurrentOraclePrice());
        assertTrue(oValid);
    }

    function testUpdateScalingPriceOracleFailureNotGovernor() public {
        vm.startPrank(address(0));
        vm.expectRevert(bytes(""Ownable: caller is not the owner""));

        oraclePassThrough.updateScalingPriceOracle(
            ScalingPriceOracle(address(scalingPriceOracle))
        );
        vm.stopPrank();
    }

    function testUpdateScalingPriceOracleSuccess() public {
        ScalingPriceOracle newScalingPriceOracle = ScalingPriceOracle(
            address(
                new MockScalingPriceOracle(
                    oracle,
                    jobId,
                    fee,
                    currentMonth,
                    previousMonth
                )
            )
        );

        oraclePassThrough.updateScalingPriceOracle(newScalingPriceOracle);

        /// assert that scaling price oracle was updated to new contract
        assertEq(
            address(newScalingPriceOracle),
            address(oraclePassThrough.scalingPriceOracle())
        );
    }
}",724
RealWorld_BA_102_Timed_RealWord_20240827221458.log,102,Timed,11650,5038,16688,94.0,0.15901,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

/// @title an abstract contract for timed events
/// @author Fei Protocol
abstract contract Timed {
    /// @notice the start timestamp of the timed period
    uint256 public startTime;

    /// @notice the duration of the timed period
    uint256 public duration;

    event DurationUpdate(uint256 oldDuration, uint256 newDuration);

    event TimerReset(uint256 startTime);

    constructor(uint256 _duration) {
        _setDuration(_duration);
    }

    modifier duringTime() {
        require(isTimeStarted(), ""Timed: time not started"");
        require(!isTimeEnded(), ""Timed: time ended"");
        _;
    }

    modifier afterTime() {
        require(isTimeEnded(), ""Timed: time not ended"");
        _;
    }

    modifier afterTimeInit() {
        require(isTimeEnded(), ""Timed: time not ended, init"");
        _;
        _initTimed();
    }

    /// @notice return true if time period has ended
    function isTimeEnded() public view returns (bool) {
        return remainingTime() == 0;
    }

    /// @notice number of seconds remaining until time is up
    /// @return remaining
    function remainingTime() public view returns (uint256) {
        return duration - timeSinceStart(); // duration always >= timeSinceStart which is on [0,d]
    }

    /// @notice number of seconds since contract was initialized
    /// @return timestamp
    /// @dev will be less than or equal to duration
    function timeSinceStart() public view returns (uint256) {
        if (!isTimeStarted()) {
            return 0; // uninitialized
        }
        uint256 _duration = duration;
        uint256 timePassed = block.timestamp - startTime; // block timestamp always >= startTime
        return timePassed > _duration ? _duration : timePassed;
    }

    function isTimeStarted() public view returns (bool) {
        return startTime != 0;
    }

    function _initTimed() internal {
        startTime = block.timestamp;

        emit TimerReset(block.timestamp);
    }

    function _setDuration(uint256 newDuration) internal {
        require(newDuration != 0, ""Timed: zero duration"");

        uint256 oldDuration = duration;
        duration = newDuration;
        emit DurationUpdate(oldDuration, newDuration);
    }
}",514
RealWorld_BA_102_MockRateLimitedMinter_RealWord_20240827214724.log,102,MockRateLimitedMinter,5989,5086,11075,78.0,0.131665,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""../volt/minter/RateLimitedMinter.sol"";

contract MockRateLimitedMinter is RateLimitedMinter {
    constructor(
        address _core,
        uint256 _feiLimitPerSecond,
        uint256 _mintingBufferCap,
        bool _doPartialMint
    )
        CoreRef(_core)
        RateLimitedMinter(_feiLimitPerSecond, _mintingBufferCap, _doPartialMint)
    {}

    function setDoPartialMint(bool _doPartialMint) public {
        doPartialAction = _doPartialMint;
    }

    function mint(address to, uint256 amount) public {
        _mintVolt(to, amount);
    }
}",168
RealWorld_BA_102_NonCustodialPSM.t_RealWord_20240827213035.log,102,NonCustodialPSM.t,75845,5034,80879,94.0,0.479905,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {ERC20, IERC20} from ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import {MockPCVDepositV2} from ""../../../mock/MockPCVDepositV2.sol"";
import {IPCVDeposit} from ""../../../pcv/IPCVDeposit.sol"";
import {MockERC20} from ""../../../mock/MockERC20.sol"";
import {OraclePassThrough} from ""../../../oracle/OraclePassThrough.sol"";
import {ScalingPriceOracle} from ""../../../oracle/ScalingPriceOracle.sol"";
import {MockScalingPriceOracle} from ""../../../mock/MockScalingPriceOracle.sol"";
import {ICore} from ""../../../core/ICore.sol"";
import {Core} from ""../../../core/Core.sol"";
import {IVolt, Volt} from ""../../../volt/Volt.sol"";
import {NonCustodialPSM, GlobalRateLimitedMinter} from ""./../../../peg/NonCustodialPSM.sol"";
import {Vm} from ""./../utils/Vm.sol"";
import {DSTest} from ""./../utils/DSTest.sol"";
import {getCore, getAddresses, FeiTestAddresses} from ""./../utils/Fixtures.sol"";

contract NonCustodialPSMTest is DSTest {
    GlobalRateLimitedMinter private rateLimitedMinter;
    NonCustodialPSM private psm;
    ICore private core;
    IVolt private volt;

    /// ------------ Minting and RateLimited System Params ------------

    uint256 public constant mintAmount = 10_000_000e18;
    uint256 public constant bufferCap = 10_000_000e18;
    uint256 public constant individualMaxBufferCap = 5_000_000e18;
    uint256 public constant rps = 10_000e18;

    /// ------------ Oracle System Params ------------

    /// @notice prices during test will increase 1% monthly
    int256 public constant monthlyChangeRateBasisPoints = 100;
    uint256 public constant maxDeviationThresholdBasisPoints = 1_000;

    MockERC20 public underlyingToken;
    MockPCVDepositV2 public pcvDeposit;
    OraclePassThrough public oracle;

    Vm public constant vm = Vm(HEVM_ADDRESS);
    FeiTestAddresses public addresses = getAddresses();

    function setUp() public {
        core = getCore();

        volt = core.volt();
        MockScalingPriceOracle mockScalingPriceOracle = new MockScalingPriceOracle(
                address(0),
                keccak256(abi.encodePacked(""test"")),
                10e18,
                101,
                100
            );

        oracle = new OraclePassThrough(
            ScalingPriceOracle(address(mockScalingPriceOracle))
        );
        underlyingToken = new MockERC20();
        pcvDeposit = new MockPCVDepositV2(
            address(core),
            address(underlyingToken),
            0,
            0
        );

        rateLimitedMinter = new GlobalRateLimitedMinter(
            address(core),
            rps,
            rps,
            rps,
            individualMaxBufferCap,
            bufferCap
        );

        NonCustodialPSM.OracleParams memory oracleParams = NonCustodialPSM
            .OracleParams({
                coreAddress: address(core),
                oracleAddress: address(oracle),
                backupOracle: address(0),
                decimalsNormalizer: 0
            });

        NonCustodialPSM.RateLimitedParams
            memory multiRateLimitedParams = NonCustodialPSM.RateLimitedParams({
                maxRateLimitPerSecond: rps,
                rateLimitPerSecond: rps,
                bufferCap: bufferCap
            });

        NonCustodialPSM.PSMParams memory PSMParams = NonCustodialPSM.PSMParams({
            mintFeeBasisPoints: 0,
            redeemFeeBasisPoints: 0,
            underlyingToken: underlyingToken,
            pcvDeposit: pcvDeposit,
            rateLimitedMinter: rateLimitedMinter
        });

        /// create PSM
        psm = new NonCustodialPSM(
            oracleParams,
            multiRateLimitedParams,
            PSMParams
        );

        vm.startPrank(addresses.governorAddress);

        /// grant the PSM the PCV Controller role
        core.grantMinter(addresses.governorAddress);
        core.grantMinter(address(rateLimitedMinter));
        core.grantPCVController(address(psm));
        core.grantPCVController(addresses.governorAddress);
        rateLimitedMinter.addAddress(
            address(psm),
            uint112(rps),
            uint112(bufferCap)
        );

        /// mint FEI to the user
        volt.mint(address(this), mintAmount);

        vm.stopPrank();

        /// mint the PSM and user some stable coins
        underlyingToken.mint(address(pcvDeposit), mintAmount);
        underlyingToken.mint(address(this), mintAmount);

        /// invest all excess tokens in the PCV deposit
        pcvDeposit.deposit();
    }

    /// @notice PSM is set up correctly, all state variables and balances are correct
    function testPSMSetup() public {
        uint256 startingPSMUnderlyingBalance = underlyingToken.balanceOf(
            address(psm)
        );
        uint256 startingUserFEIBalance = volt.balanceOf(address(this));

        assertEq(startingPSMUnderlyingBalance, 0);
        assertEq(startingUserFEIBalance, mintAmount);

        assertTrue(core.isPCVController(address(psm)));
        assertTrue(core.isMinter(address(rateLimitedMinter)));
    }

    /// @notice PSM is set up correctly and view functions are working
    function testGetRedeemAmountOut() public {
        uint256 amountFeiIn = 100;
        assertEq(psm.getRedeemAmountOut(amountFeiIn), amountFeiIn);
    }

    /// @notice PSM is set up correctly and view functions are working
    function testGetMaxMintAmountOut() public {
        assertEq(psm.getMaxMintAmountOut(), bufferCap);

        vm.startPrank(addresses.governorAddress);
        volt.mint(address(psm), mintAmount);
        vm.stopPrank();

        assertEq(psm.getMaxMintAmountOut(), bufferCap + mintAmount);
    }

    /// @notice PSM is set up correctly and view functions are working
    function testGetMintAmountOut() public {
        uint256 amountFeiIn = 100;
        assertEq(psm.getMintAmountOut(amountFeiIn), amountFeiIn);
    }

    /// @notice PSM is set up correctly and view functions are working
    function testGetRedeemAmountOutAfterTime() public {
        uint256 amountVoltIn = 100_000;
        uint256 expectedAmountStableOut = 101_000;

        /// advance the full time period to get the full 1% price increase
        vm.warp(28 days + block.timestamp);

        assertEq(psm.getRedeemAmountOut(amountVoltIn), expectedAmountStableOut);
    }

    /// @notice PSM is set up correctly and view functions are working
    function testGetMintAmountOutAfterTime() public {
        /// assert that for 101 stables you get 100 VOLT after volt price increases 1%
        uint256 amountStableIn = 101_000;
        uint256 expectedAmountVoltOut = 99999; /// subtract 1 for precision loss from doInvert

        /// advance the full time period to get the full 1% price increase
        vm.warp(28 days + block.timestamp);

        assertEq(psm.getMintAmountOut(amountStableIn), expectedAmountVoltOut);
    }

    /// @notice pcv deposit receives underlying token on mint
    function testSwapUnderlyingForFeiAfterPriceIncrease() public {
        uint256 amountStableIn = 101_000;
        uint256 amountVoltOut = 99999; /// subtract 1 for precision loss from doInvert

        vm.warp(28 days + block.timestamp);

        underlyingToken.approve(address(psm), amountStableIn);
        psm.mint(address(this), amountStableIn, amountVoltOut);

        uint256 endingUserFEIBalance = volt.balanceOf(address(this));
        uint256 endingPSMUnderlyingBalance = underlyingToken.balanceOf(
            address(psm)
        );
        uint256 endingPCVDepositUnderlyingBalance = underlyingToken.balanceOf(
            address(pcvDeposit)
        );

        assertEq(
            endingPCVDepositUnderlyingBalance,
            mintAmount + amountStableIn
        );
        assertEq(endingPSMUnderlyingBalance, 0);
        assertEq(endingUserFEIBalance, mintAmount + amountVoltOut);
    }

    /// @notice pcv deposit receives underlying token on mint
    function testSwapUnderlyingForFei() public {
        underlyingToken.approve(address(psm), mintAmount);
        psm.mint(address(this), mintAmount, mintAmount);

        uint256 endingUserFEIBalance = volt.balanceOf(address(this));
        uint256 endingPSMUnderlyingBalance = underlyingToken.balanceOf(
            address(psm)
        );
        uint256 endingPCVDepositUnderlyingBalance = underlyingToken.balanceOf(
            address(pcvDeposit)
        );

        assertEq(endingPCVDepositUnderlyingBalance, mintAmount * 2);
        assertEq(endingPSMUnderlyingBalance, 0);
        assertEq(endingUserFEIBalance, mintAmount * 2);
    }

    /// @notice pcv deposit gets depleted on redeem
    function testSwapFeiForUnderlying() public {
        volt.approve(address(psm), mintAmount);
        psm.redeem(address(this), mintAmount, mintAmount);

        uint256 endingUserFEIBalance = volt.balanceOf(address(this));
        uint256 endingUserUnderlyingBalance = underlyingToken.balanceOf(
            address(this)
        );
        uint256 endingPSMUnderlyingBalance = underlyingToken.balanceOf(
            address(psm)
        );
        uint256 endingPCVDepositUnderlyingBalance = underlyingToken.balanceOf(
            address(pcvDeposit)
        );

        assertEq(endingPSMUnderlyingBalance, 0);
        assertEq(endingUserFEIBalance, 0);
        assertEq(endingUserUnderlyingBalance, mintAmount * 2);
        assertEq(endingPCVDepositUnderlyingBalance, 0);
    }

    /// @notice pcv deposit gets depleted on redeem
    function testSwapVoltForUnderlyingAfterPriceIncrease() public {
        uint256 amountVoltIn = 100_000;
        uint256 amountStableOut = 101_000;

        vm.warp(28 days + block.timestamp);

        volt.approve(address(psm), amountVoltIn);
        psm.redeem(address(this), amountVoltIn, amountStableOut);

        uint256 endingUserFEIBalance = volt.balanceOf(address(this));
        uint256 endingUserUnderlyingBalance = underlyingToken.balanceOf(
            address(this)
        );
        uint256 endingPSMUnderlyingBalance = underlyingToken.balanceOf(
            address(psm)
        );
        uint256 endingPCVDepositUnderlyingBalance = underlyingToken.balanceOf(
            address(pcvDeposit)
        );

        assertEq(endingPSMUnderlyingBalance, 0);
        assertEq(endingUserFEIBalance, mintAmount - amountVoltIn);
        assertEq(endingUserUnderlyingBalance, mintAmount + amountStableOut);
        assertEq(
            endingPCVDepositUnderlyingBalance,
            mintAmount - amountStableOut
        );
    }

    /// @notice pcv deposit gets depleted on redeem
    function testUnderlyingBufferDepletion() public {
        uint256 bufferStart = psm.buffer();

        volt.approve(address(psm), mintAmount);
        psm.redeem(address(this), mintAmount, mintAmount);

        uint256 bufferEnd = psm.buffer();
        uint256 endingUserFEIBalance = volt.balanceOf(address(this));
        uint256 endingUserUnderlyingBalance = underlyingToken.balanceOf(
            address(this)
        );
        uint256 endingPSMUnderlyingBalance = underlyingToken.balanceOf(
            address(psm)
        );
        uint256 endingPCVDepositUnderlyingBalance = underlyingToken.balanceOf(
            address(pcvDeposit)
        );

        assertEq(endingPSMUnderlyingBalance, 0);
        assertEq(endingUserFEIBalance, 0);
        assertEq(endingUserUnderlyingBalance, mintAmount * 2);
        assertEq(endingPCVDepositUnderlyingBalance, 0);
        assertEq(bufferStart, bufferCap);
        assertEq(bufferEnd, bufferCap - mintAmount);
    }

    /// @notice global rate limited minter buffer on the PSM gets depleted on mint
    function testFeiBufferDepletion() public {
        uint256 bufferStart = rateLimitedMinter.individualBuffer(address(psm));

        underlyingToken.approve(address(psm), mintAmount);
        psm.mint(address(this), mintAmount, mintAmount);

        uint256 bufferEnd = rateLimitedMinter.individualBuffer(address(psm));
        uint256 endingUserFEIBalance = volt.balanceOf(address(this));
        uint256 endingPSMUnderlyingBalance = underlyingToken.balanceOf(
            address(psm)
        );
        uint256 endingPCVDepositUnderlyingBalance = underlyingToken.balanceOf(
            address(pcvDeposit)
        );

        assertEq(endingPCVDepositUnderlyingBalance, mintAmount * 2);
        assertEq(endingPSMUnderlyingBalance, 0);
        assertEq(endingUserFEIBalance, mintAmount * 2);

        assertEq(bufferStart, bufferCap);
        assertEq(bufferEnd, bufferCap - mintAmount);
    }

    /// @notice replenishable rate limited minter buffer on the PSM gets increased on mint
    function testBufferReplenishment() public {
        /// drain buffer
        volt.approve(address(psm), mintAmount);
        psm.redeem(address(this), mintAmount, mintAmount);

        uint256 bufferStart = psm.bufferStored();

        underlyingToken.approve(address(psm), mintAmount);
        psm.mint(address(this), mintAmount, mintAmount);

        uint256 bufferEnd = psm.bufferStored();

        assertEq(bufferEnd - bufferStart, mintAmount);
    }

    /// @notice redeem fails without approval
    function testSwapFeiForUnderlyingFailsWithoutApproval() public {
        vm.expectRevert(bytes(""ERC20: transfer amount exceeds allowance""));

        psm.redeem(address(this), mintAmount, mintAmount);
    }

    /// @notice mint fails without approval
    function testSwapUnderlyingForFeiFailsWithoutApproval() public {
        vm.expectRevert(bytes(""ERC20: transfer amount exceeds allowance""));

        psm.mint(address(this), mintAmount, mintAmount);
    }

    /// @notice withdraw erc20 fails without correct permissions
    function testERC20WithdrawFailure() public {
        vm.expectRevert(bytes(""CoreRef: Caller is not a PCV controller""));

        psm.withdrawERC20(address(underlyingToken), address(this), 100);
    }

    /// @notice withdraw erc20 succeeds with correct permissions
    function testERC20WithdrawSuccess() public {
        vm.startPrank(addresses.governorAddress);

        core.grantPCVController(address(this));
        underlyingToken.mint(address(psm), mintAmount);

        vm.stopPrank();

        uint256 startingBalance = underlyingToken.balanceOf(address(this));
        psm.withdrawERC20(address(underlyingToken), address(this), mintAmount);
        uint256 endingBalance = underlyingToken.balanceOf(address(this));

        assertEq(endingBalance - startingBalance, mintAmount);
    }

    /// @notice set global rate limited minter fails when caller is not governor
    function testSetGlobalRateLimitedMinterFailure() public {
        vm.expectRevert(bytes(""UNAUTHORIZED""));

        psm.setGlobalRateLimitedMinter(GlobalRateLimitedMinter(address(this)));
    }

    /// @notice set global rate limited minter fails when caller is governor and new address is 0
    function testSetGlobalRateLimitedMinterFailureZeroAddress() public {
        vm.startPrank(addresses.governorAddress);

        vm.expectRevert(
            bytes(""PegStabilityModule: Invalid new GlobalRateLimitedMinter"")
        );
        psm.setGlobalRateLimitedMinter(GlobalRateLimitedMinter(address(0)));

        vm.stopPrank();
    }

    /// @notice set global rate limited minter succeeds when caller is governor
    function testSetGlobalRateLimitedMinterSuccess() public {
        vm.startPrank(addresses.governorAddress);

        psm.setGlobalRateLimitedMinter(GlobalRateLimitedMinter(address(this)));

        assertEq(address(psm.rateLimitedMinter()), address(this));

        vm.stopPrank();
    }

    /// @notice set global rate limited minter fails when caller is governor and new address is 0
    function testSetPCVDepositFailureZeroAddress() public {
        vm.startPrank(addresses.governorAddress);

        vm.expectRevert(bytes(""PegStabilityModule: Invalid new PCVDeposit""));
        psm.setPCVDeposit(IPCVDeposit(address(0)));

        vm.stopPrank();
    }

    /// @notice set PCV deposit fails when caller is governor and new address is 0
    function testSetPCVDepositFailureNonGovernor() public {
        vm.expectRevert(bytes(""UNAUTHORIZED""));
        psm.setPCVDeposit(IPCVDeposit(address(0)));
    }

    /// @notice set PCV deposit fails when caller is governor and new address is 0
    function testSetPCVDepositFailureUnderlyingTokenMismatch() public {
        vm.startPrank(addresses.governorAddress);

        MockPCVDepositV2 newPCVDeposit = new MockPCVDepositV2(
            address(core),
            address(volt),
            0,
            0
        );

        vm.expectRevert(bytes(""PegStabilityModule: Underlying token mismatch""));

        psm.setPCVDeposit(IPCVDeposit(address(newPCVDeposit)));

        vm.stopPrank();
    }

    /// @notice set PCV Deposit succeeds when caller is governor and underlying tokens match
    function testSetPCVDepositSuccess() public {
        vm.startPrank(addresses.governorAddress);

        MockPCVDepositV2 newPCVDeposit = new MockPCVDepositV2(
            address(core),
            address(underlyingToken),
            0,
            0
        );

        psm.setPCVDeposit(IPCVDeposit(address(newPCVDeposit)));

        vm.stopPrank();

        assertEq(address(newPCVDeposit), address(psm.pcvDeposit()));
    }

    /// @notice set mint fee succeeds
    function testSetMintFeeSuccess() public {
        vm.startPrank(addresses.governorAddress);
        psm.setMintFee(100);
        vm.stopPrank();

        assertEq(psm.mintFeeBasisPoints(), 100);
    }

    /// @notice set mint fee fails unauthorized
    function testSetMintFeeFailsWithoutCorrectRoles() public {
        vm.expectRevert(bytes(""UNAUTHORIZED""));

        psm.setMintFee(100);
    }

    /// @notice set redeem fee succeeds
    function testSetRedeemFeeSuccess() public {
        vm.startPrank(addresses.governorAddress);
        psm.setRedeemFee(100);
        vm.stopPrank();

        assertEq(psm.redeemFeeBasisPoints(), 100);
    }

    /// @notice set redeem fee fails unauthorized
    function testSetRedeemFeeFailsWithoutCorrectRoles() public {
        vm.expectRevert(bytes(""UNAUTHORIZED""));

        psm.setRedeemFee(100);
    }

    /// @notice redeem fails when paused
    function testRedeemFailsWhenPaused() public {
        vm.startPrank(addresses.governorAddress);
        psm.pauseRedeem();
        vm.stopPrank();

        vm.expectRevert(bytes(""PegStabilityModule: Redeem paused""));
        psm.redeem(address(this), 100, 100);
    }

    /// @notice mint fails when paused
    function testMintFailsWhenPaused() public {
        vm.startPrank(addresses.governorAddress);
        psm.pauseMint();
        vm.stopPrank();

        vm.expectRevert(bytes(""PegStabilityModule: Minting paused""));
        psm.mint(address(this), 100, 100);
    }

    /// @notice redeem fails when price has not increased enough to get minAmountOut
    function testRedeemFailsWhenScalingPriceOracleIncreases() public {
        vm.warp(28 days + block.timestamp);

        vm.expectRevert(bytes(""PegStabilityModule: Redeem not enough out""));
        psm.redeem(address(this), 100_000, 101_001);

        assertEq(oracle.getCurrentOraclePrice(), (1 ether * 101) / 100);
    }

    /// @notice mint fails when price has not increased enough to get minAmountVoltOut
    function testMintFailsWhenScalingPriceOracleIncreases() public {
        vm.warp(28 days + block.timestamp);

        vm.expectRevert(bytes(""PegStabilityModule: Mint not enough out""));
        psm.mint(address(this), 101_000, 100_001);

        assertEq(oracle.getCurrentOraclePrice(), (1 ether * 101) / 100);
        /// subtract 1 for precision loss due to doInvert
        assertEq(psm.getMintAmountOut(101_000), 100_000 - 1);
    }
}",4619
RealWorld_BA_102_Vm_RealWord_20240827213627.log,102,Vm,16882,5223,22105,71.0,0.18887,"// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

interface Vm {
    // Set block.timestamp (newTimestamp)
    function warp(uint256) external;

    // Set block.height (newHeight)
    function roll(uint256) external;

    // Set block.basefee (newBasefee)
    function fee(uint256) external;

    // Loads a storage slot from an address (who, slot)
    function load(address, bytes32) external returns (bytes32);

    // Stores a value to an address' storage slot, (who, slot, value)
    function store(
        address,
        bytes32,
        bytes32
    ) external;

    // Signs data, (privateKey, digest) => (v, r, s)
    function sign(uint256, bytes32)
        external
        returns (
            uint8,
            bytes32,
            bytes32
        );

    // Gets address for a given private key, (privateKey) => (address)
    function addr(uint256) external returns (address);

    // Performs a foreign function call via terminal, (stringInputs) => (result)
    function ffi(string[] calldata) external returns (bytes memory);

    // Sets the *next* call's msg.sender to be the input address
    function prank(address) external;

    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called
    function startPrank(address) external;

    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input
    function prank(address, address) external;

    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input
    function startPrank(address, address) external;

    // Resets subsequent calls' msg.sender to be `address(this)`
    function stopPrank() external;

    // Sets an address' balance, (who, newBalance)
    function deal(address, uint256) external;

    // Sets an address' code, (who, newCode)
    function etch(address, bytes calldata) external;

    // Expects an error on next call
    function expectRevert(bytes calldata) external;

    function expectRevert(bytes4) external;

    // Record all storage reads and writes
    function record() external;

    // Gets all accessed reads and write slot from a recording session, for a given address
    function accesses(address)
        external
        returns (bytes32[] memory reads, bytes32[] memory writes);

    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).
    // Call this function, then emit an event, then call a function. Internally after the call, we check if
    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)
    function expectEmit(
        bool,
        bool,
        bool,
        bool
    ) external;

    // Mocks a call to an address, returning specified data.
    // Calldata can either be strict or a partial match, e.g. if you only
    // pass a Solidity selector to the expected calldata, then the entire Solidity
    // function will be mocked.
    function mockCall(
        address,
        bytes calldata,
        bytes calldata
    ) external;

    // Clears all mocked calls
    function clearMockedCalls() external;

    // Expect a call to an address with the specified calldata.
    // Calldata can either be strict or a partial match
    function expectCall(address, bytes calldata) external;

    // Gets the code from an artifact file. Takes in the relative path to the json file
    function getCode(string calldata) external returns (bytes memory);

    // Labels an address in call traces
    function label(address, string calldata) external;

    // If the condition is false, discard this run's fuzz inputs and generate new ones
    function assume(bool) external;
}",860
RealWorld_BA_102_MultiRateLimited_RealWord_20240827221231.log,102,MultiRateLimited,45645,5645,51290,145.0,0.341125,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {CoreRef} from ""../refs/CoreRef.sol"";
import {TribeRoles} from ""./../core/TribeRoles.sol"";
import {RateLimited} from ""./RateLimited.sol"";
import {IMultiRateLimited} from ""./IMultiRateLimited.sol"";
import {Math} from ""@openzeppelin/contracts/utils/math/Math.sol"";
import {SafeCast} from ""@openzeppelin/contracts/utils/math/SafeCast.sol"";

/// @title abstract contract for putting a rate limit on how fast an address can perform an action e.g. Minting
/// there are two buffers, one buffer which is each individual addresses's current buffer,
/// and then there is a global buffer which is the buffer that each individual address must respect as well
/// @author Elliot Friedman, Fei Protocol
/// this contract was made abstract so that other contracts that already construct an instance of CoreRef
/// do not collide with this one
abstract contract MultiRateLimited is RateLimited, IMultiRateLimited {
    using SafeCast for *;

    /// @notice the struct containing all information per rate limited address
    struct RateLimitData {
        uint32 lastBufferUsedTime;
        uint112 bufferCap;
        uint112 bufferStored;
        uint112 rateLimitPerSecond;
    }

    /// @notice rate limited address information
    mapping(address => RateLimitData) public rateLimitPerAddress;

    /// @notice max rate limit per second allowable by non governor per contract
    uint256 public individualMaxRateLimitPerSecond;

    /// @notice max buffer cap allowable by non governor per contract
    uint256 public individualMaxBufferCap;

    /// @param _maxRateLimitPerSecond maximum amount of fei that can replenish per second ever, this amount cannot be changed by governance
    /// @param _rateLimitPerSecond maximum rate limit per second per address
    /// @param _individualMaxRateLimitPerSecond maximum rate limit per second per address in multi rate limited
    /// @param _individualMaxBufferCap maximum buffer cap in multi rate limited
    /// @param _globalBufferCap maximum global buffer cap
    constructor(
        uint256 _maxRateLimitPerSecond,
        uint256 _rateLimitPerSecond,
        uint256 _individualMaxRateLimitPerSecond,
        uint256 _individualMaxBufferCap,
        uint256 _globalBufferCap
    )
        RateLimited(
            _maxRateLimitPerSecond,
            _rateLimitPerSecond,
            _globalBufferCap,
            false
        )
    {
        require(
            _individualMaxBufferCap < _globalBufferCap,
            ""MultiRateLimited: max buffer cap invalid""
        );

        individualMaxRateLimitPerSecond = _individualMaxRateLimitPerSecond;
        individualMaxBufferCap = _individualMaxBufferCap;
    }

    modifier addressIsRegistered(address rateLimitedAddress) {
        require(
            rateLimitPerAddress[rateLimitedAddress].lastBufferUsedTime != 0,
            ""MultiRateLimited: rate limit address does not exist""
        );
        _;
    }

    // ----------- Governor and Admin only state changing api -----------

    /// @notice update the ADD_MINTER_ROLE rate limit per second
    /// @param newRateLimitPerSecond new maximum rate limit per second for add minter role
    function updateMaxRateLimitPerSecond(uint256 newRateLimitPerSecond)
        external
        virtual
        override
        onlyGovernor
    {
        require(
            newRateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,
            ""MultiRateLimited: exceeds global max rate limit per second""
        );

        uint256 oldMaxRateLimitPerSecond = individualMaxRateLimitPerSecond;
        individualMaxRateLimitPerSecond = newRateLimitPerSecond;

        emit MultiMaxRateLimitPerSecondUpdate(
            oldMaxRateLimitPerSecond,
            newRateLimitPerSecond
        );
    }

    /// @notice update the ADD_MINTER_ROLE max buffer cap
    /// @param newBufferCap new buffer cap for ADD_MINTER_ROLE added addresses
    function updateMaxBufferCap(uint256 newBufferCap)
        external
        virtual
        override
        onlyGovernor
    {
        require(
            newBufferCap <= bufferCap,
            ""MultiRateLimited: exceeds global buffer cap""
        );

        uint256 oldBufferCap = individualMaxBufferCap;
        individualMaxBufferCap = newBufferCap;

        emit MultiBufferCapUpdate(oldBufferCap, newBufferCap);
    }

    /// @notice add an authorized rateLimitedAddress contract
    /// @param rateLimitedAddress the new address to add as a rateLimitedAddress
    /// @param _rateLimitPerSecond the rate limit per second for this rateLimitedAddress
    /// @param _bufferCap  the buffer cap for this rateLimitedAddress
    function addAddress(
        address rateLimitedAddress,
        uint112 _rateLimitPerSecond,
        uint112 _bufferCap
    ) external virtual override onlyGovernor {
        _addAddress(rateLimitedAddress, _rateLimitPerSecond, _bufferCap);
    }

    /// @notice add an authorized rateLimitedAddress contract
    /// @param rateLimitedAddress the address whose buffer and rate limit per second will be set
    /// @param _rateLimitPerSecond the new rate limit per second for this rateLimitedAddress
    /// @param _bufferCap  the new buffer cap for this rateLimitedAddress
    function updateAddress(
        address rateLimitedAddress,
        uint112 _rateLimitPerSecond,
        uint112 _bufferCap
    )
        external
        virtual
        override
        addressIsRegistered(rateLimitedAddress)
        hasAnyOfTwoRoles(TribeRoles.ADD_MINTER_ROLE, TribeRoles.GOVERNOR)
    {
        if (core().hasRole(TribeRoles.ADD_MINTER_ROLE, msg.sender)) {
            require(
                _rateLimitPerSecond <= individualMaxRateLimitPerSecond,
                ""MultiRateLimited: rate limit per second exceeds non governor allowable amount""
            );
            require(
                _bufferCap <= individualMaxBufferCap,
                ""MultiRateLimited: max buffer cap exceeds non governor allowable amount""
            );
        }
        require(
            _bufferCap <= bufferCap,
            ""MultiRateLimited: buffercap too high""
        );

        _updateAddress(rateLimitedAddress, _rateLimitPerSecond, _bufferCap);
    }

    /// @notice add an authorized rateLimitedAddress contract
    /// @param rateLimitedAddress the new address to add as a rateLimitedAddress
    /// gives the newly added contract the maximum allowable rate limit per second and buffer cap
    function addAddressWithCaps(address rateLimitedAddress)
        external
        virtual
        override
        onlyTribeRole(TribeRoles.ADD_MINTER_ROLE)
    {
        _addAddress(
            rateLimitedAddress,
            uint112(individualMaxRateLimitPerSecond),
            uint112(individualMaxBufferCap)
        );
    }

    /// @notice remove an authorized rateLimitedAddress contract
    /// @param rateLimitedAddress the address to remove from the whitelist of addresses
    function removeAddress(address rateLimitedAddress)
        external
        virtual
        override
        addressIsRegistered(rateLimitedAddress)
        onlyGuardianOrGovernor
    {
        uint256 oldRateLimitPerSecond = rateLimitPerAddress[rateLimitedAddress]
            .rateLimitPerSecond;

        delete rateLimitPerAddress[rateLimitedAddress];

        emit IndividualRateLimitPerSecondUpdate(
            rateLimitedAddress,
            oldRateLimitPerSecond,
            0
        );
    }

    // ----------- Getters -----------

    /// @notice the amount of action used before hitting limit
    /// @dev replenishes at rateLimitPerSecond per second up to bufferCap
    /// @param rateLimitedAddress the address whose buffer will be returned
    /// @return the buffer of the specified rate limited address
    function individualBuffer(address rateLimitedAddress)
        public
        view
        override
        returns (uint112)
    {
        RateLimitData memory rateLimitData = rateLimitPerAddress[
            rateLimitedAddress
        ];

        uint256 elapsed = block.timestamp - rateLimitData.lastBufferUsedTime;
        return
            uint112(
                Math.min(
                    rateLimitData.bufferStored +
                        (rateLimitData.rateLimitPerSecond * elapsed),
                    rateLimitData.bufferCap
                )
            );
    }

    /// @notice the rate per second for each address
    function getRateLimitPerSecond(address limiter)
        external
        view
        override
        returns (uint256)
    {
        return rateLimitPerAddress[limiter].rateLimitPerSecond;
    }

    /// @notice the last time the buffer was used by each address
    function getLastBufferUsedTime(address limiter)
        external
        view
        override
        returns (uint256)
    {
        return rateLimitPerAddress[limiter].lastBufferUsedTime;
    }

    /// @notice the cap of the buffer that can be used at once
    function getBufferCap(address limiter)
        external
        view
        override
        returns (uint256)
    {
        return rateLimitPerAddress[limiter].bufferCap;
    }

    // ----------- Helper Methods -----------

    function _updateAddress(
        address rateLimitedAddress,
        uint112 _rateLimitPerSecond,
        uint112 _bufferCap
    ) internal {
        RateLimitData storage rateLimitData = rateLimitPerAddress[
            rateLimitedAddress
        ];

        require(
            rateLimitData.lastBufferUsedTime != 0,
            ""MultiRateLimited: rate limit address does not exist""
        );
        require(
            _rateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,
            ""MultiRateLimited: rateLimitPerSecond too high""
        );

        uint112 oldRateLimitPerSecond = rateLimitData.rateLimitPerSecond;

        rateLimitData.lastBufferUsedTime = block.timestamp.toUint32();
        rateLimitData.bufferCap = _bufferCap;
        rateLimitData.rateLimitPerSecond = _rateLimitPerSecond;
        rateLimitData.bufferStored = _bufferCap;

        emit IndividualRateLimitPerSecondUpdate(
            rateLimitedAddress,
            oldRateLimitPerSecond,
            _rateLimitPerSecond
        );
    }

    /// @param rateLimitedAddress the new address to add as a rateLimitedAddress
    /// @param _rateLimitPerSecond the rate limit per second for this rateLimitedAddress
    /// @param _bufferCap  the buffer cap for this rateLimitedAddress
    function _addAddress(
        address rateLimitedAddress,
        uint112 _rateLimitPerSecond,
        uint112 _bufferCap
    ) internal {
        require(
            _bufferCap <= bufferCap,
            ""MultiRateLimited: new buffercap too high""
        );
        require(
            rateLimitPerAddress[rateLimitedAddress].lastBufferUsedTime == 0,
            ""MultiRateLimited: address already added""
        );
        require(
            _rateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,
            ""MultiRateLimited: rateLimitPerSecond too high""
        );

        RateLimitData memory rateLimitData = RateLimitData({
            lastBufferUsedTime: block.timestamp.toUint32(),
            bufferCap: _bufferCap,
            rateLimitPerSecond: _rateLimitPerSecond,
            bufferStored: _bufferCap
        });

        rateLimitPerAddress[rateLimitedAddress] = rateLimitData;

        emit IndividualRateLimitPerSecondUpdate(
            rateLimitedAddress,
            0,
            _rateLimitPerSecond
        );
    }

    /// @notice the method that enforces the rate limit. Decreases buffer by ""amount"".
    /// @param rateLimitedAddress the address whose buffer will be depleted
    /// @param amount the amount to remove from the rateLimitedAddress's buffer
    function _depleteIndividualBuffer(
        address rateLimitedAddress,
        uint256 amount
    ) internal returns (uint256) {
        _depleteBuffer(amount);

        uint256 newBuffer = individualBuffer(rateLimitedAddress);

        require(newBuffer != 0, ""MultiRateLimited: no rate limit buffer"");
        require(amount <= newBuffer, ""MultiRateLimited: rate limit hit"");

        rateLimitPerAddress[rateLimitedAddress].bufferStored = uint112(
            newBuffer - amount
        );

        rateLimitPerAddress[rateLimitedAddress].lastBufferUsedTime = block
            .timestamp
            .toUint32();

        emit IndividualBufferUsed(
            rateLimitedAddress,
            amount,
            newBuffer - amount
        );

        return amount;
    }
}",2643
RealWorld_BA_102_MockCToken_RealWord_20240827215222.log,102,MockCToken,10264,5720,15984,98.0,0.16572,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import ""./MockERC20.sol"";
import ""hardhat/console.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

interface CToken {
    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);

    function exchangeRateStored() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);
}

contract MockCToken is MockERC20 {
    IERC20 public token;
    bool public error;
    bool public isCEther;

    uint256 private constant EXCHANGE_RATE_SCALE = 1e18;
    uint256 public effectiveExchangeRate = 2;

    constructor(IERC20 _token, bool _isCEther) {
        token = _token;
        isCEther = _isCEther;
    }

    function setError(bool _error) external {
        error = _error;
    }

    function isCToken() external pure returns (bool) {
        return true;
    }

    function underlying() external view returns (address) {
        return address(token);
    }

    function mint() external payable {
        _mint(msg.sender, msg.value / effectiveExchangeRate);
    }

    function mint(uint256 amount) external returns (uint256) {
        token.transferFrom(msg.sender, address(this), amount);
        _mint(msg.sender, amount / effectiveExchangeRate);
        return error ? 1 : 0;
    }

    function redeemUnderlying(uint256 redeemAmount) external returns (uint256) {
        _burn(msg.sender, redeemAmount / effectiveExchangeRate);
        if (address(this).balance >= redeemAmount) {
            payable(msg.sender).transfer(redeemAmount);
        } else {
            token.transfer(msg.sender, redeemAmount);
        }
        return error ? 1 : 0;
    }

    function exchangeRateStored() external view returns (uint256) {
        return EXCHANGE_RATE_SCALE * effectiveExchangeRate; // 2:1
    }
}",430
RealWorld_BA_102_RateLimitedMinter_RealWord_20240827223658.log,102,RateLimitedMinter,7335,5426,12761,86.0,0.145195,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""../../utils/RateLimited.sol"";

/// @title abstract contract for putting a rate limit on how fast a contract can mint FEI
/// @author Fei Protocol
abstract contract RateLimitedMinter is RateLimited {
    uint256 private constant MAX_FEI_LIMIT_PER_SECOND = 10_000e18; // 10000 volt/s or ~860m volt/day

    constructor(
        uint256 _feiLimitPerSecond,
        uint256 _mintingBufferCap,
        bool _doPartialMint
    )
        RateLimited(
            MAX_FEI_LIMIT_PER_SECOND,
            _feiLimitPerSecond,
            _mintingBufferCap,
            _doPartialMint
        )
    {}

    /// @notice override the FEI minting behavior to enforce a rate limit
    function _mintVolt(address to, uint256 amount) internal virtual override {
        uint256 mintAmount = _depleteBuffer(amount);
        super._mintVolt(to, mintAmount);
    }
}",228
RealWorld_BA_103_LibStorage_RealWord_20240827231006.log,103,LibStorage,3599,4463,8062,75.0,0.107255,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

struct LibStorage {
    mapping(address => bool) dexWhitelist;
    address[] dexs;
}",37
RealWorld_BA_103_ICBridge_RealWord_20240827232450.log,103,ICBridge,5534,5079,10613,80.0,0.12925,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface ICBridge {
    function send(
        address _receiver,
        address _token,
        uint256 _amount,
        uint64 _dstChinId,
        uint64 _nonce,
        uint32 _maxSlippage
    ) external;

    function sendNative(
        address _receiver,
        uint256 _amount,
        uint64 _dstChinId,
        uint64 _nonce,
        uint32 _maxSlippage
    ) external;

    function relay(
        bytes calldata _relayRequest,
        bytes[] calldata _sigs,
        address[] calldata _signers,
        uint256[] calldata _powers
    ) external;
}",157
RealWorld_BA_103_IAnyswapRouter_RealWord_20240828003436.log,103,IAnyswapRouter,5267,5092,10359,77.0,0.128175,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IAnyswapRouter {
    function anySwapOutUnderlying(
        address token,
        address to,
        uint256 amount,
        uint256 toChainID
    ) external;

    function anySwapOut(
        address token,
        address to,
        uint256 amount,
        uint256 toChainID
    ) external;

    function anySwapOutNative(
        address token,
        address to,
        uint256 toChainID
    ) external payable;

    function wNATIVE() external returns (address);
}",124
RealWorld_BA_103_LibAsset_RealWord_20240828002705.log,103,LibAsset,22485,5970,28455,94.0,0.231825,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.7;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/**
 * @title LibAsset
 * @author Connext <support@connext.network>
 * @notice This library contains helpers for dealing with onchain transfers
 *         of assets, including accounting for the native asset `assetId`
 *         conventions and any noncompliant ERC20 transfers
 */
library LibAsset {
    uint256 private constant MAX_INT = 2**256 - 1;

    /**
     * @dev All native assets use the empty address for their asset id
     *      by convention
     */
    address internal constant NATIVE_ASSETID = address(0);

    /**
     * @notice Determines whether the given assetId is the native asset
     * @param assetId The asset identifier to evaluate
     * @return Boolean indicating if the asset is the native asset
     */
    function isNativeAsset(address assetId) internal pure returns (bool) {
        return assetId == NATIVE_ASSETID;
    }

    /**
     * @notice Gets the balance of the inheriting contract for the given asset
     * @param assetId The asset identifier to get the balance of
     * @return Balance held by contracts using this library
     */
    function getOwnBalance(address assetId) internal view returns (uint256) {
        return isNativeAsset(assetId) ? address(this).balance : IERC20(assetId).balanceOf(address(this));
    }

    /**
     * @notice Transfers ether from the inheriting contract to a given
     *         recipient
     * @param recipient Address to send ether to
     * @param amount Amount to send to given recipient
     */
    function transferNativeAsset(address payable recipient, uint256 amount) internal {
        // solhint-disable-next-line avoid-low-level-calls
        (bool success, ) = recipient.call{ value: amount }("""");
        require(success, ""#TNA:028"");
    }

    /**
     * @notice Gives approval for another address to spend tokens
     * @param assetId Token address to transfer
     * @param spender Address to give spend approval to
     * @param amount Amount to approve for spending
     */
    function approveERC20(
        IERC20 assetId,
        address spender,
        uint256 amount
    ) internal {
        if (isNativeAsset(address(assetId))) return;
        uint256 allowance = assetId.allowance(address(this), spender);
        if (allowance < amount) {
            if (allowance > 0) SafeERC20.safeApprove(IERC20(assetId), spender, 0);
            SafeERC20.safeApprove(IERC20(assetId), spender, MAX_INT);
        }
    }

    /**
     * @notice Transfers tokens from the inheriting contract to a given
     *         recipient
     * @param assetId Token address to transfer
     * @param recipient Address to send ether to
     * @param amount Amount to send to given recipient
     */
    function transferERC20(
        address assetId,
        address recipient,
        uint256 amount
    ) internal {
        SafeERC20.safeTransfer(IERC20(assetId), recipient, amount);
    }

    /**
     * @notice Transfers tokens from a sender to a given recipient
     * @param assetId Token address to transfer
     * @param from Address of sender/owner
     * @param to Address of recipient/spender
     * @param amount Amount to transfer from owner to spender
     */
    function transferFromERC20(
        address assetId,
        address from,
        address to,
        uint256 amount
    ) internal {
        SafeERC20.safeTransferFrom(IERC20(assetId), from, to, amount);
    }

    /**
     * @notice Increases the allowance of a token to a spender
     * @param assetId Token address of asset to increase allowance of
     * @param spender Account whos allowance is increased
     * @param amount Amount to increase allowance by
     */
    function increaseERC20Allowance(
        address assetId,
        address spender,
        uint256 amount
    ) internal {
        require(!isNativeAsset(assetId), ""#IA:034"");
        SafeERC20.safeIncreaseAllowance(IERC20(assetId), spender, amount);
    }

    /**
     * @notice Decreases the allowance of a token to a spender
     * @param assetId Token address of asset to decrease allowance of
     * @param spender Account whos allowance is decreased
     * @param amount Amount to decrease allowance by
     */
    function decreaseERC20Allowance(
        address assetId,
        address spender,
        uint256 amount
    ) internal {
        require(!isNativeAsset(assetId), ""#DA:034"");
        SafeERC20.safeDecreaseAllowance(IERC20(assetId), spender, amount);
    }

    /**
     * @notice Wrapper function to transfer a given asset (native or erc20) to
     *         some recipient. Should handle all non-compliant return value
     *         tokens as well by using the SafeERC20 contract by open zeppelin.
     * @param assetId Asset id for transfer (address(0) for native asset,
     *                token address for erc20s)
     * @param recipient Address to send asset to
     * @param amount Amount to send to given recipient
     */
    function transferAsset(
        address assetId,
        address payable recipient,
        uint256 amount
    ) internal {
        isNativeAsset(assetId) ? transferNativeAsset(recipient, amount) : transferERC20(assetId, recipient, amount);
    }
}",1217
RealWorld_BA_103_DexManagerFacet_RealWord_20240828001213.log,103,DexManagerFacet,14141,5191,19332,89.0,0.174525,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""../Libraries/LibStorage.sol"";
import ""../Libraries/LibDiamond.sol"";

/**
 * @title Optics Router Facet
 * @author Li.Finance (https://li.finance)
 * @notice Facet contract for managing approved DEXs to be used in swaps.
 */
contract DexManagerFacet {
    LibStorage internal s;

    /// @notice Register the address of a DEX contract to be approved for swapping.
    /// @param _dex The address of the DEX contract to be approved.
    function addDex(address _dex) external {
        LibDiamond.enforceIsContractOwner();

        if (s.dexWhitelist[_dex] == true) {
            return;
        }

        s.dexWhitelist[_dex] = true;
        s.dexs.push(_dex);
    }

    /// @notice Batch register the addresss of DEX contracts to be approved for swapping.
    /// @param _dexs The addresses of the DEX contracts to be approved.
    function batchAddDex(address[] calldata _dexs) external {
        LibDiamond.enforceIsContractOwner();

        for (uint256 i; i < _dexs.length; i++) {
            if (s.dexWhitelist[_dexs[i]] == true) {
                continue;
            }
            s.dexWhitelist[_dexs[i]] = true;
            s.dexs.push(_dexs[i]);
        }
    }

    /// @notice Unregister the address of a DEX contract approved for swapping.
    /// @param _dex The address of the DEX contract to be unregistered.
    function removeDex(address _dex) external {
        LibDiamond.enforceIsContractOwner();

        if (s.dexWhitelist[_dex] == false) {
            return;
        }

        s.dexWhitelist[_dex] = false;
        for (uint256 i; i < s.dexs.length; i++) {
            if (s.dexs[i] == _dex) {
                _removeDex(i);
                return;
            }
        }
    }

    /// @notice Batch unregister the addresses of DEX contracts approved for swapping.
    /// @param _dexs The addresses of the DEX contracts to be unregistered.
    function batchRemoveDex(address[] calldata _dexs) external {
        LibDiamond.enforceIsContractOwner();

        for (uint256 i; i < _dexs.length; i++) {
            if (s.dexWhitelist[_dexs[i]] == false) {
                continue;
            }
            s.dexWhitelist[_dexs[i]] = false;
            for (uint256 j; j < s.dexs.length; j++) {
                if (s.dexs[j] == _dexs[i]) {
                    _removeDex(j);
                    return;
                }
            }
        }
    }

    function approvedDexs() external view returns (address[] memory) {
        return s.dexs;
    }

    function _removeDex(uint256 index) private {
        // Move the last element into the place to delete
        s.dexs[index] = s.dexs[s.dexs.length - 1];
        // Remove the last element
        s.dexs.pop();
    }
}",684
RealWorld_BA_103_LiFiDiamond_RealWord_20240828000447.log,103,LiFiDiamond,11866,5796,17662,91.0,0.17525,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { LibDiamond } from ""./Libraries/LibDiamond.sol"";
import { IDiamondCut } from ""./Interfaces/IDiamondCut.sol"";

contract LiFiDiamond {
    constructor(address _contractOwner, address _diamondCutFacet) payable {
        LibDiamond.setContractOwner(_contractOwner);

        // Add the diamondCut external function from the diamondCutFacet
        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);
        bytes4[] memory functionSelectors = new bytes4[](1);
        functionSelectors[0] = IDiamondCut.diamondCut.selector;
        cut[0] = IDiamondCut.FacetCut({
            facetAddress: _diamondCutFacet,
            action: IDiamondCut.FacetCutAction.Add,
            functionSelectors: functionSelectors
        });
        LibDiamond.diamondCut(cut, address(0), """");
    }

    // Find facet for function that is called and execute the
    // function if a facet is found and return any value.
    // solhint-disable-next-line no-complex-fallback
    fallback() external payable {
        LibDiamond.DiamondStorage storage ds;
        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;

        // get diamond storage
        // solhint-disable-next-line no-inline-assembly
        assembly {
            ds.slot := position
        }

        // get facet from function selector
        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;
        require(facet != address(0), ""Diamond: Function does not exist"");

        // Execute external function from facet using delegatecall and return any value.
        // solhint-disable-next-line no-inline-assembly
        assembly {
            // copy function selector and any arguments
            calldatacopy(0, 0, calldatasize())
            // execute function call using the facet
            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)
            // get any return value
            returndatacopy(0, 0, returndatasize())
            // return any return value or error back to the caller
            switch result
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }

    // Able to receive ether
    // solhint-disable-next-line no-empty-blocks
    receive() external payable {}
}",532
RealWorld_BA_103_HopFacet_RealWord_20240827225949.log,103,HopFacet,26721,6187,32908,102.0,0.257345,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { ILiFi } from ""../Interfaces/ILiFi.sol"";
import { IHopBridge } from ""../Interfaces/IHopBridge.sol"";
import { LibAsset, IERC20 } from ""../Libraries/LibAsset.sol"";
import { LibDiamond } from ""../Libraries/LibDiamond.sol"";
import ""./Swapper.sol"";

/**
 * @title Hop Facet
 * @author Li.Finance (https://li.finance)
 * @notice Provides functionality for bridging through Hop
 */
contract HopFacet is ILiFi, Swapper {
    /* ========== Storage ========== */

    bytes32 internal constant NAMESPACE = keccak256(""com.lifi.facets.hop"");
    struct Storage {
        mapping(string => IHopBridge.BridgeConfig) hopBridges;
        uint256 hopChainId;
    }

    /* ========== Types ========== */

    struct HopData {
        string asset;
        address recipient;
        uint256 chainId;
        uint256 amount;
        uint256 bonderFee;
        uint256 amountOutMin;
        uint256 deadline;
        uint256 destinationAmountOutMin;
        uint256 destinationDeadline;
    }

    /* ========== Init ========== */

    function initHop(
        string[] memory _tokens,
        IHopBridge.BridgeConfig[] memory _bridgeConfigs,
        uint256 _chainId
    ) external {
        Storage storage s = getStorage();
        LibDiamond.enforceIsContractOwner();

        for (uint8 i; i < _tokens.length; i++) {
            s.hopBridges[_tokens[i]] = _bridgeConfigs[i];
        }
        s.hopChainId = _chainId;
    }

    /* ========== Public Bridge Functions ========== */

    /**
     * @notice Bridges tokens via Hop Protocol
     * @param _lifiData data used purely for tracking and analytics
     * @param _hopData data specific to Hop Protocol
     */
    function startBridgeTokensViaHop(LiFiData memory _lifiData, HopData calldata _hopData) public payable {
        address sendingAssetId = _bridge(_hopData.asset).token;

        if (sendingAssetId == address(0)) require(msg.value == _hopData.amount, ""ERR_INVALID_AMOUNT"");
        else {
            uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);
            LibAsset.transferFromERC20(sendingAssetId, msg.sender, address(this), _hopData.amount);
            require(
                LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance == _hopData.amount,
                ""ERR_INVALID_AMOUNT""
            );
        }

        _startBridge(_hopData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /**
     * @notice Performs a swap before bridging via Hop Protocol
     * @param _lifiData data used purely for tracking and analytics
     * @param _swapData an array of swap related data for performing swaps before bridging
     * @param _hopData data specific to Hop Protocol
     */
    function swapAndStartBridgeTokensViaHop(
        LiFiData memory _lifiData,
        LibSwap.SwapData[] calldata _swapData,
        HopData memory _hopData
    ) public payable {
        address sendingAssetId = _bridge(_hopData.asset).token;

        uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);

        // Swap
        _executeSwaps(_lifiData, _swapData);

        uint256 _postSwapBalance = LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance;

        require(_postSwapBalance > 0, ""ERR_INVALID_AMOUNT"");

        _hopData.amount = _postSwapBalance;

        _startBridge(_hopData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /* ========== Internal Functions ========== */

    /**
     * @dev Conatains the business logic for the bridge via Hop Protocol
     * @param _hopData data specific to Hop Protocol
     */
    function _startBridge(HopData memory _hopData) internal {
        Storage storage s = getStorage();
        address sendingAssetId = _bridge(_hopData.asset).token;

        address bridge;
        if (s.hopChainId == 1) {
            bridge = _bridge(_hopData.asset).bridge;
        } else {
            bridge = _bridge(_hopData.asset).ammWrapper;
        }

        // Do HOP stuff
        require(s.hopChainId != _hopData.chainId, ""Cannot bridge to the same network."");

        // Give Hop approval to bridge tokens
        LibAsset.approveERC20(IERC20(sendingAssetId), bridge, _hopData.amount);

        uint256 value = LibAsset.isNativeAsset(address(sendingAssetId)) ? _hopData.amount : 0;

        if (s.hopChainId == 1) {
            // Ethereum L1
            IHopBridge(bridge).sendToL2{ value: value }(
                _hopData.chainId,
                _hopData.recipient,
                _hopData.amount,
                _hopData.destinationAmountOutMin,
                _hopData.destinationDeadline,
                address(0),
                0
            );
        } else {
            // L2
            // solhint-disable-next-line check-send-result
            IHopBridge(bridge).swapAndSend{ value: value }(
                _hopData.chainId,
                _hopData.recipient,
                _hopData.amount,
                _hopData.bonderFee,
                _hopData.amountOutMin,
                _hopData.deadline,
                _hopData.destinationAmountOutMin,
                _hopData.destinationDeadline
            );
        }
    }

    function _bridge(string memory _asset) internal view returns (IHopBridge.BridgeConfig memory) {
        Storage storage s = getStorage();
        return s.hopBridges[_asset];
    }

    function getStorage() internal pure returns (Storage storage s) {
        bytes32 namespace = NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}",1438
RealWorld_BA_103_IERC165_RealWord_20240827233052.log,103,IERC165,5126,3757,8883,78.0,0.10077,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IERC165 {
    /// @notice Query if a contract implements an interface
    /// @param interfaceId The interface identifier, as specified in ERC-165
    /// @dev Interface identification is specified in ERC-165. This function
    ///  uses less than 30,000 gas.
    /// @return `true` if the contract implements `interfaceID` and
    ///  `interfaceID` is not 0xffffffff, `false` otherwise
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}",129
RealWorld_BA_103_HopFacet_RealWord_20240828001344.log,103,HopFacet,26530,5764,32294,105.0,0.24793,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { ILiFi } from ""../Interfaces/ILiFi.sol"";
import { IHopBridge } from ""../Interfaces/IHopBridge.sol"";
import { LibAsset, IERC20 } from ""../Libraries/LibAsset.sol"";
import { LibDiamond } from ""../Libraries/LibDiamond.sol"";
import ""./Swapper.sol"";

/**
 * @title Hop Facet
 * @author Li.Finance (https://li.finance)
 * @notice Provides functionality for bridging through Hop
 */
contract HopFacet is ILiFi, Swapper {
    /* ========== Storage ========== */

    bytes32 internal constant NAMESPACE = keccak256(""com.lifi.facets.hop"");
    struct Storage {
        mapping(string => IHopBridge.BridgeConfig) hopBridges;
        uint256 hopChainId;
    }

    /* ========== Types ========== */

    struct HopData {
        string asset;
        address recipient;
        uint256 chainId;
        uint256 amount;
        uint256 bonderFee;
        uint256 amountOutMin;
        uint256 deadline;
        uint256 destinationAmountOutMin;
        uint256 destinationDeadline;
    }

    /* ========== Init ========== */

    function initHop(
        string[] memory _tokens,
        IHopBridge.BridgeConfig[] memory _bridgeConfigs,
        uint256 _chainId
    ) external {
        Storage storage s = getStorage();
        LibDiamond.enforceIsContractOwner();

        for (uint8 i; i < _tokens.length; i++) {
            s.hopBridges[_tokens[i]] = _bridgeConfigs[i];
        }
        s.hopChainId = _chainId;
    }

    /* ========== Public Bridge Functions ========== */

    /**
     * @notice Bridges tokens via Hop Protocol
     * @param _lifiData data used purely for tracking and analytics
     * @param _hopData data specific to Hop Protocol
     */
    function startBridgeTokensViaHop(LiFiData memory _lifiData, HopData calldata _hopData) public payable {
        address sendingAssetId = _bridge(_hopData.asset).token;

        if (sendingAssetId == address(0)) require(msg.value == _hopData.amount, ""ERR_INVALID_AMOUNT"");
        else {
            uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);
            LibAsset.transferFromERC20(sendingAssetId, msg.sender, address(this), _hopData.amount);
            require(
                LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance == _hopData.amount,
                ""ERR_INVALID_AMOUNT""
            );
        }

        _startBridge(_hopData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /**
     * @notice Performs a swap before bridging via Hop Protocol
     * @param _lifiData data used purely for tracking and analytics
     * @param _swapData an array of swap related data for performing swaps before bridging
     * @param _hopData data specific to Hop Protocol
     */
    function swapAndStartBridgeTokensViaHop(
        LiFiData memory _lifiData,
        LibSwap.SwapData[] calldata _swapData,
        HopData memory _hopData
    ) public payable {
        address sendingAssetId = _bridge(_hopData.asset).token;

        uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);

        // Swap
        _executeSwaps(_lifiData, _swapData);

        uint256 _postSwapBalance = LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance;

        require(_postSwapBalance > 0, ""ERR_INVALID_AMOUNT"");

        _hopData.amount = _postSwapBalance;

        _startBridge(_hopData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /* ========== Internal Functions ========== */

    /**
     * @dev Conatains the business logic for the bridge via Hop Protocol
     * @param _hopData data specific to Hop Protocol
     */
    function _startBridge(HopData memory _hopData) internal {
        Storage storage s = getStorage();
        address sendingAssetId = _bridge(_hopData.asset).token;

        address bridge;
        if (s.hopChainId == 1) {
            bridge = _bridge(_hopData.asset).bridge;
        } else {
            bridge = _bridge(_hopData.asset).ammWrapper;
        }

        // Do HOP stuff
        require(s.hopChainId != _hopData.chainId, ""Cannot bridge to the same network."");

        // Give Hop approval to bridge tokens
        LibAsset.approveERC20(IERC20(sendingAssetId), bridge, _hopData.amount);

        uint256 value = LibAsset.isNativeAsset(address(sendingAssetId)) ? _hopData.amount : 0;

        if (s.hopChainId == 1) {
            // Ethereum L1
            IHopBridge(bridge).sendToL2{ value: value }(
                _hopData.chainId,
                _hopData.recipient,
                _hopData.amount,
                _hopData.destinationAmountOutMin,
                _hopData.destinationDeadline,
                address(0),
                0
            );
        } else {
            // L2
            // solhint-disable-next-line check-send-result
            IHopBridge(bridge).swapAndSend{ value: value }(
                _hopData.chainId,
                _hopData.recipient,
                _hopData.amount,
                _hopData.bonderFee,
                _hopData.amountOutMin,
                _hopData.deadline,
                _hopData.destinationAmountOutMin,
                _hopData.destinationDeadline
            );
        }
    }

    function _bridge(string memory _asset) internal view returns (IHopBridge.BridgeConfig memory) {
        Storage storage s = getStorage();
        return s.hopBridges[_asset];
    }

    function getStorage() internal pure returns (Storage storage s) {
        bytes32 namespace = NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}",1438
RealWorld_BA_103_DiamondLoupeFacet_RealWord_20240828001728.log,103,DiamondLoupeFacet,12707,4974,17681,74.0,0.163015,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { LibDiamond } from ""../Libraries/LibDiamond.sol"";
import { IDiamondLoupe } from ""../Interfaces/IDiamondLoupe.sol"";
import { IERC165 } from ""../Interfaces/IERC165.sol"";

contract DiamondLoupeFacet is IDiamondLoupe, IERC165 {
    // Diamond Loupe Functions
    ////////////////////////////////////////////////////////////////////
    /// These functions are expected to be called frequently by tools.
    //
    // struct Facet {
    //     address facetAddress;
    //     bytes4[] functionSelectors;
    // }

    /// @notice Gets all facets and their selectors.
    /// @return facets_ Facet
    function facets() external view override returns (Facet[] memory facets_) {
        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
        uint256 numFacets = ds.facetAddresses.length;
        facets_ = new Facet[](numFacets);
        for (uint256 i; i < numFacets; i++) {
            address facetAddress_ = ds.facetAddresses[i];
            facets_[i].facetAddress = facetAddress_;
            facets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress_].functionSelectors;
        }
    }

    /// @notice Gets all the function selectors provided by a facet.
    /// @param _facet The facet address.
    /// @return facetFunctionSelectors_
    function facetFunctionSelectors(address _facet)
        external
        view
        override
        returns (bytes4[] memory facetFunctionSelectors_)
    {
        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
        facetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;
    }

    /// @notice Get all the facet addresses used by a diamond.
    /// @return facetAddresses_
    function facetAddresses() external view override returns (address[] memory facetAddresses_) {
        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
        facetAddresses_ = ds.facetAddresses;
    }

    /// @notice Gets the facet that supports the given selector.
    /// @dev If facet is not found return address(0).
    /// @param _functionSelector The function selector.
    /// @return facetAddress_ The facet address.
    function facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {
        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
        facetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;
    }

    // This implements ERC-165.
    function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {
        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
        return ds.supportedInterfaces[_interfaceId];
    }
}",590
RealWorld_BA_103_IAnyswapRouter_RealWord_20240827232201.log,103,IAnyswapRouter,4996,4730,9726,76.0,0.11958,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IAnyswapRouter {
    function anySwapOutUnderlying(
        address token,
        address to,
        uint256 amount,
        uint256 toChainID
    ) external;

    function anySwapOut(
        address token,
        address to,
        uint256 amount,
        uint256 toChainID
    ) external;

    function anySwapOutNative(
        address token,
        address to,
        uint256 toChainID
    ) external payable;

    function wNATIVE() external returns (address);
}",124
RealWorld_BA_103_LibUtil_RealWord_20240828002603.log,103,LibUtil,5166,3834,9000,60.0,0.10251,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""./LibBytes.sol"";

library LibUtil {
    using LibBytes for bytes;

    function getRevertMsg(bytes memory _res) internal pure returns (string memory) {
        // If the _res length is less than 68, then the transaction failed silently (without a revert message)
        if (_res.length < 68) return ""Transaction reverted silently"";
        bytes memory revertData = _res.slice(4, _res.length - 4); // Remove the selector which is the first 4 bytes
        return abi.decode(revertData, (string)); // All that remains is the revert string
    }
}",145
RealWorld_BA_103_Swapper_RealWord_20240827230642.log,103,Swapper,6349,5044,11393,109.0,0.132625,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { ILiFi } from ""../Interfaces/ILiFi.sol"";
import { LibSwap } from ""../Libraries/LibSwap.sol"";
import { LibStorage } from ""../Libraries/LibStorage.sol"";

contract Swapper is ILiFi {
    /* ========== Storage ========== */
    LibStorage internal ls;

    function _executeSwaps(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) internal {
        // Swap
        for (uint8 i; i < _swapData.length; i++) {
            require(
                ls.dexWhitelist[_swapData[i].approveTo] == true && ls.dexWhitelist[_swapData[i].callTo] == true,
                ""Contract call not allowed!""
            );

            LibSwap.swap(_lifiData.transactionId, _swapData[i]);
        }
    }
}",194
RealWorld_BA_103_ICBridge_RealWord_20240828003713.log,103,ICBridge,5423,5084,10507,80.0,0.128795,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface ICBridge {
    function send(
        address _receiver,
        address _token,
        uint256 _amount,
        uint64 _dstChinId,
        uint64 _nonce,
        uint32 _maxSlippage
    ) external;

    function sendNative(
        address _receiver,
        uint256 _amount,
        uint64 _dstChinId,
        uint64 _nonce,
        uint32 _maxSlippage
    ) external;

    function relay(
        bytes calldata _relayRequest,
        bytes[] calldata _sigs,
        address[] calldata _signers,
        uint256[] calldata _powers
    ) external;
}",157
RealWorld_BA_103_LibBytes_RealWord_20240827231539.log,103,LibBytes,69571,5717,75288,102.0,0.462195,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

library LibBytes {
    // solhint-disable no-inline-assembly

    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {
        bytes memory tempBytes;

        assembly {
            // Get a location of some free memory and store it in tempBytes as
            // Solidity does for memory variables.
            tempBytes := mload(0x40)

            // Store the length of the first bytes array at the beginning of
            // the memory for tempBytes.
            let length := mload(_preBytes)
            mstore(tempBytes, length)

            // Maintain a memory counter for the current write location in the
            // temp bytes array by adding the 32 bytes for the array length to
            // the starting location.
            let mc := add(tempBytes, 0x20)
            // Stop copying when the memory counter reaches the length of the
            // first bytes array.
            let end := add(mc, length)

            for {
                // Initialize a copy counter to the start of the _preBytes data,
                // 32 bytes into its memory.
                let cc := add(_preBytes, 0x20)
            } lt(mc, end) {
                // Increase both counters by 32 bytes each iteration.
                mc := add(mc, 0x20)
                cc := add(cc, 0x20)
            } {
                // Write the _preBytes data into the tempBytes memory 32 bytes
                // at a time.
                mstore(mc, mload(cc))
            }

            // Add the length of _postBytes to the current length of tempBytes
            // and store it as the new length in the first 32 bytes of the
            // tempBytes memory.
            length := mload(_postBytes)
            mstore(tempBytes, add(length, mload(tempBytes)))

            // Move the memory counter back from a multiple of 0x20 to the
            // actual end of the _preBytes data.
            mc := end
            // Stop copying when the memory counter reaches the new combined
            // length of the arrays.
            end := add(mc, length)

            for {
                let cc := add(_postBytes, 0x20)
            } lt(mc, end) {
                mc := add(mc, 0x20)
                cc := add(cc, 0x20)
            } {
                mstore(mc, mload(cc))
            }

            // Update the free-memory pointer by padding our last write location
            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the
            // next 32 byte block, then round down to the nearest multiple of
            // 32. If the sum of the length of the two arrays is zero then add
            // one before rounding down to leave a blank 32 bytes (the length block with 0).
            mstore(
                0x40,
                and(
                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),
                    not(31) // Round down to the nearest 32 bytes.
                )
            )
        }

        return tempBytes;
    }

    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {
        assembly {
            // Read the first 32 bytes of _preBytes storage, which is the length
            // of the array. (We don't need to use the offset into the slot
            // because arrays use the entire slot.)
            let fslot := sload(_preBytes.slot)
            // Arrays of 31 bytes or less have an even value in their slot,
            // while longer arrays have an odd value. The actual length is
            // the slot divided by two for odd values, and the lowest order
            // byte divided by two for even values.
            // If the slot is even, bitwise and the slot with 255 and divide by
            // two to get the length. If the slot is odd, bitwise and the slot
            // with -1 and divide by two.
            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)
            let mlength := mload(_postBytes)
            let newlength := add(slength, mlength)
            // slength can contain both the length and contents of the array
            // if length < 32 bytes so let's prepare for that
            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage
            switch add(lt(slength, 32), lt(newlength, 32))
            case 2 {
                // Since the new array still fits in the slot, we just need to
                // update the contents of the slot.
                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length
                sstore(
                    _preBytes.slot,
                    // all the modifications to the slot are inside this
                    // next block
                    add(
                        // we can just add to the slot contents because the
                        // bytes we want to change are the LSBs
                        fslot,
                        add(
                            mul(
                                div(
                                    // load the bytes from memory
                                    mload(add(_postBytes, 0x20)),
                                    // zero all bytes to the right
                                    exp(0x100, sub(32, mlength))
                                ),
                                // and now shift left the number of bytes to
                                // leave space for the length in the slot
                                exp(0x100, sub(32, newlength))
                            ),
                            // increase length by the double of the memory
                            // bytes length
                            mul(mlength, 2)
                        )
                    )
                )
            }
            case 1 {
                // The stored value fits in the slot, but the combined value
                // will exceed it.
                // get the keccak hash to get the contents of the array
                mstore(0x0, _preBytes.slot)
                let sc := add(keccak256(0x0, 0x20), div(slength, 32))

                // save new length
                sstore(_preBytes.slot, add(mul(newlength, 2), 1))

                // The contents of the _postBytes array start 32 bytes into
                // the structure. Our first read should obtain the `submod`
                // bytes that can fit into the unused space in the last word
                // of the stored array. To get this, we read 32 bytes starting
                // from `submod`, so the data we read overlaps with the array
                // contents by `submod` bytes. Masking the lowest-order
                // `submod` bytes allows us to add that value directly to the
                // stored value.

                let submod := sub(32, slength)
                let mc := add(_postBytes, submod)
                let end := add(_postBytes, mlength)
                let mask := sub(exp(0x100, submod), 1)

                sstore(
                    sc,
                    add(
                        and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00),
                        and(mload(mc), mask)
                    )
                )

                for {
                    mc := add(mc, 0x20)
                    sc := add(sc, 1)
                } lt(mc, end) {
                    sc := add(sc, 1)
                    mc := add(mc, 0x20)
                } {
                    sstore(sc, mload(mc))
                }

                mask := exp(0x100, sub(mc, end))

                sstore(sc, mul(div(mload(mc), mask), mask))
            }
            default {
                // get the keccak hash to get the contents of the array
                mstore(0x0, _preBytes.slot)
                // Start copying to the last used word of the stored array.
                let sc := add(keccak256(0x0, 0x20), div(slength, 32))

                // save new length
                sstore(_preBytes.slot, add(mul(newlength, 2), 1))

                // Copy over the first `submod` bytes of the new data as in
                // case 1 above.
                let slengthmod := mod(slength, 32)
                let submod := sub(32, slengthmod)
                let mc := add(_postBytes, submod)
                let end := add(_postBytes, mlength)
                let mask := sub(exp(0x100, submod), 1)

                sstore(sc, add(sload(sc), and(mload(mc), mask)))

                for {
                    sc := add(sc, 1)
                    mc := add(mc, 0x20)
                } lt(mc, end) {
                    sc := add(sc, 1)
                    mc := add(mc, 0x20)
                } {
                    sstore(sc, mload(mc))
                }

                mask := exp(0x100, sub(mc, end))

                sstore(sc, mul(div(mload(mc), mask), mask))
            }
        }
    }

    function slice(
        bytes memory _bytes,
        uint256 _start,
        uint256 _length
    ) internal pure returns (bytes memory) {
        require(_length + 31 >= _length, ""slice_overflow"");
        require(_bytes.length >= _start + _length, ""slice_outOfBounds"");

        bytes memory tempBytes;

        assembly {
            switch iszero(_length)
            case 0 {
                // Get a location of some free memory and store it in tempBytes as
                // Solidity does for memory variables.
                tempBytes := mload(0x40)

                // The first word of the slice result is potentially a partial
                // word read from the original array. To read it, we calculate
                // the length of that partial word and start copying that many
                // bytes into the array. The first word we copy will start with
                // data we don't care about, but the last `lengthmod` bytes will
                // land at the beginning of the contents of the new array. When
                // we're done copying, we overwrite the full first word with
                // the actual length of the slice.
                let lengthmod := and(_length, 31)

                // The multiplication in the next line is necessary
                // because when slicing multiples of 32 bytes (lengthmod == 0)
                // the following copy loop was copying the origin's length
                // and then ending prematurely not copying everything it should.
                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))
                let end := add(mc, _length)

                for {
                    // The multiplication in the next line has the same exact purpose
                    // as the one above.
                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)
                } lt(mc, end) {
                    mc := add(mc, 0x20)
                    cc := add(cc, 0x20)
                } {
                    mstore(mc, mload(cc))
                }

                mstore(tempBytes, _length)

                //update free-memory pointer
                //allocating the array padded to 32 bytes like the compiler does now
                mstore(0x40, and(add(mc, 31), not(31)))
            }
            //if we want a zero-length slice let's just return a zero-length array
            default {
                tempBytes := mload(0x40)
                //zero out the 32 bytes slice we are about to return
                //we need to do it because Solidity does not garbage collect
                mstore(tempBytes, 0)

                mstore(0x40, add(tempBytes, 0x20))
            }
        }

        return tempBytes;
    }

    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {
        require(_bytes.length >= _start + 20, ""toAddress_outOfBounds"");
        address tempAddress;

        assembly {
            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)
        }

        return tempAddress;
    }

    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {
        require(_bytes.length >= _start + 1, ""toUint8_outOfBounds"");
        uint8 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x1), _start))
        }

        return tempUint;
    }

    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {
        require(_bytes.length >= _start + 2, ""toUint16_outOfBounds"");
        uint16 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x2), _start))
        }

        return tempUint;
    }

    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {
        require(_bytes.length >= _start + 4, ""toUint32_outOfBounds"");
        uint32 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x4), _start))
        }

        return tempUint;
    }

    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {
        require(_bytes.length >= _start + 8, ""toUint64_outOfBounds"");
        uint64 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x8), _start))
        }

        return tempUint;
    }

    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {
        require(_bytes.length >= _start + 12, ""toUint96_outOfBounds"");
        uint96 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0xc), _start))
        }

        return tempUint;
    }

    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {
        require(_bytes.length >= _start + 16, ""toUint128_outOfBounds"");
        uint128 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x10), _start))
        }

        return tempUint;
    }

    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {
        require(_bytes.length >= _start + 32, ""toUint256_outOfBounds"");
        uint256 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x20), _start))
        }

        return tempUint;
    }

    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {
        require(_bytes.length >= _start + 32, ""toBytes32_outOfBounds"");
        bytes32 tempBytes32;

        assembly {
            tempBytes32 := mload(add(add(_bytes, 0x20), _start))
        }

        return tempBytes32;
    }

    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {
        bool success = true;

        assembly {
            let length := mload(_preBytes)

            // if lengths don't match the arrays are not equal
            switch eq(length, mload(_postBytes))
            case 1 {
                // cb is a circuit breaker in the for loop since there's
                //  no said feature for inline assembly loops
                // cb = 1 - don't breaker
                // cb = 0 - break
                let cb := 1

                let mc := add(_preBytes, 0x20)
                let end := add(mc, length)

                for {
                    let cc := add(_postBytes, 0x20)
                    // the next line is the loop condition:
                    // while(uint256(mc < end) + cb == 2)
                } eq(add(lt(mc, end), cb), 2) {
                    mc := add(mc, 0x20)
                    cc := add(cc, 0x20)
                } {
                    // if any of these checks fails then arrays are not equal
                    if iszero(eq(mload(mc), mload(cc))) {
                        // unsuccess:
                        success := 0
                        cb := 0
                    }
                }
            }
            default {
                // unsuccess:
                success := 0
            }
        }

        return success;
    }

    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {
        bool success = true;

        assembly {
            // we know _preBytes_offset is 0
            let fslot := sload(_preBytes.slot)
            // Decode the length of the stored array like in concatStorage().
            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)
            let mlength := mload(_postBytes)

            // if lengths don't match the arrays are not equal
            switch eq(slength, mlength)
            case 1 {
                // slength can contain both the length and contents of the array
                // if length < 32 bytes so let's prepare for that
                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage
                if iszero(iszero(slength)) {
                    switch lt(slength, 32)
                    case 1 {
                        // blank the last byte which is the length
                        fslot := mul(div(fslot, 0x100), 0x100)

                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {
                            // unsuccess:
                            success := 0
                        }
                    }
                    default {
                        // cb is a circuit breaker in the for loop since there's
                        //  no said feature for inline assembly loops
                        // cb = 1 - don't breaker
                        // cb = 0 - break
                        let cb := 1

                        // get the keccak hash to get the contents of the array
                        mstore(0x0, _preBytes.slot)
                        let sc := keccak256(0x0, 0x20)

                        let mc := add(_postBytes, 0x20)
                        let end := add(mc, mlength)

                        // the next line is the loop condition:
                        // while(uint256(mc < end) + cb == 2)
                        // solhint-disable-next-line no-empty-blocks
                        for {

                        } eq(add(lt(mc, end), cb), 2) {
                            sc := add(sc, 1)
                            mc := add(mc, 0x20)
                        } {
                            if iszero(eq(sload(sc), mload(mc))) {
                                // unsuccess:
                                success := 0
                                cb := 0
                            }
                        }
                    }
                }
            }
            default {
                // unsuccess:
                success := 0
            }
        }

        return success;
    }
}",4136
RealWorld_BA_103_GenericSwapFacet_RealWord_20240827225229.log,103,GenericSwapFacet,9852,5343,15195,84.0,0.15612,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { ILiFi } from ""../Interfaces/ILiFi.sol"";
import { LibAsset, IERC20 } from ""../Libraries/LibAsset.sol"";
import ""./Swapper.sol"";

/**
 * @title Generic Swap Facet
 * @author Li.Finance (https://li.finance)
 * @notice Provides functionality for swapping through ANY DEX
 * @dev Uses calldata to execute arbitrary methods on DEXs
 */
contract GenericSwapFacet is ILiFi, Swapper {
    /* ========== Public Functions ========== */

    /**
     * @notice Performs a swap and that's it
     * @param _lifiData data used purely for tracking and analytics
     * @param _swapData an array of swap related data for performing swaps before bridging
     */
    function swapTokensGeneric(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) public payable {
        uint256 receivingAssetIdBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId);

        // Swap
        _executeSwaps(_lifiData, _swapData);

        uint256 postSwapBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId) - receivingAssetIdBalance;

        LibAsset.transferAsset(_lifiData.receivingAssetId, payable(msg.sender), postSwapBalance);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }
}",379
RealWorld_BA_103_ILiFi_RealWord_20240828003315.log,103,ILiFi,8119,4565,12684,79.0,0.131895,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface ILiFi {
    /* ========== Structs ========== */

    struct LiFiData {
        bytes32 transactionId;
        string integrator;
        address referrer;
        address sendingAssetId;
        address receivingAssetId;
        address receiver;
        uint256 destinationChainId;
        uint256 amount;
    }

    /* ========== Events ========== */

    event LiFiTransferStarted(
        bytes32 indexed transactionId,
        string integrator,
        address referrer,
        address sendingAssetId,
        address receivingAssetId,
        address receiver,
        uint256 amount,
        uint256 destinationChainId,
        uint256 timestamp
    );

    event LiFiTransferCompleted(
        bytes32 indexed transactionId,
        address receivingAssetId,
        address receiver,
        uint256 amount,
        uint256 timestamp
    );

    event LiFiTransferConfirmed(
        bytes32 indexed transactionId,
        string integrator,
        address referrer,
        address sendingAssetId,
        address receivingAssetId,
        address receiver,
        uint256 amount,
        uint256 destinationChainId,
        uint256 timestamp
    );
    event LiFiTransferRefunded(
        bytes32 indexed transactionId,
        string integrator,
        address referrer,
        address sendingAssetId,
        address receivingAssetId,
        address receiver,
        uint256 amount,
        uint256 destinationChainId,
        uint256 timestamp
    );
    event Inited(address indexed bridge, uint64 chainId);
}",314
RealWorld_BA_103_DexManagerFacet_RealWord_20240827225818.log,103,DexManagerFacet,13854,5357,19211,89.0,0.17641,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""../Libraries/LibStorage.sol"";
import ""../Libraries/LibDiamond.sol"";

/**
 * @title Optics Router Facet
 * @author Li.Finance (https://li.finance)
 * @notice Facet contract for managing approved DEXs to be used in swaps.
 */
contract DexManagerFacet {
    LibStorage internal s;

    /// @notice Register the address of a DEX contract to be approved for swapping.
    /// @param _dex The address of the DEX contract to be approved.
    function addDex(address _dex) external {
        LibDiamond.enforceIsContractOwner();

        if (s.dexWhitelist[_dex] == true) {
            return;
        }

        s.dexWhitelist[_dex] = true;
        s.dexs.push(_dex);
    }

    /// @notice Batch register the addresss of DEX contracts to be approved for swapping.
    /// @param _dexs The addresses of the DEX contracts to be approved.
    function batchAddDex(address[] calldata _dexs) external {
        LibDiamond.enforceIsContractOwner();

        for (uint256 i; i < _dexs.length; i++) {
            if (s.dexWhitelist[_dexs[i]] == true) {
                continue;
            }
            s.dexWhitelist[_dexs[i]] = true;
            s.dexs.push(_dexs[i]);
        }
    }

    /// @notice Unregister the address of a DEX contract approved for swapping.
    /// @param _dex The address of the DEX contract to be unregistered.
    function removeDex(address _dex) external {
        LibDiamond.enforceIsContractOwner();

        if (s.dexWhitelist[_dex] == false) {
            return;
        }

        s.dexWhitelist[_dex] = false;
        for (uint256 i; i < s.dexs.length; i++) {
            if (s.dexs[i] == _dex) {
                _removeDex(i);
                return;
            }
        }
    }

    /// @notice Batch unregister the addresses of DEX contracts approved for swapping.
    /// @param _dexs The addresses of the DEX contracts to be unregistered.
    function batchRemoveDex(address[] calldata _dexs) external {
        LibDiamond.enforceIsContractOwner();

        for (uint256 i; i < _dexs.length; i++) {
            if (s.dexWhitelist[_dexs[i]] == false) {
                continue;
            }
            s.dexWhitelist[_dexs[i]] = false;
            for (uint256 j; j < s.dexs.length; j++) {
                if (s.dexs[j] == _dexs[i]) {
                    _removeDex(j);
                    return;
                }
            }
        }
    }

    function approvedDexs() external view returns (address[] memory) {
        return s.dexs;
    }

    function _removeDex(uint256 index) private {
        // Move the last element into the place to delete
        s.dexs[index] = s.dexs[s.dexs.length - 1];
        // Remove the last element
        s.dexs.pop();
    }
}",684
RealWorld_BA_103_IDiamondLoupe_RealWord_20240827232927.log,103,IDiamondLoupe,7595,5126,12721,82.0,0.140495,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

// A loupe is a small magnifying glass used to look at diamonds.
// These functions look at diamonds
interface IDiamondLoupe {
    /// These functions are expected to be called frequently
    /// by tools.

    struct Facet {
        address facetAddress;
        bytes4[] functionSelectors;
    }

    /// @notice Gets all facet addresses and their four byte function selectors.
    /// @return facets_ Facet
    function facets() external view returns (Facet[] memory facets_);

    /// @notice Gets all the function selectors supported by a specific facet.
    /// @param _facet The facet address.
    /// @return facetFunctionSelectors_
    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);

    /// @notice Get all the facet addresses used by a diamond.
    /// @return facetAddresses_
    function facetAddresses() external view returns (address[] memory facetAddresses_);

    /// @notice Gets the facet that supports the given selector.
    /// @dev If facet is not found return address(0).
    /// @param _functionSelector The function selector.
    /// @return facetAddress_ The facet address.
    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);
}",276
RealWorld_BA_103_AnyswapFacet_RealWord_20240828002127.log,103,AnyswapFacet,26733,5370,32103,92.0,0.241065,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { ILiFi } from ""../Interfaces/ILiFi.sol"";
import { IAnyswapRouter } from ""../Interfaces/IAnyswapRouter.sol"";
import { LibDiamond } from ""../Libraries/LibDiamond.sol"";
import { LibAsset, IERC20 } from ""../Libraries/LibAsset.sol"";
import { IAnyswapToken } from ""../Interfaces/IAnyswapToken.sol"";
import { LibDiamond } from ""../Libraries/LibDiamond.sol"";
import ""./Swapper.sol"";

/**
 * @title Anyswap Facet
 * @author Li.Finance (https://li.finance)
 * @notice Provides functionality for bridging through Multichain (Prev. AnySwap)
 */
contract AnyswapFacet is ILiFi, Swapper {
    /* ========== Types ========== */

    struct AnyswapData {
        address token;
        address router;
        uint256 amount;
        address recipient;
        uint256 toChainId;
    }

    /* ========== Public Bridge Functions ========== */

    /**
     * @notice Bridges tokens via Anyswap
     * @param _lifiData data used purely for tracking and analytics
     * @param _anyswapData data specific to Anyswap
     */
    function startBridgeTokensViaAnyswap(LiFiData memory _lifiData, AnyswapData calldata _anyswapData) public payable {
        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();
        if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {
            if (underlyingToken == address(0)) {
                underlyingToken = _anyswapData.token;
            }

            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);
            LibAsset.transferFromERC20(underlyingToken, msg.sender, address(this), _anyswapData.amount);

            require(
                LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount,
                ""ERR_INVALID_AMOUNT""
            );
        } else {
            require(msg.value == _anyswapData.amount, ""ERR_INVALID_AMOUNT"");
        }

        _startBridge(_anyswapData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /**
     * @notice Performs a swap before bridging via Anyswap
     * @param _lifiData data used purely for tracking and analytics
     * @param _swapData an array of swap related data for performing swaps before bridging
     * @param _anyswapData data specific to Anyswap
     */
    function swapAndStartBridgeTokensViaAnyswap(
        LiFiData memory _lifiData,
        LibSwap.SwapData[] calldata _swapData,
        AnyswapData memory _anyswapData
    ) public payable {
        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();
        if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {
            if (underlyingToken == address(0)) {
                underlyingToken = _anyswapData.token;
            }

            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);

            // Swap
            _executeSwaps(_lifiData, _swapData);

            uint256 _postSwapBalance = LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance;

            require(_postSwapBalance > 0, ""ERR_INVALID_AMOUNT"");

            _anyswapData.amount = _postSwapBalance;
        } else {
            uint256 _fromBalance = address(this).balance;

            // Swap
            _executeSwaps(_lifiData, _swapData);

            require(address(this).balance - _fromBalance >= _anyswapData.amount, ""ERR_INVALID_AMOUNT"");

            uint256 _postSwapBalance = address(this).balance - _fromBalance;

            require(_postSwapBalance > 0, ""ERR_INVALID_AMOUNT"");

            _anyswapData.amount = _postSwapBalance;
        }

        _startBridge(_anyswapData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /* ========== Internal Functions ========== */

    /**
     * @dev Conatains the business logic for the bridge via Anyswap
     * @param _anyswapData data specific to Anyswap
     */
    function _startBridge(AnyswapData memory _anyswapData) internal {
        // Check chain id
        require(block.chainid != _anyswapData.toChainId, ""Cannot bridge to the same network."");
        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();

        if (underlyingToken == IAnyswapRouter(_anyswapData.router).wNATIVE()) {
            IAnyswapRouter(_anyswapData.router).anySwapOutNative{ value: _anyswapData.amount }(
                _anyswapData.token,
                _anyswapData.recipient,
                _anyswapData.toChainId
            );
            return;
        }

        if (_anyswapData.token != address(0)) {
            // Has underlying token?
            if (underlyingToken != address(0)) {
                // Give Anyswap approval to bridge tokens
                LibAsset.approveERC20(IERC20(underlyingToken), _anyswapData.router, _anyswapData.amount);

                IAnyswapRouter(_anyswapData.router).anySwapOutUnderlying(
                    _anyswapData.token,
                    _anyswapData.recipient,
                    _anyswapData.amount,
                    _anyswapData.toChainId
                );
            } else {
                // Give Anyswap approval to bridge tokens
                LibAsset.approveERC20(IERC20(_anyswapData.token), _anyswapData.router, _anyswapData.amount);

                IAnyswapRouter(_anyswapData.router).anySwapOut(
                    _anyswapData.token,
                    _anyswapData.recipient,
                    _anyswapData.amount,
                    _anyswapData.toChainId
                );
            }
        }
    }
}",1495
RealWorld_BA_103_DiamondCutFacet_RealWord_20240827225355.log,103,DiamondCutFacet,6528,5341,11869,88.0,0.13946,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { IDiamondCut } from ""../Interfaces/IDiamondCut.sol"";
import { LibDiamond } from ""../Libraries/LibDiamond.sol"";

contract DiamondCutFacet is IDiamondCut {
    /// @notice Add/replace/remove any number of functions and optionally execute
    ///         a function with delegatecall
    /// @param _diamondCut Contains the facet addresses and function selectors
    /// @param _init The address of the contract or facet to execute _calldata
    /// @param _calldata A function call, including function selector and arguments
    ///                  _calldata is executed with delegatecall on _init
    function diamondCut(
        FacetCut[] calldata _diamondCut,
        address _init,
        bytes calldata _calldata
    ) external override {
        LibDiamond.enforceIsContractOwner();
        LibDiamond.diamondCut(_diamondCut, _init, _calldata);
    }
}",209
RealWorld_BA_103_CBridgeFacet_RealWord_20240827230133.log,103,CBridgeFacet,26034,5639,31673,102.0,0.24295,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { LibAsset, IERC20 } from ""../Libraries/LibAsset.sol"";
import { ILiFi } from ""../Interfaces/ILiFi.sol"";
import { ICBridge } from ""../Interfaces/ICBridge.sol"";
import { LibDiamond } from ""../Libraries/LibDiamond.sol"";
import ""./Swapper.sol"";

/**
 * @title CBridge Facet
 * @author Li.Finance (https://li.finance)
 * @notice Provides functionality for bridging through CBridge
 */
contract CBridgeFacet is ILiFi, Swapper {
    /* ========== Storage ========== */

    bytes32 internal constant NAMESPACE = keccak256(""com.lifi.facets.cbridge2"");
    struct Storage {
        address cBridge;
        uint64 cBridgeChainId;
    }

    /* ========== Types ========== */

    struct CBridgeData {
        address receiver;
        address token;
        uint256 amount;
        uint64 dstChainId;
        uint64 nonce;
        uint32 maxSlippage;
    }

    /* ========== Init ========== */

    /**
     * @notice Initializes local variables for the CBridge facet
     * @param _cBridge address of the canonical CBridge router contract
     * @param _chainId chainId of this deployed contract
     */
    function initCbridge(address _cBridge, uint64 _chainId) external {
        Storage storage s = getStorage();
        LibDiamond.enforceIsContractOwner();
        s.cBridge = _cBridge;
        s.cBridgeChainId = _chainId;
        emit Inited(s.cBridge, s.cBridgeChainId);
    }

    /* ========== Public Bridge Functions ========== */

    /**
     * @notice Bridges tokens via CBridge
     * @param _lifiData data used purely for tracking and analytics
     * @param _cBridgeData data specific to CBridge
     */
    function startBridgeTokensViaCBridge(LiFiData memory _lifiData, CBridgeData calldata _cBridgeData) public payable {
        if (_cBridgeData.token != address(0)) {
            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);

            LibAsset.transferFromERC20(_cBridgeData.token, msg.sender, address(this), _cBridgeData.amount);

            require(
                LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance == _cBridgeData.amount,
                ""ERR_INVALID_AMOUNT""
            );
        } else {
            require(msg.value >= _cBridgeData.amount, ""ERR_INVALID_AMOUNT"");
        }

        _startBridge(_cBridgeData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /**
     * @notice Performs a swap before bridging via CBridge
     * @param _lifiData data used purely for tracking and analytics
     * @param _swapData an array of swap related data for performing swaps before bridging
     * @param _cBridgeData data specific to CBridge
     */
    function swapAndStartBridgeTokensViaCBridge(
        LiFiData memory _lifiData,
        LibSwap.SwapData[] calldata _swapData,
        CBridgeData memory _cBridgeData
    ) public payable {
        if (_cBridgeData.token != address(0)) {
            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);

            // Swap
            _executeSwaps(_lifiData, _swapData);

            uint256 _postSwapBalance = LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance;

            require(_postSwapBalance > 0, ""ERR_INVALID_AMOUNT"");

            _cBridgeData.amount = _postSwapBalance;
        } else {
            uint256 _fromBalance = address(this).balance;

            // Swap
            _executeSwaps(_lifiData, _swapData);

            uint256 _postSwapBalance = address(this).balance - _fromBalance;

            require(_postSwapBalance > 0, ""ERR_INVALID_AMOUNT"");

            _cBridgeData.amount = _postSwapBalance;
        }

        _startBridge(_cBridgeData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /* ========== Internal Functions ========== */

    /*
     * @dev Conatains the business logic for the bridge via CBridge
     * @param _cBridgeData data specific to CBridge
     */
    function _startBridge(CBridgeData memory _cBridgeData) internal {
        Storage storage s = getStorage();
        address bridge = _bridge();

        // Do CBridge stuff
        require(s.cBridgeChainId != _cBridgeData.dstChainId, ""Cannot bridge to the same network."");

        if (LibAsset.isNativeAsset(_cBridgeData.token)) {
            ICBridge(bridge).sendNative(
                _cBridgeData.receiver,
                _cBridgeData.amount,
                _cBridgeData.dstChainId,
                _cBridgeData.nonce,
                _cBridgeData.maxSlippage
            );
        } else {
            // Give CBridge approval to bridge tokens
            LibAsset.approveERC20(IERC20(_cBridgeData.token), bridge, _cBridgeData.amount);
            // solhint-disable check-send-result
            ICBridge(bridge).send(
                _cBridgeData.receiver,
                _cBridgeData.token,
                _cBridgeData.amount,
                _cBridgeData.dstChainId,
                _cBridgeData.nonce,
                _cBridgeData.maxSlippage
            );
        }
    }

    /*
     * @dev Public view function for the CBridge router address
     * @returns the router address
     */
    function _bridge() internal view returns (address) {
        Storage storage s = getStorage();
        return s.cBridge;
    }

    /**
     * @dev fetch local storage
     */
    function getStorage() internal pure returns (Storage storage s) {
        bytes32 namespace = NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}",1422
RealWorld_BA_103_LibUtil_RealWord_20240827231245.log,103,LibUtil,5049,4463,9512,81.0,0.114505,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""./LibBytes.sol"";

library LibUtil {
    using LibBytes for bytes;

    function getRevertMsg(bytes memory _res) internal pure returns (string memory) {
        // If the _res length is less than 68, then the transaction failed silently (without a revert message)
        if (_res.length < 68) return ""Transaction reverted silently"";
        bytes memory revertData = _res.slice(4, _res.length - 4); // Remove the selector which is the first 4 bytes
        return abi.decode(revertData, (string)); // All that remains is the revert string
    }
}",145
RealWorld_BA_103_LibDiamond_RealWord_20240828002424.log,103,LibDiamond,37809,5196,43005,97.0,0.292965,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { IDiamondCut } from ""../Interfaces/IDiamondCut.sol"";

library LibDiamond {
    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(""diamond.standard.diamond.storage"");

    struct FacetAddressAndPosition {
        address facetAddress;
        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array
    }

    struct FacetFunctionSelectors {
        bytes4[] functionSelectors;
        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array
    }

    struct DiamondStorage {
        // maps function selector to the facet address and
        // the position of the selector in the facetFunctionSelectors.selectors array
        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;
        // maps facet addresses to function selectors
        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;
        // facet addresses
        address[] facetAddresses;
        // Used to query if a contract implements an interface.
        // Used to implement ERC-165.
        mapping(bytes4 => bool) supportedInterfaces;
        // owner of the contract
        address contractOwner;
    }

    function diamondStorage() internal pure returns (DiamondStorage storage ds) {
        bytes32 position = DIAMOND_STORAGE_POSITION;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            ds.slot := position
        }
    }

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function setContractOwner(address _newOwner) internal {
        DiamondStorage storage ds = diamondStorage();
        address previousOwner = ds.contractOwner;
        ds.contractOwner = _newOwner;
        emit OwnershipTransferred(previousOwner, _newOwner);
    }

    function contractOwner() internal view returns (address contractOwner_) {
        contractOwner_ = diamondStorage().contractOwner;
    }

    function enforceIsContractOwner() internal view {
        require(msg.sender == diamondStorage().contractOwner, ""LibDiamond: Must be contract owner"");
    }

    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);

    // Internal function version of diamondCut
    function diamondCut(
        IDiamondCut.FacetCut[] memory _diamondCut,
        address _init,
        bytes memory _calldata
    ) internal {
        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {
            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;
            if (action == IDiamondCut.FacetCutAction.Add) {
                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);
            } else if (action == IDiamondCut.FacetCutAction.Replace) {
                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);
            } else if (action == IDiamondCut.FacetCutAction.Remove) {
                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);
            } else {
                revert(""LibDiamondCut: Incorrect FacetCutAction"");
            }
        }
        emit DiamondCut(_diamondCut, _init, _calldata);
        initializeDiamondCut(_init, _calldata);
    }

    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
        require(_functionSelectors.length > 0, ""LibDiamondCut: No selectors in facet to cut"");
        DiamondStorage storage ds = diamondStorage();
        require(_facetAddress != address(0), ""LibDiamondCut: Add facet can't be address(0)"");
        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);
        // add new facet address if it does not exist
        if (selectorPosition == 0) {
            addFacet(ds, _facetAddress);
        }
        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {
            bytes4 selector = _functionSelectors[selectorIndex];
            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;
            require(oldFacetAddress == address(0), ""LibDiamondCut: Can't add function that already exists"");
            addFunction(ds, selector, selectorPosition, _facetAddress);
            selectorPosition++;
        }
    }

    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
        require(_functionSelectors.length > 0, ""LibDiamondCut: No selectors in facet to cut"");
        DiamondStorage storage ds = diamondStorage();
        require(_facetAddress != address(0), ""LibDiamondCut: Add facet can't be address(0)"");
        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);
        // add new facet address if it does not exist
        if (selectorPosition == 0) {
            addFacet(ds, _facetAddress);
        }
        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {
            bytes4 selector = _functionSelectors[selectorIndex];
            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;
            require(oldFacetAddress != _facetAddress, ""LibDiamondCut: Can't replace function with same function"");
            removeFunction(ds, oldFacetAddress, selector);
            addFunction(ds, selector, selectorPosition, _facetAddress);
            selectorPosition++;
        }
    }

    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
        require(_functionSelectors.length > 0, ""LibDiamondCut: No selectors in facet to cut"");
        DiamondStorage storage ds = diamondStorage();
        // if function does not exist then do nothing and return
        require(_facetAddress == address(0), ""LibDiamondCut: Remove facet address must be address(0)"");
        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {
            bytes4 selector = _functionSelectors[selectorIndex];
            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;
            removeFunction(ds, oldFacetAddress, selector);
        }
    }

    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {
        enforceHasContractCode(_facetAddress, ""LibDiamondCut: New facet has no code"");
        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;
        ds.facetAddresses.push(_facetAddress);
    }

    function addFunction(
        DiamondStorage storage ds,
        bytes4 _selector,
        uint96 _selectorPosition,
        address _facetAddress
    ) internal {
        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;
        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);
        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;
    }

    function removeFunction(
        DiamondStorage storage ds,
        address _facetAddress,
        bytes4 _selector
    ) internal {
        require(_facetAddress != address(0), ""LibDiamondCut: Can't remove function that doesn't exist"");
        // an immutable function is a function defined directly in a diamond
        require(_facetAddress != address(this), ""LibDiamondCut: Can't remove immutable function"");
        // replace selector with last selector, then delete last selector
        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;
        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;
        // if not the same then replace _selector with lastSelector
        if (selectorPosition != lastSelectorPosition) {
            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];
            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;
            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);
        }
        // delete the last selector
        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();
        delete ds.selectorToFacetAndPosition[_selector];

        // if no more selectors for facet address then delete the facet address
        if (lastSelectorPosition == 0) {
            // replace facet address with last facet address and delete last facet address
            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;
            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;
            if (facetAddressPosition != lastFacetAddressPosition) {
                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];
                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;
                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;
            }
            ds.facetAddresses.pop();
            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;
        }
    }

    function initializeDiamondCut(address _init, bytes memory _calldata) internal {
        if (_init == address(0)) {
            require(_calldata.length == 0, ""LibDiamondCut: _init is address(0) but_calldata is not empty"");
        } else {
            require(_calldata.length > 0, ""LibDiamondCut: _calldata is empty but _init is not address(0)"");
            if (_init != address(this)) {
                enforceHasContractCode(_init, ""LibDiamondCut: _init address has no code"");
            }
            // solhint-disable-next-line avoid-low-level-calls
            (bool success, bytes memory error) = _init.delegatecall(_calldata);
            if (!success) {
                if (error.length > 0) {
                    // bubble up the error
                    revert(string(error));
                } else {
                    revert(""LibDiamondCut: _init function reverted"");
                }
            }
        }
    }

    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {
        uint256 contractSize;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            contractSize := extcodesize(_contract)
        }
        require(contractSize > 0, _errorMessage);
    }
}",2168
RealWorld_BA_103_IHopBridge_RealWord_20240827232754.log,103,IHopBridge,5473,5036,10509,90.0,0.128085,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IHopBridge {
    struct BridgeConfig {
        address token;
        address bridge;
        address ammWrapper;
    }

    function sendToL2(
        uint256 chainId,
        address recipient,
        uint256 amount,
        uint256 amountOutMin,
        uint256 deadline,
        address relayer,
        uint256 relayerFee
    ) external payable;

    function swapAndSend(
        uint256 chainId,
        address recipient,
        uint256 amount,
        uint256 bonderFee,
        uint256 amountOutMin,
        uint256 deadline,
        uint256 destinationAmountOutMin,
        uint256 destinationDeadline
    ) external payable;
}",153
RealWorld_BA_103_WithdrawFacet_RealWord_20240828001844.log,103,WithdrawFacet,8560,6038,14598,87.0,0.16356,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { LibDiamond } from ""../Libraries/LibDiamond.sol"";

contract WithdrawFacet {
    using SafeERC20 for IERC20;
    address private constant NATIVE_ASSET = address(0);

    event LogWithdraw(address indexed _assetAddress, address _from, uint256 amount);

    /**
     * @dev Withdraw asset.
     * @param _assetAddress Asset to be withdrawn.
     * @param _to address to withdraw to.
     * @param _amount amount of asset to withdraw.
     */
    function withdraw(
        address _assetAddress,
        address _to,
        uint256 _amount
    ) public {
        LibDiamond.enforceIsContractOwner();
        address sendTo = (_to == address(0)) ? msg.sender : _to;
        uint256 assetBalance;
        if (_assetAddress == NATIVE_ASSET) {
            address self = address(this); // workaround for a possible solidity bug
            assert(_amount <= self.balance);
            payable(sendTo).transfer(_amount);
        } else {
            assetBalance = IERC20(_assetAddress).balanceOf(address(this));
            assert(_amount <= assetBalance);
            IERC20(_assetAddress).safeTransfer(sendTo, _amount);
        }
        emit LogWithdraw(sendTo, _assetAddress, _amount);
    }
}",335
RealWorld_BA_103_LibAsset_RealWord_20240827231408.log,103,LibAsset,23311,5285,28596,89.0,0.222255,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.7;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/**
 * @title LibAsset
 * @author Connext <support@connext.network>
 * @notice This library contains helpers for dealing with onchain transfers
 *         of assets, including accounting for the native asset `assetId`
 *         conventions and any noncompliant ERC20 transfers
 */
library LibAsset {
    uint256 private constant MAX_INT = 2**256 - 1;

    /**
     * @dev All native assets use the empty address for their asset id
     *      by convention
     */
    address internal constant NATIVE_ASSETID = address(0);

    /**
     * @notice Determines whether the given assetId is the native asset
     * @param assetId The asset identifier to evaluate
     * @return Boolean indicating if the asset is the native asset
     */
    function isNativeAsset(address assetId) internal pure returns (bool) {
        return assetId == NATIVE_ASSETID;
    }

    /**
     * @notice Gets the balance of the inheriting contract for the given asset
     * @param assetId The asset identifier to get the balance of
     * @return Balance held by contracts using this library
     */
    function getOwnBalance(address assetId) internal view returns (uint256) {
        return isNativeAsset(assetId) ? address(this).balance : IERC20(assetId).balanceOf(address(this));
    }

    /**
     * @notice Transfers ether from the inheriting contract to a given
     *         recipient
     * @param recipient Address to send ether to
     * @param amount Amount to send to given recipient
     */
    function transferNativeAsset(address payable recipient, uint256 amount) internal {
        // solhint-disable-next-line avoid-low-level-calls
        (bool success, ) = recipient.call{ value: amount }("""");
        require(success, ""#TNA:028"");
    }

    /**
     * @notice Gives approval for another address to spend tokens
     * @param assetId Token address to transfer
     * @param spender Address to give spend approval to
     * @param amount Amount to approve for spending
     */
    function approveERC20(
        IERC20 assetId,
        address spender,
        uint256 amount
    ) internal {
        if (isNativeAsset(address(assetId))) return;
        uint256 allowance = assetId.allowance(address(this), spender);
        if (allowance < amount) {
            if (allowance > 0) SafeERC20.safeApprove(IERC20(assetId), spender, 0);
            SafeERC20.safeApprove(IERC20(assetId), spender, MAX_INT);
        }
    }

    /**
     * @notice Transfers tokens from the inheriting contract to a given
     *         recipient
     * @param assetId Token address to transfer
     * @param recipient Address to send ether to
     * @param amount Amount to send to given recipient
     */
    function transferERC20(
        address assetId,
        address recipient,
        uint256 amount
    ) internal {
        SafeERC20.safeTransfer(IERC20(assetId), recipient, amount);
    }

    /**
     * @notice Transfers tokens from a sender to a given recipient
     * @param assetId Token address to transfer
     * @param from Address of sender/owner
     * @param to Address of recipient/spender
     * @param amount Amount to transfer from owner to spender
     */
    function transferFromERC20(
        address assetId,
        address from,
        address to,
        uint256 amount
    ) internal {
        SafeERC20.safeTransferFrom(IERC20(assetId), from, to, amount);
    }

    /**
     * @notice Increases the allowance of a token to a spender
     * @param assetId Token address of asset to increase allowance of
     * @param spender Account whos allowance is increased
     * @param amount Amount to increase allowance by
     */
    function increaseERC20Allowance(
        address assetId,
        address spender,
        uint256 amount
    ) internal {
        require(!isNativeAsset(assetId), ""#IA:034"");
        SafeERC20.safeIncreaseAllowance(IERC20(assetId), spender, amount);
    }

    /**
     * @notice Decreases the allowance of a token to a spender
     * @param assetId Token address of asset to decrease allowance of
     * @param spender Account whos allowance is decreased
     * @param amount Amount to decrease allowance by
     */
    function decreaseERC20Allowance(
        address assetId,
        address spender,
        uint256 amount
    ) internal {
        require(!isNativeAsset(assetId), ""#DA:034"");
        SafeERC20.safeDecreaseAllowance(IERC20(assetId), spender, amount);
    }

    /**
     * @notice Wrapper function to transfer a given asset (native or erc20) to
     *         some recipient. Should handle all non-compliant return value
     *         tokens as well by using the SafeERC20 contract by open zeppelin.
     * @param assetId Asset id for transfer (address(0) for native asset,
     *                token address for erc20s)
     * @param recipient Address to send asset to
     * @param amount Amount to send to given recipient
     */
    function transferAsset(
        address assetId,
        address payable recipient,
        uint256 amount
    ) internal {
        isNativeAsset(assetId) ? transferNativeAsset(recipient, amount) : transferERC20(assetId, recipient, amount);
    }
}",1217
RealWorld_BA_103_GenericSwapFacet_RealWord_20240828000620.log,103,GenericSwapFacet,9424,5810,15234,95.0,0.16332,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { ILiFi } from ""../Interfaces/ILiFi.sol"";
import { LibAsset, IERC20 } from ""../Libraries/LibAsset.sol"";
import ""./Swapper.sol"";

/**
 * @title Generic Swap Facet
 * @author Li.Finance (https://li.finance)
 * @notice Provides functionality for swapping through ANY DEX
 * @dev Uses calldata to execute arbitrary methods on DEXs
 */
contract GenericSwapFacet is ILiFi, Swapper {
    /* ========== Public Functions ========== */

    /**
     * @notice Performs a swap and that's it
     * @param _lifiData data used purely for tracking and analytics
     * @param _swapData an array of swap related data for performing swaps before bridging
     */
    function swapTokensGeneric(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) public payable {
        uint256 receivingAssetIdBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId);

        // Swap
        _executeSwaps(_lifiData, _swapData);

        uint256 postSwapBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId) - receivingAssetIdBalance;

        LibAsset.transferAsset(_lifiData.receivingAssetId, payable(msg.sender), postSwapBalance);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }
}",379
RealWorld_BA_103_LiFiDiamond_RealWord_20240827225101.log,103,LiFiDiamond,12036,5654,17690,85.0,0.17326,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { LibDiamond } from ""./Libraries/LibDiamond.sol"";
import { IDiamondCut } from ""./Interfaces/IDiamondCut.sol"";

contract LiFiDiamond {
    constructor(address _contractOwner, address _diamondCutFacet) payable {
        LibDiamond.setContractOwner(_contractOwner);

        // Add the diamondCut external function from the diamondCutFacet
        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);
        bytes4[] memory functionSelectors = new bytes4[](1);
        functionSelectors[0] = IDiamondCut.diamondCut.selector;
        cut[0] = IDiamondCut.FacetCut({
            facetAddress: _diamondCutFacet,
            action: IDiamondCut.FacetCutAction.Add,
            functionSelectors: functionSelectors
        });
        LibDiamond.diamondCut(cut, address(0), """");
    }

    // Find facet for function that is called and execute the
    // function if a facet is found and return any value.
    // solhint-disable-next-line no-complex-fallback
    fallback() external payable {
        LibDiamond.DiamondStorage storage ds;
        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;

        // get diamond storage
        // solhint-disable-next-line no-inline-assembly
        assembly {
            ds.slot := position
        }

        // get facet from function selector
        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;
        require(facet != address(0), ""Diamond: Function does not exist"");

        // Execute external function from facet using delegatecall and return any value.
        // solhint-disable-next-line no-inline-assembly
        assembly {
            // copy function selector and any arguments
            calldatacopy(0, 0, calldatasize())
            // execute function call using the facet
            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)
            // get any return value
            returndatacopy(0, 0, returndatasize())
            // return any return value or error back to the caller
            switch result
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }

    // Able to receive ether
    // solhint-disable-next-line no-empty-blocks
    receive() external payable {}
}",532
RealWorld_BA_103_ILiFi_RealWord_20240827232025.log,103,ILiFi,9050,5210,14260,93.0,0.14945,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface ILiFi {
    /* ========== Structs ========== */

    struct LiFiData {
        bytes32 transactionId;
        string integrator;
        address referrer;
        address sendingAssetId;
        address receivingAssetId;
        address receiver;
        uint256 destinationChainId;
        uint256 amount;
    }

    /* ========== Events ========== */

    event LiFiTransferStarted(
        bytes32 indexed transactionId,
        string integrator,
        address referrer,
        address sendingAssetId,
        address receivingAssetId,
        address receiver,
        uint256 amount,
        uint256 destinationChainId,
        uint256 timestamp
    );

    event LiFiTransferCompleted(
        bytes32 indexed transactionId,
        address receivingAssetId,
        address receiver,
        uint256 amount,
        uint256 timestamp
    );

    event LiFiTransferConfirmed(
        bytes32 indexed transactionId,
        string integrator,
        address referrer,
        address sendingAssetId,
        address receivingAssetId,
        address receiver,
        uint256 amount,
        uint256 destinationChainId,
        uint256 timestamp
    );
    event LiFiTransferRefunded(
        bytes32 indexed transactionId,
        string integrator,
        address referrer,
        address sendingAssetId,
        address receivingAssetId,
        address receiver,
        uint256 amount,
        uint256 destinationChainId,
        uint256 timestamp
    );
    event Inited(address indexed bridge, uint64 chainId);
}",314
RealWorld_BA_103_ITransactionManager_RealWord_20240828003835.log,103,ITransactionManager,29934,5622,35556,81.0,0.26211,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.7;

interface ITransactionManager {
    // Structs

    // Holds all data that is constant between sending and
    // receiving chains. The hash of this is what gets signed
    // to ensure the signature can be used on both chains.
    struct InvariantTransactionData {
        address receivingChainTxManagerAddress;
        address user;
        address router;
        address initiator; // msg.sender of sending side
        address sendingAssetId;
        address receivingAssetId;
        address sendingChainFallback; // funds sent here on cancel
        address receivingAddress;
        address callTo;
        uint256 sendingChainId;
        uint256 receivingChainId;
        bytes32 callDataHash; // hashed to prevent free option
        bytes32 transactionId;
    }

    // Holds all data that varies between sending and receiving
    // chains. The hash of this is stored onchain to ensure the
    // information passed in is valid.
    struct VariantTransactionData {
        uint256 amount;
        uint256 expiry;
        uint256 preparedBlockNumber;
    }

    // All Transaction data, constant and variable
    struct TransactionData {
        address receivingChainTxManagerAddress;
        address user;
        address router;
        address initiator; // msg.sender of sending side
        address sendingAssetId;
        address receivingAssetId;
        address sendingChainFallback;
        address receivingAddress;
        address callTo;
        bytes32 callDataHash;
        bytes32 transactionId;
        uint256 sendingChainId;
        uint256 receivingChainId;
        uint256 amount;
        uint256 expiry;
        uint256 preparedBlockNumber; // Needed for removal of active blocks on fulfill/cancel
    }

    // The structure of the signed data for fulfill
    struct SignedFulfillData {
        bytes32 transactionId;
        uint256 relayerFee;
        string functionIdentifier; // ""fulfill"" or ""cancel""
        uint256 receivingChainId; // For domain separation
        address receivingChainTxManagerAddress; // For domain separation
    }

    // The structure of the signed data for cancellation
    struct SignedCancelData {
        bytes32 transactionId;
        string functionIdentifier;
        uint256 receivingChainId;
        address receivingChainTxManagerAddress; // For domain separation
    }

    /**
     * Arguments for calling prepare()
     * @param invariantData The data for a crosschain transaction that will
     *                      not change between sending and receiving chains.
     *                      The hash of this data is used as the key to store
     *                      the inforamtion that does change between chains
     *                      (amount,expiry,preparedBlock) for verification
     * @param amount The amount of the transaction on this chain
     * @param expiry The block.timestamp when the transaction will no longer be
     *               fulfillable and is freely cancellable on this chain
     * @param encryptedCallData The calldata to be executed when the tx is
     *                          fulfilled. Used in the function to allow the user
     *                          to reconstruct the tx from events. Hash is stored
     *                          onchain to prevent shenanigans.
     * @param encodedBid The encoded bid that was accepted by the user for this
     *                   crosschain transfer. It is supplied as a param to the
     *                   function but is only used in event emission
     * @param bidSignature The signature of the bidder on the encoded bid for
     *                     this transaction. Only used within the function for
     *                     event emission. The validity of the bid and
     *                     bidSignature are enforced offchain
     * @param encodedMeta The meta for the function
     */
    struct PrepareArgs {
        InvariantTransactionData invariantData;
        uint256 amount;
        uint256 expiry;
        bytes encryptedCallData;
        bytes encodedBid;
        bytes bidSignature;
        bytes encodedMeta;
    }

    /**
     * @param txData All of the data (invariant and variant) for a crosschain
     *               transaction. The variant data provided is checked against
     *               what was stored when the `prepare` function was called.
     * @param relayerFee The fee that should go to the relayer when they are
     *                   calling the function on the receiving chain for the user
     * @param signature The users signature on the transaction id + fee that
     *                  can be used by the router to unlock the transaction on
     *                  the sending chain
     * @param callData The calldata to be sent to and executed by the
     *                 `FulfillHelper`
     * @param encodedMeta The meta for the function
     */
    struct FulfillArgs {
        TransactionData txData;
        uint256 relayerFee;
        bytes signature;
        bytes callData;
        bytes encodedMeta;
    }

    /**
     * Arguments for calling cancel()
     * @param txData All of the data (invariant and variant) for a crosschain
     *               transaction. The variant data provided is checked against
     *               what was stored when the `prepare` function was called.
     * @param signature The user's signature that allows a transaction to be
     *                  cancelled by a relayer
     * @param encodedMeta The meta for the function
     */
    struct CancelArgs {
        TransactionData txData;
        bytes signature;
        bytes encodedMeta;
    }

    // Adding/removing asset events
    event RouterAdded(address indexed addedRouter, address indexed caller);

    event RouterRemoved(address indexed removedRouter, address indexed caller);

    // Adding/removing router events
    event AssetAdded(address indexed addedAssetId, address indexed caller);

    event AssetRemoved(address indexed removedAssetId, address indexed caller);

    // Liquidity events
    event LiquidityAdded(address indexed router, address indexed assetId, uint256 amount, address caller);

    event LiquidityRemoved(address indexed router, address indexed assetId, uint256 amount, address recipient);

    // Transaction events
    event TransactionPrepared(
        address indexed user,
        address indexed router,
        bytes32 indexed transactionId,
        TransactionData txData,
        address caller,
        PrepareArgs args
    );

    event TransactionFulfilled(
        address indexed user,
        address indexed router,
        bytes32 indexed transactionId,
        FulfillArgs args,
        bool success,
        bool isContract,
        bytes returnData,
        address caller
    );

    event TransactionCancelled(
        address indexed user,
        address indexed router,
        bytes32 indexed transactionId,
        CancelArgs args,
        address caller
    );

    // Getters
    function getChainId() external view returns (uint256);

    function getStoredChainId() external view returns (uint256);

    // Owner only methods
    function addRouter(address router) external;

    function removeRouter(address router) external;

    function addAssetId(address assetId) external;

    function removeAssetId(address assetId) external;

    // Router only methods
    function addLiquidityFor(
        uint256 amount,
        address assetId,
        address router
    ) external payable;

    function addLiquidity(uint256 amount, address assetId) external payable;

    function removeLiquidity(
        uint256 amount,
        address assetId,
        address payable recipient
    ) external;

    // Methods for crosschain transfers
    // called in the following order (in happy case)
    // 1. prepare by user on sending chain
    // 2. prepare by router on receiving chain
    // 3. fulfill by user on receiving chain
    // 4. fulfill by router on sending chain
    function prepare(PrepareArgs calldata args) external payable returns (TransactionData memory);

    function fulfill(FulfillArgs calldata args) external returns (TransactionData memory);

    function cancel(CancelArgs calldata args) external returns (TransactionData memory);
}",1660
RealWorld_BA_103_IDiamondCut_RealWord_20240827232320.log,103,IDiamondCut,7254,5272,12526,87.0,0.14171,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IDiamondCut {
    enum FacetCutAction {
        Add,
        Replace,
        Remove
    }
    // Add=0, Replace=1, Remove=2

    struct FacetCut {
        address facetAddress;
        FacetCutAction action;
        bytes4[] functionSelectors;
    }

    /// @notice Add/replace/remove any number of functions and optionally execute
    ///         a function with delegatecall
    /// @param _diamondCut Contains the facet addresses and function selectors
    /// @param _init The address of the contract or facet to execute _calldata
    /// @param _calldata A function call, including function selector and arguments
    ///                  _calldata is executed with delegatecall on _init
    function diamondCut(
        FacetCut[] calldata _diamondCut,
        address _init,
        bytes calldata _calldata
    ) external;

    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);
}",226
RealWorld_BA_103_CBridgeFacet_RealWord_20240828001531.log,103,CBridgeFacet,26331,5791,32122,114.0,0.247475,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { LibAsset, IERC20 } from ""../Libraries/LibAsset.sol"";
import { ILiFi } from ""../Interfaces/ILiFi.sol"";
import { ICBridge } from ""../Interfaces/ICBridge.sol"";
import { LibDiamond } from ""../Libraries/LibDiamond.sol"";
import ""./Swapper.sol"";

/**
 * @title CBridge Facet
 * @author Li.Finance (https://li.finance)
 * @notice Provides functionality for bridging through CBridge
 */
contract CBridgeFacet is ILiFi, Swapper {
    /* ========== Storage ========== */

    bytes32 internal constant NAMESPACE = keccak256(""com.lifi.facets.cbridge2"");
    struct Storage {
        address cBridge;
        uint64 cBridgeChainId;
    }

    /* ========== Types ========== */

    struct CBridgeData {
        address receiver;
        address token;
        uint256 amount;
        uint64 dstChainId;
        uint64 nonce;
        uint32 maxSlippage;
    }

    /* ========== Init ========== */

    /**
     * @notice Initializes local variables for the CBridge facet
     * @param _cBridge address of the canonical CBridge router contract
     * @param _chainId chainId of this deployed contract
     */
    function initCbridge(address _cBridge, uint64 _chainId) external {
        Storage storage s = getStorage();
        LibDiamond.enforceIsContractOwner();
        s.cBridge = _cBridge;
        s.cBridgeChainId = _chainId;
        emit Inited(s.cBridge, s.cBridgeChainId);
    }

    /* ========== Public Bridge Functions ========== */

    /**
     * @notice Bridges tokens via CBridge
     * @param _lifiData data used purely for tracking and analytics
     * @param _cBridgeData data specific to CBridge
     */
    function startBridgeTokensViaCBridge(LiFiData memory _lifiData, CBridgeData calldata _cBridgeData) public payable {
        if (_cBridgeData.token != address(0)) {
            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);

            LibAsset.transferFromERC20(_cBridgeData.token, msg.sender, address(this), _cBridgeData.amount);

            require(
                LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance == _cBridgeData.amount,
                ""ERR_INVALID_AMOUNT""
            );
        } else {
            require(msg.value >= _cBridgeData.amount, ""ERR_INVALID_AMOUNT"");
        }

        _startBridge(_cBridgeData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /**
     * @notice Performs a swap before bridging via CBridge
     * @param _lifiData data used purely for tracking and analytics
     * @param _swapData an array of swap related data for performing swaps before bridging
     * @param _cBridgeData data specific to CBridge
     */
    function swapAndStartBridgeTokensViaCBridge(
        LiFiData memory _lifiData,
        LibSwap.SwapData[] calldata _swapData,
        CBridgeData memory _cBridgeData
    ) public payable {
        if (_cBridgeData.token != address(0)) {
            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);

            // Swap
            _executeSwaps(_lifiData, _swapData);

            uint256 _postSwapBalance = LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance;

            require(_postSwapBalance > 0, ""ERR_INVALID_AMOUNT"");

            _cBridgeData.amount = _postSwapBalance;
        } else {
            uint256 _fromBalance = address(this).balance;

            // Swap
            _executeSwaps(_lifiData, _swapData);

            uint256 _postSwapBalance = address(this).balance - _fromBalance;

            require(_postSwapBalance > 0, ""ERR_INVALID_AMOUNT"");

            _cBridgeData.amount = _postSwapBalance;
        }

        _startBridge(_cBridgeData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /* ========== Internal Functions ========== */

    /*
     * @dev Conatains the business logic for the bridge via CBridge
     * @param _cBridgeData data specific to CBridge
     */
    function _startBridge(CBridgeData memory _cBridgeData) internal {
        Storage storage s = getStorage();
        address bridge = _bridge();

        // Do CBridge stuff
        require(s.cBridgeChainId != _cBridgeData.dstChainId, ""Cannot bridge to the same network."");

        if (LibAsset.isNativeAsset(_cBridgeData.token)) {
            ICBridge(bridge).sendNative(
                _cBridgeData.receiver,
                _cBridgeData.amount,
                _cBridgeData.dstChainId,
                _cBridgeData.nonce,
                _cBridgeData.maxSlippage
            );
        } else {
            // Give CBridge approval to bridge tokens
            LibAsset.approveERC20(IERC20(_cBridgeData.token), bridge, _cBridgeData.amount);
            // solhint-disable check-send-result
            ICBridge(bridge).send(
                _cBridgeData.receiver,
                _cBridgeData.token,
                _cBridgeData.amount,
                _cBridgeData.dstChainId,
                _cBridgeData.nonce,
                _cBridgeData.maxSlippage
            );
        }
    }

    /*
     * @dev Public view function for the CBridge router address
     * @returns the router address
     */
    function _bridge() internal view returns (address) {
        Storage storage s = getStorage();
        return s.cBridge;
    }

    /**
     * @dev fetch local storage
     */
    function getStorage() internal pure returns (Storage storage s) {
        bytes32 namespace = NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}",1422
RealWorld_BA_103_NXTPFacet_RealWord_20240828001045.log,103,NXTPFacet,31098,5572,36670,85.0,0.26693,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { ITransactionManager } from ""../Interfaces/ITransactionManager.sol"";
import { ILiFi } from ""../Interfaces/ILiFi.sol"";
import { LibAsset, IERC20 } from ""../Libraries/LibAsset.sol"";
import { LibDiamond } from ""../Libraries/LibDiamond.sol"";
import ""./Swapper.sol"";

/**
 * @title NXTP (Connext) Facet
 * @author Li.Finance (https://li.finance)
 * @notice Provides functionality for bridging through NXTP (Connext)
 */
contract NXTPFacet is ILiFi, Swapper {
    /* ========== Storage ========== */

    bytes32 internal constant NAMESPACE = keccak256(""com.lifi.facets.nxtp"");
    struct Storage {
        ITransactionManager nxtpTxManager;
    }

    /* ========== Events ========== */

    event NXTPBridgeStarted(
        bytes32 indexed lifiTransactionId,
        bytes32 nxtpTransactionId,
        ITransactionManager.TransactionData txData
    );

    /* ========== Init ========== */

    function initNXTP(ITransactionManager _txMgrAddr) external {
        Storage storage s = getStorage();
        LibDiamond.enforceIsContractOwner();
        s.nxtpTxManager = _txMgrAddr;
    }

    /* ========== Public Bridge Functions ========== */

    /**
     * @notice This function starts a cross-chain transaction using the NXTP protocol
     * @param _lifiData data used purely for tracking and analytics
     * @param _nxtpData data needed to complete an NXTP cross-chain transaction
     */
    function startBridgeTokensViaNXTP(LiFiData memory _lifiData, ITransactionManager.PrepareArgs memory _nxtpData)
        public
        payable
    {
        // Ensure sender has enough to complete the bridge transaction
        address sendingAssetId = _nxtpData.invariantData.sendingAssetId;
        if (sendingAssetId == address(0)) require(msg.value == _nxtpData.amount, ""ERR_INVALID_AMOUNT"");
        else {
            uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);
            LibAsset.transferFromERC20(sendingAssetId, msg.sender, address(this), _nxtpData.amount);
            require(
                LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance == _nxtpData.amount,
                ""ERR_INVALID_AMOUNT""
            );
        }

        // Start the bridge process
        _startBridge(_lifiData.transactionId, _nxtpData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /**
     * @notice This function performs a swap or multiple swaps and then starts a cross-chain transaction
     *         using the NXTP protocol.
     * @param _lifiData data used purely for tracking and analytics
     * @param _swapData array of data needed for swaps
     * @param _nxtpData data needed to complete an NXTP cross-chain transaction
     */
    function swapAndStartBridgeTokensViaNXTP(
        LiFiData memory _lifiData,
        LibSwap.SwapData[] calldata _swapData,
        ITransactionManager.PrepareArgs memory _nxtpData
    ) public payable {
        address sendingAssetId = _nxtpData.invariantData.sendingAssetId;
        uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);

        // Swap
        _executeSwaps(_lifiData, _swapData);

        uint256 _postSwapBalance = LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance;

        require(_postSwapBalance > 0, ""ERR_INVALID_AMOUNT"");

        _nxtpData.amount = _postSwapBalance;

        _startBridge(_lifiData.transactionId, _nxtpData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /**
     * @notice Completes a cross-chain transaction on the receiving chain using the NXTP protocol.
     * @param _lifiData data used purely for tracking and analytics
     * @param assetId token received on the receiving chain
     * @param receiver address that will receive the tokens
     * @param amount number of tokens received
     */
    function completeBridgeTokensViaNXTP(
        LiFiData memory _lifiData,
        address assetId,
        address receiver,
        uint256 amount
    ) public payable {
        if (LibAsset.isNativeAsset(assetId)) {
            require(msg.value == amount, ""INVALID_ETH_AMOUNT"");
        } else {
            require(msg.value == 0, ""ETH_WITH_ERC"");
            LibAsset.transferFromERC20(assetId, msg.sender, address(this), amount);
        }

        LibAsset.transferAsset(assetId, payable(receiver), amount);

        emit LiFiTransferCompleted(_lifiData.transactionId, assetId, receiver, amount, block.timestamp);
    }

    /**
     * @notice Performs a swap before completing a cross-chain transaction
     *         on the receiving chain using the NXTP protocol.
     * @param _lifiData data used purely for tracking and analytics
     * @param _swapData array of data needed for swaps
     * @param finalAssetId token received on the receiving chain
     * @param receiver address that will receive the tokens
     */
    function swapAndCompleteBridgeTokensViaNXTP(
        LiFiData memory _lifiData,
        LibSwap.SwapData[] calldata _swapData,
        address finalAssetId,
        address receiver
    ) public payable {
        uint256 startingBalance = LibAsset.getOwnBalance(finalAssetId);

        // Swap
        _executeSwaps(_lifiData, _swapData);

        uint256 postSwapBalance = LibAsset.getOwnBalance(finalAssetId);

        uint256 finalBalance;

        if (postSwapBalance > startingBalance) {
            finalBalance = postSwapBalance - startingBalance;
            LibAsset.transferAsset(finalAssetId, payable(receiver), finalBalance);
        }

        emit LiFiTransferCompleted(_lifiData.transactionId, finalAssetId, receiver, finalBalance, block.timestamp);
    }

    /* ========== Internal Functions ========== */

    function _startBridge(bytes32 _transactionId, ITransactionManager.PrepareArgs memory _nxtpData) internal {
        Storage storage s = getStorage();
        IERC20 sendingAssetId = IERC20(_nxtpData.invariantData.sendingAssetId);

        // Give Connext approval to bridge tokens
        LibAsset.approveERC20(IERC20(sendingAssetId), address(s.nxtpTxManager), _nxtpData.amount);

        uint256 value = LibAsset.isNativeAsset(address(sendingAssetId)) ? _nxtpData.amount : 0;

        // Initiate bridge transaction on sending chain
        ITransactionManager.TransactionData memory result = s.nxtpTxManager.prepare{ value: value }(_nxtpData);

        emit NXTPBridgeStarted(_transactionId, result.transactionId, result);
    }

    function getStorage() internal pure returns (Storage storage s) {
        bytes32 namespace = NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }

    /* ========== Getter Functions ========== */

    /**
     * @notice show the NXTP transaction manager contract address
     */
    function getNXTPTransactionManager() external view returns (address) {
        Storage storage s = getStorage();
        return address(s.nxtpTxManager);
    }
}",1721
RealWorld_BA_103_ITransactionManager_RealWord_20240827232612.log,103,ITransactionManager,30312,6042,36354,100.0,0.2724,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.7;

interface ITransactionManager {
    // Structs

    // Holds all data that is constant between sending and
    // receiving chains. The hash of this is what gets signed
    // to ensure the signature can be used on both chains.
    struct InvariantTransactionData {
        address receivingChainTxManagerAddress;
        address user;
        address router;
        address initiator; // msg.sender of sending side
        address sendingAssetId;
        address receivingAssetId;
        address sendingChainFallback; // funds sent here on cancel
        address receivingAddress;
        address callTo;
        uint256 sendingChainId;
        uint256 receivingChainId;
        bytes32 callDataHash; // hashed to prevent free option
        bytes32 transactionId;
    }

    // Holds all data that varies between sending and receiving
    // chains. The hash of this is stored onchain to ensure the
    // information passed in is valid.
    struct VariantTransactionData {
        uint256 amount;
        uint256 expiry;
        uint256 preparedBlockNumber;
    }

    // All Transaction data, constant and variable
    struct TransactionData {
        address receivingChainTxManagerAddress;
        address user;
        address router;
        address initiator; // msg.sender of sending side
        address sendingAssetId;
        address receivingAssetId;
        address sendingChainFallback;
        address receivingAddress;
        address callTo;
        bytes32 callDataHash;
        bytes32 transactionId;
        uint256 sendingChainId;
        uint256 receivingChainId;
        uint256 amount;
        uint256 expiry;
        uint256 preparedBlockNumber; // Needed for removal of active blocks on fulfill/cancel
    }

    // The structure of the signed data for fulfill
    struct SignedFulfillData {
        bytes32 transactionId;
        uint256 relayerFee;
        string functionIdentifier; // ""fulfill"" or ""cancel""
        uint256 receivingChainId; // For domain separation
        address receivingChainTxManagerAddress; // For domain separation
    }

    // The structure of the signed data for cancellation
    struct SignedCancelData {
        bytes32 transactionId;
        string functionIdentifier;
        uint256 receivingChainId;
        address receivingChainTxManagerAddress; // For domain separation
    }

    /**
     * Arguments for calling prepare()
     * @param invariantData The data for a crosschain transaction that will
     *                      not change between sending and receiving chains.
     *                      The hash of this data is used as the key to store
     *                      the inforamtion that does change between chains
     *                      (amount,expiry,preparedBlock) for verification
     * @param amount The amount of the transaction on this chain
     * @param expiry The block.timestamp when the transaction will no longer be
     *               fulfillable and is freely cancellable on this chain
     * @param encryptedCallData The calldata to be executed when the tx is
     *                          fulfilled. Used in the function to allow the user
     *                          to reconstruct the tx from events. Hash is stored
     *                          onchain to prevent shenanigans.
     * @param encodedBid The encoded bid that was accepted by the user for this
     *                   crosschain transfer. It is supplied as a param to the
     *                   function but is only used in event emission
     * @param bidSignature The signature of the bidder on the encoded bid for
     *                     this transaction. Only used within the function for
     *                     event emission. The validity of the bid and
     *                     bidSignature are enforced offchain
     * @param encodedMeta The meta for the function
     */
    struct PrepareArgs {
        InvariantTransactionData invariantData;
        uint256 amount;
        uint256 expiry;
        bytes encryptedCallData;
        bytes encodedBid;
        bytes bidSignature;
        bytes encodedMeta;
    }

    /**
     * @param txData All of the data (invariant and variant) for a crosschain
     *               transaction. The variant data provided is checked against
     *               what was stored when the `prepare` function was called.
     * @param relayerFee The fee that should go to the relayer when they are
     *                   calling the function on the receiving chain for the user
     * @param signature The users signature on the transaction id + fee that
     *                  can be used by the router to unlock the transaction on
     *                  the sending chain
     * @param callData The calldata to be sent to and executed by the
     *                 `FulfillHelper`
     * @param encodedMeta The meta for the function
     */
    struct FulfillArgs {
        TransactionData txData;
        uint256 relayerFee;
        bytes signature;
        bytes callData;
        bytes encodedMeta;
    }

    /**
     * Arguments for calling cancel()
     * @param txData All of the data (invariant and variant) for a crosschain
     *               transaction. The variant data provided is checked against
     *               what was stored when the `prepare` function was called.
     * @param signature The user's signature that allows a transaction to be
     *                  cancelled by a relayer
     * @param encodedMeta The meta for the function
     */
    struct CancelArgs {
        TransactionData txData;
        bytes signature;
        bytes encodedMeta;
    }

    // Adding/removing asset events
    event RouterAdded(address indexed addedRouter, address indexed caller);

    event RouterRemoved(address indexed removedRouter, address indexed caller);

    // Adding/removing router events
    event AssetAdded(address indexed addedAssetId, address indexed caller);

    event AssetRemoved(address indexed removedAssetId, address indexed caller);

    // Liquidity events
    event LiquidityAdded(address indexed router, address indexed assetId, uint256 amount, address caller);

    event LiquidityRemoved(address indexed router, address indexed assetId, uint256 amount, address recipient);

    // Transaction events
    event TransactionPrepared(
        address indexed user,
        address indexed router,
        bytes32 indexed transactionId,
        TransactionData txData,
        address caller,
        PrepareArgs args
    );

    event TransactionFulfilled(
        address indexed user,
        address indexed router,
        bytes32 indexed transactionId,
        FulfillArgs args,
        bool success,
        bool isContract,
        bytes returnData,
        address caller
    );

    event TransactionCancelled(
        address indexed user,
        address indexed router,
        bytes32 indexed transactionId,
        CancelArgs args,
        address caller
    );

    // Getters
    function getChainId() external view returns (uint256);

    function getStoredChainId() external view returns (uint256);

    // Owner only methods
    function addRouter(address router) external;

    function removeRouter(address router) external;

    function addAssetId(address assetId) external;

    function removeAssetId(address assetId) external;

    // Router only methods
    function addLiquidityFor(
        uint256 amount,
        address assetId,
        address router
    ) external payable;

    function addLiquidity(uint256 amount, address assetId) external payable;

    function removeLiquidity(
        uint256 amount,
        address assetId,
        address payable recipient
    ) external;

    // Methods for crosschain transfers
    // called in the following order (in happy case)
    // 1. prepare by user on sending chain
    // 2. prepare by router on receiving chain
    // 3. fulfill by user on receiving chain
    // 4. fulfill by router on sending chain
    function prepare(PrepareArgs calldata args) external payable returns (TransactionData memory);

    function fulfill(FulfillArgs calldata args) external returns (TransactionData memory);

    function cancel(CancelArgs calldata args) external returns (TransactionData memory);
}",1660
RealWorld_BA_103_IAnyswapToken_RealWord_20240828003204.log,103,IAnyswapToken,3569,4561,8130,69.0,0.109065,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IAnyswapToken {
    function underlying() external returns (address);
}",33
RealWorld_BA_103_IERC173_RealWord_20240827233212.log,103,IERC173,6048,4947,10995,84.0,0.12918,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

/// @title ERC-173 Contract Ownership Standard
///  Note: the ERC-165 identifier for this interface is 0x7f5828d0
/* is ERC165 */
interface IERC173 {
    /// @dev This emits when ownership of a contract changes.
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /// @notice Get the address of the owner
    /// @return owner_ The address of the owner.
    function owner() external view returns (address owner_);

    /// @notice Set the address of the new owner of the contract
    /// @dev Set _newOwner to address(0) to renounce any ownership.
    /// @param _newOwner The address of the new owner of the contract
    function transferOwnership(address _newOwner) external;
}",184
RealWorld_BA_103_IERC173_RealWord_20240828004334.log,103,IERC173,6049,5552,11601,82.0,0.141285,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

/// @title ERC-173 Contract Ownership Standard
///  Note: the ERC-165 identifier for this interface is 0x7f5828d0
/* is ERC165 */
interface IERC173 {
    /// @dev This emits when ownership of a contract changes.
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /// @notice Get the address of the owner
    /// @return owner_ The address of the owner.
    function owner() external view returns (address owner_);

    /// @notice Set the address of the new owner of the contract
    /// @dev Set _newOwner to address(0) to renounce any ownership.
    /// @param _newOwner The address of the new owner of the contract
    function transferOwnership(address _newOwner) external;
}",184
RealWorld_BA_103_IHopBridge_RealWord_20240828003958.log,103,IHopBridge,5371,5293,10664,81.0,0.132715,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IHopBridge {
    struct BridgeConfig {
        address token;
        address bridge;
        address ammWrapper;
    }

    function sendToL2(
        uint256 chainId,
        address recipient,
        uint256 amount,
        uint256 amountOutMin,
        uint256 deadline,
        address relayer,
        uint256 relayerFee
    ) external payable;

    function swapAndSend(
        uint256 chainId,
        address recipient,
        uint256 amount,
        uint256 bonderFee,
        uint256 amountOutMin,
        uint256 deadline,
        uint256 destinationAmountOutMin,
        uint256 destinationDeadline
    ) external payable;
}",153
RealWorld_BA_103_OwnershipFacet_RealWord_20240828000920.log,103,OwnershipFacet,4976,5614,10590,83.0,0.13716,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { LibDiamond } from ""../Libraries/LibDiamond.sol"";
import { IERC173 } from ""../Interfaces/IERC173.sol"";

contract OwnershipFacet is IERC173 {
    function transferOwnership(address _newOwner) external override {
        LibDiamond.enforceIsContractOwner();
        LibDiamond.setContractOwner(_newOwner);
    }

    function owner() external view override returns (address owner_) {
        owner_ = LibDiamond.contractOwner();
    }
}",112
RealWorld_BA_103_DiamondCutFacet_RealWord_20240828000757.log,103,DiamondCutFacet,6663,5346,12009,81.0,0.140235,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { IDiamondCut } from ""../Interfaces/IDiamondCut.sol"";
import { LibDiamond } from ""../Libraries/LibDiamond.sol"";

contract DiamondCutFacet is IDiamondCut {
    /// @notice Add/replace/remove any number of functions and optionally execute
    ///         a function with delegatecall
    /// @param _diamondCut Contains the facet addresses and function selectors
    /// @param _init The address of the contract or facet to execute _calldata
    /// @param _calldata A function call, including function selector and arguments
    ///                  _calldata is executed with delegatecall on _init
    function diamondCut(
        FacetCut[] calldata _diamondCut,
        address _init,
        bytes calldata _calldata
    ) external override {
        LibDiamond.enforceIsContractOwner();
        LibDiamond.diamondCut(_diamondCut, _init, _calldata);
    }
}",209
RealWorld_BA_103_LibStorage_RealWord_20240828002302.log,103,LibStorage,3586,4521,8107,80.0,0.10835,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

struct LibStorage {
    mapping(address => bool) dexWhitelist;
    address[] dexs;
}",37
RealWorld_BA_103_LibSwap_RealWord_20240828003024.log,103,LibSwap,10389,5071,15460,97.0,0.153365,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { LibAsset, IERC20 } from ""./LibAsset.sol"";
import { LibUtil } from ""./LibUtil.sol"";

library LibSwap {
    uint256 private constant MAX_INT = 2**256 - 1;

    struct SwapData {
        address callTo;
        address approveTo;
        address sendingAssetId;
        address receivingAssetId;
        uint256 fromAmount;
        bytes callData;
    }

    event AssetSwapped(
        bytes32 transactionId,
        address dex,
        address fromAssetId,
        address toAssetId,
        uint256 fromAmount,
        uint256 toAmount,
        uint256 timestamp
    );

    function swap(bytes32 transactionId, SwapData calldata _swapData) internal {
        uint256 fromAmount = _swapData.fromAmount;
        uint256 toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId);
        address fromAssetId = _swapData.sendingAssetId;
        if (!LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {
            LibAsset.transferFromERC20(fromAssetId, msg.sender, address(this), fromAmount);
        }

        if (!LibAsset.isNativeAsset(fromAssetId)) {
            LibAsset.approveERC20(IERC20(fromAssetId), _swapData.approveTo, fromAmount);
        }

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData);
        if (!success) {
            string memory reason = LibUtil.getRevertMsg(res);
            revert(reason);
        }

        toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount;
        emit AssetSwapped(
            transactionId,
            _swapData.callTo,
            _swapData.sendingAssetId,
            _swapData.receivingAssetId,
            fromAmount,
            toAmount,
            block.timestamp
        );
    }
}",439
RealWorld_BA_103_IAnyswapToken_RealWord_20240827231855.log,103,IAnyswapToken,3518,4169,7687,88.0,0.10097,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IAnyswapToken {
    function underlying() external returns (address);
}",33
RealWorld_BA_103_WithdrawFacet_RealWord_20240827230502.log,103,WithdrawFacet,9188,5672,14860,98.0,0.15938,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { LibDiamond } from ""../Libraries/LibDiamond.sol"";

contract WithdrawFacet {
    using SafeERC20 for IERC20;
    address private constant NATIVE_ASSET = address(0);

    event LogWithdraw(address indexed _assetAddress, address _from, uint256 amount);

    /**
     * @dev Withdraw asset.
     * @param _assetAddress Asset to be withdrawn.
     * @param _to address to withdraw to.
     * @param _amount amount of asset to withdraw.
     */
    function withdraw(
        address _assetAddress,
        address _to,
        uint256 _amount
    ) public {
        LibDiamond.enforceIsContractOwner();
        address sendTo = (_to == address(0)) ? msg.sender : _to;
        uint256 assetBalance;
        if (_assetAddress == NATIVE_ASSET) {
            address self = address(this); // workaround for a possible solidity bug
            assert(_amount <= self.balance);
            payable(sendTo).transfer(_amount);
        } else {
            assetBalance = IERC20(_assetAddress).balanceOf(address(this));
            assert(_amount <= assetBalance);
            IERC20(_assetAddress).safeTransfer(sendTo, _amount);
        }
        emit LogWithdraw(sendTo, _assetAddress, _amount);
    }
}",335
RealWorld_BA_103_LibSwap_RealWord_20240827231723.log,103,LibSwap,10464,5390,15854,89.0,0.16012,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { LibAsset, IERC20 } from ""./LibAsset.sol"";
import { LibUtil } from ""./LibUtil.sol"";

library LibSwap {
    uint256 private constant MAX_INT = 2**256 - 1;

    struct SwapData {
        address callTo;
        address approveTo;
        address sendingAssetId;
        address receivingAssetId;
        uint256 fromAmount;
        bytes callData;
    }

    event AssetSwapped(
        bytes32 transactionId,
        address dex,
        address fromAssetId,
        address toAssetId,
        uint256 fromAmount,
        uint256 toAmount,
        uint256 timestamp
    );

    function swap(bytes32 transactionId, SwapData calldata _swapData) internal {
        uint256 fromAmount = _swapData.fromAmount;
        uint256 toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId);
        address fromAssetId = _swapData.sendingAssetId;
        if (!LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {
            LibAsset.transferFromERC20(fromAssetId, msg.sender, address(this), fromAmount);
        }

        if (!LibAsset.isNativeAsset(fromAssetId)) {
            LibAsset.approveERC20(IERC20(fromAssetId), _swapData.approveTo, fromAmount);
        }

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData);
        if (!success) {
            string memory reason = LibUtil.getRevertMsg(res);
            revert(reason);
        }

        toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount;
        emit AssetSwapped(
            transactionId,
            _swapData.callTo,
            _swapData.sendingAssetId,
            _swapData.receivingAssetId,
            fromAmount,
            toAmount,
            block.timestamp
        );
    }
}",439
RealWorld_BA_103_LibDiamond_RealWord_20240827231123.log,103,LibDiamond,37817,5155,42972,80.0,0.292185,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { IDiamondCut } from ""../Interfaces/IDiamondCut.sol"";

library LibDiamond {
    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(""diamond.standard.diamond.storage"");

    struct FacetAddressAndPosition {
        address facetAddress;
        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array
    }

    struct FacetFunctionSelectors {
        bytes4[] functionSelectors;
        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array
    }

    struct DiamondStorage {
        // maps function selector to the facet address and
        // the position of the selector in the facetFunctionSelectors.selectors array
        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;
        // maps facet addresses to function selectors
        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;
        // facet addresses
        address[] facetAddresses;
        // Used to query if a contract implements an interface.
        // Used to implement ERC-165.
        mapping(bytes4 => bool) supportedInterfaces;
        // owner of the contract
        address contractOwner;
    }

    function diamondStorage() internal pure returns (DiamondStorage storage ds) {
        bytes32 position = DIAMOND_STORAGE_POSITION;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            ds.slot := position
        }
    }

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function setContractOwner(address _newOwner) internal {
        DiamondStorage storage ds = diamondStorage();
        address previousOwner = ds.contractOwner;
        ds.contractOwner = _newOwner;
        emit OwnershipTransferred(previousOwner, _newOwner);
    }

    function contractOwner() internal view returns (address contractOwner_) {
        contractOwner_ = diamondStorage().contractOwner;
    }

    function enforceIsContractOwner() internal view {
        require(msg.sender == diamondStorage().contractOwner, ""LibDiamond: Must be contract owner"");
    }

    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);

    // Internal function version of diamondCut
    function diamondCut(
        IDiamondCut.FacetCut[] memory _diamondCut,
        address _init,
        bytes memory _calldata
    ) internal {
        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {
            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;
            if (action == IDiamondCut.FacetCutAction.Add) {
                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);
            } else if (action == IDiamondCut.FacetCutAction.Replace) {
                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);
            } else if (action == IDiamondCut.FacetCutAction.Remove) {
                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);
            } else {
                revert(""LibDiamondCut: Incorrect FacetCutAction"");
            }
        }
        emit DiamondCut(_diamondCut, _init, _calldata);
        initializeDiamondCut(_init, _calldata);
    }

    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
        require(_functionSelectors.length > 0, ""LibDiamondCut: No selectors in facet to cut"");
        DiamondStorage storage ds = diamondStorage();
        require(_facetAddress != address(0), ""LibDiamondCut: Add facet can't be address(0)"");
        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);
        // add new facet address if it does not exist
        if (selectorPosition == 0) {
            addFacet(ds, _facetAddress);
        }
        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {
            bytes4 selector = _functionSelectors[selectorIndex];
            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;
            require(oldFacetAddress == address(0), ""LibDiamondCut: Can't add function that already exists"");
            addFunction(ds, selector, selectorPosition, _facetAddress);
            selectorPosition++;
        }
    }

    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
        require(_functionSelectors.length > 0, ""LibDiamondCut: No selectors in facet to cut"");
        DiamondStorage storage ds = diamondStorage();
        require(_facetAddress != address(0), ""LibDiamondCut: Add facet can't be address(0)"");
        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);
        // add new facet address if it does not exist
        if (selectorPosition == 0) {
            addFacet(ds, _facetAddress);
        }
        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {
            bytes4 selector = _functionSelectors[selectorIndex];
            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;
            require(oldFacetAddress != _facetAddress, ""LibDiamondCut: Can't replace function with same function"");
            removeFunction(ds, oldFacetAddress, selector);
            addFunction(ds, selector, selectorPosition, _facetAddress);
            selectorPosition++;
        }
    }

    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
        require(_functionSelectors.length > 0, ""LibDiamondCut: No selectors in facet to cut"");
        DiamondStorage storage ds = diamondStorage();
        // if function does not exist then do nothing and return
        require(_facetAddress == address(0), ""LibDiamondCut: Remove facet address must be address(0)"");
        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {
            bytes4 selector = _functionSelectors[selectorIndex];
            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;
            removeFunction(ds, oldFacetAddress, selector);
        }
    }

    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {
        enforceHasContractCode(_facetAddress, ""LibDiamondCut: New facet has no code"");
        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;
        ds.facetAddresses.push(_facetAddress);
    }

    function addFunction(
        DiamondStorage storage ds,
        bytes4 _selector,
        uint96 _selectorPosition,
        address _facetAddress
    ) internal {
        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;
        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);
        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;
    }

    function removeFunction(
        DiamondStorage storage ds,
        address _facetAddress,
        bytes4 _selector
    ) internal {
        require(_facetAddress != address(0), ""LibDiamondCut: Can't remove function that doesn't exist"");
        // an immutable function is a function defined directly in a diamond
        require(_facetAddress != address(this), ""LibDiamondCut: Can't remove immutable function"");
        // replace selector with last selector, then delete last selector
        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;
        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;
        // if not the same then replace _selector with lastSelector
        if (selectorPosition != lastSelectorPosition) {
            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];
            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;
            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);
        }
        // delete the last selector
        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();
        delete ds.selectorToFacetAndPosition[_selector];

        // if no more selectors for facet address then delete the facet address
        if (lastSelectorPosition == 0) {
            // replace facet address with last facet address and delete last facet address
            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;
            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;
            if (facetAddressPosition != lastFacetAddressPosition) {
                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];
                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;
                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;
            }
            ds.facetAddresses.pop();
            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;
        }
    }

    function initializeDiamondCut(address _init, bytes memory _calldata) internal {
        if (_init == address(0)) {
            require(_calldata.length == 0, ""LibDiamondCut: _init is address(0) but_calldata is not empty"");
        } else {
            require(_calldata.length > 0, ""LibDiamondCut: _calldata is empty but _init is not address(0)"");
            if (_init != address(this)) {
                enforceHasContractCode(_init, ""LibDiamondCut: _init address has no code"");
            }
            // solhint-disable-next-line avoid-low-level-calls
            (bool success, bytes memory error) = _init.delegatecall(_calldata);
            if (!success) {
                if (error.length > 0) {
                    // bubble up the error
                    revert(string(error));
                } else {
                    revert(""LibDiamondCut: _init function reverted"");
                }
            }
        }
    }

    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {
        uint256 contractSize;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            contractSize := extcodesize(_contract)
        }
        require(contractSize > 0, _errorMessage);
    }
}",2168
RealWorld_BA_103_Swapper_RealWord_20240828002014.log,103,Swapper,5981,4165,10146,71.0,0.113205,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { ILiFi } from ""../Interfaces/ILiFi.sol"";
import { LibSwap } from ""../Libraries/LibSwap.sol"";
import { LibStorage } from ""../Libraries/LibStorage.sol"";

contract Swapper is ILiFi {
    /* ========== Storage ========== */
    LibStorage internal ls;

    function _executeSwaps(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) internal {
        // Swap
        for (uint8 i; i < _swapData.length; i++) {
            require(
                ls.dexWhitelist[_swapData[i].approveTo] == true && ls.dexWhitelist[_swapData[i].callTo] == true,
                ""Contract call not allowed!""
            );

            LibSwap.swap(_lifiData.transactionId, _swapData[i]);
        }
    }
}",194
RealWorld_BA_103_OwnershipFacet_RealWord_20240827225525.log,103,OwnershipFacet,4759,4514,9273,69.0,0.114075,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { LibDiamond } from ""../Libraries/LibDiamond.sol"";
import { IERC173 } from ""../Interfaces/IERC173.sol"";

contract OwnershipFacet is IERC173 {
    function transferOwnership(address _newOwner) external override {
        LibDiamond.enforceIsContractOwner();
        LibDiamond.setContractOwner(_newOwner);
    }

    function owner() external view override returns (address owner_) {
        owner_ = LibDiamond.contractOwner();
    }
}",112
RealWorld_BA_103_DiamondLoupeFacet_RealWord_20240827230317.log,103,DiamondLoupeFacet,12860,5511,18371,103.0,0.17452,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { LibDiamond } from ""../Libraries/LibDiamond.sol"";
import { IDiamondLoupe } from ""../Interfaces/IDiamondLoupe.sol"";
import { IERC165 } from ""../Interfaces/IERC165.sol"";

contract DiamondLoupeFacet is IDiamondLoupe, IERC165 {
    // Diamond Loupe Functions
    ////////////////////////////////////////////////////////////////////
    /// These functions are expected to be called frequently by tools.
    //
    // struct Facet {
    //     address facetAddress;
    //     bytes4[] functionSelectors;
    // }

    /// @notice Gets all facets and their selectors.
    /// @return facets_ Facet
    function facets() external view override returns (Facet[] memory facets_) {
        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
        uint256 numFacets = ds.facetAddresses.length;
        facets_ = new Facet[](numFacets);
        for (uint256 i; i < numFacets; i++) {
            address facetAddress_ = ds.facetAddresses[i];
            facets_[i].facetAddress = facetAddress_;
            facets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress_].functionSelectors;
        }
    }

    /// @notice Gets all the function selectors provided by a facet.
    /// @param _facet The facet address.
    /// @return facetFunctionSelectors_
    function facetFunctionSelectors(address _facet)
        external
        view
        override
        returns (bytes4[] memory facetFunctionSelectors_)
    {
        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
        facetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;
    }

    /// @notice Get all the facet addresses used by a diamond.
    /// @return facetAddresses_
    function facetAddresses() external view override returns (address[] memory facetAddresses_) {
        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
        facetAddresses_ = ds.facetAddresses;
    }

    /// @notice Gets the facet that supports the given selector.
    /// @dev If facet is not found return address(0).
    /// @param _functionSelector The function selector.
    /// @return facetAddress_ The facet address.
    function facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {
        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
        facetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;
    }

    // This implements ERC-165.
    function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {
        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
        return ds.supportedInterfaces[_interfaceId];
    }
}",590
RealWorld_BA_103_IERC165_RealWord_20240828004236.log,103,IERC165,5094,3065,8159,56.0,0.08677,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IERC165 {
    /// @notice Query if a contract implements an interface
    /// @param interfaceId The interface identifier, as specified in ERC-165
    /// @dev Interface identification is specified in ERC-165. This function
    ///  uses less than 30,000 gas.
    /// @return `true` if the contract implements `interfaceID` and
    ///  `interfaceID` is not 0xffffffff, `false` otherwise
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}",129
RealWorld_BA_103_IDiamondCut_RealWord_20240828003555.log,103,IDiamondCut,6549,4663,11212,76.0,0.126005,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IDiamondCut {
    enum FacetCutAction {
        Add,
        Replace,
        Remove
    }
    // Add=0, Replace=1, Remove=2

    struct FacetCut {
        address facetAddress;
        FacetCutAction action;
        bytes4[] functionSelectors;
    }

    /// @notice Add/replace/remove any number of functions and optionally execute
    ///         a function with delegatecall
    /// @param _diamondCut Contains the facet addresses and function selectors
    /// @param _init The address of the contract or facet to execute _calldata
    /// @param _calldata A function call, including function selector and arguments
    ///                  _calldata is executed with delegatecall on _init
    function diamondCut(
        FacetCut[] calldata _diamondCut,
        address _init,
        bytes calldata _calldata
    ) external;

    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);
}",226
RealWorld_BA_103_NXTPFacet_RealWord_20240827225636.log,103,NXTPFacet,31233,5578,36811,99.0,0.267725,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { ITransactionManager } from ""../Interfaces/ITransactionManager.sol"";
import { ILiFi } from ""../Interfaces/ILiFi.sol"";
import { LibAsset, IERC20 } from ""../Libraries/LibAsset.sol"";
import { LibDiamond } from ""../Libraries/LibDiamond.sol"";
import ""./Swapper.sol"";

/**
 * @title NXTP (Connext) Facet
 * @author Li.Finance (https://li.finance)
 * @notice Provides functionality for bridging through NXTP (Connext)
 */
contract NXTPFacet is ILiFi, Swapper {
    /* ========== Storage ========== */

    bytes32 internal constant NAMESPACE = keccak256(""com.lifi.facets.nxtp"");
    struct Storage {
        ITransactionManager nxtpTxManager;
    }

    /* ========== Events ========== */

    event NXTPBridgeStarted(
        bytes32 indexed lifiTransactionId,
        bytes32 nxtpTransactionId,
        ITransactionManager.TransactionData txData
    );

    /* ========== Init ========== */

    function initNXTP(ITransactionManager _txMgrAddr) external {
        Storage storage s = getStorage();
        LibDiamond.enforceIsContractOwner();
        s.nxtpTxManager = _txMgrAddr;
    }

    /* ========== Public Bridge Functions ========== */

    /**
     * @notice This function starts a cross-chain transaction using the NXTP protocol
     * @param _lifiData data used purely for tracking and analytics
     * @param _nxtpData data needed to complete an NXTP cross-chain transaction
     */
    function startBridgeTokensViaNXTP(LiFiData memory _lifiData, ITransactionManager.PrepareArgs memory _nxtpData)
        public
        payable
    {
        // Ensure sender has enough to complete the bridge transaction
        address sendingAssetId = _nxtpData.invariantData.sendingAssetId;
        if (sendingAssetId == address(0)) require(msg.value == _nxtpData.amount, ""ERR_INVALID_AMOUNT"");
        else {
            uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);
            LibAsset.transferFromERC20(sendingAssetId, msg.sender, address(this), _nxtpData.amount);
            require(
                LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance == _nxtpData.amount,
                ""ERR_INVALID_AMOUNT""
            );
        }

        // Start the bridge process
        _startBridge(_lifiData.transactionId, _nxtpData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /**
     * @notice This function performs a swap or multiple swaps and then starts a cross-chain transaction
     *         using the NXTP protocol.
     * @param _lifiData data used purely for tracking and analytics
     * @param _swapData array of data needed for swaps
     * @param _nxtpData data needed to complete an NXTP cross-chain transaction
     */
    function swapAndStartBridgeTokensViaNXTP(
        LiFiData memory _lifiData,
        LibSwap.SwapData[] calldata _swapData,
        ITransactionManager.PrepareArgs memory _nxtpData
    ) public payable {
        address sendingAssetId = _nxtpData.invariantData.sendingAssetId;
        uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);

        // Swap
        _executeSwaps(_lifiData, _swapData);

        uint256 _postSwapBalance = LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance;

        require(_postSwapBalance > 0, ""ERR_INVALID_AMOUNT"");

        _nxtpData.amount = _postSwapBalance;

        _startBridge(_lifiData.transactionId, _nxtpData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /**
     * @notice Completes a cross-chain transaction on the receiving chain using the NXTP protocol.
     * @param _lifiData data used purely for tracking and analytics
     * @param assetId token received on the receiving chain
     * @param receiver address that will receive the tokens
     * @param amount number of tokens received
     */
    function completeBridgeTokensViaNXTP(
        LiFiData memory _lifiData,
        address assetId,
        address receiver,
        uint256 amount
    ) public payable {
        if (LibAsset.isNativeAsset(assetId)) {
            require(msg.value == amount, ""INVALID_ETH_AMOUNT"");
        } else {
            require(msg.value == 0, ""ETH_WITH_ERC"");
            LibAsset.transferFromERC20(assetId, msg.sender, address(this), amount);
        }

        LibAsset.transferAsset(assetId, payable(receiver), amount);

        emit LiFiTransferCompleted(_lifiData.transactionId, assetId, receiver, amount, block.timestamp);
    }

    /**
     * @notice Performs a swap before completing a cross-chain transaction
     *         on the receiving chain using the NXTP protocol.
     * @param _lifiData data used purely for tracking and analytics
     * @param _swapData array of data needed for swaps
     * @param finalAssetId token received on the receiving chain
     * @param receiver address that will receive the tokens
     */
    function swapAndCompleteBridgeTokensViaNXTP(
        LiFiData memory _lifiData,
        LibSwap.SwapData[] calldata _swapData,
        address finalAssetId,
        address receiver
    ) public payable {
        uint256 startingBalance = LibAsset.getOwnBalance(finalAssetId);

        // Swap
        _executeSwaps(_lifiData, _swapData);

        uint256 postSwapBalance = LibAsset.getOwnBalance(finalAssetId);

        uint256 finalBalance;

        if (postSwapBalance > startingBalance) {
            finalBalance = postSwapBalance - startingBalance;
            LibAsset.transferAsset(finalAssetId, payable(receiver), finalBalance);
        }

        emit LiFiTransferCompleted(_lifiData.transactionId, finalAssetId, receiver, finalBalance, block.timestamp);
    }

    /* ========== Internal Functions ========== */

    function _startBridge(bytes32 _transactionId, ITransactionManager.PrepareArgs memory _nxtpData) internal {
        Storage storage s = getStorage();
        IERC20 sendingAssetId = IERC20(_nxtpData.invariantData.sendingAssetId);

        // Give Connext approval to bridge tokens
        LibAsset.approveERC20(IERC20(sendingAssetId), address(s.nxtpTxManager), _nxtpData.amount);

        uint256 value = LibAsset.isNativeAsset(address(sendingAssetId)) ? _nxtpData.amount : 0;

        // Initiate bridge transaction on sending chain
        ITransactionManager.TransactionData memory result = s.nxtpTxManager.prepare{ value: value }(_nxtpData);

        emit NXTPBridgeStarted(_transactionId, result.transactionId, result);
    }

    function getStorage() internal pure returns (Storage storage s) {
        bytes32 namespace = NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }

    /* ========== Getter Functions ========== */

    /**
     * @notice show the NXTP transaction manager contract address
     */
    function getNXTPTransactionManager() external view returns (address) {
        Storage storage s = getStorage();
        return address(s.nxtpTxManager);
    }
}",1721
RealWorld_BA_103_AnyswapFacet_RealWord_20240827230833.log,103,AnyswapFacet,26798,5918,32716,91.0,0.25235,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import { ILiFi } from ""../Interfaces/ILiFi.sol"";
import { IAnyswapRouter } from ""../Interfaces/IAnyswapRouter.sol"";
import { LibDiamond } from ""../Libraries/LibDiamond.sol"";
import { LibAsset, IERC20 } from ""../Libraries/LibAsset.sol"";
import { IAnyswapToken } from ""../Interfaces/IAnyswapToken.sol"";
import { LibDiamond } from ""../Libraries/LibDiamond.sol"";
import ""./Swapper.sol"";

/**
 * @title Anyswap Facet
 * @author Li.Finance (https://li.finance)
 * @notice Provides functionality for bridging through Multichain (Prev. AnySwap)
 */
contract AnyswapFacet is ILiFi, Swapper {
    /* ========== Types ========== */

    struct AnyswapData {
        address token;
        address router;
        uint256 amount;
        address recipient;
        uint256 toChainId;
    }

    /* ========== Public Bridge Functions ========== */

    /**
     * @notice Bridges tokens via Anyswap
     * @param _lifiData data used purely for tracking and analytics
     * @param _anyswapData data specific to Anyswap
     */
    function startBridgeTokensViaAnyswap(LiFiData memory _lifiData, AnyswapData calldata _anyswapData) public payable {
        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();
        if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {
            if (underlyingToken == address(0)) {
                underlyingToken = _anyswapData.token;
            }

            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);
            LibAsset.transferFromERC20(underlyingToken, msg.sender, address(this), _anyswapData.amount);

            require(
                LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount,
                ""ERR_INVALID_AMOUNT""
            );
        } else {
            require(msg.value == _anyswapData.amount, ""ERR_INVALID_AMOUNT"");
        }

        _startBridge(_anyswapData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /**
     * @notice Performs a swap before bridging via Anyswap
     * @param _lifiData data used purely for tracking and analytics
     * @param _swapData an array of swap related data for performing swaps before bridging
     * @param _anyswapData data specific to Anyswap
     */
    function swapAndStartBridgeTokensViaAnyswap(
        LiFiData memory _lifiData,
        LibSwap.SwapData[] calldata _swapData,
        AnyswapData memory _anyswapData
    ) public payable {
        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();
        if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {
            if (underlyingToken == address(0)) {
                underlyingToken = _anyswapData.token;
            }

            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);

            // Swap
            _executeSwaps(_lifiData, _swapData);

            uint256 _postSwapBalance = LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance;

            require(_postSwapBalance > 0, ""ERR_INVALID_AMOUNT"");

            _anyswapData.amount = _postSwapBalance;
        } else {
            uint256 _fromBalance = address(this).balance;

            // Swap
            _executeSwaps(_lifiData, _swapData);

            require(address(this).balance - _fromBalance >= _anyswapData.amount, ""ERR_INVALID_AMOUNT"");

            uint256 _postSwapBalance = address(this).balance - _fromBalance;

            require(_postSwapBalance > 0, ""ERR_INVALID_AMOUNT"");

            _anyswapData.amount = _postSwapBalance;
        }

        _startBridge(_anyswapData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }

    /* ========== Internal Functions ========== */

    /**
     * @dev Conatains the business logic for the bridge via Anyswap
     * @param _anyswapData data specific to Anyswap
     */
    function _startBridge(AnyswapData memory _anyswapData) internal {
        // Check chain id
        require(block.chainid != _anyswapData.toChainId, ""Cannot bridge to the same network."");
        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();

        if (underlyingToken == IAnyswapRouter(_anyswapData.router).wNATIVE()) {
            IAnyswapRouter(_anyswapData.router).anySwapOutNative{ value: _anyswapData.amount }(
                _anyswapData.token,
                _anyswapData.recipient,
                _anyswapData.toChainId
            );
            return;
        }

        if (_anyswapData.token != address(0)) {
            // Has underlying token?
            if (underlyingToken != address(0)) {
                // Give Anyswap approval to bridge tokens
                LibAsset.approveERC20(IERC20(underlyingToken), _anyswapData.router, _anyswapData.amount);

                IAnyswapRouter(_anyswapData.router).anySwapOutUnderlying(
                    _anyswapData.token,
                    _anyswapData.recipient,
                    _anyswapData.amount,
                    _anyswapData.toChainId
                );
            } else {
                // Give Anyswap approval to bridge tokens
                LibAsset.approveERC20(IERC20(_anyswapData.token), _anyswapData.router, _anyswapData.amount);

                IAnyswapRouter(_anyswapData.router).anySwapOut(
                    _anyswapData.token,
                    _anyswapData.recipient,
                    _anyswapData.amount,
                    _anyswapData.toChainId
                );
            }
        }
    }
}",1495
RealWorld_BA_103_IDiamondLoupe_RealWord_20240828004121.log,103,IDiamondLoupe,8019,4533,12552,73.0,0.130755,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

// A loupe is a small magnifying glass used to look at diamonds.
// These functions look at diamonds
interface IDiamondLoupe {
    /// These functions are expected to be called frequently
    /// by tools.

    struct Facet {
        address facetAddress;
        bytes4[] functionSelectors;
    }

    /// @notice Gets all facet addresses and their four byte function selectors.
    /// @return facets_ Facet
    function facets() external view returns (Facet[] memory facets_);

    /// @notice Gets all the function selectors supported by a specific facet.
    /// @param _facet The facet address.
    /// @return facetFunctionSelectors_
    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);

    /// @notice Get all the facet addresses used by a diamond.
    /// @return facetAddresses_
    function facetAddresses() external view returns (address[] memory facetAddresses_);

    /// @notice Gets the facet that supports the given selector.
    /// @dev If facet is not found return address(0).
    /// @param _functionSelector The function selector.
    /// @return facetAddress_ The facet address.
    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);
}",276
RealWorld_BA_103_LibBytes_RealWord_20240828002841.log,103,LibBytes,69290,5829,75119,101.0,0.46303,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

library LibBytes {
    // solhint-disable no-inline-assembly

    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {
        bytes memory tempBytes;

        assembly {
            // Get a location of some free memory and store it in tempBytes as
            // Solidity does for memory variables.
            tempBytes := mload(0x40)

            // Store the length of the first bytes array at the beginning of
            // the memory for tempBytes.
            let length := mload(_preBytes)
            mstore(tempBytes, length)

            // Maintain a memory counter for the current write location in the
            // temp bytes array by adding the 32 bytes for the array length to
            // the starting location.
            let mc := add(tempBytes, 0x20)
            // Stop copying when the memory counter reaches the length of the
            // first bytes array.
            let end := add(mc, length)

            for {
                // Initialize a copy counter to the start of the _preBytes data,
                // 32 bytes into its memory.
                let cc := add(_preBytes, 0x20)
            } lt(mc, end) {
                // Increase both counters by 32 bytes each iteration.
                mc := add(mc, 0x20)
                cc := add(cc, 0x20)
            } {
                // Write the _preBytes data into the tempBytes memory 32 bytes
                // at a time.
                mstore(mc, mload(cc))
            }

            // Add the length of _postBytes to the current length of tempBytes
            // and store it as the new length in the first 32 bytes of the
            // tempBytes memory.
            length := mload(_postBytes)
            mstore(tempBytes, add(length, mload(tempBytes)))

            // Move the memory counter back from a multiple of 0x20 to the
            // actual end of the _preBytes data.
            mc := end
            // Stop copying when the memory counter reaches the new combined
            // length of the arrays.
            end := add(mc, length)

            for {
                let cc := add(_postBytes, 0x20)
            } lt(mc, end) {
                mc := add(mc, 0x20)
                cc := add(cc, 0x20)
            } {
                mstore(mc, mload(cc))
            }

            // Update the free-memory pointer by padding our last write location
            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the
            // next 32 byte block, then round down to the nearest multiple of
            // 32. If the sum of the length of the two arrays is zero then add
            // one before rounding down to leave a blank 32 bytes (the length block with 0).
            mstore(
                0x40,
                and(
                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),
                    not(31) // Round down to the nearest 32 bytes.
                )
            )
        }

        return tempBytes;
    }

    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {
        assembly {
            // Read the first 32 bytes of _preBytes storage, which is the length
            // of the array. (We don't need to use the offset into the slot
            // because arrays use the entire slot.)
            let fslot := sload(_preBytes.slot)
            // Arrays of 31 bytes or less have an even value in their slot,
            // while longer arrays have an odd value. The actual length is
            // the slot divided by two for odd values, and the lowest order
            // byte divided by two for even values.
            // If the slot is even, bitwise and the slot with 255 and divide by
            // two to get the length. If the slot is odd, bitwise and the slot
            // with -1 and divide by two.
            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)
            let mlength := mload(_postBytes)
            let newlength := add(slength, mlength)
            // slength can contain both the length and contents of the array
            // if length < 32 bytes so let's prepare for that
            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage
            switch add(lt(slength, 32), lt(newlength, 32))
            case 2 {
                // Since the new array still fits in the slot, we just need to
                // update the contents of the slot.
                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length
                sstore(
                    _preBytes.slot,
                    // all the modifications to the slot are inside this
                    // next block
                    add(
                        // we can just add to the slot contents because the
                        // bytes we want to change are the LSBs
                        fslot,
                        add(
                            mul(
                                div(
                                    // load the bytes from memory
                                    mload(add(_postBytes, 0x20)),
                                    // zero all bytes to the right
                                    exp(0x100, sub(32, mlength))
                                ),
                                // and now shift left the number of bytes to
                                // leave space for the length in the slot
                                exp(0x100, sub(32, newlength))
                            ),
                            // increase length by the double of the memory
                            // bytes length
                            mul(mlength, 2)
                        )
                    )
                )
            }
            case 1 {
                // The stored value fits in the slot, but the combined value
                // will exceed it.
                // get the keccak hash to get the contents of the array
                mstore(0x0, _preBytes.slot)
                let sc := add(keccak256(0x0, 0x20), div(slength, 32))

                // save new length
                sstore(_preBytes.slot, add(mul(newlength, 2), 1))

                // The contents of the _postBytes array start 32 bytes into
                // the structure. Our first read should obtain the `submod`
                // bytes that can fit into the unused space in the last word
                // of the stored array. To get this, we read 32 bytes starting
                // from `submod`, so the data we read overlaps with the array
                // contents by `submod` bytes. Masking the lowest-order
                // `submod` bytes allows us to add that value directly to the
                // stored value.

                let submod := sub(32, slength)
                let mc := add(_postBytes, submod)
                let end := add(_postBytes, mlength)
                let mask := sub(exp(0x100, submod), 1)

                sstore(
                    sc,
                    add(
                        and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00),
                        and(mload(mc), mask)
                    )
                )

                for {
                    mc := add(mc, 0x20)
                    sc := add(sc, 1)
                } lt(mc, end) {
                    sc := add(sc, 1)
                    mc := add(mc, 0x20)
                } {
                    sstore(sc, mload(mc))
                }

                mask := exp(0x100, sub(mc, end))

                sstore(sc, mul(div(mload(mc), mask), mask))
            }
            default {
                // get the keccak hash to get the contents of the array
                mstore(0x0, _preBytes.slot)
                // Start copying to the last used word of the stored array.
                let sc := add(keccak256(0x0, 0x20), div(slength, 32))

                // save new length
                sstore(_preBytes.slot, add(mul(newlength, 2), 1))

                // Copy over the first `submod` bytes of the new data as in
                // case 1 above.
                let slengthmod := mod(slength, 32)
                let submod := sub(32, slengthmod)
                let mc := add(_postBytes, submod)
                let end := add(_postBytes, mlength)
                let mask := sub(exp(0x100, submod), 1)

                sstore(sc, add(sload(sc), and(mload(mc), mask)))

                for {
                    sc := add(sc, 1)
                    mc := add(mc, 0x20)
                } lt(mc, end) {
                    sc := add(sc, 1)
                    mc := add(mc, 0x20)
                } {
                    sstore(sc, mload(mc))
                }

                mask := exp(0x100, sub(mc, end))

                sstore(sc, mul(div(mload(mc), mask), mask))
            }
        }
    }

    function slice(
        bytes memory _bytes,
        uint256 _start,
        uint256 _length
    ) internal pure returns (bytes memory) {
        require(_length + 31 >= _length, ""slice_overflow"");
        require(_bytes.length >= _start + _length, ""slice_outOfBounds"");

        bytes memory tempBytes;

        assembly {
            switch iszero(_length)
            case 0 {
                // Get a location of some free memory and store it in tempBytes as
                // Solidity does for memory variables.
                tempBytes := mload(0x40)

                // The first word of the slice result is potentially a partial
                // word read from the original array. To read it, we calculate
                // the length of that partial word and start copying that many
                // bytes into the array. The first word we copy will start with
                // data we don't care about, but the last `lengthmod` bytes will
                // land at the beginning of the contents of the new array. When
                // we're done copying, we overwrite the full first word with
                // the actual length of the slice.
                let lengthmod := and(_length, 31)

                // The multiplication in the next line is necessary
                // because when slicing multiples of 32 bytes (lengthmod == 0)
                // the following copy loop was copying the origin's length
                // and then ending prematurely not copying everything it should.
                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))
                let end := add(mc, _length)

                for {
                    // The multiplication in the next line has the same exact purpose
                    // as the one above.
                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)
                } lt(mc, end) {
                    mc := add(mc, 0x20)
                    cc := add(cc, 0x20)
                } {
                    mstore(mc, mload(cc))
                }

                mstore(tempBytes, _length)

                //update free-memory pointer
                //allocating the array padded to 32 bytes like the compiler does now
                mstore(0x40, and(add(mc, 31), not(31)))
            }
            //if we want a zero-length slice let's just return a zero-length array
            default {
                tempBytes := mload(0x40)
                //zero out the 32 bytes slice we are about to return
                //we need to do it because Solidity does not garbage collect
                mstore(tempBytes, 0)

                mstore(0x40, add(tempBytes, 0x20))
            }
        }

        return tempBytes;
    }

    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {
        require(_bytes.length >= _start + 20, ""toAddress_outOfBounds"");
        address tempAddress;

        assembly {
            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)
        }

        return tempAddress;
    }

    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {
        require(_bytes.length >= _start + 1, ""toUint8_outOfBounds"");
        uint8 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x1), _start))
        }

        return tempUint;
    }

    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {
        require(_bytes.length >= _start + 2, ""toUint16_outOfBounds"");
        uint16 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x2), _start))
        }

        return tempUint;
    }

    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {
        require(_bytes.length >= _start + 4, ""toUint32_outOfBounds"");
        uint32 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x4), _start))
        }

        return tempUint;
    }

    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {
        require(_bytes.length >= _start + 8, ""toUint64_outOfBounds"");
        uint64 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x8), _start))
        }

        return tempUint;
    }

    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {
        require(_bytes.length >= _start + 12, ""toUint96_outOfBounds"");
        uint96 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0xc), _start))
        }

        return tempUint;
    }

    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {
        require(_bytes.length >= _start + 16, ""toUint128_outOfBounds"");
        uint128 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x10), _start))
        }

        return tempUint;
    }

    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {
        require(_bytes.length >= _start + 32, ""toUint256_outOfBounds"");
        uint256 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x20), _start))
        }

        return tempUint;
    }

    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {
        require(_bytes.length >= _start + 32, ""toBytes32_outOfBounds"");
        bytes32 tempBytes32;

        assembly {
            tempBytes32 := mload(add(add(_bytes, 0x20), _start))
        }

        return tempBytes32;
    }

    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {
        bool success = true;

        assembly {
            let length := mload(_preBytes)

            // if lengths don't match the arrays are not equal
            switch eq(length, mload(_postBytes))
            case 1 {
                // cb is a circuit breaker in the for loop since there's
                //  no said feature for inline assembly loops
                // cb = 1 - don't breaker
                // cb = 0 - break
                let cb := 1

                let mc := add(_preBytes, 0x20)
                let end := add(mc, length)

                for {
                    let cc := add(_postBytes, 0x20)
                    // the next line is the loop condition:
                    // while(uint256(mc < end) + cb == 2)
                } eq(add(lt(mc, end), cb), 2) {
                    mc := add(mc, 0x20)
                    cc := add(cc, 0x20)
                } {
                    // if any of these checks fails then arrays are not equal
                    if iszero(eq(mload(mc), mload(cc))) {
                        // unsuccess:
                        success := 0
                        cb := 0
                    }
                }
            }
            default {
                // unsuccess:
                success := 0
            }
        }

        return success;
    }

    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {
        bool success = true;

        assembly {
            // we know _preBytes_offset is 0
            let fslot := sload(_preBytes.slot)
            // Decode the length of the stored array like in concatStorage().
            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)
            let mlength := mload(_postBytes)

            // if lengths don't match the arrays are not equal
            switch eq(slength, mlength)
            case 1 {
                // slength can contain both the length and contents of the array
                // if length < 32 bytes so let's prepare for that
                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage
                if iszero(iszero(slength)) {
                    switch lt(slength, 32)
                    case 1 {
                        // blank the last byte which is the length
                        fslot := mul(div(fslot, 0x100), 0x100)

                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {
                            // unsuccess:
                            success := 0
                        }
                    }
                    default {
                        // cb is a circuit breaker in the for loop since there's
                        //  no said feature for inline assembly loops
                        // cb = 1 - don't breaker
                        // cb = 0 - break
                        let cb := 1

                        // get the keccak hash to get the contents of the array
                        mstore(0x0, _preBytes.slot)
                        let sc := keccak256(0x0, 0x20)

                        let mc := add(_postBytes, 0x20)
                        let end := add(mc, mlength)

                        // the next line is the loop condition:
                        // while(uint256(mc < end) + cb == 2)
                        // solhint-disable-next-line no-empty-blocks
                        for {

                        } eq(add(lt(mc, end), cb), 2) {
                            sc := add(sc, 1)
                            mc := add(mc, 0x20)
                        } {
                            if iszero(eq(sload(sc), mload(mc))) {
                                // unsuccess:
                                success := 0
                                cb := 0
                            }
                        }
                    }
                }
            }
            default {
                // unsuccess:
                success := 0
            }
        }

        return success;
    }
}",4136
RealWorld_BA_105_ReentrancyGuard_RealWord_20240828075645.log,105,ReentrancyGuard,13048,4553,17601,65.0,0.1563,"// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)

pragma solidity ^0.8.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and making it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}",637
RealWorld_BA_105_ERC165_RealWord_20240828080545.log,105,ERC165,6766,4444,11210,65.0,0.12271,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""../interfaces/IERC165.sol"";

/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 * for the additional interface id that will be supported. For example:
 *
 * ```solidity
 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 * }
 * ```
 *
 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 */
abstract contract ERC165 is IERC165 {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}",204
RealWorld_BA_105_SafeERC20_RealWord_20240828075531.log,105,SafeERC20,16293,4996,21289,71.0,0.181385,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""../interfaces/IERC20.sol"";
import ""../utils/Address.sol"";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            ""SafeERC20: approve from non-zero to non-zero allowance""
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender) + value;
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, ""SafeERC20: decreased allowance below zero"");
            uint256 newAllowance = oldAllowance - value;
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
        }
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, ""SafeERC20: low-level call failed"");
        if (returndata.length > 0) {
            // Return data is optional
            require(abi.decode(returndata, (bool)), ""SafeERC20: ERC20 operation did not succeed"");
        }
    }
}",863
RealWorld_BA_105_IERC165_RealWord_20240828081119.log,105,IERC165,6134,3981,10115,82.0,0.11029,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}",193
RealWorld_BA_105_ERC20_RealWord_20240828075301.log,105,ERC20,47267,5552,52819,77.0,0.347375,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interfaces/IERC20.sol"";
import ""./interfaces/IERC20Metadata.sol"";
import ""./utils/Context.sol"";

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin Contracts guidelines: functions revert
 * instead returning `false` on failure. This behavior is nonetheless
 * conventional and does not conflict with the expectations of ERC20
 * applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20, IERC20Metadata {
    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;

    /**
     * @dev Sets the values for {name} and {symbol}.
     *
     * The default value of {decimals} is 18. To select a different value for
     * {decimals} you should overload it.
     *
     * All two of these values are immutable: they can only be set once during
     * construction.
     */
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5.05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless this function is
     * overridden;
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view virtual override returns (uint8) {
        return 18;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * Requirements:
     *
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);

        uint256 currentAllowance = _allowances[sender][_msgSender()];
        require(currentAllowance >= amount, ""ERC20: transfer amount exceeds allowance"");
        unchecked {
            _approve(sender, _msgSender(), currentAllowance - amount);
        }

        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        uint256 currentAllowance = _allowances[_msgSender()][spender];
        require(currentAllowance >= subtractedValue, ""ERC20: decreased allowance below zero"");
        unchecked {
            _approve(_msgSender(), spender, currentAllowance - subtractedValue);
        }

        return true;
    }

    /**
     * @dev Moves `amount` of tokens from `sender` to `recipient`.
     *
     * This internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _beforeTokenTransfer(sender, recipient, amount);

        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""ERC20: transfer amount exceeds balance"");
        unchecked {
            _balances[sender] = senderBalance - amount;
        }
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);

        _afterTokenTransfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);

        _afterTokenTransfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _beforeTokenTransfer(account, address(0), amount);

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, ""ERC20: burn amount exceeds balance"");
        unchecked {
            _balances[account] = accountBalance - amount;
        }
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);

        _afterTokenTransfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}

    /**
     * @dev Hook that is called after any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * has been transferred to `to`.
     * - when `from` is zero, `amount` tokens have been minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}
}",2760
RealWorld_BA_105_IERC20Metadata_RealWord_20240828081017.log,105,IERC20Metadata,5078,4137,9215,60.0,0.10813,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./IERC20.sol"";

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 *
 * _Available since v4.1._
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}",140
RealWorld_BA_105_Ownable_RealWord_20240828075753.log,105,Ownable,10506,5140,15646,69.0,0.15533,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./Context.sol"";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(_msgSender());
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}",481
RealWorld_BA_105_Context_RealWord_20240828080233.log,105,Context,5593,3730,9323,59.0,0.102565,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}",164
RealWorld_BA_105_PaladinRewardReserve_RealWord_20240828075028.log,105,PaladinRewardReserve,10901,5212,16113,70.0,0.158745,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import ""./open-zeppelin/utils/Ownable.sol"";
import ""./open-zeppelin/utils/ReentrancyGuard.sol"";
import ""./open-zeppelin/interfaces/IERC20.sol"";
import ""./open-zeppelin/libraries/SafeERC20.sol"";

/** @title Paladin Reward Reserve contract  */
/// @author Paladin
contract PaladinRewardReserve is Ownable, ReentrancyGuard{
    using SafeERC20 for IERC20;

    /** @notice Addresses allowed to transfer tokens from this contract */
    mapping(address => bool) public approvedSpenders;

    /** @notice Emitted when a new spender is approved*/
    event NewSpender(address indexed token, address indexed spender, uint256 amount);
    /** @notice Emitted when the allowance of a spander is updated */
    event UpdateSpender(address indexed token, address indexed spender, uint256 amount);
    /** @notice Emitted when a spender allowance is removed */
    event RemovedSpender(address indexed token, address indexed spender);

    constructor(address _admin) {
        transferOwnership(_admin);
    }

    function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {
        require(!approvedSpenders[spender], ""Already Spender"");
        approvedSpenders[spender] = true;
        IERC20(token).safeApprove(spender, amount);

        emit NewSpender(token, spender, amount);
    }

    function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {
        require(approvedSpenders[spender], ""Not approved Spender"");
        IERC20(token).safeApprove(spender, 0);
        IERC20(token).safeApprove(spender, amount);

        emit UpdateSpender(token, spender, amount);
    }

    function removeSpender(address token, address spender) external onlyOwner {
        require(approvedSpenders[spender], ""Not approved Spender"");
        approvedSpenders[spender] = false;
        IERC20(token).safeApprove(spender, 0);

        emit RemovedSpender(token, spender);
    }

    function transferToken(address token, address receiver, uint256 amount) external onlyOwner nonReentrant {
        IERC20(token).safeTransfer(receiver, amount);
    }

}",494
RealWorld_BA_105_Address_RealWord_20240828075904.log,105,Address,31622,5184,36806,73.0,0.26179,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, ""Address: insufficient balance"");

        (bool success, ) = recipient.call{value: amount}("""");
        require(success, ""Address: unable to send value, recipient may have reverted"");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, ""Address: low-level call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, ""Address: insufficient balance for call"");
        require(isContract(target), ""Address: call to non-contract"");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, ""Address: low-level static call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), ""Address: static call to non-contract"");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), ""Address: delegate call to non-contract"");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}",1783
RealWorld_BA_105_ECDSA_RealWord_20240828080019.log,105,ECDSA,37847,4570,42417,70.0,0.280635,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.
 *
 * These functions can be used to verify that a message was signed by the holder
 * of the private keys of a given address.
 */
library ECDSA {
    enum RecoverError {
        NoError,
        InvalidSignature,
        InvalidSignatureLength,
        InvalidSignatureS,
        InvalidSignatureV
    }

    function _throwError(RecoverError error) private pure {
        if (error == RecoverError.NoError) {
            return; // no error: do nothing
        } else if (error == RecoverError.InvalidSignature) {
            revert(""ECDSA: invalid signature"");
        } else if (error == RecoverError.InvalidSignatureLength) {
            revert(""ECDSA: invalid signature length"");
        } else if (error == RecoverError.InvalidSignatureS) {
            revert(""ECDSA: invalid signature 's' value"");
        } else if (error == RecoverError.InvalidSignatureV) {
            revert(""ECDSA: invalid signature 'v' value"");
        }
    }

    /**
     * @dev Returns the address that signed a hashed message (`hash`) with
     * `signature` or error string. This address can then be used for verification purposes.
     *
     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
     * this function rejects them by requiring the `s` value to be in the lower
     * half order, and the `v` value to be either 27 or 28.
     *
     * IMPORTANT: `hash` _must_ be the result of a hash operation for the
     * verification to be secure: it is possible to craft signatures that
     * recover to arbitrary addresses for non-hashed data. A safe way to ensure
     * this is by receiving a hash of the original message (which may otherwise
     * be too long), and then calling {toEthSignedMessageHash} on it.
     *
     * Documentation for signature generation:
     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]
     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]
     *
     * _Available since v4.3._
     */
    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {
        // Check the signature length
        // - case 65: r,s,v signature (standard)
        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._
        if (signature.length == 65) {
            bytes32 r;
            bytes32 s;
            uint8 v;
            // ecrecover takes the signature parameters, and the only way to get them
            // currently is to use assembly.
            assembly {
                r := mload(add(signature, 0x20))
                s := mload(add(signature, 0x40))
                v := byte(0, mload(add(signature, 0x60)))
            }
            return tryRecover(hash, v, r, s);
        } else if (signature.length == 64) {
            bytes32 r;
            bytes32 vs;
            // ecrecover takes the signature parameters, and the only way to get them
            // currently is to use assembly.
            assembly {
                r := mload(add(signature, 0x20))
                vs := mload(add(signature, 0x40))
            }
            return tryRecover(hash, r, vs);
        } else {
            return (address(0), RecoverError.InvalidSignatureLength);
        }
    }

    /**
     * @dev Returns the address that signed a hashed message (`hash`) with
     * `signature`. This address can then be used for verification purposes.
     *
     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
     * this function rejects them by requiring the `s` value to be in the lower
     * half order, and the `v` value to be either 27 or 28.
     *
     * IMPORTANT: `hash` _must_ be the result of a hash operation for the
     * verification to be secure: it is possible to craft signatures that
     * recover to arbitrary addresses for non-hashed data. A safe way to ensure
     * this is by receiving a hash of the original message (which may otherwise
     * be too long), and then calling {toEthSignedMessageHash} on it.
     */
    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, signature);
        _throwError(error);
        return recovered;
    }

    /**
     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.
     *
     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]
     *
     * _Available since v4.3._
     */
    function tryRecover(
        bytes32 hash,
        bytes32 r,
        bytes32 vs
    ) internal pure returns (address, RecoverError) {
        bytes32 s;
        uint8 v;
        assembly {
            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
            v := add(shr(255, vs), 27)
        }
        return tryRecover(hash, v, r, s);
    }

    /**
     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.
     *
     * _Available since v4.2._
     */
    function recover(
        bytes32 hash,
        bytes32 r,
        bytes32 vs
    ) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, r, vs);
        _throwError(error);
        return recovered;
    }

    /**
     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,
     * `r` and `s` signature fields separately.
     *
     * _Available since v4.3._
     */
    function tryRecover(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal pure returns (address, RecoverError) {
        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most
        // signatures from current libraries generate a unique signature with an s-value in the lower half order.
        //
        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
        // these malleable signatures as well.
        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
            return (address(0), RecoverError.InvalidSignatureS);
        }
        if (v != 27 && v != 28) {
            return (address(0), RecoverError.InvalidSignatureV);
        }

        // If the signature is valid (and not malleable), return the signer address
        address signer = ecrecover(hash, v, r, s);
        if (signer == address(0)) {
            return (address(0), RecoverError.InvalidSignature);
        }

        return (signer, RecoverError.NoError);
    }

    /**
     * @dev Overload of {ECDSA-recover} that receives the `v`,
     * `r` and `s` signature fields separately.
     */
    function recover(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);
        _throwError(error);
        return recovered;
    }

    /**
     * @dev Returns an Ethereum Signed Message, created from a `hash`. This
     * produces hash corresponding to the one signed with the
     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]
     * JSON-RPC method as part of EIP-191.
     *
     * See {recover}.
     */
    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
        // 32 is the length in bytes of hash,
        // enforced by the type signature above
        return keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash));
    }

    /**
     * @dev Returns an Ethereum Signed Typed Data, created from a
     * `domainSeparator` and a `structHash`. This produces hash corresponding
     * to the one signed with the
     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]
     * JSON-RPC method as part of EIP-712.
     *
     * See {recover}.
     */
    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(""\x19\x01"", domainSeparator, structHash));
    }
}",2172
RealWorld_BA_105_AccessControl_RealWord_20240828075420.log,105,AccessControl,29682,4955,34637,70.0,0.24751,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interfaces/IAccessControl.sol"";
import ""./utils/Context.sol"";
import ""./utils/Strings.sol"";
import ""./utils/ERC165.sol"";

/**
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms. This is a lightweight version that doesn't allow enumerating role
 * members except through off-chain means by accessing the contract event logs. Some
 * applications may benefit from on-chain enumerability, for those cases see
 * {AccessControlEnumerable}.
 *
 * Roles are referred to by their `bytes32` identifier. These should be exposed
 * in the external API and be unique. The best way to achieve this is by
 * using `public constant` hash digests:
 *
 * ```
 * bytes32 public constant MY_ROLE = keccak256(""MY_ROLE"");
 * ```
 *
 * Roles can be used to represent a set of permissions. To restrict access to a
 * function call, use {hasRole}:
 *
 * ```
 * function foo() public {
 *     require(hasRole(MY_ROLE, msg.sender));
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {_setRoleAdmin}.
 *
 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it.
 */
abstract contract AccessControl is Context, IAccessControl, ERC165 {
    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    /**
     * @dev Modifier that checks that an account has a specific role. Reverts
     * with a standardized message including the required role.
     *
     * The format of the revert reason is given by the following regular expression:
     *
     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
     *
     * _Available since v4.1._
     */
    modifier onlyRole(bytes32 role) {
        _checkRole(role, _msgSender());
        _;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
    }

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) public view override returns (bool) {
        return _roles[role].members[account];
    }

    /**
     * @dev Revert with a standard message if `account` is missing `role`.
     *
     * The format of the revert reason is given by the following regular expression:
     *
     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
     */
    function _checkRole(bytes32 role, address account) internal view {
        if (!hasRole(role, account)) {
            revert(
                string(
                    abi.encodePacked(
                        ""AccessControl: account "",
                        Strings.toHexString(uint160(account), 20),
                        "" is missing role "",
                        Strings.toHexString(uint256(role), 32)
                    )
                )
            );
        }
    }

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {
        return _roles[role].adminRole;
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
        _grantRole(role, account);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
        _revokeRole(role, account);
    }

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) public virtual override {
        require(account == _msgSender(), ""AccessControl: can only renounce roles for self"");

        _revokeRole(role, account);
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event. Note that unlike {grantRole}, this function doesn't perform any
     * checks on the calling account.
     *
     * [WARNING]
     * ====
     * This function should only be called from the constructor when setting
     * up the initial roles for the system.
     *
     * Using this function in any other way is effectively circumventing the admin
     * system imposed by {AccessControl}.
     * ====
     */
    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }

    /**
     * @dev Sets `adminRole` as ``role``'s admin role.
     *
     * Emits a {RoleAdminChanged} event.
     */
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        bytes32 previousAdminRole = getRoleAdmin(role);
        _roles[role].adminRole = adminRole;
        emit RoleAdminChanged(role, previousAdminRole, adminRole);
    }

    function _grantRole(bytes32 role, address account) private {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, _msgSender());
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, _msgSender());
        }
    }
}",1647
RealWorld_BA_105_MerkleProof_RealWord_20240828080131.log,105,MerkleProof,8761,4060,12821,60.0,0.125005,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev These functions deal with verification of Merkle Trees proofs.
 *
 * The proofs can be generated using the JavaScript library
 * https://github.com/miguelmota/merkletreejs[merkletreejs].
 * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.
 *
 * See `test/utils/cryptography/MerkleProof.test.js` for some examples.
 */
library MerkleProof {
    /**
     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree
     * defined by `root`. For this, a `proof` must be provided, containing
     * sibling hashes on the branch from the leaf to the root of the tree. Each
     * pair of leaves and each pair of pre-images are assumed to be sorted.
     */
    function verify(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool) {
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash <= proofElement) {
                // Hash(current computed hash + current element of the proof)
                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
            } else {
                // Hash(current element of the proof + current computed hash)
                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
            }
        }

        // Check if the computed hash (root) is equal to the provided root
        return computedHash == root;
    }
}",367
RealWorld_BA_105_IMerkleDistributor_RealWord_20240828080800.log,105,IMerkleDistributor,4816,4631,9447,70.0,0.1167,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;


interface IMerkleDistributor {

    function token() external view returns (address);

    function merkleRoot() external view returns (bytes32);

    function isClaimed(uint256 index) external view returns (bool);

    function claim(
        uint256 index,
        address account,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external;

    event Claimed(uint256 index, address account, uint256 amount);
}",109
RealWorld_BA_105_Math_RealWord_20240828080334.log,105,Math,8172,4357,12529,66.0,0.128,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Standard math utilities missing in the Solidity language.
 */
library Math {
    /**
     * @dev Returns the largest of two numbers.
     */
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? a : b;
    }

    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two numbers. The result is rounded towards
     * zero.
     */
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow.
        return (a & b) + (a ^ b) / 2;
    }

    /**
     * @dev Returns the ceiling of the division of two numbers.
     *
     * This differs from standard division with `/` in that it rounds up instead
     * of rounding down.
     */
    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b - 1) / b can overflow on addition, so we distribute.
        return a / b + (a % b == 0 ? 0 : 1);
    }
}",309
RealWorld_BA_105_StakingHPAL.test_RealWord_20240828081243.log,105,StakingHPAL.test,41558,4919,46477,88.0,0.30617,"// SPDX-License-Identifier: Unlicensed
pragma solidity ^0.8.10;

import ""ds-test/test.sol"";
import ""forge-std/Vm.sol"";
import ""forge-std/console.sol"";
import {Utils} from ""./utils/Utils.sol"";

import {PaladinToken} from ""../../contracts/test/PaladinToken.sol"";
import {HolyPaladinToken} from ""../../contracts/HolyPaladinToken.sol"";

contract StakingHPALTest is DSTest {
    Vm internal immutable vm = Vm(HEVM_ADDRESS);

    Utils internal utils;

    address payable[] internal users;

    PaladinToken internal pal;
    HolyPaladinToken internal hpal;

    function setUp() public {
        utils = new Utils();
        users = utils.createUsers(2);

        uint256 palSupply = 50000000 * 1e18;
        pal = new PaladinToken(palSupply, address(this), address(this));
        pal.setTransfersAllowed(true);

        //hPAL constructor parameters
        uint256 startDropPerSecond = 0.0005 * 1e18;
        uint256 endDropPerSecond = 0.00001 * 1e18;
        uint256 dropDecreaseDuration = 63115200;
        uint256 baseLockBonusRatio = 1 * 1e18;
        uint256 minLockBonusRatio = 2 * 1e18;
        uint256 maxLockBonusRatio = 6 * 1e18;

        hpal = new HolyPaladinToken(
            address(pal),
            address(this),
            address(this),
            startDropPerSecond,
            endDropPerSecond,
            dropDecreaseDuration,
            baseLockBonusRatio,
            minLockBonusRatio,
            maxLockBonusRatio
        );
    }

    // using uint72 since we gave only 1 000 PAL to the user
    function testStaking(uint72 amount) public {
        address payable staker = users[0];

        uint256 transferAmount = 1000 * 1e18;

        pal.transfer(staker, transferAmount);

        uint256 previousBalance = pal.balanceOf(staker);
        uint256 previousStakedBalance = hpal.balanceOf(staker);
        uint256 previousContractBalance = pal.balanceOf(address(hpal));
        uint256 previousTotalSupply = hpal.totalSupply();

        vm.prank(staker);

        pal.approve(address(hpal), amount);

        if(amount == 0){
            vm.expectRevert(
                bytes(""hPAL: Null amount"")
            );
            vm.prank(staker);
            hpal.stake(amount);

            uint256 newBalance = pal.balanceOf(staker);
            uint256 newStakedBalance = hpal.balanceOf(staker);
            uint256 newContractBalance = pal.balanceOf(address(hpal));
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalance, previousBalance);
            assertEq(newStakedBalance, previousStakedBalance);
            assertEq(newContractBalance, previousContractBalance);
            assertEq(newTotalSupply, previousTotalSupply);
        }
        else if(amount > previousBalance) {
            vm.expectRevert(
                bytes(""ERC20: transfer amount exceeds balance"")
            );
            vm.prank(staker);
            hpal.stake(amount);

            uint256 newBalance = pal.balanceOf(staker);
            uint256 newStakedBalance = hpal.balanceOf(staker);
            uint256 newContractBalance = pal.balanceOf(address(hpal));
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalance, previousBalance);
            assertEq(newStakedBalance, previousStakedBalance);
            assertEq(newContractBalance, previousContractBalance);
            assertEq(newTotalSupply, previousTotalSupply);
        }
        else{
            vm.prank(staker);
            uint256 returnAmount = hpal.stake(amount);

            assertEq(returnAmount, amount);

            uint256 newBalance = pal.balanceOf(staker);
            uint256 newStakedBalance = hpal.balanceOf(staker);
            uint256 newContractBalance = pal.balanceOf(address(hpal));
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalance, previousBalance - amount);
            assertEq(newStakedBalance, previousStakedBalance + amount);
            assertEq(newContractBalance, previousContractBalance + amount);
            assertEq(newTotalSupply, previousTotalSupply + amount);

        }

    }

    // using uint72 since we gave only 1 000 PAL to the user
    function testUnstaking(uint72 amount) public {
        address payable staker = users[0];

        uint256 transferAmount = 1000 * 1e18;

        uint256 stakingAmount = 700 * 1e18;

        pal.transfer(staker, transferAmount);

        vm.prank(staker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(staker);
        hpal.stake(stakingAmount);

        vm.prank(staker);
        hpal.cooldown();

        utils.advanceTime(864100);

        uint256 previousBalance = pal.balanceOf(staker);
        uint256 previousStakedBalance = hpal.balanceOf(staker);
        uint256 previousContractBalance = pal.balanceOf(address(hpal));
        uint256 previousTotalSupply = hpal.totalSupply();

        if(amount == 0){
            vm.expectRevert(
                bytes(""hPAL: Null amount"")
            );
            vm.prank(staker);
            hpal.unstake(amount, staker);

            uint256 newBalance = pal.balanceOf(staker);
            uint256 newStakedBalance = hpal.balanceOf(staker);
            uint256 newContractBalance = pal.balanceOf(address(hpal));
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalance, previousBalance);
            assertEq(newStakedBalance, previousStakedBalance);
            assertEq(newContractBalance, previousContractBalance);
            assertEq(newTotalSupply, previousTotalSupply);
        }
        else if(amount > previousStakedBalance) {
            vm.prank(staker);
            uint256 returnAmount = hpal.unstake(amount, staker);

            assertLt(returnAmount, amount);
            assertEq(returnAmount, previousStakedBalance);

            uint256 newBalance = pal.balanceOf(staker);
            uint256 newStakedBalance = hpal.balanceOf(staker);
            uint256 newContractBalance = pal.balanceOf(address(hpal));
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalance, previousBalance + returnAmount);
            assertEq(newStakedBalance, 0);
            assertEq(newContractBalance, previousContractBalance - returnAmount);
            assertEq(newTotalSupply, previousTotalSupply - returnAmount);
        }
        else{
            vm.prank(staker);
            uint256 returnAmount = hpal.unstake(amount, staker);

            assertEq(returnAmount, amount);

            uint256 newBalance = pal.balanceOf(staker);
            uint256 newStakedBalance = hpal.balanceOf(staker);
            uint256 newContractBalance = pal.balanceOf(address(hpal));
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalance, previousBalance + amount);
            assertEq(newStakedBalance, previousStakedBalance - amount);
            assertEq(newContractBalance, previousContractBalance - amount);
            assertEq(newTotalSupply, previousTotalSupply - amount);

        }

    }

    function testClaim(uint72 amount) public {
        address payable staker = users[0];

        uint256 transferAmount = 1000 * 1e18;

        uint256 stakingAmount = 700 * 1e18;

        pal.transfer(staker, transferAmount);

        pal.approve(address(hpal), 1000000 * 1e18);

        vm.prank(staker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(staker);
        hpal.stake(stakingAmount);

        vm.prank(staker);
        hpal.cooldown();

        utils.advanceTime(864100);

        vm.prank(staker);
        hpal.unstake(stakingAmount, staker);

        uint256 previousBalance = pal.balanceOf(staker);
        uint256 previousVaultBalance = pal.balanceOf(address(this));

        uint256 claimableAmount = hpal.claimableRewards(staker);

        if(amount == 0){
            vm.expectRevert(
                bytes(""hPAL: incorrect amount"")
            );
            vm.prank(staker);
            hpal.claim(amount);

            uint256 newBalance = pal.balanceOf(staker);
            uint256 newVaultBalance = pal.balanceOf(address(this));

            assertEq(newBalance, previousBalance);
            assertEq(newVaultBalance, previousVaultBalance);
        }
        else if(amount > claimableAmount) {
            vm.prank(staker);
            hpal.claim(amount);

            uint256 newBalance = pal.balanceOf(staker);
            uint256 newVaultBalance = pal.balanceOf(address(this));

            assertEq(newBalance, previousBalance + claimableAmount);
            assertEq(newVaultBalance, previousVaultBalance - claimableAmount);

            uint256 newClaimableAmount = hpal.claimableRewards(staker);

            assertEq(newClaimableAmount, 0);
        }
        else{
            vm.prank(staker);
            hpal.claim(amount);

            uint256 newBalance = pal.balanceOf(staker);
            uint256 newVaultBalance = pal.balanceOf(address(this));

            assertEq(newBalance, previousBalance + amount);
            assertEq(newVaultBalance, previousVaultBalance - amount);

            uint256 newClaimableAmount = hpal.claimableRewards(staker);

            assertEq(newClaimableAmount, claimableAmount - amount);

        }

    }

    function testTransfer(uint72 amount) public {
        address payable staker = users[0];
        address payable receiver = users[1];

        uint256 transferAmount = 1000 * 1e18;

        uint256 stakingAmount = 700 * 1e18;

        pal.transfer(staker, transferAmount);

        vm.prank(staker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(staker);
        hpal.stake(stakingAmount);

        uint256 previousBalanceStaker = hpal.balanceOf(staker);
        uint256 previousBalanceReceiver = hpal.balanceOf(receiver);
        uint256 previousTotalSupply = hpal.totalSupply();

        if(amount > stakingAmount) {
            vm.expectRevert(
                bytes(""hPAL: Available balance too low"")
            );
            vm.prank(staker);
            hpal.transfer(receiver, amount);

            uint256 newBalanceStaker = hpal.balanceOf(staker);
            uint256 newBalanceReceiver = hpal.balanceOf(receiver);
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalanceStaker, previousBalanceStaker);
            assertEq(newBalanceReceiver, previousBalanceReceiver);
            assertEq(newTotalSupply, previousTotalSupply);
        }
        else{
            vm.prank(staker);
            bool success = hpal.transfer(receiver, amount);

            assertTrue(success);

            uint256 newBalanceStaker = hpal.balanceOf(staker);
            uint256 newBalanceReceiver = hpal.balanceOf(receiver);
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalanceStaker, previousBalanceStaker - amount);
            assertEq(newBalanceReceiver, previousBalanceReceiver + amount);
            assertEq(newTotalSupply, previousTotalSupply);

        }
    }

}",2411
RealWorld_BA_105_PaladinToken_RealWord_20240828075140.log,105,PaladinToken,38733,5544,44277,80.0,0.304545,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import ""../open-zeppelin/ERC20.sol"";
import ""../open-zeppelin/AccessControl.sol"";
import ""../open-zeppelin/utils/Math.sol"";
import ""../open-zeppelin/utils/ECDSA.sol"";

/** @title Paladin Token contract  */
/// @author Paladin
contract PaladinToken is ERC20, AccessControl {
    /** @notice The identifier for admin role */
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN"");
    /** @notice The identifier for transfer-allwoed role */
    bytes32 public constant TRANSFER_ROLE = keccak256(""TRANSFER"");

    bytes32 public constant DOMAIN_TYPEHASH = keccak256(""EIP712Domain(string name,uint256 chainId,address verifyingContract)"");

    bytes32 private constant DELEGATION_TYPEHASH =
        keccak256(""Delegation(address delegatee,uint256 nonce,uint256 expiry)"");

    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    // Storage :

    /** @notice boolean allowing transfer for all users */
    bool public transfersAllowed = false;

    mapping(address => address) public delegates;

    mapping(address => Checkpoint[]) public checkpoints;

    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    mapping(address => uint256) public nonces;

    // Events :

    /** @notice Emitted when transfer toggle is switched */
    event TransfersAllowed(bool transfersAllowed);

    event DelegateChanged(
        address indexed delegator,
        address indexed fromDelegate,
        address indexed toDelegate
    );

    event DelegateVotesChanged(
        address indexed delegate,
        uint256 previousBalance,
        uint256 newBalance
    );

    // Modifiers :

    /** @dev Allows only ADMIN role to call the function */
    modifier onlyAdmin() {
        require(
            hasRole(ADMIN_ROLE, msg.sender),
            ""PaladinToken: caller not admin""
        );
        _;
    }

    /** @dev Allows only caller with the TRANSFER role to execute transfer */
    modifier onlyTransferer(address from) {
        require(
            transfersAllowed || hasRole(TRANSFER_ROLE, msg.sender),
            ""PaladinToken: caller cannot transfer""
        );
        _;
    }

    constructor(
        uint256 initialSupply,
        address admin,
        address recipient
    ) ERC20(""Paladin Token"", ""PAL"") {
        _setupRole(TRANSFER_ROLE, admin);
        _setupRole(TRANSFER_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, admin);
        _setRoleAdmin(TRANSFER_ROLE, ADMIN_ROLE);

        _mint(recipient, initialSupply);
    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override onlyTransferer(from) {}

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function delegate(address delegatee) external virtual {
        return _delegate(_msgSender(), delegatee);
    }

    function delegateBySig(
        address delegatee,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external virtual {
        require(block.timestamp <= expiry, ""PaladinToken: signature expired"");

        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this)));
        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));
        bytes32 digest = keccak256(abi.encodePacked(""\x19\x01"", domainSeparator, structHash));
        address signer = ecrecover(digest, v, r, s);
        
        require(signer != address(0), ""PaladinToken: invalid signature"");
        require(nonce == nonces[signer], ""PaladinToken: invalid nonce"");
        nonces[signer]++;
        return _delegate(signer, delegatee);
    }

    function numCheckpoints(address account)
        external
        view
        virtual
        returns (uint256)
    {
        return checkpoints[account].length;
    }

    function getCurrentVotes(address account) external view returns (uint256) {
        uint256 nbCheckpoints = checkpoints[account].length;
        return
            nbCheckpoints == 0
                ? 0
                : checkpoints[account][nbCheckpoints - 1].votes;
    }

    function getPastVotes(address account, uint256 blockNumber)
        external
        view
        returns (uint256)
    {
        require(
            blockNumber < block.number,
            ""PaladinToken: invalid blockNumber""
        );

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) {
            return 0;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function getPastDelegate(address account, uint256 blockNumber)
        external
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            ""PaladinToken: invalid blockNumber""
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _delegate(address delegator, address delegatee) internal {
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    function _moveDelegates(
        address from,
        address to,
        uint256 amount
    ) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(
        address delegatee,
        uint256 newVotes
    ) internal {
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    function safe32(uint n) internal pure returns (uint32) {
        require(n <= type(uint32).max, ""PaladinToken : block number exceed 32 bits"");
        return uint32(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        require(n <= type(uint224).max, ""PaladinToken : amount exceed 224 bits"");
        return uint224(n);
    }

    function getChainId() internal view returns (uint) {
        uint256 chainId;
        assembly { chainId := chainid() }
        return chainId;
    }



    // Admin methods :

    /**
     * @notice Allow/Block transfer for all users
     * @dev Change transfersAllowed flag
     * @param _transfersAllowed bool : true to allow Transfer, false to block
     */
    function setTransfersAllowed(bool _transfersAllowed) external onlyAdmin {
        transfersAllowed = _transfersAllowed;
        emit TransfersAllowed(transfersAllowed);
    }
}",2218
RealWorld_BA_105_Strings_RealWord_20240828080442.log,105,Strings,10984,4033,15017,61.0,0.13558,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev String operations.
 */
library Strings {
    bytes16 private constant _HEX_SYMBOLS = ""0123456789abcdef"";

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return ""0"";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return ""0x00"";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = ""0"";
        buffer[1] = ""x"";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, ""Strings: hex length insufficient"");
        return string(buffer);
    }
}",503
RealWorld_BA_105_Utils_RealWord_20240828081549.log,105,Utils,8197,5328,13525,93.0,0.147545,"// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.10;

import ""ds-test/test.sol"";
import ""forge-std/Vm.sol"";

//common utilities for forge tests
contract Utils is DSTest {
    Vm internal immutable vm = Vm(HEVM_ADDRESS);
    bytes32 internal nextUser = keccak256(abi.encodePacked(""user address""));

    function getNextUserAddress() external returns (address payable) {
        //bytes32 to address conversion
        address payable user = payable(address(uint160(uint256(nextUser))));
        nextUser = keccak256(abi.encodePacked(nextUser));
        return user;
    }

    //create users with 100 ether balance
    function createUsers(uint256 userNum)
        external
        returns (address payable[] memory)
    {
        address payable[] memory users = new address payable[](userNum);
        for (uint256 i = 0; i < userNum; i++) {
            address payable user = this.getNextUserAddress();
            vm.deal(user, 100 ether);
            users[i] = user;
        }
        return users;
    }

    //move block.number forward by a given number of blocks
    function mineBlocks(uint256 numBlocks) external {
        uint256 targetBlock = block.number + numBlocks;
        vm.roll(targetBlock);
    }

    function advanceTime(uint256 timeToAdvance) external {
        uint256 targetTimestamp = block.timestamp + timeToAdvance;
        vm.warp(targetTimestamp);
    }
}",313
RealWorld_BA_105_IAccessControl_RealWord_20240828080912.log,105,IAccessControl,14877,5337,20214,63.0,0.181125,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev External interface of AccessControl declared to support ERC165 detection.
 */
interface IAccessControl {
    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     *
     * _Available since v3.1._
     */
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {AccessControl-_setupRole}.
     */
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) external view returns (bool);

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {AccessControl-_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) external;
}",692
RealWorld_BA_105_IERC20_RealWord_20240828080652.log,105,IERC20,13771,4958,18729,66.0,0.168015,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",617
RealWorld_BA_105_LockingHPAL.test_RealWord_20240828081413.log,105,LockingHPAL.test,117477,5221,122698,94.0,0.691805,"// SPDX-License-Identifier: Unlicensed
pragma solidity ^0.8.10;

import ""ds-test/test.sol"";
import ""forge-std/Vm.sol"";
import ""forge-std/console.sol"";
import {Utils} from ""./utils/Utils.sol"";

import {PaladinToken} from ""../../contracts/test/PaladinToken.sol"";
import {HolyPaladinToken} from ""../../contracts/HolyPaladinToken.sol"";

contract LockingHPALTest is DSTest {
    Vm internal immutable vm = Vm(HEVM_ADDRESS);

    Utils internal utils;

    address payable[] internal users;

    PaladinToken internal pal;
    HolyPaladinToken internal hpal;

    function setUp() public {
        utils = new Utils();
        users = utils.createUsers(2);

        uint256 palSupply = 50000000 * 1e18;
        pal = new PaladinToken(palSupply, address(this), address(this));
        pal.setTransfersAllowed(true);

        //hPAL constructor parameters
        uint256 startDropPerSecond = 0.0005 * 1e18;
        uint256 endDropPerSecond = 0.00001 * 1e18;
        uint256 dropDecreaseDuration = 63115200;
        uint256 baseLockBonusRatio = 1 * 1e18;
        uint256 minLockBonusRatio = 2 * 1e18;
        uint256 maxLockBonusRatio = 6 * 1e18;

        hpal = new HolyPaladinToken(
            address(pal),
            address(this),
            address(this),
            startDropPerSecond,
            endDropPerSecond,
            dropDecreaseDuration,
            baseLockBonusRatio,
            minLockBonusRatio,
            maxLockBonusRatio
        );
    }

    // using uint72 since we gave only 1 000 PAL to the user
    function testLockingAmount(uint72 amount) public {
        address payable locker = users[0];

        uint256 transferAmount = 1000 * 1e18;

        uint256 stakingAmount = 700 * 1e18;

        pal.transfer(locker, transferAmount);

        vm.prank(locker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(locker);
        hpal.stake(stakingAmount);

        uint256 lockDuration = 31557600;

        HolyPaladinToken.TotalLock memory previousTotalLocked = hpal.getCurrentTotalLock();

        if(amount == 0){
            vm.expectRevert(
                bytes(""hPAL: Null amount"")
            );
            vm.prank(locker);
            hpal.lock(amount, lockDuration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, 0);
            assertEq(userLock.startTimestamp, 0);
            assertEq(userLock.duration, 0);
            assertEq(userLock.fromBlock, 0);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(amount > stakingAmount) {
            vm.expectRevert(
                bytes(""hPAL: Amount over balance"")
            );
            vm.prank(locker);
            hpal.lock(amount, lockDuration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, 0);
            assertEq(userLock.startTimestamp, 0);
            assertEq(userLock.duration, 0);
            assertEq(userLock.fromBlock, 0);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else{
            vm.prank(locker);
            hpal.lock(amount, lockDuration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, amount);
            assertEq(userLock.startTimestamp, block.timestamp);
            assertEq(userLock.duration, lockDuration);
            assertEq(userLock.fromBlock, block.number);
            assertEq(newTotalLocked.total, previousTotalLocked.total + amount);

        }

    }

    function testReLockingAmount(uint72 amount) public {
        address payable locker = users[0];

        uint256 transferAmount = 1000 * 1e18;

        uint256 stakingAmount = 700 * 1e18;

        uint256 lockAmount = 300 * 1e18;

        pal.transfer(locker, transferAmount);

        vm.prank(locker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(locker);
        hpal.stake(stakingAmount);

        uint256 lockDuration = 31557600;

        vm.prank(locker);
        hpal.lock(lockAmount, lockDuration);

        HolyPaladinToken.UserLock memory previousLock = hpal.getUserLock(locker);
        HolyPaladinToken.TotalLock memory previousTotalLocked = hpal.getCurrentTotalLock();

        if(amount == 0){
            vm.expectRevert(
                bytes(""hPAL: Null amount"")
            );
            vm.prank(locker);
            hpal.lock(amount, lockDuration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(amount > stakingAmount) {
            vm.expectRevert(
                bytes(""hPAL: Amount over balance"")
            );
            vm.prank(locker);
            hpal.lock(amount, lockDuration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(amount < lockAmount) {
            vm.expectRevert(
                bytes(""hPAL: smaller amount"")
            );
            vm.prank(locker);
            hpal.lock(amount, lockDuration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else{
            vm.prank(locker);
            hpal.lock(amount, lockDuration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, amount);
            assertEq(userLock.startTimestamp, block.timestamp);
            assertEq(userLock.duration, lockDuration);
            assertEq(userLock.fromBlock, block.number);
            assertEq(newTotalLocked.total, previousTotalLocked.total + amount - lockAmount);

        }

    }

    function testLockingDuration(uint256 duration) public {
        address payable locker = users[0];

        uint256 transferAmount = 1000 * 1e18;

        uint256 stakingAmount = 700 * 1e18;

        pal.transfer(locker, transferAmount);

        vm.prank(locker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(locker);
        hpal.stake(stakingAmount);

        uint256 lockAmount = 300 * 1e18;

        HolyPaladinToken.TotalLock memory previousTotalLocked = hpal.getCurrentTotalLock();

        if(duration < hpal.MIN_LOCK_DURATION()){
            vm.expectRevert(
                bytes(""hPAL: Lock duration under min"")
            );
            vm.prank(locker);
            hpal.lock(lockAmount, duration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, 0);
            assertEq(userLock.startTimestamp, 0);
            assertEq(userLock.duration, 0);
            assertEq(userLock.fromBlock, 0);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(duration > hpal.MAX_LOCK_DURATION()) {
            vm.expectRevert(
                bytes(""hPAL: Lock duration over max"")
            );
            vm.prank(locker);
            hpal.lock(lockAmount, duration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, 0);
            assertEq(userLock.startTimestamp, 0);
            assertEq(userLock.duration, 0);
            assertEq(userLock.fromBlock, 0);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else{
            vm.prank(locker);
            hpal.lock(lockAmount, duration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, lockAmount);
            assertEq(userLock.startTimestamp, block.timestamp);
            assertEq(userLock.duration, duration);
            assertEq(userLock.fromBlock, block.number);
            assertEq(newTotalLocked.total, previousTotalLocked.total + lockAmount);

        }
    }

    function testReLockingDuration(uint256 duration) public {
        address payable locker = users[0];

        uint256 transferAmount = 1000 * 1e18;

        uint256 stakingAmount = 700 * 1e18;

        pal.transfer(locker, transferAmount);

        vm.prank(locker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(locker);
        hpal.stake(stakingAmount);

        uint256 lockAmount = 300 * 1e18;

        uint256 lockDuration = 31557600;

        vm.prank(locker);
        hpal.lock(lockAmount, lockDuration);

        HolyPaladinToken.UserLock memory previousLock = hpal.getUserLock(locker);

        HolyPaladinToken.TotalLock memory previousTotalLocked = hpal.getCurrentTotalLock();

        if(duration < hpal.MIN_LOCK_DURATION()){
            vm.expectRevert(
                bytes(""hPAL: Lock duration under min"")
            );
            vm.prank(locker);
            hpal.lock(lockAmount, duration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(duration > hpal.MAX_LOCK_DURATION()) {
            vm.expectRevert(
                bytes(""hPAL: Lock duration over max"")
            );
            vm.prank(locker);
            hpal.lock(lockAmount, duration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(duration < lockDuration) {
            vm.expectRevert(
                bytes(""hPAL: smaller duration"")
            );
            vm.prank(locker);
            hpal.lock(lockAmount, duration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else{
            vm.prank(locker);
            hpal.lock(lockAmount, duration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);

        }

    }

    function testIncreaseLockAmount(uint72 amount) public {
        address payable locker = users[0];

        uint256 transferAmount = 1000 * 1e18;

        uint256 stakingAmount = 700 * 1e18;

        uint256 lockAmount = 300 * 1e18;

        pal.transfer(locker, transferAmount);

        vm.prank(locker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(locker);
        hpal.stake(stakingAmount);

        uint256 lockDuration = 31557600;

        vm.prank(locker);
        hpal.lock(lockAmount, lockDuration);

        HolyPaladinToken.UserLock memory previousLock = hpal.getUserLock(locker);
        HolyPaladinToken.TotalLock memory previousTotalLocked = hpal.getCurrentTotalLock();
        
        if(amount == 0){
            vm.expectRevert(
                bytes(""hPAL: Null amount"")
            );
            vm.prank(locker);
            hpal.increaseLock(amount);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(amount > stakingAmount) {
            vm.expectRevert(
                bytes(""hPAL: Amount over balance"")
            );
            vm.prank(locker);
            hpal.increaseLock(amount);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(amount < lockAmount) {
            vm.expectRevert(
                bytes(""hPAL: smaller amount"")
            );
            vm.prank(locker);
            hpal.increaseLock(amount);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else{
            vm.prank(locker);
            hpal.increaseLock(amount);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, lockDuration);
            assertEq(userLock.fromBlock, block.number);
            assertEq(newTotalLocked.total, previousTotalLocked.total + amount - previousLock.amount);

        }

    }

    function testIncreaseLockDuration(uint256 duration) public {
        address payable locker = users[0];

        uint256 transferAmount = 1000 * 1e18;

        uint256 stakingAmount = 700 * 1e18;

        uint256 lockAmount = 300 * 1e18;

        pal.transfer(locker, transferAmount);

        vm.prank(locker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(locker);
        hpal.stake(stakingAmount);

        uint256 lockDuration = 31557600;

        vm.prank(locker);
        hpal.lock(lockAmount, lockDuration);

        HolyPaladinToken.UserLock memory previousLock = hpal.getUserLock(locker);
        HolyPaladinToken.TotalLock memory previousTotalLocked = hpal.getCurrentTotalLock();
        
        if(duration < hpal.MIN_LOCK_DURATION()){
            vm.expectRevert(
                bytes(""hPAL: Lock duration under min"")
            );
            vm.prank(locker);
            hpal.increaseLockDuration(duration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(duration > hpal.MAX_LOCK_DURATION()) {
            vm.expectRevert(
                bytes(""hPAL: Lock duration over max"")
            );
            vm.prank(locker);
            hpal.increaseLockDuration(duration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(duration < lockDuration) {
            vm.expectRevert(
                bytes(""hPAL: smaller duration"")
            );
            vm.prank(locker);
            hpal.increaseLockDuration(duration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else{
            vm.prank(locker);
            hpal.increaseLockDuration(duration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, block.timestamp);
            assertEq(userLock.duration, duration);
            assertEq(userLock.fromBlock, block.number);
            assertEq(newTotalLocked.total, previousTotalLocked.total);

        }

    }

    function testLockAndUnlock(uint72 amount) public {
        address payable locker = users[0];

        uint256 transferAmount = 1000 * 1e18;

        uint256 stakingAmount = 700 * 1e18;

        pal.transfer(locker, transferAmount);

        vm.prank(locker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(locker);
        hpal.stake(stakingAmount);

        uint256 lockDuration = 31557600;

        if(amount > stakingAmount || amount == 0) return;

        vm.prank(locker);
        hpal.lock(amount, lockDuration);

        HolyPaladinToken.TotalLock memory previousTotalLocked = hpal.getCurrentTotalLock();

        utils.advanceTime(lockDuration + 10);
        
        vm.prank(locker);
        hpal.unlock();

        HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
        HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

        assertEq(userLock.amount, 0);
        assertEq(userLock.startTimestamp, block.timestamp);
        assertEq(userLock.duration, 0);
        assertEq(userLock.fromBlock, block.number);
        assertEq(newTotalLocked.total, previousTotalLocked.total - amount);

        assertEq(hpal.userCurrentBonusRatio(locker), 0);

    }

    function testLockAndKick(uint72 amount) public {
        address payable locker = users[0];
        address payable kicker = users[1];

        uint256 transferAmount = 1000 * 1e18;

        uint256 stakingAmount = 700 * 1e18;

        pal.transfer(locker, transferAmount);

        vm.prank(locker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(locker);
        hpal.stake(stakingAmount);

        uint256 lockDuration = 31557600;

        if(amount > stakingAmount || amount == 0) return;

        vm.prank(locker);
        hpal.lock(amount, lockDuration);

        uint256 previousLockerBalance = hpal.balanceOf(locker);
        uint256 previousLockerKicker = hpal.balanceOf(kicker);

        HolyPaladinToken.TotalLock memory previousTotalLocked = hpal.getCurrentTotalLock();

        utils.advanceTime(lockDuration + hpal.UNLOCK_DELAY() + 10);
        
        vm.prank(kicker);
        hpal.kick(locker);

        uint256 penaltyAmount = (amount * (hpal.UNLOCK_DELAY() / hpal.WEEK()) * hpal.kickRatioPerWeek()) / hpal.MAX_BPS();

        HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
        HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

        assertEq(userLock.amount, 0);
        assertEq(userLock.startTimestamp, block.timestamp);
        assertEq(userLock.duration, 0);
        assertEq(userLock.fromBlock, block.number);
        assertEq(newTotalLocked.total, previousTotalLocked.total - amount);

        assertEq(hpal.userCurrentBonusRatio(locker), 0);

        uint256 newLockerBalance = hpal.balanceOf(locker);
        uint256 newLockerKicker = hpal.balanceOf(kicker);

        assertEq(newLockerBalance, previousLockerBalance - penaltyAmount);
        assertEq(newLockerKicker, previousLockerKicker + penaltyAmount);

    }

    function testStakeAndLock(uint72 amount) public {
        address payable locker = users[0];

        pal.transfer(locker, 1000 * 1e18);

        uint256 previousBalance = pal.balanceOf(locker);
        uint256 previousStakedBalance = hpal.balanceOf(locker);
        uint256 previousContractBalance = pal.balanceOf(address(hpal));
        uint256 previousTotalSupply = hpal.totalSupply();

        vm.prank(locker);
        pal.approve(address(hpal), amount);

        HolyPaladinToken.TotalLock memory previousTotalLocked = hpal.getCurrentTotalLock();

        if(amount == 0){
            vm.expectRevert(
                bytes(""hPAL: Null amount"")
            );
            vm.prank(locker);
            hpal.stakeAndLock(amount, 31557600);

            uint256 newBalance = pal.balanceOf(locker);
            uint256 newStakedBalance = hpal.balanceOf(locker);
            uint256 newContractBalance = pal.balanceOf(address(hpal));
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalance, previousBalance);
            assertEq(newStakedBalance, previousStakedBalance);
            assertEq(newContractBalance, previousContractBalance);
            assertEq(newTotalSupply, previousTotalSupply);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, 0);
            assertEq(userLock.startTimestamp, 0);
            assertEq(userLock.duration, 0);
            assertEq(userLock.fromBlock, 0);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(amount > previousBalance) {
            vm.expectRevert(
                bytes(""ERC20: transfer amount exceeds balance"")
            );
            vm.prank(locker);
            hpal.stakeAndLock(amount, 31557600);

            uint256 newBalance = pal.balanceOf(locker);
            uint256 newStakedBalance = hpal.balanceOf(locker);
            uint256 newContractBalance = pal.balanceOf(address(hpal));
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalance, previousBalance);
            assertEq(newStakedBalance, previousStakedBalance);
            assertEq(newContractBalance, previousContractBalance);
            assertEq(newTotalSupply, previousTotalSupply);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, 0);
            assertEq(userLock.startTimestamp, 0);
            assertEq(userLock.duration, 0);
            assertEq(userLock.fromBlock, 0);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else{
            vm.prank(locker);
            uint256 returnAmount = hpal.stakeAndLock(amount, 31557600);

            assertEq(returnAmount, amount);

            uint256 newBalance = pal.balanceOf(locker);
            uint256 newStakedBalance = hpal.balanceOf(locker);
            uint256 newContractBalance = pal.balanceOf(address(hpal));
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalance, previousBalance - amount);
            assertEq(newStakedBalance, previousStakedBalance + amount);
            assertEq(newContractBalance, previousContractBalance + amount);
            assertEq(newTotalSupply, previousTotalSupply + amount);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, amount);
            assertEq(userLock.startTimestamp, block.timestamp);
            assertEq(userLock.duration, 31557600);
            assertEq(userLock.fromBlock, block.number);
            assertEq(newTotalLocked.total, previousTotalLocked.total + amount);
        }
    }

    function testStakeAndIncreaseLock(uint72 amount) public {
        address payable locker = users[0];

        pal.transfer(locker, 1000 * 1e18);

        vm.prank(locker);
        pal.approve(address(hpal), 1000 * 1e18);
            
        vm.prank(locker);
        hpal.stake(700 * 1e18);

        vm.prank(locker);
        hpal.lock(300 * 1e18, 31557600);

        uint256 previousBalance = pal.balanceOf(locker);
        uint256 previousStakedBalance = hpal.balanceOf(locker);
        uint256 previousContractBalance = pal.balanceOf(address(hpal));
        uint256 previousTotalSupply = hpal.totalSupply();

        HolyPaladinToken.UserLock memory previousLock = hpal.getUserLock(locker);
        HolyPaladinToken.TotalLock memory previousTotalLocked = hpal.getCurrentTotalLock();
        
        if(amount == 0){
            vm.expectRevert(
                bytes(""hPAL: Null amount"")
            );
            vm.prank(locker);
            hpal.stakeAndIncreaseLock(amount, 31557600);

            assertEq(pal.balanceOf(locker), previousBalance);
            assertEq(hpal.balanceOf(locker), previousStakedBalance);
            assertEq(pal.balanceOf(address(hpal)), previousContractBalance);
            assertEq(hpal.totalSupply(), previousTotalSupply);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(amount > previousBalance) {
            vm.expectRevert(
                bytes(""ERC20: transfer amount exceeds balance"")
            );
            vm.prank(locker);
            hpal.stakeAndIncreaseLock(amount, 31557600);

            assertEq(pal.balanceOf(locker), previousBalance);
            assertEq(hpal.balanceOf(locker), previousStakedBalance);
            assertEq(pal.balanceOf(address(hpal)), previousContractBalance);
            assertEq(hpal.totalSupply(), previousTotalSupply);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else{
            vm.prank(locker);
            uint256 returnAmount = hpal.stakeAndIncreaseLock(amount, 31557600);

            assertEq(returnAmount, amount);

            assertEq(pal.balanceOf(locker), previousBalance - amount);
            assertEq(hpal.balanceOf(locker), previousStakedBalance + amount);
            assertEq(pal.balanceOf(address(hpal)), previousContractBalance + amount);
            assertEq(hpal.totalSupply(), previousTotalSupply + amount);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount + amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, 31557600);
            assertEq(userLock.fromBlock, block.number);
            assertEq(newTotalLocked.total, previousTotalLocked.total + amount);

        }

    }

    function testTransferLock(uint72 amount) public {
        address payable locker = users[0];
        address payable receiver = users[1];

        uint256 stakingAmount = 700 * 1e18;

        pal.transfer(locker, 1000 * 1e18);

        vm.prank(locker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(locker);
        hpal.stake(stakingAmount);

        uint256 lockAmount = 300 * 1e18;

        vm.prank(locker);
        hpal.lock(lockAmount, 31557600);

        uint256 previousBalanceLocker = hpal.balanceOf(locker);
        uint256 previousAvailableBalanceLocker = hpal.availableBalanceOf(locker);
        uint256 previousBalanceReceiver = hpal.balanceOf(receiver);
        uint256 previousTotalSupply = hpal.totalSupply();

        if(amount > previousAvailableBalanceLocker) {
            vm.expectRevert(
                bytes(""hPAL: Available balance too low"")
            );
            vm.prank(locker);
            hpal.transfer(receiver, amount);

            uint256 newBalanceLocker = hpal.balanceOf(locker);
            uint256 newAvailableBalanceLocker = hpal.availableBalanceOf(locker);
            uint256 newBalanceReceiver = hpal.balanceOf(receiver);
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalanceLocker, previousBalanceLocker);
            assertEq(newAvailableBalanceLocker, previousAvailableBalanceLocker);
            assertEq(newBalanceReceiver, previousBalanceReceiver);
            assertEq(newTotalSupply, previousTotalSupply);
        }
        else{
            vm.prank(locker);
            bool success = hpal.transfer(receiver, amount);

            assertTrue(success);

            uint256 newBalanceLocker = hpal.balanceOf(locker);
            uint256 newAvailableBalanceLocker = hpal.availableBalanceOf(locker);
            uint256 newBalanceReceiver = hpal.balanceOf(receiver);
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalanceLocker, previousBalanceLocker - amount);
            assertEq(newAvailableBalanceLocker, previousAvailableBalanceLocker - amount);
            assertEq(newBalanceReceiver, previousBalanceReceiver + amount);
            assertEq(newTotalSupply, previousTotalSupply);

        }
    }

}",7126
RealWorld_BA_105_HolyPaladinToken_RealWord_20240828074926.log,105,HolyPaladinToken,0,0,0,,0.0,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import ""./open-zeppelin/ERC20.sol"";
import ""./open-zeppelin/utils/Ownable.sol"";
import ""./open-zeppelin/interfaces/IERC20.sol"";
import ""./open-zeppelin/libraries/SafeERC20.sol"";
import ""./open-zeppelin/utils/Math.sol"";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20(""Holy Paladin Token"", ""hPAL""), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, ""hPAL: No balance"");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, ""hPAL: cannot kick yourself"");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, ""hPAL: incorrect amount"");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), ""hPAL: Available balance too low"");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, ""hPAL: invalid blockNumber"");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, ""hPAL: invalid blockNumber"");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, ""hPAL: Null amount"");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, ""hPAL: Null amount"");
        require(receiver != address(0), ""hPAL: Address Zero"");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), ""hPAL: Insufficient cooldown"");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, ""hPAL: unstake period expired"");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, ""hPAL: Null amount"");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, ""hPAL: Amount over balance"");
        require(duration >= MIN_LOCK_DURATION, ""hPAL: Lock duration under min"");
        require(duration <= MAX_LOCK_DURATION, ""hPAL: Lock duration over max"");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,""hPAL: smaller amount"");
                require(duration >=  currentUserLock.duration,""hPAL: smaller duration"");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, ""hPAL: No Lock"");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, ""hPAL: Not expired"");
        require(currentUserLock.amount > 0, ""hPAL: No Lock"");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), ""hPAL: Address Zero"");
        require(userLocks[user].length > 0, ""hPAL: No Lock"");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, ""hPAL: Not expired"");
        require(currentUserLock.amount > 0, ""hPAL: No Lock"");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, ""hPAL: Not kickable"");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, ""hPAL: Not emergency"");

        require(amount > 0, ""hPAL: Null amount"");
        require(receiver != address(0), ""hPAL: Address Zero"");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}",12522
RealWorld_BA_106_Vm_RealWord_20240828085026.log,106,Vm,16884,5219,22103,73.0,0.1888,"// SPDX-License-Identifier: Apache 2.0 
// https://github.com/brockelmore/forge-std/blob/master/LICENSE-APACHE
pragma solidity >=0.6.0;
pragma experimental ABIEncoderV2;

interface Vm {
    // Set block.timestamp (newTimestamp)
    function warp(uint256) external;
    // Set block.height (newHeight)
    function roll(uint256) external;
    // Set block.basefee (newBasefee)
    function fee(uint256) external;
    // Loads a storage slot from an address (who, slot)
    function load(address,bytes32) external returns (bytes32);
    // Stores a value to an address' storage slot, (who, slot, value)
    function store(address,bytes32,bytes32) external;
    // Signs data, (privateKey, digest) => (v, r, s)
    function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);
    // Gets address for a given private key, (privateKey) => (address)
    function addr(uint256) external returns (address);
    // Performs a foreign function call via terminal, (stringInputs) => (result)
    function ffi(string[] calldata) external returns (bytes memory);
    // Sets the *next* call's msg.sender to be the input address
    function prank(address) external;
    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called
    function startPrank(address) external;
    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input
    function prank(address,address) external;
    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, 
    // and the tx.origin to be the second input
    function startPrank(address,address) external;
    // Resets subsequent calls' msg.sender to be `address(this)`
    function stopPrank() external;
    // Sets an address' balance, (who, newBalance)
    function deal(address, uint256) external;
    // Sets an address' code, (who, newCode)
    function etch(address, bytes calldata) external;
    // Expects an error on next call
    function expectRevert(bytes calldata) external;
    function expectRevert(bytes4) external;
    function expectRevert() external;
    // Record all storage reads and writes
    function record() external;
    // Gets all accessed reads and write slot from a recording session, for a given address
    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);
    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).
    // Call this function, then emit an event, then call a function. Internally after the call, we check if
    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)
    function expectEmit(bool,bool,bool,bool) external;
    // Mocks a call to an address, returning specified data.
    // Calldata can either be strict or a partial match, e.g. if you only
    // pass a Solidity selector to the expected calldata, then the entire Solidity
    // function will be mocked.
    function mockCall(address,bytes calldata,bytes calldata) external;
    // Clears all mocked calls
    function clearMockedCalls() external;
    // Expect a call to an address with the specified calldata.
    // Calldata can either be strict or a partial match
    function expectCall(address,bytes calldata) external;
    // Gets the code from an artifact file. Takes in the relative path to the json file
    function getCode(string calldata) external returns (bytes memory);
    // Labels an address in call traces
    function label(address, string calldata) external;
    // If the condition is false, discard this run's fuzz inputs and generate new ones
    function assume(bool) external;
}",867
RealWorld_BA_106_NFTLoanFacilitator_RealWord_20240828084249.log,106,NFTLoanFacilitator,56111,5356,61467,86.0,0.387675,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.12;

import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import {SafeTransferLib, ERC20} from ""@rari-capital/solmate/src/utils/SafeTransferLib.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

import {INFTLoanFacilitator} from './interfaces/INFTLoanFacilitator.sol';
import {IERC721Mintable} from './interfaces/IERC721Mintable.sol';
import {ILendTicket} from './interfaces/ILendTicket.sol';

contract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {
    using SafeTransferLib for ERC20;

    // ==== constants ====

    /** 
     * See {INFTLoanFacilitator-INTEREST_RATE_DECIMALS}.     
     * @dev lowest non-zero APR possible = (1/10^3) = 0.001 = 0.1%
     */
    uint8 public constant override INTEREST_RATE_DECIMALS = 3;

    /// See {INFTLoanFacilitator-SCALAR}.
    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS;

    
    // ==== state variables ====

    /// See {INFTLoanFacilitator-originationFeeRate}.
    /// @dev starts at 1%
    uint256 public override originationFeeRate = 10 ** (INTEREST_RATE_DECIMALS - 2);

    /// See {INFTLoanFacilitator-requiredImprovementRate}.
    /// @dev starts at 10%
    uint256 public override requiredImprovementRate = 10 ** (INTEREST_RATE_DECIMALS - 1);

    /// See {INFTLoanFacilitator-lendTicketContract}.
    address public override lendTicketContract;

    /// See {INFTLoanFacilitator-borrowTicketContract}.
    address public override borrowTicketContract;

    /// See {INFTLoanFacilitator-loanInfo}.
    mapping(uint256 => Loan) public loanInfo;

    /// @dev tracks loan count
    uint256 private _nonce = 1;

    
    // ==== modifiers ====

    modifier notClosed(uint256 loanId) { 
        require(!loanInfo[loanId].closed, ""NFTLoanFacilitator: loan closed"");
        _; 
    }


    // ==== constructor ====

    constructor(address _manager) {
        transferOwnership(_manager);
    }

    
    // ==== state changing external functions ====

    /// See {INFTLoanFacilitator-createLoan}.
    function createLoan(
        uint256 collateralTokenId,
        address collateralContractAddress,
        uint16 maxPerAnumInterest,
        uint128 minLoanAmount,
        address loanAssetContractAddress,
        uint32 minDurationSeconds,
        address mintBorrowTicketTo
    )
        external
        override
        returns (uint256 id) 
    {
        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');
        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');
        require(collateralContractAddress != lendTicketContract,
        'NFTLoanFacilitator: cannot use tickets as collateral');
        require(collateralContractAddress != borrowTicketContract, 
        'NFTLoanFacilitator: cannot use tickets as collateral');
        
        IERC721(collateralContractAddress).transferFrom(msg.sender, address(this), collateralTokenId);

        unchecked {
            id = _nonce++;
        }

        Loan storage loan = loanInfo[id];
        loan.loanAssetContractAddress = loanAssetContractAddress;
        loan.loanAmount = minLoanAmount;
        loan.collateralTokenId = collateralTokenId;
        loan.collateralContractAddress = collateralContractAddress;
        loan.perAnumInterestRate = maxPerAnumInterest;
        loan.durationSeconds = minDurationSeconds;
        
        IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);
        emit CreateLoan(
            id,
            msg.sender,
            collateralTokenId,
            collateralContractAddress,
            maxPerAnumInterest,
            loanAssetContractAddress,
            minLoanAmount,
            minDurationSeconds
        );
    }

    /// See {INFTLoanFacilitator-closeLoan}.
    function closeLoan(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {
        require(IERC721(borrowTicketContract).ownerOf(loanId) == msg.sender,
        ""NFTLoanFacilitator: borrow ticket holder only"");

        Loan storage loan = loanInfo[loanId];
        require(loan.lastAccumulatedTimestamp == 0, ""NFTLoanFacilitator: has lender, use repayAndCloseLoan"");
        
        loan.closed = true;
        IERC721(loan.collateralContractAddress).transferFrom(address(this), sendCollateralTo, loan.collateralTokenId);
        emit Close(loanId);
    }

    /// See {INFTLoanFacilitator-lend}.
    function lend(
        uint256 loanId,
        uint16 interestRate,
        uint128 amount,
        uint32 durationSeconds,
        address sendLendTicketTo
    )
        external
        override
        notClosed(loanId)
    {
        Loan storage loan = loanInfo[loanId];
        
        if (loan.lastAccumulatedTimestamp == 0) {
            address loanAssetContractAddress = loan.loanAssetContractAddress;
            require(loanAssetContractAddress != address(0), ""NFTLoanFacilitator: invalid loan"");

            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');
            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');
            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');
        
            loan.perAnumInterestRate = interestRate;
            loan.lastAccumulatedTimestamp = uint40(block.timestamp);
            loan.durationSeconds = durationSeconds;
            loan.loanAmount = amount;

            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);
            uint256 facilitatorTake = amount * originationFeeRate / SCALAR;
            ERC20(loanAssetContractAddress).safeTransfer(
                IERC721(borrowTicketContract).ownerOf(loanId),
                amount - facilitatorTake
            );
            IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);
        } else {
            uint256 previousLoanAmount = loan.loanAmount;
            // will underflow if amount < previousAmount
            uint256 amountIncrease = amount - previousLoanAmount;

            {
                uint256 previousInterestRate = loan.perAnumInterestRate;
                uint256 previousDurationSeconds = loan.durationSeconds;

                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');
                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');

                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease
                || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds 
                || (previousInterestRate != 0 // do not allow rate improvement if rate already 0
                    && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), 
                ""NFTLoanFacilitator: proposed terms must be better than existing terms"");
            }

            uint256 accumulatedInterest = _interestOwed(
                previousLoanAmount,
                loan.lastAccumulatedTimestamp,
                loan.perAnumInterestRate,
                loan.accumulatedInterest
            );

            require(accumulatedInterest <= type(uint128).max,
            ""NFTLoanFacilitator: accumulated interest exceeds uint128"");

            loan.perAnumInterestRate = interestRate;
            loan.lastAccumulatedTimestamp = uint40(block.timestamp);
            loan.durationSeconds = durationSeconds;
            loan.loanAmount = amount;
            loan.accumulatedInterest = uint128(accumulatedInterest);

            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);
            if (amountIncrease > 0) {
                address loanAssetContractAddress = loan.loanAssetContractAddress;
                ERC20(loanAssetContractAddress).safeTransferFrom(
                    msg.sender,
                    address(this),
                    amount + accumulatedInterest
                );
                ERC20(loanAssetContractAddress).safeTransfer(
                    currentLoanOwner,
                    accumulatedInterest + previousLoanAmount
                );
                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);
                ERC20(loanAssetContractAddress).safeTransfer(
                    IERC721(borrowTicketContract).ownerOf(loanId),
                    amountIncrease - facilitatorTake
                );
            } else {
                ERC20(loan.loanAssetContractAddress).safeTransferFrom(
                    msg.sender,
                    currentLoanOwner,
                    accumulatedInterest + previousLoanAmount
                );
            }
            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);
            
            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);
        }

        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);
    }

    /// See {INFTLoanFacilitator-repayAndCloseLoan}.
    function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {
        Loan storage loan = loanInfo[loanId];

        uint256 interest = _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
        address lender = IERC721(lendTicketContract).ownerOf(loanId);
        loan.closed = true;
        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);
        IERC721(loan.collateralContractAddress).safeTransferFrom(
            address(this),
            IERC721(borrowTicketContract).ownerOf(loanId),
            loan.collateralTokenId
        );

        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);
        emit Close(loanId);
    }

    /// See {INFTLoanFacilitator-seizeCollateral}.
    function seizeCollateral(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {
        require(IERC721(lendTicketContract).ownerOf(loanId) == msg.sender, 
        ""NFTLoanFacilitator: lend ticket holder only"");

        Loan storage loan = loanInfo[loanId];
        require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp,
        ""NFTLoanFacilitator: payment is not late"");

        loan.closed = true;
        IERC721(loan.collateralContractAddress).safeTransferFrom(
            address(this),
            sendCollateralTo,
            loan.collateralTokenId
        );

        emit SeizeCollateral(loanId);
        emit Close(loanId);
    }

    
    // === owner state changing ===

    /**
     * @notice Sets lendTicketContract to _contract
     * @dev cannot be set if lendTicketContract is already set
     */
    function setLendTicketContract(address _contract) external onlyOwner {
        require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set');

        lendTicketContract = _contract;
    }

    /**
     * @notice Sets borrowTicketContract to _contract
     * @dev cannot be set if borrowTicketContract is already set
     */
    function setBorrowTicketContract(address _contract) external onlyOwner {
        require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set');

        borrowTicketContract = _contract;
    }

    /// @notice Transfers `amount` of loan origination fees for `asset` to `to`
    function withdrawOriginationFees(address asset, uint256 amount, address to) external onlyOwner {
        ERC20(asset).safeTransfer(to, amount);

        emit WithdrawOriginationFees(asset, amount, to);
    }

    /**
     * @notice Updates originationFeeRate the faciliator keeps of each loan amount
     * @dev Cannot be set higher than 5%
     */
    function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {
        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), ""NFTLoanFacilitator: max fee 5%"");
        
        originationFeeRate = _originationFeeRate;

        emit UpdateOriginationFeeRate(_originationFeeRate);
    }

    /**
     * @notice updates the percent improvement required of at least one loan term when buying out lender 
     * a loan that already has a lender. E.g. setting this value to 10 means duration or amount
     * must be 10% higher or interest rate must be 10% lower. 
     * @dev Cannot be 0.
     */
    function updateRequiredImprovementRate(uint256 _improvementRate) external onlyOwner {
        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');

        requiredImprovementRate = _improvementRate;

        emit UpdateRequiredImprovementRate(_improvementRate);
    }

    
    // ==== external view ====

    /// See {INFTLoanFacilitator-loanInfoStruct}.
    function loanInfoStruct(uint256 loanId) external view override returns (Loan memory) {
        return loanInfo[loanId];
    }

    /// See {INFTLoanFacilitator-totalOwed}.
    function totalOwed(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        if (loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;

        return loanInfo[loanId].loanAmount + _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
    }

    /// See {INFTLoanFacilitator-interestOwed}.
    function interestOwed(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        if(loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;

        return _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
    }

    /// See {INFTLoanFacilitator-loanEndSeconds}.
    function loanEndSeconds(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        return loan.durationSeconds + loan.lastAccumulatedTimestamp;
    }

    
    // === private ===

    /// @dev Returns the total interest owed on loan
    function _interestOwed(
        uint256 loanAmount,
        uint256 lastAccumulatedTimestamp,
        uint256 perAnumInterestRate,
        uint256 accumulatedInterest
    ) 
        internal 
        view 
        returns (uint256) 
    {
        return loanAmount
            * (block.timestamp - lastAccumulatedTimestamp)
            * (perAnumInterestRate * 1e18 / 365 days)
            / 1e21 // SCALAR * 1e18
            + accumulatedInterest;
    }
}",3357
RealWorld_BA_106_IERC721Mintable_RealWord_20240828090801.log,106,IERC721Mintable,4572,3947,8519,72.0,0.1018,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

interface IERC721Mintable {
    /**
     * @notice mints an ERC721 token of tokenId to the to address
     * @dev only callable by nft loan facilitator
     * @param to The address to send the token to
     * @param tokenId The id of the token to mint
     */
    function mint(address to, uint256 tokenId) external;
}",97
RealWorld_BA_106_BokkyPooBahsDateTimeLibrary_RealWord_20240828090508.log,106,BokkyPooBahsDateTimeLibrary,59185,5492,64677,94.0,0.405765,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

// ----------------------------------------------------------------------------
// BokkyPooBah's DateTime Library v1.01
//
// A gas-efficient Solidity date and time library
//
// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary
//
// Tested date range 1970/01/01 to 2345/12/31
//
// Conventions:
// Unit      | Range         | Notes
// :-------- |:-------------:|:-----
// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC
// year      | 1970 ... 2345 |
// month     | 1 ... 12      |
// day       | 1 ... 31      |
// hour      | 0 ... 23      |
// minute    | 0 ... 59      |
// second    | 0 ... 59      |
// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday
//
//
// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.
// ----------------------------------------------------------------------------

library BokkyPooBahsDateTimeLibrary {

    uint constant SECONDS_PER_DAY = 24 * 60 * 60;
    uint constant SECONDS_PER_HOUR = 60 * 60;
    uint constant SECONDS_PER_MINUTE = 60;
    int constant OFFSET19700101 = 2440588;

    uint constant DOW_MON = 1;
    uint constant DOW_TUE = 2;
    uint constant DOW_WED = 3;
    uint constant DOW_THU = 4;
    uint constant DOW_FRI = 5;
    uint constant DOW_SAT = 6;
    uint constant DOW_SUN = 7;

    // ------------------------------------------------------------------------
    // Calculate the number of days from 1970/01/01 to year/month/day using
    // the date conversion algorithm from
    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php
    // and subtracting the offset 2440588 so that 1970/01/01 is day 0
    //
    // days = day
    //      - 32075
    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4
    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12
    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4
    //      - offset
    // ------------------------------------------------------------------------
    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {
        require(year >= 1970);
        int _year = int(year);
        int _month = int(month);
        int _day = int(day);

        int __days = _day
          - 32075
          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4
          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12
          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4
          - OFFSET19700101;

        _days = uint(__days);
    }

    // ------------------------------------------------------------------------
    // Calculate year/month/day from the number of days since 1970/01/01 using
    // the date conversion algorithm from
    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php
    // and adding the offset 2440588 so that 1970/01/01 is day 0
    //
    // int L = days + 68569 + offset
    // int N = 4 * L / 146097
    // L = L - (146097 * N + 3) / 4
    // year = 4000 * (L + 1) / 1461001
    // L = L - 1461 * year / 4 + 31
    // month = 80 * L / 2447
    // dd = L - 2447 * month / 80
    // L = month / 11
    // month = month + 2 - 12 * L
    // year = 100 * (N - 49) + year + L
    // ------------------------------------------------------------------------
    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {
        int __days = int(_days);

        int L = __days + 68569 + OFFSET19700101;
        int N = 4 * L / 146097;
        L = L - (146097 * N + 3) / 4;
        int _year = 4000 * (L + 1) / 1461001;
        L = L - 1461 * _year / 4 + 31;
        int _month = 80 * L / 2447;
        int _day = L - 2447 * _month / 80;
        L = _month / 11;
        _month = _month + 2 - 12 * L;
        _year = 100 * (N - 49) + _year + L;

        year = uint(_year);
        month = uint(_month);
        day = uint(_day);
    }

    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {
        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;
    }
    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {
        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;
    }
    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }
    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        uint secs = timestamp % SECONDS_PER_DAY;
        hour = secs / SECONDS_PER_HOUR;
        secs = secs % SECONDS_PER_HOUR;
        minute = secs / SECONDS_PER_MINUTE;
        second = secs % SECONDS_PER_MINUTE;
    }

    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {
        if (year >= 1970 && month > 0 && month <= 12) {
            uint daysInMonth = _getDaysInMonth(year, month);
            if (day > 0 && day <= daysInMonth) {
                valid = true;
            }
        }
    }
    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {
        if (isValidDate(year, month, day)) {
            if (hour < 24 && minute < 60 && second < 60) {
                valid = true;
            }
        }
    }
    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {
        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);
        leapYear = _isLeapYear(year);
    }
    function _isLeapYear(uint year) internal pure returns (bool leapYear) {
        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);
    }
    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {
        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;
    }
    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {
        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;
    }
    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {
        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);
        daysInMonth = _getDaysInMonth(year, month);
    }
    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {
        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {
            daysInMonth = 31;
        } else if (month != 2) {
            daysInMonth = 30;
        } else {
            daysInMonth = _isLeapYear(year) ? 29 : 28;
        }
    }
    // 1 = Monday, 7 = Sunday
    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {
        uint _days = timestamp / SECONDS_PER_DAY;
        dayOfWeek = (_days + 3) % 7 + 1;
    }

    function getYear(uint timestamp) internal pure returns (uint year) {
        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }
    function getMonth(uint timestamp) internal pure returns (uint month) {
        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }
    function getDay(uint timestamp) internal pure returns (uint day) {
        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }
    function getHour(uint timestamp) internal pure returns (uint hour) {
        uint secs = timestamp % SECONDS_PER_DAY;
        hour = secs / SECONDS_PER_HOUR;
    }
    function getMinute(uint timestamp) internal pure returns (uint minute) {
        uint secs = timestamp % SECONDS_PER_HOUR;
        minute = secs / SECONDS_PER_MINUTE;
    }
    function getSecond(uint timestamp) internal pure returns (uint second) {
        second = timestamp % SECONDS_PER_MINUTE;
    }

    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {
        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        year += _years;
        uint daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;
        require(newTimestamp >= timestamp);
    }
    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {
        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        month += _months;
        year += (month - 1) / 12;
        month = (month - 1) % 12 + 1;
        uint daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;
        require(newTimestamp >= timestamp);
    }
    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp + _days * SECONDS_PER_DAY;
        require(newTimestamp >= timestamp);
    }
    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;
        require(newTimestamp >= timestamp);
    }
    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;
        require(newTimestamp >= timestamp);
    }
    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp + _seconds;
        require(newTimestamp >= timestamp);
    }

    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {
        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        year -= _years;
        uint daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;
        require(newTimestamp <= timestamp);
    }
    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {
        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        uint yearMonth = year * 12 + (month - 1) - _months;
        year = yearMonth / 12;
        month = yearMonth % 12 + 1;
        uint daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;
        require(newTimestamp <= timestamp);
    }
    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp - _days * SECONDS_PER_DAY;
        require(newTimestamp <= timestamp);
    }
    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;
        require(newTimestamp <= timestamp);
    }
    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;
        require(newTimestamp <= timestamp);
    }
    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp - _seconds;
        require(newTimestamp <= timestamp);
    }

    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {
        require(fromTimestamp <= toTimestamp);
        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);
        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);
        _years = toYear - fromYear;
    }
    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {
        require(fromTimestamp <= toTimestamp);
        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);
        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);
        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;
    }
    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {
        require(fromTimestamp <= toTimestamp);
        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;
    }
    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {
        require(fromTimestamp <= toTimestamp);
        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;
    }
    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {
        require(fromTimestamp <= toTimestamp);
        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;
    }
    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {
        require(fromTimestamp <= toTimestamp);
        _seconds = toTimestamp - fromTimestamp;
    }
}",3464
RealWorld_BA_106_PopulateSVGParams_RealWord_20240828090341.log,106,PopulateSVGParams,21337,6098,27435,85.0,0.228645,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/utils/Strings.sol"";
import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";

import './BokkyPooBahsDateTimeLibrary.sol';
import './UintStrings.sol';
import '../../NFTLoanFacilitator.sol';
import '../../interfaces/IERC20Metadata.sol';
import './HexStrings.sol';
import './NFTLoanTicketSVG.sol';


library PopulateSVGParams{
    /**
     * @notice Populates and returns the passed `svgParams` with loan info retrieved from
     * `nftLoanFacilitator` for `id`, the loan id
     * @param svgParams The svg params to populate, which already has `nftType` populated from NFTLoansTicketDescriptor
     * @param nftLoanFacilitator The loan facilitator contract to get loan info from for loan `id`
     * @param id The id of the loan
     * @return `svgParams`, with all values now populated
     */
    function populate(NFTLoanTicketSVG.SVGParams memory svgParams, NFTLoanFacilitator nftLoanFacilitator, uint256 id)
        internal
        view
        returns (NFTLoanTicketSVG.SVGParams memory)
    {
        (bool closed, uint256 perAnumInterestRate,
        uint256 durationSeconds, uint256 lastAccumulatedTimestamp,
        address collateralAddress, address loanAsset, ,
        uint256 loanAmount, uint256 collateralID) = nftLoanFacilitator.loanInfo(id);

        svgParams.id = Strings.toString(id);
        svgParams.status = loanStatus(lastAccumulatedTimestamp, durationSeconds, closed);
        svgParams.interestRate = interestRateString(nftLoanFacilitator, perAnumInterestRate); 
        svgParams.loanAssetContract = HexStrings.toHexString(uint160(loanAsset), 20);
        svgParams.loanAssetSymbol = loanAssetSymbol(loanAsset);
        svgParams.collateralContract = HexStrings.toHexString(uint160(collateralAddress), 20);
        svgParams.collateralContractPartial = HexStrings.partialHexString(uint160(collateralAddress), 10, 40);
        svgParams.collateralAssetSymbol = collateralAssetSymbol(collateralAddress);
        svgParams.collateralId = Strings.toString(collateralID);
        svgParams.loanAmount = loanAmountString(loanAmount, loanAsset);
        svgParams.interestAccrued = accruedInterest(nftLoanFacilitator, id, loanAsset);
        svgParams.durationDays = Strings.toString(durationSeconds / (24 * 60 * 60));
        svgParams.endDateTime = lastAccumulatedTimestamp == 0 ? ""n/a"" 
        : endDateTime(lastAccumulatedTimestamp + durationSeconds);
        
        return svgParams;
    }

    function interestRateString(NFTLoanFacilitator nftLoanFacilitator, uint256 perAnumInterestRate) 
        private 
        view 
        returns (string memory)
    {
        return UintStrings.decimalString(
            perAnumInterestRate,
            nftLoanFacilitator.INTEREST_RATE_DECIMALS() - 2,
            true
            );
    }

    function loanAmountString(uint256 amount, address asset) private view returns (string memory) {
        return UintStrings.decimalString(amount, IERC20Metadata(asset).decimals(), false);
    }

    function loanAssetSymbol(address asset) private view returns (string memory) {
        return IERC20Metadata(asset).symbol();
    }

    function collateralAssetSymbol(address asset) private view returns (string memory) {
        return ERC721(asset).symbol();
    }

    function accruedInterest(NFTLoanFacilitator nftLoanFacilitator, uint256 loanId, address loanAsset) 
        private 
        view 
        returns (string memory)
    {
        return UintStrings.decimalString(
            nftLoanFacilitator.interestOwed(loanId),
            IERC20Metadata(loanAsset).decimals(),
            false);
    }

    function loanStatus(uint256 lastAccumulatedTimestamp, uint256 durationSeconds, bool closed) 
        view 
        private 
        returns (string memory)
    {
        if (lastAccumulatedTimestamp == 0) return ""awaiting lender"";

        if (closed) return ""closed"";

        if (block.timestamp > (lastAccumulatedTimestamp + durationSeconds)) return ""past due"";

        return ""accruing interest"";
    }

    /** 
     * @param endDateSeconds The unix seconds timestamp of the loan end date
     * @return a string representation of the UTC end date and time of the loan,
     * in format YYYY-MM-DD HH:MM:SS
     */
    function endDateTime(uint256 endDateSeconds) private pure returns (string memory) {
        (uint year, uint month, 
        uint day, uint hour, 
        uint minute, uint second) = BokkyPooBahsDateTimeLibrary.timestampToDateTime(endDateSeconds);
        return string.concat(
                Strings.toString(year),
                '-',
                Strings.toString(month),
                '-',
                Strings.toString(day),
                ' ',
                Strings.toString(hour),
                ':',
                Strings.toString(minute),
                ':',
                Strings.toString(second),
                ' UTC'
        );
    } 
}",1117
RealWorld_BA_106_BorrowTicketSVGHelper_RealWord_20240828085939.log,106,BorrowTicketSVGHelper,9197,5095,14292,76.0,0.147885,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import './TicketTypeSpecificSVGHelper.sol';

contract BorrowTicketSVGHelper is TicketTypeSpecificSVGHelper {
    /**
     * @dev Returns SVG styles where the primary background color is derived
     * from the collateral asset address and the secondary background color 
     * is derived from the loan asset address
     */
    function backgroundColorsStyles(
        string memory collateralAsset,
        string memory loanAsset
    ) 
        external 
        pure
        override 
        returns (string memory)
    {
        return colorStyles(collateralAsset, loanAsset);
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function ticketIdXCoordinate() external pure override returns (string memory) {
        return '134';
    }
    
    /// See {ITicketTypeSpecificSVGHelper}
    function backgroundTitleRectsXTranslate() external pure override returns (string memory) {
        return '31';
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function titlesPositionClass() external pure override returns (string memory) {
        return 'right';
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function titlesXTranslate() external pure override returns (string memory) {
        return '121';
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function backgroundValueRectsXTranslate() external pure override returns (string memory) {
        return '129';
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function alignmentClass() external pure override returns (string memory) {
        return 'left';
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function valuesXTranslate() external pure override returns (string memory) {
        return '136';
    }
}",369
RealWorld_BA_106_NFTLoanTicket_RealWord_20240828084135.log,106,NFTLoanTicket,9208,5351,14559,72.0,0.15306,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.12;

import {ERC721} from ""@rari-capital/solmate/src/tokens/ERC721.sol"";

import {NFTLoanFacilitator} from './NFTLoanFacilitator.sol';
import {NFTLoansTicketDescriptor} from './descriptors/NFTLoansTicketDescriptor.sol';
import {IERC721Mintable} from './interfaces/IERC721Mintable.sol';

contract NFTLoanTicket is ERC721, IERC721Mintable {
    NFTLoanFacilitator public immutable nftLoanFacilitator;
    NFTLoansTicketDescriptor public immutable descriptor;

    modifier loanFacilitatorOnly() { 
        require(msg.sender == address(nftLoanFacilitator), ""NFTLoanTicket: only loan facilitator"");
        _; 
    }

    /// @dev Sets the values for {name} and {symbol} and {nftLoanFacilitator} and {descriptor}.
    constructor(
        string memory name, 
        string memory symbol, 
        NFTLoanFacilitator _nftLoanFacilitator, 
        NFTLoansTicketDescriptor _descriptor
    ) 
        ERC721(name, symbol) 
    {
        nftLoanFacilitator = _nftLoanFacilitator;
        descriptor = _descriptor;
    }

    /// See {IERC721Mintable-mint}.
    function mint(address to, uint256 tokenId) external override loanFacilitatorOnly {
        _mint(to, tokenId);
    }

    /// @notice returns a base64 encoded data uri containing the token metadata in JSON format
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        return descriptor.uri(nftLoanFacilitator, tokenId);
    }
}",385
RealWorld_BA_106_NFTLoansTicketDescriptor_RealWord_20240828085423.log,106,NFTLoansTicketDescriptor,15292,5746,21038,95.0,0.19138,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import 'base64-sol/base64.sol';
import '../NFTLoanFacilitator.sol';
import './libraries/NFTLoanTicketSVG.sol';
import './libraries/PopulateSVGParams.sol';

contract NFTLoansTicketDescriptor {
    // Lend or Borrow 
    string public nftType;
    ITicketTypeSpecificSVGHelper immutable public svgHelper;

    /// @dev Initializes the contract by setting a `nftType` and `svgHelper`
    constructor(string memory _nftType, ITicketTypeSpecificSVGHelper _svgHelper) {
        nftType = _nftType;
        svgHelper = _svgHelper;
    }

    /**
     * @dev Returns a string which is a data uri of base64 encoded JSON,
     * the JSON contains the token metadata: name, description, image
     * which reflect information about `id` loan in `nftLoanFacilitator`
     */ 
    function uri(NFTLoanFacilitator nftLoanFacilitator, uint256 id)
        external
        view
        returns (string memory)
    {
        NFTLoanTicketSVG.SVGParams memory svgParams;
        svgParams.nftType = nftType;
        svgParams = PopulateSVGParams.populate(svgParams, nftLoanFacilitator, id);
        
        return generateDescriptor(svgParams);
    }

    /**
     * @dev Returns a string which is a data uri of base64 encoded JSON,
     * the JSON contains the token metadata: name, description, image.
     * The metadata values come from `svgParams`
     */ 
    function generateDescriptor(NFTLoanTicketSVG.SVGParams memory svgParams)
        private
        view
        returns (string memory)
    {
        return string.concat(
            'data:application/json;base64,',
            Base64.encode(
                bytes(
                    string.concat(
                        '{""name"":""',
                        svgParams.nftType,
                        ' ticket',
                        ' #',
                        svgParams.id,
                        '"", ""description"":""',
                        generateDescription(svgParams.id),
                        generateDescriptionDetails(
                            svgParams.loanAssetContract,
                            svgParams.loanAssetSymbol,
                            svgParams.collateralContract, 
                            svgParams.collateralAssetSymbol,
                            svgParams.collateralId),
                        '"", ""image"": ""',
                        'data:image/svg+xml;base64,',
                        Base64.encode(bytes(NFTLoanTicketSVG.generateSVG(svgParams, svgHelper))),
                        '""}'
                    )
                )
            )
        );
    }

    /// @dev Returns string, ticket type (borrow or lend) specific description      
    function generateDescription(string memory loanId) internal pure virtual returns (string memory) {}

    /// @dev Returns string, important info about the loan that this ticket is related to 
    function generateDescriptionDetails(
        string memory loanAsset,
        string memory loanAssetSymbol,
        string memory collateralAsset,
        string memory collateralAssetSymbol,
        string memory collateralAssetId
    ) 
        private 
        pure 
        returns (string memory) 
    {
        return string.concat(
            '\\n\\nCollateral Address: ',
            collateralAsset,
            ' (',
            collateralAssetSymbol,
            ')\\n\\n',
            'Collateral ID: ',
            collateralAssetId,
            '\\n\\n',
            'Loan Asset Address: ',
            loanAsset,
            ' (',
            loanAssetSymbol,
            ')\\n\\n',
            'WARNING: Do your own research to verify the legitimacy of the assets related to this ticket'
        );
    }
}",747
RealWorld_BA_106_CryptoPunks_RealWord_20240828084624.log,106,CryptoPunks,6937,5607,12544,77.0,0.146825,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/utils/Strings.sol"";

contract CryptoPunks is ERC721 {
    using Strings for uint256;

    uint256 private _nonce = 999;

	constructor() ERC721(""CryptoPunks"", ""PUNKS"") {
    }

    function mint() external returns (uint256 id) {
        id = mintTo(msg.sender);
    }

    function mintTo(address to) public returns (uint256) {
        _safeMint(to, ++_nonce, """");
        return _nonce;
    }

    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), ""ERC721Metadata: URI query for nonexistent token"");

        return """";
    }
}",183
RealWorld_BA_106_NFTLoanTicketSVG_RealWord_20240828090219.log,106,NFTLoanTicketSVG,35579,5359,40938,80.0,0.285075,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;
import 'base64-sol/base64.sol';
import '../../interfaces/ITicketTypeSpecificSVGHelper.sol';


library NFTLoanTicketSVG {

    struct SVGParams{
        // ""Borrow"" or ""Lend""
        string nftType;
        // The Token Id, which is also the Id of the associated loan in NFTLoanFacilitator
        string id;
        // Human readable status, see {PopulateSVGParams-loanStatus}
        string status;
        // The approximate APR loan interest rate
        string interestRate;
        // The contract address of the ERC20 loan asset
        string loanAssetContract;
        // The symbol of the ERC20 loan asset
        string loanAssetSymbol;
        // The contract address of the ERC721 collateral asset
        string collateralContract;
        // The contract address of the ERC721 collateral asset, shortened for display
        string collateralContractPartial;
        // Symbol of the ERC721 collateral asset
        string collateralAssetSymbol;
        // TokenId of the ERC721 collateral asset
        string collateralId;
        // The loan amount, in loan asset units
        string loanAmount;
        // The interest accrued so far on the loan, in loan asset units
        string interestAccrued;
        // The loan duration in days, 0 if duration is less than 1 day
        string durationDays;
        // The UTC end date and time of the loan, 'n/a' if loan does not have lender
        string endDateTime;
    }

    /// @notice returns an SVG image as a string. The SVG image is specific to the SVGParams
    function generateSVG(SVGParams memory params, ITicketTypeSpecificSVGHelper typeSpecificHelper) 
    internal 
    pure 
    returns (string memory svg) 
    {
        return string.concat(
            '<svg version=""1.1"" id=""Layer_1"" xmlns=""http://www.w3.org/2000/svg"" ',
            'xmlns:xlink=""http://www.w3.org/1999/xlink"" x=""0px"" y=""0px"" ',
            'viewBox=""0 0 300 300"" style=""enable-background:new 0 0 300 300;"" xml:space=""preserve"">',
            stylesAndBackground(
                typeSpecificHelper,
                params.id,
                params.loanAssetContract,
                params.collateralContract
            ),
            staticValues(params.nftType, typeSpecificHelper),
            dynamicValues(params, typeSpecificHelper),
            dynamicValues2(params),
            '</svg>'
        );
    }

    function stylesAndBackground(
        ITicketTypeSpecificSVGHelper typeSpecificHelper,
        string memory id, 
        string memory loanAsset,
        string memory collateralAsset
    ) 
        private 
        pure
        returns (string memory) 
    {
        return string.concat(
            '<style type=""text/css"">',
                '.st0{fill:url(#wash);}',
                '.st1{width: 171px; height: 23px; opacity:0.65; fill:#FFFFFF;}',
                '.st2{width: 171px; height: 23px; opacity:0.45; fill:#FFFFFF;}',
                '.st3{width: 98px; height: 23px; opacity:0.2; fill:#FFFFFF;}',
                '.st4{width: 98px; height: 23px; opacity:0.35; fill:#FFFFFF;}',
                '.st5{font-family: monospace, monospace; font-size: 28px;}',
                '.st7{font-family: monospace, monospace; font-size:10px; fill:#000000; opacity: .9;}',
                '.st8{width: 98px; height: 54px; opacity:0.35; fill:#FFFFFF;}',
                '.st9{width: 171px; height: 54px; opacity:0.65; fill:#FFFFFF;}',
                '.right{text-anchor: end;}',
                '.left{text-anchor: start;}',
                typeSpecificHelper.backgroundColorsStyles(loanAsset, collateralAsset),
            '</style>',
            '<defs>',
                '<radialGradient id=""wash"" cx=""120"" cy=""40"" r=""140"" gradientTransform=""skewY(5)"" ',
                'gradientUnits=""userSpaceOnUse"">',
                    '<stop  offset=""0%"" class=""highlight-hue""/>',
                    '<stop  offset=""100%"" class=""highlight-offset""/>',
                    '<animate attributeName=""r"" values=""300;520;320;420;300"" dur=""25s"" repeatCount=""indefinite""/>',
                    '<animate attributeName=""cx"" values=""120;420;260;120;60;120"" dur=""25s"" repeatCount=""indefinite""/>',
                    '<animate attributeName=""cy"" values=""40;300;40;250;390;40"" dur=""25s"" repeatCount=""indefinite""/>',
                '</radialGradient>',
            '</defs>',
            '<rect x=""0"" class=""st0"" width=""300"" height=""300""/>',
            '<rect y=""31"" x=""',
            typeSpecificHelper.backgroundValueRectsXTranslate(),
            '"" width=""171"" height=""54"" style=""opacity:0.65; fill:#FFFFFF;""/>',
            '<text x=""',
            typeSpecificHelper.ticketIdXCoordinate(),
            '"" y=""69"" class=""st5 ',
            typeSpecificHelper.alignmentClass(),
            '"" fill=""black"">',
            id,
            '</text>'
        );
    }

    function staticValues(
        string memory ticketType,
        ITicketTypeSpecificSVGHelper typeSpecificHelper
    )
        private
        pure
        returns (string memory) 
    {
        return string.concat(
            '<g transform=""translate(',
            typeSpecificHelper.backgroundTitleRectsXTranslate(),
            ',0)"">',
                '<rect y=""31"" class=""st8""/>',
                '<rect y=""85"" class=""st3""/>',
                '<rect y=""108"" class=""st4""/>',
                '<rect y=""131"" class=""st3""/>',
                '<rect y=""154"" class=""st4""/>',
                '<rect y=""177"" class=""st3""/>',
                '<rect y=""200"" class=""st4""/>',
                '<rect y=""223"" class=""st3""/>',
                '<rect y=""246"" class=""st4""/>',
            '</g>',
            '<g class=""st7 ',
            typeSpecificHelper.titlesPositionClass(),
            '"" transform=""translate(',
            typeSpecificHelper.titlesXTranslate(),
            ',0)"">',
                '<text y=""56"">',
                ticketType,
                'er</text>',
                '<text y=""70"">Ticket</text>',
                '<text y=""99"">Loan Amount</text>',
                '<text y=""122"">Interest Rate</text>',
                '<text y=""145"">Status</text>',
                '<text y=""168"">Accrued</text>',
                '<text y=""191"">Collateral NFT</text>',
                '<text y=""214"">Collateral ID</text>',
                '<text y=""237"">Duration</text>',
                '<text y=""260"">End Date</text>',
            '</g>',
            '<g transform=""translate(',
            typeSpecificHelper.backgroundValueRectsXTranslate(),
            ',0)"">',
                '<rect y=""246"" class=""st1""/>',
                '<rect y=""223"" class=""st2""/>',
                '<rect y=""200"" class=""st1""/>',
                '<rect y=""177"" class=""st2""/>',
                '<rect y=""154"" class=""st1""/>',
                '<rect y=""131"" class=""st2""/>',
                '<rect y=""108"" class=""st1""/>',
                '<rect y=""85"" class=""st2""/>',
            '</g>'
        );
    }

    function dynamicValues(
        SVGParams memory params, 
        ITicketTypeSpecificSVGHelper typeSpecificHelper
    ) 
        private
        pure
        returns (string memory) 
    {
        return string.concat(
            '<g class=""st7 ',
            typeSpecificHelper.alignmentClass(),
            '"" transform=""translate(',
            typeSpecificHelper.valuesXTranslate(),
            ',0)"">',
            '<text y=""99"">',
            params.loanAmount, 
            ' ',
            params.loanAssetSymbol,
            '</text>',
            '<text y=""122"">',
            params.interestRate,
            '</text>',
            '<text y=""145"">',
            params.status,
            '</text>',
            '<text y=""168"">'
        );
    }

    function dynamicValues2(
        SVGParams memory params
    ) 
        private 
        pure 
        returns (string memory) 
    {
        return string.concat(
            params.interestAccrued,
            ' ',
            params.loanAssetSymbol,
            '</text>',
            '<text y=""191"">(',
            params.collateralAssetSymbol,
            ') ',
            params.collateralContractPartial,
            '</text>',
            '<text y=""214"">',
            params.collateralId,
            '</text>',
            '<text y=""237"">',
            params.durationDays,
            ' days </text>',
            '<text y=""260"">',
            params.endDateTime,
            '</text>',
            '</g>'
        );
    }
}",1972
RealWorld_BA_106_HexStrings_RealWord_20240828090057.log,106,HexStrings,12816,5086,17902,80.0,0.1658,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

library HexStrings {
    bytes16 internal constant ALPHABET = '0123456789abcdef';

    // @notice returns value as a hex string of desiredPartialStringLength length,
    // adding '0x' to the start and '...' to the end. 
    // Designed to be used for shortening addresses for display purposes.
    // @param value The value to return as a hex string
    // @param desiredPartialStringLength How many hex characters of `value` to return in the string
    // @param valueLengthAsHexString The length of `value` as a hex string
    function partialHexString(
        uint160 value,
        uint8 desiredPartialStringLength,
        uint8 valueLengthAsHexString
    ) 
        internal 
        pure 
        returns (string memory) 
    {
        bytes memory buffer = new bytes(desiredPartialStringLength + 5);
        buffer[0] = '0';
        buffer[1] = 'x';
        uint8 offset = desiredPartialStringLength + 1;
        // remove values not in partial length, four bytes for every hex character
        value >>= 4 * (valueLengthAsHexString - desiredPartialStringLength);
        for (uint8 i = offset; i > 1; --i) {
            buffer[i] = ALPHABET[value & 0xf];
            value >>= 4;
        }
        require(value == 0, 'HexStrings: hex length insufficient');
        // uint8 offset 
        buffer[offset + 1] = '.';
        buffer[offset + 2] = '.';
        buffer[offset + 3] = '.';
        return string(buffer);
    }

    /// @notice Converts a `uint160` to its ASCII `string` hexadecimal representation with fixed length.
    /// @dev Credit to Open Zeppelin under MIT license 
    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/243adff49ce1700e0ecb99fe522fb16cff1d1ddc/contracts/utils/Strings.sol#L55
    function toHexString(uint160 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = '0';
        buffer[1] = 'x';
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = ALPHABET[value & 0xf];
            value >>= 4;
        }
        require(value == 0, 'HexStrings: hex length insufficient');
        return string(buffer);
    }
}",561
RealWorld_BA_106_LendTicket_RealWord_20240828083859.log,106,LendTicket,9579,5450,15029,65.0,0.156895,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.12;

import {ILendTicket} from './interfaces/ILendTicket.sol';
import {NFTLoanTicket} from './NFTLoanTicket.sol';
import {NFTLoanFacilitator} from './NFTLoanFacilitator.sol';
import {NFTLoansTicketDescriptor} from './descriptors/NFTLoansTicketDescriptor.sol';

contract LendTicket is NFTLoanTicket, ILendTicket {

    /// See NFTLoanTicket
    constructor(
        NFTLoanFacilitator _nftLoanFacilitator,
        NFTLoansTicketDescriptor _descriptor
    ) 
        NFTLoanTicket(""Lend Ticket"", ""LNDT"", _nftLoanFacilitator, _descriptor) 
    {}

    /// See {ILendTicket-loanFacilitatorTransfer}
    function loanFacilitatorTransfer(address from, address to, uint256 loanId) external override loanFacilitatorOnly {
        _transfer(from, to, loanId);
    }

    /// @dev exact copy of 
    /// https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol#L69-L96
    /// with L78 - L81 removed to enable loanFacilitatorTransfer
    function _transfer(
        address from,
        address to,
        uint256 id
    ) internal {
        require(from == ownerOf[id], ""WRONG_FROM"");

        require(to != address(0), ""INVALID_RECIPIENT"");

        // Underflow of the sender's balance is impossible because we check for
        // ownership above and the recipient's balance can't realistically overflow.
        unchecked {
            balanceOf[from]--;

            balanceOf[to]++;
        }

        ownerOf[id] = to;

        delete getApproved[id];

        emit Transfer(from, to, id);
    }
}",402
RealWorld_BA_106_BorrowTicket_RealWord_20240828084006.log,106,BorrowTicket,5330,4947,10277,87.0,0.12559,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.12;

import './NFTLoanTicket.sol';
import {NFTLoanFacilitator} from './NFTLoanFacilitator.sol';
import {NFTLoansTicketDescriptor} from './descriptors/NFTLoansTicketDescriptor.sol';

contract BorrowTicket is NFTLoanTicket {

    /// See NFTLoanTicket
    constructor(
        NFTLoanFacilitator _nftLoanFacilitator,
        NFTLoansTicketDescriptor _descriptor
    ) 
        NFTLoanTicket(""Borrow Ticket"", ""BRWT"", _nftLoanFacilitator, _descriptor)
    {}
}",146
RealWorld_BA_106_test_RealWord_20240828085141.log,106,test,60024,5277,65301,89.0,0.40566,"// SPDX-License-Identifier: GPL-3.0-or-later

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity >=0.4.23;

contract DSTest {
    event log                    (string);
    event logs                   (bytes);

    event log_address            (address);
    event log_bytes32            (bytes32);
    event log_int                (int);
    event log_uint               (uint);
    event log_bytes              (bytes);
    event log_string             (string);

    event log_named_address      (string key, address val);
    event log_named_bytes32      (string key, bytes32 val);
    event log_named_decimal_int  (string key, int val, uint decimals);
    event log_named_decimal_uint (string key, uint val, uint decimals);
    event log_named_int          (string key, int val);
    event log_named_uint         (string key, uint val);
    event log_named_bytes        (string key, bytes val);
    event log_named_string       (string key, string val);

    bool public IS_TEST = true;
    bool public failed;

    address constant HEVM_ADDRESS =
        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));

    modifier mayRevert() { _; }
    modifier testopts(string memory) { _; }

    function fail() internal {
        failed = true;
    }

    modifier logs_gas() {
        uint startGas = gasleft();
        _;
        uint endGas = gasleft();
        emit log_named_uint(""gas"", startGas - endGas);
    }

    function assertTrue(bool condition) internal {
        if (!condition) {
            emit log(""Error: Assertion Failed"");
            fail();
        }
    }

    function assertTrue(bool condition, string memory err) internal {
        if (!condition) {
            emit log_named_string(""Error"", err);
            assertTrue(condition);
        }
    }

    function assertEq(address a, address b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [address]"");
            emit log_named_address(""  Expected"", b);
            emit log_named_address(""    Actual"", a);
            fail();
        }
    }
    function assertEq(address a, address b, string memory err) internal {
        if (a != b) {
            emit log_named_string (""Error"", err);
            assertEq(a, b);
        }
    }

    function assertEq(bytes32 a, bytes32 b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [bytes32]"");
            emit log_named_bytes32(""  Expected"", b);
            emit log_named_bytes32(""    Actual"", a);
            fail();
        }
    }
    function assertEq(bytes32 a, bytes32 b, string memory err) internal {
        if (a != b) {
            emit log_named_string (""Error"", err);
            assertEq(a, b);
        }
    }
    function assertEq32(bytes32 a, bytes32 b) internal {
        assertEq(a, b);
    }
    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {
        assertEq(a, b, err);
    }

    function assertEq(int a, int b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [int]"");
            emit log_named_int(""  Expected"", b);
            emit log_named_int(""    Actual"", a);
            fail();
        }
    }
    function assertEq(int a, int b, string memory err) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }
    function assertEq(uint a, uint b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [uint]"");
            emit log_named_uint(""  Expected"", b);
            emit log_named_uint(""    Actual"", a);
            fail();
        }
    }
    function assertEq(uint a, uint b, string memory err) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }
    function assertEqDecimal(int a, int b, uint decimals) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Expected"", b, decimals);
            emit log_named_decimal_int(""    Actual"", a, decimals);
            fail();
        }
    }
    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEqDecimal(a, b, decimals);
        }
    }
    function assertEqDecimal(uint a, uint b, uint decimals) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Expected"", b, decimals);
            emit log_named_decimal_uint(""    Actual"", a, decimals);
            fail();
        }
    }
    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEqDecimal(a, b, decimals);
        }
    }

    function assertGt(uint a, uint b) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }
    function assertGt(uint a, uint b, string memory err) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGt(a, b);
        }
    }
    function assertGt(int a, int b) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }
    function assertGt(int a, int b, string memory err) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGt(a, b);
        }
    }
    function assertGtDecimal(int a, int b, uint decimals) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGtDecimal(a, b, decimals);
        }
    }
    function assertGtDecimal(uint a, uint b, uint decimals) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGtDecimal(a, b, decimals);
        }
    }

    function assertGe(uint a, uint b) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }
    function assertGe(uint a, uint b, string memory err) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGe(a, b);
        }
    }
    function assertGe(int a, int b) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }
    function assertGe(int a, int b, string memory err) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGe(a, b);
        }
    }
    function assertGeDecimal(int a, int b, uint decimals) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGeDecimal(a, b, decimals);
        }
    }
    function assertGeDecimal(uint a, uint b, uint decimals) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGeDecimal(a, b, decimals);
        }
    }

    function assertLt(uint a, uint b) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }
    function assertLt(uint a, uint b, string memory err) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLt(a, b);
        }
    }
    function assertLt(int a, int b) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }
    function assertLt(int a, int b, string memory err) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLt(a, b);
        }
    }
    function assertLtDecimal(int a, int b, uint decimals) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLtDecimal(a, b, decimals);
        }
    }
    function assertLtDecimal(uint a, uint b, uint decimals) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLtDecimal(a, b, decimals);
        }
    }

    function assertLe(uint a, uint b) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }
    function assertLe(uint a, uint b, string memory err) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertLe(a, b);
        }
    }
    function assertLe(int a, int b) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }
    function assertLe(int a, int b, string memory err) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertLe(a, b);
        }
    }
    function assertLeDecimal(int a, int b, uint decimals) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertLeDecimal(a, b, decimals);
        }
    }
    function assertLeDecimal(uint a, uint b, uint decimals) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertGeDecimal(a, b, decimals);
        }
    }

    function assertEq(string memory a, string memory b) internal {
        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
            emit log(""Error: a == b not satisfied [string]"");
            emit log_named_string(""  Value a"", a);
            emit log_named_string(""  Value b"", b);
            fail();
        }
    }
    function assertEq(string memory a, string memory b, string memory err) internal {
        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }

    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {
        ok = true;
        if (a.length == b.length) {
            for (uint i = 0; i < a.length; i++) {
                if (a[i] != b[i]) {
                    ok = false;
                }
            }
        } else {
            ok = false;
        }
    }
    function assertEq0(bytes memory a, bytes memory b) internal {
        if (!checkEq0(a, b)) {
            emit log(""Error: a == b not satisfied [bytes]"");
            emit log_named_bytes(""  Expected"", a);
            emit log_named_bytes(""    Actual"", b);
            fail();
        }
    }
    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {
        if (!checkEq0(a, b)) {
            emit log_named_string(""Error"", err);
            assertEq0(a, b);
        }
    }
}",3539
RealWorld_BA_106_LendTicketSVGHelper_RealWord_20240828085715.log,106,LendTicketSVGHelper,9024,5045,14069,71.0,0.14602,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import './TicketTypeSpecificSVGHelper.sol';

contract LendTicketSVGHelper is TicketTypeSpecificSVGHelper {
    /**
     * @dev Returns SVG styles where the primary background color is derived
     * from the loan asset address and the secondary background color 
     * is derived from the collateral asset address
     */
    function backgroundColorsStyles(
        string memory collateralAsset,
        string memory loanAsset
    ) 
        external
        pure
        override
        returns (string memory)
    {
        return colorStyles(loanAsset, collateralAsset);
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function ticketIdXCoordinate() external pure override returns (string memory) {
        return '165';
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function backgroundTitleRectsXTranslate() external pure override returns (string memory) {
        return '171';
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function titlesPositionClass() external pure override returns (string memory) {
        return 'left';
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function titlesXTranslate() external pure override returns (string memory) {
        return '179';
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function backgroundValueRectsXTranslate() external pure override returns (string memory) {
        return '0';
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function alignmentClass() external pure override returns (string memory) {
        return 'right';
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function valuesXTranslate() external pure override returns (string memory) {
        return '163';
    }
}",369
RealWorld_BA_106_TicketTypeSpecificSVGHelper_RealWord_20240828085828.log,106,TicketTypeSpecificSVGHelper,12212,4708,16920,69.0,0.15522,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import '../interfaces/ITicketTypeSpecificSVGHelper.sol';
import ""@openzeppelin/contracts/utils/Strings.sol"";

contract TicketTypeSpecificSVGHelper is ITicketTypeSpecificSVGHelper {
    /// See {ITicketTypeSpecificSVGHelper-backgroundColorsStyles}
    function backgroundColorsStyles(
        string memory collateralAsset,
        string memory loanAsset
    ) 
        external 
        pure 
        override 
        virtual 
        returns (string memory) 
    {}

    /// See {ITicketTypeSpecificSVGHelper}
    function ticketIdXCoordinate() external pure virtual override returns (string memory) {}

    /// See {ITicketTypeSpecificSVGHelper}
    function backgroundTitleRectsXTranslate() external pure virtual override returns (string memory) {}

    /// See {ITicketTypeSpecificSVGHelper}
    function titlesPositionClass() external pure virtual override returns (string memory) {}
    
    /// See {ITicketTypeSpecificSVGHelper}
    function titlesXTranslate() external pure virtual override returns (string memory) {}

    /// See {ITicketTypeSpecificSVGHelper}
    function backgroundValueRectsXTranslate() external pure virtual override returns (string memory) {}

    /// See {ITicketTypeSpecificSVGHelper}
    function alignmentClass() external pure virtual override returns (string memory) {}

    /// See {ITicketTypeSpecificSVGHelper}
    function valuesXTranslate() external pure virtual override returns (string memory) {}

    /// @dev used by backgroundColorsStyles, returns SVG style classes    
    function colorStyles(string memory primary, string memory secondary) internal pure returns (string memory) {
        return string.concat(
            '.highlight-hue{stop-color:',
            addressStringToHSL(primary),
            '}',
            '.highlight-offset{stop-color:',
            addressStringToHSL(secondary),
            '}'
        );
    }

    /**
     * @dev returns a string, an HSL color specification that can be used in SVG styles. 
     * where H, S, and L, are derived from `account`
     */
    function addressStringToHSL(string memory account) private pure returns (string memory) {
        bytes32 hs = keccak256(abi.encodePacked(account));
        uint256 h = (uint256(uint8(hs[0])) + uint8(hs[1])) % 360;
        uint256 s = 80 + (uint8(hs[2]) % 20);
        uint256 l = 80 + (uint8(hs[3]) % 10);
        return string.concat(
            'hsl(',
            Strings.toString(h),
            ',',
            Strings.toString(s),
            '%,',
            Strings.toString(l),
            '%)'
        );
    }
}",574
RealWorld_BA_106_MaliciousERC20_RealWord_20240828084743.log,106,MaliciousERC20,7983,5386,13369,81.0,0.147635,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""../../interfaces/INFTLoanFacilitator.sol"";

contract MaliciousERC20 is ERC20, IERC721Receiver {
    INFTLoanFacilitator nftLoanFacilitator;

    constructor(address facilitatorAddress) ERC20("""", ""MAL"") {
        nftLoanFacilitator = INFTLoanFacilitator(facilitatorAddress);
        _mint(msg.sender, 1000000 * (10**uint256(decimals())));
    }

    function mint(uint256 amount, address to) external {
        _mint(to, amount * (10**decimals()));
    }

    function transfer(address recipient, uint256 amount)
        public
        virtual
        override
        returns (bool)
    {
        _transfer(_msgSender(), recipient, amount);
        nftLoanFacilitator.closeLoan(1, address(this));
        return true;
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC721Received.selector;
    }
}",274
RealWorld_BA_106_INFTLoanFacilitator_RealWord_20240828090915.log,106,INFTLoanFacilitator,48982,5636,54618,82.0,0.35763,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

interface INFTLoanFacilitator {
    /// @notice See loanInfo
    struct Loan {
        bool closed;
        uint16 perAnumInterestRate;
        uint32 durationSeconds;
        uint40 lastAccumulatedTimestamp;
        address collateralContractAddress;
        address loanAssetContractAddress;
        uint128 accumulatedInterest;
        uint128 loanAmount;
        uint256 collateralTokenId;
    }

    /**
     * @notice The magnitude of SCALAR
     * @dev 10^INTEREST_RATE_DECIMALS = 1 = 100%
     */
    function INTEREST_RATE_DECIMALS() external returns (uint8);

    /**
     * @notice The SCALAR for all percentages in the loan facilitator contract
     * @dev Any interest rate passed to a function should already been multiplied by SCALAR
     */
    function SCALAR() external returns (uint256);

    /**
     * @notice The percent of the loan amount that the facilitator will take as a fee, scaled by SCALAR
     * @dev Starts set to 1%. Can only be set to 0 - 5%. 
     */
    function originationFeeRate() external returns (uint256);

    /**
     * @notice The lend ticket contract associated with this loan faciliator
     * @dev Once set, cannot be modified
     */
    function lendTicketContract() external returns (address);

    /**
     * @notice The borrow ticket contract associated with this loan faciliator
     * @dev Once set, cannot be modified
     */
    function borrowTicketContract() external returns (address);

    /**
     * @notice The percent improvement required of at least one loan term when buying out current lender 
     * a loan that already has a lender, scaled by SCALAR. 
     * E.g. setting this value to 100 (10%) means, when replacing a lender, the new loan terms must have
     * at least 10% greater duration or loan amount or at least 10% lower interest rate. 
     * @dev Starts at 100 = 10%. Only owner can set. Cannot be set to 0.
     */
    function requiredImprovementRate() external returns (uint256);
    
    /**
     * @notice Emitted when the loan is created
     * @param id The id of the new loan, matches the token id of the borrow ticket minted in the same transaction
     * @param minter msg.sender
     * @param collateralTokenId The token id of the collateral NFT
     * @param collateralContract The contract address of the collateral NFT
     * @param maxInterestRate The max per anum interest rate, scaled by SCALAR
     * @param loanAssetContract The contract address of the loan asset
     * @param minLoanAmount mimimum loan amount
     * @param minDurationSeconds minimum loan duration in seconds
    */
    event CreateLoan(
        uint256 indexed id,
        address indexed minter,
        uint256 collateralTokenId,
        address collateralContract,
        uint256 maxInterestRate,
        address loanAssetContract,
        uint256 minLoanAmount,
        uint256 minDurationSeconds
        );

    /** 
     * @notice Emitted when ticket is closed
     * @param id The id of the ticket which has been closed
     */
    event Close(uint256 indexed id);

    /** 
     * @notice Emitted when the loan is underwritten or re-underwritten
     * @param id The id of the ticket which is being underwritten
     * @param lender msg.sender
     * @param interestRate The per anum interest rate, scaled by SCALAR, for the loan
     * @param loanAmount The loan amount
     * @param durationSeconds The loan duration in seconds 
     */
    event Lend(
        uint256 indexed id,
        address indexed lender,
        uint256 interestRate,
        uint256 loanAmount,
        uint256 durationSeconds
    );

    /**
     * @notice Emitted when a loan is being re-underwritten, the current loan ticket holder is being bought out
     * @param lender msg.sender
     * @param replacedLoanOwner The current loan ticket holder
     * @param interestEarned The amount of interest the loan has accrued from first lender to this buyout
     * @param replacedAmount The loan amount prior to buyout
     */    
    event BuyoutLender(
        uint256 indexed id,
        address indexed lender,
        address indexed replacedLoanOwner,
        uint256 interestEarned,
        uint256 replacedAmount
    );
    
    /**
     * @notice Emitted when loan is repaid
     * @param id The loan id
     * @param repayer msg.sender
     * @param loanOwner The current holder of the lend ticket for this loan, token id matching the loan id
     * @param interestEarned The total interest accumulated on the loan
     * @param loanAmount The loan amount
     */
    event Repay(
        uint256 indexed id,
        address indexed repayer,
        address indexed loanOwner,
        uint256 interestEarned,
        uint256 loanAmount
    );

    /**
     * @notice Emitted when loan NFT collateral is seized 
     * @param id The ticket id
     */
    event SeizeCollateral(uint256 indexed id);

     /**
      * @notice Emitted when origination fees are withdrawn
      * @dev only owner can call
      * @param asset the ERC20 asset withdrawn
      * @param amount the amount withdrawn
      * @param to the address the withdrawn amount was sent to
      */
     event WithdrawOriginationFees(address asset, uint256 amount, address to);

      /**
      * @notice Emitted when originationFeeRate is updated
      * @dev only owner can call, value is scaled by SCALAR, 100% = SCALAR
      * @param feeRate the new origination fee rate
      */
     event UpdateOriginationFeeRate(uint32 feeRate);

     /**
      * @notice Emitted when requiredImprovementRate is updated
      * @dev only owner can call, value is scaled by SCALAR, 100% = SCALAR
      * @param improvementRate the new required improvementRate
      */
     event UpdateRequiredImprovementRate(uint256 improvementRate);

    /**
     * @notice (1) transfers the collateral NFT to the loan facilitator contract 
     * (2) creates the loan, populating loanInfo in the facilitator contract,
     * and (3) mints a Borrow Ticket to mintBorrowTicketTo
     * @dev loan duration or loan amount cannot be 0, 
     * this is done to protect borrowers from accidentally passing a default value
     * and also because it creates odd lending and buyout behavior: possible to lend
     * for 0 value or 0 duration, and possible to buyout with no improvement because, for example
     * previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds
     * evaluates to true if previousDurationSeconds is 0 and durationSeconds is 0.
     * loanAssetContractAddress cannot be address(0), we check this because Solmate SafeTransferLib
     * does not revert with address(0) and this could cause odd behavior.
     * collateralContractAddress cannot be address(borrowTicket) or address(lendTicket).
     * @param collateralTokenId The token id of the collateral NFT 
     * @param collateralContractAddress The contract address of the collateral NFT
     * @param maxPerAnumInterest The maximum per anum interest rate for this loan, scaled by SCALAR
     * @param minLoanAmount The minimum acceptable loan amount for this loan
     * @param loanAssetContractAddress The address of the loan asset
     * @param minDurationSeconds The minimum duration for this loan
     * @param mintBorrowTicketTo An address to mint the Borrow Ticket corresponding to this loan to
     * @return id of the created loan
     */
    function createLoan(
            uint256 collateralTokenId,
            address collateralContractAddress,
            uint16 maxPerAnumInterest,
            uint128 minLoanAmount,
            address loanAssetContractAddress,
            uint32 minDurationSeconds,
            address mintBorrowTicketTo
    ) external returns (uint256 id);

    /**
     * @notice Closes the loan, sends the NFT collateral to sendCollateralTo
     * @dev Can only be called by the holder of the Borrow Ticket with tokenId
     * matching the loanId. Can only be called if loan has not be underwritten,
     * i.e. lastAccumulatedInterestTimestamp = 0
     * @param loanId The loan id
     * @param sendCollateralTo The address to send the collateral NFT to
     */
    function closeLoan(uint256 loanId, address sendCollateralTo) external;

    /**
     * @notice Lends, meeting or beating the proposed loan terms, 
     * transferring `amount` of the loan asset 
     * to the facilitator contract. If the loan has not yet been underwritten, 
     * a Lend Ticket is minted to `sendLendTicketTo`. If the loan has already been 
     * underwritten, then this is a buyout, and the Lend Ticket will be transferred
     * from the current holder to `sendLendTicketTo`. Also in the case of a buyout, interestOwed()
     * is transferred from the caller to the facilitator contract, in addition to `amount`, and
     * totalOwed() is paid to the current Lend Ticket holder.
     * @dev Loan terms must meet or beat loan terms. If a buyout, at least one loan term
     * must be improved by at least 10%. E.g. 10% longer duration, 10% lower interest, 
     * 10% higher amount
     * @param loanId The loan id
     * @param interestRate The per anum interest rate, scaled by SCALAR
     * @param amount The loan amount
     * @param durationSeconds The loan duration in seconds
     * @param sendLendTicketTo The address to send the Lend Ticket to
     */
    function lend(
            uint256 loanId,
            uint16 interestRate,
            uint128 amount,
            uint32 durationSeconds,
            address sendLendTicketTo
    ) external;

    /**
     * @notice repays and closes the loan, transferring totalOwed() to the current Lend Ticket holder
     * and transferring the collateral NFT to the Borrow Ticket holder.
     * @param loanId The loan id
     */
    function repayAndCloseLoan(uint256 loanId) external;

    /**
     * @notice Transfers the collateral NFT to `sendCollateralTo` and closes the loan.
     * @dev Can only be called by Lend Ticket holder. Can only be called 
     * if block.timestamp > loanEndSeconds()
     * @param loanId The loan id
     * @param sendCollateralTo The address to send the collateral NFT to
     */
    function seizeCollateral(uint256 loanId, address sendCollateralTo) external;

    /**
     * @notice returns the info for this loan
     * @param loanId The id of the loan
     * @return closed Whether or not the ticket is closed
     * @return perAnumInterestRate The per anum interest rate, scaled by SCALAR
     * @return durationSeconds The loan duration in seconds
     
     * @return lastAccumulatedTimestamp The timestamp (in seconds) when interest was last accumulated, 
     * i.e. the timestamp of the most recent underwriting
     * @return collateralContractAddress The contract address of the NFT collateral 
     * @return loanAssetContractAddress The contract address of the loan asset.
     * @return accumulatedInterest The amount of interest accumulated on the loan prior to the current lender
     * @return loanAmount The loan amount
     * @return collateralTokenId The token ID of the NFT collateral
     */
    function loanInfo(uint256 loanId)
        external 
        view 
        returns (
            bool closed,
            uint16 perAnumInterestRate,
            uint32 durationSeconds,
            uint40 lastAccumulatedTimestamp,
            address collateralContractAddress,
            address loanAssetContractAddress,
            uint128 accumulatedInterest,
            uint128 loanAmount,
            uint256 collateralTokenId
        );

    /**
     * @notice returns the info for this loan
     * @dev this is a convenience method for other contracts that would prefer to have the 
     * Loan object not decomposed. 
     * @param loanId The id of the loan
     * @return Loan struct corresponding to loanId
     */
    function loanInfoStruct(uint256 loanId) external view returns (Loan memory);

    /**
     * @notice returns the total amount owed for the loan, i.e. principal + interest
     * @param loanId The loan id
     */
    function totalOwed(uint256 loanId) view external returns (uint256);

    /**
     * @notice returns the interest owed on the loan, in loan asset units
     * @param loanId The loan id
     */
    function interestOwed(uint256 loanId) view external returns (uint256);

    /**
     * @notice returns the unix timestamp (seconds) of the loan end
     * @param loanId The loan id
     */
    function loanEndSeconds(uint256 loanId) view external returns (uint256);
}",2876
RealWorld_BA_106_ITicketTypeSpecificSVGHelper_RealWord_20240828091039.log,106,ITicketTypeSpecificSVGHelper,6796,3791,10587,66.0,0.1098,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

interface ITicketTypeSpecificSVGHelper {
    /**
     * @notice returns a string of styles for use within an SVG
     * @param collateralAsset A string of the collateral asset address
     * @param loanAsset A string of the loan asset address
     */
    function backgroundColorsStyles(
        string memory collateralAsset,
        string memory loanAsset
        ) 
        external pure 
        returns (string memory);

    /**
     * @dev All the below methods return ticket-type-specific values
     * used in building the ticket svg image. See NFTLoanTicketSVG for usage.
     */

    function ticketIdXCoordinate() external pure returns (string memory);

    function backgroundTitleRectsXTranslate() external pure returns (string memory);

    function titlesPositionClass() external pure returns (string memory);

    function titlesXTranslate() external pure returns (string memory);

    function backgroundValueRectsXTranslate() external pure returns (string memory);

    function alignmentClass() external pure returns (string memory);

    function valuesXTranslate() external pure returns (string memory);
}",237
RealWorld_BA_106_NFTLoanFacilitatorTest.t_RealWord_20240828084418.log,106,NFTLoanFacilitatorTest.t,0,0,0,,0.0,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.12;

import {DSTest} from ""./helpers/test.sol"";
import {Vm} from ""./helpers/Vm.sol"";

import {NFTLoanFacilitator} from ""contracts/NFTLoanFacilitator.sol"";
import {NFTLoanFacilitatorFactory} from ""./helpers/NFTLoanFacilitatorFactory.sol"";
import {BorrowTicket} from ""contracts/BorrowTicket.sol"";
import {LendTicket} from ""contracts/LendTicket.sol"";
import {CryptoPunks} from ""./mocks/CryptoPunks.sol"";
import {DAI} from ""./mocks/DAI.sol"";

contract NFTLoanFacilitatorGasBenchMarkTest is DSTest {
    Vm vm = Vm(HEVM_ADDRESS);
    NFTLoanFacilitator facilitator;
    CryptoPunks punks = new CryptoPunks();
    DAI dai = new DAI();
    uint256 punkId;
    uint16 interestRate = 15;
    uint128 loanAmount = 1e20;
    uint32 loanDuration = 1000;
    uint256 startTimestamp = 5;

    function setUp() public {
        NFTLoanFacilitatorFactory factory = new NFTLoanFacilitatorFactory();
        (, , facilitator) = factory.newFacilitator(address(this));

        // approve for lending
        dai.mint(loanAmount * 3, address(this));
        dai.approve(address(facilitator), loanAmount * 3);

        // create a loan so we can close it or lend against it
        punkId = punks.mint();
        punks.approve(address(facilitator), punkId);
        facilitator.createLoan(
            punkId,
            address(punks),
            interestRate,
            loanAmount,
            address(dai),
            loanDuration,
            address(this)
        );

        // mint another punk so we can create a second loan
        punks.mint();
        punks.approve(address(facilitator), punkId + 1);

        // prevent errors from timestamp 0
        vm.warp(startTimestamp);

        // create another loan and lend against it so we can buyout or repay
        punks.mint();
        punks.approve(address(facilitator), punkId + 2);
        facilitator.createLoan(
            punkId + 2,
            address(punks),
            interestRate,
            loanAmount,
            address(dai),
            loanDuration,
            address(this)
        );
        facilitator.lend(
            2,
            interestRate,
            loanAmount,
            loanDuration,
            address(this)
        );
    }

    function testCreateLoan() public {
        facilitator.createLoan(
            punkId + 1,
            address(punks),
            interestRate,
            loanAmount,
            address(dai),
            loanDuration,
            address(this)
        );
    }

    function testCloseLoan() public {
        facilitator.closeLoan(1, address(this));
    }

    function testLend() public {
        facilitator.lend(
            1,
            interestRate,
            loanAmount,
            loanDuration,
            address(this)
        );
    }

    function testLendBuyout() public {
        facilitator.lend(
            2,
            interestRate,
            loanAmount + ((loanAmount * 10) / 100),
            loanDuration,
            address(this)
        );
    }

    function testRepayAndClose() public {
        facilitator.repayAndCloseLoan(2);
    }

    function testSeizeCollateral() public {
        vm.warp(startTimestamp + loanDuration + 1);
        facilitator.seizeCollateral(2, address(this));
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes memory
    ) public pure returns (bytes4) {
        return this.onERC721Received.selector;
    }
}

contract NFTLoanFacilitatorTest is DSTest {
    event CreateLoan(
        uint256 indexed id,
        address indexed minter,
        uint256 collateralTokenId,
        address collateralContract,
        uint256 maxInterestRate,
        address loanAssetContract,
        uint256 minLoanAmount,
        uint256 minDurationSeconds
    );

    event Lend(
        uint256 indexed id,
        address indexed lender,
        uint256 interestRate,
        uint256 loanAmount,
        uint256 durationSeconds
    );

    event BuyoutLender(
        uint256 indexed id,
        address indexed lender,
        address indexed replacedLoanOwner,
        uint256 interestEarned,
        uint256 replacedAmount
    );

    Vm vm = Vm(HEVM_ADDRESS);

    NFTLoanFacilitator facilitator;
    BorrowTicket borrowTicket;
    LendTicket lendTicket;

    address borrower = address(1);
    address lender = address(2);

    CryptoPunks punks = new CryptoPunks();
    DAI dai = new DAI();

    uint16 interestRate = 15;
    uint128 loanAmount = 1e20;
    uint32 loanDuration = 1000;
    uint256 startTimestamp = 5;
    uint256 punkId;

    function setUp() public {
        NFTLoanFacilitatorFactory factory = new NFTLoanFacilitatorFactory();
        (borrowTicket, lendTicket, facilitator) = factory.newFacilitator(
            address(this)
        );
        vm.warp(startTimestamp);

        vm.startPrank(borrower);
        punkId = punks.mint();
        punks.approve(address(facilitator), punkId);
        vm.stopPrank();
    }

    function testCreateLoanEmitsCorrectly() public {
        vm.expectEmit(true, true, true, true);
        emit CreateLoan(
            1,
            borrower,
            punkId,
            address(punks),
            interestRate,
            address(dai),
            loanAmount,
            loanDuration
        );
        vm.prank(borrower);
        facilitator.createLoan(
            punkId,
            address(punks),
            interestRate,
            loanAmount,
            address(dai),
            loanDuration,
            borrower
        );
    }

    function testCreateLoanTransfersCollateralToSelf() public {
        vm.prank(borrower);
        facilitator.createLoan(
            punkId,
            address(punks),
            interestRate,
            loanAmount,
            address(dai),
            loanDuration,
            borrower
        );

        assertEq(punks.ownerOf(punkId), address(facilitator));
    }

    function testCreateLoanMintsBorrowTicketCorrectly() public {
        address mintBorrowTicketTo = address(3);
        vm.prank(borrower);
        uint256 loanId = facilitator.createLoan(
            punkId,
            address(punks),
            interestRate,
            loanAmount,
            address(dai),
            loanDuration,
            mintBorrowTicketTo
        );

        assertEq(borrowTicket.ownerOf(loanId), mintBorrowTicketTo);
    }

    function testCreateLoanSetsValuesCorrectly(
        uint16 maxPerAnumInterest,
        uint128 minLoanAmount,
        uint32 minDurationSeconds,
        address mintTo
    ) public {
        vm.assume(minLoanAmount > 0);
        vm.assume(minDurationSeconds > 0);
        vm.assume(mintTo != address(0));

        vm.prank(borrower);
        uint256 loanId = facilitator.createLoan(
            punkId,
            address(punks),
            maxPerAnumInterest,
            minLoanAmount,
            address(dai),
            minDurationSeconds,
            mintTo
        );
        (
            bool closed,
            uint16 perAnumInterestRate,
            uint32 durationSeconds,
            uint40 lastAccumulatedTimestamp,
            address collateralContractAddress,
            address loanAssetContractAddress,
            uint128 accumulatedInterest,
            uint128 loanAmountFromLoan,
            uint256 collateralTokenId
        ) = facilitator.loanInfo(loanId);

        assertTrue(!closed);
        assertEq(durationSeconds, minDurationSeconds);
        assertEq(perAnumInterestRate, maxPerAnumInterest);
        assertEq(loanAmountFromLoan, minLoanAmount);
        assertEq(lastAccumulatedTimestamp, 0);
        assertEq(accumulatedInterest, 0);
        assertEq(collateralContractAddress, address(punks));
        assertEq(collateralTokenId, punkId);
        assertEq(loanAssetContractAddress, address(dai));
    }

    function testCreateLoanZeroDurationNotAllowed() public {
        vm.startPrank(borrower);
        vm.expectRevert(""NFTLoanFacilitator: 0 duration"");
        facilitator.createLoan(
            punkId,
            address(punks),
            interestRate,
            loanAmount,
            address(dai),
            0,
            borrower
        );
    }

    function testCreateLoanZeroAmountNotAllowed() public {
        vm.startPrank(borrower);
        vm.expectRevert(""NFTLoanFacilitator: 0 loan amount"");
        facilitator.createLoan(
            punkId,
            address(punks),
            interestRate,
            0,
            address(dai),
            loanDuration,
            borrower
        );
    }

    function testCreateLoanAddressZeroCollateralFails() public {
        vm.startPrank(borrower);
        vm.expectRevert(bytes(""""));
        facilitator.createLoan(
            punkId,
            address(0),
            interestRate,
            loanAmount,
            address(dai),
            loanDuration,
            borrower
        );
    }

    function testBorrowTicketUnusableAsCollateral() public {
        (, uint256 loanId) = setUpLoanForTest(borrower);
        vm.startPrank(borrower);

        borrowTicket.approve(address(facilitator), loanId);
        vm.expectRevert(""NFTLoanFacilitator: cannot use tickets as collateral"");
        facilitator.createLoan(
            loanId,
            address(borrowTicket),
            interestRate,
            loanAmount,
            address(dai),
            loanDuration,
            borrower
        );
    }

    function testLendTicketUnusableAsCollateral() public {
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);
        vm.startPrank(lender);

        lendTicket.approve(address(facilitator), loanId);
        vm.expectRevert(""NFTLoanFacilitator: cannot use tickets as collateral"");
        facilitator.createLoan(
            loanId,
            address(lendTicket),
            interestRate,
            loanAmount,
            address(dai),
            loanDuration,
            borrower
        );
    }

    function testSuccessfulCloseLoan() public {
        (uint256 tokenId, uint256 loanId) = setUpLoanForTest(borrower);
        vm.startPrank(borrower);

        facilitator.closeLoan(loanId, borrower);
        assertEq(punks.ownerOf(tokenId), borrower); // make sure borrower gets their NFT back
        (bool closed, , , , , , , , ) = facilitator.loanInfo(loanId);
        assertTrue(closed); // make sure loan was closed
    }

    function testClosingAlreadyClosedLoan() public {
        (, uint256 loanId) = setUpLoanForTest(borrower);
        vm.startPrank(borrower);

        facilitator.closeLoan(loanId, borrower);

        // closing an already closed loan should revert
        vm.expectRevert(""NFTLoanFacilitator: loan closed"");
        facilitator.closeLoan(loanId, borrower);
    }

    function testClosingLoanWithLender() public {
        (, uint256 loanId) = setUpLoanForTest(borrower);
        vm.startPrank(borrower);

        dai.mint(loanAmount, borrower);
        dai.approve(address(facilitator), loanAmount); // approve for lending
        vm.warp(startTimestamp); // make sure there's a non-zero timestamp
        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            loanDuration,
            borrower
        ); // have borrower lend, this is not realistic, but will do for this test

        // loan has lender, should now revert
        vm.expectRevert(
            ""NFTLoanFacilitator: has lender, use repayAndCloseLoan""
        );
        facilitator.closeLoan(loanId, borrower);
    }

    function testClosingLoanFromNonBorrower() public {
        (, uint256 loanId) = setUpLoanForTest(borrower);

        vm.startPrank(address(2));
        vm.expectRevert(""NFTLoanFacilitator: borrow ticket holder only"");
        facilitator.closeLoan(loanId, borrower);
        vm.stopPrank();
    }

    function testInterestExceedingUint128BuyoutReverts() public {
        loanAmount = type(uint128).max;
        // 100% APR
        interestRate = 1000;
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);
        facilitator.interestOwed(loanId);
        vm.warp(startTimestamp + 366 days);
        
        vm.expectRevert(""NFTLoanFacilitator: accumulated interest exceeds uint128"");
        facilitator.lend(loanId, 0, loanAmount, loanDuration, address(4));
    }

    function testInterestExceedingUint128InterestOwed() public {
        loanAmount = type(uint128).max;
        // 100% APR
        interestRate = 1000;
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);
        vm.warp(startTimestamp + 366 days);
        facilitator.interestOwed(loanId); 
    }

    function testRepayInterestOwedExceedingUint128() public {
        loanAmount = type(uint128).max;
        // 100% APR
        interestRate = 1000;
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);
        vm.warp(startTimestamp + 366 days);
        uint256 t = facilitator.totalOwed(loanId);
        vm.startPrank(address(3));
        dai.mint(t, address(3));
        dai.approve(address(facilitator), t);
        facilitator.repayAndCloseLoan(loanId);
        vm.stopPrank();
    }

    function testLendMintsLendTicketCorrectly() public {
        (, uint256 loanId) = setUpLoanForTest(borrower);
        setUpLender(lender);
        vm.startPrank(lender);
         facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            loanDuration,
            lender
        );

        assertEq(lendTicket.ownerOf(loanId), lender);
    }

    function testLendTransfersERC20Correctly() public {
        (, uint256 loanId) = setUpLoanForTest(borrower);
        setUpLender(lender);

        uint256 lenderBalance = dai.balanceOf(lender);

        vm.startPrank(lender);
         facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            loanDuration,
            lender
        );

        assertEq(dai.balanceOf(lender), lenderBalance - loanAmount);
        uint256 facilitatorTake = loanAmount * facilitator.originationFeeRate() / facilitator.SCALAR();
        assertEq(dai.balanceOf(address(facilitator)), facilitatorTake);
        assertEq(dai.balanceOf(borrower), loanAmount - facilitatorTake);
    }

    function testLendUpdatesValuesCorrectly(
        uint16 rate,
        uint128 amount,
        uint32 duration,
        address sendTo
    ) public {
        vm.assume(rate <= interestRate);
        vm.assume(amount >= loanAmount);
        vm.assume(duration >= loanDuration);
        vm.assume(sendTo != address(0));
        vm.assume(amount < type(uint256).max / 10); // else origination fee multiplication overflows

        (uint256 tokenId, uint256 loanId) = setUpLoanForTest(borrower);

        dai.mint(amount, address(this));
        dai.approve(address(facilitator), amount);

        facilitator.lend(
            loanId,
            rate,
            amount,
            duration,
            sendTo
        );
        (
            bool closed,
            uint16 interest,
            uint32 durationSeconds,
            uint40 lastAccumulatedTimestamp,
            address collateralContractAddress,
            address loanAssetContractAddress,
            uint128 accumulatedInterest,
            uint128 loanAmountFromLoan,
            uint256 collateralTokenId
        ) = facilitator.loanInfo(loanId);

        assertTrue(!closed);
        assertEq(rate, interest);
        assertEq(duration, durationSeconds);
        assertEq(amount, loanAmountFromLoan);
        assertEq(lastAccumulatedTimestamp, startTimestamp);
        assertEq(accumulatedInterest, 0);
        // does not change immutable values
        assertEq(collateralContractAddress, address(punks));
        assertEq(loanAssetContractAddress, address(dai));
        assertEq(collateralTokenId, tokenId);
    }

    function testLendEmitsCorrectly() public {
        (, uint256 loanId) = setUpLoanForTest(borrower);

        dai.mint(loanAmount, address(this));
        dai.approve(address(facilitator), loanAmount);

        vm.expectEmit(true, true, false, true);
        emit Lend(
            loanId,
            address(this),
            interestRate,
            loanAmount,
            loanDuration
        );

        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            loanDuration,
            address(1)
        );
    }

    function testSuccessfulLend() public {
        (, uint256 loanId) = setUpLoanForTest(borrower);

        setUpLender(lender);
        vm.startPrank(lender);
        uint256 lenderBalance = dai.balanceOf(lender);

        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            loanDuration,
            lender
        );
        (
            ,
            ,
            ,
            uint40 lastAccumulatedTimestamp,
            ,
            ,
            uint256 accumulatedInterest,
            ,

        ) = facilitator.loanInfo(loanId);
        assertEq(lastAccumulatedTimestamp, startTimestamp);
        assertEq(accumulatedInterest, 0);

        // make sure lenders dai is transfered and lender gets lend ticket
        assertEq(dai.balanceOf(lender), lenderBalance - loanAmount);
        assertEq(lendTicket.ownerOf(loanId), lender);

        // make sure Facilitator subtracted origination fee
        uint256 facilitatorTake = (loanAmount *
            facilitator.originationFeeRate()) / facilitator.SCALAR();
        assertEq(dai.balanceOf(address(facilitator)), facilitatorTake);

        // make sure borrower got their loan in DAI
        assertEq(dai.balanceOf(borrower), loanAmount - facilitatorTake);
    }

    function testLoanValuesNotChangedAfterLend() public {
        (uint256 tokenId, uint256 loanId) = setUpLoanForTest(borrower);

        setUpLender(lender);
        vm.startPrank(lender);

        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            loanDuration,
            lender
        );
        (
            bool closed,
            uint16 interest,
            uint32 durationSeconds,
            uint40 lastAccumulatedTimestamp,
            address collateralContractAddress,
            address loanAssetContractAddress,
            uint128 accumulatedInterest,
            uint128 loanAmountFromLoan,
            uint256 collateralTokenId
        ) = facilitator.loanInfo(loanId);

        assertTrue(!closed);
        assertEq(interestRate, interest);
        assertEq(lastAccumulatedTimestamp, startTimestamp);
        assertEq(durationSeconds, loanDuration);
        assertEq(accumulatedInterest, 0);
        assertEq(loanAmountFromLoan, loanAmount);
        assertEq(collateralContractAddress, address(punks));
        assertEq(loanAssetContractAddress, address(dai));
        assertEq(collateralTokenId, tokenId);
    }

    function testLendFailsIfHigherInterestRate(uint16 rate, uint32 duration, uint128 amount) public {
        vm.assume(rate > interestRate);
        vm.assume(duration >= loanDuration);
        vm.assume(amount >= loanAmount);
        (, uint256 loanId) = setUpLoanForTest(borrower);

        setUpLender(lender);
        vm.startPrank(lender);
        vm.expectRevert(""NFTLoanFacilitator: rate too high"");
        facilitator.lend(
            loanId,
            rate,
            amount,
            duration,
            lender
        );
    }

    function testLendFailsIfLowerAmount(uint16 rate, uint32 duration, uint128 amount) public {
        vm.assume(rate <= interestRate);
        vm.assume(duration >= loanDuration);
        vm.assume(amount < loanAmount);
        (, uint256 loanId) = setUpLoanForTest(borrower);

        setUpLender(lender);
        vm.startPrank(lender);
        vm.expectRevert(""NFTLoanFacilitator: amount too low"");
        facilitator.lend(
            loanId,
            rate,
            amount,
            duration,
            lender
        );
    }

    function testLendFailsIfLowerDuration(uint16 rate, uint32 duration, uint128 amount) public {
        vm.assume(rate <= interestRate);
        vm.assume(duration < loanDuration);
        vm.assume(amount >= loanAmount);
        (, uint256 loanId) = setUpLoanForTest(borrower);

        setUpLender(lender);
        vm.startPrank(lender);
        vm.expectRevert(""NFTLoanFacilitator: duration too low"");
        facilitator.lend(
            loanId,
            rate,
            amount,
            duration,
            lender
        );
    }

    function testInterestAccruesCorrectly() public {
        (, uint256 loanId) = setUpLoanForTest(borrower);
        setUpLender(lender);
        vm.startPrank(lender);
        facilitator.lend(
            loanId,
            10, // 1% annual rate
            loanAmount,
            loanDuration,
            lender
        );

        uint256 interestAccrued = facilitator.interestOwed(loanId);
        assertEq(interestAccrued, 0);

        uint256 elapsedTime = 1; // simulate fast forwarding 100 seconds
        vm.warp(startTimestamp + elapsedTime);

        // 1 second with 1% annual = 0.000000031709792% per second
        // 0.00000000031709792 * 10^20 = 31709791983
        assertEq(facilitator.interestOwed(loanId), 31709791983);

        // 1 year with 1% annual on 10^20 = 10^18
        // tiny loss of precision, 10^18 - 999999999997963200 = 2036800
        // => 0.000000000002037 in the case of currencies with 18 decimals
        vm.warp(startTimestamp + 365 days);
        assertEq(facilitator.interestOwed(loanId), 999999999997963200);
    }

    function testBuyoutSucceedsIfRateImproved(uint16 rate) public {
        vm.assume(rate <= decreaseByMinPercent(interestRate));
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);
        
        address newLender = address(3);
        setUpLender(newLender);
        vm.startPrank(newLender);

        facilitator.lend(
            loanId,
            rate,
            loanAmount,
            loanDuration,
            newLender
        );
    }

    function testBuyoutSucceedsIfAmountImproved(uint128 amount) public {
        vm.assume(amount < type(uint256).max / 10); // else origination fee multiplication overflows
        vm.assume(amount >= increaseByMinPercent(loanAmount));
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);
        
        address newLender = address(3);
        setUpLender(newLender);
        uint256 amountIncrease = amount - loanAmount;
        dai.mint(amountIncrease, newLender);

        vm.startPrank(newLender);
        facilitator.lend(
            loanId,
            interestRate,
            amount,
            loanDuration,
            newLender
        );
    }

    function testBuyoutSucceedsIfDurationImproved(uint32 duration) public {
        vm.assume(duration >= increaseByMinPercent(loanDuration));
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);
        
        address newLender = address(3);
        setUpLender(newLender);
        vm.startPrank(newLender);

        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            duration,
            newLender
        );
    }

    function testBuyoutUpdatesValuesCorrectly() public {
        (uint256 tokenId, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);
        
        address newLender = address(3);
        setUpLender(newLender);
        uint32 newDuration = uint32(increaseByMinPercent(loanDuration));

        vm.prank(newLender);
        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            newDuration,
            address(1)
        );
        (
            bool closed,
            uint16 interest,
            uint32 durationSeconds,
            uint40 lastAccumulatedTimestamp,
            address collateralContractAddress,
            address loanAssetContractAddress,
            uint128 accumulatedInterest,
            uint128 loanAmountFromLoan,
            uint256 collateralTokenId
        ) = facilitator.loanInfo(loanId);

        assertTrue(!closed);
        assertEq(interestRate, interest);
        assertEq(newDuration, durationSeconds);
        assertEq(loanAmount, loanAmountFromLoan);
        assertEq(lastAccumulatedTimestamp, startTimestamp);
        assertEq(accumulatedInterest, 0);
        // does not change immutable values
        assertEq(collateralContractAddress, address(punks));
        assertEq(loanAssetContractAddress, address(dai));
        assertEq(collateralTokenId, tokenId);
    }

    function testBuyoutUpdatesAccumulatedInterestCorrectly() public {
        
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);
        uint256 elapsedTime = 100;
        vm.warp(startTimestamp + elapsedTime);
        uint256 interest = facilitator.interestOwed(loanId);
        uint32 newDuration = uint32(increaseByMinPercent(loanDuration));

        dai.mint(loanAmount + interest, address(this));
        dai.approve(address(facilitator), loanAmount + interest);

        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            newDuration,
            address(1)
        );
        (
            ,
            ,
            ,
            uint40 lastAccumulatedTimestamp,
            ,
            ,
            uint256 accumulatedInterest,
            ,
            
        ) = facilitator.loanInfo(loanId);

        assertEq(lastAccumulatedTimestamp, startTimestamp + elapsedTime);
        assertEq(accumulatedInterest, interest);
    }

    function testBuyoutTransfersLendTicket() public {
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);
        
        address newLender = address(3);
        setUpLender(newLender);
        uint32 newDuration = uint32(increaseByMinPercent(loanDuration));

        vm.prank(newLender);
        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            newDuration,
            newLender
        );

        assertEq(lendTicket.ownerOf(loanId), newLender);
    }

    function testBuyoutPaysPreviousLenderCorrectly(uint128 amount) public {
        vm.assume(amount >= loanAmount);
        vm.assume(amount < type(uint256).max / 10); // else origination fee multiplication overflows
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);

        vm.warp(startTimestamp + 100);
        uint256 interest = facilitator.interestOwed(loanId);

        dai.mint(amount + interest, address(this));
        dai.approve(address(facilitator), amount + interest);

        uint256 beforeBalance = dai.balanceOf(lender);
        
        facilitator.lend(
            loanId,
            interestRate,
            amount,
            uint32(increaseByMinPercent(loanDuration)),
            address(1)
        );

        assertEq(beforeBalance + loanAmount + interest, dai.balanceOf(lender));
    }

    function testBuyoutPaysBorrowerCorrectly(uint128 amount) public {
        vm.assume(amount >= loanAmount);
        vm.assume(amount < type(uint256).max / 10); // else origination fee multiplication overflows
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);

        dai.mint(amount, address(this));
        dai.approve(address(facilitator), amount);

        uint256 beforeBalance = dai.balanceOf(borrower);
        
        facilitator.lend(
            loanId,
            interestRate,
            amount,
            uint32(increaseByMinPercent(loanDuration)),
            address(1)
        );

        uint256 amountIncrease = amount - loanAmount;
        uint256 originationFee = amountIncrease * facilitator.originationFeeRate() / facilitator.SCALAR();
        assertEq(beforeBalance + (amountIncrease - originationFee), dai.balanceOf(borrower));
    }

    function testBuyoutPaysFacilitatorCorrectly(uint128 amount) public {
        vm.assume(amount >= loanAmount);
        vm.assume(amount < type(uint256).max / 10); // else origination fee multiplication overflows
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);

        address newLender = address(3);
        dai.mint(amount, newLender);
        vm.startPrank(newLender);
        dai.approve(address(facilitator), amount);

        uint256 beforeBalance = dai.balanceOf(address(facilitator));
        
        facilitator.lend(
            loanId,
            interestRate,
            amount,
            uint32(increaseByMinPercent(loanDuration)),
            address(1)
        );

        uint256 amountIncrease = amount - loanAmount;
        uint256 originationFee = amountIncrease * facilitator.originationFeeRate() / facilitator.SCALAR();
        assertEq(beforeBalance + originationFee, dai.balanceOf(address(facilitator)));
    }

    function testBuyoutEmitsCorrectly() public {
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);
        
        address newLender = address(3);
        setUpLender(newLender);
        uint32 newDuration = uint32(increaseByMinPercent(loanDuration));

        vm.expectEmit(true, true, true, true);
        emit BuyoutLender(
            loanId,
            newLender,
            lender,
            0,
            loanAmount
        );

        vm.expectEmit(true, true, false, true);
        emit Lend(
            loanId,
            newLender,
            interestRate,
            loanAmount,
            newDuration
        );

        vm.prank(newLender);
        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            newDuration,
            address(1)
        );
    }

    function testBuyoutFailsIfTermsNotImproved() public {
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);

        address newLender = address(3);
        setUpLender(newLender);
        vm.startPrank(newLender);
        vm.expectRevert(
            ""NFTLoanFacilitator: proposed terms must be better than existing terms""
        );
        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            loanDuration,
            newLender
        );
    }

    function testBuyoutFailsIfLoanAmountNotSufficientlyImproved() public {
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);

        address newLender = address(3);
        setUpLender(newLender);
        vm.startPrank(newLender);
        uint256 newAmount = increaseByMinPercent(loanAmount) - 1;
        vm.expectRevert(
            ""NFTLoanFacilitator: proposed terms must be better than existing terms""
        );
        facilitator.lend(
            loanId,
            interestRate,
            uint128(newAmount),
            loanDuration,
            newLender
        );
        vm.stopPrank();
    }

    function testBuyoutFailsIfLoanDurationNotSufficientlyImproved() public {
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);

        address newLender = address(3);
        setUpLender(newLender);
        vm.startPrank(newLender);
        uint32 newDuration = uint32(increaseByMinPercent(loanDuration) - 1);
        vm.expectRevert(
            ""NFTLoanFacilitator: proposed terms must be better than existing terms""
        );
        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            newDuration,
            newLender
        );
        vm.stopPrank();
    }

    function testBuyoutFailsIfInterestRateNotSufficientlyImproved() public {
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);

        address newLender = address(3);
        setUpLender(newLender);
        vm.startPrank(newLender);
        uint16 newRate = uint16(decreaseByMinPercent(interestRate) + 1);
        vm.expectRevert(
            ""NFTLoanFacilitator: proposed terms must be better than existing terms""
        );
        facilitator.lend(
            loanId,
            newRate,
            loanAmount,
            loanDuration,
            newLender
        );
        vm.stopPrank();
    }

    function testBuyoutFailsIfLoanAmountRegressed(uint16 newRate, uint32 newDuration, uint128 newAmount) public {
        vm.assume(newRate <= interestRate);
        vm.assume(newDuration >= loanDuration);
        vm.assume(newAmount < loanAmount);
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);

        address newLender = address(3);
        setUpLender(newLender);
        vm.startPrank(newLender);
        vm.expectRevert(abi.encodeWithSignature(""Panic(uint256)"", 0x11));
        facilitator.lend(
            loanId,
            newRate,
            uint128(newAmount),
            newDuration,
            newLender
        );
        vm.stopPrank();
    }

    function testBuyoutFailsIfInterestRateRegressed(uint16 newRate, uint32 newDuration, uint128 newAmount) public {
        vm.assume(newRate > interestRate);
        vm.assume(newDuration >= loanDuration);
        vm.assume(newAmount >= loanAmount);
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);

        address newLender = address(3);
        setUpLender(newLender);
        vm.startPrank(newLender);
        vm.expectRevert(""NFTLoanFacilitator: rate too high"");
        facilitator.lend(
            loanId,
            newRate,
            uint128(newAmount),
            newDuration,
            newLender
        );
        vm.stopPrank();
    }

    function testBuyoutFailsIfDurationRegressed(uint16 newRate, uint32 newDuration, uint128 newAmount) public {
        vm.assume(newRate <= interestRate);
        vm.assume(newDuration < loanDuration);
        vm.assume(newAmount >= loanAmount);
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);

        address newLender = address(3);
        setUpLender(newLender);
        vm.startPrank(newLender);
        vm.expectRevert(""NFTLoanFacilitator: duration too low"");
        facilitator.lend(
            loanId,
            newRate,
            uint128(newAmount),
            newDuration,
            newLender
        );
        vm.stopPrank();
    }

    function testRepayAndCloseSuccessful() public {
        (uint256 tokenId, uint256 loanId) = setUpLoanWithLenderForTest(
            borrower,
            lender
        );
        vm.warp(startTimestamp + 10); // warp so we have some interest accrued on the loan
        vm.startPrank(borrower);

        uint256 interestAccrued = facilitator.interestOwed(loanId);
        dai.mint(interestAccrued + calculateTake(loanAmount), borrower); // give borrower enough money to pay back the loan
        dai.approve(address(facilitator), loanAmount + interestAccrued);
        uint256 balanceOfBorrower = dai.balanceOf(borrower);

        facilitator.repayAndCloseLoan(loanId);

        // ensure ERC20 balances are correct
        assertEq(
            dai.balanceOf(borrower),
            balanceOfBorrower - (loanAmount + interestAccrued)
        );
        assertEq(dai.balanceOf(lender), loanAmount + interestAccrued);

        assertEq(punks.ownerOf(tokenId), borrower); // ensure borrower gets their NFT back
        (bool closed, , , , , , , , ) = facilitator.loanInfo(loanId); // ensure loan is closed on-chain
        assertTrue(closed);
    }

    function testRepayAndCloseFailsIfLoanClosed() public {
        (, uint256 loanId) = setUpLoanForTest(borrower);
        vm.startPrank(borrower);
        facilitator.closeLoan(loanId, borrower);
        vm.expectRevert(""NFTLoanFacilitator: loan closed"");
        facilitator.repayAndCloseLoan(loanId);
    }

    function testSeizeCollateralSuccessful() public {
        (uint256 tokenId, uint256 loanId) = setUpLoanWithLenderForTest(
            borrower,
            lender
        );
        vm.warp(startTimestamp + loanDuration + 1); // fast forward to timestamp where loan would be overdue
        vm.prank(lender);

        facilitator.seizeCollateral(loanId, lender);
        assertEq(punks.ownerOf(tokenId), lender); // ensure lender seized collateral

        (bool closed, , , , , , , , ) = facilitator.loanInfo(loanId); // ensure loan is closed on-chain
        assertTrue(closed);
    }

    function testSeizeCollateralFailsIfLoanNotOverdue() public {
        (, uint256 loanId) = setUpLoanWithLenderForTest(
            borrower,
            lender
        );
        vm.warp(startTimestamp + loanDuration); // fast forward to timestamp where loan would not be overdue
        vm.prank(lender);

        vm.expectRevert(""NFTLoanFacilitator: payment is not late"");
        facilitator.seizeCollateral(loanId, lender);
    }

    function testSeizeCollateralFailsIfNonLoanOwnerCalls() public {
        (, uint256 loanId) = setUpLoanWithLenderForTest(
            borrower,
            lender
        );
        address randomAddress = address(4);
        vm.prank(randomAddress);

        vm.expectRevert(""NFTLoanFacilitator: lend ticket holder only"");
        facilitator.seizeCollateral(loanId, randomAddress);
    }

    function testSeizeCollateralFailsIfLoanIsClosed() public {
        (, uint256 loanId) = setUpLoanForTest(borrower);
        vm.prank(borrower);
        facilitator.closeLoan(loanId, borrower);

        vm.startPrank(lender);
        vm.expectRevert(""NFTLoanFacilitator: loan closed"");
        facilitator.seizeCollateral(loanId, lender);
        vm.stopPrank();
    }

    function testUpdateOriginationFeeRevertsIfNotCalledByManager() public {
        vm.startPrank(address(1));
        vm.expectRevert(""Ownable: caller is not the owner"");
        facilitator.updateOriginationFeeRate(1);
    }

    function testUpdateOriginationFeeRevertsIfGreaterThanFivePercent() public {
        uint256 interestRateDecimals = facilitator.INTEREST_RATE_DECIMALS();
        vm.startPrank(address(this));
        vm.expectRevert(""NFTLoanFacilitator: max fee 5%"");
        facilitator.updateOriginationFeeRate(
            uint32(6 * (10**(interestRateDecimals - 2)))
        );
    }

    function testUpdateOriginationFeeWorks() public {
        uint256 interestRateDecimals = facilitator.INTEREST_RATE_DECIMALS();
        vm.startPrank(address(this));
        facilitator.updateOriginationFeeRate(
            uint32(2 * (10**(interestRateDecimals - 2)))
        );
        assertEq(
            facilitator.originationFeeRate(),
            uint32(2 * (10**(interestRateDecimals - 2)))
        );
    }

    function testUpdateRequiredImprovementRateRevertsIfNotCalledByManager()
        public
    {
        vm.startPrank(address(1));
        vm.expectRevert(""Ownable: caller is not the owner"");
        facilitator.updateRequiredImprovementRate(1);
    }

    function testUpdateRequiredImprovementRateRevertsIf0()
        public
    {
        vm.startPrank(address(this));
        vm.expectRevert(""NFTLoanFacilitator: 0 improvement rate"");
        facilitator.updateRequiredImprovementRate(0);
    }

    function testUpdateRequiredImprovementRateWorks() public {
        vm.startPrank(address(this));
        facilitator.updateRequiredImprovementRate(20 * facilitator.SCALAR());
        assertEq(
            facilitator.requiredImprovementRate(),
            20 * facilitator.SCALAR()
        );
    }

    function setUpLender(address lenderAddress) public {
        // create a lender address and give them some approved dai
        vm.startPrank(lenderAddress);
        dai.mint(loanAmount, lenderAddress);
        dai.approve(address(facilitator), 2**256 - 1); // approve for lending
        vm.stopPrank();
    }

    function setUpLoanWithLenderForTest(
        address borrowerAddress,
        address lenderAddress
    ) public returns (uint256 tokenId, uint256 loanId) {
        (tokenId, loanId) = setUpLoanForTest(borrowerAddress);
        setUpLender(lenderAddress);
        vm.startPrank(lenderAddress);
        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            loanDuration,
            lender
        );
        vm.stopPrank();
    }

    // returns tokenId of NFT used as collateral for the loan and loanId to be used in other test methods
    function setUpLoanForTest(address borrowerAddress)
        public
        returns (uint256 tokenId, uint256 loanId)
    {
        vm.startPrank(borrowerAddress);
        tokenId = punks.mint();
        punks.approve(address(facilitator), tokenId);
        loanId = facilitator.createLoan(
            tokenId,
            address(punks),
            interestRate,
            loanAmount,
            address(dai),
            loanDuration,
            borrower
        );
        vm.stopPrank();
    }

    function increaseByMinPercent(uint256 old) public view returns (uint256) {
        return
            old +
            old * 
            facilitator.requiredImprovementRate() /
            facilitator.SCALAR();
    }

    function decreaseByMinPercent(uint256 old) public view returns (uint256) {
        return old - old * facilitator.requiredImprovementRate() / facilitator.SCALAR();
    }

    function calculateTake(uint256 amount) public view returns (uint256) {
        return
            (amount * facilitator.originationFeeRate()) /
            facilitator.SCALAR();
    }
}

contract NFTLendTicketTest is DSTest {
    Vm vm = Vm(HEVM_ADDRESS);
    NFTLoanFacilitator facilitator;
    BorrowTicket borrowTicket;
    LendTicket lendTicket;

    function setUp() public {
        NFTLoanFacilitatorFactory factory = new NFTLoanFacilitatorFactory();
        (borrowTicket, lendTicket, facilitator) = factory.newFacilitator(
            address(this)
        );
    }

    function testLoanFacilitatorTransferSuccessful() public {
        address holder = address(1);
        address receiver = address(2);
        uint256 loanId = 0;

        vm.startPrank(address(facilitator));

        lendTicket.mint(holder, loanId);
        assertEq(lendTicket.ownerOf(loanId), holder);

        lendTicket.loanFacilitatorTransfer(holder, receiver, 0);
        assertEq(lendTicket.ownerOf(loanId), receiver);
    }

    function testLoanFacilitatorTransferRevertsIfNotFacilitator() public {
        vm.startPrank(address(1));
        vm.expectRevert(""NFTLoanTicket: only loan facilitator"");
        lendTicket.loanFacilitatorTransfer(address(1), address(2), 0);
    }
}",9746
RealWorld_BA_106_UintStrings_RealWord_20240828090645.log,106,UintStrings,20499,5079,25578,74.0,0.204075,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.12;


library UintStrings {
    /** 
     * @notice Converts `number` into a decimal string, with '%' is `isPercent` = true
     * @param number The number to convert to a string
     * @param decimals The number of decimals `number` should have when converted to a string
     * for example, number = 15 and decimals = 0 would yield ""15"", 
     * whereas number = 15 and decimals = 1 would yield ""1.5""
     * @param isPercent Whether the string returned should include '%' at the end
     * @return string
     */
    function decimalString(uint256 number, uint8 decimals, bool isPercent) internal pure returns (string memory) {
        if (number == 0) return isPercent ? ""0%"" : ""0"";
        
        uint8 percentBufferOffset = isPercent ? 1 : 0;
        uint256 tenPowDecimals = 10 ** decimals;

        uint256 temp = number;
        uint8 digits;
        uint8 numSigfigs;
        while (temp != 0) {
            if (numSigfigs > 0) {
                // count all digits preceding least significant figure
                numSigfigs++;
            } else if (temp % 10 != 0) {
                numSigfigs++;
            }
            digits++;
            temp /= 10;
        }

        DecimalStringParams memory params;
        params.isPercent = isPercent;
        if ((digits - numSigfigs) >= decimals) {
            // no decimals, ensure we preserve all trailing zeros
            params.sigfigs = number / tenPowDecimals;
            params.sigfigIndex = digits - decimals;
            params.bufferLength = params.sigfigIndex + percentBufferOffset;
        } else {
            // chop all trailing zeros for numbers with decimals
            params.sigfigs = number / (10 ** (digits - numSigfigs));
            if (tenPowDecimals > number) {
                // number is less than one
                // in this case, there may be leading zeros after the decimal place 
                // that need to be added

                // offset leading zeros by two to account for leading '0.'
                params.zerosStartIndex = 2;
                params.zerosEndIndex = decimals - digits + 2;
                params.sigfigIndex = numSigfigs + params.zerosEndIndex;
                params.bufferLength = params.sigfigIndex + percentBufferOffset;
                params.isLessThanOne = true;
            } else {
                // In this case, there are digits before and
                // after the decimal place
                params.sigfigIndex = numSigfigs + 1;
                params.decimalIndex = digits - decimals + 1;
            }
        }
        params.bufferLength = params.sigfigIndex + percentBufferOffset;
        return generateDecimalString(params);
    }

    /// @dev the below is from
    /// https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/NFTDescriptor.sol#L189-L231
    // with modifications

    struct DecimalStringParams {
        // significant figures of decimal
        uint256 sigfigs;
        // length of decimal string
        uint8 bufferLength;
        // ending index for significant figures (funtion works backwards when copying sigfigs)
        uint8 sigfigIndex;
        // index of decimal place (0 if no decimal)
        uint8 decimalIndex;
        // start index for trailing/leading 0's for very small/large numbers
        uint8 zerosStartIndex;
        // end index for trailing/leading 0's for very small/large numbers
        uint8 zerosEndIndex;
        // true if decimal number is less than one
        bool isLessThanOne;
        // true if string should include ""%""
        bool isPercent;
    }

    function generateDecimalString(DecimalStringParams memory params) private pure returns (string memory) {
        bytes memory buffer = new bytes(params.bufferLength);
        if (params.isPercent) {
            buffer[buffer.length - 1] = '%';
        }
        if (params.isLessThanOne) {
            buffer[0] = '0';
            buffer[1] = '.';
        }

        // add leading/trailing 0's
        for (uint256 zerosCursor = params.zerosStartIndex; zerosCursor < params.zerosEndIndex; zerosCursor++) {
            buffer[zerosCursor] = bytes1(uint8(48));
        }
        // add sigfigs
        while (params.sigfigs > 0) {
            if (params.decimalIndex > 0 && params.sigfigIndex == params.decimalIndex) {
                buffer[--params.sigfigIndex] = '.';
            }
            buffer[--params.sigfigIndex] = bytes1(uint8(uint256(48) + (params.sigfigs % 10)));
            params.sigfigs /= 10;
        }
        return string(buffer);
    }
}",1060
RealWorld_BA_106_LendTicketDescriptor_RealWord_20240828085600.log,106,LendTicketDescriptor,7433,5224,12657,73.0,0.141645,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import './NFTLoansTicketDescriptor.sol';

contract LendTicketDescriptor is NFTLoansTicketDescriptor {
    /// @dev Initializes the contract by setting a `nftType` and a `svgHelper`
    constructor(ITicketTypeSpecificSVGHelper _svgHelper) NFTLoansTicketDescriptor(""Lend"", _svgHelper) {}

    /**
     * @notice returns string with lend ticket description details
     * @dev Called by generateDescriptor when populating the description part of the token metadata. 
     */
    function generateDescription(string memory loanId) internal pure override returns (string memory) {
        return string.concat(
            'This Lend Ticket NFT was created when NFT Loan #', 
            loanId,
            ' was underwritten. On loan repayment, funds will be transferred to the lend ticket holder. ',
            'If the loan is not paid back on time, the lend ticket holder is entitled to ',
            'seize the NFT collateral.'
        );
    }

}",222
RealWorld_BA_106_BorrowTicketDescriptor_RealWord_20240828085312.log,106,BorrowTicketDescriptor,6864,4902,11766,69.0,0.13236,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import './NFTLoansTicketDescriptor.sol';

contract BorrowTicketDescriptor is NFTLoansTicketDescriptor {
    /// @dev see NFTLoansTicketDescriptor
    constructor(ITicketTypeSpecificSVGHelper _svgHelper) NFTLoansTicketDescriptor(""Borrow"", _svgHelper) {}

    /**
     * @notice returns string with borrow ticket description details
     * @dev Called by generateDescriptor when populating the description part of the token metadata. 
     */
    function generateDescription(string memory) internal pure override returns (string memory) {
        return 'This Borrow Ticket NFT was created by the deposit of an NFT into the NFT Loan Faciliator '
                'contract to serve as collateral for a loan. If the loan is underwritten, funds will be transferred '
                'to the borrow ticket holder. If the loan is repaid, the NFT collateral is transferred to the borrow '
                'ticket holder. If the loan is marked closed, the collateral has been withdrawn.';
                
    }

}",225
RealWorld_BA_106_DAI_RealWord_20240828084513.log,106,DAI,4383,4438,8821,69.0,0.110675,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract DAI is ERC20 {
    constructor() ERC20("""", ""DAI"") {}

    function mint(uint256 amount, address to) external {
        _mint(to, amount);
    }
}",72
RealWorld_BA_106_NFTLoanFacilitatorFactory_RealWord_20240828084906.log,106,NFTLoanFacilitatorFactory,9302,5437,14739,77.0,0.15525,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import {NFTLoanFacilitator} from 'contracts/NFTLoanFacilitator.sol';
import {BorrowTicket} from 'contracts/BorrowTicket.sol';
import {LendTicket} from 'contracts/LendTicket.sol';
import {BorrowTicketDescriptor} from 'contracts/descriptors/BorrowTicketDescriptor.sol';
import {LendTicketDescriptor} from 'contracts/descriptors/LendTicketDescriptor.sol';
import {LendTicketSVGHelper} from 'contracts/descriptors/LendTicketSVGHelper.sol';
import {BorrowTicketSVGHelper} from 'contracts/descriptors/BorrowTicketSVGHelper.sol';

interface Vm {
    function startPrank(address account) external;
    function stopPrank() external;
}

contract NFTLoanFacilitatorFactory {
    Vm vm = Vm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);

    function newFacilitator(address manager)
        public 
        returns (
            BorrowTicket borrowTicket,
            LendTicket lendTicket,
            NFTLoanFacilitator facilitator
        )
    {
        BorrowTicketSVGHelper bs = new BorrowTicketSVGHelper();
        BorrowTicketDescriptor bd = new BorrowTicketDescriptor(bs);

        LendTicketSVGHelper ls = new LendTicketSVGHelper();
        LendTicketDescriptor ld = new LendTicketDescriptor(ls);

        facilitator = new NFTLoanFacilitator(manager);
        borrowTicket = new BorrowTicket(facilitator, bd);
        lendTicket = new LendTicket(facilitator, ld);
        vm.startPrank(manager);
        facilitator.setBorrowTicketContract(address(borrowTicket));
        facilitator.setLendTicketContract(address(lendTicket));
        vm.stopPrank();
    }
}",391
RealWorld_BA_106_ILendTicket_RealWord_20240828091249.log,106,ILendTicket,5743,5016,10759,77.0,0.129035,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

interface ILendTicket {
    /**
     * @notice Transfers a lend ticket
     * @dev can only be called by nft loan facilitator
     * @param from The current holder of the lend ticket
     * @param to Address to send the lend ticket to
     * @param loanId The lend ticket token id, which is also the loan id in the facilitator contract
     */
    function loanFacilitatorTransfer(address from, address to, uint256 loanId) external;
}",121
RealWorld_BA_106_IERC20Metadata_RealWord_20240828091147.log,106,IERC20Metadata,3888,3708,7596,60.0,0.0936,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

interface IERC20Metadata {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
}",56
RealWorld_BA_107_EtherRocks_RealWord_20240829091819.log,107,EtherRocks,12943,7061,20004,107.0,0.205935,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8;

contract EtherRock {
    struct Rock {
        address owner;
        bool currentlyForSale;
        uint256 price;
        uint256 timesSold;
    }

    mapping(uint256 => Rock) public rocks;

    mapping(address => uint256[]) public rockOwners;

    uint256 public latestNewRockForSale;

    address owner;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    constructor() {
        rocks[0].currentlyForSale = true;
    }

    function getRockInfo(uint256 rockNumber)
        external
        view
        returns (
            address,
            bool,
            uint256,
            uint256
        )
    {
        return (
            rocks[rockNumber].owner,
            rocks[rockNumber].currentlyForSale,
            rocks[rockNumber].price,
            rocks[rockNumber].timesSold
        );
    }

    function rockOwningHistory(address _address)
        external
        view
        returns (uint256[] memory)
    {
        return rockOwners[_address];
    }

    function buyRock(uint256 rockNumber) external payable {
        require(rocks[rockNumber].currentlyForSale == true, ""Not for sale"");
        require(msg.value == rocks[rockNumber].price);
        rocks[rockNumber].currentlyForSale = false;
        rocks[rockNumber].timesSold++;
        if (rockNumber != latestNewRockForSale) {
            payable(rocks[rockNumber].owner).transfer(rocks[rockNumber].price);
        }
        rocks[rockNumber].owner = msg.sender;
        rockOwners[msg.sender].push(rockNumber);
        if (rockNumber == latestNewRockForSale) {
            if (rockNumber != 99) {
                latestNewRockForSale++;
                rocks[latestNewRockForSale].price = 0;
                rocks[latestNewRockForSale].currentlyForSale = true;
            }
        }
    }

    function sellRock(uint256 rockNumber, uint256 price) external {
        require(msg.sender == rocks[rockNumber].owner);
        require(price > 0);
        rocks[rockNumber].price = price;
        rocks[rockNumber].currentlyForSale = true;
    }

    function dontSellRock(uint256 rockNumber) external {
        require(msg.sender == rocks[rockNumber].owner);
        rocks[rockNumber].currentlyForSale = false;
    }

    function giftRock(uint256 rockNumber, address receiver) external {
        require(msg.sender == rocks[rockNumber].owner);
        rocks[rockNumber].owner = receiver;
        rockOwners[receiver].push(rockNumber);
    }

    function withdraw() external onlyOwner {
        payable(owner).transfer(address(this).balance);
    }
}",585
RealWorld_BA_107_MockBooster_RealWord_20240829092232.log,107,MockBooster,0,0,0,,0.0,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../interfaces/IBooster.sol"";

contract MockBooster is IBooster {
    IERC20 internal poolToken;
    address internal recipient;

    constructor(IERC20 _poolToken, address _recipient) {
        poolToken = _poolToken;
        recipient = _recipient;
    }

    function depositAll(uint256, bool) external override returns (bool) {
        poolToken.transferFrom(
            msg.sender,
            recipient,
            poolToken.balanceOf(msg.sender)
        );
        return true;
    }
}",143
RealWorld_BA_107_TestERC721_RealWord_20240829092008.log,107,TestERC721,4790,4213,9003,68.0,0.10821,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";

// This contract is only for testing
contract TestERC721 is ERC721(""TEST"", ""TEST"") {

    function mint(address to, uint256 index) external {
        _mint(to, index);
    }

    function ownerOf(uint256 tokenId) public view override returns (address) {
        if (!_exists(tokenId))
            return address(0);

        return super.ownerOf(tokenId);
    }
}",119
RealWorld_BA_107_MockStrategy_RealWord_20240829092119.log,107,MockStrategy,9559,4918,14477,70.0,0.146155,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../interfaces/IController.sol"";
import ""../interfaces/IStrategy.sol"";

contract MockStrategy is IStrategy {
    address public override want;
    address public jpeg;
    address public baseRewardPool;

    constructor(
        address _want,
        address _jpeg,
        address _baseRewardPool
    ) {
        want = _want;
        jpeg = _jpeg;
        baseRewardPool = _baseRewardPool;
    }

    function deposit() external override {}

    function withdraw(address token) external override {
        IERC20(token).transfer(
            msg.sender,
            IERC20(token).balanceOf(address(this))
        );
    }

    function withdraw(uint256 amount) external override {
        address vault = IController(msg.sender).vaults(want);
        IERC20(want).transfer(vault, amount);
    }

    function withdrawAll() external override returns (uint256) {
        address vault = IController(msg.sender).vaults(want);
        uint256 balance = IERC20(want).balanceOf(address(this));
        IERC20(want).transfer(vault, balance);
        return balance;
    }

    function balanceOf() external view override returns (uint256) {
        return IERC20(want).balanceOf(address(this));
    }

    function balanceOfJPEG() public view override returns (uint256) {
        return IERC20(jpeg).balanceOf(address(this));
    }

    function withdrawJPEG(address to) external override {
        IERC20(jpeg).transfer(to, balanceOfJPEG());
    }

    function convexConfig()
        external
        view
        override
        returns (
            address,
            address,
            uint256
        )
    {
        return (address(0), baseRewardPool, 0);
    }
}",398
RealWorld_BA_109_AxelarGateway_RealWord_20240829172222.log,109,AxelarGateway,68852,5955,74807,103.0,0.46336,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IAxelarGateway } from './interfaces/IAxelarGateway.sol';
import { IERC20 } from './interfaces/IERC20.sol';
import { IERC20BurnFrom } from './interfaces/IERC20BurnFrom.sol';

import { BurnableMintableCappedERC20 } from './BurnableMintableCappedERC20.sol';
import { DepositHandler } from './DepositHandler.sol';
import { AdminMultisigBase } from './AdminMultisigBase.sol';
import { TokenDeployer } from './TokenDeployer.sol';

abstract contract AxelarGateway is IAxelarGateway, AdminMultisigBase {
    error NotSelf();
    error InvalidCodeHash();
    error SetupFailed();
    error InvalidAmount();
    error TokenDoesNotExist(string symbol);
    error TokenAlreadyExists(string symbol);
    error TokenDeployFailed(string symbol);
    error TokenContractDoesNotExist(address token);
    error BurnFailed(string symbol);
    error MintFailed(string symbol);
    error TokenIsFrozen(string symbol);

    enum Role {
        Admin,
        Owner,
        Operator
    }

    enum TokenType {
        InternalBurnable,
        InternalBurnableFrom,
        External
    }

    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.
    bytes32 internal constant KEY_IMPLEMENTATION =
        bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);

    // AUDIT: slot names should be prefixed with some standard string
    // AUDIT: constants should be literal and their derivation should be in comments
    bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');

    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');
    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');
    bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');
    bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');
    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');
    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');

    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');
    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');
    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');
    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');
    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');
    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');
    bytes32 internal constant SELECTOR_TRANSFER_OWNERSHIP = keccak256('transferOwnership');

    uint8 internal constant OLD_KEY_RETENTION = 16;

    address internal immutable TOKEN_DEPLOYER_IMPLEMENTATION;

    constructor(address tokenDeployerImplementation) {
        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;
    }

    modifier onlySelf() {
        if (msg.sender != address(this)) revert NotSelf();

        _;
    }

    /******************\
    |* Public Methods *|
    \******************/

    function sendToken(
        string memory destinationChain,
        string memory destinationAddress,
        string memory symbol,
        uint256 amount
    ) external {
        _burnTokenFrom(msg.sender, symbol, amount);
        emit TokenSent(msg.sender, destinationChain, destinationAddress, symbol, amount);
    }

    function callContract(
        string memory destinationChain,
        string memory destinationContractAddress,
        bytes memory payload
    ) external {
        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);
    }

    function callContractWithToken(
        string memory destinationChain,
        string memory destinationContractAddress,
        bytes memory payload,
        string memory symbol,
        uint256 amount
    ) external {
        _burnTokenFrom(msg.sender, symbol, amount);
        emit ContractCallWithToken(
            msg.sender,
            destinationChain,
            destinationContractAddress,
            keccak256(payload),
            payload,
            symbol,
            amount
        );
    }

    function isContractCallApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) external view override returns (bool) {
        return
            getBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));
    }

    function isContractCallAndMintApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) external view override returns (bool) {
        return
            getBool(
                _getIsContractCallApprovedWithMintKey(
                    commandId,
                    sourceChain,
                    sourceAddress,
                    contractAddress,
                    payloadHash,
                    symbol,
                    amount
                )
            );
    }

    function validateContractCall(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes32 payloadHash
    ) external override returns (bool valid) {
        bytes32 key = _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);
        valid = getBool(key);
        if (valid) _setBool(key, false);
    }

    function validateContractCallAndMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) external override returns (bool valid) {
        bytes32 key = _getIsContractCallApprovedWithMintKey(
            commandId,
            sourceChain,
            sourceAddress,
            msg.sender,
            payloadHash,
            symbol,
            amount
        );
        valid = getBool(key);
        if (valid) {
            _setBool(key, false);
            _mintToken(symbol, msg.sender, amount);
        }
    }

    /***********\
    |* Getters *|
    \***********/

    function allTokensFrozen() public view override returns (bool) {
        return getBool(KEY_ALL_TOKENS_FROZEN);
    }

    function implementation() public view override returns (address) {
        return getAddress(KEY_IMPLEMENTATION);
    }

    function tokenAddresses(string memory symbol) public view override returns (address) {
        return getAddress(_getTokenAddressKey(symbol));
    }

    function tokenFrozen(string memory symbol) public view override returns (bool) {
        return getBool(_getFreezeTokenKey(symbol));
    }

    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {
        return getBool(_getIsCommandExecutedKey(commandId));
    }

    /// @dev Returns the current `adminEpoch`.
    function adminEpoch() external view override returns (uint256) {
        return _adminEpoch();
    }

    /// @dev Returns the admin threshold for a given `adminEpoch`.
    function adminThreshold(uint256 epoch) external view override returns (uint256) {
        return _getAdminThreshold(epoch);
    }

    /// @dev Returns the array of admins within a given `adminEpoch`.
    function admins(uint256 epoch) external view override returns (address[] memory results) {
        uint256 adminCount = _getAdminCount(epoch);
        results = new address[](adminCount);

        for (uint256 i; i < adminCount; i++) {
            results[i] = _getAdmin(epoch, i);
        }
    }

    /*******************\
    |* Admin Functions *|
    \*******************/

    function freezeToken(string memory symbol) external override onlyAdmin {
        _setBool(_getFreezeTokenKey(symbol), true);

        emit TokenFrozen(symbol);
    }

    function unfreezeToken(string memory symbol) external override onlyAdmin {
        _setBool(_getFreezeTokenKey(symbol), false);

        emit TokenUnfrozen(symbol);
    }

    function freezeAllTokens() external override onlyAdmin {
        _setBool(KEY_ALL_TOKENS_FROZEN, true);

        emit AllTokensFrozen();
    }

    function unfreezeAllTokens() external override onlyAdmin {
        _setBool(KEY_ALL_TOKENS_FROZEN, false);

        emit AllTokensUnfrozen();
    }

    function upgrade(
        address newImplementation,
        bytes32 newImplementationCodeHash,
        bytes calldata setupParams
    ) external override onlyAdmin {
        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();

        emit Upgraded(newImplementation);

        // AUDIT: If `newImplementation.setup` performs `selfdestruct`, it will result in the loss of _this_ implementation (thereby losing the gateway)
        //        if `upgrade` is entered within the context of _this_ implementation itself.
        if (setupParams.length > 0) {
            (bool success, ) = newImplementation.delegatecall(
                abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams)
            );

            if (!success) revert SetupFailed();
        }

        _setImplementation(newImplementation);
    }

    /**********************\
    |* Internal Functions *|
    \**********************/

    function _burnTokenFrom(
        address sender,
        string memory symbol,
        uint256 amount
    ) internal {
        address tokenAddress = tokenAddresses(symbol);

        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);
        if (amount == 0) revert InvalidAmount();

        TokenType tokenType = _getTokenType(symbol);
        bool burnSuccess;

        if (tokenType == TokenType.External) {
            _checkTokenStatus(symbol);

            burnSuccess = _callERC20Token(
                tokenAddress,
                abi.encodeWithSelector(IERC20.transferFrom.selector, sender, address(this), amount)
            );

            if (!burnSuccess) revert BurnFailed(symbol);

            return;
        }

        if (tokenType == TokenType.InternalBurnableFrom) {
            burnSuccess = _callERC20Token(
                tokenAddress,
                abi.encodeWithSelector(IERC20BurnFrom.burnFrom.selector, sender, amount)
            );

            if (!burnSuccess) revert BurnFailed(symbol);

            return;
        }

        burnSuccess = _callERC20Token(
            tokenAddress,
            abi.encodeWithSelector(
                IERC20.transferFrom.selector,
                sender,
                BurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)),
                amount
            )
        );

        if (!burnSuccess) revert BurnFailed(symbol);

        BurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));
    }

    function _deployToken(
        string memory name,
        string memory symbol,
        uint8 decimals,
        uint256 cap,
        address tokenAddress
    ) internal {
        // Ensure that this symbol has not been taken.
        if (tokenAddresses(symbol) != address(0)) revert TokenAlreadyExists(symbol);

        if (tokenAddress == address(0)) {
            // If token address is no specified, it indicates a request to deploy one.
            bytes32 salt = keccak256(abi.encodePacked(symbol));

            (bool success, bytes memory data) = TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall(
                abi.encodeWithSelector(TokenDeployer.deployToken.selector, name, symbol, decimals, cap, salt)
            );

            if (!success) revert TokenDeployFailed(symbol);

            tokenAddress = abi.decode(data, (address));

            _setTokenType(symbol, TokenType.InternalBurnableFrom);
        } else {
            // If token address is specified, ensure that there is a contact at the specified addressed.
            if (tokenAddress.code.length == uint256(0)) revert TokenContractDoesNotExist(tokenAddress);

            // Mark that this symbol is an external token, which is needed to differentiate between operations on mint and burn.
            _setTokenType(symbol, TokenType.External);
        }

        _setTokenAddress(symbol, tokenAddress);

        emit TokenDeployed(symbol, tokenAddress);
    }

    function _mintToken(
        string memory symbol,
        address account,
        uint256 amount
    ) internal {
        address tokenAddress = tokenAddresses(symbol);

        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);

        if (_getTokenType(symbol) == TokenType.External) {
            _checkTokenStatus(symbol);

            bool success = _callERC20Token(
                tokenAddress,
                abi.encodeWithSelector(IERC20.transfer.selector, account, amount)
            );

            if (!success) revert MintFailed(symbol);
        } else {
            BurnableMintableCappedERC20(tokenAddress).mint(account, amount);
        }
    }

    function _burnToken(string memory symbol, bytes32 salt) internal {
        address tokenAddress = tokenAddresses(symbol);

        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);

        if (_getTokenType(symbol) == TokenType.External) {
            _checkTokenStatus(symbol);

            DepositHandler depositHandler = new DepositHandler{ salt: salt }();

            (bool success, bytes memory returnData) = depositHandler.execute(
                tokenAddress,
                abi.encodeWithSelector(
                    IERC20.transfer.selector,
                    address(this),
                    IERC20(tokenAddress).balanceOf(address(depositHandler))
                )
            );

            if (!success || (returnData.length != uint256(0) && !abi.decode(returnData, (bool))))
                revert BurnFailed(symbol);

            depositHandler.destroy(address(this));
        } else {
            BurnableMintableCappedERC20(tokenAddress).burn(salt);
        }
    }

    function _approveContractCall(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        bytes32 sourceTxHash,
        uint256 sourceEventIndex
    ) internal {
        _setContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);
        emit ContractCallApproved(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            sourceTxHash,
            sourceEventIndex
        );
    }

    function _approveContractCallWithMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount,
        bytes32 sourceTxHash,
        uint256 sourceEventIndex
    ) internal {
        _setContractCallApprovedWithMint(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            symbol,
            amount
        );
        emit ContractCallApprovedWithMint(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            symbol,
            amount,
            sourceTxHash,
            sourceEventIndex
        );
    }

    /********************\
    |* Pure Key Getters *|
    \********************/

    function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));
    }

    function _getFreezeTokenKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_FROZEN, symbol));
    }

    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));
    }

    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));
    }

    function _getIsContractCallApprovedKey(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    PREFIX_CONTRACT_CALL_APPROVED,
                    commandId,
                    sourceChain,
                    sourceAddress,
                    contractAddress,
                    payloadHash
                )
            );
    }

    function _getIsContractCallApprovedWithMintKey(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,
                    commandId,
                    sourceChain,
                    sourceAddress,
                    contractAddress,
                    payloadHash,
                    symbol,
                    amount
                )
            );
    }

    /********************\
    |* Internal Methods *|
    \********************/

    function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {
        (bool success, bytes memory returnData) = tokenAddress.call(callData);
        return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));
    }

    /********************\
    |* Internal Getters *|
    \********************/

    function _getTokenType(string memory symbol) internal view returns (TokenType) {
        return TokenType(getUint(_getTokenTypeKey(symbol)));
    }

    function _checkTokenStatus(string memory symbol) internal view {
        if (getBool(_getFreezeTokenKey(symbol)) || getBool(KEY_ALL_TOKENS_FROZEN)) revert TokenIsFrozen(symbol);
    }

    /********************\
    |* Internal Setters *|
    \********************/

    function _setTokenType(string memory symbol, TokenType tokenType) internal {
        _setUint(_getTokenTypeKey(symbol), uint256(tokenType));
    }

    function _setTokenAddress(string memory symbol, address tokenAddress) internal {
        _setAddress(_getTokenAddressKey(symbol), tokenAddress);
    }

    function _setCommandExecuted(bytes32 commandId, bool executed) internal {
        _setBool(_getIsCommandExecutedKey(commandId), executed);
    }

    function _setContractCallApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) internal {
        _setBool(
            _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash),
            true
        );
    }

    function _setContractCallApprovedWithMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) internal {
        _setBool(
            _getIsContractCallApprovedWithMintKey(
                commandId,
                sourceChain,
                sourceAddress,
                contractAddress,
                payloadHash,
                symbol,
                amount
            ),
            true
        );
    }

    function _setImplementation(address newImplementation) internal {
        _setAddress(KEY_IMPLEMENTATION, newImplementation);
    }
}",4083
RealWorld_BA_109_ERC20Permit_RealWord_20240829170925.log,109,ERC20Permit,11559,5901,17460,106.0,0.175815,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { ERC20 } from './ERC20.sol';

abstract contract ERC20Permit is ERC20 {
    bytes32 public DOMAIN_SEPARATOR;

    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = '\x19\x01';

    // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')
    bytes32 private constant DOMAIN_TYPE_SIGNATURE_HASH =
        bytes32(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f);

    // keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)')
    bytes32 private constant PERMIT_SIGNATURE_HASH =
        bytes32(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9);

    mapping(address => uint256) public nonces;

    constructor(string memory name) {
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                DOMAIN_TYPE_SIGNATURE_HASH,
                keccak256(bytes(name)),
                keccak256(bytes('1')),
                block.chainid,
                address(this)
            )
        );
    }

    function permit(
        address issuer,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        require(block.timestamp < deadline, 'EXPIRED');
        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, 'INV_S');
        require(v == 27 || v == 28, 'INV_V');

        bytes32 digest = keccak256(
            abi.encodePacked(
                EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(PERMIT_SIGNATURE_HASH, issuer, spender, value, nonces[issuer]++, deadline))
            )
        );

        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress == issuer, 'INV_SIG');

        // _approve will revert if issuer is address(0x0)
        _approve(issuer, spender, value);
    }
}",514
RealWorld_BA_109_IAxelarGatewaySinglesig_RealWord_20240829173442.log,109,IAxelarGatewaySinglesig,4807,5031,9838,75.0,0.124655,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IAxelarGateway } from './IAxelarGateway.sol';

interface IAxelarGatewaySinglesig is IAxelarGateway {
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    event OperatorshipTransferred(address indexed previousOperator, address indexed newOperator);

    function owner() external view returns (address);

    function operator() external view returns (address);
}",101
RealWorld_BA_109_AdminMultisigBase_RealWord_20240829171835.log,109,AdminMultisigBase,28155,5665,33820,84.0,0.254075,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { EternalStorage } from './EternalStorage.sol';

contract AdminMultisigBase is EternalStorage {
    error NotAdmin();
    error AlreadyVoted();
    error InvalidAdmins();
    error InvalidAdminThreshold();
    error DuplicateAdmin(address admin);

    // AUDIT: slot names should be prefixed with some standard string
    // AUDIT: constants should be literal and their derivation should be in comments
    bytes32 internal constant KEY_ADMIN_EPOCH = keccak256('admin-epoch');

    bytes32 internal constant PREFIX_ADMIN = keccak256('admin');
    bytes32 internal constant PREFIX_ADMIN_COUNT = keccak256('admin-count');
    bytes32 internal constant PREFIX_ADMIN_THRESHOLD = keccak256('admin-threshold');
    bytes32 internal constant PREFIX_ADMIN_VOTE_COUNTS = keccak256('admin-vote-counts');
    bytes32 internal constant PREFIX_ADMIN_VOTED = keccak256('admin-voted');
    bytes32 internal constant PREFIX_IS_ADMIN = keccak256('is-admin');

    modifier onlyAdmin() {
        uint256 adminEpoch = _adminEpoch();

        if (!_isAdmin(adminEpoch, msg.sender)) revert NotAdmin();

        bytes32 topic = keccak256(msg.data);

        // Check that admin has not voted, then record that they have voted.
        if (_hasVoted(adminEpoch, topic, msg.sender)) revert AlreadyVoted();

        _setHasVoted(adminEpoch, topic, msg.sender, true);

        // Determine the new vote count and update it.
        uint256 adminVoteCount = _getVoteCount(adminEpoch, topic) + uint256(1);
        _setVoteCount(adminEpoch, topic, adminVoteCount);

        // Do not proceed with operation execution if insufficient votes.
        if (adminVoteCount < _getAdminThreshold(adminEpoch)) return;

        _;

        // Clear vote count and voted booleans.
        _setVoteCount(adminEpoch, topic, uint256(0));

        uint256 adminCount = _getAdminCount(adminEpoch);

        for (uint256 i; i < adminCount; i++) {
            _setHasVoted(adminEpoch, topic, _getAdmin(adminEpoch, i), false);
        }
    }

    /********************\
    |* Pure Key Getters *|
    \********************/

    function _getAdminKey(uint256 adminEpoch, uint256 index) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_ADMIN, adminEpoch, index));
    }

    function _getAdminCountKey(uint256 adminEpoch) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_ADMIN_COUNT, adminEpoch));
    }

    function _getAdminThresholdKey(uint256 adminEpoch) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_ADMIN_THRESHOLD, adminEpoch));
    }

    function _getAdminVoteCountsKey(uint256 adminEpoch, bytes32 topic) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTE_COUNTS, adminEpoch, topic));
    }

    function _getAdminVotedKey(
        uint256 adminEpoch,
        bytes32 topic,
        address account
    ) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTED, adminEpoch, topic, account));
    }

    function _getIsAdminKey(uint256 adminEpoch, address account) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_IS_ADMIN, adminEpoch, account));
    }

    /***********\
    |* Getters *|
    \***********/

    function _adminEpoch() internal view returns (uint256) {
        return getUint(KEY_ADMIN_EPOCH);
    }

    function _getAdmin(uint256 adminEpoch, uint256 index) internal view returns (address) {
        return getAddress(_getAdminKey(adminEpoch, index));
    }

    function _getAdminCount(uint256 adminEpoch) internal view returns (uint256) {
        return getUint(_getAdminCountKey(adminEpoch));
    }

    function _getAdminThreshold(uint256 adminEpoch) internal view returns (uint256) {
        return getUint(_getAdminThresholdKey(adminEpoch));
    }

    function _getVoteCount(uint256 adminEpoch, bytes32 topic) internal view returns (uint256) {
        return getUint(_getAdminVoteCountsKey(adminEpoch, topic));
    }

    function _hasVoted(
        uint256 adminEpoch,
        bytes32 topic,
        address account
    ) internal view returns (bool) {
        return getBool(_getAdminVotedKey(adminEpoch, topic, account));
    }

    function _isAdmin(uint256 adminEpoch, address account) internal view returns (bool) {
        return getBool(_getIsAdminKey(adminEpoch, account));
    }

    /***********\
    |* Setters *|
    \***********/

    function _setAdminEpoch(uint256 adminEpoch) internal {
        _setUint(KEY_ADMIN_EPOCH, adminEpoch);
    }

    function _setAdmin(
        uint256 adminEpoch,
        uint256 index,
        address account
    ) internal {
        _setAddress(_getAdminKey(adminEpoch, index), account);
    }

    function _setAdminCount(uint256 adminEpoch, uint256 adminCount) internal {
        _setUint(_getAdminCountKey(adminEpoch), adminCount);
    }

    function _setAdmins(
        uint256 adminEpoch,
        address[] memory accounts,
        uint256 threshold
    ) internal {
        uint256 adminLength = accounts.length;

        if (adminLength < threshold) revert InvalidAdmins();

        if (threshold == uint256(0)) revert InvalidAdminThreshold();

        _setAdminThreshold(adminEpoch, threshold);
        _setAdminCount(adminEpoch, adminLength);

        for (uint256 i; i < adminLength; i++) {
            address account = accounts[i];

            // Check that the account wasn't already set as an admin for this epoch.
            if (_isAdmin(adminEpoch, account)) revert DuplicateAdmin(account);

            // Set this account as the i-th admin in this epoch (needed to we can clear topic votes in `onlyAdmin`).
            _setAdmin(adminEpoch, i, account);
            _setIsAdmin(adminEpoch, account, true);
        }
    }

    function _setAdminThreshold(uint256 adminEpoch, uint256 adminThreshold) internal {
        _setUint(_getAdminThresholdKey(adminEpoch), adminThreshold);
    }

    function _setVoteCount(
        uint256 adminEpoch,
        bytes32 topic,
        uint256 voteCount
    ) internal {
        _setUint(_getAdminVoteCountsKey(adminEpoch, topic), voteCount);
    }

    function _setHasVoted(
        uint256 adminEpoch,
        bytes32 topic,
        address account,
        bool voted
    ) internal {
        _setBool(_getAdminVotedKey(adminEpoch, topic, account), voted);
    }

    function _setIsAdmin(
        uint256 adminEpoch,
        address account,
        bool isAdmin
    ) internal {
        _setBool(_getIsAdminKey(adminEpoch, account), isAdmin);
    }
}",1525
RealWorld_BA_109_DepositHandler_RealWord_20240829171548.log,109,DepositHandler,6101,4754,10855,89.0,0.125585,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

contract DepositHandler {
    uint256 internal constant IS_NOT_LOCKED = uint256(0);
    uint256 internal constant IS_LOCKED = uint256(1);

    uint256 internal _lockedStatus = IS_NOT_LOCKED;

    modifier noReenter() {
        require(_lockedStatus == IS_NOT_LOCKED);

        _lockedStatus = IS_LOCKED;
        _;
        _lockedStatus = IS_NOT_LOCKED;
    }

    function execute(address callee, bytes calldata data)
        external
        noReenter
        returns (bool success, bytes memory returnData)
    {
        (success, returnData) = callee.call(data);
    }

    function destroy(address etherDestination) external noReenter {
        selfdestruct(payable(etherDestination));
    }
}",175
RealWorld_BA_109_EternalStorage_RealWord_20240829172407.log,109,EternalStorage,12265,5136,17401,80.0,0.164045,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

/**
 * @title EternalStorage
 * @dev This contract holds all the necessary state variables to carry out the storage of any contract.
 */
contract EternalStorage {
    mapping(bytes32 => uint256) private _uintStorage;
    mapping(bytes32 => string) private _stringStorage;
    mapping(bytes32 => address) private _addressStorage;
    mapping(bytes32 => bytes) private _bytesStorage;
    mapping(bytes32 => bool) private _boolStorage;
    mapping(bytes32 => int256) private _intStorage;

    // *** Getter Methods ***
    function getUint(bytes32 key) public view returns (uint256) {
        return _uintStorage[key];
    }

    function getString(bytes32 key) public view returns (string memory) {
        return _stringStorage[key];
    }

    function getAddress(bytes32 key) public view returns (address) {
        return _addressStorage[key];
    }

    function getBytes(bytes32 key) public view returns (bytes memory) {
        return _bytesStorage[key];
    }

    function getBool(bytes32 key) public view returns (bool) {
        return _boolStorage[key];
    }

    function getInt(bytes32 key) public view returns (int256) {
        return _intStorage[key];
    }

    // *** Setter Methods ***
    function _setUint(bytes32 key, uint256 value) internal {
        _uintStorage[key] = value;
    }

    function _setString(bytes32 key, string memory value) internal {
        _stringStorage[key] = value;
    }

    function _setAddress(bytes32 key, address value) internal {
        _addressStorage[key] = value;
    }

    function _setBytes(bytes32 key, bytes memory value) internal {
        _bytesStorage[key] = value;
    }

    function _setBool(bytes32 key, bool value) internal {
        _boolStorage[key] = value;
    }

    function _setInt(bytes32 key, int256 value) internal {
        _intStorage[key] = value;
    }

    // *** Delete Methods ***
    function _deleteUint(bytes32 key) internal {
        delete _uintStorage[key];
    }

    function _deleteString(bytes32 key) internal {
        delete _stringStorage[key];
    }

    function _deleteAddress(bytes32 key) internal {
        delete _addressStorage[key];
    }

    function _deleteBytes(bytes32 key) internal {
        delete _bytesStorage[key];
    }

    function _deleteBool(bytes32 key) internal {
        delete _boolStorage[key];
    }

    function _deleteInt(bytes32 key) internal {
        delete _intStorage[key];
    }
}",560
RealWorld_BA_109_IERC20BurnFrom_RealWord_20240829173207.log,109,IERC20BurnFrom,3325,3926,7251,67.0,0.095145,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

interface IERC20BurnFrom {
    function burnFrom(address account, uint256 amount) external;
}",37
RealWorld_BA_109_ECDSA_RealWord_20240829171423.log,109,ECDSA,17677,5023,22700,82.0,0.188845,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

/**
 * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.
 *
 * These functions can be used to verify that a message was signed by the holder
 * of the private keys of a given address.
 */
library ECDSA {
    error InvalidSignatureLength();
    error InvalidS();
    error InvalidV();
    error InvalidSignature();

    /**
     * @dev Returns the address that signed a hashed message (`hash`) with
     * `signature`. This address can then be used for verification purposes.
     *
     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
     * this function rejects them by requiring the `s` value to be in the lower
     * half order, and the `v` value to be either 27 or 28.
     *
     * IMPORTANT: `hash` _must_ be the result of a hash operation for the
     * verification to be secure: it is possible to craft signatures that
     * recover to arbitrary addresses for non-hashed data. A safe way to ensure
     * this is by receiving a hash of the original message (which may otherwise
     * be too long), and then calling {toEthSignedMessageHash} on it.
     */
    function recover(bytes32 hash, bytes memory signature) internal pure returns (address signer) {
        // Check the signature length
        if (signature.length != 65) revert InvalidSignatureLength();

        // Divide the signature in r, s and v variables
        bytes32 r;
        bytes32 s;
        uint8 v;

        // ecrecover takes the signature parameters, and the only way to get them
        // currently is to use assembly.
        // solhint-disable-next-line no-inline-assembly
        assembly {
            r := mload(add(signature, 0x20))
            s := mload(add(signature, 0x40))
            v := byte(0, mload(add(signature, 0x60)))
        }

        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most
        // signatures from current libraries generate a unique signature with an s-value in the lower half order.
        //
        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
        // these malleable signatures as well.
        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) revert InvalidS();

        if (v != 27 && v != 28) revert InvalidV();

        // If the signature is valid (and not malleable), return the signer address
        if ((signer = ecrecover(hash, v, r, s)) == address(0)) revert InvalidSignature();
    }

    /**
     * @dev Returns an Ethereum Signed Message, created from a `hash`. This
     * replicates the behavior of the
     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]
     * JSON-RPC method.
     *
     * See {recover}.
     */
    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
        // 32 is the length in bytes of hash,
        // enforced by the type signature above
        return keccak256(abi.encodePacked('\x19Ethereum Signed Message:\n32', hash));
    }
}",901
RealWorld_BA_109_AxelarGatewaySinglesig_RealWord_20240829171300.log,109,AxelarGatewaySinglesig,42653,5023,47676,80.0,0.313725,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IAxelarGatewaySinglesig } from './interfaces/IAxelarGatewaySinglesig.sol';

import { ECDSA } from './ECDSA.sol';
import { AxelarGateway } from './AxelarGateway.sol';

contract AxelarGatewaySinglesig is IAxelarGatewaySinglesig, AxelarGateway {
    error InvalidAddress();
    error NotProxy();
    error InvalidChainId();
    error InvalidCommands();

    bytes32 internal constant KEY_OWNER_EPOCH = keccak256('owner-epoch');

    bytes32 internal constant PREFIX_OWNER = keccak256('owner');

    bytes32 internal constant KEY_OPERATOR_EPOCH = keccak256('operator-epoch');

    bytes32 internal constant PREFIX_OPERATOR = keccak256('operator');

    constructor(address tokenDeployer) AxelarGateway(tokenDeployer) {}

    /********************\
    |* Pure Key Getters *|
    \********************/

    function _getOwnerKey(uint256 ownerEpoch) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OWNER, ownerEpoch));
    }

    function _getOperatorKey(uint256 operatorEpoch) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OPERATOR, operatorEpoch));
    }

    /***********\
    |* Getters *|
    \***********/

    function _ownerEpoch() internal view returns (uint256) {
        return getUint(KEY_OWNER_EPOCH);
    }

    function _getOwner(uint256 ownerEpoch) internal view returns (address) {
        return getAddress(_getOwnerKey(ownerEpoch));
    }

    /// @dev Returns true if a `account` is owner within the last `OLD_KEY_RETENTION + 1` owner epochs (excluding the current one).
    function _isValidPreviousOwner(address account) internal view returns (bool) {
        uint256 ownerEpoch = _ownerEpoch();
        uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);
        uint256 lowerBoundOwnerEpoch = ownerEpoch > recentEpochs ? ownerEpoch - recentEpochs : uint256(0);

        --ownerEpoch;
        while (ownerEpoch > lowerBoundOwnerEpoch) {
            if (account == _getOwner(ownerEpoch--)) return true;
        }

        return false;
    }

    function owner() public view override returns (address) {
        return _getOwner(_ownerEpoch());
    }

    function _operatorEpoch() internal view returns (uint256) {
        return getUint(KEY_OPERATOR_EPOCH);
    }

    function _getOperator(uint256 operatorEpoch) internal view returns (address) {
        return getAddress(_getOperatorKey(operatorEpoch));
    }

    /// @dev Returns true if a `account` is operator within the last `OLD_KEY_RETENTION + 1` operator epochs.
    function _isValidRecentOperator(address account) internal view returns (bool) {
        uint256 operatorEpoch = _operatorEpoch();
        uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);
        uint256 lowerBoundOperatorEpoch = operatorEpoch > recentEpochs ? operatorEpoch - recentEpochs : uint256(0);

        while (operatorEpoch > lowerBoundOperatorEpoch) {
            if (account == _getOperator(operatorEpoch--)) return true;
        }

        return false;
    }

    function operator() public view override returns (address) {
        return _getOperator(_operatorEpoch());
    }

    /***********\
    |* Setters *|
    \***********/

    function _setOwnerEpoch(uint256 ownerEpoch) internal {
        _setUint(KEY_OWNER_EPOCH, ownerEpoch);
    }

    function _setOwner(uint256 ownerEpoch, address account) internal {
        _setAddress(_getOwnerKey(ownerEpoch), account);
    }

    function _setOperatorEpoch(uint256 operatorEpoch) internal {
        _setUint(KEY_OPERATOR_EPOCH, operatorEpoch);
    }

    function _setOperator(uint256 operatorEpoch, address account) internal {
        _setAddress(_getOperatorKey(operatorEpoch), account);
    }

    /**********************\
    |* Self Functionality *|
    \**********************/

    function deployToken(bytes calldata params, bytes32) external onlySelf {
        (string memory name, string memory symbol, uint8 decimals, uint256 cap, address tokenAddr) = abi.decode(
            params,
            (string, string, uint8, uint256, address)
        );

        _deployToken(name, symbol, decimals, cap, tokenAddr);
    }

    function mintToken(bytes calldata params, bytes32) external onlySelf {
        (string memory symbol, address account, uint256 amount) = abi.decode(params, (string, address, uint256));

        _mintToken(symbol, account, amount);
    }

    function burnToken(bytes calldata params, bytes32) external onlySelf {
        (string memory symbol, bytes32 salt) = abi.decode(params, (string, bytes32));

        _burnToken(symbol, salt);
    }

    function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {
        (
            string memory sourceChain,
            string memory sourceAddress,
            address contractAddress,
            bytes32 payloadHash,
            bytes32 sourceTxHash,
            uint256 sourceEventIndex
        ) = abi.decode(params, (string, string, address, bytes32, bytes32, uint256));

        _approveContractCall(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            sourceTxHash,
            sourceEventIndex
        );
    }

    function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {
        (
            string memory sourceChain,
            string memory sourceAddress,
            address contractAddress,
            bytes32 payloadHash,
            string memory symbol,
            uint256 amount,
            bytes32 sourceTxHash,
            uint256 sourceEventIndex
        ) = abi.decode(params, (string, string, address, bytes32, string, uint256, bytes32, uint256));

        _approveContractCallWithMint(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            symbol,
            amount,
            sourceTxHash,
            sourceEventIndex
        );
    }

    function transferOwnership(bytes calldata params, bytes32) external onlySelf {
        address newOwner = abi.decode(params, (address));
        uint256 ownerEpoch = _ownerEpoch();

        if (newOwner == address(0)) revert InvalidAddress();

        emit OwnershipTransferred(_getOwner(ownerEpoch), newOwner);

        _setOwnerEpoch(++ownerEpoch);
        _setOwner(ownerEpoch, newOwner);
    }

    function transferOperatorship(bytes calldata params, bytes32) external onlySelf {
        address newOperator = abi.decode(params, (address));

        if (newOperator == address(0)) revert InvalidAddress();

        emit OperatorshipTransferred(operator(), newOperator);

        uint256 operatorEpoch = _operatorEpoch();
        _setOperatorEpoch(++operatorEpoch);
        _setOperator(operatorEpoch, newOperator);
    }

    /**************************\
    |* External Functionality *|
    \**************************/

    function setup(bytes calldata params) external override {
        // Prevent setup from being called on a non-proxy (the implementation).
        if (implementation() == address(0)) revert NotProxy();

        (address[] memory adminAddresses, uint256 adminThreshold, address ownerAddress, address operatorAddress) = abi
            .decode(params, (address[], uint256, address, address));

        uint256 adminEpoch = _adminEpoch() + uint256(1);
        _setAdminEpoch(adminEpoch);
        _setAdmins(adminEpoch, adminAddresses, adminThreshold);

        uint256 ownerEpoch = _ownerEpoch() + uint256(1);
        _setOwnerEpoch(ownerEpoch);
        _setOwner(ownerEpoch, ownerAddress);

        uint256 operatorEpoch = _operatorEpoch() + uint256(1);
        _setOperatorEpoch(operatorEpoch);
        _setOperator(operatorEpoch, operatorAddress);

        emit OwnershipTransferred(address(0), ownerAddress);
        emit OperatorshipTransferred(address(0), operatorAddress);
    }

    function execute(bytes calldata input) external override {
        (bytes memory data, bytes memory signature) = abi.decode(input, (bytes, bytes));

        _execute(data, signature);
    }

    function _execute(bytes memory data, bytes memory sig) internal {
        address signer = ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(data)), sig);

        (
            uint256 chainId,
            Role signerRole,
            bytes32[] memory commandIds,
            string[] memory commands,
            bytes[] memory params
        ) = abi.decode(data, (uint256, Role, bytes32[], string[], bytes[]));

        if (chainId != block.chainid) revert InvalidChainId();

        uint256 commandsLength = commandIds.length;

        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();

        bool isCurrentOwner;
        bool isValidRecentOwner;
        bool isValidRecentOperator;

        if (signerRole == Role.Owner) {
            isCurrentOwner = signer == owner();
            isValidRecentOwner = isCurrentOwner || _isValidPreviousOwner(signer);
        } else if (signerRole == Role.Operator) {
            isValidRecentOperator = _isValidRecentOperator(signer);
        }

        for (uint256 i; i < commandsLength; i++) {
            bytes32 commandId = commandIds[i];

            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */

            bytes4 commandSelector;
            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));

            if (commandHash == SELECTOR_DEPLOY_TOKEN) {
                if (!isValidRecentOwner) continue;

                commandSelector = AxelarGatewaySinglesig.deployToken.selector;
            } else if (commandHash == SELECTOR_MINT_TOKEN) {
                if (!isValidRecentOperator && !isValidRecentOwner) continue;

                commandSelector = AxelarGatewaySinglesig.mintToken.selector;
            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {
                if (!isValidRecentOperator && !isValidRecentOwner) continue;

                commandSelector = AxelarGatewaySinglesig.approveContractCall.selector;
            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {
                if (!isValidRecentOperator && !isValidRecentOwner) continue;

                commandSelector = AxelarGatewaySinglesig.approveContractCallWithMint.selector;
            } else if (commandHash == SELECTOR_BURN_TOKEN) {
                if (!isValidRecentOperator && !isValidRecentOwner) continue;

                commandSelector = AxelarGatewaySinglesig.burnToken.selector;
            } else if (commandHash == SELECTOR_TRANSFER_OWNERSHIP) {
                if (!isCurrentOwner) continue;

                commandSelector = AxelarGatewaySinglesig.transferOwnership.selector;
            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {
                if (!isCurrentOwner) continue;

                commandSelector = AxelarGatewaySinglesig.transferOperatorship.selector;
            } else {
                continue; /* Ignore if unknown command received */
            }

            // Prevent a re-entrancy from executing this command before it can be marked as successful.
            _setCommandExecuted(commandId, true);
            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));
            _setCommandExecuted(commandId, success);

            if (success) {
                emit Executed(commandId);
            }
        }
    }
}",2452
RealWorld_BA_109_AddressFormat_RealWord_20240829172943.log,109,AddressFormat,6188,4227,10415,69.0,0.11548,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

library AddressFormat {
    function toLowerString(address a) internal pure returns (string memory) {
        bytes memory data = abi.encodePacked(a);
        bytes memory characters = '0123456789abcdef';
        bytes memory byteString = new bytes(2 + data.length * 2);

        byteString[0] = '0';
        byteString[1] = 'x';

        for (uint256 i = 0; i < data.length; i++) {
            byteString[2 + i * 2] = characters[uint256(uint8(data[i] >> 4))];
            byteString[3 + i * 2] = characters[uint256(uint8(data[i] & 0x0f))];
        }
        return string(byteString);
    }
}",178
RealWorld_BA_109_AxelarGatewayProxy_RealWord_20240829170519.log,109,AxelarGatewayProxy,8799,4998,13797,84.0,0.143955,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IAxelarGateway } from './interfaces/IAxelarGateway.sol';

import { EternalStorage } from './EternalStorage.sol';

contract AxelarGatewayProxy is EternalStorage {
    error SetupFailed();

    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.
    bytes32 internal constant KEY_IMPLEMENTATION =
        bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);

    constructor(address gatewayImplementation, bytes memory params) {
        _setAddress(KEY_IMPLEMENTATION, gatewayImplementation);

        (bool success, ) = gatewayImplementation.delegatecall(
            abi.encodeWithSelector(IAxelarGateway.setup.selector, params)
        );

        if (!success) revert SetupFailed();
    }

    function setup(bytes calldata params) external {}

    fallback() external payable {
        address implementation = getAddress(KEY_IMPLEMENTATION);

        assembly {
            calldatacopy(0, 0, calldatasize())

            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)

            returndatacopy(0, 0, returndatasize())

            switch result
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }

    receive() external payable {
        revert('NO_ETHER');
    }
}",347
RealWorld_BA_109_ERC20_RealWord_20240829170645.log,109,ERC20,34285,5857,40142,89.0,0.288565,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IERC20 } from './interfaces/IERC20.sol';

import { Context } from './Context.sol';

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20 {
    mapping(address => uint256) public override balanceOf;

    mapping(address => mapping(address => uint256)) public override allowance;

    uint256 public override totalSupply;

    string public name;
    string public symbol;

    uint8 public immutable decimals;

    /**
     * @dev Sets the values for {name}, {symbol}, and {decimals}.
     *
     * All three of these values are immutable: they can only be set once during
     * construction.
     */
    constructor(
        string memory name_,
        string memory symbol_,
        uint8 decimals_
    ) {
        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * Requirements:
     *
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), allowance[sender][_msgSender()] - amount);
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, allowance[_msgSender()][spender] + addedValue);
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, allowance[_msgSender()][spender] - subtractedValue);
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal virtual {
        require(sender != address(0), 'ZERO_ADDR');
        require(recipient != address(0), 'ZERO_ADDR');

        _beforeTokenTransfer(sender, recipient, amount);

        balanceOf[sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), 'ZERO_ADDR');

        _beforeTokenTransfer(address(0), account, amount);

        totalSupply += amount;
        balanceOf[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), 'ZERO_ADDR');

        _beforeTokenTransfer(account, address(0), amount);

        balanceOf[account] -= amount;
        totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), 'ZERO_ADDR');
        require(spender != address(0), 'ZERO_ADDR');

        allowance[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be to transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}
}",1935
RealWorld_BA_109_DestinationSwapExecutable_RealWord_20240829172645.log,109,DestinationSwapExecutable,6366,4956,11322,93.0,0.13095,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IAxelarExecutable } from '../interfaces/IAxelarExecutable.sol';
import { IERC20 } from '../interfaces/IERC20.sol';
import { TokenSwapper } from './TokenSwapper.sol';

contract DestinationSwapExecutable is IAxelarExecutable {
    address swapper;

    constructor(address gatewayAddress, address swapperAddress) IAxelarExecutable(gatewayAddress) {
        swapper = swapperAddress;
    }

    function _executeWithToken(
        string memory,
        string memory,
        bytes calldata payload,
        string memory tokenSymbol,
        uint256 amount
    ) internal override {
        (address toTokenAddress, address recipient) = abi.decode(payload, (address, address));

        address tokenAddress = _getTokenAddress(tokenSymbol);
        IERC20(tokenAddress).approve(swapper, amount);
        TokenSwapper(swapper).swap(tokenAddress, amount, toTokenAddress, recipient);
    }
}",213
RealWorld_BA_109_BurnableMintableCappedERC20_RealWord_20240829172529.log,109,BurnableMintableCappedERC20,11609,5166,16775,73.0,0.161365,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { MintableCappedERC20 } from './MintableCappedERC20.sol';
import { DepositHandler } from './DepositHandler.sol';
import { EternalStorage } from './EternalStorage.sol';

contract BurnableMintableCappedERC20 is MintableCappedERC20 {
    // keccak256('token-frozen')
    bytes32 private constant PREFIX_TOKEN_FROZEN =
        bytes32(0x1a7261d3a36c4ce4235d10859911c9444a6963a3591ec5725b96871d9810626b);

    // keccak256('all-tokens-frozen')
    bytes32 private constant KEY_ALL_TOKENS_FROZEN =
        bytes32(0x75a31d1ce8e5f9892188befc328d3b9bd3fa5037457e881abc21f388471b8d96);

    event Frozen(address indexed owner);
    event Unfrozen(address indexed owner);

    constructor(
        string memory name,
        string memory symbol,
        uint8 decimals,
        uint256 capacity
    ) MintableCappedERC20(name, symbol, decimals, capacity) {}

    function depositAddress(bytes32 salt) public view returns (address) {
        /* Convert a hash which is bytes32 to an address which is 20-byte long
        according to https://docs.soliditylang.org/en/v0.8.1/control-structures.html?highlight=create2#salted-contract-creations-create2 */
        return
            address(
                uint160(
                    uint256(
                        keccak256(
                            abi.encodePacked(
                                bytes1(0xff),
                                owner,
                                salt,
                                keccak256(abi.encodePacked(type(DepositHandler).creationCode))
                            )
                        )
                    )
                )
            );
    }

    function burn(bytes32 salt) public onlyOwner {
        address account = depositAddress(salt);
        _burn(account, balanceOf[account]);
    }

    function _beforeTokenTransfer(
        address,
        address,
        uint256
    ) internal view override {
        require(!EternalStorage(owner).getBool(KEY_ALL_TOKENS_FROZEN), 'IS_FROZEN');
        require(!EternalStorage(owner).getBool(keccak256(abi.encodePacked(PREFIX_TOKEN_FROZEN, symbol))), 'IS_FROZEN');
    }
}",528
RealWorld_BA_109_TokenSwapper_RealWord_20240829172820.log,109,TokenSwapper,6364,4697,11061,81.0,0.12576,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IERC20 } from '../interfaces/IERC20.sol';

contract TokenSwapper {
    address tokenA;
    address tokenB;

    constructor(address tokenA_, address tokenB_) {
        tokenA = tokenA_;
        tokenB = tokenB_;
    }

    function swap(
        address tokenAddress,
        uint256 amount,
        address toTokenAddress,
        address recipient
    ) external returns (uint256 convertedAmount) {
        IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);

        if (tokenAddress == tokenA) {
            require(toTokenAddress == tokenB, 'WRONG TOKEN PAIR');
            convertedAmount = amount * 2;
        } else {
            require(tokenAddress == tokenB && toTokenAddress == tokenA, 'WRONG TOKEN PAIR');
            convertedAmount = amount / 2;
        }

        IERC20(toTokenAddress).transfer(recipient, convertedAmount);
    }
}",215
RealWorld_BA_109_IAxelarExecutable_RealWord_20240829173316.log,109,IAxelarExecutable,9338,4854,14192,84.0,0.14377,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IAxelarGateway } from './IAxelarGateway.sol';

abstract contract IAxelarExecutable {
    error NotApprovedByGateway();

    IAxelarGateway public gateway;

    constructor(address gateway_) {
        gateway = IAxelarGateway(gateway_);
    }

    function execute(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes calldata payload
    ) external {
        bytes32 payloadHash = keccak256(payload);
        if (!IAxelarGateway(gateway).validateContractCall(commandId, sourceChain, sourceAddress, payloadHash))
            revert NotApprovedByGateway();
        _execute(sourceChain, sourceAddress, payload);
    }

    function executeWithToken(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes calldata payload,
        string memory tokenSymbol,
        uint256 amount
    ) external {
        bytes32 payloadHash = keccak256(payload);
        if (
            !IAxelarGateway(gateway).validateContractCallAndMint(
                commandId,
                sourceChain,
                sourceAddress,
                payloadHash,
                tokenSymbol,
                amount
            )
        ) revert NotApprovedByGateway();

        _executeWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount);
    }

    function _getTokenAddress(string memory tokenSymbol) internal view returns (address) {
        return IAxelarGateway(gateway).tokenAddresses(tokenSymbol);
    }

    function _execute(
        string memory sourceChain,
        string memory sourceAddress,
        bytes calldata payload
    ) internal virtual {}

    function _executeWithToken(
        string memory sourceChain,
        string memory sourceAddress,
        bytes calldata payload,
        string memory tokenSymbol,
        uint256 amount
    ) internal virtual {}
}",398
RealWorld_BA_109_TokenDeployer_RealWord_20240829171720.log,109,TokenDeployer,4888,4458,9346,73.0,0.1136,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { BurnableMintableCappedERC20 } from './BurnableMintableCappedERC20.sol';

contract TokenDeployer {
    function deployToken(
        string memory name,
        string memory symbol,
        uint8 decimals,
        uint256 cap,
        bytes32 salt
    ) external returns (address tokenAddress) {
        tokenAddress = address(new BurnableMintableCappedERC20{ salt: salt }(name, symbol, decimals, cap));
    }
}",117
RealWorld_BA_109_Ownable_RealWord_20240829170816.log,109,Ownable,5010,3570,8580,67.0,0.09645,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

abstract contract Ownable {
    address public owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        owner = msg.sender;
        emit OwnershipTransferred(address(0), msg.sender);
    }

    modifier onlyOwner() {
        require(owner == msg.sender, 'NOT_OWNER');
        _;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), 'ZERO_ADDR');

        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}",132
RealWorld_BA_109_MintableCappedERC20_RealWord_20240829172002.log,109,MintableCappedERC20,7884,5183,13067,80.0,0.14308,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IERC20BurnFrom } from './interfaces/IERC20BurnFrom.sol';

import { ERC20 } from './ERC20.sol';
import { ERC20Permit } from './ERC20Permit.sol';
import { Ownable } from './Ownable.sol';

contract MintableCappedERC20 is ERC20, ERC20Permit, Ownable, IERC20BurnFrom {
    uint256 public cap;

    constructor(
        string memory name,
        string memory symbol,
        uint8 decimals,
        uint256 capacity
    ) ERC20(name, symbol, decimals) ERC20Permit(name) Ownable() {
        cap = capacity;
    }

    function mint(address account, uint256 amount) public onlyOwner {
        uint256 capacity = cap;
        require(capacity == 0 || totalSupply + amount <= capacity, 'CAP_EXCEEDED');

        _mint(account, amount);
    }

    // TODO move burnFrom into a separate BurnableERC20 contract
    function burnFrom(address account, uint256 amount) external onlyOwner {
        _approve(account, owner, allowance[account][owner] - amount);
        _burn(account, amount);
    }
}",259
RealWorld_BA_109_IAxelarGatewayMultisig_RealWord_20240829173728.log,109,IAxelarGatewayMultisig,6266,5224,11490,97.0,0.13581,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IAxelarGateway } from './IAxelarGateway.sol';

interface IAxelarGatewayMultisig is IAxelarGateway {
    event OwnershipTransferred(address[] preOwners, uint256 prevThreshold, address[] newOwners, uint256 newThreshold);

    event OperatorshipTransferred(
        address[] preOperators,
        uint256 prevThreshold,
        address[] newOperators,
        uint256 newThreshold
    );

    function ownerEpoch() external view returns (uint256);

    function ownerThreshold(uint256 epoch) external view returns (uint256);

    function owners(uint256 epoch) external view returns (address[] memory);

    function operatorEpoch() external view returns (uint256);

    function operatorThreshold(uint256 epoch) external view returns (uint256);

    function operators(uint256 epoch) external view returns (address[] memory);
}",192
RealWorld_BA_109_IAxelarGateway_RealWord_20240829173559.log,109,IAxelarGateway,17475,5474,22949,87.0,0.196855,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

interface IAxelarGateway {
    /**********\
    |* Events *|
    \**********/

    event TokenSent(
        address indexed sender,
        string destinationChain,
        string destinationAddress,
        string symbol,
        uint256 amount
    );

    event ContractCall(
        address indexed sender,
        string destinationChain,
        string destinationContractAddress,
        bytes32 indexed payloadHash,
        bytes payload
    );

    event ContractCallWithToken(
        address indexed sender,
        string destinationChain,
        string destinationContractAddress,
        bytes32 indexed payloadHash,
        bytes payload,
        string symbol,
        uint256 amount
    );

    event Executed(bytes32 indexed commandId);

    event TokenDeployed(string symbol, address tokenAddresses);

    event ContractCallApproved(
        bytes32 indexed commandId,
        string sourceChain,
        string sourceAddress,
        address indexed contractAddress,
        bytes32 indexed payloadHash,
        bytes32 sourceTxHash,
        uint256 sourceEventIndex
    );

    event ContractCallApprovedWithMint(
        bytes32 indexed commandId,
        string sourceChain,
        string sourceAddress,
        address indexed contractAddress,
        bytes32 indexed payloadHash,
        string symbol,
        uint256 amount,
        bytes32 sourceTxHash,
        uint256 sourceEventIndex
    );

    event TokenFrozen(string symbol);

    event TokenUnfrozen(string symbol);

    event AllTokensFrozen();

    event AllTokensUnfrozen();

    event AccountBlacklisted(address indexed account);

    event AccountWhitelisted(address indexed account);

    event Upgraded(address indexed implementation);

    /******************\
    |* Public Methods *|
    \******************/

    function sendToken(
        string memory destinationChain,
        string memory destinationAddress,
        string memory symbol,
        uint256 amount
    ) external;

    function callContract(
        string memory destinationChain,
        string memory contractAddress,
        bytes memory payload
    ) external;

    function callContractWithToken(
        string memory destinationChain,
        string memory contractAddress,
        bytes memory payload,
        string memory symbol,
        uint256 amount
    ) external;

    function isContractCallApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) external view returns (bool);

    function isContractCallAndMintApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) external view returns (bool);

    function validateContractCall(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes32 payloadHash
    ) external returns (bool);

    function validateContractCallAndMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) external returns (bool);

    /***********\
    |* Getters *|
    \***********/

    function allTokensFrozen() external view returns (bool);

    function implementation() external view returns (address);

    function tokenAddresses(string memory symbol) external view returns (address);

    function tokenFrozen(string memory symbol) external view returns (bool);

    function isCommandExecuted(bytes32 commandId) external view returns (bool);

    function adminEpoch() external view returns (uint256);

    function adminThreshold(uint256 epoch) external view returns (uint256);

    function admins(uint256 epoch) external view returns (address[] memory);

    /*******************\
    |* Admin Functions *|
    \*******************/

    function freezeToken(string memory symbol) external;

    function unfreezeToken(string memory symbol) external;

    function freezeAllTokens() external;

    function unfreezeAllTokens() external;

    function upgrade(
        address newImplementation,
        bytes32 newImplementationCodeHash,
        bytes calldata setupParams
    ) external;

    /**********************\
    |* External Functions *|
    \**********************/

    function setup(bytes calldata params) external;

    function execute(bytes calldata input) external;
}",886
RealWorld_BA_109_IERC20_RealWord_20240829173054.log,109,IERC20,12817,4621,17438,71.0,0.156505,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",617
RealWorld_BA_109_AxelarGatewayMultisig_RealWord_20240829171114.log,109,AxelarGatewayMultisig,75955,5776,81731,104.0,0.495295,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IAxelarGatewayMultisig } from './interfaces/IAxelarGatewayMultisig.sol';

import { ECDSA } from './ECDSA.sol';
import { AxelarGateway } from './AxelarGateway.sol';

contract AxelarGatewayMultisig is IAxelarGatewayMultisig, AxelarGateway {
    error InvalidAddress();
    error InvalidOwners();
    error InvalidOwnerThreshold();
    error DuplicateOwner(address owner);
    error InvalidOperators();
    error InvalidOperatorThreshold();
    error DuplicateOperator(address operator);
    error NotProxy();
    error InvalidChainId();
    error MalformedSigners();
    error InvalidCommands();

    // AUDIT: slot names should be prefixed with some standard string
    // AUDIT: constants should be literal and their derivation should be in comments
    bytes32 internal constant KEY_OWNER_EPOCH = keccak256('owner-epoch');

    bytes32 internal constant PREFIX_OWNER = keccak256('owner');
    bytes32 internal constant PREFIX_OWNER_COUNT = keccak256('owner-count');
    bytes32 internal constant PREFIX_OWNER_THRESHOLD = keccak256('owner-threshold');
    bytes32 internal constant PREFIX_IS_OWNER = keccak256('is-owner');

    bytes32 internal constant KEY_OPERATOR_EPOCH = keccak256('operator-epoch');

    bytes32 internal constant PREFIX_OPERATOR = keccak256('operator');
    bytes32 internal constant PREFIX_OPERATOR_COUNT = keccak256('operator-count');
    bytes32 internal constant PREFIX_OPERATOR_THRESHOLD = keccak256('operator-threshold');
    bytes32 internal constant PREFIX_IS_OPERATOR = keccak256('is-operator');

    constructor(address tokenDeployer) AxelarGateway(tokenDeployer) {}

    function _isSortedAscAndContainsNoDuplicate(address[] memory accounts) internal pure returns (bool) {
        for (uint256 i; i < accounts.length - 1; ++i) {
            if (accounts[i] >= accounts[i + 1]) {
                return false;
            }
        }

        return true;
    }

    /************************\
    |* Owners Functionality *|
    \************************/

    /********************\
    |* Pure Key Getters *|
    \********************/

    function _getOwnerKey(uint256 epoch, uint256 index) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OWNER, epoch, index));
    }

    function _getOwnerCountKey(uint256 epoch) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OWNER_COUNT, epoch));
    }

    function _getOwnerThresholdKey(uint256 epoch) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OWNER_THRESHOLD, epoch));
    }

    function _getIsOwnerKey(uint256 epoch, address account) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_IS_OWNER, epoch, account));
    }

    /***********\
    |* Getters *|
    \***********/

    function _ownerEpoch() internal view returns (uint256) {
        return getUint(KEY_OWNER_EPOCH);
    }

    function _getOwner(uint256 epoch, uint256 index) internal view returns (address) {
        return getAddress(_getOwnerKey(epoch, index));
    }

    function _getOwnerCount(uint256 epoch) internal view returns (uint256) {
        return getUint(_getOwnerCountKey(epoch));
    }

    function _getOwnerThreshold(uint256 epoch) internal view returns (uint256) {
        return getUint(_getOwnerThresholdKey(epoch));
    }

    function _isOwner(uint256 epoch, address account) internal view returns (bool) {
        return getBool(_getIsOwnerKey(epoch, account));
    }

    /// @dev Returns true if a sufficient quantity of `accounts` are owners within the last `OLD_KEY_RETENTION + 1` owner epochs (excluding the current one).
    function _areValidPreviousOwners(address[] memory accounts) internal view returns (bool) {
        uint256 epoch = _ownerEpoch();
        uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);
        uint256 lowerBoundOwnerEpoch = epoch > recentEpochs ? epoch - recentEpochs : uint256(0);

        --epoch;
        while (epoch > lowerBoundOwnerEpoch) {
            if (_areValidOwnersInEpoch(epoch--, accounts)) return true;
        }

        return false;
    }

    /// @dev Returns true if a sufficient quantity of `accounts` are owners in the `ownerEpoch`.
    function _areValidOwnersInEpoch(uint256 epoch, address[] memory accounts) internal view returns (bool) {
        uint256 threshold = _getOwnerThreshold(epoch);
        uint256 validSignerCount;

        for (uint256 i; i < accounts.length; i++) {
            if (_isOwner(epoch, accounts[i]) && ++validSignerCount >= threshold) return true;
        }

        return false;
    }

    /// @dev Returns the current `ownerEpoch`.
    function ownerEpoch() external view override returns (uint256) {
        return _ownerEpoch();
    }

    /// @dev Returns the threshold for a given `ownerEpoch`.
    function ownerThreshold(uint256 epoch) external view override returns (uint256) {
        return _getOwnerThreshold(epoch);
    }

    /// @dev Returns the array of owners within a given `ownerEpoch`.
    function owners(uint256 epoch) public view override returns (address[] memory results) {
        uint256 ownerCount = _getOwnerCount(epoch);
        results = new address[](ownerCount);

        for (uint256 i; i < ownerCount; i++) {
            results[i] = _getOwner(epoch, i);
        }
    }

    /***********\
    |* Setters *|
    \***********/

    function _setOwnerEpoch(uint256 epoch) internal {
        _setUint(KEY_OWNER_EPOCH, epoch);
    }

    function _setOwner(
        uint256 epoch,
        uint256 index,
        address account
    ) internal {
        if (account == address(0)) revert InvalidAddress();

        _setAddress(_getOwnerKey(epoch, index), account);
    }

    function _setOwnerCount(uint256 epoch, uint256 ownerCount) internal {
        _setUint(_getOwnerCountKey(epoch), ownerCount);
    }

    function _setOwners(
        uint256 epoch,
        address[] memory accounts,
        uint256 threshold
    ) internal {
        uint256 accountLength = accounts.length;

        if (accountLength < threshold) revert InvalidOwners();

        if (threshold == uint256(0)) revert InvalidOwnerThreshold();

        _setOwnerThreshold(epoch, threshold);
        _setOwnerCount(epoch, accountLength);

        for (uint256 i; i < accountLength; i++) {
            address account = accounts[i];

            // Check that the account wasn't already set as an owner for this ownerEpoch.
            if (_isOwner(epoch, account)) revert DuplicateOwner(account);

            // Set this account as the i-th owner in this ownerEpoch (needed to we can get all the owners for `owners`).
            _setOwner(epoch, i, account);
            _setIsOwner(epoch, account, true);
        }
    }

    function _setOwnerThreshold(uint256 epoch, uint256 threshold) internal {
        _setUint(_getOwnerThresholdKey(epoch), threshold);
    }

    function _setIsOwner(
        uint256 epoch,
        address account,
        bool isOwner
    ) internal {
        _setBool(_getIsOwnerKey(epoch, account), isOwner);
    }

    /**************************\
    |* Operator Functionality *|
    \**************************/

    /********************\
    |* Pure Key Getters *|
    \********************/

    function _getOperatorKey(uint256 epoch, uint256 index) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OPERATOR, epoch, index));
    }

    function _getOperatorCountKey(uint256 epoch) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OPERATOR_COUNT, epoch));
    }

    function _getOperatorThresholdKey(uint256 epoch) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OPERATOR_THRESHOLD, epoch));
    }

    function _getIsOperatorKey(uint256 epoch, address account) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_IS_OPERATOR, epoch, account));
    }

    /***********\
    |* Getters *|
    \***********/

    function _operatorEpoch() internal view returns (uint256) {
        return getUint(KEY_OPERATOR_EPOCH);
    }

    function _getOperator(uint256 epoch, uint256 index) internal view returns (address) {
        return getAddress(_getOperatorKey(epoch, index));
    }

    function _getOperatorCount(uint256 epoch) internal view returns (uint256) {
        return getUint(_getOperatorCountKey(epoch));
    }

    function _getOperatorThreshold(uint256 epoch) internal view returns (uint256) {
        return getUint(_getOperatorThresholdKey(epoch));
    }

    function _isOperator(uint256 epoch, address account) internal view returns (bool) {
        return getBool(_getIsOperatorKey(epoch, account));
    }

    /// @dev Returns true if a sufficient quantity of `accounts` are operator in the same `operatorEpoch`, within the last `OLD_KEY_RETENTION + 1` operator epochs.
    function _areValidRecentOperators(address[] memory accounts) internal view returns (bool) {
        uint256 epoch = _operatorEpoch();
        uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);
        uint256 lowerBoundOperatorEpoch = epoch > recentEpochs ? epoch - recentEpochs : uint256(0);

        while (epoch > lowerBoundOperatorEpoch) {
            if (_areValidOperatorsInEpoch(epoch--, accounts)) return true;
        }

        return false;
    }

    /// @dev Returns true if a sufficient quantity of `accounts` are operator in the `operatorEpoch`.
    function _areValidOperatorsInEpoch(uint256 epoch, address[] memory accounts) internal view returns (bool) {
        uint256 threshold = _getOperatorThreshold(epoch);
        uint256 validSignerCount;

        for (uint256 i; i < accounts.length; i++) {
            if (_isOperator(epoch, accounts[i]) && ++validSignerCount >= threshold) return true;
        }

        return false;
    }

    /// @dev Returns the current `operatorEpoch`.
    function operatorEpoch() external view override returns (uint256) {
        return _operatorEpoch();
    }

    /// @dev Returns the threshold for a given `operatorEpoch`.
    function operatorThreshold(uint256 epoch) external view override returns (uint256) {
        return _getOperatorThreshold(epoch);
    }

    /// @dev Returns the array of operators within a given `operatorEpoch`.
    function operators(uint256 epoch) public view override returns (address[] memory results) {
        uint256 operatorCount = _getOperatorCount(epoch);
        results = new address[](operatorCount);

        for (uint256 i; i < operatorCount; i++) {
            results[i] = _getOperator(epoch, i);
        }
    }

    /***********\
    |* Setters *|
    \***********/

    function _setOperatorEpoch(uint256 epoch) internal {
        _setUint(KEY_OPERATOR_EPOCH, epoch);
    }

    function _setOperator(
        uint256 epoch,
        uint256 index,
        address account
    ) internal {
        _setAddress(_getOperatorKey(epoch, index), account);
    }

    function _setOperatorCount(uint256 epoch, uint256 operatorCount) internal {
        _setUint(_getOperatorCountKey(epoch), operatorCount);
    }

    function _setOperators(
        uint256 epoch,
        address[] memory accounts,
        uint256 threshold
    ) internal {
        uint256 accountLength = accounts.length;

        if (accountLength < threshold) revert InvalidOperators();

        if (threshold == uint256(0)) revert InvalidOperatorThreshold();

        _setOperatorThreshold(epoch, threshold);
        _setOperatorCount(epoch, accountLength);

        for (uint256 i; i < accountLength; i++) {
            address account = accounts[i];

            // Check that the account wasn't already set as an operator for this operatorEpoch.
            if (_isOperator(epoch, account)) revert DuplicateOperator(account);

            if (account == address(0)) revert InvalidAddress();

            // Set this account as the i-th operator in this operatorEpoch (needed to we can get all the operators for `operators`).
            _setOperator(epoch, i, account);
            _setIsOperator(epoch, account, true);
        }
    }

    function _setOperatorThreshold(uint256 epoch, uint256 threshold) internal {
        _setUint(_getOperatorThresholdKey(epoch), threshold);
    }

    function _setIsOperator(
        uint256 epoch,
        address account,
        bool isOperator
    ) internal {
        _setBool(_getIsOperatorKey(epoch, account), isOperator);
    }

    /**********************\
    |* Self Functionality *|
    \**********************/

    function deployToken(bytes calldata params, bytes32) external onlySelf {
        (string memory name, string memory symbol, uint8 decimals, uint256 cap, address tokenAddr) = abi.decode(
            params,
            (string, string, uint8, uint256, address)
        );

        _deployToken(name, symbol, decimals, cap, tokenAddr);
    }

    function mintToken(bytes calldata params, bytes32) external onlySelf {
        (string memory symbol, address account, uint256 amount) = abi.decode(params, (string, address, uint256));

        _mintToken(symbol, account, amount);
    }

    function burnToken(bytes calldata params, bytes32) external onlySelf {
        (string memory symbol, bytes32 salt) = abi.decode(params, (string, bytes32));

        _burnToken(symbol, salt);
    }

    function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {
        (
            string memory sourceChain,
            string memory sourceAddress,
            address contractAddress,
            bytes32 payloadHash,
            bytes32 sourceTxHash,
            uint256 sourceEventIndex
        ) = abi.decode(params, (string, string, address, bytes32, bytes32, uint256));

        _approveContractCall(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            sourceTxHash,
            sourceEventIndex
        );
    }

    function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {
        (
            string memory sourceChain,
            string memory sourceAddress,
            address contractAddress,
            bytes32 payloadHash,
            string memory symbol,
            uint256 amount,
            bytes32 sourceTxHash,
            uint256 sourceEventIndex
        ) = abi.decode(params, (string, string, address, bytes32, string, uint256, bytes32, uint256));

        _approveContractCallWithMint(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            symbol,
            amount,
            sourceTxHash,
            sourceEventIndex
        );
    }

    function transferOwnership(bytes calldata params, bytes32) external onlySelf {
        (address[] memory newOwners, uint256 newThreshold) = abi.decode(params, (address[], uint256));

        uint256 epoch = _ownerEpoch();

        emit OwnershipTransferred(owners(epoch), _getOwnerThreshold(epoch), newOwners, newThreshold);

        _setOwnerEpoch(++epoch);
        _setOwners(epoch, newOwners, newThreshold);
    }

    function transferOperatorship(bytes calldata params, bytes32) external onlySelf {
        (address[] memory newOperators, uint256 newThreshold) = abi.decode(params, (address[], uint256));

        uint256 epoch = _operatorEpoch();

        emit OperatorshipTransferred(operators(epoch), _getOperatorThreshold(epoch), newOperators, newThreshold);

        _setOperatorEpoch(++epoch);
        _setOperators(epoch, newOperators, newThreshold);
    }

    /**************************\
    |* External Functionality *|
    \**************************/

    function setup(bytes calldata params) external override {
        // Prevent setup from being called on a non-proxy (the implementation).
        if (implementation() == address(0)) revert NotProxy();

        (
            address[] memory adminAddresses,
            uint256 newAdminThreshold,
            address[] memory ownerAddresses,
            uint256 newOwnerThreshold,
            address[] memory operatorAddresses,
            uint256 newOperatorThreshold
        ) = abi.decode(params, (address[], uint256, address[], uint256, address[], uint256));

        uint256 newAdminEpoch = _adminEpoch() + uint256(1);
        _setAdminEpoch(newAdminEpoch);
        _setAdmins(newAdminEpoch, adminAddresses, newAdminThreshold);

        uint256 newOwnerEpoch = _ownerEpoch() + uint256(1);
        _setOwnerEpoch(newOwnerEpoch);
        _setOwners(newOwnerEpoch, ownerAddresses, newOwnerThreshold);

        uint256 newOperatorEpoch = _operatorEpoch() + uint256(1);
        _setOperatorEpoch(newOperatorEpoch);
        _setOperators(newOperatorEpoch, operatorAddresses, newOperatorThreshold);

        emit OwnershipTransferred(new address[](uint256(0)), uint256(0), ownerAddresses, newOwnerThreshold);
        emit OperatorshipTransferred(new address[](uint256(0)), uint256(0), operatorAddresses, newOperatorThreshold);
    }

    function execute(bytes calldata input) external override {
        (bytes memory data, bytes[] memory signatures) = abi.decode(input, (bytes, bytes[]));

        _execute(data, signatures);
    }

    function _execute(bytes memory data, bytes[] memory signatures) internal {
        uint256 signatureCount = signatures.length;

        address[] memory signers = new address[](signatureCount);

        for (uint256 i; i < signatureCount; i++) {
            signers[i] = ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(data)), signatures[i]);
        }

        (
            uint256 chainId,
            Role signersRole,
            bytes32[] memory commandIds,
            string[] memory commands,
            bytes[] memory params
        ) = abi.decode(data, (uint256, Role, bytes32[], string[], bytes[]));

        if (chainId != block.chainid) revert InvalidChainId();

        if (!_isSortedAscAndContainsNoDuplicate(signers)) revert MalformedSigners();

        uint256 commandsLength = commandIds.length;

        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();

        bool areValidCurrentOwners;
        bool areValidRecentOwners;
        bool areValidRecentOperators;

        if (signersRole == Role.Owner) {
            areValidCurrentOwners = _areValidOwnersInEpoch(_ownerEpoch(), signers);
            areValidRecentOwners = areValidCurrentOwners || _areValidPreviousOwners(signers);
        } else if (signersRole == Role.Operator) {
            areValidRecentOperators = _areValidRecentOperators(signers);
        }

        for (uint256 i; i < commandsLength; i++) {
            bytes32 commandId = commandIds[i];

            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */

            bytes4 commandSelector;
            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));

            if (commandHash == SELECTOR_DEPLOY_TOKEN) {
                if (!areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.deployToken.selector;
            } else if (commandHash == SELECTOR_MINT_TOKEN) {
                if (!areValidRecentOperators && !areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.mintToken.selector;
            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {
                if (!areValidRecentOperators && !areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.approveContractCall.selector;
            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {
                if (!areValidRecentOperators && !areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.approveContractCallWithMint.selector;
            } else if (commandHash == SELECTOR_BURN_TOKEN) {
                if (!areValidRecentOperators && !areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.burnToken.selector;
            } else if (commandHash == SELECTOR_TRANSFER_OWNERSHIP) {
                if (!areValidCurrentOwners) continue;

                commandSelector = AxelarGatewayMultisig.transferOwnership.selector;
            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {
                if (!areValidCurrentOwners) continue;

                commandSelector = AxelarGatewayMultisig.transferOperatorship.selector;
            } else {
                continue; /* Ignore if unknown command received */
            }

            // Prevent a re-entrancy from executing this command before it can be marked as successful.
            _setCommandExecuted(commandId, true);
            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));
            _setCommandExecuted(commandId, success);

            if (success) {
                emit Executed(commandId);
            }
        }
    }
}",4538
RealWorld_BA_109_Context_RealWord_20240829172124.log,109,Context,6130,3119,9249,56.0,0.09303,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}",195
RealWorld_BA_112_MockVault_RealWord_20240829184621.log,112,MockVault,7965,4866,12831,90.0,0.137145,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../vault/EthVault.sol"";
import ""../vault/Erc20Vault.sol"";

abstract contract MockVaultMethods is Vault {
    function setStrategy(address _strategy) external onlyGovernance returns (bool) {
        if (address(getStrategy()) == _strategy) return false;

        _setConfig(_STRATEGY_KEY, _strategy);
        return true;
    }

    function setTargetAllocation(uint256 allocation) external onlyGovernance returns (uint256) {
        _setConfig(_TARGET_ALLOCATION_KEY, allocation);
        return allocation;
    }

    function setBound(uint256 newBound) external onlyGovernance returns (uint256) {
        _setConfig(_BOUND_KEY, newBound);
        return newBound;
    }

    function depositToReserve(address coin, uint256 amount) external {
        IERC20(coin).approve(address(reserve), amount);
        reserve.deposit(coin, amount);
    }

    function withdrawFromReserve(address coin, uint256 amount) external {
        reserve.withdraw(coin, amount);
    }
}

contract MockErc20Vault is Erc20Vault, MockVaultMethods {
    constructor(IController controller) Erc20Vault(controller) {}
}

contract MockEthVault is EthVault, MockVaultMethods {
    constructor(IController controller) EthVault(controller) {}
}",292
RealWorld_BA_112_ICTokenRegistry_RealWord_20240829201640.log,112,ICTokenRegistry,4907,4873,9780,80.0,0.121995,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./vendor/CToken.sol"";

interface ICTokenRegistry {
    function getCToken(address underlying) external view returns (CToken);

    function getCToken(address underlying, bool ensureExists) external view returns (CToken);

    function fetchCToken(address underlying) external returns (CToken);
}",85
RealWorld_BA_112_BkdToken_RealWord_20240829193135.log,112,BkdToken,6486,4643,11129,75.0,0.12529,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../../interfaces/tokenomics/IBkdToken.sol"";

import ""../../libraries/ScaledMath.sol"";
import ""../../libraries/Errors.sol"";

contract BkdToken is IBkdToken, ERC20 {
    using ScaledMath for uint256;

    address public immutable minter;

    constructor(
        string memory name_,
        string memory symbol_,
        address _minter
    ) ERC20(name_, symbol_) {
        minter = _minter;
    }

    /**
     * @notice Mints tokens for a given address.
     * @dev Fails if msg.sender is not the minter.
     * @param account Account for which tokens should be minted.
     * @param amount Amount of tokens to mint.
     */
    function mint(address account, uint256 amount) external override {
        require(msg.sender == minter, Error.UNAUTHORIZED_ACCESS);
        _mint(account, amount);
    }
}",223
RealWorld_BA_112_LpGauge_RealWord_20240829193252.log,112,LpGauge,19728,5119,24847,86.0,0.20102,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../interfaces/IStakerVault.sol"";
import ""../../interfaces/IController.sol"";
import ""../../interfaces/tokenomics/ILpGauge.sol"";
import ""../../interfaces/tokenomics/IRewardsGauge.sol"";

import ""../../libraries/ScaledMath.sol"";
import ""../../libraries/Errors.sol"";
import ""../../libraries/AddressProviderHelpers.sol"";

import ""../access/Authorization.sol"";

contract LpGauge is ILpGauge, IRewardsGauge, Authorization {
    using AddressProviderHelpers for IAddressProvider;
    using ScaledMath for uint256;

    IController public immutable controller;
    IStakerVault public immutable stakerVault;
    IInflationManager public immutable inflationManager;

    uint256 public poolStakedIntegral;
    uint256 public poolLastUpdate;
    mapping(address => uint256) public perUserStakedIntegral;
    mapping(address => uint256) public perUserShare;

    constructor(IController _controller, address _stakerVault)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        require(address(_controller) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        require(_stakerVault != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        controller = IController(_controller);
        stakerVault = IStakerVault(_stakerVault);
        IInflationManager _inflationManager = IController(_controller).inflationManager();
        require(address(_inflationManager) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        inflationManager = _inflationManager;
    }

    /**
     * @notice Checkpoint function for the pool statistics.
     * @return `true` if successful.
     */
    function poolCheckpoint() external override returns (bool) {
        return _poolCheckpoint();
    }

    /**
     * @notice Calculates the token rewards a user should receive and mints these.
     * @param beneficiary Address to claim rewards for.
     * @return `true` if success.
     */
    function claimRewards(address beneficiary) external override returns (uint256) {
        require(
            msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );
        userCheckpoint(beneficiary);
        uint256 amount = perUserShare[beneficiary];
        if (amount <= 0) return 0;
        perUserShare[beneficiary] = 0;
        _mintRewards(beneficiary, amount);
        return amount;
    }

    function claimableRewards(address beneficiary) external view override returns (uint256) {
        uint256 poolTotalStaked = stakerVault.getPoolTotalStaked();
        uint256 poolStakedIntegral_ = poolStakedIntegral;
        if (poolTotalStaked > 0) {
            poolStakedIntegral_ += (inflationManager.getLpRateForStakerVault(address(stakerVault)) *
                (block.timestamp - poolLastUpdate)).scaledDiv(poolTotalStaked);
        }

        return
            perUserShare[beneficiary] +
            stakerVault.stakedAndActionLockedBalanceOf(beneficiary).scaledMul(
                poolStakedIntegral_ - perUserStakedIntegral[beneficiary]
            );
    }

    /**
     * @notice Checkpoint function for the statistics for a particular user.
     * @param user Address of the user to checkpoint.
     * @return `true` if successful.
     */
    function userCheckpoint(address user) public override returns (bool) {
        _poolCheckpoint();

        // No checkpoint for the actions and strategies, since this does not accumulate tokens
        if (
            IController(controller).addressProvider().isAction(user) || stakerVault.isStrategy(user)
        ) {
            return false;
        }
        uint256 poolStakedIntegral_ = poolStakedIntegral;
        perUserShare[user] += (
            (stakerVault.stakedAndActionLockedBalanceOf(user)).scaledMul(
                (poolStakedIntegral_ - perUserStakedIntegral[user])
            )
        );

        perUserStakedIntegral[user] = poolStakedIntegral_;

        return true;
    }

    function _mintRewards(address beneficiary, uint256 amount) internal {
        inflationManager.mintRewards(beneficiary, amount);
    }

    function _poolCheckpoint() internal returns (bool) {
        uint256 currentRate = inflationManager.getLpRateForStakerVault(address(stakerVault));
        // Update the integral of total token supply for the pool
        uint256 poolTotalStaked = stakerVault.getPoolTotalStaked();
        if (poolTotalStaked > 0) {
            poolStakedIntegral += (currentRate * (block.timestamp - poolLastUpdate)).scaledDiv(
                poolTotalStaked
            );
        }
        poolLastUpdate = block.timestamp;
        return true;
    }
}",1024
RealWorld_BA_112_MockAction_RealWord_20240829185603.log,112,MockAction,9760,5882,15642,90.0,0.16644,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../interfaces/actions/IAction.sol"";
import ""../../interfaces/IGasBank.sol"";

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

contract MockAction is IAction {
    using EnumerableSet for EnumerableSet.AddressSet;
    mapping(address => uint256) private _totalGasRegistered;

    EnumerableSet.AddressSet private _usableTokens;

    receive() external payable {}

    function setEthRequiredForGas(address payer, uint256 amount) external {
        _totalGasRegistered[payer] = amount;
    }

    function withdrawFromGasBank(
        IGasBank bank,
        address account,
        uint256 amount
    ) external {
        bank.withdrawFrom(account, payable(address(this)), amount);
    }

    function addUsableToken(address token) external override returns (bool) {
        return _usableTokens.add(token);
    }

    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        return _totalGasRegistered[payer];
    }

    function getUsableTokens() external pure returns (address[] memory) {
        return new address[](0);
    }

    function isUsable(address) external pure returns (bool) {
        return false;
    }

    function getActionFee() external pure returns (uint256) {
        return 0;
    }

    function getFeeHandler() external pure returns (address) {
        return address(0);
    }

    function executeActionFee() external pure returns (uint256) {
        return 0;
    }

    function executeSwapperSlippage() external pure returns (uint256) {
        return 0;
    }

    function executeFeeHandler() external pure returns (address) {
        return address(0);
    }
}",382
RealWorld_BA_112_ICvxLocker_RealWord_20240829211022.log,112,ICvxLocker,7831,4822,12653,92.0,0.135595,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface ICvxLocker {
    function getReward(address _account, bool _stake) external;

    function balanceOf(address _user) external view returns (uint256);

    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external;

    function processExpiredLocks(bool _relock) external;

    function withdrawExpiredLocksTo(address _withdrawTo) external;

    function maximumBoostPayment() external returns (uint256);

    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external;

    function lockedBalanceOf(address _user) external view returns (uint256 amount);

    function checkpointEpoch() external;

    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 indexed _epoch,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );

    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(address indexed _user, address indexed _kicked, uint256 _reward);
    event RewardPaid(address indexed _user, address indexed _rewardsToken, uint256 _reward);
    event Recovered(address _token, uint256 _amount);
}",301
RealWorld_BA_112_IAddressProvider_RealWord_20240829203014.log,112,IAddressProvider,14277,5357,19634,100.0,0.178525,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./pool/ILiquidityPool.sol"";
import ""./IPreparable.sol"";
import ""./IGasBank.sol"";
import ""./oracles/IOracleProvider.sol"";
import ""../libraries/AddressProviderMeta.sol"";

// solhint-disable ordering

interface IAddressProvider is IPreparable {
    event KnownAddressKeyAdded(bytes32 indexed key);
    event StakerVaultListed(address indexed stakerVault);
    event StakerVaultDelisted(address indexed stakerVault);
    event ActionListed(address indexed action);
    event PoolListed(address indexed pool);
    event PoolDelisted(address indexed pool);
    event VaultUpdated(address indexed previousVault, address indexed newVault);

    /** Key functions */
    function getKnownAddressKeys() external view returns (bytes32[] memory);

    function freezeAddress(bytes32 key) external;

    /** Pool functions */

    function allPools() external view returns (address[] memory);

    function addPool(address pool) external;

    function poolsCount() external view returns (uint256);

    function getPoolAtIndex(uint256 index) external view returns (address);

    function isPool(address pool) external view returns (bool);

    function removePool(address pool) external returns (bool);

    function getPoolForToken(address token) external view returns (ILiquidityPool);

    function safeGetPoolForToken(address token) external view returns (address);

    /** Vault functions  */

    function updateVault(address previousVault, address newVault) external;

    function allVaults() external view returns (address[] memory);

    function vaultsCount() external view returns (uint256);

    function getVaultAtIndex(uint256 index) external view returns (address);

    function isVault(address vault) external view returns (bool);

    /** Action functions */

    function allActions() external view returns (address[] memory);

    function addAction(address action) external returns (bool);

    function isAction(address action) external view returns (bool);

    /** Address functions */
    function initializeAddress(
        bytes32 key,
        address initialAddress,
        bool frezable
    ) external;

    function initializeAndFreezeAddress(bytes32 key, address initialAddress) external;

    function getAddress(bytes32 key) external view returns (address);

    function getAddress(bytes32 key, bool checkExists) external view returns (address);

    function getAddressMeta(bytes32 key) external view returns (AddressProviderMeta.Meta memory);

    function prepareAddress(bytes32 key, address newAddress) external returns (bool);

    function executeAddress(bytes32 key) external returns (address);

    function resetAddress(bytes32 key) external returns (bool);

    /** Staker vault functions */
    function allStakerVaults() external view returns (address[] memory);

    function tryGetStakerVault(address token) external view returns (bool, address);

    function getStakerVault(address token) external view returns (address);

    function addStakerVault(address stakerVault) external returns (bool);

    function isStakerVault(address stakerVault, address token) external view returns (bool);

    function isStakerVaultRegistered(address stakerVault) external view returns (bool);

    function isWhiteListedFeeHandler(address feeHandler) external view returns (bool);
}",687
RealWorld_BA_112_AddressProviderMeta_RealWord_20240829201334.log,112,AddressProviderMeta,5699,3994,9693,76.0,0.108375,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

library AddressProviderMeta {
    struct Meta {
        bool freezable;
        bool frozen;
    }

    function fromUInt(uint256 value) internal pure returns (Meta memory) {
        Meta memory meta;
        meta.freezable = (value & 1) == 1;
        meta.frozen = ((value >> 1) & 1) == 1;
        return meta;
    }

    function toUInt(Meta memory meta) internal pure returns (uint256) {
        uint256 value;
        value |= meta.freezable ? 1 : 0;
        value |= meta.frozen ? 1 << 1 : 0;
        return value;
    }
}",165
RealWorld_BA_112_IVault_RealWord_20240829202400.log,112,IVault,8455,5363,13818,105.0,0.149535,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./IStrategy.sol"";
import ""./IPreparable.sol"";

/**
 * @title Interface for a Vault
 */

interface IVault is IPreparable {
    event StrategyActivated(address indexed strategy);

    event StrategyDeactivated(address indexed strategy);

    /**
     * @dev 'netProfit' is the profit after all fees have been deducted
     */
    event Harvest(uint256 indexed netProfit, uint256 indexed loss);

    function initialize(
        address _pool,
        uint256 _debtLimit,
        uint256 _targetAllocation,
        uint256 _bound
    ) external;

    function withdrawFromStrategyWaitingForRemoval(address strategy) external returns (uint256);

    function deposit() external payable;

    function withdraw(uint256 amount) external returns (bool);

    function initializeStrategy(address strategy_) external returns (bool);

    function withdrawAll() external;

    function withdrawFromReserve(uint256 amount) external;

    function executeNewStrategy() external returns (address);

    function prepareNewStrategy(address newStrategy) external returns (bool);

    function getStrategy() external view returns (IStrategy);

    function getStrategiesWaitingForRemoval() external view returns (address[] memory);

    function getAllocatedToStrategyWaitingForRemoval(address strategy)
        external
        view
        returns (uint256);

    function getTotalUnderlying() external view returns (uint256);

    function getUnderlying() external view returns (address);
}",318
RealWorld_BA_112_ICurveSwapEth_RealWord_20240829211438.log,112,ICurveSwapEth,9758,5686,15444,91.0,0.16251,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface ICurveSwapEth {
    function get_virtual_price() external view returns (uint256);

    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount) external payable;

    function add_liquidity(uint256[3] calldata amounts, uint256 min_mint_amount) external payable;

    function remove_liquidity_imbalance(uint256[3] calldata amounts, uint256 max_burn_amount)
        external;

    function remove_liquidity_imbalance(uint256[2] calldata amounts, uint256 max_burn_amount)
        external;

    function remove_liquidity(uint256 _amount, uint256[3] calldata min_amounts) external;

    function exchange(
        uint256 i,
        uint256 j,
        uint256 dx,
        uint256 min_dy
    ) external payable;

    function coins(uint256 i) external view returns (address);

    function get_dy(
        uint256 i,
        uint256 j,
        uint256 dx
    ) external view returns (uint256);

    function calc_token_amount(uint256[3] calldata amounts, bool deposit)
        external
        view
        returns (uint256);

    function calc_token_amount(uint256[2] calldata amounts, bool deposit)
        external
        view
        returns (uint256);

    function calc_withdraw_one_coin(uint256 _token_amount, int128 i)
        external
        view
        returns (uint256);

    function remove_liquidity_one_coin(
        uint256 _token_amount,
        int128 i,
        uint256 min_amount
    ) external;
}",356
RealWorld_BA_112_Authorization_RealWord_20240829181434.log,112,Authorization,4628,4851,9479,82.0,0.12016,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./AuthorizationBase.sol"";

contract Authorization is AuthorizationBase {
    IRoleManager internal immutable __roleManager;

    constructor(IRoleManager roleManager) {
        __roleManager = roleManager;
    }

    function _roleManager() internal view override returns (IRoleManager) {
        return __roleManager;
    }
}",89
RealWorld_BA_112_ChainlinkAggregator_RealWord_20240829211611.log,112,ChainlinkAggregator,8729,5133,13862,93.0,0.146305,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface AggregatorInterface {
    function latestAnswer() external view returns (int256);

    function latestTimestamp() external view returns (uint256);

    function latestRound() external view returns (uint256);

    function getAnswer(uint256 roundId) external view returns (int256);

    function getTimestamp(uint256 roundId) external view returns (uint256);

    event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);
    event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);
}

interface AggregatorV3Interface {
    function decimals() external view returns (uint8);

    function description() external view returns (string memory);

    function version() external view returns (uint256);

    // getRoundData and latestRoundData should both raise ""No data present""
    // if they do not have data to report, instead of returning unset values
    // which could be misinterpreted as actual reported values.
    function getRoundData(uint80 _roundId)
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );

    function latestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );
}

interface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}",334
RealWorld_BA_112_ComptrollerStorage_RealWord_20240829213747.log,112,ComptrollerStorage,20302,5510,25812,118.0,0.21171,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

import ""./CToken.sol"";
import ""./PriceOracle.sol"";

contract UnitrollerAdminStorage {
    /**
     * @notice Administrator for this contract
     */
    address public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address public pendingAdmin;

    /**
     * @notice Active brains of Unitroller
     */
    address public comptrollerImplementation;

    /**
     * @notice Pending brains of Unitroller
     */
    address public pendingComptrollerImplementation;
}

contract ComptrollerV1Storage is UnitrollerAdminStorage {
    /**
     * @notice Oracle which gives the price of any given asset
     */
    PriceOracle public oracle;

    /**
     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow
     */
    uint256 public closeFactorMantissa;

    /**
     * @notice Multiplier representing the discount on collateral that a liquidator receives
     */
    uint256 public liquidationIncentiveMantissa;

    /**
     * @notice Max number of assets a single account can participate in (borrow or use as collateral)
     */
    uint256 public maxAssets;

    /**
     * @notice Per-account mapping of ""assets you are in"", capped by maxAssets
     */
    mapping(address => CToken[]) public accountAssets;
}

contract ComptrollerV2Storage is ComptrollerV1Storage {
    struct Market {
        /// @notice Whether or not this market is listed
        bool isListed;
        /**
         * @notice Multiplier representing the most one can borrow against their collateral in this market.
         *  For instance, 0.9 to allow borrowing 90% of collateral value.
         *  Must be between 0 and 1, and stored as a mantissa.
         */
        uint256 collateralFactorMantissa;
        /// @notice Per-market mapping of ""accounts in this asset""
        mapping(address => bool) accountMembership;
        /// @notice Whether or not this market receives COMP
        bool isComped;
    }

    /**
     * @notice Official mapping of cTokens -> Market metadata
     * @dev Used e.g. to determine if a market is supported
     */
    mapping(address => Market) public markets;

    /**
     * @notice The Pause Guardian can pause certain actions as a safety mechanism.
     *  Actions which allow users to remove their own assets cannot be paused.
     *  Liquidation / seizing / transfer can only be paused globally, not by market.
     */
    address public pauseGuardian;
    bool public _mintGuardianPaused;
    bool public _borrowGuardianPaused;
    bool public transferGuardianPaused;
    bool public seizeGuardianPaused;
    mapping(address => bool) public mintGuardianPaused;
    mapping(address => bool) public borrowGuardianPaused;
}

contract ComptrollerV3Storage is ComptrollerV2Storage {
    struct CompMarketState {
        /// @notice The market's last updated compBorrowIndex or compSupplyIndex
        uint224 index;
        /// @notice The block number the index was last updated at
        uint32 block;
    }

    /// @notice A list of all markets
    CToken[] public allMarkets;

    /// @notice The rate at which the flywheel distributes COMP, per block
    uint256 public compRate;

    /// @notice The portion of compRate that each market currently receives
    mapping(address => uint256) public compSpeeds;

    /// @notice The COMP market supply state for each market
    mapping(address => CompMarketState) public compSupplyState;

    /// @notice The COMP market borrow state for each market
    mapping(address => CompMarketState) public compBorrowState;

    /// @notice The COMP borrow index for each market for each supplier as of the last time they accrued COMP
    mapping(address => mapping(address => uint256)) public compSupplierIndex;

    /// @notice The COMP borrow index for each market for each borrower as of the last time they accrued COMP
    mapping(address => mapping(address => uint256)) public compBorrowerIndex;

    /// @notice The COMP accrued but not yet transferred to each user
    mapping(address => uint256) public compAccrued;
}

contract ComptrollerV4Storage is ComptrollerV3Storage {
    // @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.
    address public borrowCapGuardian;

    // @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.
    mapping(address => uint256) public borrowCaps;
}

contract ComptrollerV5Storage is ComptrollerV4Storage {
    /// @notice The portion of COMP that each contributor receives per block
    mapping(address => uint256) public compContributorSpeeds;

    /// @notice Last block at which a contributor's COMP rewards have been allocated
    mapping(address => uint256) public lastContributorBlock;
}",1067
RealWorld_BA_112_MockSwapper3Crv_RealWord_20240829183345.log,112,MockSwapper3Crv,5730,4585,10315,75.0,0.12035,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../swappers/Swapper3Crv.sol"";

contract MockSwapper3Crv is Swapper3Crv {
    // Wrapped internal methods for testing only
    function getBestDex(
        address fromToken,
        address toToken,
        uint256 amount
    ) external view returns (address bestDex, uint256 amountOut) {
        return _getBestDex(fromToken, toToken, amount);
    }

    function tokenAmountOut(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        address dex
    ) external view returns (uint256) {
        return _tokenAmountOut(tokenIn, tokenOut, amountIn, dex);
    }
}",170
RealWorld_BA_112_AddressProviderKeys_RealWord_20240829201050.log,112,AddressProviderKeys,5597,3524,9121,86.0,0.098465,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

library AddressProviderKeys {
    bytes32 internal constant _TREASURY_KEY = ""treasury"";
    bytes32 internal constant _GAS_BANK_KEY = ""gasBank"";
    bytes32 internal constant _VAULT_RESERVE_KEY = ""vaultReserve"";
    bytes32 internal constant _SWAPPER_REGISTRY_KEY = ""swapperRegistry"";
    bytes32 internal constant _ORACLE_PROVIDER_KEY = ""oracleProvider"";
    bytes32 internal constant _POOL_FACTORY_KEY = ""poolFactory"";
    bytes32 internal constant _CONTROLLER_KEY = ""controller"";
    bytes32 internal constant _BKD_LOCKER_KEY = ""bkdLocker"";
    bytes32 internal constant _ROLE_MANAGER_KEY = ""roleManager"";
}",166
RealWorld_BA_112_MockTopUpHandler_RealWord_20240829184019.log,112,MockTopUpHandler,11965,5466,17431,102.0,0.169145,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

import ""../actions/topup/handlers/BaseHandler.sol"";

contract MockTopUpHandler is BaseHandler, Initializable {
    using SafeERC20 for IERC20;

    MockUserFactors public immutable userFactors;

    constructor() {
        userFactors = new MockUserFactors();
    }

    /**
     * @dev Executes the top-up of a position, in this case, just send money back to the user
     */
    function topUp(
        bytes32 account,
        address underlying,
        uint256 amount,
        bytes memory /* extra */
    ) external override returns (bool) {
        address addr = address(bytes20(account));
        if (underlying == address(0)) {
            payable(addr).transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(addr, amount);
        }

        userFactors.increaseUserFactor(addr);

        return true;
    }

    function getUserFactor(bytes32 account, bytes memory) external view override returns (uint256) {
        require(address(userFactors) != address(0), ""user factors not set"");
        address addr = address(bytes20(account));
        return userFactors.getUserFactor(addr);
    }
}

contract MockUserFactors {
    /**
     * @dev all users start with `_DEFAULT_USER_FACTOR` and their position is
     * increased by `_INCREMENT_USER_FACTOR` when they are topped up
     */
    uint256 internal constant _DEFAULT_USER_FACTOR = 1.3e18;
    uint256 internal constant _INCREMENT_USER_FACTOR = 0.3e18;

    mapping(address => uint256) internal _userFactors;

    function increaseUserFactor(address account) external {
        // NOTE: add _INCREMENT_USER_FACTOR to the current user factor to be able
        // to simulate topping up actually increasing the current factor
        uint256 userFactor = _userFactors[account];
        if (userFactor == 0) {
            userFactor = _DEFAULT_USER_FACTOR;
        }
        _userFactors[account] = userFactor + _INCREMENT_USER_FACTOR;
    }

    function getUserFactor(address account) external view returns (uint256) {
        uint256 userFactor = _userFactors[account];
        return userFactor == 0 ? _DEFAULT_USER_FACTOR : userFactor;
    }
}",540
RealWorld_BA_112_StakerVaultProfiler_RealWord_20240829191710.log,112,StakerVaultProfiler,5608,4884,10492,79.0,0.12572,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../StakerVault.sol"";
import ""../../LpToken.sol"";

contract StakerVaultProfiler {
    StakerVault public stakerVault;

    constructor(address _stakerVault) {
        stakerVault = StakerVault(_stakerVault);
        LpToken(stakerVault.token()).approve(address(stakerVault), type(uint256).max);
    }

    function profileStake(uint256 amount) external {
        stakerVault.stake(amount);
        stakerVault.stake(amount);
        stakerVault.stake(amount);
        stakerVault.stake(amount);

        stakerVault.unstake(amount);
        stakerVault.unstake(amount);
        stakerVault.unstake(amount);
    }
}",170
RealWorld_BA_112_CompoundHandler_RealWord_20240829192658.log,112,CompoundHandler,26099,5388,31487,87.0,0.238255,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../../../../libraries/AccountEncoding.sol"";

import ""./BaseHandler.sol"";
import ""../../../../interfaces/ICTokenRegistry.sol"";
import ""../../../../interfaces/vendor/CToken.sol"";
import ""../../../../interfaces/vendor/ExponentialNoError.sol"";
import ""../../../../interfaces/vendor/Comptroller.sol"";
import ""../../../../libraries/Errors.sol"";
import ""../../../../libraries/ScaledMath.sol"";

contract CompoundHandler is BaseHandler, ExponentialNoError {
    using ScaledMath for uint256;
    using SafeERC20 for IERC20;
    using AccountEncoding for bytes32;

    struct AccountLiquidityLocalVars {
        uint256 sumCollateral;
        uint256 sumBorrow;
        uint256 cTokenBalance;
        uint256 borrowBalance;
        uint256 exchangeRateMantissa;
        uint256 oraclePriceMantissa;
        Exp collateralFactor;
        Exp exchangeRate;
        Exp oraclePrice;
        Exp tokensToDenom;
    }

    Comptroller public immutable comptroller;
    ICTokenRegistry public immutable cTokenRegistry;

    constructor(address comptrollerAddress, address _cTokenRegistry) {
        comptroller = Comptroller(comptrollerAddress);
        cTokenRegistry = ICTokenRegistry(_cTokenRegistry);
    }

    /**
     * @notice Executes the top-up of a position.
     * @param account Account holding the position.
     * @param underlying Underlying for tup-up.
     * @param amount Amount to top-up by.
     * @return `true` if successful.
     */
    function topUp(
        bytes32 account,
        address underlying,
        uint256 amount,
        bytes memory extra
    ) external override returns (bool) {
        bool repayDebt = abi.decode(extra, (bool));
        CToken ctoken = cTokenRegistry.fetchCToken(underlying);
        uint256 initialTokens = ctoken.balanceOf(address(this));

        address addr = account.addr();

        if (repayDebt) {
            amount -= _repayAnyDebt(addr, underlying, amount, ctoken);
            if (amount == 0) return true;
        }

        uint256 err;
        if (underlying == address(0)) {
            err = ctoken.mint{value: amount}(amount);
        } else {
            IERC20(underlying).safeApprove(address(ctoken), amount);
            err = ctoken.mint(amount);
        }
        require(err == 0, Error.FAILED_MINT);

        uint256 newTokens = ctoken.balanceOf(address(this));
        uint256 mintedTokens = newTokens - initialTokens;

        bool success = ctoken.transfer(addr, mintedTokens);
        require(success, Error.FAILED_TRANSFER);
        return true;
    }

    /**
     * @notice Returns the collaterization ratio of the user.
     *         A result of 1.5 (x1e18) means that the user has a 150% collaterization ratio.
     * @param account account for which to check the factor.
     * @return User factor.
     */
    function getUserFactor(bytes32 account, bytes memory) external view override returns (uint256) {
        (uint256 sumCollateral, uint256 sumBorrow) = _getAccountBorrowsAndSupply(account.addr());
        if (sumBorrow == 0) {
            return type(uint256).max;
        }
        return sumCollateral.scaledDiv(sumBorrow);
    }

    /**
     * @notice Repays any existing debt for the given underlying.
     * @param account Account for which to repay the debt.
     * @param underlying The underlying token to repay the debt for.
     * @param maximum The maximum amount of debt to repay.
     * @return The amount of debt that was repayed in the underlying.
     */
    function _repayAnyDebt(
        address account,
        address underlying,
        uint256 maximum,
        CToken ctoken
    ) internal returns (uint256) {
        uint256 debt = ctoken.borrowBalanceCurrent(account);
        if (debt == 0) return 0;
        if (debt > maximum) debt = maximum;

        uint256 err;
        if (underlying == address(0)) {
            CEther cether = CEther(address(ctoken));
            err = cether.repayBorrowBehalf{value: debt}(account);
        } else {
            IERC20(underlying).safeApprove(address(ctoken), debt);
            err = ctoken.repayBorrowBehalf(account, debt);
        }
        require(err == 0, Error.FAILED_REPAY_BORROW);

        return debt;
    }

    function _getAccountBorrowsAndSupply(address account) internal view returns (uint256, uint256) {
        AccountLiquidityLocalVars memory vars; // Holds all our calculation results
        uint256 oErr;

        PriceOracle oracle = comptroller.oracle();
        // For each asset the account is in
        CToken[] memory assets = comptroller.getAssetsIn(account);
        for (uint256 i = 0; i < assets.length; i++) {
            CToken asset = assets[i];

            // Read the balances and exchange rate from the cToken
            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset
                .getAccountSnapshot(account);
            require(oErr == 0, Error.FAILED_METHOD_CALL);
            (, uint256 collateralFactorMantissa, ) = comptroller.markets(address(asset));
            vars.collateralFactor = Exp({mantissa: collateralFactorMantissa});
            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});

            // Get the normalized price of the asset
            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);
            require(vars.oraclePriceMantissa != 0, Error.FAILED_METHOD_CALL);
            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});

            // Pre-compute a conversion factor from tokens -> ether (normalized price value)
            vars.tokensToDenom = mul_(
                mul_(vars.collateralFactor, vars.exchangeRate),
                vars.oraclePrice
            );

            // sumCollateral += tokensToDenom * cTokenBalance
            vars.sumCollateral = mul_ScalarTruncateAddUInt(
                vars.tokensToDenom,
                vars.cTokenBalance,
                vars.sumCollateral
            );

            // sumBorrow += oraclePrice * borrowBalance
            vars.sumBorrow = mul_ScalarTruncateAddUInt(
                vars.oraclePrice,
                vars.borrowBalance,
                vars.sumBorrow
            );
        }

        return (vars.sumCollateral, vars.sumBorrow);
    }
}",1456
RealWorld_BA_112_ILendingPool_RealWord_20240829213137.log,112,ILendingPool,66832,5946,72778,103.0,0.45308,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

import ""../../libraries/vendor/DataTypes.sol"";

interface ILendingPool {
    /**
     * @dev Emitted on deposit()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address initiating the deposit
     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens
     * @param amount The amount deposited
     * @param referral The referral code used
     **/
    event Deposit(
        address indexed reserve,
        address user,
        address indexed onBehalfOf,
        uint256 amount,
        uint16 indexed referral
    );

    /**
     * @dev Emitted on withdraw()
     * @param reserve The address of the underlyng asset being withdrawn
     * @param user The address initiating the withdrawal, owner of aTokens
     * @param to Address that will receive the underlying
     * @param amount The amount to be withdrawn
     **/
    event Withdraw(
        address indexed reserve,
        address indexed user,
        address indexed to,
        uint256 amount
    );

    /**
     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened
     * @param reserve The address of the underlying asset being borrowed
     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just
     * initiator of the transaction on flashLoan()
     * @param onBehalfOf The address that will be getting the debt
     * @param amount The amount borrowed out
     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable
     * @param borrowRate The numeric rate at which the user has borrowed
     * @param referral The referral code used
     **/
    event Borrow(
        address indexed reserve,
        address user,
        address indexed onBehalfOf,
        uint256 amount,
        uint256 borrowRateMode,
        uint256 borrowRate,
        uint16 indexed referral
    );

    /**
     * @dev Emitted on repay()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The beneficiary of the repayment, getting his debt reduced
     * @param repayer The address of the user initiating the repay(), providing the funds
     * @param amount The amount repaid
     **/
    event Repay(
        address indexed reserve,
        address indexed user,
        address indexed repayer,
        uint256 amount
    );

    /**
     * @dev Emitted on swapBorrowRateMode()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user swapping his rate mode
     * @param rateMode The rate mode that the user wants to swap to
     **/
    event Swap(address indexed reserve, address indexed user, uint256 rateMode);

    /**
     * @dev Emitted on setUserUseReserveAsCollateral()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user enabling the usage as collateral
     **/
    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on setUserUseReserveAsCollateral()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user enabling the usage as collateral
     **/
    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on rebalanceStableBorrowRate()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user for which the rebalance has been executed
     **/
    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on flashLoan()
     * @param target The address of the flash loan receiver contract
     * @param initiator The address initiating the flash loan
     * @param asset The address of the asset being flash borrowed
     * @param amount The amount flash borrowed
     * @param premium The fee flash borrowed
     * @param referralCode The referral code used
     **/
    event FlashLoan(
        address indexed target,
        address indexed initiator,
        address indexed asset,
        uint256 amount,
        uint256 premium,
        uint16 referralCode
    );

    /**
     * @dev Emitted when the pause is triggered.
     */
    event Paused();

    /**
     * @dev Emitted when the pause is lifted.
     */
    event Unpaused();

    /**
     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via
     * LendingPoolCollateral manager using a DELEGATECALL
     * This allows to have the events in the generated ABI for LendingPool.
     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation
     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation
     * @param user The address of the borrower getting liquidated
     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover
     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator
     * @param liquidator The address of the liquidator
     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants
     * to receive the underlying collateral asset directly
     **/
    event LiquidationCall(
        address indexed collateralAsset,
        address indexed debtAsset,
        address indexed user,
        uint256 debtToCover,
        uint256 liquidatedCollateralAmount,
        address liquidator,
        bool receiveAToken
    );

    /**
     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared
     * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,
     * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it
     * gets added to the LendingPool ABI
     * @param reserve The address of the underlying asset of the reserve
     * @param liquidityRate The new liquidity rate
     * @param stableBorrowRate The new stable borrow rate
     * @param variableBorrowRate The new variable borrow rate
     * @param liquidityIndex The new liquidity index
     * @param variableBorrowIndex The new variable borrow index
     **/
    event ReserveDataUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    /**
     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.
     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC
     * @param asset The address of the underlying asset to deposit
     * @param amount The amount to be deposited
     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user
     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens
     *   is a different wallet
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     **/
    function deposit(
        address asset,
        uint256 amount,
        address onBehalfOf,
        uint16 referralCode
    ) external payable;

    /**
     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned
     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC
     * @param asset The address of the underlying asset to withdraw
     * @param amount The underlying amount to be withdrawn
     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance
     * @param to Address that will receive the underlying, same as msg.sender if the user
     *   wants to receive it on his own wallet, or a different address if the beneficiary is a
     *   different wallet
     * @return The final amount withdrawn
     **/
    function withdraw(
        address asset,
        uint256 amount,
        address to
    ) external returns (uint256);

    /**
     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower
     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the
     * corresponding debt token (StableDebtToken or VariableDebtToken)
     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet
     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`
     * @param asset The address of the underlying asset to borrow
     * @param amount The amount to be borrowed
     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself
     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator
     * if he has been given credit delegation allowance
     **/
    function borrow(
        address asset,
        uint256 amount,
        uint256 interestRateMode,
        uint16 referralCode,
        address onBehalfOf
    ) external;

    /**
     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned
     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address
     * @param asset The address of the borrowed underlying asset previously borrowed
     * @param amount The amount to repay
     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`
     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable
     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the
     * user calling the function if he wants to reduce/remove his own debt, or the address of any other
     * other borrower whose debt should be removed
     * @return The final amount repaid
     **/
    function repay(
        address asset,
        uint256 amount,
        uint256 rateMode,
        address onBehalfOf
    ) external returns (uint256);

    /**
     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa
     * @param asset The address of the underlying asset borrowed
     * @param rateMode The rate mode that the user wants to swap to
     **/
    function swapBorrowRateMode(address asset, uint256 rateMode) external;

    /**
     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.
     * - Users can be rebalanced if the following conditions are satisfied:
     *     1. Usage ratio is above 95%
     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been
     *        borrowed at a stable rate and depositors are not earning enough
     * @param asset The address of the underlying asset borrowed
     * @param user The address of the user to be rebalanced
     **/
    function rebalanceStableBorrowRate(address asset, address user) external;

    /**
     * @dev Allows depositors to enable/disable a specific deposited asset as collateral
     * @param asset The address of the underlying asset deposited
     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise
     **/
    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;

    /**
     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1
     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives
     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk
     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation
     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation
     * @param user The address of the borrower getting liquidated
     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover
     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants
     * to receive the underlying collateral asset directly
     **/
    function liquidationCall(
        address collateralAsset,
        address debtAsset,
        address user,
        uint256 debtToCover,
        bool receiveAToken
    ) external;

    /**
     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,
     * as long as the amount taken plus a fee is returned.
     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.
     * For further details please visit https://developers.aave.com
     * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface
     * @param assets The addresses of the assets being flash-borrowed
     * @param amounts The amounts amounts being flash-borrowed
     * @param modes Types of the debt to open if the flash loan is not returned:
     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver
     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address
     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address
     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2
     * @param params Variadic packed params to pass to the receiver as extra information
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     **/
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata modes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;

    /**
     * @dev Returns the user account data across all the reserves
     * @param user The address of the user
     * @return totalCollateralETH the total collateral in ETH of the user
     * @return totalDebtETH the total debt in ETH of the user
     * @return availableBorrowsETH the borrowing power left of the user
     * @return currentLiquidationThreshold the liquidation threshold of the user
     * @return ltv the loan to value of the user
     * @return healthFactor the current health factor of the user
     **/
    function getUserAccountData(address user)
        external
        view
        returns (
            uint256 totalCollateralETH,
            uint256 totalDebtETH,
            uint256 availableBorrowsETH,
            uint256 currentLiquidationThreshold,
            uint256 ltv,
            uint256 healthFactor
        );

    function initReserve(
        address reserve,
        address aTokenAddress,
        address stableDebtAddress,
        address variableDebtAddress,
        address interestRateStrategyAddress
    ) external;

    function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress)
        external;

    function setConfiguration(address reserve, uint256 configuration) external;

    /**
     * @dev Returns the configuration of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The configuration of the reserve
     **/
    function getConfiguration(address asset)
        external
        view
        returns (DataTypes.ReserveConfigurationMap memory);

    /**
     * @dev Returns the configuration of the user across all the reserves
     * @param user The user address
     * @return The configuration of the user
     **/
    function getUserConfiguration(address user)
        external
        view
        returns (DataTypes.UserConfigurationMap memory);

    /**
     * @dev Returns the normalized income normalized income of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The reserve's normalized income
     */
    function getReserveNormalizedIncome(address asset) external view returns (uint256);

    /**
     * @dev Returns the normalized variable debt per unit of asset
     * @param asset The address of the underlying asset of the reserve
     * @return The reserve normalized variable debt
     */
    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);

    /**
     * @dev Returns the state and configuration of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The state of the reserve
     **/
    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);

    function finalizeTransfer(
        address asset,
        address from,
        address to,
        uint256 amount,
        uint256 balanceFromAfter,
        uint256 balanceToBefore
    ) external;

    function getReservesList() external view returns (address[] memory);

    // function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);

    function setPause(bool val) external;

    function paused() external view returns (bool);
}",3996
RealWorld_BA_112_MockChainlinkFeed_RealWord_20240829185735.log,112,MockChainlinkFeed,5676,4222,9898,69.0,0.11282,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.9;

contract MockChainlinkFeed {
    uint8 public immutable decimals;
    int256 public immutable price;
    uint256 public immutable lastUpdate;

    constructor(
        uint8 _decimals,
        int256 _price,
        uint256 _lastUpdate
    ) {
        decimals = _decimals;
        price = _price;
        lastUpdate = _lastUpdate;
    }

    function latestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        return (0, price, lastUpdate, lastUpdate, 0);
    }
}",167
RealWorld_BA_112_TopUpActionFeeHandler_RealWord_20240829192004.log,112,TopUpActionFeeHandler,34778,4734,39512,84.0,0.26857,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";

import ""../../../interfaces/actions/IActionFeeHandler.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/tokenomics/IKeeperGauge.sol"";

import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/AddressProviderHelpers.sol"";

import ""../../LpToken.sol"";
import ""../../access/Authorization.sol"";
import ""../../pool/LiquidityPool.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice Contract to manage the distribution protocol fees
 */
contract TopUpActionFeeHandler is IActionFeeHandler, Authorization, Preparable {
    using ScaledMath for uint256;
    using SafeERC20Upgradeable for LpToken;
    using AddressProviderHelpers for IAddressProvider;

    bytes32 internal constant _KEEPER_FEE_FRACTION_KEY = ""KeeperFee"";
    bytes32 internal constant _KEEPER_GAUGE_KEY = ""KeeperGauge"";
    bytes32 internal constant _TREASURY_FEE_FRACTION_KEY = ""TreasuryFee"";

    address public immutable actionContract;
    IController public immutable controller;

    mapping(address => uint256) public treasuryAmounts;
    mapping(address => mapping(address => uint256)) public keeperRecords;

    event KeeperFeesClaimed(address indexed keeper, address token, uint256 totalClaimed);

    event FeesPayed(
        address indexed payer,
        address indexed keeper,
        address token,
        uint256 amount,
        uint256 keeperAmount,
        uint256 lpAmount
    );

    constructor(
        IController _controller,
        address _actionContract,
        uint256 keeperFee,
        uint256 treasuryFee
    ) Authorization(_controller.addressProvider().getRoleManager()) {
        require(keeperFee + treasuryFee <= ScaledMath.ONE, Error.INVALID_AMOUNT);
        actionContract = _actionContract;
        controller = _controller;
        _setConfig(_KEEPER_FEE_FRACTION_KEY, keeperFee);
        _setConfig(_TREASURY_FEE_FRACTION_KEY, treasuryFee);
    }

    function setInitialKeeperGaugeForToken(address lpToken, address _keeperGauge)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(getKeeperGauge(lpToken) == address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        require(_keeperGauge != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        _setConfig(_getKeeperGaugeKey(lpToken), _keeperGauge);
        return true;
    }

    /**
     * @notice Transfers the keeper and treasury fees to the fee handler and burns LP fees.
     * @param payer Account who's position the fees are charged on.
     * @param beneficiary Beneficiary of the fees paid (usually this will be the keeper).
     * @param amount Total fee value (both keeper and LP fees).
     * @param lpTokenAddress Address of the lpToken used to pay fees.
     * @return `true` if successful.
     */
    function payFees(
        address payer,
        address beneficiary,
        uint256 amount,
        address lpTokenAddress
    ) external override returns (bool) {
        require(msg.sender == actionContract, Error.UNAUTHORIZED_ACCESS);
        // Handle keeper fees
        uint256 keeperAmount = amount.scaledMul(getKeeperFeeFraction());
        uint256 treasuryAmount = amount.scaledMul(getTreasuryFeeFraction());
        LpToken lpToken = LpToken(lpTokenAddress);

        lpToken.safeTransferFrom(msg.sender, address(this), amount);

        address keeperGauge = getKeeperGauge(lpTokenAddress);
        if (keeperGauge != address(0)) {
            IKeeperGauge(keeperGauge).reportFees(beneficiary, keeperAmount, lpTokenAddress);
        }

        // Accrue keeper and treasury fees here for periodic claiming
        keeperRecords[beneficiary][lpTokenAddress] += keeperAmount;
        treasuryAmounts[lpTokenAddress] += treasuryAmount;

        // Handle LP fees
        uint256 lpAmount = amount - keeperAmount - treasuryAmount;
        lpToken.burn(lpAmount);
        emit FeesPayed(payer, beneficiary, lpTokenAddress, amount, keeperAmount, lpAmount);
        return true;
    }

    /**
     * @notice Claim all accrued fees for an LPToken.
     * @param beneficiary Address to claim the fees for.
     * @param token Address of the lpToken for claiming.
     * @return `true` if successful.
     */
    function claimKeeperFeesForPool(address beneficiary, address token)
        external
        override
        returns (bool)
    {
        uint256 totalClaimable = keeperRecords[beneficiary][token];
        require(totalClaimable > 0, Error.NOTHING_TO_CLAIM);
        keeperRecords[beneficiary][token] = 0;

        LpToken lpToken = LpToken(token);
        lpToken.safeTransfer(beneficiary, totalClaimable);

        emit KeeperFeesClaimed(beneficiary, token, totalClaimable);
        return true;
    }

    /**
     * @notice Claim all accrued treasury fees for an LPToken.
     * @param token Address of the lpToken for claiming.
     * @return `true` if successful.
     */
    function claimTreasuryFees(address token) external override returns (bool) {
        uint256 claimable = treasuryAmounts[token];
        treasuryAmounts[token] = 0;
        LpToken(token).safeTransfer(controller.addressProvider().getTreasury(), claimable);
        return true;
    }

    /**
     * @notice Prepare update of keeper fee (with time delay enforced).
     * @param newKeeperFee New keeper fee value.
     * @return `true` if successful.
     */
    function prepareKeeperFee(uint256 newKeeperFee) external onlyGovernance returns (bool) {
        require(newKeeperFee <= ScaledMath.ONE, Error.INVALID_AMOUNT);
        return _prepare(_KEEPER_FEE_FRACTION_KEY, newKeeperFee);
    }

    /**
     * @notice Execute update of keeper fee (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New keeper fee.
     */
    function executeKeeperFee() external returns (uint256) {
        require(
            pendingUInts256[_TREASURY_FEE_FRACTION_KEY] +
                pendingUInts256[_KEEPER_FEE_FRACTION_KEY] <=
                ScaledMath.ONE,
            Error.INVALID_AMOUNT
        );
        return _executeUInt256(_KEEPER_FEE_FRACTION_KEY);
    }

    function resetKeeperFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_KEEPER_FEE_FRACTION_KEY);
    }

    function prepareKeeperGauge(address lpToken, address newKeeperGauge)
        external
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getKeeperGaugeKey(lpToken), newKeeperGauge);
    }

    function executeKeeperGauge(address lpToken) external returns (address) {
        return _executeAddress(_getKeeperGaugeKey(lpToken));
    }

    function resetKeeperGauge(address lpToken) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getKeeperGaugeKey(lpToken));
    }

    /**
     * @notice Prepare update of treasury fee (with time delay enforced).
     * @param newTreasuryFee New treasury fee value.
     * @return `true` if successful.
     */
    function prepareTreasuryFee(uint256 newTreasuryFee) external onlyGovernance returns (bool) {
        require(newTreasuryFee <= ScaledMath.ONE, Error.INVALID_AMOUNT);
        return _prepare(_TREASURY_FEE_FRACTION_KEY, newTreasuryFee);
    }

    /**
     * @notice Execute update of treasury fee (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New treasury fee.
     */
    function executeTreasuryFee() external returns (uint256) {
        require(
            pendingUInts256[_TREASURY_FEE_FRACTION_KEY] +
                pendingUInts256[_KEEPER_FEE_FRACTION_KEY] <=
                ScaledMath.ONE,
            Error.INVALID_AMOUNT
        );
        return _executeUInt256(_TREASURY_FEE_FRACTION_KEY);
    }

    function resetTreasuryFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_TREASURY_FEE_FRACTION_KEY);
    }

    function getKeeperFeeFraction() public view returns (uint256) {
        return currentUInts256[_KEEPER_FEE_FRACTION_KEY];
    }

    function getKeeperGauge(address lpToken) public view returns (address) {
        return currentAddresses[_getKeeperGaugeKey(lpToken)];
    }

    function getTreasuryFeeFraction() public view returns (uint256) {
        return currentUInts256[_TREASURY_FEE_FRACTION_KEY];
    }

    function _getKeeperGaugeKey(address lpToken) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_KEEPER_GAUGE_KEY, lpToken));
    }
}",2004
RealWorld_BA_112_StrategySwapper_RealWord_20240829182406.log,112,StrategySwapper,57105,5893,62998,96.0,0.403385,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""../../interfaces/IAddressProvider.sol"";
import ""../access/Authorization.sol"";
import ""./IStrategySwapper.sol"";
import ""../../interfaces/vendor/UniswapRouter02.sol"";
import ""../../interfaces/vendor/ICurveSwapEth.sol"";
import ""../../libraries/ScaledMath.sol"";
import ""../../libraries/AddressProviderHelpers.sol"";
import ""../../interfaces/IERC20Full.sol"";
import ""../../interfaces/vendor/IWETH.sol"";

contract StrategySwapper is IStrategySwapper, Authorization {
    using ScaledMath for uint256;
    using SafeERC20 for IERC20;
    using AddressProviderHelpers for IAddressProvider;

    IWETH internal constant _WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH
    UniswapRouter02 internal constant _SUSHISWAP =
        UniswapRouter02(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F); // Sushiswap Router for swaps
    UniswapRouter02 internal constant _UNISWAP =
        UniswapRouter02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); // Uniswap Router for swaps

    IAddressProvider internal immutable _addressProvider; // Address provider used for getting oracle provider

    uint256 public slippageTolerance; // The amount of slippage to allow from the oracle price of an asset
    mapping(address => ICurveSwapEth) public curvePools; // Curve Pool to use for swaps to ETH (if any)
    mapping(address => bool) public swapViaUniswap; // If Uniswap should be used over Sushiswap for swaps

    event SetSlippageTolerance(uint256 value); // Emitted after a succuessful setting of slippage tolerance
    event SetCurvePool(address token, address curvePool); // Emitted after a succuessful setting of a Curve Pool
    event SetSwapViaUniswap(address token, bool swapViaUniswap); // Emitted after a succuessful setting of swap via Uniswap

    constructor(address addressProvider_, uint256 slippageTolerance_)
        Authorization(IAddressProvider(addressProvider_).getRoleManager())
    {
        _addressProvider = IAddressProvider(addressProvider_);
        slippageTolerance = slippageTolerance_;
    }

    receive() external payable {}

    /**
     * @notice Swaps all the balance of a token for WETH.
     * @param token_ Address of the token to swap for WETH.
     */
    function swapAllForWeth(address token_) external override {
        return swapForWeth(token_, IERC20(token_).balanceOf(msg.sender));
    }

    /**
     * @notice Swaps all available WETH for underlying.
     * @param token_ Address of the token to swap WETH to.
     */
    function swapAllWethForToken(address token_) external override {
        IWETH weth_ = _WETH;
        uint256 wethBalance_ = weth_.balanceOf(msg.sender);
        if (wethBalance_ == 0) return;
        weth_.transferFrom(msg.sender, address(this), wethBalance_);

        if (token_ == address(0)) {
            weth_.withdraw(wethBalance_);
            // solhint-disable-next-line avoid-low-level-calls
            (bool sent, ) = payable(msg.sender).call{value: wethBalance_}("""");
            require(sent, ""failed to send eth"");
            return;
        }

        // Handling Curve Pool swaps
        ICurveSwapEth curvePool_ = curvePools[token_];
        if (address(curvePool_) != address(0)) {
            _approve(address(weth_), address(curvePool_));
            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);
            curvePool_.exchange(
                wethIndex_,
                tokenIndex_,
                wethBalance_,
                _minTokenAmountOut(wethBalance_, token_)
            );
            IERC20(token_).safeTransfer(msg.sender, IERC20(token_).balanceOf(address(this)));
            return;
        }

        // Handling Uniswap or Sushiswap swaps
        address[] memory path_ = new address[](2);
        path_[0] = address(weth_);
        path_[1] = token_;
        UniswapRouter02 dex_ = _getDex(token_);
        _approve(address(weth_), address(dex_));
        uint256 amountOut_ = dex_.swapExactTokensForTokens(
            wethBalance_,
            _minTokenAmountOut(wethBalance_, token_),
            path_,
            address(this),
            block.timestamp
        )[1];
        IERC20(token_).safeTransfer(msg.sender, amountOut_);
    }

    /**
     * @notice Set slippage tolerance for swaps.
     * @dev Stored as a multiplier, e.g. 2% would be set as 0.98.
     * @param slippageTolerance_ New slippage tolerance.
     */
    function setSlippageTolerance(uint256 slippageTolerance_) external override onlyGovernance {
        require(slippageTolerance_ <= ScaledMath.ONE, Error.INVALID_SLIPPAGE_TOLERANCE);
        require(slippageTolerance_ > 0.8e18, Error.INVALID_SLIPPAGE_TOLERANCE);
        slippageTolerance = slippageTolerance_;
        emit SetSlippageTolerance(slippageTolerance_);
    }

    /**
     * @notice Sets the Curve Pool to use for swapping a token with WETH.
     * @dev To use Uniswap or Sushiswap instead, set the Curve Pool to the zero address.
     * @param token_ The token to set the Curve Pool for.
     * @param curvePool_ The address of the Curve Pool.
     */
    function setCurvePool(address token_, address curvePool_) external override onlyGovernance {
        require(token_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        require(curvePool_ != address(curvePools[token_]), Error.SAME_ADDRESS_NOT_ALLOWED);
        curvePools[token_] = ICurveSwapEth(curvePool_);
        emit SetCurvePool(token_, curvePool_);
    }

    /**
     * @notice Sets if swaps should go via Uniswap for the given token_.
     * @param token_ The token to set the swapViaUniswap for.
     * @param swapViaUniswap_ If Sushiswap should be use for swaps for token_.
     */
    function setSwapViaUniswap(address token_, bool swapViaUniswap_)
        external
        override
        onlyGovernance
    {
        require(token_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        swapViaUniswap[token_] = swapViaUniswap_;
        emit SetSwapViaUniswap(token_, swapViaUniswap_);
    }

    /**
     * @notice Gets the amount of tokenOut_ that would be received by swapping amountIn_ of tokenIn_.
     * @param tokenIn_ The token to swap in.
     * @param tokenOut_ The token to get out.
     * @param amountIn_ The amount to swap in.
     * @return The amount of tokenOut_ that would be received by swapping amountIn_ of tokenIn_.
     */
    function amountOut(
        address tokenIn_,
        address tokenOut_,
        uint256 amountIn_
    ) external view override returns (uint256) {
        if (amountIn_ == 0) return 0;
        uint256 wethOut_ = _tokenToWethAmountOut(tokenIn_, amountIn_);
        return _wethToTokenAmountOut(tokenOut_, wethOut_);
    }

    /**
     * @notice Swaps a token for WETH.
     * @param token_ Address of the token to swap for WETH.
     * @param amount_ Amount of the token to swap for WETH.
     */
    function swapForWeth(address token_, uint256 amount_) public override {
        if (amount_ == 0) return;
        IERC20(token_).safeTransferFrom(msg.sender, address(this), amount_);

        // Handling Curve Pool swaps
        ICurveSwapEth curvePool_ = curvePools[token_];
        IWETH weth_ = _WETH;
        if (address(curvePool_) != address(0)) {
            _approve(token_, address(curvePool_));
            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);
            curvePool_.exchange(
                tokenIndex_,
                wethIndex_,
                amount_,
                _minWethAmountOut(amount_, token_)
            );
            IERC20(weth_).safeTransfer(msg.sender, weth_.balanceOf(address(this)));
            return;
        }

        // Handling Uniswap or Sushiswap swaps
        address[] memory path_ = new address[](2);
        path_[0] = token_;
        path_[1] = address(weth_);
        UniswapRouter02 dex_ = _getDex(token_);
        _approve(token_, address(dex_));
        uint256 amountOut_ = dex_.swapExactTokensForTokens(
            amount_,
            _minWethAmountOut(amount_, token_),
            path_,
            address(this),
            block.timestamp
        )[1];
        IERC20(weth_).safeTransfer(msg.sender, amountOut_);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token_ The token to approve for.
     * @param spender_ The spender to approve.
     */
    function _approve(address token_, address spender_) internal {
        if (IERC20(token_).allowance(address(this), spender_) > 0) return;
        IERC20(token_).safeApprove(spender_, type(uint256).max);
    }

    /**
     * @dev Gets the dex to use for swapping a given token.
     * @param token_ The token to get the dex for.
     * @return The dex to use for swapping a given token.
     */
    function _getDex(address token_) internal view returns (UniswapRouter02) {
        return swapViaUniswap[token_] ? _UNISWAP : _SUSHISWAP;
    }

    /**
     * @dev Returns the amount of WETH received by swapping amount_ of token_.
     * @param token_ The token to get the amount for swapping to WETH.
     * @param amount_ The amount of token_ that is being swapped to WETH.
     * @return The amount of WETH received by swapping amount_ of token_.
     */
    function _tokenToWethAmountOut(address token_, uint256 amount_)
        internal
        view
        returns (uint256)
    {
        if (amount_ == 0) return 0;
        IWETH weth_ = _WETH;
        if (token_ == address(weth_)) return amount_;
        if (token_ == address(0)) return amount_;

        // Getting amount via Curve Pool if set
        ICurveSwapEth curvePool_ = curvePools[token_];
        if (address(curvePool_) != address(0)) {
            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);
            return curvePool_.get_dy(tokenIndex_, wethIndex_, amount_);
        }

        // Getting amount via Uniswap or Sushiswap
        address[] memory path_ = new address[](2);
        path_[0] = token_;
        path_[1] = address(weth_);
        return _getDex(token_).getAmountsOut(amount_, path_)[1];
    }

    /**
     * @dev Returns the amount of token_ received by swapping amount_ of WETH.
     * @param token_ The token to get the amount for swapping from WETH.
     * @param amount_ The amount of WETH that is being swapped to token_.
     * @return The amount of token_ received by swapping amount_ of WETH.
     */
    function _wethToTokenAmountOut(address token_, uint256 amount_)
        internal
        view
        returns (uint256)
    {
        if (amount_ == 0) return 0;
        IWETH weth_ = _WETH;
        if (token_ == address(weth_)) return amount_;
        if (token_ == address(0)) return amount_;

        // Getting amount via Curve Pool if set
        ICurveSwapEth curvePool_ = curvePools[token_];
        if (address(curvePool_) != address(0)) {
            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);
            return curvePool_.get_dy(wethIndex_, tokenIndex_, amount_);
        }

        // Getting amount via Uniswap or Sushiswap
        address[] memory path_ = new address[](2);
        path_[0] = address(weth_);
        path_[1] = token_;
        return _getDex(token_).getAmountsOut(amount_, path_)[1];
    }

    /**
     * @dev Returns the multiplier for converting a token_ amount to the same decimals as WETH.
     *   For example, USDC (which has decimals of 6) would have a multiplier of 12e18.
     * @param token_ The token to get the decimal multiplier for.
     * @return the multiplier for converting a token_ amount to the same decimals as WETH.
     */
    function _decimalMultiplier(address token_) internal view returns (uint256) {
        return 10**(18 - IERC20Full(token_).decimals());
    }

    /**
     * @dev Returns the Curve Pool coin indicies for a given Token.
     * @param curvePool_ The Curve Pool to return the indicies for.
     * @param token_ The Token to get the indicies for.
     * @return wethIndex_ The coin index for WETH.
     * @return tokenIndex_ The coin index for the Token.
     */
    function _getIndices(ICurveSwapEth curvePool_, address token_)
        internal
        view
        returns (uint256 wethIndex_, uint256 tokenIndex_)
    {
        return curvePool_.coins(1) == token_ ? (0, 1) : (1, 0);
    }

    /**
     * @dev Returns the minimum amount of Token to recieve from swap.
     * @param wethAmount_ The amount of WETH being swapped.
     * @param token_ The Token the WETH is being swapped to.
     * @return minAmountOut The minimum amount of Token to recieve from swap.
     */
    function _minTokenAmountOut(uint256 wethAmount_, address token_)
        internal
        view
        returns (uint256 minAmountOut)
    {
        return
            wethAmount_
                .scaledDiv(_addressProvider.getOracleProvider().getPriceETH(token_))
                .scaledMul(slippageTolerance) / _decimalMultiplier(token_);
    }

    /**
     * @dev Returns the minimum amount of WETH to recieve from swap.
     * @param tokenAmount_ The amount of Token being swapped.
     * @param token_ The Token that is being swapped for WETH.
     * @return minAmountOut The minimum amount of WETH to recieve from swap.
     */
    function _minWethAmountOut(uint256 tokenAmount_, address token_)
        internal
        view
        returns (uint256 minAmountOut)
    {
        return
            tokenAmount_
                .scaledMul(_addressProvider.getOracleProvider().getPriceETH(token_))
                .scaledMul(slippageTolerance) * _decimalMultiplier(token_);
    }
}",3455
RealWorld_BA_112_MockRewardStaking_RealWord_20240829185221.log,112,MockRewardStaking,14938,5414,20352,79.0,0.18297,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./MockBooster.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../../interfaces/vendor/IBooster.sol"";
import ""../../interfaces/vendor/IRewardStaking.sol"";
import ""../testing/MockErc20.sol"";
import ""../utils/CvxMintAmount.sol"";

// solhint-disable no-unused-vars
contract MockRewardStaking is IRewardStaking, CvxMintAmount {
    mapping(address => uint256) public balances;
    mapping(address => uint256) public crvEarned;
    mapping(address => uint256) public cvxEarned;

    address public token;
    address public crvToken;
    address public cvxToken;
    address public booster;

    constructor(
        address _token,
        address _tokenCrv,
        address _tokenCvx
    ) {
        token = _token;
        crvToken = _tokenCrv;
        cvxToken = _tokenCvx;
    }

    function setBooster(address _booster) external {
        booster = _booster;
    }

    function setCrvEarned(address user, uint256 amount) external {
        crvEarned[user] = amount;
        cvxEarned[user] = getCvxMintAmount(amount);
    }

    function stakeFor(address user, uint256 amount) external override {
        IERC20(token).transferFrom(msg.sender, address(this), amount);
        balances[user] += amount;
    }

    function stake(uint256) external override {}

    function stakeAll() external override returns (bool) {
        return true;
    }

    function withdraw(uint256 amount, bool claim) external override returns (bool) {
        return true;
    }

    function withdrawAndUnwrap(uint256 amount, bool claim) external override returns (bool) {
        require(!claim, ""Not implemented claiming in withdraw and unwrap"");
        balances[msg.sender] -= amount;
        IBooster(booster).withdrawTo(0, amount, msg.sender);
        return true;
    }

    function getReward() external override {
        MockErc20(crvToken).mint_for_testing(msg.sender, crvEarned[msg.sender]);
        MockErc20(cvxToken).mint_for_testing(msg.sender, cvxEarned[msg.sender]);
        crvEarned[msg.sender] = 0;
        cvxEarned[msg.sender] = 0;
    }

    function getReward(address _account, bool _claimExtras) external override {
        MockErc20(crvToken).mint_for_testing(_account, crvEarned[_account]);
        MockErc20(cvxToken).mint_for_testing(_account, cvxEarned[_account]);
        crvEarned[_account] = 0;
        cvxEarned[_account] = 0;
    }

    function earned(address account) external view override returns (uint256) {
        return crvEarned[account];
    }

    function extraRewardsLength() external view override returns (uint256) {
        return 0;
    }

    function extraRewards(uint256 _pid) external view override returns (address) {
        return address(0);
    }

    function rewardToken() external view override returns (address) {
        return crvToken;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return balances[account];
    }
}",721
RealWorld_BA_112_Errors_RealWord_20240829200010.log,112,Errors,26857,5419,32276,121.0,0.242665,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

// solhint-disable private-vars-leading-underscore

library Error {
    string internal constant ADDRESS_WHITELISTED = ""address already whitelisted"";
    string internal constant ADMIN_ALREADY_SET = ""admin has already been set once"";
    string internal constant ADDRESS_NOT_WHITELISTED = ""address not whitelisted"";
    string internal constant ADDRESS_NOT_FOUND = ""address not found"";
    string internal constant CONTRACT_INITIALIZED = ""contract can only be initialized once"";
    string internal constant CONTRACT_PAUSED = ""contract is paused"";
    string internal constant UNAUTHORIZED_PAUSE = ""not authorized to pause"";
    string internal constant INVALID_AMOUNT = ""invalid amount"";
    string internal constant INVALID_INDEX = ""invalid index"";
    string internal constant INVALID_VALUE = ""invalid msg.value"";
    string internal constant INVALID_SENDER = ""invalid msg.sender"";
    string internal constant INVALID_TOKEN = ""token address does not match pool's LP token address"";
    string internal constant INVALID_DECIMALS = ""incorrect number of decimals"";
    string internal constant INVALID_ARGUMENT = ""invalid argument"";
    string internal constant INVALID_PARAMETER_VALUE = ""invalid parameter value attempted"";
    string internal constant INVALID_IMPLEMENTATION = ""invalid pool implementation for given coin"";
    string internal constant INVALID_POOL_IMPLEMENTATION =
        ""invalid pool implementation for given coin"";
    string internal constant INVALID_LP_TOKEN_IMPLEMENTATION =
        ""invalid LP Token implementation for given coin"";
    string internal constant INVALID_VAULT_IMPLEMENTATION =
        ""invalid vault implementation for given coin"";
    string internal constant INVALID_STAKER_VAULT_IMPLEMENTATION =
        ""invalid stakerVault implementation for given coin"";
    string internal constant INSUFFICIENT_BALANCE = ""insufficient balance"";
    string internal constant ADDRESS_ALREADY_SET = ""Address is already set"";
    string internal constant INSUFFICIENT_STRATEGY_BALANCE = ""insufficient strategy balance"";
    string internal constant INSUFFICIENT_FUNDS_RECEIVED = ""insufficient funds received"";
    string internal constant ADDRESS_DOES_NOT_EXIST = ""address does not exist"";
    string internal constant ADDRESS_FROZEN = ""address is frozen"";
    string internal constant ROLE_EXISTS = ""role already exists"";
    string internal constant CANNOT_REVOKE_ROLE = ""cannot revoke role"";
    string internal constant UNAUTHORIZED_ACCESS = ""unauthorized access"";
    string internal constant SAME_ADDRESS_NOT_ALLOWED = ""same address not allowed"";
    string internal constant SELF_TRANSFER_NOT_ALLOWED = ""self-transfer not allowed"";
    string internal constant ZERO_ADDRESS_NOT_ALLOWED = ""zero address not allowed"";
    string internal constant ZERO_TRANSFER_NOT_ALLOWED = ""zero transfer not allowed"";
    string internal constant THRESHOLD_TOO_HIGH = ""threshold is too high, must be under 10"";
    string internal constant INSUFFICIENT_THRESHOLD = ""insufficient threshold"";
    string internal constant NO_POSITION_EXISTS = ""no position exists"";
    string internal constant POSITION_ALREADY_EXISTS = ""position already exists"";
    string internal constant PROTOCOL_NOT_FOUND = ""protocol not found"";
    string internal constant TOP_UP_FAILED = ""top up failed"";
    string internal constant SWAP_PATH_NOT_FOUND = ""swap path not found"";
    string internal constant UNDERLYING_NOT_SUPPORTED = ""underlying token not supported"";
    string internal constant NOT_ENOUGH_FUNDS_WITHDRAWN =
        ""not enough funds were withdrawn from the pool"";
    string internal constant FAILED_TRANSFER = ""transfer failed"";
    string internal constant FAILED_MINT = ""mint failed"";
    string internal constant FAILED_REPAY_BORROW = ""repay borrow failed"";
    string internal constant FAILED_METHOD_CALL = ""method call failed"";
    string internal constant NOTHING_TO_CLAIM = ""there is no claimable balance"";
    string internal constant ERC20_BALANCE_EXCEEDED = ""ERC20: transfer amount exceeds balance"";
    string internal constant INVALID_MINTER =
        ""the minter address of the LP token and the pool address do not match"";
    string internal constant STAKER_VAULT_EXISTS = ""a staker vault already exists for the token"";
    string internal constant DEADLINE_NOT_ZERO = ""deadline must be 0"";
    string internal constant DEADLINE_NOT_SET = ""deadline is 0"";
    string internal constant DEADLINE_NOT_REACHED = ""deadline has not been reached yet"";
    string internal constant DELAY_TOO_SHORT = ""delay be at least 3 days"";
    string internal constant INSUFFICIENT_UPDATE_BALANCE =
        ""insufficient funds for updating the position"";
    string internal constant SAME_AS_CURRENT = ""value must be different to existing value"";
    string internal constant NOT_CAPPED = ""the pool is not currently capped"";
    string internal constant ALREADY_CAPPED = ""the pool is already capped"";
    string internal constant EXCEEDS_DEPOSIT_CAP = ""deposit exceeds deposit cap"";
    string internal constant VALUE_TOO_LOW_FOR_GAS = ""value too low to cover gas"";
    string internal constant NOT_ENOUGH_FUNDS = ""not enough funds to withdraw"";
    string internal constant ESTIMATED_GAS_TOO_HIGH = ""too much ETH will be used for gas"";
    string internal constant DEPOSIT_FAILED = ""deposit failed"";
    string internal constant GAS_TOO_HIGH = ""too much ETH used for gas"";
    string internal constant GAS_BANK_BALANCE_TOO_LOW = ""not enough ETH in gas bank to cover gas"";
    string internal constant INVALID_TOKEN_TO_ADD = ""Invalid token to add"";
    string internal constant INVALID_TOKEN_TO_REMOVE = ""token can not be removed"";
    string internal constant TIME_DELAY_NOT_EXPIRED = ""time delay not expired yet"";
    string internal constant UNDERLYING_NOT_WITHDRAWABLE =
        ""pool does not support additional underlying coins to be withdrawn"";
    string internal constant STRATEGY_SHUT_DOWN = ""Strategy is shut down"";
    string internal constant STRATEGY_DOES_NOT_EXIST = ""Strategy does not exist"";
    string internal constant UNSUPPORTED_UNDERLYING = ""Underlying not supported"";
    string internal constant NO_DEX_SET = ""no dex has been set for token"";
    string internal constant INVALID_TOKEN_PAIR = ""invalid token pair"";
    string internal constant TOKEN_NOT_USABLE = ""token not usable for the specific action"";
    string internal constant ADDRESS_NOT_ACTION = ""address is not registered action"";
    string internal constant INVALID_SLIPPAGE_TOLERANCE = ""Invalid slippage tolerance"";
    string internal constant POOL_NOT_PAUSED = ""Pool must be paused to withdraw from reserve"";
    string internal constant INTERACTION_LIMIT = ""Max of one deposit and withdraw per block"";
    string internal constant GAUGE_EXISTS = ""Gauge already exists"";
    string internal constant GAUGE_DOES_NOT_EXIST = ""Gauge does not exist"";
    string internal constant EXCEEDS_MAX_BOOST = ""Not allowed to exceed maximum boost on Convex"";
    string internal constant PREPARED_WITHDRAWAL =
        ""Cannot relock funds when withdrawal is being prepared"";
    string internal constant ASSET_NOT_SUPPORTED = ""Asset not supported"";
    string internal constant STALE_PRICE = ""Price is stale"";
    string internal constant NEGATIVE_PRICE = ""Price is negative"";
    string internal constant NOT_ENOUGH_BKD_STAKED = ""Not enough BKD tokens staked"";
    string internal constant RESERVE_ACCESS_EXCEEDED = ""Reserve access exceeded"";
}",1489
RealWorld_BA_112_MockMinter_RealWord_20240829191115.log,112,MockMinter,5097,4807,9904,89.0,0.121625,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../../interfaces/vendor/IGauge.sol"";
import ""./../MockErc20.sol"";

contract MockMinter is IMinter {
    address public token;

    uint256 private _mintAmount;

    constructor(address _token) {
        token = _token;
    }

    function setMintAmount(uint256 mintAmount_) external {
        _mintAmount = mintAmount_;
    }

    function mint(
        address /* gaugeAddr */
    ) external override {
        MockErc20(token).mintFor(msg.sender, _mintAmount);
    }
}",134
RealWorld_BA_112_ChainlinkOracleProvider_RealWord_20240829180957.log,112,ChainlinkOracleProvider,11834,5519,17353,95.0,0.16955,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../access/Authorization.sol"";

import ""../../interfaces/oracles/IChainlinkOracleProvider.sol"";
import ""../../interfaces/vendor/ChainlinkAggregator.sol"";

import ""../../libraries/Errors.sol"";
import ""../../libraries/DecimalScale.sol"";

contract ChainlinkOracleProvider is IChainlinkOracleProvider, Authorization {
    using DecimalScale for uint256;

    uint256 public stalePriceDelay;

    mapping(address => address) public feeds;

    event FeedUpdated(address indexed asset, address indexed previousFeed, address indexed newFeed);

    constructor(IRoleManager roleManager, address ethFeed) Authorization(roleManager) {
        feeds[address(0)] = ethFeed;
        stalePriceDelay = 2 hours;
    }

    /// @notice Allows to set Chainlink feeds
    /// @dev All feeds should be set relative to USD.
    /// This can only be called by governance
    function setFeed(address asset, address feed) external override onlyGovernance {
        address previousFeed = feeds[asset];
        require(feed != previousFeed, Error.INVALID_ARGUMENT);
        feeds[asset] = feed;
        emit FeedUpdated(asset, previousFeed, feed);
    }

    /**
     * @notice Sets the stake price delay value.
     * @param stalePriceDelay_ The new stale price delay to set.
     */
    function setStalePriceDelay(uint256 stalePriceDelay_) external override onlyGovernance {
        require(stalePriceDelay_ >= 1 hours, Error.INVALID_ARGUMENT);
        stalePriceDelay = stalePriceDelay_;
    }

    /// @inheritdoc IOracleProvider
    function getPriceETH(address asset) external view override returns (uint256) {
        return (getPriceUSD(asset) * 1e18) / getPriceUSD(address(0));
    }

    /// @inheritdoc IOracleProvider
    function getPriceUSD(address asset) public view override returns (uint256) {
        address feed = feeds[asset];
        require(feed != address(0), Error.ASSET_NOT_SUPPORTED);

        (, int256 answer, , uint256 updatedAt, ) = AggregatorV2V3Interface(feed).latestRoundData();

        require(block.timestamp <= updatedAt + stalePriceDelay, Error.STALE_PRICE);
        require(answer >= 0, Error.NEGATIVE_PRICE);

        uint256 price = uint256(answer);
        uint8 decimals = AggregatorV2V3Interface(feed).decimals();
        return price.scaleFrom(decimals);
    }
}",519
RealWorld_BA_112_ITopUpAction_RealWord_20240829205033.log,112,ITopUpAction,14831,5997,20828,126.0,0.194095,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../IPreparable.sol"";
import ""../IAction.sol"";

interface ITopUpAction is IAction, IPreparable {
    struct RecordKey {
        address payer;
        bytes32 account;
        bytes32 protocol;
    }

    struct RecordMeta {
        bytes32 account;
        bytes32 protocol;
    }

    struct Record {
        uint64 threshold;
        uint64 priorityFee;
        uint64 maxFee;
        address actionToken;
        address depositToken;
        uint128 singleTopUpAmount; // denominated in action token
        uint128 totalTopUpAmount; // denominated in action token
        uint128 depositTokenBalance;
        bytes extra;
    }

    struct RecordWithMeta {
        bytes32 account;
        bytes32 protocol;
        Record record;
    }

    event Register(
        bytes32 indexed account,
        bytes32 indexed protocol,
        uint256 indexed threshold,
        address payer,
        address depositToken,
        uint256 depositAmount,
        address actionToken,
        uint256 singleTopUpAmount,
        uint256 totalTopUpAmount,
        uint256 maxGasPrice,
        bytes extra
    );

    event Deregister(address indexed payer, bytes32 indexed account, bytes32 indexed protocol);

    event TopUp(
        bytes32 indexed account,
        bytes32 indexed protocol,
        address indexed payer,
        address depositToken,
        uint256 consumedDepositAmount,
        address actionToken,
        uint256 topupAmount
    );

    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool);

    function execute(
        address payer,
        bytes32 account,
        address keeper,
        bytes32 protocol
    ) external returns (bool);

    function execute(
        address payer,
        bytes32 account,
        address keeper,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) external returns (bool);

    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external returns (bool);

    function getSupportedProtocols() external view returns (bytes32[] memory);

    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) external view returns (Record memory);

    function getUserPositions(address payer) external view returns (RecordMeta[] memory);

    function getHandler(bytes32 protocol) external view returns (address);

    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        returns (address[] memory users, uint256 nextCursor);

    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) external view returns (uint256);

    function getTopUpHandler(bytes32 protocol) external view returns (address);

    function prepareTopUpHandler(bytes32 protocol, address newHandler) external returns (bool);

    function executeTopUpHandler(bytes32 protocol) external returns (address);

    function resetTopUpHandler(bytes32 protocol) external returns (bool);

    function getSwapperSlippage() external view returns (uint256);
}",665
RealWorld_BA_112_Minter_RealWord_20240829193605.log,112,Minter,33563,5220,38783,82.0,0.272215,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

import ""../../interfaces/IController.sol"";
import ""../../interfaces/tokenomics/IBkdToken.sol"";

import ""../../libraries/Errors.sol"";
import ""../../libraries/ScaledMath.sol"";
import ""../../libraries/AddressProviderHelpers.sol"";

import ""./BkdToken.sol"";
import ""../access/Authorization.sol"";

contract Minter is Authorization, ReentrancyGuard {
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    uint256 private constant _INFLATION_DECAY_PERIOD = 365 days;

    // Lp Rates
    uint256 public immutable initialAnnualInflationRateLp;
    uint256 public immutable annualInflationDecayLp;
    uint256 public currentInflationAmountLp;

    // Keeper Rates
    uint256 public immutable initialPeriodKeeperInflation;
    uint256 public immutable initialAnnualInflationRateKeeper;
    uint256 public immutable annualInflationDecayKeeper;
    uint256 public currentInflationAmountKeeper;

    // AMM Rates
    uint256 public immutable initialPeriodAmmInflation;
    uint256 public immutable initialAnnualInflationRateAmm;
    uint256 public immutable annualInflationDecayAmm;
    uint256 public currentInflationAmountAmm;

    bool public initialPeriodEnded;

    // Non-inflation rates
    uint256 public immutable nonInflationDistribution;
    uint256 public issuedNonInflationSupply;

    uint256 public lastInflationDecay;
    uint256 public currentTotalInflation;

    // Used for final safety check to ensure inflation is not exceeded
    uint256 public totalAvailableToNow;
    uint256 public totalMintedToNow;
    uint256 public lastEvent;

    IController public immutable controller;
    BkdToken public token;

    event TokensMinted(address beneficiary, uint256 amount);

    constructor(
        uint256 _annualInflationRateLp,
        uint256 _annualInflationRateKeeper,
        uint256 _annualInflationRateAmm,
        uint256 _annualInflationDecayLp,
        uint256 _annualInflationDecayKeeper,
        uint256 _annualInflationDecayAmm,
        uint256 _initialPeriodKeeperInflation,
        uint256 _initialPeriodAmmInflation,
        uint256 _nonInflationDistribution,
        IController _controller
    ) Authorization(_controller.addressProvider().getRoleManager()) {
        require(_annualInflationDecayLp < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);
        require(_annualInflationDecayKeeper < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);
        require(_annualInflationDecayAmm < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);
        initialAnnualInflationRateLp = _annualInflationRateLp;
        initialAnnualInflationRateKeeper = _annualInflationRateKeeper;
        initialAnnualInflationRateAmm = _annualInflationRateAmm;

        annualInflationDecayLp = _annualInflationDecayLp;
        annualInflationDecayKeeper = _annualInflationDecayKeeper;
        annualInflationDecayAmm = _annualInflationDecayAmm;

        initialPeriodKeeperInflation = _initialPeriodKeeperInflation;
        initialPeriodAmmInflation = _initialPeriodAmmInflation;

        currentInflationAmountLp = _annualInflationRateLp / _INFLATION_DECAY_PERIOD;
        currentInflationAmountKeeper = _initialPeriodKeeperInflation / _INFLATION_DECAY_PERIOD;
        currentInflationAmountAmm = _initialPeriodAmmInflation / _INFLATION_DECAY_PERIOD;

        currentTotalInflation =
            currentInflationAmountLp +
            currentInflationAmountKeeper +
            currentInflationAmountAmm;

        nonInflationDistribution = _nonInflationDistribution;
        controller = _controller;
    }

    function setToken(address _token) external onlyGovernance {
        require(address(token) == address(0), ""Token already set!"");
        token = BkdToken(_token);
    }

    function startInflation() external onlyGovernance {
        require(lastEvent == 0, ""Inflation has already started."");
        lastEvent = block.timestamp;
        lastInflationDecay = block.timestamp;
    }

    /**
     * @notice Update the inflation rate according to the piecewise linear schedule.
     * @dev This updates the inflation rate to the next linear segment in the inflations schedule.
     * @return `true` if successful.
     */
    function executeInflationRateUpdate() external returns (bool) {
        return _executeInflationRateUpdate();
    }

    /**
     * @notice Mints BKD tokens to a specified address.
     * @dev Can only be called by the controller.
     * @param beneficiary Address to mint tokens for.
     * @param amount Amount of tokens to mint.
     * @return `true` if successful.
     */
    function mint(address beneficiary, uint256 amount) external nonReentrant returns (bool) {
        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);
        if (lastEvent == 0) return false;
        return _mint(beneficiary, amount);
    }

    /**
     * @notice Mint tokens that are not part of the inflation schedule.
     * @dev The amount of tokens that can be minted in total is subject to a pre-set upper limit.
     * @param beneficiary Address to mint tokens for.
     * @param amount Amount of tokens to mint.
     * @return `true` if successful.
     */
    function mintNonInflationTokens(address beneficiary, uint256 amount)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            issuedNonInflationSupply + amount <= nonInflationDistribution,
            ""Maximum non-inflation amount exceeded.""
        );
        issuedNonInflationSupply += amount;
        token.mint(beneficiary, amount);
        emit TokensMinted(beneficiary, amount);
        return true;
    }

    /**
     * @notice Supplies the inflation rate for LPs per unit of time (seconds).
     * @return LP inflation rate.
     */
    function getLpInflationRate() external view returns (uint256) {
        if (lastEvent == 0) return 0;
        return currentInflationAmountLp;
    }

    /**
     * @notice Supplies the inflation rate for keepers per unit of time (seconds).
     * @return keeper inflation rate.
     */
    function getKeeperInflationRate() external view returns (uint256) {
        if (lastEvent == 0) return 0;
        return currentInflationAmountKeeper;
    }

    /**
     * @notice Supplies the inflation rate for LPs on AMMs per unit of time (seconds).
     * @return AMM inflation rate.
     */
    function getAmmInflationRate() external view returns (uint256) {
        if (lastEvent == 0) return 0;
        return currentInflationAmountAmm;
    }

    function _executeInflationRateUpdate() internal returns (bool) {
        totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));
        lastEvent = block.timestamp;
        if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {
            currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);
            if (initialPeriodEnded) {
                currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(
                    annualInflationDecayKeeper
                );
                currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(
                    annualInflationDecayAmm
                );
            } else {
                currentInflationAmountKeeper =
                    initialAnnualInflationRateKeeper /
                    _INFLATION_DECAY_PERIOD;

                currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;
                initialPeriodEnded = true;
            }
            currentTotalInflation =
                currentInflationAmountLp +
                currentInflationAmountKeeper +
                currentInflationAmountAmm;
            controller.inflationManager().checkpointAllGauges();
            lastInflationDecay = block.timestamp;
        }
        return true;
    }

    function _mint(address beneficiary, uint256 amount) internal returns (bool) {
        totalAvailableToNow += ((block.timestamp - lastEvent) * currentTotalInflation);
        uint256 newTotalMintedToNow = totalMintedToNow + amount;
        require(newTotalMintedToNow <= totalAvailableToNow, ""Mintable amount exceeded"");
        totalMintedToNow = newTotalMintedToNow;
        lastEvent = block.timestamp;
        token.mint(beneficiary, amount);
        _executeInflationRateUpdate();
        emit TokensMinted(beneficiary, amount);
        return true;
    }
}",1932
RealWorld_BA_112_IOracleProvider_RealWord_20240829204317.log,112,IOracleProvider,5873,5162,11035,78.0,0.132605,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IOracleProvider {
    /// @notice Quotes the USD price of `baseAsset`
    /// @param baseAsset the asset of which the price is to be quoted
    /// @return the USD price of the asset
    function getPriceUSD(address baseAsset) external view returns (uint256);

    /// @notice Quotes the ETH price of `baseAsset`
    /// @param baseAsset the asset of which the price is to be quoted
    /// @return the ETH price of the asset
    function getPriceETH(address baseAsset) external view returns (uint256);
}",141
RealWorld_BA_112_RoleManager_RealWord_20240829181134.log,112,RoleManager,22625,5932,28557,100.0,0.231765,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../interfaces/IAddressProvider.sol"";
import ""../../interfaces/IRoleManager.sol"";

import ""../../libraries/Roles.sol"";
import ""../../libraries/Errors.sol"";
import ""../../libraries/AddressProviderKeys.sol"";

contract RoleManager is IRoleManager {
    using EnumerableSet for EnumerableSet.AddressSet;

    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }
    mapping(bytes32 => RoleData) private _roles;
    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;

    IAddressProvider public immutable addressProvider;

    modifier onlyGovernance() {
        require(hasRole(Roles.GOVERNANCE, msg.sender), Error.UNAUTHORIZED_ACCESS);
        _;
    }

    constructor(IAddressProvider _addressProvider) {
        addressProvider = _addressProvider;
        _grantRole(Roles.GOVERNANCE, msg.sender);
    }

    function grantRole(bytes32 role, address account) external onlyGovernance {
        _grantRole(role, account);
    }

    function addGovernor(address newGovernor) external onlyGovernance {
        _grantRole(Roles.GOVERNANCE, newGovernor);
    }

    function renounceGovernance() external onlyGovernance {
        require(getRoleMemberCount(Roles.GOVERNANCE) > 1, Error.CANNOT_REVOKE_ROLE);
        _revokeRole(Roles.GOVERNANCE, msg.sender);
    }

    function addGaugeZap(address zap) external onlyGovernance {
        _grantRole(Roles.GAUGE_ZAP, zap);
    }

    function removeGaugeZap(address zap) external {
        revokeRole(Roles.GAUGE_ZAP, zap);
    }

    function hasAnyRole(
        bytes32 role1,
        bytes32 role2,
        address account
    ) external view returns (bool) {
        return hasRole(role1, account) || hasRole(role2, account);
    }

    function hasAnyRole(
        bytes32 role1,
        bytes32 role2,
        bytes32 role3,
        address account
    ) external view returns (bool) {
        return hasRole(role1, account) || hasRole(role2, account) || hasRole(role3, account);
    }

    function hasAnyRole(bytes32[] memory roles, address account)
        external
        view
        virtual
        override
        returns (bool)
    {
        for (uint256 i = 0; i < roles.length; i++) {
            if (hasRole(roles[i], account)) {
                return true;
            }
        }
        return false;
    }

    function getRoleMember(bytes32 role, uint256 index)
        external
        view
        virtual
        override
        returns (address)
    {
        if (role == Roles.ADDRESS_PROVIDER && index == 0) {
            return address(addressProvider);
        } else if (role == Roles.POOL_FACTORY && index == 0) {
            return addressProvider.getAddress(AddressProviderKeys._POOL_FACTORY_KEY);
        } else if (role == Roles.CONTROLLER && index == 0) {
            return addressProvider.getAddress(AddressProviderKeys._CONTROLLER_KEY);
        } else if (role == Roles.POOL) {
            return addressProvider.getPoolAtIndex(index);
        } else if (role == Roles.VAULT) {
            return addressProvider.getVaultAtIndex(index);
        }
        return _roleMembers[role].at(index);
    }

    function revokeRole(bytes32 role, address account) public onlyGovernance {
        require(role != Roles.GOVERNANCE, Error.CANNOT_REVOKE_ROLE);
        require(hasRole(role, account), Error.INVALID_ARGUMENT);
        _revokeRole(role, account);
    }

    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {
        if (
            role == Roles.ADDRESS_PROVIDER || role == Roles.POOL_FACTORY || role == Roles.CONTROLLER
        ) {
            return 1;
        }
        if (role == Roles.POOL) {
            return addressProvider.poolsCount();
        }
        if (role == Roles.VAULT) {
            return addressProvider.vaultsCount();
        }
        return _roleMembers[role].length();
    }

    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {
        if (role == Roles.ADDRESS_PROVIDER) {
            return account == address(addressProvider);
        } else if (role == Roles.POOL_FACTORY) {
            return
                account == addressProvider.getAddress(AddressProviderKeys._POOL_FACTORY_KEY, false);
        } else if (role == Roles.CONTROLLER) {
            return
                account == addressProvider.getAddress(AddressProviderKeys._CONTROLLER_KEY, false);
        } else if (role == Roles.MAINTENANCE) {
            return _roles[role].members[account] || _roles[Roles.GOVERNANCE].members[account];
        } else if (role == Roles.POOL) {
            return addressProvider.isPool(account);
        } else if (role == Roles.VAULT) {
            return addressProvider.isVault(account);
        }
        return _roles[role].members[account];
    }

    function _grantRole(bytes32 role, address account) internal {
        _roles[role].members[account] = true;
        _roleMembers[role].add(account);
        emit RoleGranted(role, account, msg.sender);
    }

    function _revokeRole(bytes32 role, address account) internal {
        _roles[role].members[account] = false;
        emit RoleRevoked(role, account, msg.sender);
    }
}",1200
RealWorld_BA_112_ControllerProfiler_RealWord_20240829191246.log,112,ControllerProfiler,6211,5123,11334,97.0,0.133515,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../Controller.sol"";

contract ControllerProfiler {
    Controller public immutable controller;

    constructor(address _controller) {
        controller = Controller(_controller);
    }

    function profileIsAction() external {
        IAddressProvider addressProvider = controller.addressProvider();
        addressProvider.isAction(address(this));
        addressProvider.addAction(address(this));
        addressProvider.isAction(address(this));
        addressProvider.isAction(address(controller));
        addressProvider.addAction(address(this));
        addressProvider.isAction(address(this));
        addressProvider.isAction(address(controller));
    }

    function profilePoolAddingAndLpTokenGet(address pool, address token) external {
        IAddressProvider addressProvider = controller.addressProvider();
        addressProvider.addPool(pool);
        addressProvider.getPoolForToken(token);
        controller.removePool(pool);
    }
}",183
RealWorld_BA_112_IUniswapV2Pair_RealWord_20240829214920.log,112,IUniswapV2Pair,13156,5597,18753,96.0,0.17772,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function name() external pure returns (string memory);

    function symbol() external pure returns (string memory);

    function decimals() external pure returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address owner) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function transfer(address to, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PERMIT_TYPEHASH() external pure returns (bytes32);

    function nonces(address owner) external view returns (uint256);

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    event Mint(address indexed sender, uint256 amount0, uint256 amount1);
    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint256 amount0In,
        uint256 amount1In,
        uint256 amount0Out,
        uint256 amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint256);

    function factory() external view returns (address);

    function token0() external view returns (address);

    function token1() external view returns (address);

    function getReserves()
        external
        view
        returns (
            uint112 reserve0,
            uint112 reserve1,
            uint32 blockTimestampLast
        );

    function price0CumulativeLast() external view returns (uint256);

    function price1CumulativeLast() external view returns (uint256);

    function kLast() external view returns (uint256);

    function mint(address to) external returns (uint256 liquidity);

    function burn(address to) external returns (uint256 amount0, uint256 amount1);

    function swap(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        bytes calldata data
    ) external;

    function skim(address to) external;

    function sync() external;

    function initialize(address, address) external;
}",578
RealWorld_BA_112_OracleProviderExtensions_RealWord_20240829180834.log,112,OracleProviderExtensions,5029,4711,9740,81.0,0.119365,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../libraries/ScaledMath.sol"";
import ""../../interfaces/oracles/IOracleProvider.sol"";

library OracleProviderExtensions {
    using ScaledMath for uint256;

    function getRelativePrice(
        IOracleProvider priceOracle,
        address fromToken,
        address toToken
    ) internal view returns (uint256) {
        return priceOracle.getPriceUSD(fromToken).scaledDiv(priceOracle.getPriceUSD(toToken));
    }
}",109
RealWorld_BA_112_GasBank_RealWord_20240829180408.log,112,GasBank,13133,5429,18562,92.0,0.174245,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../libraries/Errors.sol"";
import ""../interfaces/IController.sol"";
import ""../interfaces/IGasBank.sol"";

contract GasBank is IGasBank {
    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    /**
     * @notice Keeps track of the user balances
     */
    mapping(address => uint256) internal _balances;

    constructor(IController _controller) {
        addressProvider = _controller.addressProvider();
        controller = _controller;
    }

    /**
     * @notice Deposit `msg.value` on behalf of `account`
     */
    function depositFor(address account) external payable override {
        _balances[account] += msg.value;
        emit Deposit(account, msg.value);
    }

    /**
     * @notice Withdraws `amount` from `account`
     */
    function withdrawFrom(address account, uint256 amount) external override {
        withdrawFrom(account, payable(account), amount);
    }

    /**
     * @notice Withdraws amount not required by any action
     */
    function withdrawUnused(address account) external {
        uint256 currentBalance = _balances[account];
        require(
            msg.sender == account || addressProvider.isAction(msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );
        uint256 ethRequired = controller.getTotalEthRequiredForGas(account);
        if (currentBalance > ethRequired) {
            _withdrawFrom(account, payable(account), currentBalance - ethRequired, currentBalance);
        }
    }

    /**
     * @return the balance of `account`
     */
    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }

    /**
     * @notice Withdraws `amount` on behalf of `account` and send to `to`
     */
    function withdrawFrom(
        address account,
        address payable to,
        uint256 amount
    ) public override {
        uint256 currentBalance = _balances[account];
        require(currentBalance >= amount, Error.NOT_ENOUGH_FUNDS);
        require(
            msg.sender == account || addressProvider.isAction(msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );

        if (msg.sender == account) {
            uint256 ethRequired = controller.getTotalEthRequiredForGas(account);
            require(currentBalance - amount >= ethRequired, Error.NOT_ENOUGH_FUNDS);
        }
        _withdrawFrom(account, to, amount, currentBalance);
    }

    function _withdrawFrom(
        address account,
        address payable to,
        uint256 amount,
        uint256 currentBalance
    ) internal {
        _balances[account] = currentBalance - amount;

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, ) = to.call{value: amount}("""");
        require(success, Error.FAILED_TRANSFER);

        emit Withdraw(account, to, amount);
    }
}",607
RealWorld_BA_112_ILiquidityPool_RealWord_20240829210558.log,112,ILiquidityPool,13117,5674,18791,90.0,0.179065,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../IPreparable.sol"";
import ""../../interfaces/IVault.sol"";

interface ILiquidityPool is IPreparable {
    event Deposit(address indexed minter, uint256 depositAmount, uint256 mintedLpTokens);

    event DepositFor(
        address indexed minter,
        address indexed mintee,
        uint256 depositAmount,
        uint256 mintedLpTokens
    );

    event Redeem(address indexed redeemer, uint256 redeemAmount, uint256 redeemTokens);

    event LpTokenSet(address indexed lpToken);

    event StakerVaultSet(address indexed stakerVault);

    function redeem(uint256 redeemTokens) external returns (uint256);

    function redeem(uint256 redeemTokens, uint256 minRedeemAmount) external returns (uint256);

    function calcRedeem(address account, uint256 underlyingAmount) external returns (uint256);

    function deposit(uint256 mintAmount) external payable returns (uint256);

    function deposit(uint256 mintAmount, uint256 minTokenAmount) external payable returns (uint256);

    function depositAndStake(uint256 depositAmount, uint256 minTokenAmount)
        external
        payable
        returns (uint256);

    function depositFor(address account, uint256 depositAmount) external payable returns (uint256);

    function depositFor(
        address account,
        uint256 depositAmount,
        uint256 minTokenAmount
    ) external payable returns (uint256);

    function unstakeAndRedeem(uint256 redeemLpTokens, uint256 minRedeemAmount)
        external
        returns (uint256);

    function handleLpTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) external;

    function prepareNewVault(address _vault) external returns (bool);

    function executeNewVault() external returns (address);

    function executeNewMaxWithdrawalFee() external returns (uint256);

    function executeNewRequiredReserves() external returns (uint256);

    function executeNewReserveDeviation() external returns (uint256);

    function setLpToken(address _lpToken) external returns (bool);

    function setStaker() external returns (bool);

    function isCapped() external returns (bool);

    function uncap() external returns (bool);

    function updateDepositCap(uint256 _depositCap) external returns (bool);

    function withdrawAll() external;

    function getUnderlying() external view returns (address);

    function getLpToken() external view returns (address);

    function getWithdrawalFee(address account, uint256 amount) external view returns (uint256);

    function getVault() external view returns (IVault);

    function exchangeRate() external view returns (uint256);

    function totalUnderlying() external view returns (uint256);
}",613
RealWorld_BA_112_IAdmin_RealWord_20240829203422.log,112,IAdmin,4796,4745,9541,85.0,0.11888,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IAdmin {
    event NewAdminAdded(address newAdmin);
    event AdminRenounced(address oldAdmin);

    function admins() external view returns (address[] memory);

    function addAdmin(address newAdmin) external returns (bool);

    function renounceAdmin() external returns (bool);

    function isAdmin(address account) external view returns (bool);
}",94
RealWorld_BA_112_ExponentialNoError_RealWord_20240829212520.log,112,ExponentialNoError,25510,5952,31462,114.0,0.24659,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

/**
 * @title Exponential module for storing fixed-precision decimals
 * @author Compound
 * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.
 *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:
 *         `Exp({mantissa: 5100000000000000000})`.
 */
contract ExponentialNoError {
    uint256 constant expScale = 1e18;
    uint256 constant doubleScale = 1e36;
    uint256 constant halfExpScale = expScale / 2;
    uint256 constant mantissaOne = expScale;

    struct Exp {
        uint256 mantissa;
    }

    struct Double {
        uint256 mantissa;
    }

    /**
     * @dev Truncates the given exp to a whole number value.
     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15
     */
    function truncate(Exp memory exp) internal pure returns (uint256) {
        // Note: We are not using careful math here as we're performing a division that cannot fail
        return exp.mantissa / expScale;
    }

    /**
     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.
     */
    function mul_ScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (uint256) {
        Exp memory product = mul_(a, scalar);
        return truncate(product);
    }

    /**
     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.
     */
    function mul_ScalarTruncateAddUInt(
        Exp memory a,
        uint256 scalar,
        uint256 addend
    ) internal pure returns (uint256) {
        Exp memory product = mul_(a, scalar);
        return truncate(product) + addend;
    }

    /**
     * @dev Checks if first Exp is less than second Exp.
     */
    function lessThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {
        return left.mantissa < right.mantissa;
    }

    /**
     * @dev Checks if left Exp <= right Exp.
     */
    function lessThanOrEqualExp(Exp memory left, Exp memory right) internal pure returns (bool) {
        return left.mantissa <= right.mantissa;
    }

    /**
     * @dev Checks if left Exp > right Exp.
     */
    function greaterThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {
        return left.mantissa > right.mantissa;
    }

    /**
     * @dev returns true if Exp is exactly zero
     */
    function isZeroExp(Exp memory value) internal pure returns (bool) {
        return value.mantissa == 0;
    }

    function safe224(uint256 n, string memory errorMessage) internal pure returns (uint224) {
        require(n < 2**224, errorMessage);
        return uint224(n);
    }

    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {
        require(n < 2**32, errorMessage);
        return uint32(n);
    }

    function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {
        return Exp({mantissa: a.mantissa + b.mantissa});
    }

    function add_(Double memory a, Double memory b) internal pure returns (Double memory) {
        return Double({mantissa: a.mantissa + b.mantissa});
    }

    function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {
        return Exp({mantissa: a.mantissa - b.mantissa});
    }

    function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {
        return Double({mantissa: a.mantissa - b.mantissa});
    }

    function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {
        return Exp({mantissa: (a.mantissa * b.mantissa) / expScale});
    }

    function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {
        return Exp({mantissa: (a.mantissa * b)});
    }

    function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {
        return (a * b.mantissa) / expScale;
    }

    function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {
        return Double({mantissa: (a.mantissa * b.mantissa) / doubleScale});
    }

    function mul_(Double memory a, uint256 b) internal pure returns (Double memory) {
        return Double({mantissa: a.mantissa * b});
    }

    function mul_(uint256 a, Double memory b) internal pure returns (uint256) {
        return (a * b.mantissa) / doubleScale;
    }

    function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {
        return Exp({mantissa: (a.mantissa * expScale) / b.mantissa});
    }

    function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {
        return Exp({mantissa: a.mantissa / b});
    }

    function div_(uint256 a, Exp memory b) internal pure returns (uint256) {
        return (a * expScale) / b.mantissa;
    }

    function div_(Double memory a, Double memory b) internal pure returns (Double memory) {
        return Double({mantissa: (a.mantissa * doubleScale) / b.mantissa});
    }

    function div_(Double memory a, uint256 b) internal pure returns (Double memory) {
        return Double({mantissa: a.mantissa / b});
    }

    function div_(uint256 a, Double memory b) internal pure returns (uint256) {
        return (a * doubleScale) / b.mantissa;
    }

    function fraction(uint256 a, uint256 b) internal pure returns (Double memory) {
        return Double({mantissa: (a * doubleScale) / b});
    }
}",1367
RealWorld_BA_112_MockEthStrategy_RealWord_20240829190654.log,112,MockEthStrategy,16069,5521,21590,91.0,0.190765,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../access/Authorization.sol"";
import ""../../interfaces/IStrategy.sol"";
import ""../../interfaces/IStakerVault.sol"";

/**
 * MockStrategy for testing.
 * This strategy does not do anything with funds it receives.
 */
contract MockEthStrategy is IStrategy, Authorization {
    using SafeERC20 for IERC20;

    address internal _underlying = address(0);

    address payable internal _vault;

    address public override strategist;

    modifier onlyVault() {
        require(msg.sender == _vault, Error.UNAUTHORIZED_ACCESS);
        _;
    }

    constructor(IRoleManager roleManager) Authorization(roleManager) {
        strategist = address(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);
    }

    receive() external payable {}

    function setVault(address payable newVault) external onlyGovernance returns (bool) {
        require(_vault == address(0), ""Vault can only be set once"");
        require(newVault != address(0), ""Vault cannot be zero address"");
        _vault = newVault;
        return true;
    }

    // Deposits token (same as want() returns) into a smart contact specified by the Strategy.
    function deposit() external payable override onlyVault returns (bool) {
        // Does nothing in mock
        return true;
    }

    // Controller | Vault role - withdraw should always return to Vault
    function withdraw(uint256 amount) external override onlyVault returns (bool) {
        uint256 currentBalance = address(this).balance;
        if (amount <= currentBalance) payable(address(_vault)).transfer(amount);
        else payable(address(_vault)).transfer(currentBalance);
        return true;
    }

    // Controller | Vault role - withdraw should always return to Vault
    function withdrawAll() external virtual override onlyVault returns (uint256) {
        uint256 currentBalance = address(this).balance;
        payable(address(_vault)).transfer(currentBalance);
        return currentBalance;
    }

    function withdrawDust(address coin) external returns (bool) {
        require(coin != address(_underlying), ""Unauthorized withdrawal"");
        uint256 currentBalance = address(this).balance;
        require(currentBalance > 0, ""Invalid amount to withdraw"");
        payable(address(_vault)).transfer(currentBalance);
        return true;
    }

    // For testing
    function burnETH(uint256 amount) external {
        uint256 currentBalance = address(this).balance;
        require(currentBalance >= amount, Error.INSUFFICIENT_BALANCE);
        payable(address(0)).transfer(amount);
    }

    function stakeInVault(address lpToken, address stakerVault) external {
        IERC20(lpToken).approve(stakerVault, 4e18);
        IStakerVault(stakerVault).stake(4e18);
    }

    function name() external view override returns (string memory) {
        return ""MockStrategy"";
    }

    function want() external view returns (address) {
        return _underlying;
    }

    function balance() external view override returns (uint256) {
        return address(this).balance;
    }

    function shutdown() external pure override returns (bool) {
        return true;
    }

    function hasPendingFunds() external pure override returns (bool) {
        return false;
    }

    function harvestable() external pure override returns (uint256) {
        return 0;
    }

    function harvest() external pure override returns (uint256) {
        return 0;
    }
}",786
RealWorld_BA_112_MockGauge_RealWord_20240829190828.log,112,MockGauge,9120,5218,14338,86.0,0.14996,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../interfaces/vendor/IGauge.sol"";
import ""./MockErc20.sol"";

contract MockGauge is IGauge {
    address private _lpToken;

    mapping(address => uint256) private _balances;

    // mock claimable CRV rewards
    uint256 private _claimableTokens = 0;

    constructor(address lpToken_) {
        _lpToken = lpToken_;
    }

    function deposit(uint256 amount) external override {
        require(
            MockErc20(_lpToken).balanceOf(msg.sender) >= amount,
            ""insufficient user gauge balance""
        );
        MockErc20(_lpToken).transferFrom(msg.sender, address(this), amount);
        _balances[msg.sender] += amount;
    }

    function withdraw(uint256 amount) external override {
        require(_balances[msg.sender] >= amount, ""insufficient user gauge balance"");
        _balances[msg.sender] -= amount;
        MockErc20(_lpToken).transfer(msg.sender, amount);
    }

    // for mocking CRV rewards
    function setClaimableTokens(uint256 amount) external {
        _claimableTokens = amount;
    }

    // solhint-disable-next-line func-name-mixedcase
    function user_checkpoint(address account) external override {}

    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }

    // solhint-disable-next-line func-name-mixedcase
    function claimable_tokens(address) external view override returns (uint256) {
        return _claimableTokens;
    }
}",344
RealWorld_BA_112_DummyErc20_RealWord_20240829183110.log,112,DummyErc20,4650,4316,8966,72.0,0.10957,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract DummyERC20 is ERC20, Ownable {
    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}

    function mintAsOwner(uint256 amount) external onlyOwner {
        _mint(msg.sender, amount);
    }
}",108
RealWorld_BA_112_IStakerVault_RealWord_20240829201802.log,112,IStakerVault,10774,5986,16760,115.0,0.17359,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IStakerVault {
    event Staked(address indexed account, uint256 amount);
    event Unstaked(address indexed account, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function initialize(address _token) external;

    function initializeLpGauge(address _lpGauge) external returns (bool);

    function stake(uint256 amount) external returns (bool);

    function stakeFor(address account, uint256 amount) external returns (bool);

    function unstake(uint256 amount) external returns (bool);

    function unstakeFor(
        address src,
        address dst,
        uint256 amount
    ) external returns (bool);

    function approve(address spender, uint256 amount) external returns (bool);

    function transfer(address account, uint256 amount) external returns (bool);

    function transferFrom(
        address src,
        address dst,
        uint256 amount
    ) external returns (bool);

    function allowance(address owner, address spender) external view returns (uint256);

    function getToken() external view returns (address);

    function balanceOf(address account) external view returns (uint256);

    function stakedAndActionLockedBalanceOf(address account) external view returns (uint256);

    function actionLockedBalanceOf(address account) external view returns (uint256);

    function increaseActionLockedBalance(address account, uint256 amount) external returns (bool);

    function decreaseActionLockedBalance(address account, uint256 amount) external returns (bool);

    function getStakedByActions() external view returns (uint256);

    function addStrategy(address strategy) external returns (bool);

    function getPoolTotalStaked() external view returns (uint256);

    function prepareLpGauge(address _lpGauge) external returns (bool);

    function executeLpGauge() external returns (bool);

    function getLpGauge() external view returns (address);

    function poolCheckpoint() external returns (bool);

    function isStrategy(address user) external view returns (bool);
}",455
RealWorld_BA_112_MockErc20Strategy_RealWord_20240829184452.log,112,MockErc20Strategy,17284,5490,22774,87.0,0.19622,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../access/Authorization.sol"";
import ""../../interfaces/IStrategy.sol"";
import ""../../interfaces/IStakerVault.sol"";

/**
 * MockStrategy for testing.
 * This strategy does not do anything with funds it receives.
 */
contract MockErc20Strategy is IStrategy, Authorization {
    using SafeERC20 for IERC20;

    address internal _underlying;

    address internal _vault;

    address public override strategist;

    modifier onlyVault() {
        require(msg.sender == _vault, Error.UNAUTHORIZED_ACCESS);
        _;
    }

    constructor(IRoleManager roleManager, address underlying) Authorization(roleManager) {
        _underlying = underlying;
        strategist = address(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);
    }

    function setVault(address newVault) external onlyGovernance returns (bool) {
        require(_vault == address(0), ""Vault can only be set once"");
        require(newVault != address(0), ""Vault cannot be zero address"");
        _vault = newVault;
        return true;
    }

    // Deposits token (same as want() returns) into a smart contact specified by the Strategy.
    function deposit() external payable override onlyVault returns (bool) {
        // Does nothing in mock
        return true;
    }

    // Controller | Vault role - withdraw should always return to Vault
    function withdraw(uint256 amount) external override onlyVault returns (bool) {
        uint256 currentBalance = IERC20(_underlying).balanceOf(address(this));
        if (amount <= currentBalance) IERC20(_underlying).safeTransfer(_vault, amount);
        else IERC20(_underlying).safeTransfer(_vault, currentBalance);
        return true;
    }

    // Controller | Vault role - withdraw should always return to Vault
    function withdrawAll() external virtual override onlyVault returns (uint256) {
        uint256 currentBalance = IERC20(_underlying).balanceOf(address(this));
        IERC20(_underlying).safeTransfer(_vault, currentBalance);
        return currentBalance;
    }

    function withdrawDust(address coin) external returns (bool) {
        require(coin != address(_underlying), ""Unauthorized withdrawal"");
        uint256 currentBalance = IERC20(coin).balanceOf(address(this));
        require(currentBalance > 0, ""Invalid amount to withdraw"");
        IERC20(coin).transfer(_vault, currentBalance);
        return true;
    }

    function transfer(
        address coin,
        address to,
        uint256 amount
    ) external returns (bool) {
        require(amount > 0, ""Invalid amount to transfer"");
        IERC20(coin).transfer(to, amount);
        return true;
    }

    function drainFunds(address account) external {
        uint256 _balance = IERC20(_underlying).balanceOf(address(this));
        IERC20(_underlying).transfer(account, _balance);
    }

    function stakeInVault(address lpToken, address stakerVault) external {
        IERC20(lpToken).approve(stakerVault, 4e18);
        IStakerVault(stakerVault).stake(4e18);
    }

    function want() external view returns (address) {
        return _underlying;
    }

    function balance() external view override returns (uint256) {
        return IERC20(_underlying).balanceOf(address(this));
    }

    function name() external pure override returns (string memory) {
        return ""MockStrategy"";
    }

    function shutdown() external pure override returns (bool) {
        return true;
    }

    function harvestable() external pure override returns (uint256) {
        return 0;
    }

    function harvest() external pure override returns (uint256) {
        return 0;
    }

    function hasPendingFunds() external pure override returns (bool) {
        return false;
    }
}",883
RealWorld_BA_112_BkdEthCvx_RealWord_20240829181744.log,112,BkdEthCvx,27421,5754,33175,88.0,0.252185,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./ConvexStrategyBase.sol"";

/**
 * This is the BkdEthCvx strategy, which is designed to be used by a Backd ETH Vault.
 * The strategy holds ETH as it's underlying and allocates liquidity to Convex via given Curve Pool with 2 underlying tokens.
 * Rewards received on Convex (CVX, CRV), are sold in part for the underlying.
 * A share of earned CVX & CRV are retained on behalf of the Backd community to participate in governance.
 */
contract BkdEthCvx is ConvexStrategyBase {
    using ScaledMath for uint256;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    constructor(
        address vault_,
        address strategist_,
        uint256 convexPid_,
        address curvePool_,
        uint256 curveIndex_,
        IAddressProvider addressProvider_,
        address strategySwapper_
    )
        ConvexStrategyBase(
            vault_,
            strategist_,
            convexPid_,
            curvePool_,
            curveIndex_,
            addressProvider_,
            strategySwapper_
        )
    {
        // Setting default values
        imbalanceToleranceIn = 0.0007e18;
        imbalanceToleranceOut = 0.0104e18;

        // Approvals
        (address lp_, , , , , ) = _BOOSTER.poolInfo(convexPid_);
        IERC20(lp_).safeApprove(address(_BOOSTER), type(uint256).max);
    }

    receive() external payable {}

    function name() external pure override returns (string memory) {
        return ""BkdEthCvx"";
    }

    function balance() public view override returns (uint256) {
        return _underlyingBalance() + _lpToUnderlying(_stakedBalance() + _lpBalance());
    }

    function _deposit() internal override returns (bool) {
        // Depositing into Curve Pool
        uint256 underlyingBalance = _underlyingBalance();
        if (underlyingBalance == 0) return false;
        uint256[2] memory amounts;
        amounts[curveIndex] = underlyingBalance;
        curvePool.add_liquidity{value: underlyingBalance}(
            amounts,
            _minLpAccepted(underlyingBalance)
        );

        // Depositing into Convex and Staking
        if (!_BOOSTER.depositAll(convexPid, true)) return false;
        return true;
    }

    function _withdraw(uint256 amount) internal override returns (bool) {
        uint256 underlyingBalance = _underlyingBalance();

        // Transferring from idle balance if enough
        if (underlyingBalance >= amount) {
            payable(vault).transfer(amount);
            emit Withdraw(amount);
            return true;
        }

        // Unstaking needed LP Tokens from Convex
        uint256 requiredUnderlyingAmount = amount - underlyingBalance;
        uint256 maxLpBurned = _maxLpBurned(requiredUnderlyingAmount);
        uint256 requiredLpAmount = maxLpBurned - _lpBalance();
        if (!rewards.withdrawAndUnwrap(requiredLpAmount, false)) return false;

        // Removing needed liquidity from Curve
        uint256[2] memory amounts;
        // solhint-disable-next-line reentrancy
        amounts[curveIndex] = requiredUnderlyingAmount;
        curvePool.remove_liquidity_imbalance(amounts, maxLpBurned);
        payable(vault).transfer(amount);
        return true;
    }

    function _withdrawAll() internal override returns (uint256) {
        // Unstaking and withdrawing from Convex pool
        uint256 stakedBalance = _stakedBalance();
        if (stakedBalance > 0) {
            if (!rewards.withdrawAndUnwrap(stakedBalance, false)) return 0;
        }

        // Removing liquidity from Curve
        uint256 lpBalance = _lpBalance();
        if (lpBalance > 0) {
            curvePool.remove_liquidity_one_coin(
                lpBalance,
                int128(uint128(curveIndex)),
                _minUnderlyingAccepted(lpBalance)
            );
        }

        // Transferring underlying to vault
        uint256 underlyingBalance = _underlyingBalance();
        if (underlyingBalance == 0) return 0;
        payable(vault).transfer(underlyingBalance);
        return underlyingBalance;
    }

    function _underlyingBalance() internal view override returns (uint256) {
        return address(this).balance;
    }

    /**
     * @notice Calculates the minimum LP to accept when depositing underlying into Curve Pool.
     * @param _underlyingAmount Amount of underlying that is being deposited into Curve Pool.
     * @return The minimum LP balance to accept.
     */
    function _minLpAccepted(uint256 _underlyingAmount) internal view returns (uint256) {
        return _underlyingToLp(_underlyingAmount).scaledMul(ScaledMath.ONE - imbalanceToleranceIn);
    }

    /**
     * @notice Calculates the maximum LP to accept burning when withdrawing amount from Curve Pool.
     * @param _underlyingAmount Amount of underlying that is being widthdrawn from Curve Pool.
     * @return The maximum LP balance to accept burning.
     */
    function _maxLpBurned(uint256 _underlyingAmount) internal view returns (uint256) {
        return _underlyingToLp(_underlyingAmount).scaledMul(ScaledMath.ONE + imbalanceToleranceOut);
    }

    /**
     * @notice Calculates the minimum underlying to accept when burning LP tokens to withdraw from Curve Pool.
     * @param _lpAmount Amount of LP tokens being burned to withdraw from Curve Pool.
     * @return The minimum underlying balance to accept.
     */
    function _minUnderlyingAccepted(uint256 _lpAmount) internal view returns (uint256) {
        return _lpToUnderlying(_lpAmount).scaledMul(ScaledMath.ONE - imbalanceToleranceOut);
    }

    /**
     * @notice Converts an amount of underlying into their estimated LP value.
     * @dev Uses get_virtual_price which is less suceptible to manipulation.
     *  But is also less accurate to how much could be withdrawn.
     * @param _underlyingAmount Amount of underlying to convert.
     * @return The estimated value in the LP.
     */
    function _underlyingToLp(uint256 _underlyingAmount) internal view returns (uint256) {
        return _underlyingAmount.scaledDiv(curvePool.get_virtual_price());
    }

    /**
     * @notice Converts an amount of LP into their estimated underlying value.
     * @dev Uses get_virtual_price which is less suceptible to manipulation.
     *  But is also less accurate to how much could be withdrawn.
     * @param _lpAmount Amount of LP to convert.
     * @return The estimated value in the underlying.
     */
    function _lpToUnderlying(uint256 _lpAmount) internal view returns (uint256) {
        return _lpAmount.scaledMul(curvePool.get_virtual_price());
    }
}",1503
RealWorld_BA_112_StakerVault_RealWord_20240829175421.log,112,StakerVault,53787,5603,59390,104.0,0.380995,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

import ""../libraries/ScaledMath.sol"";
import ""../libraries/Errors.sol"";
import ""../libraries/Errors.sol"";
import ""../libraries/AddressProviderHelpers.sol"";

import ""../interfaces/IStakerVault.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/IVault.sol"";
import ""../interfaces/IController.sol"";
import ""../interfaces/tokenomics/IRewardsGauge.sol"";
import ""../interfaces/IController.sol"";
import ""../interfaces/pool/ILiquidityPool.sol"";
import ""../interfaces/tokenomics/ILpGauge.sol"";
import ""../interfaces/IERC20Full.sol"";

import ""./utils/Preparable.sol"";
import ""./Controller.sol"";
import ""./pool/LiquidityPool.sol"";
import ""./access/Authorization.sol"";
import ""./utils/Pausable.sol"";

/**
 * @notice This contract handles staked tokens from Backd pools
 * However, not that this is NOT an ERC-20 compliant contract and these
 * tokens should never be integrated with any protocol assuming ERC-20 compliant
 * tokens
 * @dev When paused, allows only withdraw/unstake
 */
contract StakerVault is IStakerVault, Authorization, Pausable, Initializable, Preparable {
    using AddressProviderHelpers for IAddressProvider;
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;

    bytes32 internal constant _LP_GAUGE = ""lpGauge"";

    IController public immutable controller;

    address public token;

    mapping(address => uint256) public balances;
    mapping(address => uint256) public actionLockedBalances;

    mapping(address => mapping(address => uint256)) internal _allowances;

    // All the data fields required for the staking tracking
    uint256 private _poolTotalStaked;

    mapping(address => bool) public strategies;
    uint256 public strategiesTotalStaked;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        require(address(_controller) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        controller = _controller;
    }

    function initialize(address _token) external override initializer {
        token = _token;
    }

    function initializeLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {
        require(currentAddresses[_LP_GAUGE] == address(0), Error.ROLE_EXISTS);
        _setConfig(_LP_GAUGE, _lpGauge);
        controller.inflationManager().addGaugeForVault(token);
        return true;
    }

    function prepareLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {
        _prepare(_LP_GAUGE, _lpGauge);
        return true;
    }

    function executeLpGauge() external override onlyGovernance returns (bool) {
        _executeAddress(_LP_GAUGE);
        controller.inflationManager().addGaugeForVault(token);
        return true;
    }

    /**
     * @notice Registers an address as a strategy to be excluded from token accumulation.
     * @dev This should be used is a strategy deposits into a stakerVault and should not get gov. tokens.
     * @return `true` if success.
     */
    function addStrategy(address strategy) external override returns (bool) {
        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);
        strategies[strategy] = true;
        return true;
    }

    /**
     * @notice Transfer staked tokens to an account.
     * @dev This is not an ERC20 transfer, as tokens are still owned by this contract, but fees get updated in the LP pool.
     * @param account Address to transfer to.
     * @param amount Amount to transfer.
     * @return `true` if success.
     */
    function transfer(address account, uint256 amount) external override notPaused returns (bool) {
        require(msg.sender != account, Error.SELF_TRANSFER_NOT_ALLOWED);
        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);

        ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);
        pool.handleLpTokenTransfer(msg.sender, account, amount);

        balances[msg.sender] -= amount;
        balances[account] += amount;

        address lpGauge = currentAddresses[_LP_GAUGE];
        if (lpGauge != address(0)) {
            ILpGauge(lpGauge).userCheckpoint(msg.sender);
            ILpGauge(lpGauge).userCheckpoint(account);
        }

        emit Transfer(msg.sender, account, amount);
        return true;
    }

    /**
     * @notice Transfer staked tokens from src to dst.
     * @dev This is not an ERC20 transfer, as tokens are still owned by this contract, but fees get updated in the LP pool.
     * @param src Address to transfer from.
     * @param dst Address to transfer to.
     * @param amount Amount to transfer.
     * @return `true` if success.
     */
    function transferFrom(
        address src,
        address dst,
        uint256 amount
    ) external override notPaused returns (bool) {
        /* Do not allow self transfers */
        require(src != dst, Error.SAME_ADDRESS_NOT_ALLOWED);

        address spender = msg.sender;

        /* Get the allowance, infinite for the account owner */
        uint256 startingAllowance = 0;
        if (spender == src) {
            startingAllowance = type(uint256).max;
        } else {
            startingAllowance = _allowances[src][spender];
        }
        require(startingAllowance >= amount, Error.INSUFFICIENT_BALANCE);

        uint256 srcTokens = balances[src];
        require(srcTokens >= amount, Error.INSUFFICIENT_BALANCE);

        address lpGauge = currentAddresses[_LP_GAUGE];
        if (lpGauge != address(0)) {
            ILpGauge(lpGauge).userCheckpoint(src);
            ILpGauge(lpGauge).userCheckpoint(dst);
        }
        ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);
        pool.handleLpTokenTransfer(src, dst, amount);

        uint256 allowanceNew = startingAllowance - amount;
        uint256 srcTokensNew = srcTokens - amount;
        uint256 dstTokensNew = balances[dst] + amount;

        /* Update token balances */
        balances[src] = srcTokensNew;
        balances[dst] = dstTokensNew;

        /* Update allowance if necessary */
        if (startingAllowance != type(uint256).max) {
            _allowances[src][spender] = allowanceNew;
        }
        emit Transfer(src, dst, amount);
        return true;
    }

    /**
     * @notice Approve staked tokens for spender.
     * @param spender Address to approve tokens for.
     * @param amount Amount to approve.
     * @return `true` if success.
     */
    function approve(address spender, uint256 amount) external override notPaused returns (bool) {
        address src = msg.sender;
        _allowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice If an action is registered and stakes funds, this updates the actionLockedBalances for the user.
     * @param account Address that registered the action.
     * @param amount Amount staked by the action.
     * @return `true` if success.
     */
    function increaseActionLockedBalance(address account, uint256 amount)
        external
        override
        returns (bool)
    {
        require(controller.addressProvider().isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);

        address lpGauge = currentAddresses[_LP_GAUGE];
        if (lpGauge != address(0)) {
            ILpGauge(lpGauge).userCheckpoint(account);
        }
        actionLockedBalances[account] += amount;
        return true;
    }

    /**
     * @notice If an action is executed/reset, this updates the actionLockedBalances for the user.
     * @param account Address that registered the action.
     * @param amount Amount executed/reset by the action.
     * @return `true` if success.
     */
    function decreaseActionLockedBalance(address account, uint256 amount)
        external
        override
        returns (bool)
    {
        require(controller.addressProvider().isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);

        address lpGauge = currentAddresses[_LP_GAUGE];
        if (lpGauge != address(0)) {
            ILpGauge(lpGauge).userCheckpoint(account);
        }
        if (actionLockedBalances[account] > amount) {
            actionLockedBalances[account] -= amount;
        } else {
            actionLockedBalances[account] = 0;
        }
        return true;
    }

    function poolCheckpoint() external override returns (bool) {
        if (currentAddresses[_LP_GAUGE] != address(0)) {
            return ILpGauge(currentAddresses[_LP_GAUGE]).poolCheckpoint();
        }
        return false;
    }

    function getLpGauge() external view override returns (address) {
        return currentAddresses[_LP_GAUGE];
    }

    function isStrategy(address user) external view override returns (bool) {
        return strategies[user];
    }

    /**
     * @notice Get the total amount of tokens that are staked by actions
     * @return Total amount staked by actions
     */
    function getStakedByActions() external view override returns (uint256) {
        address[] memory actions = controller.addressProvider().allActions();
        uint256 total;
        for (uint256 i = 0; i < actions.length; i++) {
            total += balances[actions[i]];
        }
        return total;
    }

    function allowance(address owner, address spender) external view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function balanceOf(address account) external view override returns (uint256) {
        return balances[account];
    }

    function getPoolTotalStaked() external view override returns (uint256) {
        return _poolTotalStaked;
    }

    /**
     * @notice Returns the total balance in the staker vault, including that locked in positions.
     * @param account Account to query balance for.
     * @return Total balance in staker vault for account.
     */
    function stakedAndActionLockedBalanceOf(address account)
        external
        view
        override
        returns (uint256)
    {
        return balances[account] + actionLockedBalances[account];
    }

    function actionLockedBalanceOf(address account) external view override returns (uint256) {
        return actionLockedBalances[account];
    }

    function decimals() external view returns (uint8) {
        return IERC20Full(token).decimals();
    }

    function getToken() external view override returns (address) {
        return token;
    }

    function unstake(uint256 amount) public override returns (bool) {
        return unstakeFor(msg.sender, msg.sender, amount);
    }

    /**
     * @notice Stake an amount of vault tokens.
     * @param amount Amount of token to stake.
     * @return `true` if success.
     */
    function stake(uint256 amount) public override returns (bool) {
        return stakeFor(msg.sender, amount);
    }

    /**
     * @notice Stake amount of vault token on behalf of another account.
     * @param account Account for which tokens will be staked.
     * @param amount Amount of token to stake.
     * @return `true` if success.
     */
    function stakeFor(address account, uint256 amount) public override notPaused returns (bool) {
        require(IERC20(token).balanceOf(msg.sender) >= amount, Error.INSUFFICIENT_BALANCE);

        address lpGauge = currentAddresses[_LP_GAUGE];
        if (lpGauge != address(0)) {
            ILpGauge(lpGauge).userCheckpoint(account);
        }

        uint256 oldBal = IERC20(token).balanceOf(address(this));

        if (msg.sender != account) {
            ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);
            pool.handleLpTokenTransfer(msg.sender, account, amount);
        }

        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        uint256 staked = IERC20(token).balanceOf(address(this)) - oldBal;
        require(staked == amount, Error.INVALID_AMOUNT);
        balances[account] += staked;

        if (strategies[account]) {
            strategiesTotalStaked += staked;
        } else {
            _poolTotalStaked += staked;
        }
        emit Staked(account, amount);
        return true;
    }

    /**
     * @notice Unstake tokens on behalf of another account.
     * @dev Needs to be approved.
     * @param src Account for which tokens will be unstaked.
     * @param dst Account receiving the tokens.
     * @param amount Amount of token to unstake/receive.
     * @return `true` if success.
     */
    function unstakeFor(
        address src,
        address dst,
        uint256 amount
    ) public override returns (bool) {
        ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);
        uint256 allowance_ = _allowances[src][msg.sender];
        require(
            src == msg.sender || allowance_ >= amount || address(pool) == msg.sender,
            Error.UNAUTHORIZED_ACCESS
        );
        require(balances[src] >= amount, Error.INSUFFICIENT_BALANCE);
        address lpGauge = currentAddresses[_LP_GAUGE];
        if (lpGauge != address(0)) {
            ILpGauge(lpGauge).userCheckpoint(src);
        }
        uint256 oldBal = IERC20(token).balanceOf(address(this));

        if (src != dst) {
            pool.handleLpTokenTransfer(src, dst, amount);
        }

        IERC20(token).safeTransfer(dst, amount);

        uint256 unstaked = oldBal - IERC20(token).balanceOf(address(this));

        if (src != msg.sender && allowance_ != type(uint256).max && address(pool) != msg.sender) {
            // update allowance
            _allowances[src][msg.sender] -= unstaked;
        }
        balances[src] -= unstaked;

        if (strategies[src]) {
            strategiesTotalStaked -= unstaked;
        } else {
            _poolTotalStaked -= unstaked;
        }
        emit Unstaked(src, amount);
        return true;
    }

    function _isAuthorizedToPause(address account) internal view override returns (bool) {
        return _roleManager().hasRole(Roles.GOVERNANCE, account);
    }
}",3192
RealWorld_BA_112_IAction_RealWord_20240829204437.log,112,IAction,6462,6058,12520,100.0,0.15347,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IAction {
    /**
     * @return the total amount of ETH (in wei) required to cover gas
     */
    function getEthRequiredForGas(address payer) external view returns (uint256);

    function addUsableToken(address token) external returns (bool);

    function getUsableTokens() external view returns (address[] memory);

    function isUsable(address token) external view returns (bool);

    function getActionFee() external view returns (uint256);

    function getFeeHandler() external view returns (address);

    function executeActionFee() external returns (uint256);

    function executeSwapperSlippage() external returns (uint256);

    function executeFeeHandler() external returns (address);
}",173
RealWorld_BA_112_Vault_RealWord_20240829195203.log,112,Vault,102393,5887,108280,114.0,0.629705,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../../interfaces/IVault.sol"";
import ""../../interfaces/IVaultReserve.sol"";
import ""../../interfaces/IController.sol"";
import ""../../interfaces/IStrategy.sol"";

import ""../../libraries/ScaledMath.sol"";
import ""../../libraries/Errors.sol"";
import ""../../libraries/EnumerableExtensions.sol"";
import ""../../libraries/AddressProviderHelpers.sol"";

import ""./VaultStorage.sol"";
import ""../utils/Preparable.sol"";
import ""../utils/IPausable.sol"";
import ""../access/Authorization.sol"";

abstract contract Vault is IVault, Authorization, VaultStorageV1, Preparable, Initializable {
    using ScaledMath for uint256;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using EnumerableMapping for EnumerableMapping.AddressToUintMap;
    using EnumerableExtensions for EnumerableMapping.AddressToUintMap;
    using AddressProviderHelpers for IAddressProvider;

    bytes32 internal constant _STRATEGY_KEY = ""Strategy"";
    bytes32 internal constant _PERFORMANCE_FEE_KEY = ""PerformanceFee"";
    bytes32 internal constant _STRATEGIST_FEE_KEY = ""StrategistFee"";
    bytes32 internal constant _DEBT_LIMIT_KEY = ""DebtLimit"";
    bytes32 internal constant _TARGET_ALLOCATION_KEY = ""TargetAllocation"";
    bytes32 internal constant _RESERVE_FEE_KEY = ""ReserveFee"";
    bytes32 internal constant _BOUND_KEY = ""Bound"";

    uint256 internal constant _INITIAL_RESERVE_FEE = 0.01e18;
    uint256 internal constant _INITIAL_STRATEGIST_FEE = 0.1e18;
    uint256 internal constant _INITIAL_PERFORMANCE_FEE = 0;

    uint256 public constant MAX_PERFORMANCE_FEE = 0.5e18;
    uint256 public constant MAX_DEVIATION_BOUND = 0.5e18;
    uint256 public constant STRATEGY_DELAY = 5 days;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;
    IVaultReserve public immutable reserve;

    modifier onlyPool() {
        require(msg.sender == pool, Error.UNAUTHORIZED_ACCESS);
        _;
    }

    modifier onlyPoolOrGovernance() {
        require(
            msg.sender == pool || _roleManager().hasRole(Roles.GOVERNANCE, msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );
        _;
    }

    modifier onlyPoolOrMaintenance() {
        require(
            msg.sender == pool || _roleManager().hasRole(Roles.MAINTENANCE, msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );
        _;
    }

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        IAddressProvider addressProvider_ = _controller.addressProvider();
        addressProvider = addressProvider_;
        reserve = IVaultReserve(addressProvider_.getVaultReserve());
    }

    function _initialize(
        address _pool,
        uint256 _debtLimit,
        uint256 _targetAllocation,
        uint256 _bound
    ) internal {
        require(_debtLimit <= ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(_targetAllocation <= ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(_bound <= MAX_DEVIATION_BOUND, Error.INVALID_AMOUNT);

        pool = _pool;

        _setConfig(_DEBT_LIMIT_KEY, _debtLimit);
        _setConfig(_TARGET_ALLOCATION_KEY, _targetAllocation);
        _setConfig(_BOUND_KEY, _bound);
        _setConfig(_RESERVE_FEE_KEY, _INITIAL_RESERVE_FEE);
        _setConfig(_STRATEGIST_FEE_KEY, _INITIAL_STRATEGIST_FEE);
        _setConfig(_PERFORMANCE_FEE_KEY, _INITIAL_PERFORMANCE_FEE);
    }

    /**
     * @notice Handles deposits from the liquidity pool
     */
    function deposit() external payable override onlyPoolOrMaintenance {
        // solhint-disable-previous-line ordering
        _deposit();
    }

    /**
     * @notice Withdraws specified amount of underlying from vault.
     * @dev If the specified amount exceeds idle funds, an amount of funds is withdrawn
     *      from the strategy such that it will achieve a target allocation for after the
     *      amount has been withdrawn.
     * @param amount Amount to withdraw.
     * @return `true` if successful.
     */
    function withdraw(uint256 amount) external override onlyPoolOrGovernance returns (bool) {
        IStrategy strategy = getStrategy();
        uint256 availableUnderlying_ = _availableUnderlying();

        if (availableUnderlying_ < amount) {
            if (address(strategy) == address(0)) return false;
            uint256 allocated = strategy.balance();
            uint256 requiredWithdrawal = amount - availableUnderlying_;

            if (requiredWithdrawal > allocated) return false;

            // compute withdrawal amount to sustain target allocation
            uint256 newTarget = (allocated - requiredWithdrawal).scaledMul(getTargetAllocation());
            uint256 excessAmount = allocated - newTarget;
            strategy.withdraw(excessAmount);
            currentAllocated = _computeNewAllocated(currentAllocated, excessAmount);
        } else {
            uint256 allocatedUnderlying = 0;
            if (address(strategy) != address(0))
                allocatedUnderlying = IStrategy(strategy).balance();
            uint256 totalUnderlying = availableUnderlying_ +
                allocatedUnderlying +
                waitingForRemovalAllocated;
            uint256 totalUnderlyingAfterWithdraw = totalUnderlying - amount;
            _rebalance(totalUnderlyingAfterWithdraw, allocatedUnderlying);
        }

        _transfer(pool, amount);
        return true;
    }

    /**
     * @notice Withdraws all funds from vault and strategy and transfer them to the pool.
     */
    function withdrawAll() external override onlyPoolOrGovernance {
        _withdrawAllFromStrategy();
        _transfer(pool, _availableUnderlying());
    }

    /**
     * @notice Withdraws specified amount of underlying from reserve to vault.
     * @dev Withdraws from reserve will cause a spike in pool exchange rate.
     *  Pool deposits should be paused during this to prevent front running
     * @param amount Amount to withdraw.
     */
    function withdrawFromReserve(uint256 amount) external override onlyGovernance {
        require(amount > 0, Error.INVALID_AMOUNT);
        require(IPausable(pool).isPaused(), Error.POOL_NOT_PAUSED);
        uint256 reserveBalance_ = reserve.getBalance(address(this), getUnderlying());
        require(amount <= reserveBalance_, Error.INSUFFICIENT_BALANCE);
        reserve.withdraw(getUnderlying(), amount);
    }

    /**
     * @notice Activate the current strategy set for the vault.
     * @return `true` if strategy has been activated
     */
    function activateStrategy() external onlyGovernance returns (bool) {
        return _activateStrategy();
    }

    /**
     * @notice Deactivates a strategy.
     * @return `true` if strategy has been deactivated
     */
    function deactivateStrategy() external onlyGovernance returns (bool) {
        return _deactivateStrategy();
    }

    /**
     * @notice Initializes the vault's strategy.
     * @dev Bypasses the time delay, but can only be called if strategy is not set already.
     * @param strategy_ Address of the strategy.
     * @return `true` if successful.
     */
    function initializeStrategy(address strategy_) external override onlyGovernance returns (bool) {
        require(currentAddresses[_STRATEGY_KEY] == address(0), Error.ADDRESS_ALREADY_SET);
        require(strategy_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        _setConfig(_STRATEGY_KEY, strategy_);
        _activateStrategy();
        require(IStrategy(strategy_).strategist() != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        return true;
    }

    /**
     * @notice Prepare update of the vault's strategy (with time delay enforced).
     * @param newStrategy Address of the new strategy.
     * @return `true` if successful.
     */
    function prepareNewStrategy(address newStrategy)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_STRATEGY_KEY, newStrategy, STRATEGY_DELAY);
    }

    /**
     * @notice Execute strategy update (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New strategy address.
     */
    function executeNewStrategy() external override returns (address) {
        _executeDeadline(_STRATEGY_KEY);
        IStrategy strategy = getStrategy();
        if (address(strategy) != address(0)) {
            _harvest();
            strategy.shutdown();
            strategy.withdrawAll();

            // there might still be some balance left if the strategy did not
            // manage to withdraw all funds (e.g. due to locking)
            uint256 remainingStrategyBalance = strategy.balance();
            if (remainingStrategyBalance > 0) {
                _strategiesWaitingForRemoval.set(address(strategy), remainingStrategyBalance);
                waitingForRemovalAllocated += remainingStrategyBalance;
            }
        }
        _deactivateStrategy();
        currentAllocated = 0;
        totalDebt = 0;
        address newStrategy = pendingAddresses[_STRATEGY_KEY];
        _setConfig(_STRATEGY_KEY, newStrategy);

        if (newStrategy != address(0)) {
            _activateStrategy();
        }

        return newStrategy;
    }

    function resetNewStrategy() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_STRATEGY_KEY);
    }

    /**
     * @notice Prepare update of performance fee (with time delay enforced).
     * @param newPerformanceFee New performance fee value.
     * @return `true` if successful.
     */
    function preparePerformanceFee(uint256 newPerformanceFee)
        external
        onlyGovernance
        returns (bool)
    {
        require(newPerformanceFee <= MAX_PERFORMANCE_FEE, Error.INVALID_AMOUNT);
        return _prepare(_PERFORMANCE_FEE_KEY, newPerformanceFee);
    }

    /**
     * @notice Execute update of performance fee (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New performance fee.
     */
    function executePerformanceFee() external returns (uint256) {
        return _executeUInt256(_PERFORMANCE_FEE_KEY);
    }

    function resetPerformanceFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_PERFORMANCE_FEE_KEY);
    }

    /**
     * @notice Prepare update of strategist fee (with time delay enforced).
     * @param newStrategistFee New strategist fee value.
     * @return `true` if successful.
     */
    function prepareStrategistFee(uint256 newStrategistFee) external onlyGovernance returns (bool) {
        _checkFeesInvariant(getReserveFee(), newStrategistFee);
        return _prepare(_STRATEGIST_FEE_KEY, newStrategistFee);
    }

    /**
     * @notice Execute update of strategist fee (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New strategist fee.
     */
    function executeStrategistFee() external returns (uint256) {
        uint256 newStrategistFee = _executeUInt256(_STRATEGIST_FEE_KEY);
        _checkFeesInvariant(getReserveFee(), newStrategistFee);
        return newStrategistFee;
    }

    function resetStrategistFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_STRATEGIST_FEE_KEY);
    }

    /**
     * @notice Prepare update of debt limit (with time delay enforced).
     * @param newDebtLimit New debt limit.
     * @return `true` if successful.
     */
    function prepareDebtLimit(uint256 newDebtLimit) external onlyGovernance returns (bool) {
        return _prepare(_DEBT_LIMIT_KEY, newDebtLimit);
    }

    /**
     * @notice Execute update of debt limit (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New debt limit.
     */
    function executeDebtLimit() external returns (uint256) {
        uint256 debtLimit = _executeUInt256(_DEBT_LIMIT_KEY);
        uint256 debtLimitAllocated = currentAllocated.scaledMul(debtLimit);
        if (totalDebt >= debtLimitAllocated) {
            _handleExcessDebt();
        }
        return debtLimit;
    }

    function resetDebtLimit() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_DEBT_LIMIT_KEY);
    }

    /**
     * @notice Prepare update of target allocation (with time delay enforced).
     * @param newTargetAllocation New target allocation.
     * @return `true` if successful.
     */
    function prepareTargetAllocation(uint256 newTargetAllocation)
        external
        onlyGovernance
        returns (bool)
    {
        return _prepare(_TARGET_ALLOCATION_KEY, newTargetAllocation);
    }

    /**
     * @notice Execute update of target allocation (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New target allocation.
     */
    function executeTargetAllocation() external returns (uint256) {
        uint256 targetAllocation = _executeUInt256(_TARGET_ALLOCATION_KEY);
        _deposit();
        return targetAllocation;
    }

    function resetTargetAllocation() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_TARGET_ALLOCATION_KEY);
    }

    /**
     * @notice Prepare update of reserve fee (with time delay enforced).
     * @param newReserveFee New reserve fee.
     * @return `true` if successful.
     */
    function prepareReserveFee(uint256 newReserveFee) external onlyGovernance returns (bool) {
        _checkFeesInvariant(newReserveFee, getStrategistFee());
        return _prepare(_RESERVE_FEE_KEY, newReserveFee);
    }

    /**
     * @notice Execute update of reserve fee (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New reserve fee.
     */
    function executeReserveFee() external returns (uint256) {
        uint256 newReserveFee = _executeUInt256(_RESERVE_FEE_KEY);
        _checkFeesInvariant(newReserveFee, getStrategistFee());
        return newReserveFee;
    }

    function resetReserveFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_RESERVE_FEE_KEY);
    }

    /**
     * @notice Prepare update of deviation bound for strategy allocation (with time delay enforced).
     * @param newBound New deviation bound for target allocation.
     * @return `true` if successful.
     */
    function prepareBound(uint256 newBound) external onlyGovernance returns (bool) {
        require(newBound <= MAX_DEVIATION_BOUND, Error.INVALID_AMOUNT);
        return _prepare(_BOUND_KEY, newBound);
    }

    /**
     * @notice Execute update of deviation bound for strategy allocation (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New deviation bound.
     */
    function executeBound() external returns (uint256) {
        uint256 bound = _executeUInt256(_BOUND_KEY);
        _deposit();
        return bound;
    }

    function resetBound() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_BOUND_KEY);
    }

    /**
     * @notice Withdraws an amount of underlying from the strategy to the vault.
     * @param amount Amount of underlying to withdraw.
     * @return True if successful withdrawal.
     */
    function withdrawFromStrategy(uint256 amount) external onlyGovernance returns (bool) {
        IStrategy strategy = getStrategy();
        if (address(strategy) == address(0)) return false;
        if (strategy.balance() < amount) return false;
        uint256 oldBalance = _availableUnderlying();
        strategy.withdraw(amount);
        uint256 newBalance = _availableUnderlying();
        currentAllocated -= newBalance - oldBalance;
        return true;
    }

    function withdrawFromStrategyWaitingForRemoval(address strategy) external returns (uint256) {
        (bool exists, uint256 allocated) = _strategiesWaitingForRemoval.tryGet(strategy);
        require(exists, Error.STRATEGY_DOES_NOT_EXIST);

        IStrategy strategy_ = IStrategy(strategy);

        strategy_.harvest();
        uint256 withdrawn = strategy_.withdrawAll();

        uint256 _waitingForRemovalAllocated = waitingForRemovalAllocated;
        if (withdrawn >= _waitingForRemovalAllocated) {
            waitingForRemovalAllocated = 0;
        } else {
            waitingForRemovalAllocated = _waitingForRemovalAllocated - withdrawn;
        }

        if (withdrawn > allocated) {
            uint256 profit = withdrawn - allocated;
            uint256 strategistShare = _shareFees(profit.scaledMul(getPerformanceFee()));
            if (strategistShare > 0) {
                _payStrategist(strategistShare, strategy_.strategist());
            }
            allocated = 0;
            emit Harvest(profit, 0);
        } else {
            allocated -= withdrawn;
        }

        if (strategy_.balance() == 0) {
            _strategiesWaitingForRemoval.remove(address(strategy_));
        } else {
            _strategiesWaitingForRemoval.set(address(strategy_), allocated);
        }

        return withdrawn;
    }

    function getStrategiesWaitingForRemoval() external view returns (address[] memory) {
        return _strategiesWaitingForRemoval.keysArray();
    }

    /**
     * @notice Computes the total underlying of the vault: idle funds + allocated funds - debt
     * @return Total amount of underlying.
     */
    function getTotalUnderlying() external view override returns (uint256) {
        uint256 availableUnderlying_ = _availableUnderlying();

        if (address(getStrategy()) == address(0)) {
            return availableUnderlying_;
        }

        uint256 netUnderlying = availableUnderlying_ +
            currentAllocated +
            waitingForRemovalAllocated;
        if (totalDebt <= netUnderlying) return netUnderlying - totalDebt;
        return 0;
    }

    function getAllocatedToStrategyWaitingForRemoval(address strategy)
        external
        view
        returns (uint256)
    {
        return _strategiesWaitingForRemoval.get(strategy);
    }

    /**
     * @notice Withdraws all funds from strategy to vault.
     * @dev Harvests profits before withdrawing. Deactivates strategy after withdrawing.
     * @return `true` if successful.
     */
    function withdrawAllFromStrategy() public onlyPoolOrGovernance returns (bool) {
        return _withdrawAllFromStrategy();
    }

    /**
     * @notice Harvest profits from the vault's strategy.
     * @dev Harvesting adds profits to the vault's balance and deducts fees.
     *  No performance fees are charged on profit used to repay debt.
     * @return `true` if successful.
     */
    function harvest() public onlyPoolOrMaintenance returns (bool) {
        return _harvest();
    }

    /**
     * @notice Returns the percentage of the performance fee that goes to the strategist.
     */
    function getStrategistFee() public view returns (uint256) {
        return currentUInts256[_STRATEGIST_FEE_KEY];
    }

    function getStrategy() public view override returns (IStrategy) {
        return IStrategy(currentAddresses[_STRATEGY_KEY]);
    }

    /**
     * @notice Returns the percentage of the performance fee which is allocated to the vault reserve
     */
    function getReserveFee() public view returns (uint256) {
        return currentUInts256[_RESERVE_FEE_KEY];
    }

    /**
     * @notice Returns the fee charged on a strategy's generated profits.
     * @dev The strategist is paid in LP tokens, while the remainder of the profit stays in the vault.
     *      Default performance fee is set to 5% of harvested profits.
     */
    function getPerformanceFee() public view returns (uint256) {
        return currentUInts256[_PERFORMANCE_FEE_KEY];
    }

    /**
     * @notice Returns the allowed symmetric bound for target allocation (e.g. +- 5%)
     */
    function getBound() public view returns (uint256) {
        return currentUInts256[_BOUND_KEY];
    }

    /**
     * @notice The target percentage of total underlying funds to be allocated towards a strategy.
     * @dev this is to reduce gas costs. Withdrawals first come from idle funds and can therefore
     *      avoid unnecessary gas costs.
     */
    function getTargetAllocation() public view returns (uint256) {
        return currentUInts256[_TARGET_ALLOCATION_KEY];
    }

    /**
     * @notice The debt limit that the total debt of a strategy may not exceed.
     */
    function getDebtLimit() public view returns (uint256) {
        return currentUInts256[_DEBT_LIMIT_KEY];
    }

    function getUnderlying() public view virtual override returns (address);

    function _activateStrategy() internal returns (bool) {
        IStrategy strategy = getStrategy();
        if (address(strategy) == address(0)) return false;

        strategyActive = true;
        emit StrategyActivated(address(strategy));
        _deposit();
        return true;
    }

    function _harvest() internal returns (bool) {
        IStrategy strategy = getStrategy();
        if (address(strategy) == address(0)) {
            return false;
        }

        strategy.harvest();

        uint256 strategistShare = 0;

        uint256 allocatedUnderlying = strategy.balance();
        uint256 amountAllocated = currentAllocated;
        uint256 currentDebt = totalDebt;

        if (allocatedUnderlying > amountAllocated) {
            // we made profits
            uint256 profit = allocatedUnderlying - amountAllocated;

            if (profit > currentDebt) {
                if (currentDebt > 0) {
                    profit -= currentDebt;
                    currentDebt = 0;
                }
                (profit, strategistShare) = _shareProfit(profit);
            } else {
                currentDebt -= profit;
            }
            emit Harvest(profit, 0);
        } else if (allocatedUnderlying < amountAllocated) {
            // we made a loss
            uint256 loss = amountAllocated - allocatedUnderlying;
            currentDebt += loss;

            // check debt limit and withdraw funds if exceeded
            uint256 debtLimit = getDebtLimit();
            uint256 debtLimitAllocated = amountAllocated.scaledMul(debtLimit);
            if (currentDebt > debtLimitAllocated) {
                currentDebt = _handleExcessDebt(currentDebt);
            }
            emit Harvest(0, loss);
        } else {
            // nothing to declare
            return true;
        }

        totalDebt = currentDebt;
        currentAllocated = strategy.balance();

        if (strategistShare > 0) {
            _payStrategist(strategistShare);
        }

        return true;
    }

    function _withdrawAllFromStrategy() internal returns (bool) {
        IStrategy strategy = getStrategy();
        if (address(strategy) == address(0)) return false;
        _harvest();
        uint256 oldBalance = _availableUnderlying();
        strategy.withdrawAll();
        uint256 newBalance = _availableUnderlying();
        uint256 withdrawnAmount = newBalance - oldBalance;

        currentAllocated = _computeNewAllocated(currentAllocated, withdrawnAmount);
        _deactivateStrategy();
        return true;
    }

    function _handleExcessDebt(uint256 currentDebt) internal returns (uint256) {
        uint256 underlyingReserves = reserve.getBalance(address(this), getUnderlying());
        if (currentDebt > underlyingReserves) {
            _emergencyStop(underlyingReserves);
        } else if (reserve.canWithdraw(address(this))) {
            reserve.withdraw(getUnderlying(), currentDebt);
            currentDebt = 0;
            _deposit();
        }
        return currentDebt;
    }

    function _handleExcessDebt() internal {
        uint256 currentDebt = totalDebt;
        uint256 newDebt = _handleExcessDebt(totalDebt);
        if (currentDebt != newDebt) {
            totalDebt = newDebt;
        }
    }

    /**
     * @notice Invest the underlying money in the vault after a deposit from the pool is made.
     * @dev After each deposit, the vault checks whether it needs to rebalance underlying funds allocated to strategy.
     * If no strategy is set then all deposited funds will be idle.
     */
    function _deposit() internal {
        if (!strategyActive) return;

        uint256 allocatedUnderlying = getStrategy().balance();
        uint256 totalUnderlying = _availableUnderlying() +
            allocatedUnderlying +
            waitingForRemovalAllocated;

        if (totalUnderlying == 0) return;
        _rebalance(totalUnderlying, allocatedUnderlying);
    }

    function _shareProfit(uint256 profit) internal returns (uint256, uint256) {
        uint256 totalFeeAmount = profit.scaledMul(getPerformanceFee());
        if (_availableUnderlying() < totalFeeAmount) {
            getStrategy().withdraw(totalFeeAmount);
        }
        uint256 strategistShare = _shareFees(totalFeeAmount);

        return ((profit - totalFeeAmount), strategistShare);
    }

    function _shareFees(uint256 totalFeeAmount) internal returns (uint256) {
        uint256 strategistShare = totalFeeAmount.scaledMul(getStrategistFee());

        uint256 reserveShare = totalFeeAmount.scaledMul(getReserveFee());
        uint256 treasuryShare = totalFeeAmount - strategistShare - reserveShare;

        _depositToReserve(reserveShare);
        if (treasuryShare > 0) {
            _depositToTreasury(treasuryShare);
        }
        return strategistShare;
    }

    function _emergencyStop(uint256 underlyingReserves) internal {
        // debt limit exceeded: withdraw funds from strategy
        uint256 withdrawn = getStrategy().withdrawAll();

        uint256 actualDebt = _computeNewAllocated(currentAllocated, withdrawn);

        if (reserve.canWithdraw(address(this))) {
            // check if debt can be covered with reserve funds
            if (underlyingReserves >= actualDebt) {
                reserve.withdraw(getUnderlying(), actualDebt);
            } else if (underlyingReserves > 0) {
                // debt can not be covered with reserves
                reserve.withdraw(getUnderlying(), underlyingReserves);
            }
        }

        // too much money lost, stop the strategy
        _deactivateStrategy();
    }

    /**
     * @notice Deactivates a strategy. All positions of the strategy are exited.
     * @return `true` if strategy has been deactivated
     */
    function _deactivateStrategy() internal returns (bool) {
        if (!strategyActive) return false;

        strategyActive = false;
        emit StrategyDeactivated(address(getStrategy()));
        return true;
    }

    function _payStrategist(uint256 amount) internal {
        _payStrategist(amount, getStrategy().strategist());
    }

    function _payStrategist(uint256 amount, address strategist) internal virtual;

    function _transfer(address to, uint256 amount) internal virtual;

    function _depositToReserve(uint256 amount) internal virtual;

    function _depositToTreasury(uint256 amount) internal virtual;

    function _availableUnderlying() internal view virtual returns (uint256);

    function _computeNewAllocated(uint256 allocated, uint256 withdrawn)
        internal
        pure
        returns (uint256)
    {
        if (allocated > withdrawn) {
            return allocated - withdrawn;
        }
        return 0;
    }

    function _checkFeesInvariant(uint256 reserveFee, uint256 strategistFee) internal pure {
        require(
            reserveFee + strategistFee <= ScaledMath.ONE,
            ""sum of strategist fee and reserve fee should be below 1""
        );
    }

    function _rebalance(uint256 totalUnderlying, uint256 allocatedUnderlying)
        private
        returns (bool)
    {
        if (!strategyActive) return false;
        uint256 targetAllocation = getTargetAllocation();

        IStrategy strategy = getStrategy();
        uint256 bound = getBound();

        uint256 target = totalUnderlying.scaledMul(targetAllocation);
        uint256 upperBound = targetAllocation == 0 ? 0 : targetAllocation + bound;
        upperBound = upperBound > ScaledMath.ONE ? ScaledMath.ONE : upperBound;
        uint256 lowerBound = bound > targetAllocation ? 0 : targetAllocation - bound;
        if (allocatedUnderlying > totalUnderlying.scaledMul(upperBound)) {
            // withdraw funds from strategy
            uint256 withdrawAmount = allocatedUnderlying - target;
            strategy.withdraw(withdrawAmount);

            currentAllocated = _computeNewAllocated(currentAllocated, withdrawAmount);
        } else if (allocatedUnderlying < totalUnderlying.scaledMul(lowerBound)) {
            // allocate more funds to strategy
            uint256 depositAmount = target - allocatedUnderlying;
            _transfer(address(strategy), depositAmount);
            currentAllocated += depositAmount;
            strategy.deposit();
        }
        return true;
    }
}",6432
RealWorld_BA_112_DataTypes_RealWord_20240829201453.log,112,DataTypes,10069,5561,15630,105.0,0.161565,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

library DataTypes {
    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.
    struct ReserveData {
        //stores the reserve configuration
        ReserveConfigurationMap configuration;
        //the liquidity index. Expressed in ray
        uint128 liquidityIndex;
        //variable borrow index. Expressed in ray
        uint128 variableBorrowIndex;
        //the current supply rate. Expressed in ray
        uint128 currentLiquidityRate;
        //the current variable borrow rate. Expressed in ray
        uint128 currentVariableBorrowRate;
        //the current stable borrow rate. Expressed in ray
        uint128 currentStableBorrowRate;
        uint40 lastUpdateTimestamp;
        //tokens addresses
        address aTokenAddress;
        address stableDebtTokenAddress;
        address variableDebtTokenAddress;
        //address of the interest rate strategy
        address interestRateStrategyAddress;
        //the id of the reserve. Represents the position in the list of the active reserves
        uint8 id;
    }

    struct ReserveConfigurationMap {
        //bit 0-15: LTV
        //bit 16-31: Liq. threshold
        //bit 32-47: Liq. bonus
        //bit 48-55: Decimals
        //bit 56: Reserve is active
        //bit 57: reserve is frozen
        //bit 58: borrowing is enabled
        //bit 59: stable rate borrowing enabled
        //bit 60-63: reserved
        //bit 64-79: reserve factor
        uint256 data;
    }

    struct UserConfigurationMap {
        uint256 data;
    }

    enum InterestRateMode {
        NONE,
        STABLE,
        VARIABLE
    }
}",398
RealWorld_BA_112_ITopUpKeeperHelper_RealWord_20240829204743.log,112,ITopUpKeeperHelper,6233,5102,11335,82.0,0.133205,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./ITopUpAction.sol"";

interface ITopUpKeeperHelper {
    struct TopupData {
        address payer;
        bytes32 account;
        bytes32 protocol;
        ITopUpAction.Record record;
    }

    function listPositions(address payer)
        external
        view
        returns (ITopUpAction.RecordWithMeta[] memory);

    function getExecutableTopups(uint256 cursor, uint256 howMany)
        external
        returns (TopupData[] memory topups, uint256 nextCursor);

    function canExecute(ITopUpAction.RecordKey calldata key) external view returns (bool);

    function batchCanExecute(ITopUpAction.RecordKey[] calldata keys)
        external
        returns (bool[] memory);
}",175
RealWorld_BA_112_MockTopUpAction_RealWord_20240829190421.log,112,MockTopUpAction,6164,4926,11090,85.0,0.12934,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../actions/topup/TopUpAction.sol"";

contract MockTopUpAction is TopUpAction {
    constructor(IController _controller) TopUpAction(_controller) {
        // solhint-disable-previous-line no-empty-blocks
    }

    function updateFeeHandler(address feeHandlerAddress) external onlyGovernance {
        _setConfig(_FEE_HANDLER_KEY, feeHandlerAddress);
    }

    function setActionFee(uint256 fee) external onlyGovernance {
        _setConfig(_ACTION_FEE_KEY, fee);
    }

    function testingPayFees(
        address payer,
        address keeper,
        uint256 amount,
        address lpToken
    ) external {
        _payFees(payer, keeper, amount, lpToken);
    }
}",179
RealWorld_BA_112_ComptrollerInterface_RealWord_20240829210844.log,112,ComptrollerInterface,13564,5254,18818,96.0,0.1729,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

abstract contract ComptrollerInterface {
    /// @notice Indicator that this is a Comptroller contract (for inspection)
    bool public constant isComptroller = true;

    /*** Assets You Are In ***/

    function enterMarkets(address[] calldata cTokens) external virtual returns (uint256[] memory);

    function exitMarket(address cToken) external virtual returns (uint256);

    /*** Policy Hooks ***/

    function mintAllowed(
        address cToken,
        address minter,
        uint256 mintAmount
    ) external virtual returns (uint256);

    function mintVerify(
        address cToken,
        address minter,
        uint256 mintAmount,
        uint256 mintTokens
    ) external virtual;

    function redeemAllowed(
        address cToken,
        address redeemer,
        uint256 redeemTokens
    ) external virtual returns (uint256);

    function redeemVerify(
        address cToken,
        address redeemer,
        uint256 redeemAmount,
        uint256 redeemTokens
    ) external virtual;

    function borrowAllowed(
        address cToken,
        address borrower,
        uint256 borrowAmount
    ) external virtual returns (uint256);

    function borrowVerify(
        address cToken,
        address borrower,
        uint256 borrowAmount
    ) external virtual;

    function repayBorrowAllowed(
        address cToken,
        address payer,
        address borrower,
        uint256 repayAmount
    ) external virtual returns (uint256);

    function repayBorrowVerify(
        address cToken,
        address payer,
        address borrower,
        uint256 repayAmount,
        uint256 borrowerIndex
    ) external virtual;

    function liquidateBorrowAllowed(
        address cTokenBorrowed,
        address cTokenCollateral,
        address liquidator,
        address borrower,
        uint256 repayAmount
    ) external virtual returns (uint256);

    function liquidateBorrowVerify(
        address cTokenBorrowed,
        address cTokenCollateral,
        address liquidator,
        address borrower,
        uint256 repayAmount,
        uint256 seizeTokens
    ) external virtual;

    function seizeAllowed(
        address cTokenCollateral,
        address cTokenBorrowed,
        address liquidator,
        address borrower,
        uint256 seizeTokens
    ) external virtual returns (uint256);

    function seizeVerify(
        address cTokenCollateral,
        address cTokenBorrowed,
        address liquidator,
        address borrower,
        uint256 seizeTokens
    ) external virtual;

    function transferAllowed(
        address cToken,
        address src,
        address dst,
        uint256 transferTokens
    ) external virtual returns (uint256);

    function transferVerify(
        address cToken,
        address src,
        address dst,
        uint256 transferTokens
    ) external virtual;

    /*** Liquidity/Liquidation Calculations ***/

    function liquidateCalculateSeizeTokens(
        address cTokenBorrowed,
        address cTokenCollateral,
        uint256 repayAmount
    ) external view virtual returns (uint256, uint256);
}",653
RealWorld_BA_112_PriceOracle_RealWord_20240829211746.log,112,PriceOracle,5516,5265,10781,89.0,0.13288,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

import ""./CToken.sol"";

abstract contract PriceOracle {
    /// @notice Indicator that this is a PriceOracle contract (for inspection)
    bool public constant isPriceOracle = true;

    /**
     * @notice Get the underlying price of a cToken asset
     * @param cToken The cToken to get the underlying price of
     * @return The underlying asset price mantissa (scaled by 1e18).
     *  Zero means the price is unavailable.
     */
    function getUnderlyingPrice(CToken cToken) external view virtual returns (uint256);
}",138
RealWorld_BA_112_Erc20Vault_RealWord_20240829194910.log,112,Erc20Vault,9156,5124,14280,90.0,0.14826,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./Vault.sol"";

contract Erc20Vault is Vault {
    using AddressProviderHelpers for IAddressProvider;
    using SafeERC20 for IERC20;

    constructor(IController controller) Vault(controller) {}

    function initialize(
        address _pool,
        uint256 _debtLimit,
        uint256 _targetAllocation,
        uint256 _bound
    ) external virtual override initializer {
        _initialize(_pool, _debtLimit, _targetAllocation, _bound);
        address underlying_ = ILiquidityPool(pool).getUnderlying();
        require(underlying_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        IERC20(underlying_).safeApprove(address(reserve), type(uint256).max);
        IERC20(underlying_).safeApprove(_pool, type(uint256).max);
    }

    function getUnderlying() public view override returns (address) {
        return ILiquidityPool(pool).getUnderlying();
    }

    function _transfer(address to, uint256 amount) internal override {
        IERC20(getUnderlying()).safeTransfer(to, amount);
    }

    function _depositToReserve(uint256 amount) internal override {
        reserve.deposit(getUnderlying(), amount);
    }

    function _depositToTreasury(uint256 amount) internal override {
        IERC20(getUnderlying()).safeTransfer(addressProvider.getTreasury(), amount);
    }

    function _payStrategist(uint256 amount, address strategist) internal override {
        if (strategist == address(0)) return;
        ILiquidityPool(pool).depositFor(strategist, amount);
    }

    function _availableUnderlying() internal view override returns (uint256) {
        return IERC20(getUnderlying()).balanceOf(address(this));
    }
}",396
RealWorld_BA_112_MockPriceOracle_RealWord_20240829183610.log,112,MockPriceOracle,6792,4168,10960,75.0,0.11732,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../interfaces/oracles/IOracleProvider.sol"";

contract MockPriceOracle is IOracleProvider {
    mapping(address => uint256) internal _prices;

    function setPrice(address baseAsset, uint256 price) external {
        _prices[baseAsset] = price;
    }

    /// @inheritdoc IOracleProvider
    /// @dev this is a dummy function that tries to read from the state
    /// and otherwise simply returns 1
    function getPriceUSD(address baseAsset) external view returns (uint256) {
        uint256 cachedPrice = _prices[baseAsset];
        return cachedPrice == 0 ? 1e18 : cachedPrice;
    }

    /// @inheritdoc IOracleProvider
    /// @dev this is a dummy function that tries to read from the state
    /// and otherwise simply returns 1
    function getPriceETH(address baseAsset) external view returns (uint256) {
        uint256 cachedPrice = _prices[baseAsset];
        return cachedPrice == 0 ? 1e18 : cachedPrice;
    }
}",240
RealWorld_BA_112_MockBKDMinter_RealWord_20240829184203.log,112,MockBKDMinter,8549,5264,13813,82.0,0.148025,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity 0.8.9;

import ""../tokenomics/Minter.sol"";

contract MockBKDMinter is Minter {
    constructor(
        uint256 _annualInflationRateLp,
        uint256 _annualInflationRateKeeper,
        uint256 _annualInflationRateAmm,
        uint256 _annualInflationDecayLp,
        uint256 _annualInflationDecayKeeper,
        uint256 _annualInflationDecayAmm,
        uint256 _initialPeriodKeeperInflation,
        uint256 _initialPeriodAmmInflation,
        uint256 _nonInflationDistribution,
        IController _controller
    )
        Minter(
            _annualInflationRateLp,
            _annualInflationRateKeeper,
            _annualInflationRateAmm,
            _annualInflationDecayLp,
            _annualInflationDecayKeeper,
            _annualInflationDecayAmm,
            _initialPeriodKeeperInflation,
            _initialPeriodAmmInflation,
            _nonInflationDistribution,
            _controller
        )
    {}

    // solhint-disable-next-line func-name-mixedcase
    function mint_for_testing(address beneficiary, uint256 amount) external returns (bool) {
        token.mint(beneficiary, amount);
        return true;
    }

    // solhint-disable-next-line func-name-mixedcase
    function mint_for_testing_with_checks(address beneficiary, uint256 amount)
        external
        returns (bool)
    {
        return _mint(beneficiary, amount);
    }
}",336
RealWorld_BA_112_IPausable_RealWord_20240829182957.log,112,IPausable,4282,4022,8304,71.0,0.10185,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IPausable {
    function pause() external returns (bool);

    function unpause() external returns (bool);

    function isPaused() external view returns (bool);

    function isAuthorizedToPause(address account) external view returns (bool);
}",74
RealWorld_BA_112_SwapperRegistry_RealWord_20240829180101.log,112,SwapperRegistry,15205,5294,20499,84.0,0.181905,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";

import ""../libraries/Errors.sol"";
import ""./access/Authorization.sol"";
import ""../interfaces/ISwapperRegistry.sol"";

contract SwapperRegistry is ISwapperRegistry, Authorization {
    mapping(address => address[]) private _swappableTokens;
    mapping(address => mapping(address => address)) private _swapperImplementations;

    event NewSwapper(address fromToken, address toToken, address newSwapper);
    event SwapperRemoved(address fromToken, address toToken, address oldSwapper);
    event NewSwappablePair(address fromToken, address toToken);

    constructor(IRoleManager roleManager) Authorization(roleManager) {}

    /**
     * @notice Add new swapper implementation for a given token pair.
     * @param fromToken Address of token to swap.
     * @param toToken Address of token to receive.
     * @param newSwapper Address of new swapper implementation for the token pair.
     * @return True if the swapper was successfully set for the token pair.
     */
    function registerSwapper(
        address fromToken,
        address toToken,
        address newSwapper
    ) external onlyGovernance returns (bool) {
        require(
            fromToken != toToken &&
                fromToken != address(0) &&
                toToken != address(0) &&
                newSwapper != address(0),
            Error.INVALID_TOKEN_PAIR
        );
        address swapper = _swapperImplementations[fromToken][toToken];
        if (swapper != address(0)) {
            if (swapper == newSwapper) return false;
            emit SwapperRemoved(fromToken, toToken, swapper);
        } else {
            _swappableTokens[fromToken].push(toToken);
            emit NewSwappablePair(fromToken, toToken);
        }
        _swapperImplementations[fromToken][toToken] = newSwapper;
        emit NewSwapper(fromToken, toToken, newSwapper);
        return true;
    }

    /**
     * @notice Get swapper implementation for a given token pair.
     * @param fromToken Address of token to swap.
     * @param toToken Address of token to receive.
     * @return Address of swapper for token pair. Returns zero address if no swapper implementation exists.
     */
    function getSwapper(address fromToken, address toToken)
        external
        view
        override
        returns (address)
    {
        return _swapperImplementations[fromToken][toToken];
    }

    /**
     * @notice Check if a swapper implementation exists for a given token pair.
     * @param fromToken Address of token to swap.
     * @param toToken Address of token to receive.
     * @return True if a swapper exists for the token pair.
     */
    function swapperExists(address fromToken, address toToken)
        external
        view
        override
        returns (bool)
    {
        return _swapperImplementations[fromToken][toToken] != address(0) ? true : false;
    }

    function getAllSwappableTokens(address token)
        external
        view
        override
        returns (address[] memory)
    {
        return _swappableTokens[token];
    }
}",753
RealWorld_BA_112_IGauge_RealWord_20240829214411.log,112,IGauge,6350,5717,12067,113.0,0.14609,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface IGauge {
    function deposit(uint256) external;

    function balanceOf(address) external view returns (uint256);

    function withdraw(uint256) external;

    function user_checkpoint(address) external;

    function claimable_tokens(address) external view returns (uint256);
}

interface IVotingEscrow {
    function create_lock(uint256 _value, uint256 _time) external;

    function increase_amount(uint256 _value) external;

    function increase_unlock_time(uint256 _unlock_time) external;

    function withdraw() external;

    function balanceOf(address _address) external view returns (uint256);

    function totalSupply() external view returns (uint256);
}

interface IFeeDistributor {
    function claim(address _addr) external returns (uint256);
}

interface IMinter {
    function mint(address gauge_addr) external;
}",188
RealWorld_BA_112_CvxCrvRewardsLocker_RealWord_20240829180227.log,112,CvxCrvRewardsLocker,43431,5733,49164,99.0,0.331815,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./access/Authorization.sol"";

import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/vendor/IRewardStaking.sol"";
import ""../interfaces/vendor/ICrvDepositor.sol"";
import ""../interfaces/vendor/IDelegation.sol"";
import ""../interfaces/vendor/IvlCvxExtraRewardDistribution.sol"";
import ""../interfaces/vendor/ICurveSwap.sol"";
import ""../interfaces/vendor/ICvxLocker.sol"";
import ""../interfaces/ICvxCrvRewardsLocker.sol"";

import ""../libraries/Errors.sol"";
import ""../libraries/AddressProviderHelpers.sol"";

contract CvxCrvRewardsLocker is ICvxCrvRewardsLocker, Authorization {
    using AddressProviderHelpers for IAddressProvider;

    using SafeERC20 for IERC20;

    // ERC20 tokens
    address public constant CVX = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);
    address public constant CVX_CRV = address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);
    address public constant CRV = address(0xD533a949740bb3306d119CC777fa900bA034cd52);

    address public constant CVX_CRV_CRV_CURVE_POOL =
        address(0x9D0464996170c6B9e75eED71c68B99dDEDf279e8); // cvxCRV/CRV Curve Pool
    address public constant CRV_DEPOSITOR = address(0x8014595F2AB54cD7c604B00E9fb932176fDc86Ae); // Lock CRV for cvxCRV
    address public constant CVX_CRV_STAKING = address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); // Stake cvxCRV and get rewards
    address public constant CVX_LOCKER = address(0x72a19342e8F1838460eBFCCEf09F6585e32db86E); // CVX Locker
    address public constant VL_CVX_EXTRA_REWARD_DISTRIBUTION =
        address(0xDecc7d761496d30F30b92Bdf764fb8803c79360D);

    uint256 public spendRatio;
    bool public prepareWithdrawal;
    address public treasury;

    int128 private constant _CRV_INDEX = 0;
    int128 private constant _CVX_CRV_INDEX = 1;

    event NewSpendRatio(uint256 newSpendRatio);
    event NewTreasury(address newTreasury);

    constructor(IAddressProvider _addressProvider)
        Authorization(_addressProvider.getRoleManager())
    {
        // Approve for locking CRV for cvxCRV
        IERC20(CRV).safeApprove(CRV_DEPOSITOR, type(uint256).max);

        // Approve for staking cvxCRV
        IERC20(CVX_CRV).safeApprove(CVX_CRV_STAKING, type(uint256).max);

        // Approve for cvxCRV/CRV Curve Pool Swaps
        IERC20(CRV).safeApprove(CVX_CRV_CRV_CURVE_POOL, type(uint256).max);

        // Approve CVX Locker
        IERC20(CVX).safeApprove(CVX_LOCKER, type(uint256).max);

        treasury = _addressProvider.getTreasury();
    }

    function lockCvx() external override {
        _lockCvx();
    }

    function lockCrv() external override {
        _lockCrv();
    }

    /**
     * @notice Set spend ratio for CVX locking.
     * @dev Spend ratio is the amount of CVX that should be donated to
     * the Convex treasury to boost vote power. This needs to be enabled
     * by Convex.
     * @param _spendRatio New spend ratio to be used.
     */
    function setSpendRatio(uint256 _spendRatio) external onlyGovernance returns (bool) {
        require(
            _spendRatio <= ICvxLocker(CVX_LOCKER).maximumBoostPayment(),
            Error.EXCEEDS_MAX_BOOST
        );
        spendRatio = _spendRatio;
        emit NewSpendRatio(_spendRatio);
        return true;
    }

    /**
     * @notice Claim rewards from Convex.
     * @dev Rewards to claim are for staked cvxCRV and locked CVX.
     * @param lockAndStake If true, claimed reward tokens (CRV) will be locked and staked (CRV for cvxCRV and CVX for vlCVX).
     */
    function claimRewards(bool lockAndStake) external override returns (bool) {
        ICvxLocker(CVX_LOCKER).getReward(address(this), false);

        IRewardStaking(CVX_CRV_STAKING).getReward();

        if (lockAndStake) {
            lockRewards();
        }
        return true;
    }

    /**
     * @notice Stakes cvxCRV in the cvxCRV rewards contract on Convex.
     */
    function stakeCvxCrv() external override returns (bool) {
        return _stakeCvxCrv();
    }

    /**
     * @notice Prepares a withdrawal of funds.
     * @dev If this is set then no idle funds can get locked or staked.
     */
    function setWithdrawalFlag() external onlyGovernance {
        prepareWithdrawal = true;
    }

    /**
     * @notice Resets prepared withdrawal of funds.
     */
    function resetWithdrawalFlag() external onlyGovernance {
        prepareWithdrawal = false;
    }

    /**
     * @notice Processes exipred locks.
     */
    function processExpiredLocks(bool relock) external override returns (bool) {
        if (relock) {
            require(!prepareWithdrawal, Error.PREPARED_WITHDRAWAL);
        }

        if (relock) {
            ICvxLocker(CVX_LOCKER).processExpiredLocks(relock);
        } else {
            ICvxLocker(CVX_LOCKER).withdrawExpiredLocksTo(treasury);
        }

        return true;
    }

    /**
     * @notice Set treasury to receive withdrawn funds.
     */
    function setTreasury(address _treasury) external onlyGovernance returns (bool) {
        treasury = _treasury;
        emit NewTreasury(treasury);
        return true;
    }

    /**
     * @notice Withdraw full amount of a token to the treasury.
     * @param token Token to withdraw entire balance of.
     */
    function withdraw(address token) external onlyGovernance returns (bool) {
        uint256 balance = IERC20(token).balanceOf(address(this));
        IERC20(token).safeTransfer(treasury, balance);
        return true;
    }

    /**
     * @notice Withdraw cvxCRV to treasury.
     * @dev Unstakes cvxCRV if it is staked.
     */
    function withdrawCvxCrv(uint256 amount) external onlyGovernance {
        IRewardStaking(CVX_CRV_STAKING).withdraw(amount, true);
        uint256 cvxcrvBal = IERC20(CVX_CRV).balanceOf(address(this));
        if (cvxcrvBal > 0) {
            IERC20(CVX_CRV).safeTransfer(treasury, cvxcrvBal);
        }
    }

    function unstakeCvxCrv() external onlyGovernance {
        unstakeCvxCrv(false);
    }

    function unstakeCvxCrv(uint256 amount, bool withdrawal) external onlyGovernance {
        _unstakeCvxCrv(amount, withdrawal);
    }

    /**
     * @notice Set delegate to receive vote weight.
     */
    function setDelegate(address delegateContract, address delegate) external onlyGovernance {
        IDelegation(delegateContract).setDelegate(""cvx.eth"", delegate);
    }

    /**
     * @notice Clears a delegate for the msg.sender and a specific id.
     */
    function clearDelegate(address delegateContract) external onlyGovernance {
        IDelegation(delegateContract).clearDelegate(""cvx.eth"");
    }

    function forfeitRewards(address token, uint256 index) external onlyGovernance {
        IvlCvxExtraRewardDistribution(VL_CVX_EXTRA_REWARD_DISTRIBUTION).forfeitRewards(
            token,
            index
        );
    }

    /**
     * @notice Lock CRV and CVX tokens.
     * @dev CRV get locked for cvxCRV and staked on Convex.
     */
    function lockRewards() public returns (bool) {
        _lockCrv();
        _lockCvx();
        return true;
    }

    /**
     * @notice Withdraw an amount of a token to the treasury.
     * @param token Token to withdraw.
     * @param amount Amount of token to withdraw.
     */
    function withdraw(address token, uint256 amount) public onlyGovernance returns (bool) {
        IERC20(token).safeTransfer(treasury, amount);
        return true;
    }

    /**
     * @notice Unstake cvxCRV from Convex.
     */
    function unstakeCvxCrv(bool withdrawal) public onlyGovernance {
        uint256 staked = IRewardStaking(CVX_CRV_STAKING).balanceOf(address(this));
        _unstakeCvxCrv(staked, withdrawal);
    }

    function _lockCrv() internal {
        if (prepareWithdrawal) return;

        uint256 currentBalance = IERC20(CRV).balanceOf(address(this));
        if (currentBalance != 0) {
            // Checks if we can get a better rate on Curve Pool
            uint256 amountOut = ICurveSwap(CVX_CRV_CRV_CURVE_POOL).get_dy(
                _CRV_INDEX,
                _CVX_CRV_INDEX,
                currentBalance
            );
            if (amountOut > currentBalance) {
                ICurveSwap(CVX_CRV_CRV_CURVE_POOL).exchange(
                    _CRV_INDEX,
                    _CVX_CRV_INDEX,
                    currentBalance,
                    0
                );
            } else {
                // Swap CRV for cxvCRV and stake
                ICrvDepositor(CRV_DEPOSITOR).deposit(currentBalance, false, address(0));
            }
            IRewardStaking(CVX_CRV_STAKING).stakeAll();
            return;
        }

        if (IERC20(CVX_CRV).balanceOf(address(this)) > 0)
            IRewardStaking(CVX_CRV_STAKING).stakeAll();
    }

    function _lockCvx() internal {
        // Locks CVX for vlCVX
        if (prepareWithdrawal) return;
        uint256 currentBalance = IERC20(CVX).balanceOf(address(this));
        if (currentBalance == 0) return;
        ICvxLocker(CVX_LOCKER).lock(address(this), currentBalance, spendRatio);
    }

    function _stakeCvxCrv() internal returns (bool) {
        if (prepareWithdrawal) return false;

        if (IERC20(CVX_CRV).balanceOf(address(this)) == 0) return false;
        IRewardStaking(CVX_CRV_STAKING).stakeAll();
        return true;
    }

    function _unstakeCvxCrv(uint256 amount, bool withdrawal) internal {
        IRewardStaking(CVX_CRV_STAKING).withdraw(amount, true);
        if (withdrawal) {
            IERC20(CVX_CRV).safeTransfer(treasury, amount);
        }
    }
}",2583
RealWorld_BA_112_ILpGauge_RealWord_20240829205658.log,112,ILpGauge,4204,4362,8566,104.0,0.10826,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface ILpGauge {
    function poolCheckpoint() external returns (bool);

    function userCheckpoint(address user) external returns (bool);

    function claimableRewards(address beneficiary) external view returns (uint256);
}",68
RealWorld_BA_112_VaultStorage_RealWord_20240829195545.log,112,VaultStorage,6919,4572,11491,141.0,0.126035,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../libraries/EnumerableMapping.sol"";
import ""../../interfaces/IVaultReserve.sol"";
import ""../../interfaces/IStrategy.sol"";

contract VaultStorage {
    uint256 public currentAllocated;
    uint256 public waitingForRemovalAllocated;
    address public pool;

    uint256 public totalDebt;
    bool public strategyActive;

    EnumerableMapping.AddressToUintMap internal _strategiesWaitingForRemoval;
}

contract VaultStorageV1 is VaultStorage {
    /**
     * @dev This is to avoid breaking contracts inheriting from `VaultStorage`
     * such as `Erc20Vault`, especially if they have storage variables
     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
     * for more details
     *
     * A new field can be added using a new contract such as
     *
     * ```solidity
     * contract VaultStorageV2 is VaultStorage {
     *   uint256 someNewField;
     *   uint256[49] private __gap;
     * }
     */
    uint256[50] private __gap;
}",256
RealWorld_BA_112_InterestRateModel_RealWord_20240829213617.log,112,InterestRateModel,8598,5181,13779,87.0,0.14661,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

/**
 * @title Compound's InterestRateModel Interface
 * @author Compound
 */
abstract contract InterestRateModel {
    /// @notice Indicator that this is an InterestRateModel contract (for inspection)
    bool public constant isInterestRateModel = true;

    /**
     * @notice Calculates the current borrow interest rate per block
     * @param cash The total amount of cash the market has
     * @param borrows The total amount of borrows the market has outstanding
     * @param reserves The total amount of reserves the market has
     * @return The borrow rate per block (as a percentage, and scaled by 1e18)
     */
    function getBorrowRate(
        uint256 cash,
        uint256 borrows,
        uint256 reserves
    ) external view virtual returns (uint256);

    /**
     * @notice Calculates the current supply interest rate per block
     * @param cash The total amount of cash the market has
     * @param borrows The total amount of borrows the market has outstanding
     * @param reserves The total amount of reserves the market has
     * @param reserveFactorMantissa The current reserve factor the market has
     * @return The supply rate per block (as a percentage, and scaled by 1e18)
     */
    function getSupplyRate(
        uint256 cash,
        uint256 borrows,
        uint256 reserves,
        uint256 reserveFactorMantissa
    ) external view virtual returns (uint256);
}",329
RealWorld_BA_112_ConvexStrategyBase_RealWord_20240829181559.log,112,ConvexStrategyBase,68354,5955,74309,103.0,0.46087,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

// TODO Add validation of curve pools
// TODO Test validation

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""./IStrategySwapper.sol"";

import ""../utils/CvxMintAmount.sol"";

import ""../access/Authorization.sol"";

import ""../../libraries/ScaledMath.sol"";
import ""../../libraries/AddressProviderHelpers.sol"";
import ""../../libraries/EnumerableExtensions.sol"";

import ""../../interfaces/IStrategy.sol"";
import ""../../interfaces/vendor/IBooster.sol"";
import ""../../interfaces/vendor/IRewardStaking.sol"";
import ""../../interfaces/vendor/ICurveSwapEth.sol"";
import ""../../interfaces/vendor/ICurveRegistry.sol"";

abstract contract ConvexStrategyBase is IStrategy, Authorization, CvxMintAmount {
    using ScaledMath for uint256;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    IBooster internal constant _BOOSTER = IBooster(0xF403C135812408BFbE8713b5A23a04b3D48AAE31); // Convex Booster Contract
    IERC20 internal constant _CRV = IERC20(0xD533a949740bb3306d119CC777fa900bA034cd52); // CRV
    IERC20 internal constant _CVX = IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); // CVX
    IERC20 internal constant _WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH
    ICurveRegistry internal constant _CURVE_REGISTRY =
        ICurveRegistry(0x90E00ACe148ca3b23Ac1bC8C240C2a7Dd9c2d7f5); // Curve Registry Contract
    address internal constant _CURVE_ETH_ADDRESS =
        address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE); // Null Address used for Curve ETH pools

    IStrategySwapper internal immutable _strategySwapper;

    address internal _strategist; // The strategist for the strategy
    EnumerableSet.AddressSet internal _rewardTokens; // List of additional reward tokens when claiming rewards on Convex
    IERC20 public underlying; // Strategy Underlying
    bool public isShutdown; // If the strategy is shutdown, stops all deposits
    address public communityReserve; // Address for sending CVX & CRV Community Reserve share
    address public immutable vault; // Backd Vault
    uint256 public crvCommunityReserveShare; // Share of CRV sent to Community Reserve
    uint256 public cvxCommunityReserveShare; // Share of CVX sent to Community Reserve
    uint256 public imbalanceToleranceIn; // Maximum allowed slippage from Curve Pool Imbalance for depositing
    uint256 public imbalanceToleranceOut; // Maximum allowed slippage from Curve Pool Imbalance for withdrawing
    IRewardStaking public rewards; // Rewards Contract for claiming Convex Rewards
    IERC20 public lp; // Curve Pool LP Token
    ICurveSwapEth public curvePool; // Curve Pool
    uint256 public convexPid; // Index of Convex Pool in Booster Contract
    uint256 public curveIndex; // Underlying index in Curve Pool

    event Deposit(); // Emitted after a successfull deposit
    event Withdraw(uint256 amount); // Emitted after a successful withdrawal
    event WithdrawAll(uint256 amount); // Emitted after successfully withdrwaing all
    event Shutdown(); // Emitted after a successful shutdown
    event SetCommunityReserve(address reserve); // Emitted after a succuessful setting of reserve
    event SetCrvCommunityReserveShare(uint256 value); // Emitted after a succuessful setting of CRV Community Reserve Share
    event SetCvxCommunityReserveShare(uint256 value); // Emitted after a succuessful setting of CVX Community Reserve Share
    event SetImbalanceToleranceIn(uint256 value); // Emitted after a succuessful setting of imbalance tolerance in
    event SetImbalanceToleranceOut(uint256 value); // Emitted after a succuessful setting of imbalance tolerance out
    event SetStrategist(address strategist); // Emitted after a succuessful setting of strategist
    event AddRewardToken(address token); // Emitted after successfully adding a new reward token
    event RemoveRewardToken(address token); // Emitted after successfully removing a reward token
    event Harvest(uint256 amount); // Emitted after a successful harvest

    modifier onlyVault() {
        require(msg.sender == vault, Error.UNAUTHORIZED_ACCESS);
        _;
    }

    constructor(
        address vault_,
        address strategist_,
        uint256 convexPid_,
        address curvePool_,
        uint256 curveIndex_,
        IAddressProvider addressProvider_,
        address strategySwapper_
    ) Authorization(addressProvider_.getRoleManager()) {
        // Getting data from supporting contracts
        _validateCurvePool(curvePool_);
        (address lp_, , , address rewards_, , ) = _BOOSTER.poolInfo(convexPid_);
        lp = IERC20(lp_);
        rewards = IRewardStaking(rewards_);
        curvePool = ICurveSwapEth(curvePool_);
        address underlying_ = ICurveSwapEth(curvePool_).coins(curveIndex_);
        if (underlying_ == _CURVE_ETH_ADDRESS) underlying_ = address(0);
        underlying = IERC20(underlying_);

        // Setting inputs
        vault = vault_;
        _strategist = strategist_;
        convexPid = convexPid_;
        curveIndex = curveIndex_;
        _strategySwapper = IStrategySwapper(strategySwapper_);

        // Approvals
        _CRV.safeApprove(address(_strategySwapper), type(uint256).max);
        _CVX.safeApprove(address(_strategySwapper), type(uint256).max);
        _WETH.safeApprove(address(_strategySwapper), type(uint256).max);
    }

    /**
     * @notice Deposit all available underlying into Convex pool.
     * @return True if successful deposit.
     */
    function deposit() external payable override onlyVault returns (bool) {
        require(!isShutdown, Error.STRATEGY_SHUT_DOWN);
        if (!_deposit()) return false;
        emit Deposit();
        return true;
    }

    /**
     * @notice Withdraw an amount of underlying to the vault.
     * @dev This can only be called by the vault.
     *      If the amount is not available, it will be made liquid.
     * @param amount_ Amount of underlying to withdraw.
     * @return True if successful withdrawal.
     */
    function withdraw(uint256 amount_) external override onlyVault returns (bool) {
        if (amount_ == 0) return false;
        if (!_withdraw(amount_)) return false;
        emit Withdraw(amount_);
        return true;
    }

    /**
     * @notice Withdraw all underlying.
     * @dev This does not liquidate reward tokens and only considers
     *      idle underlying, idle lp tokens and staked lp tokens.
     * @return Amount of underlying withdrawn
     */
    function withdrawAll() external override returns (uint256) {
        require(
            msg.sender == vault || _roleManager().hasRole(Roles.GOVERNANCE, msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );
        uint256 amountWithdrawn_ = _withdrawAll();
        if (amountWithdrawn_ == 0) return 0;
        emit WithdrawAll(amountWithdrawn_);
        return amountWithdrawn_;
    }

    /**
     * @notice Harvests reward tokens and sells these for the underlying.
     * @dev Any underlying harvested is not redeposited by this method.
     * @return Amount of underlying harvested.
     */
    function harvest() external override onlyVault returns (uint256) {
        return _harvest();
    }

    /**
     * @notice Shuts down the strategy, disabling deposits.
     * @return True if reserve was successfully set.
     */
    function shutdown() external override onlyVault returns (bool) {
        if (isShutdown) return false;
        isShutdown = true;
        emit Shutdown();
        return true;
    }

    /**
     * @notice Set the address of the communit reserve.
     * @dev CRV & CVX will be taxed and allocated to the reserve,
     *      such that Backd can participate in governance.
     * @param _communityReserve Address of the community reserve.
     * @return True if successfully set.
     */
    function setCommunityReserve(address _communityReserve) external onlyGovernance returns (bool) {
        communityReserve = _communityReserve;
        emit SetCommunityReserve(_communityReserve);
        return true;
    }

    /**
     * @notice Set the share of CRV to send to the Community Reserve.
     * @param crvCommunityReserveShare_ New fee charged on CRV rewards for governance.
     * @return True if successfully set.
     */
    function setCrvCommunityReserveShare(uint256 crvCommunityReserveShare_)
        external
        onlyGovernance
        returns (bool)
    {
        require(crvCommunityReserveShare_ <= ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(communityReserve != address(0), ""Community reserve must be set"");
        crvCommunityReserveShare = crvCommunityReserveShare_;
        emit SetCrvCommunityReserveShare(crvCommunityReserveShare_);
        return true;
    }

    /**
     * @notice Set the share of CVX to send to the Community Reserve.
     * @param cvxCommunityReserveShare_ New fee charged on CVX rewards for governance.
     * @return True if successfully set.
     */
    function setCvxCommunityReserveShare(uint256 cvxCommunityReserveShare_)
        external
        onlyGovernance
        returns (bool)
    {
        require(cvxCommunityReserveShare_ <= ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(communityReserve != address(0), ""Community reserve must be set"");
        cvxCommunityReserveShare = cvxCommunityReserveShare_;
        emit SetCvxCommunityReserveShare(cvxCommunityReserveShare_);
        return true;
    }

    /**
     * @notice Set imbalance tolerance for Curve Pool deposits.
     * @dev Stored as a percent, e.g. 1% would be set as 0.01
     * @param imbalanceToleranceIn_ New imbalance tolarance in.
     * @return True if successfully set.
     */
    function setImbalanceToleranceIn(uint256 imbalanceToleranceIn_)
        external
        onlyGovernance
        returns (bool)
    {
        imbalanceToleranceIn = imbalanceToleranceIn_;
        emit SetImbalanceToleranceIn(imbalanceToleranceIn_);
        return true;
    }

    /**
     * @notice Set imbalance tolerance for Curve Pool withdrawals.
     * @dev Stored as a percent, e.g. 1% would be set as 0.01
     * @param imbalanceToleranceOut_ New imbalance tolarance out.
     * @return True if successfully set.
     */
    function setImbalanceToleranceOut(uint256 imbalanceToleranceOut_)
        external
        onlyGovernance
        returns (bool)
    {
        imbalanceToleranceOut = imbalanceToleranceOut_;
        emit SetImbalanceToleranceOut(imbalanceToleranceOut_);
        return true;
    }

    /**
     * @notice Set strategist.
     * @dev Can only be set by current strategist.
     * @param strategist_ Address of new strategist.
     * @return True if successfully set.
     */
    function setStrategist(address strategist_) external returns (bool) {
        require(msg.sender == _strategist, Error.UNAUTHORIZED_ACCESS);
        _strategist = strategist_;
        emit SetStrategist(strategist_);
        return true;
    }

    /**
     * @notice Add a reward token to list of extra reward tokens.
     * @dev These are tokens that are not the main assets of the strategy. For instance, temporary incentives.
     * @param token_ Address of token to add to reward token list.
     * @return True if successfully added.
     */
    function addRewardToken(address token_) external onlyGovernance returns (bool) {
        require(
            token_ != address(_CVX) && token_ != address(underlying) && token_ != address(_CRV),
            Error.INVALID_TOKEN_TO_ADD
        );
        if (_rewardTokens.contains(token_)) return false;
        _rewardTokens.add(token_);
        IERC20(token_).safeApprove(address(_strategySwapper), 0);
        IERC20(token_).safeApprove(address(_strategySwapper), type(uint256).max);
        emit AddRewardToken(token_);
        return true;
    }

    /**
     * @notice Remove a reward token.
     * @param token_ Address of token to remove from reward token list.
     * @return True if successfully removed.
     */
    function removeRewardToken(address token_) external onlyGovernance returns (bool) {
        if (!_rewardTokens.remove(token_)) return false;
        emit RemoveRewardToken(token_);
        return true;
    }

    /**
     * @notice Amount of rewards that can be harvested in the underlying.
     * @dev Includes rewards for CRV, CVX & Extra Rewards.
     * @return Estimated amount of underlying available to harvest.
     */
    function harvestable() external view override returns (uint256) {
        IRewardStaking rewards_ = rewards;
        uint256 crvAmount_ = rewards_.earned(address(this));
        if (crvAmount_ == 0) return 0;
        uint256 harvestable_ = _underlyingAmountOut(
            address(_CRV),
            crvAmount_.scaledMul(ScaledMath.ONE - crvCommunityReserveShare)
        ) +
            _underlyingAmountOut(
                address(_CVX),
                getCvxMintAmount(crvAmount_).scaledMul(ScaledMath.ONE - cvxCommunityReserveShare)
            );
        for (uint256 i = 0; i < _rewardTokens.length(); i++) {
            IRewardStaking extraRewards_ = IRewardStaking(rewards_.extraRewards(i));
            address rewardToken_ = extraRewards_.rewardToken();
            if (!_rewardTokens.contains(rewardToken_)) continue;
            harvestable_ += _underlyingAmountOut(rewardToken_, extraRewards_.earned(address(this)));
        }
        return harvestable_;
    }

    /**
     * @notice Returns the address of the strategist.
     * @return The the address of the strategist.
     */
    function strategist() external view override returns (address) {
        return _strategist;
    }

    /**
     * @notice Returns the list of reward tokens supported by the strategy.
     * @return The list of reward tokens supported by the strategy.
     */
    function rewardTokens() external view returns (address[] memory) {
        return _rewardTokens.toArray();
    }

    /**
     * @notice Get the total underlying balance of the strategy.
     * @return Underlying balance of strategy.
     */
    function balance() external view virtual override returns (uint256);

    /**
     * @notice Returns the name of the strategy.
     * @return The name of the strategy.
     */
    function name() external view virtual override returns (string memory);

    /**
     * @dev Contract does not stash tokens.
     */
    function hasPendingFunds() external pure override returns (bool) {
        return false;
    }

    function _deposit() internal virtual returns (bool);

    function _withdraw(uint256 amount_) internal virtual returns (bool);

    function _withdrawAll() internal virtual returns (uint256);

    function _harvest() internal returns (uint256) {
        uint256 initialBalance_ = _underlyingBalance();

        // Claim Convex rewards
        rewards.getReward();

        // Sending share to Community Reserve
        _sendCommunityReserveShare();

        // Swap CVX for WETH
        IStrategySwapper strategySwapper_ = _strategySwapper;
        strategySwapper_.swapAllForWeth(address(_CVX));

        // Swap CRV for WETH
        strategySwapper_.swapAllForWeth(address(_CRV));

        // Swap Extra Rewards for WETH
        for (uint256 i = 0; i < _rewardTokens.length(); i++) {
            strategySwapper_.swapAllForWeth(_rewardTokens.at(i));
        }

        // Swap WETH for underlying
        strategySwapper_.swapAllWethForToken(address(underlying));

        uint256 harvested_ = _underlyingBalance() - initialBalance_;
        emit Harvest(harvested_);
        return harvested_;
    }

    /**
     * @notice Sends a share of the current balance of CRV and CVX to the Community Reserve.
     */
    function _sendCommunityReserveShare() internal {
        address communityReserve_ = communityReserve;
        if (communityReserve_ == address(0)) return;
        uint256 cvxCommunityReserveShare_ = cvxCommunityReserveShare;
        if (cvxCommunityReserveShare_ > 0) {
            IERC20 cvx_ = _CVX;
            uint256 cvxBalance_ = cvx_.balanceOf(address(this));
            if (cvxBalance_ > 0) {
                cvx_.safeTransfer(
                    communityReserve_,
                    cvxBalance_.scaledMul(cvxCommunityReserveShare_)
                );
            }
        }
        uint256 crvCommunityReserveShare_ = crvCommunityReserveShare;
        if (crvCommunityReserveShare_ > 0) {
            IERC20 crv_ = _CRV;
            uint256 crvBalance_ = crv_.balanceOf(address(this));
            if (crvBalance_ > 0) {
                crv_.safeTransfer(
                    communityReserve_,
                    crvBalance_.scaledMul(crvCommunityReserveShare_)
                );
            }
        }
    }

    /**
     * @dev Get the balance of the underlying.
     */
    function _underlyingBalance() internal view virtual returns (uint256);

    /**
     * @dev Get the balance of the lp.
     */
    function _lpBalance() internal view returns (uint256) {
        return lp.balanceOf(address(this));
    }

    /**
     * @dev Get the balance of the underlying staked in the Curve pool.
     */
    function _stakedBalance() internal view returns (uint256) {
        return rewards.balanceOf(address(this));
    }

    function _underlyingAmountOut(address token_, uint256 amount_) internal view returns (uint256) {
        return _strategySwapper.amountOut(token_, address(underlying), amount_);
    }

    /**
     * @dev Reverts if it is not a valid Curve Pool.
     */
    function _validateCurvePool(address curvePool_) internal view {
        _CURVE_REGISTRY.get_A(curvePool_);
    }
}",4120
RealWorld_BA_112_MockKeeperGauge_RealWord_20240829190002.log,112,MockKeeperGauge,4705,4687,9392,80.0,0.117265,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../Controller.sol"";
import ""../tokenomics/KeeperGauge.sol"";

contract MockKeeperGauge is KeeperGauge {
    constructor(IController _controller, address _pool) KeeperGauge(_controller, _pool) {}

    function advanceEpoch() external override returns (bool) {
        return true;
    }
}",88
RealWorld_BA_112_MockAmmGauge_RealWord_20240829190256.log,112,MockAmmGauge,5980,4996,10976,83.0,0.12982,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../Controller.sol"";
import ""../tokenomics/AmmGauge.sol"";

contract MockAmmGauge is AmmGauge {
    constructor(IController _controller, address _ammToken) AmmGauge(_controller, _ammToken) {}

    function stake(uint256) external override returns (bool) {
        return true;
    }

    function unstake(uint256) external override returns (bool) {
        return true;
    }

    // solhint-disable-next-line no-unused-vars
    function claimableRewards(address user) external view override returns (uint256) {
        return 0;
    }

    function claimRewards(address) external pure override returns (uint256) {
        return 0;
    }

    function poolCheckpoint() public pure override returns (bool) {
        return true;
    }
}",192
RealWorld_BA_112_TopUpAction_RealWord_20240829192130.log,112,TopUpAction,129918,3166,133084,75.0,0.71291,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/IGasBank.sol"";
import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/ISwapperRegistry.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/IStakerVault.sol"";
import ""../../../interfaces/ISwapper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/IActionFeeHandler.sol"";

import ""../../../libraries/AddressProviderHelpers.sol"";
import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/EnumerableExtensions.sol"";

import ""../../access/Authorization.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being ""too deep""
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";
    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                ""topUp(bytes32,address,uint256,bytes)"",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new ""balance"" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}",8074
RealWorld_BA_112_AaveHandler_RealWord_20240829192417.log,112,AaveHandler,12269,5559,17828,84.0,0.172525,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""../../../../libraries/Errors.sol"";
import ""../../../../libraries/AccountEncoding.sol"";

import ""../../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../../interfaces/vendor/ILendingPool.sol"";
import ""../../../../interfaces/vendor/IWETH.sol"";
import ""../../../../libraries/vendor/DataTypes.sol"";

contract AaveHandler is ITopUpHandler {
    using SafeERC20 for IERC20;
    using AccountEncoding for bytes32;

    uint16 public constant BACKD_REFERRAL_CODE = 62314;

    ILendingPool public immutable lendingPool;
    IWETH public immutable weth;

    constructor(address lendingPoolAddress, address wethAddress) {
        lendingPool = ILendingPool(lendingPoolAddress);
        weth = IWETH(wethAddress);
    }

    /**
     * @notice Executes the top-up of a position.
     * @param account Account holding the position.
     * @param underlying Underlying for tup-up.
     * @param amount Amount to top-up by.
     * @return `true` if successful.
     */
    function topUp(
        bytes32 account,
        address underlying,
        uint256 amount,
        bytes memory extra
    ) external override returns (bool) {
        bool repayDebt = abi.decode(extra, (bool));
        if (underlying == address(0)) {
            weth.deposit{value: amount}();
            underlying = address(weth);
        }

        address addr = account.addr();

        DataTypes.ReserveData memory reserve = lendingPool.getReserveData(underlying);
        require(reserve.aTokenAddress != address(0), Error.UNDERLYING_NOT_SUPPORTED);

        IERC20(underlying).safeApprove(address(lendingPool), amount);

        if (repayDebt) {
            uint256 stableDebt = IERC20(reserve.stableDebtTokenAddress).balanceOf(addr);
            uint256 variableDebt = IERC20(reserve.variableDebtTokenAddress).balanceOf(addr);
            if (variableDebt + stableDebt > 0) {
                uint256 rateMode = stableDebt > variableDebt ? 1 : 2;
                amount -= lendingPool.repay(underlying, amount, rateMode, addr);
                if (amount == 0) return true;
            }
        }

        lendingPool.deposit(underlying, amount, addr, BACKD_REFERRAL_CODE);
        return true;
    }

    function getUserFactor(bytes32 account, bytes memory) external view override returns (uint256) {
        (, , , , , uint256 healthFactor) = lendingPool.getUserAccountData(account.addr());
        return healthFactor;
    }
}",606
RealWorld_BA_112_IBkdLocker_RealWord_20240829203854.log,112,IBkdLocker,10318,5480,15798,90.0,0.16119,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface IBkdLocker {
    struct WithdrawStash {
        uint256 releaseTime;
        uint256 amount;
    }

    struct RewardTokenData {
        mapping(address => uint256) userFeeIntegrals;
        mapping(address => uint256) userShares;
        uint256 feeBalance;
        uint256 feeIntegral;
    }

    event Locked(address indexed user, uint256 amount);
    event WithdrawPrepared(address indexed user, uint256 amount);
    event WithdrawExecuted(address indexed user, uint256 amount);
    event RewardsClaimed(address indexed user, address indexed rewardToken, uint256 amount);
    event FeesDeposited(uint256 amount);

    function initialize(
        uint256 startBoost,
        uint256 maxBoost,
        uint256 increasePeriod,
        uint256 withdrawDelay
    ) external;

    function migrate(address newRewardToken) external;

    function lock(uint256 amount) external;

    function lockFor(address user, uint256 amount) external;

    function userCheckpoint(address user) external;

    function claimFees() external;

    function claimFees(address _rewardToken) external;

    function prepareUnlock(uint256 amount) external;

    function executeUnlocks() external;

    function getUserShare(address user) external view returns (uint256);

    function getUserShare(address user, address _rewardToken) external view returns (uint256);

    function getStashedGovTokens(address user) external view returns (WithdrawStash[] memory);

    function claimableFees(address user) external view returns (uint256);

    function claimableFees(address user, address _rewardToken) external view returns (uint256);

    function boostedBalance(address user) external view returns (uint256);

    function balanceOf(address user) external view returns (uint256);

    function getShareOfTotalBoostedBalance(address user) external view returns (uint256);

    function computeNewBoost(
        address user,
        uint256 amountAdded,
        uint256 newTotal
    ) external view returns (uint256);
}",430
RealWorld_BA_112_EthPool_RealWord_20240829194230.log,112,EthPool,7713,4751,12464,87.0,0.133585,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./LiquidityPool.sol"";
import ""../../interfaces/pool/IEthPool.sol"";

contract EthPool is LiquidityPool, IEthPool {
    constructor(IController _controller) LiquidityPool(_controller) {}

    receive() external payable {}

    function initialize(
        string memory name_,
        uint256 depositCap_,
        address vault_
    ) external override returns (bool) {
        return _initialize(name_, depositCap_, vault_);
    }

    function getUnderlying() public pure override returns (address) {
        return address(0);
    }

    function _doTransferIn(address from, uint256 amount) internal override {
        require(msg.sender == from, Error.INVALID_SENDER);
        require(msg.value == amount, Error.INVALID_AMOUNT);
    }

    function _doTransferOut(address payable to, uint256 amount) internal override {
        to.transfer(amount);
    }

    function _getBalanceUnderlying() internal view override returns (uint256) {
        return _getBalanceUnderlying(false);
    }

    function _getBalanceUnderlying(bool transferInDone) internal view override returns (uint256) {
        uint256 balance = address(this).balance;
        if (!transferInDone) {
            balance -= msg.value;
        }
        return balance;
    }
}",284
RealWorld_BA_112_LpToken_RealWord_20240829175924.log,112,LpToken,12603,5409,18012,95.0,0.171195,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""../libraries/ScaledMath.sol"";
import ""../interfaces/ILpToken.sol"";
import ""../interfaces/pool/ILiquidityPool.sol"";
import ""../libraries/Errors.sol"";

contract LpToken is ILpToken, ERC20Upgradeable {
    using ScaledMath for uint256;

    uint8 private _decimals;

    address public override minter;

    /**
     * @notice Make a function only callable by the minter contract.
     * @dev Fails if msg.sender is not the minter.
     */
    modifier onlyMinter() {
        require(msg.sender == minter, Error.UNAUTHORIZED_ACCESS);
        _;
    }

    constructor() ERC20Upgradeable() {}

    function initialize(
        string memory name_,
        string memory symbol_,
        uint8 decimals_,
        address _minter
    ) external override initializer returns (bool) {
        require(_minter != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        __ERC20_init(name_, symbol_);
        _decimals = decimals_;
        minter = _minter;
        return true;
    }

    /**
     * @notice Mint tokens.
     * @param account Account from which tokens should be burned.
     * @param amount Amount of tokens to mint.
     */
    function mint(address account, uint256 amount) external override onlyMinter {
        _mint(account, amount);
    }

    /**
     * @notice Burns tokens of msg.sender.
     * @param amount Amount of tokens to burn.
     */
    function burn(uint256 amount) external override {
        _burn(msg.sender, amount);
    }

    /**
     * @notice Burn tokens.
     * @param owner Account from which tokens should be burned.
     * @param burnAmount Amount of tokens to burn.
     * @return Aamount of tokens burned.
     */
    function burn(address owner, uint256 burnAmount)
        external
        override
        onlyMinter
        returns (uint256)
    {
        _burn(owner, burnAmount);
        return burnAmount;
    }

    function decimals() public view virtual override returns (uint8) {
        return _decimals;
    }

    /**
     * @dev We notify that LP tokens have been transfered
     * this is currently used to keep track of the withdrawal fees
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if (amount > 0) ILiquidityPool(minter).handleLpTokenTransfer(from, to, amount); // add check to not break 0 transfers
    }
}",582
RealWorld_BA_112_MockErc20Pool_RealWord_20240829184925.log,112,MockErc20Pool,10193,5329,15522,95.0,0.157545,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../interfaces/IStakerVault.sol"";
import ""../../interfaces/IVault.sol"";

import ""../pool/Erc20Pool.sol"";

contract MockErc20Pool is Erc20Pool {
    uint256 public currentTime;

    constructor(IController _controller) Erc20Pool(_controller) {}

    function setMinWithdrawalFee(uint256 _newFee) external onlyGovernance returns (bool) {
        _setConfig(_MIN_WITHDRAWAL_FEE_KEY, _newFee);
        return true;
    }

    function setMaxWithdrawalFee(uint256 _newFee) external onlyGovernance returns (bool) {
        _setConfig(_MAX_WITHDRAWAL_FEE_KEY, _newFee);
        return true;
    }

    function setWithdrawalFeeDecreasePeriod(uint256 period) external onlyGovernance returns (bool) {
        _setConfig(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY, period);
        return true;
    }

    function setVault(address payable _vault) external {
        setVault(_vault, true);
    }

    function setMaxBackingReserveDeviationRatio(uint256 newRatio) external onlyGovernance {
        _setConfig(_RESERVE_DEVIATION_KEY, newRatio);
        _rebalanceVault();
    }

    function setRequiredBackingReserveRatio(uint256 newRatio) external onlyGovernance {
        _setConfig(_REQUIRED_RESERVES_KEY, newRatio);
        _rebalanceVault();
    }

    function setTime(uint256 _currentTime) external {
        currentTime = _currentTime;
    }

    function setVault(address payable _vault, bool updateAddressProvider) public onlyGovernance {
        if (updateAddressProvider) {
            addressProvider.updateVault(currentAddresses[_VAULT_KEY], _vault);
        }
        _setConfig(_VAULT_KEY, _vault);
    }

    function _getTime() internal view override returns (uint256) {
        return currentTime == 0 ? block.timestamp : currentTime;
    }
}",426
RealWorld_BA_112_ErrorReporter_RealWord_20240829213000.log,112,ErrorReporter,32922,5086,38008,95.0,0.26633,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

contract ComptrollerErrorReporter {
    enum Error {
        NO_ERROR,
        UNAUTHORIZED,
        COMPTROLLER_MISMATCH,
        INSUFFICIENT_SHORTFALL,
        INSUFFICIENT_LIQUIDITY,
        INVALID_CLOSE_FACTOR,
        INVALID_COLLATERAL_FACTOR,
        INVALID_LIQUIDATION_INCENTIVE,
        MARKET_NOT_ENTERED, // no longer possible
        MARKET_NOT_LISTED,
        MARKET_ALREADY_LISTED,
        MATH_ERROR,
        NONZERO_BORROW_BALANCE,
        PRICE_ERROR,
        REJECTION,
        SNAPSHOT_ERROR,
        TOO_MANY_ASSETS,
        TOO_MUCH_REPAY
    }

    enum FailureInfo {
        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,
        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,
        EXIT_MARKET_BALANCE_OWED,
        EXIT_MARKET_REJECTION,
        SET_CLOSE_FACTOR_OWNER_CHECK,
        SET_CLOSE_FACTOR_VALIDATION,
        SET_COLLATERAL_FACTOR_OWNER_CHECK,
        SET_COLLATERAL_FACTOR_NO_EXISTS,
        SET_COLLATERAL_FACTOR_VALIDATION,
        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,
        SET_IMPLEMENTATION_OWNER_CHECK,
        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,
        SET_LIQUIDATION_INCENTIVE_VALIDATION,
        SET_MAX_ASSETS_OWNER_CHECK,
        SET_PENDING_ADMIN_OWNER_CHECK,
        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,
        SET_PRICE_ORACLE_OWNER_CHECK,
        SUPPORT_MARKET_EXISTS,
        SUPPORT_MARKET_OWNER_CHECK,
        SET_PAUSE_GUARDIAN_OWNER_CHECK
    }

    /**
     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary
     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.
     **/
    event Failure(uint256 error, uint256 info, uint256 detail);

    /**
     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator
     */
    function fail(Error err, FailureInfo info) internal returns (uint256) {
        emit Failure(uint256(err), uint256(info), 0);

        return uint256(err);
    }

    /**
     * @dev use this when reporting an opaque error from an upgradeable collaborator contract
     */
    function failOpaque(
        Error err,
        FailureInfo info,
        uint256 opaqueError
    ) internal returns (uint256) {
        emit Failure(uint256(err), uint256(info), opaqueError);

        return uint256(err);
    }
}

contract TokenErrorReporter {
    enum Error {
        NO_ERROR,
        UNAUTHORIZED,
        BAD_INPUT,
        COMPTROLLER_REJECTION,
        COMPTROLLER_CALCULATION_ERROR,
        INTEREST_RATE_MODEL_ERROR,
        INVALID_ACCOUNT_PAIR,
        INVALID_CLOSE_AMOUNT_REQUESTED,
        INVALID_COLLATERAL_FACTOR,
        MATH_ERROR,
        MARKET_NOT_FRESH,
        MARKET_NOT_LISTED,
        TOKEN_INSUFFICIENT_ALLOWANCE,
        TOKEN_INSUFFICIENT_BALANCE,
        TOKEN_INSUFFICIENT_CASH,
        TOKEN_TRANSFER_IN_FAILED,
        TOKEN_TRANSFER_OUT_FAILED
    }

    /*
     * Note: FailureInfo (but not Error) is kept in alphabetical order
     *       This is because FailureInfo grows significantly faster, and
     *       the order of Error has some meaning, while the order of FailureInfo
     *       is entirely arbitrary.
     */
    enum FailureInfo {
        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,
        ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,
        ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,
        ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,
        ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,
        ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,
        ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,
        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,
        BORROW_ACCRUE_INTEREST_FAILED,
        BORROW_CASH_NOT_AVAILABLE,
        BORROW_FRESHNESS_CHECK,
        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,
        BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,
        BORROW_MARKET_NOT_LISTED,
        BORROW_COMPTROLLER_REJECTION,
        LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,
        LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,
        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,
        LIQUIDATE_COMPTROLLER_REJECTION,
        LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,
        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,
        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,
        LIQUIDATE_FRESHNESS_CHECK,
        LIQUIDATE_LIQUIDATOR_IS_BORROWER,
        LIQUIDATE_REPAY_BORROW_FRESH_FAILED,
        LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,
        LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,
        LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,
        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,
        LIQUIDATE_SEIZE_TOO_MUCH,
        MINT_ACCRUE_INTEREST_FAILED,
        MINT_COMPTROLLER_REJECTION,
        MINT_EXCHANGE_CALCULATION_FAILED,
        MINT_EXCHANGE_RATE_READ_FAILED,
        MINT_FRESHNESS_CHECK,
        MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,
        MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,
        MINT_TRANSFER_IN_FAILED,
        MINT_TRANSFER_IN_NOT_POSSIBLE,
        REDEEM_ACCRUE_INTEREST_FAILED,
        REDEEM_COMPTROLLER_REJECTION,
        REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,
        REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,
        REDEEM_EXCHANGE_RATE_READ_FAILED,
        REDEEM_FRESHNESS_CHECK,
        REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,
        REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,
        REDEEM_TRANSFER_OUT_NOT_POSSIBLE,
        REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,
        REDUCE_RESERVES_ADMIN_CHECK,
        REDUCE_RESERVES_CASH_NOT_AVAILABLE,
        REDUCE_RESERVES_FRESH_CHECK,
        REDUCE_RESERVES_VALIDATION,
        REPAY_BEHALF_ACCRUE_INTEREST_FAILED,
        REPAY_BORROW_ACCRUE_INTEREST_FAILED,
        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,
        REPAY_BORROW_COMPTROLLER_REJECTION,
        REPAY_BORROW_FRESHNESS_CHECK,
        REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,
        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,
        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,
        SET_COLLATERAL_FACTOR_OWNER_CHECK,
        SET_COLLATERAL_FACTOR_VALIDATION,
        SET_COMPTROLLER_OWNER_CHECK,
        SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,
        SET_INTEREST_RATE_MODEL_FRESH_CHECK,
        SET_INTEREST_RATE_MODEL_OWNER_CHECK,
        SET_MAX_ASSETS_OWNER_CHECK,
        SET_ORACLE_MARKET_NOT_LISTED,
        SET_PENDING_ADMIN_OWNER_CHECK,
        SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,
        SET_RESERVE_FACTOR_ADMIN_CHECK,
        SET_RESERVE_FACTOR_FRESH_CHECK,
        SET_RESERVE_FACTOR_BOUNDS_CHECK,
        TRANSFER_COMPTROLLER_REJECTION,
        TRANSFER_NOT_ALLOWED,
        TRANSFER_NOT_ENOUGH,
        TRANSFER_TOO_MUCH,
        ADD_RESERVES_ACCRUE_INTEREST_FAILED,
        ADD_RESERVES_FRESH_CHECK,
        ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE
    }

    /**
     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary
     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.
     **/
    event Failure(uint256 error, uint256 info, uint256 detail);

    /**
     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator
     */
    function fail(Error err, FailureInfo info) internal returns (uint256) {
        emit Failure(uint256(err), uint256(info), 0);

        return uint256(err);
    }

    /**
     * @dev use this when reporting an opaque error from an upgradeable collaborator contract
     */
    function failOpaque(
        Error err,
        FailureInfo info,
        uint256 opaqueError
    ) internal returns (uint256) {
        emit Failure(uint256(err), uint256(info), opaqueError);

        return uint256(err);
    }
}",1836
RealWorld_BA_112_ICrvDepositor_RealWord_20240829211156.log,112,ICrvDepositor,4159,4328,8487,80.0,0.107355,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface ICrvDepositor {
    function deposit(
        uint256 _amount,
        bool _lock,
        address _stakeAddress
    ) external;

    function depositAll(bool _lock, address _stakeAddress) external;
}",68
RealWorld_BA_112_IKeeperGauge_RealWord_20240829210316.log,112,IKeeperGauge,4970,4624,9594,77.0,0.11733,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;
import ""./IRewardsGauge.sol"";

interface IKeeperGauge is IRewardsGauge {
    function reportFees(
        address beneficiary,
        uint256 amount,
        address lpTokenAddress
    ) external returns (bool);

    function advanceEpoch() external returns (bool);

    function poolCheckpoint() external returns (bool);

    function kill() external returns (bool);

    function killed() external view returns (bool);

    function claimableRewards(address beneficiary) external view returns (uint256);
}",128
RealWorld_BA_112_IPreparable_RealWord_20240829203309.log,112,IPreparable,4842,4115,8957,71.0,0.10651,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IPreparable {
    event ConfigPreparedAddress(bytes32 indexed key, address value, uint256 delay);
    event ConfigPreparedNumber(bytes32 indexed key, uint256 value, uint256 delay);

    event ConfigUpdatedAddress(bytes32 indexed key, address oldValue, address newValue);
    event ConfigUpdatedNumber(bytes32 indexed key, uint256 oldValue, uint256 newValue);

    event ConfigReset(bytes32 indexed key);
}",109
RealWorld_BA_112_VestedEscrowRevocable_RealWord_20240829192828.log,112,VestedEscrowRevocable,16040,5869,21909,89.0,0.19758,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

/*
Rewrite of Convex Finance's Vested Escrow
found at https://github.com/convex-eth/platform/blob/main/contracts/contracts/VestedEscrow.sol
Changes:
- remove safe math (default from Solidity >=0.8)
- remove claim and stake logic
- remove safeTransferFrom logic and add support for ""airdropped"" reward token
- add revoke logic to allow admin to stop vesting for a recipient
*/

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

import ""../../libraries/Errors.sol"";

import ""./VestedEscrow.sol"";

contract VestedEscrowRevocable is VestedEscrow {
    using SafeERC20 for IERC20;

    address public immutable treasury;

    uint256 private _vestedBefore;

    mapping(address => uint256) public revokedTime;

    event Revoked(address indexed user, uint256 revokedAmount);

    constructor(
        address rewardToken_,
        uint256 starttime_,
        uint256 endtime_,
        address fundAdmin_,
        address treasury_
    ) VestedEscrow(rewardToken_, starttime_, endtime_, fundAdmin_) {
        treasury = treasury_;
        holdingContract[treasury_] = address(new EscrowTokenHolder(rewardToken_));
    }

    function claim() external override {
        claim(msg.sender);
    }

    function revoke(address _recipient) external returns (bool) {
        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);
        require(revokedTime[_recipient] == 0, ""Recipient already revoked"");
        require(_recipient != treasury, ""Treasury cannot be revoked!"");
        revokedTime[_recipient] = block.timestamp;
        uint256 vested = _totalVestedOf(_recipient, block.timestamp);

        uint256 initialAmount = initialLocked[_recipient];
        uint256 revokedAmount = initialAmount - vested;
        rewardToken.safeTransferFrom(
            holdingContract[_recipient],
            holdingContract[treasury],
            revokedAmount
        );
        initialLocked[treasury] += initialAmount;
        totalClaimed[treasury] += vested;
        _vestedBefore += vested;
        emit Revoked(_recipient, revokedAmount);
        return true;
    }

    function vestedOf(address _recipient) external view override returns (uint256) {
        if (_recipient == treasury) {
            return _totalVestedOf(_recipient, block.timestamp) - _vestedBefore;
        }

        uint256 timeRevoked = revokedTime[_recipient];
        if (timeRevoked != 0) {
            return _totalVestedOf(_recipient, timeRevoked);
        }
        return _totalVestedOf(_recipient, block.timestamp);
    }

    function balanceOf(address _recipient) external view override returns (uint256) {
        uint256 timestamp = block.timestamp;
        uint256 timeRevoked = revokedTime[_recipient];
        if (timeRevoked != 0) {
            timestamp = timeRevoked;
        }
        return _balanceOf(_recipient, timestamp);
    }

    function lockedOf(address _recipient) external view override returns (uint256) {
        if (revokedTime[_recipient] != 0) {
            return 0;
        }
        uint256 vested = _totalVestedOf(_recipient, block.timestamp);
        return initialLocked[_recipient] - vested;
    }

    function claim(address _recipient) public override nonReentrant {
        uint256 timestamp = block.timestamp;
        if (revokedTime[msg.sender] != 0) {
            timestamp = revokedTime[msg.sender];
        }
        _claimUntil(_recipient, timestamp);
    }
}",805
RealWorld_BA_112_IStrategy_RealWord_20240829202855.log,112,IStrategy,5256,4770,10026,76.0,0.12168,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IStrategy {
    function name() external view returns (string memory);

    function deposit() external payable returns (bool);

    function balance() external view returns (uint256);

    function withdraw(uint256 amount) external returns (bool);

    function withdrawAll() external returns (uint256);

    function harvestable() external view returns (uint256);

    function harvest() external returns (uint256);

    function strategist() external view returns (address);

    function shutdown() external returns (bool);

    function hasPendingFunds() external view returns (bool);
}",137
RealWorld_BA_112_IBkdToken_RealWord_20240829210148.log,112,IBkdToken,4365,4957,9322,85.0,0.120965,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IBkdToken is IERC20 {
    function mint(address account, uint256 amount) external;
}",62
RealWorld_BA_112_Erc20Pool_RealWord_20240829194359.log,112,Erc20Pool,8065,5428,13493,97.0,0.148885,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./LiquidityPool.sol"";
import ""../../interfaces/pool/IErc20Pool.sol"";

contract Erc20Pool is LiquidityPool, IErc20Pool {
    using SafeERC20 for IERC20;

    address private _underlying;

    constructor(IController _controller) LiquidityPool(_controller) {}

    function initialize(
        string memory name_,
        address underlying_,
        uint256 depositCap_,
        address vault_
    ) public override returns (bool) {
        require(underlying_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        _underlying = underlying_;
        return _initialize(name_, depositCap_, vault_);
    }

    function getUnderlying() public view override returns (address) {
        return _underlying;
    }

    function _doTransferIn(address from, uint256 amount) internal override {
        require(msg.value == 0, Error.INVALID_VALUE);
        IERC20(_underlying).safeTransferFrom(from, address(this), amount);
    }

    function _doTransferOut(address payable to, uint256 amount) internal override {
        IERC20(_underlying).safeTransfer(to, amount);
    }

    function _getBalanceUnderlying() internal view override returns (uint256) {
        return IERC20(_underlying).balanceOf(address(this));
    }

    function _getBalanceUnderlying(bool) internal view override returns (uint256) {
        return _getBalanceUnderlying();
    }
}",323
RealWorld_BA_112_IDelegation_RealWord_20240829211917.log,112,IDelegation,4234,4347,8581,84.0,0.10811,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

interface IDelegation {
    function clearDelegate(bytes32 _id) external;

    function setDelegate(bytes32 _id, address _delegate) external;

    function delegation(address _address, bytes32 _id) external view returns (address);
}",66
RealWorld_BA_112_CTokenRegistry_RealWord_20240829192247.log,112,CTokenRegistry,14983,5501,20484,88.0,0.184935,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../../../interfaces/vendor/CToken.sol"";
import ""../../../../interfaces/vendor/Comptroller.sol"";
import ""../../../../libraries/Errors.sol"";

contract CTokenRegistry {
    Comptroller public immutable comptroller;

    address public constant COMPTROLLER_MAINNET_ADDRESS =
        address(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);

    mapping(address => address) internal _underlyingToCToken;

    constructor(address comptrollerAddress) {
        comptroller = Comptroller(comptrollerAddress);
        _updateCTokenMapping();
    }

    /**
     * @notice Tries to read the CToken contract address for a given underlying token address
     * If not found, tries to fetch it from the Comptroller contract and fails if
     * cannot find it in the comptroller either
     */
    function fetchCToken(address underlying) external returns (CToken) {
        CToken ctoken = getCToken(underlying, false);
        if (address(ctoken) != address(0)) {
            return CToken(ctoken);
        }

        _updateCTokenMapping();
        return getCToken(underlying, true);
    }

    /**
     * @notice Reads the CToken contract address for a given underlying token address
     * or fails if not found
     */
    function getCToken(address underlying) external view returns (CToken) {
        return getCToken(underlying, true);
    }

    /**
     * @notice Reads the CToken contract address for a given underlying token address
     * If `ensureExists` is `true`, fails if not found, otherwise returns address 0
     */
    function getCToken(address underlying, bool ensureExists) public view returns (CToken) {
        CToken ctoken = CToken(_underlyingToCToken[underlying]);
        if (ensureExists && (address(ctoken) == address(0) || !_isCTokenUsable(ctoken))) {
            revert(Error.UNDERLYING_NOT_SUPPORTED);
        }
        return ctoken;
    }

    /**
     * @dev Updates the CToken mapping by fetching information from the Comptroller contract
     */
    function _updateCTokenMapping() internal {
        CToken[] memory ctokens = comptroller.getAllMarkets();
        for (uint256 i = 0; i < ctokens.length; i++) {
            CToken ctoken = ctokens[i];
            if (!_isCTokenUsable(ctoken)) {
                continue;
            }
            if (
                keccak256(abi.encodePacked(ctoken.symbol())) == keccak256(abi.encodePacked(""cETH""))
            ) {
                _underlyingToCToken[address(0)] = address(ctoken);
            } else {
                _underlyingToCToken[ctoken.underlying()] = address(ctoken);
            }
        }
    }

    function _isCTokenUsable(CToken ctoken) internal view returns (bool) {
        (bool listed, , ) = comptroller.markets(address(ctoken));
        // NOTE: comptroller.isDeprecated is not available on Kovan
        bool deprecated = address(comptroller) == COMPTROLLER_MAINNET_ADDRESS &&
            comptroller.isDeprecated(ctoken);
        return listed && !deprecated;
    }
}",720
RealWorld_BA_112_Roles_RealWord_20240829195808.log,112,Roles,5581,4562,10143,119.0,0.119145,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

// solhint-disable private-vars-leading-underscore

library Roles {
    bytes32 internal constant GOVERNANCE = ""governance"";
    bytes32 internal constant ADDRESS_PROVIDER = ""address_provider"";
    bytes32 internal constant POOL_FACTORY = ""pool_factory"";
    bytes32 internal constant CONTROLLER = ""controller"";
    bytes32 internal constant GAUGE_ZAP = ""gauge_zap"";
    bytes32 internal constant MAINTENANCE = ""maintenance"";
    bytes32 internal constant INFLATION_MANAGER = ""inflation_manager"";
    bytes32 internal constant POOL = ""pool"";
    bytes32 internal constant VAULT = ""vault"";
}",153
RealWorld_BA_112_PoolFactory_RealWord_20240829194538.log,112,PoolFactory,31188,5370,36558,98.0,0.26334,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/proxy/Clones.sol"";

import ""../../interfaces/IStakerVault.sol"";
import ""../../interfaces/IVault.sol"";
import ""../../interfaces/ILpToken.sol"";
import ""../../interfaces/IAdmin.sol"";
import ""../../interfaces/IController.sol"";
import ""../../interfaces/pool/ILiquidityPool.sol"";
import ""../../interfaces/pool/IErc20Pool.sol"";
import ""../../interfaces/pool/IEthPool.sol"";

import ""../../libraries/ScaledMath.sol"";
import ""../../libraries/AddressProviderHelpers.sol"";

import ""../access/Authorization.sol"";

contract PoolFactory is Authorization {
    using AddressProviderHelpers for IAddressProvider;

    struct Addresses {
        address pool;
        address vault;
        address lpToken;
        address stakerVault;
    }

    struct ImplementationNames {
        bytes32 pool;
        bytes32 vault;
        bytes32 lpToken;
        bytes32 stakerVault;
    }

    struct VaultArgs {
        uint256 debtLimit;
        uint256 targetAllocation;
        uint256 bound;
    }

    struct LpTokenArgs {
        string name;
        string symbol;
        uint8 decimals;
    }

    struct DeployPoolVars {
        address lpTokenImplementation;
        address poolImplementation;
        address stakerVaultImplementation;
        address vaultImplementation;
    }

    bytes32 internal constant _POOL_KEY = ""pool"";
    bytes32 internal constant _LP_TOKEN_KEY = ""lp_token"";
    bytes32 internal constant _STAKER_VAULT_KEY = ""staker_vault"";
    bytes32 internal constant _VAULT_KEY = ""vault"";

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    /**
     * @dev maps a contract type (e.g. ""pool"" or ""lp_token"", as defined in constants above)
     * to a mapping from an implementation name to the actual implementation
     * The implementation name is decided when registering the implementation
     * and can be arbitrary (e.g. ""ERC20PoolV1"")
     */
    mapping(bytes32 => mapping(bytes32 => address)) public implementations;

    event NewPool(address pool, address vault, address lpToken, address stakerVault);
    event NewImplementation(bytes32 key, bytes32 name, address implementation);

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = IController(_controller);
        addressProvider = IController(_controller).addressProvider();
    }

    /**
     * @notice Add a new pool implementation to the factory.
     * @param name of the pool implementation.
     * @param implementation of pool implementation to add.
     */
    function addPoolImplementation(bytes32 name, address implementation)
        external
        onlyGovernance
        returns (bool)
    {
        return _addImplementation(_POOL_KEY, name, implementation);
    }

    /**
     * @notice Add a new LP token implementation to the factory.
     * @param name of the LP token implementation.
     * @param implementation of lp token implementation to add.
     */
    function addLpTokenImplementation(bytes32 name, address implementation)
        external
        onlyGovernance
        returns (bool)
    {
        return _addImplementation(_LP_TOKEN_KEY, name, implementation);
    }

    /**
     * @notice Add a new vault implementation to the factory.
     * @param name of the vault implementation.
     * @param implementation of vault implementation to add.
     */
    function addVaultImplementation(bytes32 name, address implementation)
        external
        onlyGovernance
        returns (bool)
    {
        return _addImplementation(_VAULT_KEY, name, implementation);
    }

    /**
     * @notice Add a new staker vault implementation to the factory.
     * @param name of the staker vault implementation.
     * @param implementation of staker vault implementation to add.
     */
    function addStakerVaultImplementation(bytes32 name, address implementation)
        external
        onlyGovernance
        returns (bool)
    {
        return _addImplementation(_STAKER_VAULT_KEY, name, implementation);
    }

    /**
     * @notice Deploys a new pool and LP token.
     * @dev Decimals is an argument as not all ERC20 tokens implement the ERC20Detailed interface.
     *      An implementation where `getUnderlying()` returns the zero address is for ETH pools.
     * @param poolName Name of the pool.
     * @param underlying Address of the pool's underlying.
     * @param lpTokenArgs Arguments to create the LP token for the pool
     * @param vaultArgs Arguments to create the vault
     * @param implementationNames Name of the implementations to use
     * @return addrs Address of the deployed pool, address of the pool's deployed LP token.
     */
    function deployPool(
        string calldata poolName,
        uint256 depositCap,
        address underlying,
        LpTokenArgs calldata lpTokenArgs,
        VaultArgs calldata vaultArgs,
        ImplementationNames calldata implementationNames
    ) external onlyGovernance returns (Addresses memory addrs) {
        DeployPoolVars memory vars;

        vars.poolImplementation = implementations[_POOL_KEY][implementationNames.pool];
        require(vars.poolImplementation != address(0), Error.INVALID_POOL_IMPLEMENTATION);

        vars.lpTokenImplementation = implementations[_LP_TOKEN_KEY][implementationNames.lpToken];
        require(vars.lpTokenImplementation != address(0), Error.INVALID_LP_TOKEN_IMPLEMENTATION);

        vars.vaultImplementation = implementations[_VAULT_KEY][implementationNames.vault];
        require(vars.vaultImplementation != address(0), Error.INVALID_VAULT_IMPLEMENTATION);

        vars.stakerVaultImplementation = implementations[_STAKER_VAULT_KEY][
            implementationNames.stakerVault
        ];
        require(
            vars.stakerVaultImplementation != address(0),
            Error.INVALID_STAKER_VAULT_IMPLEMENTATION
        );

        addrs.pool = Clones.clone(vars.poolImplementation);
        addrs.vault = Clones.clone(vars.vaultImplementation);

        if (underlying == address(0)) {
            // ETH pool
            require(
                ILiquidityPool(vars.poolImplementation).getUnderlying() == address(0),
                Error.INVALID_POOL_IMPLEMENTATION
            );
            require(lpTokenArgs.decimals == 18, Error.INVALID_DECIMALS);
            IEthPool(addrs.pool).initialize(poolName, depositCap, addrs.vault);
        } else {
            IErc20Pool(addrs.pool).initialize(poolName, underlying, depositCap, addrs.vault);
        }

        addrs.lpToken = Clones.clone(vars.lpTokenImplementation);

        ILpToken(addrs.lpToken).initialize(
            lpTokenArgs.name,
            lpTokenArgs.symbol,
            lpTokenArgs.decimals,
            addrs.pool
        );

        addrs.stakerVault = Clones.clone(vars.stakerVaultImplementation);
        IStakerVault(addrs.stakerVault).initialize(addrs.lpToken);
        controller.addStakerVault(addrs.stakerVault);

        ILiquidityPool(addrs.pool).setLpToken(addrs.lpToken);
        ILiquidityPool(addrs.pool).setStaker();

        IVault(addrs.vault).initialize(
            addrs.pool,
            vaultArgs.debtLimit,
            vaultArgs.targetAllocation,
            vaultArgs.bound
        );

        addressProvider.addPool(addrs.pool);

        emit NewPool(addrs.pool, addrs.vault, addrs.lpToken, addrs.stakerVault);
        return addrs;
    }

    /**
     * @notice Add a new implementation of type `name` to the factory.
     * @param key of the implementation to add.
     * @param name of the implementation to add.
     * @param implementation of lp token implementation to add.
     */
    function _addImplementation(
        bytes32 key,
        bytes32 name,
        address implementation
    ) internal returns (bool) {
        mapping(bytes32 => address) storage currentImplementations = implementations[key];
        if (currentImplementations[name] != address(0)) {
            return false;
        }
        currentImplementations[name] = implementation;
        emit NewImplementation(key, name, implementation);
        return true;
    }
}",1767
RealWorld_BA_112_Pausable_RealWord_20240829182544.log,112,Pausable,7097,4744,11841,76.0,0.130365,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../libraries/Errors.sol"";

abstract contract Pausable {
    bool public isPaused;

    modifier notPaused() {
        require(!isPaused, Error.CONTRACT_PAUSED);
        _;
    }

    modifier onlyAuthorizedToPause() {
        require(_isAuthorizedToPause(msg.sender), Error.UNAUTHORIZED_PAUSE);
        _;
    }

    /**
     * @notice Pause the contract.
     * @return `true` if success.
     */
    function pause() external onlyAuthorizedToPause returns (bool) {
        isPaused = true;
        return true;
    }

    /**
     * @notice Unpause the contract.
     * @return `true` if success.
     */
    function unpause() external onlyAuthorizedToPause returns (bool) {
        isPaused = false;
        return true;
    }

    /**
     * @notice Returns true if `account` is authorized to pause the contract
     * @dev This should be implemented in contracts inheriting `Pausable`
     * to provide proper access control
     */
    function _isAuthorizedToPause(address account) internal view virtual returns (bool);
}",255
RealWorld_BA_112_AmmConvexGauge_RealWord_20240829192959.log,112,AmmConvexGauge,40316,5934,46250,94.0,0.32026,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../../libraries/ScaledMath.sol"";
import ""../../libraries/Errors.sol"";

import ""../../interfaces/vendor/IBooster.sol"";
import ""../../interfaces/vendor/IRewardStaking.sol"";
import ""../../interfaces/tokenomics/IAmmConvexGauge.sol"";
import ""./AmmGauge.sol"";
import ""../utils/CvxMintAmount.sol"";

contract AmmConvexGauge is IAmmConvexGauge, AmmGauge, CvxMintAmount {
    using ScaledMath for uint256;
    using SafeERC20 for IERC20;
    address public immutable cvx;
    address public immutable crv;
    address public immutable booster;
    address public inflationRecipient;

    uint256 public immutable bkdPoolPID; // bkd pool id on Convex
    IRewardStaking public immutable crvRewardsContract; // Staking contract for bkd convex deposit token

    // Additional integrals etc. for crv and cvx rewards
    uint256 public crvStakedIntegral;
    uint256 public cvxStakedIntegral;
    mapping(address => uint256) public perUserCrvStakedIntegral;
    mapping(address => uint256) public perUserCvxStakedIntegral;
    mapping(address => uint256) public perUserShareCrv;
    mapping(address => uint256) public perUserShareCvx;

    uint256 private _crvLastEarned;
    uint256 private _cvxLastEarned;
    uint256 private _preClaimRewardsCrvEarned;

    event RewardClaimed(
        address indexed beneficiary,
        uint256 bkdAmount,
        uint256 crvAmount,
        uint256 cvxAmount
    );

    constructor(
        IController _controller,
        address _ammToken,
        uint256 _bkdPoolPID,
        address _crv,
        address _cvx,
        address _booster
    ) AmmGauge(_controller, _ammToken) {
        cvx = _cvx;
        crv = _crv;
        booster = _booster;
        bkdPoolPID = _bkdPoolPID;
        (, , , address _crvRewards, , ) = IBooster(booster).poolInfo(_bkdPoolPID);
        crvRewardsContract = IRewardStaking(_crvRewards);

        // approve for Convex deposit
        IERC20(ammToken).safeApprove(booster, type(uint256).max);
    }

    function claimRewards(address beneficiary) external virtual override returns (uint256) {
        require(
            msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );
        _userCheckpoint(beneficiary);
        uint256 amount = perUserShare[beneficiary];
        uint256 crvAmount = perUserShareCrv[beneficiary];
        uint256 cvxAmount = perUserShareCvx[beneficiary];
        if (amount <= 0 && crvAmount <= 0 && cvxAmount <= 0) return 0;
        crvRewardsContract.getReward();
        _crvLastEarned = 0;
        _cvxLastEarned = 0;
        perUserShare[beneficiary] = 0;
        perUserShareCrv[beneficiary] = 0;
        perUserShareCvx[beneficiary] = 0;
        IController(controller).inflationManager().mintRewards(beneficiary, amount);
        IERC20(crv).safeTransfer(beneficiary, crvAmount);
        IERC20(cvx).safeTransfer(beneficiary, cvxAmount);
        _preClaimRewardsCrvEarned = IERC20(crv).balanceOf(address(this));
        emit RewardClaimed(beneficiary, amount, crvAmount, cvxAmount);
        return amount;
    }

    function setInflationRecipient(address recipient) external override onlyGovernance {
        require(inflationRecipient == address(0), Error.ADDRESS_ALREADY_SET);
        poolCheckpoint();
        inflationRecipient = recipient;
    }

    function deactivateInflationRecipient() external override onlyGovernance {
        require(inflationRecipient != address(0), Error.ADDRESS_NOT_FOUND);
        poolCheckpoint();
        inflationRecipient = address(0);
    }

    function claimableRewards(address user) external view virtual override returns (uint256) {
        uint256 ammStakedIntegral_ = ammStakedIntegral;
        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);
        if (user == inflationRecipient) {
            return
                perUserShare[inflationRecipient] +
                IController(controller).inflationManager().getAmmRateForToken(ammToken) *
                timeElapsed;
        }
        if (!killed && totalStaked > 0) {
            ammStakedIntegral_ +=
                IController(controller).inflationManager().getAmmRateForToken(ammToken) *
                timeElapsed.scaledDiv(totalStaked);
        }
        return
            perUserShare[user] +
            balances[user].scaledMul(ammStakedIntegral_ - perUserStakedIntegral[user]);
    }

    function allClaimableRewards(address user) external view override returns (uint256[3] memory) {
        uint256 ammStakedIntegral_ = ammStakedIntegral;
        uint256 crvStakedIntegral_ = crvStakedIntegral;
        uint256 cvxStakedIntegral_ = cvxStakedIntegral;
        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);
        uint256 crvEarned = IERC20(crv).balanceOf(address(this)) -
            _preClaimRewardsCrvEarned +
            crvRewardsContract.earned(address(this));
        uint256 cvxEarned = getCvxMintAmount(crvEarned);

        if (!killed && totalStaked > 0) {
            if (inflationRecipient == address(0)) {
                ammStakedIntegral_ +=
                    (IController(controller).inflationManager().getAmmRateForToken(ammToken)) *
                    (timeElapsed).scaledDiv(totalStaked);
            }
            crvStakedIntegral_ += (crvEarned - _crvLastEarned).scaledDiv(totalStaked);
            cvxStakedIntegral_ += (cvxEarned - _cvxLastEarned).scaledDiv(totalStaked);
        }
        uint256 bkdRewards;
        if (user == inflationRecipient) {
            bkdRewards =
                perUserShare[user] +
                IController(controller).inflationManager().getAmmRateForToken(ammToken) *
                timeElapsed;
        } else {
            bkdRewards =
                perUserShare[user] +
                balances[user].scaledMul(ammStakedIntegral_ - perUserStakedIntegral[user]);
        }
        uint256 crvRewards = perUserShareCrv[user] +
            balances[user].scaledMul(crvStakedIntegral_ - perUserCrvStakedIntegral[user]);
        uint256 cvxRewards = perUserShareCvx[user] +
            balances[user].scaledMul(cvxStakedIntegral_ - perUserCvxStakedIntegral[user]);
        uint256[3] memory allRewards = [bkdRewards, crvRewards, cvxRewards];
        return allRewards;
    }

    function stakeFor(address account, uint256 amount) public virtual override returns (bool) {
        require(amount > 0, Error.INVALID_AMOUNT);

        _userCheckpoint(account);

        IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount);
        IBooster(booster).deposit(bkdPoolPID, amount, true);
        balances[account] += amount;
        totalStaked += amount;
        emit AmmStaked(account, ammToken, amount);
        return true;
    }

    function unstakeFor(address dst, uint256 amount) public virtual override returns (bool) {
        require(amount > 0, Error.INVALID_AMOUNT);
        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);

        _userCheckpoint(msg.sender);

        crvRewardsContract.withdrawAndUnwrap(amount, false);
        IERC20(ammToken).safeTransfer(dst, amount);
        balances[msg.sender] -= amount;
        totalStaked -= amount;
        emit AmmUnstaked(msg.sender, ammToken, amount);
        return true;
    }

    function poolCheckpoint() public virtual override returns (bool) {
        if (killed) {
            return false;
        }
        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);
        uint256 currentRate = IController(controller).inflationManager().getAmmRateForToken(
            ammToken
        );
        uint256 crvEarned = IERC20(crv).balanceOf(address(this)) -
            _preClaimRewardsCrvEarned +
            crvRewardsContract.earned(address(this));
        uint256 cvxEarned = getCvxMintAmount(crvEarned);

        // Update the integral of total token supply for the pool
        if (totalStaked > 0) {
            if (inflationRecipient == address(0)) {
                ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked);
            } else {
                perUserShare[inflationRecipient] += currentRate * timeElapsed;
            }
            crvStakedIntegral += (crvEarned - _crvLastEarned).scaledDiv(totalStaked);
            cvxStakedIntegral += (cvxEarned - _cvxLastEarned).scaledDiv(totalStaked);
        }
        _crvLastEarned = crvEarned;
        _cvxLastEarned = cvxEarned;
        ammLastUpdated = uint48(block.timestamp);
        return true;
    }

    function _userCheckpoint(address user) internal virtual override returns (bool) {
        poolCheckpoint();
        perUserShare[user] += balances[user].scaledMul(
            ammStakedIntegral - perUserStakedIntegral[user]
        );
        perUserShareCrv[user] += balances[user].scaledMul(
            crvStakedIntegral - perUserCrvStakedIntegral[user]
        );
        perUserShareCvx[user] += balances[user].scaledMul(
            cvxStakedIntegral - perUserCvxStakedIntegral[user]
        );
        perUserStakedIntegral[user] = ammStakedIntegral;
        perUserCrvStakedIntegral[user] = crvStakedIntegral;
        perUserCvxStakedIntegral[user] = cvxStakedIntegral;
        return true;
    }
}",2322
RealWorld_BA_112_IERC20Full_RealWord_20240829202241.log,112,IERC20Full,4788,4082,8870,77.0,0.10558,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/// @notice This is the ERC20 interface including optional getter functions
/// The interface is used in the frontend through the generated typechain wrapper
interface IERC20Full is IERC20 {
    function symbol() external view returns (string memory);

    function name() external view returns (string memory);

    function decimals() external view returns (uint8);
}",113
RealWorld_BA_112_InflationManager_RealWord_20240829193855.log,112,InflationManager,94282,5671,99953,116.0,0.58483,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../interfaces/IStakerVault.sol"";
import ""../../interfaces/tokenomics/IInflationManager.sol"";
import ""../../interfaces/tokenomics/IKeeperGauge.sol"";
import ""../../interfaces/tokenomics/IAmmGauge.sol"";

import ""../../libraries/EnumerableMapping.sol"";
import ""../../libraries/EnumerableExtensions.sol"";
import ""../../libraries/AddressProviderHelpers.sol"";

import ""./Minter.sol"";
import ""../utils/Preparable.sol"";
import ""../access/Authorization.sol"";

contract InflationManager is Authorization, IInflationManager, Preparable {
    using EnumerableMapping for EnumerableMapping.AddressToAddressMap;
    using EnumerableExtensions for EnumerableMapping.AddressToAddressMap;
    using AddressProviderHelpers for IAddressProvider;

    IAddressProvider public immutable addressProvider;

    bytes32 internal constant _KEEPER_WEIGHT_KEY = ""keeperWeight"";
    bytes32 internal constant _AMM_WEIGHT_KEY = ""ammWeight"";
    bytes32 internal constant _LP_WEIGHT_KEY = ""lpWeight"";

    address public minter;
    bool public weightBasedKeeperDistributionDeactivated;
    uint256 public totalKeeperPoolWeight;
    uint256 public totalLpPoolWeight;
    uint256 public totalAmmTokenWeight;

    // Pool -> keeperGauge
    EnumerableMapping.AddressToAddressMap private _keeperGauges;
    // AMM token -> ammGauge
    EnumerableMapping.AddressToAddressMap private _ammGauges;

    mapping(address => bool) public gauges;

    event NewKeeperWeight(address indexed pool, uint256 newWeight);
    event NewLpWeight(address indexed pool, uint256 newWeight);
    event NewAmmTokenWeight(address indexed token, uint256 newWeight);

    modifier onlyGauge() {
        require(gauges[msg.sender], Error.UNAUTHORIZED_ACCESS);
        _;
    }

    constructor(IAddressProvider _addressProvider)
        Authorization(_addressProvider.getRoleManager())
    {
        addressProvider = _addressProvider;
    }

    function setMinter(address _minter) external onlyGovernance returns (bool) {
        require(minter == address(0), Error.ADDRESS_ALREADY_SET);
        require(_minter != address(0), Error.INVALID_MINTER);
        minter = _minter;
        return true;
    }

    /**
     * @notice Advance the keeper gauge for a pool by on epoch.
     * @param pool Pool for which the keeper gauge is advanced.
     * @return `true` if successful.
     */
    function advanceKeeperGaugeEpoch(address pool) external onlyGovernance returns (bool) {
        IKeeperGauge(_keeperGauges.get(pool)).advanceEpoch();
        return true;
    }

    /**
     * @notice Mints BKD tokens.
     * @param beneficiary Address to receive the tokens.
     * @param amount Amount of tokens to mint.
     */
    function mintRewards(address beneficiary, uint256 amount) external override onlyGauge {
        Minter(minter).mint(beneficiary, amount);
    }

    /**
     * @notice Deactivates the weight-based distribution of keeper inflation.
     * @dev This can only be done once, when the keeper inflation mechanism is altered.
     * @return `true` if successful.
     */
    function deactivateWeightBasedKeeperDistribution() external onlyGovernance returns (bool) {
        require(!weightBasedKeeperDistributionDeactivated, ""Weight-based dist. deactivated."");
        address[] memory liquidityPools = addressProvider.allPools();
        uint256 length = liquidityPools.length;
        for (uint256 i = 0; i < length; i++) {
            _removeKeeperGauge(address(liquidityPools[i]));
        }
        weightBasedKeeperDistributionDeactivated = true;
        return true;
    }

    /**
     * @notice Checkpoints all gauges.
     * @dev This is mostly used upon inflation rate updates.
     * @return `true` if successful.
     */
    function checkpointAllGauges() external override returns (bool) {
        uint256 length = _keeperGauges.length();
        for (uint256 i = 0; i < length; i++) {
            IKeeperGauge(_keeperGauges.valueAt(i)).poolCheckpoint();
        }
        address[] memory stakerVaults = addressProvider.allStakerVaults();
        for (uint256 i = 0; i < stakerVaults.length; i++) {
            IStakerVault(stakerVaults[i]).poolCheckpoint();
        }

        length = _ammGauges.length();
        for (uint256 i = 0; i < length; i++) {
            IAmmGauge(_ammGauges.valueAt(i)).poolCheckpoint();
        }
        return true;
    }

    /**
     * @notice Prepare update of a keeper pool weight (with time delay enforced).
     * @param pool Pool to update the keeper weight for.
     * @param newPoolWeight New weight for the keeper inflation for the pool.
     * @return `true` if successful.
     */
    function prepareKeeperPoolWeight(address pool, uint256 newPoolWeight)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(_keeperGauges.contains(pool), Error.INVALID_ARGUMENT);
        bytes32 key = _getKeeperGaugeKey(pool);
        _prepare(key, newPoolWeight);
        return true;
    }

    /**
     * @notice Execute update of keeper pool weight (with time delay enforced).
     * @param pool Pool to execute the keeper weight update for.
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New keeper pool weight.
     */
    function executeKeeperPoolWeight(address pool) external override returns (uint256) {
        bytes32 key = _getKeeperGaugeKey(pool);
        _executeKeeperPoolWeight(key, pool, isInflationWeightManager(msg.sender));
        return currentUInts256[key];
    }

    /**
     * @notice Prepare update of a batch of keeperGauge weights (with time delay enforced).
     * @dev Each entry in the pools array corresponds to an entry in the weights array.
     * @param pools Pools to update the keeper weight for.
     * @param weights New weights for the keeper inflation for the pools.
     * @return `true` if successful.
     */
    function batchPrepareKeeperPoolWeights(address[] calldata pools, uint256[] calldata weights)
        external
        override
        onlyGovernance
        returns (bool)
    {
        uint256 length = pools.length;
        require(length == weights.length, Error.INVALID_ARGUMENT);
        bytes32 key;
        for (uint256 i = 0; i < length; i++) {
            require(_keeperGauges.contains(pools[i]), Error.INVALID_ARGUMENT);
            key = _getKeeperGaugeKey(pools[i]);
            _prepare(key, weights[i]);
        }
        return true;
    }

    function whitelistGauge(address gauge) external onlyRole(Roles.CONTROLLER) {
        gauges[gauge] = true;
    }

    /**
     * @notice Execute weight updates for a batch of _keeperGauges.
     * @param pools Pools to execute the keeper weight updates for.
     * @return `true` if successful.
     */
    function batchExecuteKeeperPoolWeights(address[] calldata pools)
        external
        override
        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)
        returns (bool)
    {
        uint256 length = pools.length;
        bytes32 key;
        for (uint256 i = 0; i < length; i++) {
            key = _getKeeperGaugeKey(pools[i]);
            _executeKeeperPoolWeight(key, pools[i], isInflationWeightManager(msg.sender));
        }
        return true;
    }

    function removeStakerVaultFromInflation(address stakerVault, address lpToken)
        external
        onlyRole(Roles.CONTROLLER)
    {
        bytes32 key = _getLpStakerVaultKey(stakerVault);
        _prepare(key, 0);
        _executeLpPoolWeight(key, lpToken, stakerVault, true);
    }

    /**
     * @notice Prepare update of a lp pool weight (with time delay enforced).
     * @param lpToken LP token to update the weight for.
     * @param newPoolWeight New LP inflation weight.
     * @return `true` if successful.
     */
    function prepareLpPoolWeight(address lpToken, uint256 newPoolWeight)
        external
        override
        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)
        returns (bool)
    {
        address stakerVault = addressProvider.getStakerVault(lpToken);
        // Require both that gauge is registered and that pool is still in action
        require(gauges[IStakerVault(stakerVault).getLpGauge()], Error.GAUGE_DOES_NOT_EXIST);
        _ensurePoolExists(lpToken);
        bytes32 key = _getLpStakerVaultKey(stakerVault);
        _prepare(key, newPoolWeight);
        return true;
    }

    /**
     * @notice Execute update of lp pool weight (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return New lp pool weight.
     */
    function executeLpPoolWeight(address lpToken) external override returns (uint256) {
        address stakerVault = addressProvider.getStakerVault(lpToken);
        // Require both that gauge is registered and that pool is still in action
        require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);
        _ensurePoolExists(lpToken);
        bytes32 key = _getLpStakerVaultKey(stakerVault);
        _executeLpPoolWeight(key, lpToken, stakerVault, isInflationWeightManager(msg.sender));
        return currentUInts256[key];
    }

    /**
     * @notice Prepare update of a batch of LP token weights (with time delay enforced).
     * @dev Each entry in the lpTokens array corresponds to an entry in the weights array.
     * @param lpTokens LpTokens to update the inflation weight for.
     * @param weights New weights for the inflation for the LpTokens.
     * @return `true` if successful.
     */
    function batchPrepareLpPoolWeights(address[] calldata lpTokens, uint256[] calldata weights)
        external
        override
        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)
        returns (bool)
    {
        uint256 length = lpTokens.length;
        require(length == weights.length, ""Invalid length of arguments"");
        bytes32 key;
        for (uint256 i = 0; i < length; i++) {
            address stakerVault = addressProvider.getStakerVault(lpTokens[i]);
            // Require both that gauge is registered and that pool is still in action
            require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);
            _ensurePoolExists(lpTokens[i]);
            key = _getLpStakerVaultKey(stakerVault);
            _prepare(key, weights[i]);
        }
        return true;
    }

    /**
     * @notice Execute weight updates for a batch of LpTokens.
     * @dev If this is called by the INFLATION_MANAGER role address, no time delay is enforced.
     * @param lpTokens LpTokens to execute the weight updates for.
     * @return `true` if successful.
     */
    function batchExecuteLpPoolWeights(address[] calldata lpTokens)
        external
        override
        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)
        returns (bool)
    {
        uint256 length = lpTokens.length;
        for (uint256 i = 0; i < length; i++) {
            address lpToken = lpTokens[i];
            address stakerVault = addressProvider.getStakerVault(lpToken);
            // Require both that gauge is registered and that pool is still in action
            require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);
            _ensurePoolExists(lpToken);
            bytes32 key = _getLpStakerVaultKey(stakerVault);
            _executeLpPoolWeight(key, lpToken, stakerVault, isInflationWeightManager(msg.sender));
        }
        return true;
    }

    /**
     * @notice Prepare an inflation weight update for an AMM token (with time delay enforced).
     * @param token AMM token to update the weight for.
     * @param newTokenWeight New AMM token inflation weight.
     * @return `true` if successful.
     */
    function prepareAmmTokenWeight(address token, uint256 newTokenWeight)
        external
        override
        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)
        returns (bool)
    {
        require(_ammGauges.contains(token), ""amm gauge not found"");
        bytes32 key = _getAmmGaugeKey(token);
        _prepare(key, newTokenWeight);
        return true;
    }

    /**
     * @notice Execute update of lp pool weight (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New lp pool weight.
     */
    function executeAmmTokenWeight(address token) external override returns (uint256) {
        bytes32 key = _getAmmGaugeKey(token);
        _executeAmmTokenWeight(token, key, isInflationWeightManager(msg.sender));
        return currentUInts256[key];
    }

    /**
     * @notice Registers a pool's strategy with the stakerVault of the pool where the strategy deposits.
     * @dev This simply avoids the strategy accumulating tokens in the deposit pool.
     * @param depositStakerVault StakerVault of the pool where the strategy deposits.
     * @param strategyPool The pool of the strategy to register (avoids blacklisting other addresses).
     * @return `true` if successful.
     */
    function addStrategyToDepositStakerVault(address depositStakerVault, address strategyPool)
        external
        onlyGovernance
        returns (bool)
    {
        IVault _vault = ILiquidityPool(strategyPool).getVault();
        IStakerVault(depositStakerVault).addStrategy(address(_vault.getStrategy()));
        return true;
    }

    /**
     * @notice Prepare update of a batch of AMM token weights (with time delay enforced).
     * @dev Each entry in the tokens array corresponds to an entry in the weights array.
     * @param tokens AMM tokens to update the inflation weight for.
     * @param weights New weights for the inflation for the AMM tokens.
     * @return `true` if successful.
     */
    function batchPrepareAmmTokenWeights(address[] calldata tokens, uint256[] calldata weights)
        external
        override
        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)
        returns (bool)
    {
        uint256 length = tokens.length;
        bytes32 key;
        require(length == weights.length, ""Invalid length of arguments"");
        for (uint256 i = 0; i < length; i++) {
            require(_ammGauges.contains(tokens[i]), ""amm gauge not found"");
            key = _getAmmGaugeKey(tokens[i]);
            _prepare(key, weights[i]);
        }
        return true;
    }

    /**
     * @notice Execute weight updates for a batch of AMM tokens.
     * @dev If this is called by the INFLATION_MANAGER role address, no time delay is enforced.
     * @param tokens AMM tokens to execute the weight updates for.
     * @return `true` if successful.
     */
    function batchExecuteAmmTokenWeights(address[] calldata tokens)
        external
        override
        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)
        returns (bool)
    {
        uint256 length = tokens.length;
        bool isWeightManager = isInflationWeightManager(msg.sender);
        bytes32 key;
        address token;
        for (uint256 i = 0; i < length; i++) {
            token = tokens[i];
            key = _getAmmGaugeKey(token);
            _executeAmmTokenWeight(token, key, isWeightManager);
        }
        return true;
    }

    /**
     * @notice Sets the KeeperGauge for a pool.
     * @dev Multiple pools can have the same KeeperGauge.
     * @param pool Address of pool to set the KeeperGauge for.
     * @param _keeperGauge Address of KeeperGauge.
     * @return `true` if successful.
     */
    function setKeeperGauge(address pool, address _keeperGauge)
        external
        override
        onlyGovernance
        returns (bool)
    {
        uint256 length = _keeperGauges.length();
        bool keeperGaugeExists = false;
        for (uint256 i = 0; i < length; i++) {
            if (address(_keeperGauges.valueAt(i)) == _keeperGauge) {
                keeperGaugeExists = true;
                break;
            }
        }
        // Check to make sure that once weight-based dist is deactivated, only one gauge can exist
        if (!keeperGaugeExists && weightBasedKeeperDistributionDeactivated && length >= 1) {
            return false;
        }
        (bool exists, address keeperGauge) = _keeperGauges.tryGet(pool);
        require(!exists || keeperGauge != _keeperGauge, Error.INVALID_ARGUMENT);

        if (exists && !IKeeperGauge(keeperGauge).killed()) {
            IKeeperGauge(keeperGauge).poolCheckpoint();
            IKeeperGauge(keeperGauge).kill();
        }
        _keeperGauges.set(pool, _keeperGauge);
        gauges[_keeperGauge] = true;
        return true;
    }

    function removeKeeperGauge(address pool) external onlyGovernance returns (bool) {
        _removeKeeperGauge(pool);
        return true;
    }

    /**
     * @notice Sets the AmmGauge for a particular AMM token.
     * @param token Address of the amm token.
     * @param _ammGauge Address of AmmGauge.
     * @return `true` if successful.
     */
    function setAmmGauge(address token, address _ammGauge)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(IAmmGauge(_ammGauge).isAmmToken(token), Error.ADDRESS_NOT_WHITELISTED);
        uint256 length = _ammGauges.length();
        for (uint256 i = 0; i < length; i++) {
            if (address(_ammGauges.valueAt(i)) == _ammGauge) {
                return false;
            }
        }
        if (_ammGauges.contains(token)) {
            address ammGauge = _ammGauges.get(token);
            IAmmGauge(ammGauge).poolCheckpoint();
            IAmmGauge(ammGauge).kill();
        }
        _ammGauges.set(token, _ammGauge);
        gauges[_ammGauge] = true;
        return true;
    }

    function removeAmmGauge(address token) external onlyGovernance returns (bool) {
        if (!_ammGauges.contains(token)) return false;
        address ammGauge = _ammGauges.get(token);
        bytes32 key = _getAmmGaugeKey(token);
        _prepare(key, 0);
        _executeAmmTokenWeight(token, key, true);
        IAmmGauge(ammGauge).kill();
        _ammGauges.remove(token);
        // Do not delete from the gauges map to allow claiming of remaining balances
        emit AmmGaugeDelisted(token, ammGauge);
        return true;
    }

    function addGaugeForVault(address lpToken) external override returns (bool) {
        IStakerVault _stakerVault = IStakerVault(msg.sender);
        require(addressProvider.isStakerVault(msg.sender, lpToken), Error.UNAUTHORIZED_ACCESS);
        address lpGauge = _stakerVault.getLpGauge();
        require(lpGauge != address(0), Error.GAUGE_DOES_NOT_EXIST);
        gauges[lpGauge] = true;
        return true;
    }

    function getAllAmmGauges() external view override returns (address[] memory) {
        return _ammGauges.valuesArray();
    }

    function getLpRateForStakerVault(address stakerVault) external view override returns (uint256) {
        if (minter == address(0) || totalLpPoolWeight == 0) {
            return 0;
        }

        bytes32 key = _getLpStakerVaultKey(stakerVault);
        uint256 lpInflationRate = Minter(minter).getLpInflationRate();
        uint256 poolInflationRate = (currentUInts256[key] * lpInflationRate) / totalLpPoolWeight;

        return poolInflationRate;
    }

    function getKeeperRateForPool(address pool) external view override returns (uint256) {
        if (minter == address(0)) {
            return 0;
        }
        uint256 keeperInflationRate = Minter(minter).getKeeperInflationRate();
        // After deactivation of weight based dist, KeeperGauge handles the splitting
        if (weightBasedKeeperDistributionDeactivated) return keeperInflationRate;
        if (totalKeeperPoolWeight == 0) return 0;
        bytes32 key = _getKeeperGaugeKey(pool);
        uint256 poolInflationRate = (currentUInts256[key] * keeperInflationRate) /
            totalKeeperPoolWeight;
        return poolInflationRate;
    }

    function getAmmRateForToken(address token) external view override returns (uint256) {
        if (minter == address(0) || totalAmmTokenWeight == 0) {
            return 0;
        }
        bytes32 key = _getAmmGaugeKey(token);
        uint256 ammInflationRate = Minter(minter).getAmmInflationRate();
        uint256 ammTokenInflationRate = (currentUInts256[key] * ammInflationRate) /
            totalAmmTokenWeight;
        return ammTokenInflationRate;
    }

    //TOOD: See if this is still needed somewhere
    function getKeeperWeightForPool(address pool) external view override returns (uint256) {
        bytes32 key = _getKeeperGaugeKey(pool);
        return currentUInts256[key];
    }

    function getAmmWeightForToken(address token) external view override returns (uint256) {
        bytes32 key = _getAmmGaugeKey(token);
        return currentUInts256[key];
    }

    function getLpPoolWeight(address lpToken) external view override returns (uint256) {
        address stakerVault = addressProvider.getStakerVault(lpToken);
        bytes32 key = _getLpStakerVaultKey(stakerVault);
        return currentUInts256[key];
    }

    function getKeeperGaugeForPool(address pool) external view override returns (address) {
        (, address keeperGauge) = _keeperGauges.tryGet(pool);
        return keeperGauge;
    }

    function getAmmGaugeForToken(address token) external view override returns (address) {
        (, address ammGauge) = _ammGauges.tryGet(token);
        return ammGauge;
    }

    /**
     * @notice Check if an account is governance proxy.
     * @param account Address to check.
     * @return `true` if account is governance proxy.
     */
    function isInflationWeightManager(address account) public view override returns (bool) {
        return _roleManager().hasRole(Roles.INFLATION_MANAGER, account);
    }

    function _executeKeeperPoolWeight(
        bytes32 key,
        address pool,
        bool isWeightManager
    ) internal returns (bool) {
        IKeeperGauge(_keeperGauges.get(pool)).poolCheckpoint();
        totalKeeperPoolWeight = totalKeeperPoolWeight - currentUInts256[key] + pendingUInts256[key];
        totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0;
        isWeightManager ? _setConfig(key, pendingUInts256[key]) : _executeUInt256(key);
        emit NewKeeperWeight(pool, currentUInts256[key]);
        return true;
    }

    function _executeLpPoolWeight(
        bytes32 key,
        address lpToken,
        address stakerVault,
        bool isWeightManager
    ) internal returns (bool) {
        IStakerVault(stakerVault).poolCheckpoint();
        totalLpPoolWeight = totalLpPoolWeight - currentUInts256[key] + pendingUInts256[key];
        totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0;
        isWeightManager ? _setConfig(key, pendingUInts256[key]) : _executeUInt256(key);
        emit NewLpWeight(lpToken, currentUInts256[key]);
        return true;
    }

    function _executeAmmTokenWeight(
        address token,
        bytes32 key,
        bool isWeightManager
    ) internal returns (bool) {
        IAmmGauge(_ammGauges.get(token)).poolCheckpoint();
        totalAmmTokenWeight = totalAmmTokenWeight - currentUInts256[key] + pendingUInts256[key];
        totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0;
        isWeightManager ? _setConfig(key, pendingUInts256[key]) : _executeUInt256(key);
        // Do pool checkpoint to update the pool integrals
        emit NewAmmTokenWeight(token, currentUInts256[key]);
        return true;
    }

    function _removeKeeperGauge(address pool) internal {
        address keeperGauge = _keeperGauges.get(pool);
        bytes32 key = _getKeeperGaugeKey(pool);
        _prepare(key, 0);
        _executeKeeperPoolWeight(key, pool, true);
        _keeperGauges.remove(pool);
        IKeeperGauge(keeperGauge).kill();
        // Do not delete from the gauges map to allow claiming of remaining balances
        emit KeeperGaugeDelisted(pool, keeperGauge);
    }

    function _ensurePoolExists(address lpToken) internal view {
        require(
            address(addressProvider.safeGetPoolForToken(lpToken)) != address(0),
            Error.ADDRESS_NOT_FOUND
        );
    }

    function _getKeeperGaugeKey(address pool) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_KEEPER_WEIGHT_KEY, pool));
    }

    function _getAmmGaugeKey(address token) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_AMM_WEIGHT_KEY, token));
    }

    function _getLpStakerVaultKey(address vault) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_LP_WEIGHT_KEY, vault));
    }
}",5861
RealWorld_BA_112_MockStableSwap_RealWord_20240829190125.log,112,MockStableSwap,22809,5852,28661,89.0,0.231085,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""../../interfaces/vendor/ICurveSwap.sol"";
import ""./MockCurveToken.sol"";

/**
 * @notice This is a just a mock contract and does NOT contain the logic for a Curve StableSwap pool.
 */

contract MockStableSwap is ICurveSwap {
    using SafeCast for uint256;
    using SafeCast for int128;

    uint256 private _virtualPrice = 1e18;
    uint256[3] private _balances = [0, 0, 0];
    address[3] private _allCoins;
    address private _lpToken;

    constructor(address[3] memory _coins, address lpToken_) {
        _allCoins = _coins;
        _lpToken = lpToken_;
    }

    // solhint-disable-next-line no-unused-vars, func-name-mixedcase
    function add_liquidity(uint256[3] calldata amounts, uint256) external override {
        uint256 total = 0;
        for (uint256 i = 0; i < 3; i++) {
            _balances[i] += amounts[i];
            total += amounts[i];
            IERC20(_allCoins[i]).transferFrom(msg.sender, address(this), amounts[i]);
        }
        // assume we mint 1 LP token per 1 underlying
        MockCurveToken(_lpToken).mintFor(msg.sender, total);
    }

    // solhint-disable-next-line no-unused-vars, func-name-mixedcase
    function add_liquidity(uint256[2] calldata amounts, uint256) external override {
        uint256 total = 0;
        for (uint256 i = 0; i < 2; i++) {
            _balances[i] += amounts[i];
            total += amounts[i];
            IERC20(_allCoins[i]).transferFrom(msg.sender, address(this), amounts[i]);
        }
        // assume we mint 1 LP token per 1 underlying
        MockCurveToken(_lpToken).mintFor(msg.sender, total);
    }

    // solhint-disable-next-line func-name-mixedcase
    function remove_liquidity_imbalance(uint256[3] calldata amounts, uint256 maxBurnAmount)
        external
        override
    {}

    // solhint-disable-next-line func-name-mixedcase
    function remove_liquidity_imbalance(uint256[2] calldata amounts, uint256 maxBurnAmount)
        external
        override
    {}

    /**
     * @param _amount LP tokens to burn
     * @param minAmounts Minimum amount of each underlying coin to withdraw
     */
    // solhint-disable-next-line func-name-mixedcase
    function remove_liquidity(uint256 _amount, uint256[3] calldata minAmounts) external override {
        // for mock; just withdraw minAmounts
        for (uint256 i = 0; i < 3; i++) {
            _balances[i] -= minAmounts[i];
            IERC20(_allCoins[i]).transfer(msg.sender, minAmounts[i]);
        }
        MockCurveToken(_lpToken).burnFrom(msg.sender, _amount);
    }

    // solhint-disable-next-line func-name-mixedcase
    function remove_liquidity_one_coin(
        uint256 tokenAmount,
        int128 i,
        uint256 minAmount
    ) external override {
        require(_balances[i.toUint256()] >= minAmount, ""Insufficient liquidity in mock curve pool"");
        _balances[i.toUint256()] -= minAmount;
        IERC20(_allCoins[i.toUint256()]).transfer(msg.sender, minAmount);
        MockCurveToken(_lpToken).burnFrom(msg.sender, tokenAmount);
    }

    function exchange(
        int128 from,
        int128 to,
        uint256 fromAmount,
        uint256 minToAmount
    ) external override {}

    // solhint-disable-next-line func-name-mixedcase
    function get_balances() external view returns (uint256[3] memory) {
        return _balances;
    }

    // solhint-disable-next-line func-name-mixedcase
    function calc_token_amount(uint256[3] calldata amounts, bool deposit)
        external
        view
        override
        returns (uint256)
    {}

    // solhint-disable-next-line func-name-mixedcase
    function get_virtual_price() external view override returns (uint256) {
        return _virtualPrice;
    }

    function coins(uint256 index) external view override returns (address) {
        require(index >= 0 && index < 3, ""Invalid coin index"");
        return _allCoins[index];
    }

    // solhint-disable-next-line no-unused-vars, func-name-mixedcase
    function calc_withdraw_one_coin(uint256 tokenAmount, int128)
        external
        pure
        override
        returns (uint256)
    {
        // return amount assuming that 1 LP = 1 underlying
        return tokenAmount;
    }

    // solhint-disable-next-line func-name-mixedcase
    function get_dy(
        int128,
        int128,
        uint256
    ) external pure override returns (uint256) {
        return 10;
    }

    // solhint-disable-next-line func-name-mixedcase
    function calc_token_amount(uint256[2] calldata amounts, bool deposit)
        external
        pure
        override
        returns (uint256)
    {}

    // solhint-disable-next-line func-name-mixedcase
    function calc_token_amount(uint256[4] calldata amounts, bool deposit)
        external
        pure
        override
        returns (uint256)
    {}
}",1226
RealWorld_BA_112_MockAMMToken_RealWord_20240829183503.log,112,MockAMMToken,4205,3577,7782,65.0,0.092565,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MockAmmToken is ERC20 {
    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {}

    function mint(address account, uint256 amount) external {
        _mint(account, amount);
    }
}",87
RealWorld_BA_112_IStrategySwapper_RealWord_20240829182223.log,112,IStrategySwapper,5664,5121,10785,101.0,0.13074,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IStrategySwapper {
    function swapAllForWeth(address token) external;

    function swapAllWethForToken(address token_) external;

    function setSlippageTolerance(uint256 _slippageTolerance) external;

    function setSwapViaUniswap(address token_, bool swapViaUniswap_) external;

    function swapForWeth(address token, uint256 amount) external;

    function setCurvePool(address token_, address curvePool_) external;

    function amountOut(
        address tokenIn_,
        address tokenOut_,
        uint256 amountIn
    ) external view returns (uint256);
}",170
RealWorld_BA_112_BkdLocker_RealWord_20240829175608.log,112,BkdLocker,47372,5462,52834,96.0,0.3461,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""../libraries/ScaledMath.sol"";
import ""../libraries/Errors.sol"";
import ""../libraries/EnumerableExtensions.sol"";
import ""../interfaces/IBkdLocker.sol"";
import ""../interfaces/tokenomics/IBkdToken.sol"";
import ""../interfaces/tokenomics/IMigrationContract.sol"";
import ""./utils/Preparable.sol"";
import ""./access/Authorization.sol"";

contract BkdLocker is IBkdLocker, Authorization, Preparable {
    using ScaledMath for uint256;
    using SafeERC20 for IERC20;
    using EnumerableMapping for EnumerableMapping.AddressToUintMap;
    using EnumerableExtensions for EnumerableMapping.AddressToUintMap;

    bytes32 internal constant _START_BOOST = ""startBoost"";
    bytes32 internal constant _MAX_BOOST = ""maxBoost"";
    bytes32 internal constant _INCREASE_PERIOD = ""increasePeriod"";
    bytes32 internal constant _WITHDRAW_DELAY = ""withdrawDelay"";

    // User-specific data
    mapping(address => uint256) public balances;
    mapping(address => uint256) public boostFactors;
    mapping(address => uint256) public lastUpdated;
    mapping(address => WithdrawStash[]) public stashedGovTokens;
    mapping(address => uint256) public totalStashed;

    // Global data
    uint256 public totalLocked;
    uint256 public totalLockedBoosted;
    uint256 public lastMigrationEvent;
    EnumerableMapping.AddressToUintMap private _replacedRewardTokens;

    // Reward token data
    mapping(address => RewardTokenData) public rewardTokenData;
    address public rewardToken;
    IERC20 public immutable govToken;

    constructor(
        address _rewardToken,
        address _govToken,
        IRoleManager roleManager
    ) Authorization(roleManager) {
        rewardToken = _rewardToken;
        govToken = IBkdToken(_govToken);
    }

    function initialize(
        uint256 startBoost,
        uint256 maxBoost,
        uint256 increasePeriod,
        uint256 withdrawDelay
    ) external override onlyGovernance {
        require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED);
        _setConfig(_START_BOOST, startBoost);
        _setConfig(_MAX_BOOST, maxBoost);
        _setConfig(_INCREASE_PERIOD, increasePeriod);
        _setConfig(_WITHDRAW_DELAY, withdrawDelay);
    }

    /**
     * @notice Sets a new token to be the rewardToken. Fees are then accumulated in this token.
     * @dev Previously used rewardTokens can be set again here.
     */
    function migrate(address newRewardToken) external override onlyGovernance {
        _replacedRewardTokens.remove(newRewardToken);
        _replacedRewardTokens.set(rewardToken, block.timestamp);
        lastMigrationEvent = block.timestamp;
        rewardToken = newRewardToken;
    }

    /**
     * @notice Lock gov. tokens.
     * @dev The amount needs to be approved in advance.
     */
    function lock(uint256 amount) external override {
        return lockFor(msg.sender, amount);
    }

    /**
     * @notice Deposit fees (in the rewardToken) to be distributed to lockers of gov. tokens.
     * @dev `deposit` or `depositFor` needs to be called at least once before this function can be called
     * @param amount Amount of rewardToken to deposit.
     */
    function depositFees(uint256 amount) external {
        require(amount > 0, Error.INVALID_AMOUNT);
        require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);
        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);

        RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];

        curRewardTokenData.feeIntegral += amount.scaledDiv(totalLockedBoosted);
        curRewardTokenData.feeBalance += amount;
        emit FeesDeposited(amount);
    }

    function claimFees() external override {
        claimFees(rewardToken);
    }

    /**
     * @notice Checkpoint function to update user data, in particular the boost factor.
     */
    function userCheckpoint(address user) external override {
        _userCheckpoint(user, 0, balances[user]);
    }

    /**
     * @notice Prepare unlocking of locked gov. tokens.
     * @dev A delay is enforced and unlocking can only be executed after that.
     * @param amount Amount of gov. tokens to prepare for unlocking.
     */
    function prepareUnlock(uint256 amount) external override {
        require(
            totalStashed[msg.sender] + amount <= balances[msg.sender],
            ""Amount exceeds locked balance""
        );
        totalStashed[msg.sender] += amount;
        stashedGovTokens[msg.sender].push(
            WithdrawStash(block.timestamp + currentUInts256[_WITHDRAW_DELAY], amount)
        );
        emit WithdrawPrepared(msg.sender, amount);
    }

    /**
     * @notice Execute all prepared gov. token withdrawals.
     */
    function executeUnlocks() external override {
        uint256 totalAvailableToWithdraw = 0;
        WithdrawStash[] storage stashedWithdraws = stashedGovTokens[msg.sender];
        uint256 length = stashedWithdraws.length;
        require(length > 0, ""No entries"");
        uint256 i = length;
        while (i > 0) {
            i = i - 1;
            if (stashedWithdraws[i].releaseTime <= block.timestamp) {
                totalAvailableToWithdraw += stashedWithdraws[i].amount;

                stashedWithdraws[i] = stashedWithdraws[stashedWithdraws.length - 1];

                stashedWithdraws.pop();
            }
        }
        totalStashed[msg.sender] -= totalAvailableToWithdraw;
        uint256 newTotal = balances[msg.sender] - totalAvailableToWithdraw;
        _userCheckpoint(msg.sender, 0, newTotal);
        totalLocked -= totalAvailableToWithdraw;
        govToken.safeTransfer(msg.sender, totalAvailableToWithdraw);
        emit WithdrawExecuted(msg.sender, totalAvailableToWithdraw);
    }

    function getUserShare(address user) external view override returns (uint256) {
        return getUserShare(user, rewardToken);
    }

    /**
     * @notice Get the boosted locked balance for a user.
     * @dev This includes the gov. tokens queued for withdrawal.
     * @param user Address to get the boosted balance for.
     * @return boosted balance for user.
     */
    function boostedBalance(address user) external view override returns (uint256) {
        return balances[user].scaledMul(boostFactors[user]);
    }

    /**
     * @notice Get the vote weight for a user.
     * @dev This does not invlude the gov. tokens queued for withdrawal.
     * @param user Address to get the vote weight for.
     * @return vote weight for user.
     */
    function balanceOf(address user) external view override returns (uint256) {
        return (balances[user] - totalStashed[user]).scaledMul(boostFactors[user]);
    }

    /**
     * @notice Get the share of the total boosted locked balance for a user.
     * @dev This includes the gov. tokens queued for withdrawal.
     * @param user Address to get the share of the total boosted balance for.
     * @return share of the total boosted balance for user.
     */
    function getShareOfTotalBoostedBalance(address user) external view override returns (uint256) {
        return balances[user].scaledMul(boostFactors[user]).scaledDiv(totalLockedBoosted);
    }

    function getStashedGovTokens(address user)
        external
        view
        override
        returns (WithdrawStash[] memory)
    {
        return stashedGovTokens[user];
    }

    function claimableFees(address user) external view override returns (uint256) {
        return claimableFees(user, rewardToken);
    }

    /**
     * @notice Claim fees accumulated in the Locker.
     */
    function claimFees(address _rewardToken) public override {
        require(
            _rewardToken == rewardToken || _replacedRewardTokens.contains(_rewardToken),
            Error.INVALID_ARGUMENT
        );
        _userCheckpoint(msg.sender, 0, balances[msg.sender]);
        RewardTokenData storage curRewardTokenData = rewardTokenData[_rewardToken];
        uint256 claimable = curRewardTokenData.userShares[msg.sender];
        curRewardTokenData.userShares[msg.sender] = 0;
        curRewardTokenData.feeBalance -= claimable;
        IERC20(_rewardToken).safeTransfer(msg.sender, claimable);
        emit RewardsClaimed(msg.sender, _rewardToken, claimable);
    }

    /**
     * @notice Lock gov. tokens on behalf of another user.
     * @dev The amount needs to be approved in advance.
     * @param user Address of user to lock on behalf of.
     * @param amount Amount of gov. tokens to lock.
     */
    function lockFor(address user, uint256 amount) public override {
        govToken.safeTransferFrom(msg.sender, address(this), amount);
        _userCheckpoint(user, amount, balances[user] + amount);
        totalLocked += amount;
        emit Locked(user, amount);
    }

    function getUserShare(address user, address _rewardToken)
        public
        view
        override
        returns (uint256)
    {
        return rewardTokenData[_rewardToken].userShares[user];
    }

    function claimableFees(address user, address _rewardToken)
        public
        view
        override
        returns (uint256)
    {
        uint256 currentShare;
        uint256 userBalance = balances[user];
        RewardTokenData storage curRewardTokenData = rewardTokenData[_rewardToken];

        // Compute the share earned by the user since he last updated
        if (userBalance > 0) {
            currentShare += (curRewardTokenData.feeIntegral -
                curRewardTokenData.userFeeIntegrals[user]).scaledMul(
                    userBalance.scaledMul(boostFactors[user])
                );
        }
        return curRewardTokenData.userShares[user] + currentShare;
    }

    function computeNewBoost(
        address user,
        uint256 amountAdded,
        uint256 newTotal
    ) public view override returns (uint256) {
        uint256 newBoost;
        uint256 balance = balances[user];
        uint256 startBoost = currentUInts256[_START_BOOST];
        if (balance == 0 || newTotal == 0) {
            newBoost = startBoost;
        } else {
            uint256 maxBoost = currentUInts256[_MAX_BOOST];
            newBoost = boostFactors[user];
            newBoost += (block.timestamp - lastUpdated[user])
                .scaledDiv(currentUInts256[_INCREASE_PERIOD])
                .scaledMul(maxBoost - startBoost);
            if (newBoost > maxBoost) {
                newBoost = maxBoost;
            }
            if (newTotal <= balance) {
                return newBoost;
            }
            newBoost =
                newBoost.scaledMul(balance.scaledDiv(newTotal)) +
                startBoost.scaledMul(amountAdded.scaledDiv(newTotal));
        }
        return newBoost;
    }

    function _userCheckpoint(
        address user,
        uint256 amountAdded,
        uint256 newTotal
    ) internal {
        RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];

        // Compute the share earned by the user since he last updated
        uint256 userBalance = balances[user];
        if (userBalance > 0) {
            curRewardTokenData.userShares[user] += (curRewardTokenData.feeIntegral -
                curRewardTokenData.userFeeIntegrals[user]).scaledMul(
                    userBalance.scaledMul(boostFactors[user])
                );
        }

        // Update values for previous rewardTokens
        if (lastUpdated[user] < lastMigrationEvent && userBalance > 0) {
            uint256 length = _replacedRewardTokens.length();
            for (uint256 i = 0; i < length; i++) {
                (address token, uint256 replacedAt) = _replacedRewardTokens.at(i);
                if (lastUpdated[user] < replacedAt) {
                    RewardTokenData storage prevRewardTokenData = rewardTokenData[token];
                    prevRewardTokenData.userShares[user] += (prevRewardTokenData.feeIntegral -
                        prevRewardTokenData.userFeeIntegrals[user]).scaledMul(
                            userBalance.scaledMul(boostFactors[user])
                        );
                    prevRewardTokenData.userFeeIntegrals[user] = prevRewardTokenData.feeIntegral;
                }
            }
        }

        uint256 newBoost = computeNewBoost(user, amountAdded, newTotal);
        totalLockedBoosted =
            totalLockedBoosted +
            newTotal.scaledMul(newBoost) -
            balances[user].scaledMul(boostFactors[user]);

        // Update user values
        curRewardTokenData.userFeeIntegrals[user] = curRewardTokenData.feeIntegral;
        lastUpdated[user] = block.timestamp;
        boostFactors[user] = newBoost;
        balances[user] = newTotal;
    }
}",2752
RealWorld_BA_112_EnumerableMapping_RealWord_20240829200912.log,112,EnumerableMapping,48024,5294,53318,95.0,0.346,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

library EnumerableMapping {
    using EnumerableSet for EnumerableSet.Bytes32Set;

    // Code take from contracts/utils/structs/EnumerableMap.sol
    // because the helper functions are private

    // To implement this library for multiple types with as little code
    // repetition as possible, we write it in terms of a generic Map type with
    // bytes32 keys and values.
    // The Map implementation uses private functions, and user-facing
    // implementations (such as Uint256ToAddressMap) are just wrappers around
    // the underlying Map.
    // This means that we can only create new EnumerableMaps for types that fit
    // in bytes32.

    struct Map {
        // Storage of keys
        EnumerableSet.Bytes32Set _keys;
        mapping(bytes32 => bytes32) _values;
    }

    /**
     * @dev Adds a key-value pair to a map, or updates the value for an existing
     * key. O(1).
     *
     * Returns true if the key was added to the map, that is if it was not
     * already present.
     */
    function _set(
        Map storage map,
        bytes32 key,
        bytes32 value
    ) private returns (bool) {
        map._values[key] = value;
        return map._keys.add(key);
    }

    /**
     * @dev Removes a key-value pair from a map. O(1).
     *
     * Returns true if the key was removed from the map, that is if it was present.
     */
    function _remove(Map storage map, bytes32 key) private returns (bool) {
        delete map._values[key];
        return map._keys.remove(key);
    }

    /**
     * @dev Returns true if the key is in the map. O(1).
     */
    function _contains(Map storage map, bytes32 key) private view returns (bool) {
        return map._keys.contains(key);
    }

    /**
     * @dev Returns the number of key-value pairs in the map. O(1).
     */
    function _length(Map storage map) private view returns (uint256) {
        return map._keys.length();
    }

    /**
     * @dev Returns the key-value pair stored at position `index` in the map. O(1).
     *
     * Note that there are no guarantees on the ordering of entries inside the
     * array, and it may change when more entries are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {
        bytes32 key = map._keys.at(index);
        return (key, map._values[key]);
    }

    /**
     * @dev Tries to returns the value associated with `key`.  O(1).
     * Does not revert if `key` is not in the map.
     */
    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {
        bytes32 value = map._values[key];
        if (value == bytes32(0)) {
            return (_contains(map, key), bytes32(0));
        } else {
            return (true, value);
        }
    }

    /**
     * @dev Returns the value associated with `key`.  O(1).
     *
     * Requirements:
     *
     * - `key` must be in the map.
     */
    function _get(Map storage map, bytes32 key) private view returns (bytes32) {
        bytes32 value = map._values[key];
        require(value != 0 || _contains(map, key), ""EnumerableMap: nonexistent key"");
        return value;
    }

    // AddressToAddressMap

    struct AddressToAddressMap {
        Map _inner;
    }

    /**
     * @dev Adds a key-value pair to a map, or updates the value for an existing
     * key. O(1).
     *
     * Returns true if the key was added to the map, that is if it was not
     * already present.
     */
    function set(
        AddressToAddressMap storage map,
        address key,
        address value
    ) internal returns (bool) {
        return _set(map._inner, bytes32(uint256(uint160(key))), bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the key was removed from the map, that is if it was present.
     */
    function remove(AddressToAddressMap storage map, address key) internal returns (bool) {
        return _remove(map._inner, bytes32(uint256(uint160(key))));
    }

    /**
     * @dev Returns true if the key is in the map. O(1).
     */
    function contains(AddressToAddressMap storage map, address key) internal view returns (bool) {
        return _contains(map._inner, bytes32(uint256(uint160(key))));
    }

    /**
     * @dev Returns the number of elements in the map. O(1).
     */
    function length(AddressToAddressMap storage map) internal view returns (uint256) {
        return _length(map._inner);
    }

    /**
     * @dev Returns the element stored at position `index` in the set. O(1).
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(AddressToAddressMap storage map, uint256 index)
        internal
        view
        returns (address, address)
    {
        (bytes32 key, bytes32 value) = _at(map._inner, index);
        return (address(uint160(uint256(key))), address(uint160(uint256(value))));
    }

    /**
     * @dev Tries to returns the value associated with `key`.  O(1).
     * Does not revert if `key` is not in the map.
     *
     * _Available since v3.4._
     */
    function tryGet(AddressToAddressMap storage map, address key)
        internal
        view
        returns (bool, address)
    {
        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(uint256(uint160(key))));
        return (success, address(uint160(uint256(value))));
    }

    /**
     * @dev Returns the value associated with `key`.  O(1).
     *
     * Requirements:
     *
     * - `key` must be in the map.
     */
    function get(AddressToAddressMap storage map, address key) internal view returns (address) {
        return address(uint160(uint256(_get(map._inner, bytes32(uint256(uint160(key)))))));
    }

    // AddressToUintMap

    struct AddressToUintMap {
        Map _inner;
    }

    /**
     * @dev Adds a key-value pair to a map, or updates the value for an existing
     * key. O(1).
     *
     * Returns true if the key was added to the map, that is if it was not
     * already present.
     */
    function set(
        AddressToUintMap storage map,
        address key,
        uint256 value
    ) internal returns (bool) {
        return _set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the key was removed from the map, that is if it was present.
     */
    function remove(AddressToUintMap storage map, address key) internal returns (bool) {
        return _remove(map._inner, bytes32(uint256(uint160(key))));
    }

    /**
     * @dev Returns true if the key is in the map. O(1).
     */
    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {
        return _contains(map._inner, bytes32(uint256(uint160(key))));
    }

    /**
     * @dev Returns the number of elements in the map. O(1).
     */
    function length(AddressToUintMap storage map) internal view returns (uint256) {
        return _length(map._inner);
    }

    /**
     * @dev Returns the element stored at position `index` in the set. O(1).
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(AddressToUintMap storage map, uint256 index)
        internal
        view
        returns (address, uint256)
    {
        (bytes32 key, bytes32 value) = _at(map._inner, index);
        return (address(uint160(uint256(key))), uint256(value));
    }

    /**
     * @dev Tries to returns the value associated with `key`.  O(1).
     * Does not revert if `key` is not in the map.
     *
     * _Available since v3.4._
     */
    function tryGet(AddressToUintMap storage map, address key)
        internal
        view
        returns (bool, uint256)
    {
        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(uint256(uint160(key))));
        return (success, uint256(value));
    }

    /**
     * @dev Returns the value associated with `key`.  O(1).
     *
     * Requirements:
     *
     * - `key` must be in the map.
     */
    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {
        return uint256(_get(map._inner, bytes32(uint256(uint160(key)))));
    }

    // Bytes32ToUIntMap

    struct Bytes32ToUIntMap {
        Map _inner;
    }

    /**
     * @dev Adds a key-value pair to a map, or updates the value for an existing
     * key. O(1).
     *
     * Returns true if the key was added to the map, that is if it was not
     * already present.
     */
    function set(
        Bytes32ToUIntMap storage map,
        bytes32 key,
        uint256 value
    ) internal returns (bool) {
        return _set(map._inner, key, bytes32(value));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the key was removed from the map, that is if it was present.
     */
    function remove(Bytes32ToUIntMap storage map, bytes32 key) internal returns (bool) {
        return _remove(map._inner, key);
    }

    /**
     * @dev Returns true if the key is in the map. O(1).
     */
    function contains(Bytes32ToUIntMap storage map, bytes32 key) internal view returns (bool) {
        return _contains(map._inner, key);
    }

    /**
     * @dev Returns the number of elements in the map. O(1).
     */
    function length(Bytes32ToUIntMap storage map) internal view returns (uint256) {
        return _length(map._inner);
    }

    /**
     * @dev Returns the element stored at position `index` in the set. O(1).
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(Bytes32ToUIntMap storage map, uint256 index)
        internal
        view
        returns (bytes32, uint256)
    {
        (bytes32 key, bytes32 value) = _at(map._inner, index);
        return (key, uint256(value));
    }

    /**
     * @dev Tries to returns the value associated with `key`.  O(1).
     * Does not revert if `key` is not in the map.
     *
     * _Available since v3.4._
     */
    function tryGet(Bytes32ToUIntMap storage map, bytes32 key)
        internal
        view
        returns (bool, uint256)
    {
        (bool success, bytes32 value) = _tryGet(map._inner, key);
        return (success, uint256(value));
    }

    /**
     * @dev Returns the value associated with `key`.  O(1).
     *
     * Requirements:
     *
     * - `key` must be in the map.
     */
    function get(Bytes32ToUIntMap storage map, bytes32 key) internal view returns (uint256) {
        return uint256(_get(map._inner, key));
    }
}",2807
RealWorld_BA_112_TopUpKeeperHelper_RealWord_20240829191831.log,112,TopUpKeeperHelper,27619,5709,33328,91.0,0.252275,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/topup/ITopUpKeeperHelper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";

/**
 * This TopUp Keeper Helper.
 * It is a utility contract to help create Backd TopUp Keepers.
 * It exposes a view that allows the user to query a list of TopUp Positions that can be executed.
 */
contract TopUpKeeperHelper is ITopUpKeeperHelper {
    using EnumerableSet for EnumerableSet.AddressSet;

    ITopUpAction private immutable _topupAction;

    constructor(address topupAction_) {
        _topupAction = ITopUpAction(topupAction_);
    }

    /**
     * @notice Gets a list of topup positions that can be executed.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of topups to return in this pagination request.
     * @return topups List of topup positions that can be executed.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function getExecutableTopups(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (TopupData[] memory topups, uint256 nextCursor)
    {
        TopupData[] memory executableTopups = new TopupData[](howMany);
        uint256 topupsAdded;
        while (true) {
            (address[] memory users, ) = _topupAction.usersWithPositions(cursor, howMany);
            if (users.length == 0) return (_shortenTopups(executableTopups, topupsAdded), 0);
            for (uint256 i = 0; i < users.length; i++) {
                address user = users[i];
                ITopUpAction.RecordWithMeta[] memory positions = listPositions(user);
                for (uint256 j = 0; j < positions.length; j++) {
                    ITopUpAction.RecordWithMeta memory position = positions[j];
                    if (!_canExecute(user, position)) continue;
                    executableTopups[topupsAdded] = _positionToTopup(user, position);
                    topupsAdded++;
                    uint256 offset = j == positions.length - 1 ? 1 : 0;
                    if (topupsAdded == howMany) return (executableTopups, cursor + i + offset);
                }
            }
            cursor += howMany;
        }
    }

    /**
     * @notice Check if the action can be executed for the positions
     * of the given `keys`
     * @param keys Unique keys to check for
     * @return an array of boolean containing a result per input
     */
    function batchCanExecute(ITopUpAction.RecordKey[] calldata keys)
        external
        view
        override
        returns (bool[] memory)
    {
        bool[] memory results = new bool[](keys.length);
        for (uint256 i = 0; i < keys.length; i++) {
            ITopUpAction.RecordKey calldata key = keys[i];
            results[i] = canExecute(key);
        }
        return results;
    }

    /**
     * @notice Get a list of all positions the `payer` has registered.
     * @param payer Address to list position for.
     * @return Records of all registered positions.
     */
    function listPositions(address payer)
        public
        view
        override
        returns (ITopUpAction.RecordWithMeta[] memory)
    {
        ITopUpAction.RecordMeta[] memory userRecordsMeta = _topupAction.getUserPositions(payer);
        uint256 length = userRecordsMeta.length;
        ITopUpAction.RecordWithMeta[] memory result = new ITopUpAction.RecordWithMeta[](length);
        for (uint256 i = 0; i < length; i++) {
            bytes32 account = userRecordsMeta[i].account;
            bytes32 protocol = userRecordsMeta[i].protocol;
            ITopUpAction.Record memory record = _topupAction.getPosition(payer, account, protocol);
            result[i] = ITopUpAction.RecordWithMeta(account, protocol, record);
        }
        return result;
    }

    /**
     * @notice Check if action can be executed.
     * @param key Unique key of the account to check for
     * the key contains information about the payer, the account and the protocol
     * @return `true` if action can be executed, else `false.
     */
    function canExecute(ITopUpAction.RecordKey memory key) public view override returns (bool) {
        ITopUpAction.Record memory position = _topupAction.getPosition(
            key.payer,
            key.account,
            key.protocol
        );
        if (position.threshold == 0 || position.totalTopUpAmount == 0) {
            return false;
        }
        uint256 healthFactor = _topupAction.getHealthFactor(
            key.protocol,
            key.account,
            position.extra
        );
        return healthFactor < position.threshold;
    }

    /**
     * @dev Returns if a position can be executed.
     * @param user The user paying for the position.
     * @param position The position record with metadata.
     * @return 'true' if it can be executed, 'false' if not.
     */
    function _canExecute(address user, ITopUpAction.RecordWithMeta memory position)
        private
        view
        returns (bool)
    {
        return canExecute(ITopUpAction.RecordKey(user, position.account, position.protocol));
    }

    /**
     * @dev Converts from RecordWithMeta struct to TopupData struct.
     * @param user The user paying for the position.
     * @param position The position record with metadata.
     * @return The topup positions as a TopupData struct.
     */
    function _positionToTopup(address user, ITopUpAction.RecordWithMeta memory position)
        private
        pure
        returns (TopupData memory)
    {
        return TopupData(user, position.account, position.protocol, position.record);
    }

    /**
     * @dev Shortens a list of topups by truncating it to a given length.
     * @param topups The list of topups to shorten.
     * @param length The length to trucate the list of topups to.
     * @return The shortened list of topups.
     */
    function _shortenTopups(TopupData[] memory topups, uint256 length)
        private
        pure
        returns (TopupData[] memory)
    {
        TopupData[] memory shortened = new TopupData[](length);
        for (uint256 i = 0; i < length; i++) {
            shortened[i] = topups[i];
        }
        return shortened;
    }
}",1477
RealWorld_BA_112_MockTopUpActionFeeHandler_RealWord_20240829185103.log,112,MockTopUpActionFeeHandler,5876,4881,10757,76.0,0.127,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../actions/topup/TopUpActionFeeHandler.sol"";

contract MockTopUpActionFeeHandler is TopUpActionFeeHandler {
    constructor(
        IController _controller,
        address _actionContract,
        uint256 keeperFee,
        uint256 treasuryFee
    ) TopUpActionFeeHandler(_controller, _actionContract, keeperFee, treasuryFee) {}

    function callReportFees(
        address beneficiary,
        uint256 amount,
        address lpTokenAddress
    ) external {
        address keeperGauge = getKeeperGauge(lpTokenAddress);
        IKeeperGauge(keeperGauge).reportFees(beneficiary, amount, lpTokenAddress);
    }
}",164
RealWorld_BA_112_MockLpToken_RealWord_20240829185342.log,112,MockLpToken,4160,3550,7710,60.0,0.0918,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../LpToken.sol"";

contract MockLpToken is LpToken {
    // solhint-disable-next-line func-name-mixedcase
    function mint_for_testing(address account, uint256 mintAmount) external {
        _mint(account, mintAmount);
    }
}",79
RealWorld_BA_112_CTokenInterfaces_RealWord_20240829215059.log,112,CTokenInterfaces,42457,6033,48490,112.0,0.332945,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

import ""./ComptrollerInterface.sol"";
import ""./InterestRateModel.sol"";

contract CTokenStorage {
    /**
     * @dev Guard variable for re-entrancy checks
     */
    bool internal _notEntered;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint8 public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */

    uint256 internal constant borrowRateMaxMantissa = 0.0005e16;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint256 internal constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint256 internal initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint256 public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint256 public accrualBlockNumber;

    /**
     * @notice Accumulator of the total earned interest rate since the opening of the market
     */
    uint256 public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint256 public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint256 public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping(address => uint256) internal accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping(address => mapping(address => uint256)) internal transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint256 principal;
        uint256 interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) internal accountBorrows;
}

abstract contract CTokenInterface is CTokenStorage {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(
        uint256 cashPrior,
        uint256 interestAccumulated,
        uint256 borrowIndex,
        uint256 totalBorrows
    );

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint256 mintAmount, uint256 mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(
        address borrower,
        uint256 borrowAmount,
        uint256 accountBorrows,
        uint256 totalBorrows
    );

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(
        address payer,
        address borrower,
        uint256 repayAmount,
        uint256 accountBorrows,
        uint256 totalBorrows
    );

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(
        address liquidator,
        address borrower,
        uint256 repayAmount,
        address cTokenCollateral,
        uint256 seizeTokens
    );

    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(
        InterestRateModel oldInterestRateModel,
        InterestRateModel newInterestRateModel
    );

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint256 oldReserveFactorMantissa, uint256 newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are added
     */
    event ReservesAdded(address benefactor, uint256 addAmount, uint256 newTotalReserves);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint256 reduceAmount, uint256 newTotalReserves);

    /**
     * @notice EIP20 Transfer event
     */
    event Transfer(address indexed from, address indexed to, uint256 amount);

    /**
     * @notice EIP20 Approval event
     */
    event Approval(address indexed owner, address indexed spender, uint256 amount);

    /**
     * @notice Failure event
     */
    // event Failure(uint256 error, uint256 info, uint256 detail);

    /*** User Interface ***/

    function transfer(address dst, uint256 amount) external virtual returns (bool);

    function transferFrom(
        address src,
        address dst,
        uint256 amount
    ) external virtual returns (bool);

    function approve(address spender, uint256 amount) external virtual returns (bool);

    function allowance(address owner, address spender) external view virtual returns (uint256);

    function balanceOf(address owner) external view virtual returns (uint256);

    function balanceOfUnderlying(address owner) external virtual returns (uint256);

    function getAccountSnapshot(address account)
        external
        view
        virtual
        returns (
            uint256,
            uint256,
            uint256,
            uint256
        );

    function borrowRatePerBlock() external view virtual returns (uint256);

    function supplyRatePerBlock() external view virtual returns (uint256);

    function totalBorrowsCurrent() external virtual returns (uint256);

    function borrowBalanceCurrent(address account) external virtual returns (uint256);

    function borrowBalanceStored(address account) public view virtual returns (uint256);

    function exchangeRateCurrent() public virtual returns (uint256);

    function exchangeRateStored() public view virtual returns (uint256);

    function getCash() external view virtual returns (uint256);

    function accrueInterest() public virtual returns (uint256);

    function seize(
        address liquidator,
        address borrower,
        uint256 seizeTokens
    ) external virtual returns (uint256);

    /*** Admin Functions ***/

    function _setPendingAdmin(address payable newPendingAdmin) external virtual returns (uint256);

    function _acceptAdmin() external virtual returns (uint256);

    function _setComptroller(ComptrollerInterface newComptroller) public virtual returns (uint256);

    function _setReserveFactor(uint256 newReserveFactorMantissa) external virtual returns (uint256);

    function _reduceReserves(uint256 reduceAmount) external virtual returns (uint256);

    function _setInterestRateModel(InterestRateModel newInterestRateModel)
        public
        virtual
        returns (uint256);
}

contract CErc20Storage {
    /**
     * @notice Underlying asset for this CToken
     */
    address public underlying;
}

abstract contract CErc20Interface is CErc20Storage {
    /*** User Interface ***/

    function mint(uint256 mintAmount) external payable virtual returns (uint256);

    function redeem(uint256 redeemTokens) external virtual returns (uint256);

    function redeemUnderlying(uint256 redeemAmount) external virtual returns (uint256);

    function borrow(uint256 borrowAmount) external virtual returns (uint256);

    function repayBorrow(uint256 repayAmount) external virtual returns (uint256);

    function repayBorrowBehalf(address borrower, uint256 repayAmount)
        external
        virtual
        returns (uint256);

    function liquidateBorrow(
        address borrower,
        uint256 repayAmount,
        CTokenInterface cTokenCollateral
    ) external virtual returns (uint256);

    /*** Admin Functions ***/

    function _addReserves(uint256 addAmount) external virtual returns (uint256);
}

interface CEthInterface {
    /*** User Interface ***/

    function mint() external payable returns (uint256);

    function redeem(uint256 redeemTokens) external returns (uint256);

    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);

    function borrow(uint256 borrowAmount) external returns (uint256);

    function repayBorrow(uint256 repayAmount) external payable returns (uint256);

    function repayBorrowBehalf(address borrower, uint256 repayAmount)
        external
        payable
        returns (uint256);

    function liquidateBorrow(
        address borrower,
        uint256 repayAmount,
        CTokenInterface cTokenCollateral
    ) external payable returns (uint256);
}

contract CDelegationStorage {
    /**
     * @notice Implementation address for this contract
     */
    address public implementation;
}

abstract contract CDelegatorInterface is CDelegationStorage {
    /**
     * @notice Emitted when implementation is changed
     */
    event NewImplementation(address oldImplementation, address newImplementation);

    /**
     * @notice Called by the admin to update the implementation of the delegator
     * @param implementation_ The address of the new implementation for delegation
     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation
     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation
     */
    function _setImplementation(
        address implementation_,
        bool allowResign,
        bytes memory becomeImplementationData
    ) public virtual;
}

abstract contract CDelegateInterface is CDelegationStorage {
    /**
     * @notice Called by the delegator on a delegate to initialize it for duty
     * @dev Should revert if any issues arise which make it unfit for delegation
     * @param data The encoded bytes data for any initialization
     */
    function _becomeImplementation(bytes memory data) public virtual;

    /**
     * @notice Called by the delegator on a delegate to forfeit its responsibility
     */
    function _resignImplementation() public virtual;
}

abstract contract CEther {
    function repayBorrowBehalf(address borrower) external payable virtual returns (uint256);
}",2461
RealWorld_BA_112_UniswapRouter02_RealWord_20240829214606.log,112,UniswapRouter02,10646,5679,16325,116.0,0.16681,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface UniswapRouter02 {
    function swapTokensForExactTokens(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapETHForExactTokens(
        uint256 amountOut,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function swapExactTokensForETH(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function getAmountIn(
        uint256 amountOut,
        uint256 reserveIn,
        uint256 reserveOut
    ) external returns (uint256 amountIn);

    function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) external view returns (uint256 amountOut);

    function getAmountsIn(uint256 amountOut, address[] calldata path)
        external
        view
        returns (uint256[] memory amounts);

    function getAmountsOut(uint256 amountIn, address[] memory path)
        external
        view
        returns (uint256[] memory amounts);

    function getReserves(
        address factory,
        address tokenA,
        address tokenB
    ) external view returns (uint256 reserveA, uint256 reserveB);

    function WETH() external pure returns (address);
}

interface UniswapV2Pair {
    function getReserves()
        external
        view
        returns (
            uint112 _reserve0,
            uint112 _reserve1,
            uint32 _blockTimestampLast
        );
}

interface UniswapV2Factory {
    function getPair(address tokenA, address tokenB) external view returns (address pair);
}",467
RealWorld_BA_112_IBooster_RealWord_20240829212215.log,112,IBooster,6168,4937,11105,88.0,0.12958,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface IBooster {
    /**
     * @dev `_pid` is the ID of the Convex for a specific Curve LP token.
     */
    function deposit(
        uint256 _pid,
        uint256 _amount,
        bool _stake
    ) external returns (bool);

    function withdraw(uint256 _pid, uint256 _amount) external returns (bool);

    function withdrawAll(uint256 _pid) external returns (bool);

    function withdrawTo(
        uint256 _pid,
        uint256 _amount,
        address _to
    ) external returns (bool);

    function depositAll(uint256 _pid, bool _stake) external returns (bool);

    function poolInfo(uint256 pid)
        external
        view
        returns (
            address lpToken,
            address token,
            address gauge,
            address crvRewards,
            address stash,
            bool shutdown
        );
}",205
RealWorld_BA_112_ICurveCryptoSwap_RealWord_20240829212345.log,112,ICurveCryptoSwap,4349,5234,9583,93.0,0.126425,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface ICurveCryptoSwap {
    function exchange_underlying(
        uint256 i,
        uint256 j,
        uint256 dx,
        uint256 min_dy
    ) external returns (uint256);
}",60
RealWorld_BA_112_ISwapperRegistry_RealWord_20240829203157.log,112,ISwapperRegistry,4423,4298,8721,70.0,0.108075,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface ISwapperRegistry {
    function getSwapper(address fromToken, address toToken) external view returns (address);

    function swapperExists(address fromToken, address toToken) external view returns (bool);

    function getAllSwappableTokens(address token) external view returns (address[] memory);
}",85
RealWorld_BA_112_ILido_RealWord_20240829213947.log,112,ILido,22195,5480,27675,92.0,0.220575,"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>

// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.9;

/**
 * @title Liquid staking pool
 *
 * For the high-level description of the pool operation please refer to the paper.
 * Pool manages withdrawal keys and fees. It receives ether submitted by users on the ETH 1 side
 * and stakes it via the deposit_contract.sol contract. It doesn't hold ether on it's balance,
 * only a small portion (buffer) of it.
 * It also mints new tokens for rewards generated at the ETH 2.0 side.
 */
interface ILido {
    /**
     * @dev From ISTETH interface, because ""Interfaces cannot inherit"".
     */
    function totalSupply() external view returns (uint256);

    function getTotalShares() external view returns (uint256);

    /**
     * @notice Stop pool routine operations
     */
    function stop() external;

    /**
     * @notice Resume pool routine operations
     */
    function resume() external;

    event Stopped();
    event Resumed();

    /**
     * @notice Set fee rate to `_feeBasisPoints` basis points. The fees are accrued when oracles report staking results
     * @param _feeBasisPoints Fee rate, in basis points
     */
    function setFee(uint16 _feeBasisPoints) external;

    /**
     * @notice Set fee distribution: `_treasuryFeeBasisPoints` basis points go to the treasury, `_insuranceFeeBasisPoints` basis points go to the insurance fund, `_operatorsFeeBasisPoints` basis points go to node operators. The sum has to be 10 000.
     */
    function setFeeDistribution(
        uint16 _treasuryFeeBasisPoints,
        uint16 _insuranceFeeBasisPoints,
        uint16 _operatorsFeeBasisPoints
    ) external;

    /**
     * @notice Returns staking rewards fee rate
     */
    function getFee() external view returns (uint16 feeBasisPoints);

    /**
     * @notice Returns fee distribution proportion
     */
    function getFeeDistribution()
        external
        view
        returns (
            uint16 treasuryFeeBasisPoints,
            uint16 insuranceFeeBasisPoints,
            uint16 operatorsFeeBasisPoints
        );

    event FeeSet(uint16 feeBasisPoints);

    event FeeDistributionSet(
        uint16 treasuryFeeBasisPoints,
        uint16 insuranceFeeBasisPoints,
        uint16 operatorsFeeBasisPoints
    );

    /**
     * @notice Set credentials to withdraw ETH on ETH 2.0 side after the phase 2 is launched to `_withdrawalCredentials`
     * @dev Note that setWithdrawalCredentials discards all unused signing keys as the signatures are invalidated.
     * @param _withdrawalCredentials hash of withdrawal multisignature key as accepted by
     *        the deposit_contract.deposit function
     */
    function setWithdrawalCredentials(bytes32 _withdrawalCredentials) external;

    /**
     * @notice Returns current credentials to withdraw ETH on ETH 2.0 side after the phase 2 is launched
     */
    function getWithdrawalCredentials() external view returns (bytes memory);

    event WithdrawalCredentialsSet(bytes32 withdrawalCredentials);

    /**
     * @notice Ether on the ETH 2.0 side reported by the oracle
     * @param _epoch Epoch id
     * @param _eth2balance Balance in wei on the ETH 2.0 side
     */
    function pushBeacon(uint256 _epoch, uint256 _eth2balance) external;

    // User functions

    /**
     * @notice Adds eth to the pool
     * @return StETH Amount of StETH generated
     */
    function submit(address _referral) external payable returns (uint256 StETH);

    // Records a deposit made by a user
    event Submitted(address indexed sender, uint256 amount, address referral);

    // The `_amount` of ether was sent to the deposit_contract.deposit function.
    event Unbuffered(uint256 amount);

    /**
     * @notice Issues withdrawal request. Large withdrawals will be processed only after the phase 2 launch.
     * @param _amount Amount of StETH to burn
     * @param _pubkeyHash Receiving address
     */
    function withdraw(uint256 _amount, bytes32 _pubkeyHash) external;

    // Requested withdrawal of `etherAmount` to `pubkeyHash` on the ETH 2.0 side, `tokenAmount` burned by `sender`,
    // `sentFromBuffer` was sent on the current Ethereum side.
    event Withdrawal(
        address indexed sender,
        uint256 tokenAmount,
        uint256 sentFromBuffer,
        bytes32 indexed pubkeyHash,
        uint256 etherAmount
    );

    // Info functions

    /**
     * @notice Gets the amount of Ether controlled by the system
     */
    function getTotalPooledEther() external view returns (uint256);

    /**
     * @notice Gets the amount of Ether temporary buffered on this contract balance
     */
    function getBufferedEther() external view returns (uint256);

    /**
     * @notice Returns the key values related to Beacon-side
     * @return depositedValidators - number of deposited validators
     * @return beaconValidators - number of Lido's validators visible in the Beacon state, reported by oracles
     * @return beaconBalance - total amount of Beacon-side Ether (sum of all the balances of Lido validators)
     */
    function getBeaconStat()
        external
        view
        returns (
            uint256 depositedValidators,
            uint256 beaconValidators,
            uint256 beaconBalance
        );
}",1198
RealWorld_BA_112_MockStrategySwapper_RealWord_20240829181914.log,112,MockStrategySwapper,4513,3924,8437,64.0,0.101045,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./StrategySwapper.sol"";

contract MockStrategySwapper is StrategySwapper {
    constructor(address addressProvider_, uint256 slippageTolerance_)
        StrategySwapper(addressProvider_, slippageTolerance_)
    {}

    function overrideSlippageTolerance(uint256 slippageTolerance_) external {
        slippageTolerance = slippageTolerance_;
    }
}",103
RealWorld_BA_112_AddressProviderHelpers_RealWord_20240829200729.log,112,AddressProviderHelpers,11337,4994,16331,101.0,0.156565,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../interfaces/IGasBank.sol"";
import ""../interfaces/IVaultReserve.sol"";
import ""../interfaces/oracles/IOracleProvider.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/IRoleManager.sol"";
import ""../interfaces/tokenomics/IBkdToken.sol"";
import ""../interfaces/IController.sol"";

import ""./AddressProviderKeys.sol"";

library AddressProviderHelpers {
    /**
     * @return The address of the treasury.
     */
    function getTreasury(IAddressProvider provider) internal view returns (address) {
        return provider.getAddress(AddressProviderKeys._TREASURY_KEY);
    }

    /**
     * @return The gas bank.
     */
    function getGasBank(IAddressProvider provider) internal view returns (IGasBank) {
        return IGasBank(provider.getAddress(AddressProviderKeys._GAS_BANK_KEY));
    }

    /**
     * @return The address of the vault reserve.
     */
    function getVaultReserve(IAddressProvider provider) internal view returns (IVaultReserve) {
        return IVaultReserve(provider.getAddress(AddressProviderKeys._VAULT_RESERVE_KEY));
    }

    /**
     * @return The address of the swapperRegistry.
     */
    function getSwapperRegistry(IAddressProvider provider) internal view returns (address) {
        return provider.getAddress(AddressProviderKeys._SWAPPER_REGISTRY_KEY);
    }

    /**
     * @return The oracleProvider.
     */
    function getOracleProvider(IAddressProvider provider) internal view returns (IOracleProvider) {
        return IOracleProvider(provider.getAddress(AddressProviderKeys._ORACLE_PROVIDER_KEY));
    }

    /**
     * @return the address of the BKD locker
     */
    function getBKDLocker(IAddressProvider provider) internal view returns (address) {
        return provider.getAddress(AddressProviderKeys._BKD_LOCKER_KEY);
    }

    /**
     * @return the address of the BKD locker
     */
    function getRoleManager(IAddressProvider provider) internal view returns (IRoleManager) {
        return IRoleManager(provider.getAddress(AddressProviderKeys._ROLE_MANAGER_KEY));
    }

    /**
     * @return the controller
     */
    function getController(IAddressProvider provider) internal view returns (IController) {
        return IController(provider.getAddress(AddressProviderKeys._CONTROLLER_KEY));
    }
}",496
RealWorld_BA_112_EnumerableExtensions_RealWord_20240829200214.log,112,EnumerableExtensions,16937,5620,22557,111.0,0.197085,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""../libraries/EnumerableMapping.sol"";

library EnumerableExtensions {
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableMapping for EnumerableMapping.AddressToAddressMap;
    using EnumerableMapping for EnumerableMapping.AddressToUintMap;
    using EnumerableMapping for EnumerableMapping.Bytes32ToUIntMap;

    function toArray(EnumerableSet.AddressSet storage addresses)
        internal
        view
        returns (address[] memory)
    {
        uint256 len = addresses.length();
        address[] memory result = new address[](len);
        for (uint256 i = 0; i < len; i++) {
            result[i] = addresses.at(i);
        }
        return result;
    }

    function toArray(EnumerableSet.Bytes32Set storage values)
        internal
        view
        returns (bytes32[] memory)
    {
        uint256 len = values.length();
        bytes32[] memory result = new bytes32[](len);
        for (uint256 i = 0; i < len; i++) {
            result[i] = values.at(i);
        }
        return result;
    }

    function keyAt(EnumerableMapping.AddressToAddressMap storage map, uint256 index)
        internal
        view
        returns (address)
    {
        (address key, ) = map.at(index);
        return key;
    }

    function valueAt(EnumerableMapping.AddressToAddressMap storage map, uint256 index)
        internal
        view
        returns (address)
    {
        (, address value) = map.at(index);
        return value;
    }

    function keyAt(EnumerableMapping.AddressToUintMap storage map, uint256 index)
        internal
        view
        returns (address)
    {
        (address key, ) = map.at(index);
        return key;
    }

    function keyAt(EnumerableMapping.Bytes32ToUIntMap storage map, uint256 index)
        internal
        view
        returns (bytes32)
    {
        (bytes32 key, ) = map.at(index);
        return key;
    }

    function valueAt(EnumerableMapping.AddressToUintMap storage map, uint256 index)
        internal
        view
        returns (uint256)
    {
        (, uint256 value) = map.at(index);
        return value;
    }

    function keysArray(EnumerableMapping.AddressToAddressMap storage map)
        internal
        view
        returns (address[] memory)
    {
        uint256 len = map.length();
        address[] memory result = new address[](len);
        for (uint256 i = 0; i < len; i++) {
            result[i] = keyAt(map, i);
        }
        return result;
    }

    function valuesArray(EnumerableMapping.AddressToAddressMap storage map)
        internal
        view
        returns (address[] memory)
    {
        uint256 len = map.length();
        address[] memory result = new address[](len);
        for (uint256 i = 0; i < len; i++) {
            result[i] = valueAt(map, i);
        }
        return result;
    }

    function keysArray(EnumerableMapping.AddressToUintMap storage map)
        internal
        view
        returns (address[] memory)
    {
        uint256 len = map.length();
        address[] memory result = new address[](len);
        for (uint256 i = 0; i < len; i++) {
            result[i] = keyAt(map, i);
        }
        return result;
    }

    function keysArray(EnumerableMapping.Bytes32ToUIntMap storage map)
        internal
        view
        returns (bytes32[] memory)
    {
        uint256 len = map.length();
        bytes32[] memory result = new bytes32[](len);
        for (uint256 i = 0; i < len; i++) {
            result[i] = keyAt(map, i);
        }
        return result;
    }
}",857
RealWorld_BA_112_EthVault_RealWord_20240829195042.log,112,EthVault,8760,5337,14097,79.0,0.15054,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./Vault.sol"";

contract EthVault is Vault {
    using AddressProviderHelpers for IAddressProvider;

    address private constant _UNDERLYING = address(0);

    constructor(IController controller) Vault(controller) {}

    receive() external payable {}

    function initialize(
        address _pool,
        uint256 _debtLimit,
        uint256 _targetAllocation,
        uint256 _bound
    ) external virtual override initializer {
        _initialize(_pool, _debtLimit, _targetAllocation, _bound);
    }

    function getUnderlying() public pure override returns (address) {
        return _UNDERLYING;
    }

    function _transfer(address to, uint256 amount) internal override {
        payable(to).transfer(amount);
    }

    function _depositToReserve(uint256 amount) internal override {
        reserve.deposit{value: amount}(_UNDERLYING, amount);
    }

    function _depositToTreasury(uint256 amount) internal override {
        payable(addressProvider.getTreasury()).transfer(amount);
    }

    function _payStrategist(uint256 amount, address strategist) internal override {
        if (strategist == address(0)) return;
        ILiquidityPool(pool).depositFor{value: amount}(strategist, amount);
    }

    function _availableUnderlying() internal view override returns (uint256) {
        return address(this).balance;
    }
}",313
RealWorld_BA_112_IRewardBase_RealWord_20240829212717.log,112,IRewardBase,3977,4334,8311,82.0,0.106565,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

// NOTE: does not strictly but contains fucntions from `BaseRewardPool`
interface IRewardBase {
    function periodFinish() external view returns (uint256);
}",52
RealWorld_BA_112_BkdTriHopCvx_RealWord_20240829182020.log,112,BkdTriHopCvx,59392,5147,64539,121.0,0.3999,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./ConvexStrategyBase.sol"";
import ""../../interfaces/IERC20Full.sol"";

/**
 * This is the BkdTriHopCvx strategy, which is designed to be used by a Backd ERC20 Vault.
 * The strategy holds a given ERC20 underlying and allocates liquidity to Convex via a given Curve Pool.
 * The Curve Pools used are Meta Pools which first require getting an LP Token from another Curve Pool.
 * The strategy does a 'Hop' when depositing and withdrawing, by first getting the required LP Token, and then the final LP Token for Convex.
 * Rewards received on Convex (CVX, CRV), are sold in part for the underlying.
 * A share of earned CVX & CRV are retained on behalf of the Backd community to participate in governance.
 */
contract BkdTriHopCvx is ConvexStrategyBase {
    using ScaledMath for uint256;
    using SafeERC20 for IERC20;

    ICurveSwapEth public immutable curveHopPool; // Curve Pool to use for Hops
    IERC20 public immutable hopLp; // Curve Hop Pool LP Token
    uint256 public immutable curveHopIndex; // Underlying index in Curve Pool

    uint256 public hopImbalanceToleranceIn; // Maximum allowed slippage from Curve Hop Pool Imbalance for depositing
    uint256 public hopImbalanceToleranceOut; // Maximum allowed slippage from Curve Hop Pool Imbalance for withdrawing
    uint256 public decimalMultiplier; // Used for converting between underlying and LP

    event SetHopImbalanceToleranceIn(uint256 value); // Emitted after a succuessful setting of hop imbalance tolerance in
    event SetHopImbalanceToleranceOut(uint256 value); // Emitted after a succuessful setting of hop imbalance tolerance out

    constructor(
        address vault_,
        address strategist_,
        uint256 convexPid_,
        address curvePool_,
        uint256 curveIndex_,
        address curveHopPool_,
        uint256 curveHopIndex_,
        IAddressProvider addressProvider_,
        address strategySwapper_
    )
        ConvexStrategyBase(
            vault_,
            strategist_,
            convexPid_,
            curvePool_,
            curveIndex_,
            addressProvider_,
            strategySwapper_
        )
    {
        // Getting data from supporting contracts
        _validateCurvePool(curveHopPool_);
        (address lp_, , , , , ) = _BOOSTER.poolInfo(convexPid_);
        address hopLp_ = ICurveSwapEth(curvePool_).coins(curveIndex_);
        hopLp = IERC20(hopLp_);
        curveHopPool = ICurveSwapEth(curveHopPool_);
        address underlying_ = ICurveSwapEth(curveHopPool_).coins(curveHopIndex_);
        underlying = IERC20(underlying_);
        decimalMultiplier = 10**(18 - IERC20Full(underlying_).decimals());

        // Setting inputs
        curveHopIndex = curveHopIndex_;

        // Setting default values
        imbalanceToleranceIn = 0.001e18;
        imbalanceToleranceOut = 0.048e18;
        hopImbalanceToleranceIn = 0.001e18;
        hopImbalanceToleranceOut = 0.0015e18;

        // Approvals
        IERC20(underlying_).safeApprove(curveHopPool_, type(uint256).max);
        IERC20(hopLp_).safeApprove(curvePool_, type(uint256).max);
        IERC20(lp_).safeApprove(address(_BOOSTER), type(uint256).max);
    }

    /**
     * @notice Set hop imbalance tolerance for Curve Hop Pool deposits.
     * @dev Stored as a percent, e.g. 1% would be set as 0.01
     * @param _hopImbalanceToleranceIn New hop imbalance tolarance in.
     * @return True if successfully set.
     */
    function setHopImbalanceToleranceIn(uint256 _hopImbalanceToleranceIn)
        external
        onlyGovernance
        returns (bool)
    {
        hopImbalanceToleranceIn = _hopImbalanceToleranceIn;
        emit SetHopImbalanceToleranceIn(_hopImbalanceToleranceIn);
        return true;
    }

    /**
     * @notice Set hop imbalance tolerance for Curve Hop Pool withdrawals.
     * @dev Stored as a percent, e.g. 1% would be set as 0.01
     * @param _hopImbalanceToleranceOut New hop imbalance tolarance out.
     * @return True if successfully set.
     */
    function setHopImbalanceToleranceOut(uint256 _hopImbalanceToleranceOut)
        external
        onlyGovernance
        returns (bool)
    {
        hopImbalanceToleranceOut = _hopImbalanceToleranceOut;
        emit SetHopImbalanceToleranceOut(_hopImbalanceToleranceOut);
        return true;
    }

    /**
     * @notice Changes the Convex Pool used for farming yield, e.g. from FRAX to MIM.
     * @dev First withdraws all funds, then harvests any rewards, then changes pool, then deposits again.
     * @param convexPid_ The PID for the new Convex Pool.
     * @param curvePool_ The Curve Pool to deposit into to get the required LP Token for Convex staking.
     * @param curveIndex_ The index of the new Convex Pool Token in the new Curve Pool.
     */
    function changeConvexPool(
        uint256 convexPid_,
        address curvePool_,
        uint256 curveIndex_
    ) external onlyGovernance {
        _validateCurvePool(curvePool_);
        _harvest();
        _withdrawAllToHopLp();
        convexPid = convexPid_;
        curveIndex = curveIndex_;
        (address lp_, , , address rewards_, , ) = _BOOSTER.poolInfo(convexPid_);
        lp = IERC20(lp_);
        rewards = IRewardStaking(rewards_);
        curvePool = ICurveSwapEth(curvePool_);
        IERC20(hopLp).safeApprove(curvePool_, 0);
        IERC20(hopLp).safeApprove(curvePool_, type(uint256).max);
        IERC20(lp_).safeApprove(address(_BOOSTER), 0);
        IERC20(lp_).safeApprove(address(_BOOSTER), type(uint256).max);
        require(_deposit(), Error.DEPOSIT_FAILED);
    }

    function balance() public view override returns (uint256) {
        return
            _underlyingBalance() +
            _hopLpToUnderlying(_lpToHopLp(_stakedBalance() + _lpBalance()) + _hopLpBalance());
    }

    function name() public pure override returns (string memory) {
        return ""BkdTriHopCvx"";
    }

    function _deposit() internal override returns (bool) {
        require(msg.value == 0, Error.INVALID_VALUE);

        // Depositing into Curve Hop Pool
        uint256 underlyingBalance = _underlyingBalance();
        if (underlyingBalance > 0) {
            uint256[3] memory hopAmounts;
            hopAmounts[curveHopIndex] = underlyingBalance;
            curveHopPool.add_liquidity(hopAmounts, _minHopLpAcceptedFromDeposit(underlyingBalance));
        }

        // Depositing into Curve Pool
        uint256 hopLpBalance = _hopLpBalance();
        if (hopLpBalance > 0) {
            uint256[2] memory amounts;
            amounts[curveIndex] = hopLpBalance;
            curvePool.add_liquidity(amounts, _minLpAccepted(hopLpBalance));
        }

        // Depositing into Convex and Staking
        if (_lpBalance() == 0) return false;
        if (!_BOOSTER.depositAll(convexPid, true)) return false;
        return true;
    }

    function _withdraw(uint256 amount) internal override returns (bool) {
        // Transferring from idle balance if enough
        uint256 underlyingBalance = _underlyingBalance();
        if (underlyingBalance >= amount) {
            underlying.safeTransfer(vault, amount);
            emit Withdraw(amount);
            return true;
        }

        // Calculating needed amount of LP to withdraw
        uint256 requiredUnderlyingAmount = amount - underlyingBalance;
        uint256 maxHopLpBurned = _maxHopLpBurned(requiredUnderlyingAmount);
        uint256 requiredHopLpAmount = maxHopLpBurned - _hopLpBalance();
        uint256 maxLpBurned = _maxLpBurned(requiredHopLpAmount);
        uint256 requiredLpAmount = maxLpBurned - _lpBalance();

        // Unstaking needed LP Tokens from Convex
        if (!rewards.withdrawAndUnwrap(requiredLpAmount, false)) return false;

        // Removing needed liquidity from Curve Pool
        uint256[2] memory amounts;
        amounts[curveIndex] = requiredHopLpAmount;
        curvePool.remove_liquidity_imbalance(amounts, maxLpBurned);

        // Removing needed liquidity from Curve Hop Pool
        uint256[3] memory hopAmounts;
        hopAmounts[curveHopIndex] = requiredUnderlyingAmount;
        curveHopPool.remove_liquidity_imbalance(hopAmounts, maxHopLpBurned);

        // Sending underlying to vault
        underlying.safeTransfer(vault, amount);
        return true;
    }

    function _withdrawAll() internal override returns (uint256) {
        // Withdrawing all from Convex and converting to Hop LP Token
        _withdrawAllToHopLp();

        // Removing liquidity from Curve Hop Pool
        uint256 hopLpBalance = _hopLpBalance();
        if (hopLpBalance > 0) {
            curveHopPool.remove_liquidity_one_coin(
                hopLpBalance,
                int128(uint128(curveHopIndex)),
                _minUnderlyingAccepted(hopLpBalance)
            );
        }

        // Transferring underlying to vault
        uint256 underlyingBalance = _underlyingBalance();
        if (underlyingBalance == 0) return 0;
        underlying.safeTransfer(vault, underlyingBalance);
        return underlyingBalance;
    }

    function _underlyingBalance() internal view override returns (uint256) {
        return underlying.balanceOf(address(this));
    }

    /**
     * @dev Get the balance of the hop lp.
     */
    function _hopLpBalance() internal view returns (uint256) {
        return hopLp.balanceOf(address(this));
    }

    /**
     * @notice Calculates the minimum LP to accept when depositing underlying into Curve Pool.
     * @param _hopLpAmount Amount of Hop LP that is being deposited into Curve Pool.
     * @return The minimum LP balance to accept.
     */
    function _minLpAccepted(uint256 _hopLpAmount) internal view returns (uint256) {
        return _hopLpToLp(_hopLpAmount).scaledMul(ScaledMath.ONE - imbalanceToleranceIn);
    }

    /**
     * @notice Calculates the maximum LP to accept burning when withdrawing amount from Curve Pool.
     * @param _hopLpAmount Amount of Hop LP that is being widthdrawn from Curve Pool.
     * @return The maximum LP balance to accept burning.
     */
    function _maxLpBurned(uint256 _hopLpAmount) internal view returns (uint256) {
        return _hopLpToLp(_hopLpAmount).scaledMul(ScaledMath.ONE + imbalanceToleranceOut);
    }

    /**
     * @notice Calculates the minimum Hop LP to accept when burning LP tokens to withdraw from Curve Pool.
     * @param _lpAmount Amount of LP tokens being burned to withdraw from Curve Pool.
     * @return The mininum Hop LP balance to accept.
     */
    function _minHopLpAcceptedFromWithdraw(uint256 _lpAmount) internal view returns (uint256) {
        return _lpToHopLp(_lpAmount).scaledMul(ScaledMath.ONE - imbalanceToleranceOut);
    }

    /**
     * @notice Calculates the minimum Hop LP to accept when depositing underlying into Curve Hop Pool.
     * @param _underlyingAmount Amount of underlying that is being deposited into Curve Hop Pool.
     * @return The minimum Hop LP balance to accept.
     */
    function _minHopLpAcceptedFromDeposit(uint256 _underlyingAmount)
        internal
        view
        returns (uint256)
    {
        return
            _underlyingToHopLp(_underlyingAmount).scaledMul(
                ScaledMath.ONE - hopImbalanceToleranceIn
            );
    }

    /**
     * @notice Calculates the maximum Hop LP to accept burning when withdrawing amount from Curve Hop Pool.
     * @param _underlyingAmount Amount of underlying that is being widthdrawn from Curve Hop Pool.
     * @return The maximum Hop LP balance to accept burning.
     */
    function _maxHopLpBurned(uint256 _underlyingAmount) internal view returns (uint256) {
        return
            _underlyingToHopLp(_underlyingAmount).scaledMul(
                ScaledMath.ONE + hopImbalanceToleranceOut
            );
    }

    /**
     * @notice Calculates the minimum underlying to accept when burning Hop LP tokens to withdraw from Curve Hop Pool.
     * @param _hopLpAmount Amount of Hop LP tokens being burned to withdraw from Curve Hop Pool.
     * @return The mininum underlying balance to accept.
     */
    function _minUnderlyingAccepted(uint256 _hopLpAmount) internal view returns (uint256) {
        return
            _hopLpToUnderlying(_hopLpAmount).scaledMul(ScaledMath.ONE - hopImbalanceToleranceOut);
    }

    /**
     * @notice Converts an amount of underlying into their estimated Hop LP value.
     * @dev Uses get_virtual_price which is less suceptible to manipulation.
     *  But is also less accurate to how much could be withdrawn.
     * @param _underlyingAmount Amount of underlying to convert.
     * @return The estimated value in the Hop LP.
     */
    function _underlyingToHopLp(uint256 _underlyingAmount) internal view returns (uint256) {
        return (_underlyingAmount * decimalMultiplier).scaledDiv(curveHopPool.get_virtual_price());
    }

    /**
     * @notice Converts an amount of Hop LP into their estimated underlying value.
     * @dev Uses get_virtual_price which is less suceptible to manipulation.
     *  But is also less accurate to how much could be withdrawn.
     * @param _hopLpAmount Amount of Hop LP to convert.
     * @return The estimated value in the underlying.
     */
    function _hopLpToUnderlying(uint256 _hopLpAmount) internal view returns (uint256) {
        return (_hopLpAmount / decimalMultiplier).scaledMul(curveHopPool.get_virtual_price());
    }

    /**
     * @notice Converts an amount of LP into their estimated Hop LP value.
     * @dev Uses get_virtual_price which is less suceptible to manipulation.
     *  But is also less accurate to how much could be withdrawn.
     * @param _lpAmount Amount of underlying to convert.
     * @return The estimated value in the Hop LP.
     */
    function _lpToHopLp(uint256 _lpAmount) internal view returns (uint256) {
        return
            _lpAmount.scaledMul(curvePool.get_virtual_price()).scaledDiv(
                curveHopPool.get_virtual_price()
            );
    }

    /**
     * @notice Converts an amount of Hop LP into their estimated LP value.
     * @dev Uses get_virtual_price which is less suceptible to manipulation.
     *  But is also less accurate to how much could be withdrawn.
     * @param _hopLpAmount Amount of Hop LP to convert.
     * @return The estimated value in the LP.
     */
    function _hopLpToLp(uint256 _hopLpAmount) internal view returns (uint256) {
        return
            _hopLpAmount.scaledMul(curveHopPool.get_virtual_price()).scaledDiv(
                curvePool.get_virtual_price()
            );
    }

    /**
     * @dev Withdraw all underlying and convert to the Hop LP Token.
     */
    function _withdrawAllToHopLp() private {
        // Unstaking and withdrawing from Convex pool
        uint256 stakedBalance = _stakedBalance();
        if (stakedBalance > 0) {
            rewards.withdrawAndUnwrap(stakedBalance, false);
        }

        // Removing liquidity from Curve Pool
        uint256 lpBalance = _lpBalance();
        if (lpBalance > 0) {
            curvePool.remove_liquidity_one_coin(
                lpBalance,
                int128(uint128(curveIndex)),
                _minHopLpAcceptedFromWithdraw(lpBalance)
            );
        }
    }
}",3634
RealWorld_BA_112_CToken_RealWord_20240829212043.log,112,CToken,4923,4861,9784,90.0,0.121835,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

import ""./ComptrollerInterface.sol"";
import ""./CTokenInterfaces.sol"";
import ""./ErrorReporter.sol"";

/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
abstract contract CToken is CTokenInterface, CErc20Interface, TokenErrorReporter {

}

abstract contract CEthToken is CTokenInterface, CEthInterface, TokenErrorReporter {}",101
RealWorld_BA_112_ChainlinkUsdWrapper_RealWord_20240829180704.log,112,ChainlinkUsdWrapper,10058,5019,15077,88.0,0.15067,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../libraries/DecimalScale.sol"";

interface IChainlinkOracle {
    function latestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );

    function decimals() external view returns (uint8);
}

/**
 * Wrapper used for converting a Chainlink ETH Oracle to a USD Oracle.
 */
contract ChainlinkUsdWrapper is IChainlinkOracle {
    using DecimalScale for uint256;

    IChainlinkOracle private immutable _ethOracle =
        IChainlinkOracle(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);
    IChainlinkOracle private immutable _oracle;
    uint8 private immutable _decimals;

    constructor(address oracle_) {
        _oracle = IChainlinkOracle(oracle_);
        _decimals = IChainlinkOracle(oracle_).decimals();
    }

    function latestRoundData()
        external
        view
        override
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        (
            uint80 roundId_,
            int256 answer_,
            uint256 startedAt_,
            uint256 updatedAt_,
            uint80 answeredInRound_
        ) = _oracle.latestRoundData();
        return (roundId_, (answer_ * _ethPrice()) / 1e8, startedAt_, updatedAt_, answeredInRound_);
    }

    function decimals() external view override returns (uint8) {
        return _decimals;
    }

    function _ethPrice() private view returns (int256) {
        (, int256 answer, , , ) = _ethOracle.latestRoundData();
        return answer;
    }
}",414
RealWorld_BA_112_IMigrationContract_RealWord_20240829205241.log,112,IMigrationContract,3674,3981,7655,78.0,0.09799,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface IMigrationContract {
    function migrate(
        address user,
        uint256 balance,
        uint256 boost
    ) external;
}",46
RealWorld_BA_112_IGasBank_RealWord_20240829202723.log,112,IGasBank,5485,4873,10358,90.0,0.124885,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IGasBank {
    event Deposit(address indexed account, uint256 value);
    event Withdraw(address indexed account, address indexed receiver, uint256 value);

    function depositFor(address account) external payable;

    function withdrawUnused(address account) external;

    function withdrawFrom(address account, uint256 amount) external;

    function withdrawFrom(
        address account,
        address payable to,
        uint256 amount
    ) external;

    function balanceOf(address account) external view returns (uint256);
}",124
RealWorld_BA_112_Comptroller_RealWord_20240829211319.log,112,Comptroller,4712,4040,8752,77.0,0.10436,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

import ""./ComptrollerInterface.sol"";
import ""./ComptrollerStorage.sol"";

abstract contract Comptroller is ComptrollerV5Storage, ComptrollerInterface {
    function getAssetsIn(address account) external view virtual returns (CToken[] memory);

    function getAllMarkets() public view virtual returns (CToken[] memory);

    function isDeprecated(CToken cToken) public view virtual returns (bool);
}",104
RealWorld_BA_112_AmmGauge_RealWord_20240829194053.log,112,AmmGauge,24563,5736,30299,95.0,0.237535,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""../../interfaces/IController.sol"";
import ""../../interfaces/tokenomics/IAmmGauge.sol"";

import ""../../libraries/ScaledMath.sol"";
import ""../../libraries/Errors.sol"";
import ""../../libraries/AddressProviderHelpers.sol"";

import ""../access/Authorization.sol"";

contract AmmGauge is Authorization, IAmmGauge {
    using AddressProviderHelpers for IAddressProvider;
    using ScaledMath for uint256;
    using SafeERC20 for IERC20;

    IController public immutable controller;

    mapping(address => uint256) public balances;

    // All the data fields required for the staking tracking
    uint256 public ammStakedIntegral;
    uint256 public totalStaked;
    mapping(address => uint256) public perUserStakedIntegral;
    mapping(address => uint256) public perUserShare;

    address public immutable ammToken;
    bool public killed;
    uint48 public ammLastUpdated;

    event RewardClaimed(address indexed account, uint256 amount);

    constructor(IController _controller, address _ammToken)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        ammToken = _ammToken;
        controller = _controller;
        ammLastUpdated = uint48(block.timestamp);
    }

    /**
     * @notice Shut down the gauge.
     * @dev Accrued inflation can still be claimed from the gauge after shutdown.
     * @return `true` if successful.
     */
    function kill() external override returns (bool) {
        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);
        poolCheckpoint();
        killed = true;
        return true;
    }

    function claimRewards(address beneficiary) external virtual override returns (uint256) {
        require(
            msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );
        _userCheckpoint(beneficiary);
        uint256 amount = perUserShare[beneficiary];
        if (amount <= 0) return 0;
        perUserShare[beneficiary] = 0;
        controller.inflationManager().mintRewards(beneficiary, amount);
        emit RewardClaimed(beneficiary, amount);
        return amount;
    }

    function stake(uint256 amount) external virtual override returns (bool) {
        return stakeFor(msg.sender, amount);
    }

    function unstake(uint256 amount) external virtual override returns (bool) {
        return unstakeFor(msg.sender, amount);
    }

    function getAmmToken() external view override returns (address) {
        return ammToken;
    }

    function isAmmToken(address token) external view override returns (bool) {
        return token == ammToken;
    }

    function claimableRewards(address user) external view virtual override returns (uint256) {
        uint256 ammStakedIntegral_ = ammStakedIntegral;
        if (!killed && totalStaked > 0) {
            ammStakedIntegral_ += (controller.inflationManager().getAmmRateForToken(ammToken) *
                (block.timestamp - uint256(ammLastUpdated))).scaledDiv(totalStaked);
        }
        return
            perUserShare[user] +
            balances[user].scaledMul(ammStakedIntegral_ - perUserStakedIntegral[user]);
    }

    /**
     * @notice Stake amount of AMM token on behalf of another account.
     * @param account Account for which tokens will be staked.
     * @param amount Amount of token to stake.
     * @return `true` if success.
     */
    function stakeFor(address account, uint256 amount) public virtual returns (bool) {
        require(amount > 0, Error.INVALID_AMOUNT);

        _userCheckpoint(account);

        uint256 oldBal = IERC20(ammToken).balanceOf(address(this));
        IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = IERC20(ammToken).balanceOf(address(this));
        uint256 staked = newBal - oldBal;
        balances[account] += staked;
        totalStaked += staked;
        emit AmmStaked(account, ammToken, amount);
        return true;
    }

    /**
     * @notice Unstake amount of AMM token and send to another account.
     * @param dst Account to which unstaked AMM tokens will be sent.
     * @param amount Amount of token to unstake.
     * @return `true` if success.
     */
    function unstakeFor(address dst, uint256 amount) public virtual returns (bool) {
        require(amount > 0, Error.INVALID_AMOUNT);
        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);

        _userCheckpoint(msg.sender);

        uint256 oldBal = IERC20(ammToken).balanceOf(address(this));
        IERC20(ammToken).safeTransfer(dst, amount);
        uint256 newBal = IERC20(ammToken).balanceOf(address(this));
        uint256 unstaked = oldBal - newBal;
        balances[msg.sender] -= unstaked;
        totalStaked -= unstaked;
        emit AmmUnstaked(msg.sender, ammToken, amount);
        return true;
    }

    function poolCheckpoint() public virtual override returns (bool) {
        if (killed) {
            return false;
        }
        uint256 currentRate = controller.inflationManager().getAmmRateForToken(ammToken);
        // Update the integral of total token supply for the pool
        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);
        if (totalStaked > 0) {
            ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked);
        }
        ammLastUpdated = uint48(block.timestamp);
        return true;
    }

    function _userCheckpoint(address user) internal virtual returns (bool) {
        poolCheckpoint();
        perUserShare[user] += balances[user].scaledMul(
            ammStakedIntegral - perUserStakedIntegral[user]
        );
        perUserStakedIntegral[user] = ammStakedIntegral;
        return true;
    }
}",1342
RealWorld_BA_112_ITopUpHandler_RealWord_20240829204907.log,112,ITopUpHandler,7837,4993,12830,84.0,0.139045,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

/**
 * This interface should be implemented by protocols integrating with Backd
 * that require topping up a registered position
 */
interface ITopUpHandler {
    /**
     * @notice Tops up the account for the protocol associated with this handler
     * This is designed to be called using delegatecall and should therefore
     * not assume that storage will be available
     *
     * @param account account to be topped up
     * @param underlying underlying currency to be used for top up
     * @param amount amount to be topped up
     * @param extra arbitrary data that can be passed to the handler
     * @return true if the top up succeeded and false otherwise
     */
    function topUp(
        bytes32 account,
        address underlying,
        uint256 amount,
        bytes memory extra
    ) external returns (bool);

    /**
     * @notice Returns a factor for the user which should always be >= 1 for sufficiently
     *         colletaralized positions and should get closer to 1 when collaterization level decreases
     * This should be an aggregate value including all the collateral of the user
     * @param account account for which to get the factor
     */
    function getUserFactor(bytes32 account, bytes memory extra) external view returns (uint256);
}",292
RealWorld_BA_112_IInflationManager_RealWord_20240829205401.log,112,IInflationManager,14057,5817,19874,94.0,0.186625,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IInflationManager {
    event KeeperGaugeListed(address indexed pool, address indexed keeperGauge);
    event AmmGaugeListed(address indexed token, address indexed ammGauge);
    event KeeperGaugeDelisted(address indexed pool, address indexed keeperGauge);
    event AmmGaugeDelisted(address indexed token, address indexed ammGauge);

    /** Pool functions */

    function setKeeperGauge(address pool, address _keeperGauge) external returns (bool);

    function setAmmGauge(address token, address _ammGauge) external returns (bool);

    function getAllAmmGauges() external view returns (address[] memory);

    function getLpRateForStakerVault(address stakerVault) external view returns (uint256);

    function getKeeperRateForPool(address pool) external view returns (uint256);

    function getAmmRateForToken(address token) external view returns (uint256);

    function getKeeperWeightForPool(address pool) external view returns (uint256);

    function getAmmWeightForToken(address pool) external view returns (uint256);

    function getLpPoolWeight(address pool) external view returns (uint256);

    function getKeeperGaugeForPool(address pool) external view returns (address);

    function getAmmGaugeForToken(address token) external view returns (address);

    function isInflationWeightManager(address account) external view returns (bool);

    function removeStakerVaultFromInflation(address stakerVault, address lpToken) external;

    function addGaugeForVault(address lpToken) external returns (bool);

    function whitelistGauge(address gauge) external;

    function checkpointAllGauges() external returns (bool);

    function mintRewards(address beneficiary, uint256 amount) external;

    function addStrategyToDepositStakerVault(address depositStakerVault, address strategyPool)
        external
        returns (bool);

    /** Weight setter functions **/

    function prepareLpPoolWeight(address lpToken, uint256 newPoolWeight) external returns (bool);

    function prepareAmmTokenWeight(address token, uint256 newTokenWeight) external returns (bool);

    function prepareKeeperPoolWeight(address pool, uint256 newPoolWeight) external returns (bool);

    function executeLpPoolWeight(address lpToken) external returns (uint256);

    function executeAmmTokenWeight(address token) external returns (uint256);

    function executeKeeperPoolWeight(address pool) external returns (uint256);

    function batchPrepareLpPoolWeights(address[] calldata lpTokens, uint256[] calldata weights)
        external
        returns (bool);

    function batchPrepareAmmTokenWeights(address[] calldata tokens, uint256[] calldata weights)
        external
        returns (bool);

    function batchPrepareKeeperPoolWeights(address[] calldata pools, uint256[] calldata weights)
        external
        returns (bool);

    function batchExecuteLpPoolWeights(address[] calldata lpTokens) external returns (bool);

    function batchExecuteAmmTokenWeights(address[] calldata tokens) external returns (bool);

    function batchExecuteKeeperPoolWeights(address[] calldata pools) external returns (bool);
}",685
RealWorld_BA_112_VestedEscrow_RealWord_20240829193420.log,112,VestedEscrow,24119,5990,30109,102.0,0.240395,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

/*
Rewrite of Convex Finance's Vested Escrow
found at https://github.com/convex-eth/platform/blob/main/contracts/contracts/VestedEscrow.sol
Changes:
- remove safe math (default from Solidity >=0.8)
- remove claim and stake logic
- remove safeTransferFrom logic and add support for ""airdropped"" reward token
*/

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

import ""../../libraries/Errors.sol"";

contract EscrowTokenHolder {
    constructor(address rewardToken_) {
        IERC20(rewardToken_).approve(msg.sender, type(uint256).max);
    }
}

contract VestedEscrow is ReentrancyGuard {
    using SafeERC20 for IERC20;

    struct FundingAmount {
        address recipient;
        uint256 amount;
    }

    IERC20 public immutable rewardToken;
    address public admin;
    address public fundAdmin;

    uint256 public immutable startTime;
    uint256 public immutable endTime;
    uint256 public totalTime;
    uint256 public initialLockedSupply;
    uint256 public unallocatedSupply;
    bool public initializedSupply;

    mapping(address => uint256) public initialLocked;
    mapping(address => uint256) public totalClaimed;
    mapping(address => address) public holdingContract;

    event Fund(address indexed recipient, uint256 reward);
    event Claim(address indexed user, uint256 amount);

    constructor(
        address rewardToken_,
        uint256 starttime_,
        uint256 endtime_,
        address fundAdmin_
    ) {
        require(starttime_ >= block.timestamp, ""start must be future"");
        require(endtime_ > starttime_, ""end must be greater"");

        rewardToken = IERC20(rewardToken_);
        startTime = starttime_;
        endTime = endtime_;
        totalTime = endtime_ - starttime_;
        admin = msg.sender;
        fundAdmin = fundAdmin_;
    }

    function setAdmin(address _admin) external {
        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);
        admin = _admin;
    }

    function setFundAdmin(address _fundadmin) external {
        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);
        fundAdmin = _fundadmin;
    }

    function initializeUnallocatedSupply() external returns (bool) {
        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);
        require(!initializedSupply, ""Supply already initialized once"");
        unallocatedSupply = rewardToken.balanceOf(address(this));
        require(unallocatedSupply > 0, ""No reward tokens in contract"");
        initializedSupply = true;
        return true;
    }

    function fund(FundingAmount[] calldata amounts) external nonReentrant returns (bool) {
        require(msg.sender == fundAdmin || msg.sender == admin, Error.UNAUTHORIZED_ACCESS);
        require(initializedSupply, ""Supply must be initialized"");

        uint256 totalAmount = 0;
        for (uint256 i = 0; i < amounts.length; i++) {
            uint256 amount = amounts[i].amount;
            address holdingAddress = holdingContract[amounts[i].recipient];
            if (holdingAddress == address(0)) {
                holdingAddress = address(new EscrowTokenHolder(address(rewardToken)));
                holdingContract[amounts[i].recipient] = holdingAddress;
            }
            rewardToken.safeTransfer(holdingAddress, amount);
            initialLocked[amounts[i].recipient] = initialLocked[amounts[i].recipient] + amount;
            totalAmount = totalAmount + amount;
            emit Fund(amounts[i].recipient, amount);
        }

        initialLockedSupply = initialLockedSupply + totalAmount;
        unallocatedSupply = unallocatedSupply - totalAmount;
        return true;
    }

    function claim() external virtual {
        _claimUntil(msg.sender, block.timestamp);
    }

    function vestedSupply() external view returns (uint256) {
        return _totalVested();
    }

    function lockedSupply() external view returns (uint256) {
        return initialLockedSupply - _totalVested();
    }

    function vestedOf(address _recipient) external view virtual returns (uint256) {
        return _totalVestedOf(_recipient, block.timestamp);
    }

    function balanceOf(address _recipient) external view virtual returns (uint256) {
        return _balanceOf(_recipient, block.timestamp);
    }

    function lockedOf(address _recipient) external view virtual returns (uint256) {
        uint256 vested = _totalVestedOf(_recipient, block.timestamp);
        return initialLocked[_recipient] - vested;
    }

    function claim(address _recipient) public virtual nonReentrant {
        _claimUntil(_recipient, block.timestamp);
    }

    function _claimUntil(address _recipient, uint256 _time) internal {
        uint256 claimable = _balanceOf(msg.sender, _time);
        if (claimable == 0) return;
        totalClaimed[msg.sender] = totalClaimed[msg.sender] + claimable;
        rewardToken.safeTransferFrom(holdingContract[msg.sender], _recipient, claimable);

        emit Claim(msg.sender, claimable);
    }

    function _computeVestedAmount(uint256 locked, uint256 _time) internal view returns (uint256) {
        if (_time < startTime) {
            return 0;
        }
        uint256 elapsed = _time - startTime;
        return Math.min((locked * elapsed) / totalTime, locked);
    }

    function _totalVestedOf(address _recipient, uint256 _time) internal view returns (uint256) {
        return _computeVestedAmount(initialLocked[_recipient], _time);
    }

    function _totalVested() internal view returns (uint256) {
        return _computeVestedAmount(initialLockedSupply, block.timestamp);
    }

    function _balanceOf(address _recipient, uint256 _time) internal view returns (uint256) {
        uint256 vested = _totalVestedOf(_recipient, _time);
        return vested - totalClaimed[_recipient];
    }
}",1301
RealWorld_BA_112_MockInflationManager_RealWord_20240829185846.log,112,MockInflationManager,4627,4409,9036,74.0,0.111315,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../interfaces/tokenomics/IKeeperGauge.sol"";

import ""../tokenomics/InflationManager.sol"";

contract MockInflationManager is InflationManager {
    constructor(IAddressProvider addressProvider) InflationManager(addressProvider) {}

    function callKillKeeperGauge(address _keeperGauge) external {
        IKeeperGauge(_keeperGauge).kill();
    }
}",100
RealWorld_BA_112_AuthorizationBase_RealWord_20240829181316.log,112,AuthorizationBase,9074,4740,13814,76.0,0.14017,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../interfaces/IRoleManager.sol"";

import ""../../libraries/Errors.sol"";
import ""../../libraries/Roles.sol"";

/**
 * @notice Provides modifiers for authorization
 */
abstract contract AuthorizationBase {
    /**
     * @notice Only allows a sender with `role` to perform the given action
     */
    modifier onlyRole(bytes32 role) {
        require(_roleManager().hasRole(role, msg.sender), Error.UNAUTHORIZED_ACCESS);
        _;
    }

    /**
     * @notice Only allows a sender with GOVERNANCE role to perform the given action
     */
    modifier onlyGovernance() {
        require(_roleManager().hasRole(Roles.GOVERNANCE, msg.sender), Error.UNAUTHORIZED_ACCESS);
        _;
    }

    /**
     * @notice Only allows a sender with any of `roles` to perform the given action
     */
    modifier onlyRoles2(bytes32 role1, bytes32 role2) {
        require(_roleManager().hasAnyRole(role1, role2, msg.sender), Error.UNAUTHORIZED_ACCESS);
        _;
    }

    /**
     * @notice Only allows a sender with any of `roles` to perform the given action
     */
    modifier onlyRoles3(
        bytes32 role1,
        bytes32 role2,
        bytes32 role3
    ) {
        require(
            _roleManager().hasAnyRole(role1, role2, role3, msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );
        _;
    }

    function roleManager() external view virtual returns (IRoleManager) {
        return _roleManager();
    }

    function _roleManager() internal view virtual returns (IRoleManager);
}",366
RealWorld_BA_112_IDelegateRegistry_RealWord_20240829214804.log,112,IDelegateRegistry,4305,4231,8536,74.0,0.106145,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

/**
 * Full contract can be found here: https://github.com/gnosis/delegate-registry/blob/main/contracts/DelegateRegistry.sol
 */

interface IDelegateRegistry {
    function setDelegate(bytes32 id, address delegate) external;

    function clearDelegate(bytes32 id) external;
}",76
RealWorld_BA_112_ICvxCrvRewardsLocker_RealWord_20240829202120.log,112,ICvxCrvRewardsLocker,4596,4644,9240,79.0,0.11586,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface ICvxCrvRewardsLocker {
    function lockRewards() external returns (bool);

    function lockCvx() external;

    function lockCrv() external;

    function claimRewards(bool lockAndStake) external returns (bool);

    function stakeCvxCrv() external returns (bool);

    function processExpiredLocks(bool relock) external returns (bool);
}",104
RealWorld_BA_112_MockEthPool_RealWord_20240829184328.log,112,MockEthPool,10126,5013,15139,81.0,0.15089,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../pool/EthPool.sol"";

contract MockEthPool is EthPool {
    uint256 public currentTime;

    constructor(IController _controller) EthPool(_controller) {}

    function setMinWithdrawalFee(uint256 newFee) external onlyGovernance returns (bool) {
        _setConfig(_MIN_WITHDRAWAL_FEE_KEY, newFee);
        _checkFeeInvariants(newFee, getMaxWithdrawalFee());
        return true;
    }

    function setMaxWithdrawalFee(uint256 newFee) external onlyGovernance returns (bool) {
        _setConfig(_MAX_WITHDRAWAL_FEE_KEY, newFee);
        _checkFeeInvariants(getMinWithdrawalFee(), newFee);
        return true;
    }

    function setWithdrawalFeeDecreasePeriod(uint256 period) external onlyGovernance returns (bool) {
        _setConfig(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY, period);
        return true;
    }

    function setVault(address payable _vault) external {
        setVault(_vault, true);
    }

    function setMaxBackingReserveDeviationRatio(uint256 newRatio) external onlyGovernance {
        _setConfig(_RESERVE_DEVIATION_KEY, newRatio);
        _rebalanceVault();
    }

    function setRequiredBackingReserveRatio(uint256 newRatio) external onlyGovernance {
        _setConfig(_REQUIRED_RESERVES_KEY, newRatio);
        _rebalanceVault();
    }

    function setTime(uint256 _currentTime) external {
        currentTime = _currentTime;
    }

    function setVault(address payable _vault, bool updateAddressProvider) public onlyGovernance {
        if (updateAddressProvider) {
            addressProvider.updateVault(currentAddresses[_VAULT_KEY], _vault);
        }
        _setConfig(_VAULT_KEY, _vault);
    }

    function _getTime() internal view override returns (uint256) {
        return currentTime == 0 ? block.timestamp : currentTime;
    }
}",427
RealWorld_BA_112_MockErc20_RealWord_20240829183848.log,112,MockErc20,7014,4600,11614,89.0,0.12707,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MockErc20 is ERC20 {
    uint8 internal _decimals;

    constructor(uint8 decimals_) ERC20(""mock"", ""MOK"") {
        _decimals = decimals_;
    }

    function mintFor(address account, uint256 amount) external returns (bool) {
        _mint(account, amount);
        return true;
    }

    function mint(uint256 amount) external {
        _mint(msg.sender, amount);
    }

    /**
     * @dev Uses same function name as `MintableForkToken` from Brownie-Token-Tester, which makes
     *      it cleaner in tests to use this both in fork and dev mode
     */
    // solhint-disable-next-line func-name-mixedcase
    function mint_for_testing(address account, uint256 amount) external {
        _mint(account, amount);
    }

    function decimals() public view virtual override returns (uint8) {
        return _decimals;
    }
}",237
RealWorld_BA_112_ISwapper_RealWord_20240829203737.log,112,ISwapper,4300,4655,8955,75.0,0.1146,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface ISwapper {
    function swap(
        address fromToken,
        address toToken,
        uint256 swapAmount,
        uint256 minAmount
    ) external returns (uint256);

    function getRate(address fromToken, address toToken) external view returns (uint256);
}",82
RealWorld_BA_112_AddressProvider_RealWord_20240829175746.log,112,AddressProvider,55581,5629,61210,96.0,0.390485,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

import ""../interfaces/IGasBank.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/IStakerVault.sol"";
import ""../interfaces/oracles/IOracleProvider.sol"";

import ""../libraries/EnumerableExtensions.sol"";
import ""../libraries/EnumerableMapping.sol"";
import ""../libraries/AddressProviderKeys.sol"";
import ""../libraries/AddressProviderMeta.sol"";
import ""../libraries/Roles.sol"";

import ""./access/AuthorizationBase.sol"";
import ""./utils/Preparable.sol"";

// solhint-disable ordering

contract AddressProvider is IAddressProvider, AuthorizationBase, Initializable, Preparable {
    using EnumerableMapping for EnumerableMapping.AddressToAddressMap;
    using EnumerableMapping for EnumerableMapping.Bytes32ToUIntMap;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using EnumerableExtensions for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableMapping.AddressToAddressMap;
    using EnumerableExtensions for EnumerableMapping.Bytes32ToUIntMap;
    using AddressProviderMeta for AddressProviderMeta.Meta;

    // LpToken -> stakerVault
    EnumerableMapping.AddressToAddressMap internal _stakerVaults;

    EnumerableSet.AddressSet internal _whiteListedFeeHandlers;

    // value is encoded as (bool freezable, bool frozen)
    EnumerableMapping.Bytes32ToUIntMap internal _addressKeyMetas;

    EnumerableSet.AddressSet internal _actions; // list of all actions ever registered

    EnumerableSet.AddressSet internal _vaults; // list of all active vaults

    EnumerableMapping.AddressToAddressMap internal _tokenToPools;

    constructor(address treasury) {
        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, false);
        _addressKeyMetas.set(AddressProviderKeys._TREASURY_KEY, meta.toUInt());
        _setConfig(AddressProviderKeys._TREASURY_KEY, treasury);
    }

    function initialize(address roleManager) external initializer {
        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, true);
        _addressKeyMetas.set(AddressProviderKeys._ROLE_MANAGER_KEY, meta.toUInt());
        _setConfig(AddressProviderKeys._ROLE_MANAGER_KEY, roleManager);
    }

    function getKnownAddressKeys() external view returns (bytes32[] memory) {
        return _addressKeyMetas.keysArray();
    }

    function addFeeHandler(address feeHandler) external onlyGovernance returns (bool) {
        require(!_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_WHITELISTED);
        _whiteListedFeeHandlers.add(feeHandler);
        return true;
    }

    function removeFeeHandler(address feeHandler) external onlyGovernance returns (bool) {
        require(_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_NOT_WHITELISTED);
        _whiteListedFeeHandlers.remove(feeHandler);
        return true;
    }

    /**
     * @notice Adds action.
     * @param action Address of action to add.
     */
    function addAction(address action) external onlyGovernance returns (bool) {
        bool result = _actions.add(action);
        if (result) {
            emit ActionListed(action);
        }
        return result;
    }

    /**
     * @notice Adds pool.
     * @param pool Address of pool to add.
     */
    function addPool(address pool)
        external
        override
        onlyRoles2(Roles.POOL_FACTORY, Roles.GOVERNANCE)
    {
        require(pool != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);

        ILiquidityPool ipool = ILiquidityPool(pool);
        address poolToken = ipool.getLpToken();
        require(poolToken != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        if (_tokenToPools.set(poolToken, pool)) {
            address vault = address(ipool.getVault());
            if (vault != address(0)) {
                _vaults.add(vault);
            }
            emit PoolListed(pool);
        }
    }

    /**
     * @notice Delists pool.
     * @param pool Address of pool to delist.
     * @return `true` if successful.
     */
    function removePool(address pool) external override onlyRole(Roles.CONTROLLER) returns (bool) {
        address lpToken = ILiquidityPool(pool).getLpToken();
        bool removed = _tokenToPools.remove(lpToken);
        if (removed) {
            address vault = address(ILiquidityPool(pool).getVault());
            if (vault != address(0)) {
                _vaults.remove(vault);
            }
            emit PoolDelisted(pool);
        }

        return removed;
    }

    /** Vault functions  */

    /**
     * @notice returns all the registered vaults
     */
    function allVaults() external view returns (address[] memory) {
        return _vaults.toArray();
    }

    /**
     * @notice returns the vault at the given index
     */
    function getVaultAtIndex(uint256 index) external view returns (address) {
        return _vaults.at(index);
    }

    /**
     * @notice returns the number of vaults
     */
    function vaultsCount() external view returns (uint256) {
        return _vaults.length();
    }

    function isVault(address vault) external view returns (bool) {
        return _vaults.contains(vault);
    }

    function updateVault(address previousVault, address newVault) external onlyRole(Roles.POOL) {
        if (previousVault != address(0)) {
            _vaults.remove(previousVault);
        }
        if (newVault != address(0)) {
            _vaults.add(newVault);
        }
        emit VaultUpdated(previousVault, newVault);
    }

    /**
     * @notice Returns the address for the given key
     */
    function getAddress(bytes32 key) public view returns (address) {
        require(_addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);
        return currentAddresses[key];
    }

    /**
     * @notice Returns the address for the given key
     * @dev if `checkExists` is true, it will fail if the key does not exist
     */
    function getAddress(bytes32 key, bool checkExists) public view returns (address) {
        require(!checkExists || _addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);
        return currentAddresses[key];
    }

    /**
     * @notice returns the address metadata for the given key
     */
    function getAddressMeta(bytes32 key) public view returns (AddressProviderMeta.Meta memory) {
        (bool exists, uint256 metadata) = _addressKeyMetas.tryGet(key);
        require(exists, Error.ADDRESS_DOES_NOT_EXIST);
        return AddressProviderMeta.fromUInt(metadata);
    }

    function initializeAddress(bytes32 key, address initialAddress) external {
        initializeAddress(key, initialAddress, false);
    }

    /**
     * @notice Initializes an address
     * @param key Key to initialize
     * @param initialAddress Address for `key`
     */
    function initializeAddress(
        bytes32 key,
        address initialAddress,
        bool freezable
    ) public override onlyGovernance {
        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(freezable, false);
        _initializeAddress(key, initialAddress, meta);
    }

    /**
     * @notice Initializes and freezes address
     * @param key Key to initialize
     * @param initialAddress Address for `key`
     */
    function initializeAndFreezeAddress(bytes32 key, address initialAddress)
        external
        override
        onlyGovernance
    {
        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, true);
        _initializeAddress(key, initialAddress, meta);
    }

    /**
     * @notice Freezes a configuration key, making it immutable
     * @param key Key to feeze
     */
    function freezeAddress(bytes32 key) external override onlyGovernance {
        AddressProviderMeta.Meta memory meta = getAddressMeta(key);
        require(!meta.frozen, Error.ADDRESS_FROZEN);
        require(meta.freezable, Error.INVALID_ARGUMENT);
        meta.frozen = true;
        _addressKeyMetas.set(key, meta.toUInt());
    }

    /**
     * @notice Prepare update of an address
     * @param key Key to update
     * @param newAddress New address for `key`
     * @return `true` if successful.
     */
    function prepareAddress(bytes32 key, address newAddress)
        external
        override
        onlyGovernance
        returns (bool)
    {
        AddressProviderMeta.Meta memory meta = getAddressMeta(key);
        require(!meta.frozen, Error.ADDRESS_FROZEN);
        return _prepare(key, newAddress);
    }

    /**
     * @notice Execute update of `key`
     * @return New address.
     */
    function executeAddress(bytes32 key) external override returns (address) {
        AddressProviderMeta.Meta memory meta = getAddressMeta(key);
        require(!meta.frozen, Error.ADDRESS_FROZEN);
        return _executeAddress(key);
    }

    /**
     * @notice Reset `key`
     * @return true if it was reset
     */
    function resetAddress(bytes32 key) external onlyGovernance returns (bool) {
        return _resetAddressConfig(key);
    }

    /**
     * @notice Add a new staker vault and add it's lpGauge if set in vault.
     * @dev This fails if the token of the staker vault is the token of an existing staker vault.
     * @param stakerVault Vault to add.
     * @return `true` if successful.
     */
    function addStakerVault(address stakerVault)
        external
        override
        onlyRole(Roles.CONTROLLER)
        returns (bool)
    {
        address token = IStakerVault(stakerVault).getToken();
        require(token != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        require(!_stakerVaults.contains(token), Error.STAKER_VAULT_EXISTS);
        _stakerVaults.set(token, stakerVault);
        emit StakerVaultListed(stakerVault);
        return true;
    }

    function isWhiteListedFeeHandler(address feeHandler) external view override returns (bool) {
        return _whiteListedFeeHandlers.contains(feeHandler);
    }

    /**
     * @notice Get the liquidity pool for a given token
     * @dev Does not revert if the pool deos not exist
     * @param token Token for which to get the pool.
     * @return Pool address.
     */
    function safeGetPoolForToken(address token) external view override returns (address) {
        (, address poolAddress) = _tokenToPools.tryGet(token);
        return poolAddress;
    }

    /**
     * @notice Get the liquidity pool for a given token
     * @dev Reverts if the pool deos not exist
     * @param token Token for which to get the pool.
     * @return Pool address.
     */
    function getPoolForToken(address token) external view override returns (ILiquidityPool) {
        (bool exists, address poolAddress) = _tokenToPools.tryGet(token);
        require(exists, Error.ADDRESS_NOT_FOUND);
        return ILiquidityPool(poolAddress);
    }

    /**
     * @notice Get list of all action addresses.
     * @return Array with action addresses.
     */
    function allActions() external view override returns (address[] memory) {
        return _actions.toArray();
    }

    /**
     * @notice Check whether an address is an action.
     * @param action Address to check whether it is action.
     * @return True if address is an action.
     */
    function isAction(address action) external view override returns (bool) {
        return _actions.contains(action);
    }

    /**
     * @notice Check whether an address is an pool.
     * @param pool Address to check whether it is a pool.
     * @return True if address is a pool.
     */
    function isPool(address pool) external view returns (bool) {
        address lpToken = ILiquidityPool(pool).getLpToken();
        (bool exists, address poolAddress) = _tokenToPools.tryGet(lpToken);
        return exists && pool == poolAddress;
    }

    /**
     * @notice Get list of all pool addresses.
     * @return Array with pool addresses.
     */
    function allPools() external view override returns (address[] memory) {
        return _tokenToPools.valuesArray();
    }

    /**
     * @notice returns the pool at the given index
     */
    function getPoolAtIndex(uint256 index) external view returns (address) {
        return _tokenToPools.valueAt(index);
    }

    /**
     * @notice returns the number of pools
     */
    function poolsCount() external view returns (uint256) {
        return _tokenToPools.length();
    }

    /**
     * @notice Returns all the staker vaults.
     */
    function allStakerVaults() external view override returns (address[] memory) {
        return _stakerVaults.valuesArray();
    }

    /**
     * @notice Get the staker vault for a given token
     * @dev There can only exist one staker vault per unique token.
     * @param token Token for which to get the vault.
     * @return Vault address.
     */
    function getStakerVault(address token) external view override returns (address) {
        return _stakerVaults.get(token);
    }

    /**
     * @notice Tries to get the staker vault for a given token but does not throw if it does not exist
     * @return A boolean set to true if the vault exists and the vault address.
     */
    function tryGetStakerVault(address token) external view override returns (bool, address) {
        return _stakerVaults.tryGet(token);
    }

    /**
     * @notice Check if a vault is registered (exists).
     * @param stakerVault Address of staker vault to check.
     * @return `true` if registered, `false` if not.
     */
    function isStakerVaultRegistered(address stakerVault) external view override returns (bool) {
        address token = IStakerVault(stakerVault).getToken();
        return isStakerVault(stakerVault, token);
    }

    function isStakerVault(address stakerVault, address token) public view override returns (bool) {
        (bool exists, address vault) = _stakerVaults.tryGet(token);
        return exists && vault == stakerVault;
    }

    function _roleManager() internal view override returns (IRoleManager) {
        return IRoleManager(getAddress(AddressProviderKeys._ROLE_MANAGER_KEY));
    }

    function _initializeAddress(
        bytes32 key,
        address initialAddress,
        AddressProviderMeta.Meta memory meta
    ) internal {
        require(!_addressKeyMetas.contains(key), Error.INVALID_ARGUMENT);
        _addKnownAddressKey(key, meta);
        _setConfig(key, initialAddress);
    }

    function _addKnownAddressKey(bytes32 key, AddressProviderMeta.Meta memory meta) internal {
        require(_addressKeyMetas.set(key, meta.toUInt()), Error.INVALID_ARGUMENT);
        emit KnownAddressKeyAdded(key);
    }
}",3272
RealWorld_BA_112_Controller_RealWord_20240829175233.log,112,Controller,18696,5711,24407,105.0,0.2077,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../interfaces/actions/IAction.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/IController.sol"";
import ""../interfaces/IStakerVault.sol"";
import ""../interfaces/pool/ILiquidityPool.sol"";
import ""../interfaces/tokenomics/IInflationManager.sol"";

import ""../libraries/AddressProviderHelpers.sol"";

import ""./utils/Preparable.sol"";
import ""./access/Authorization.sol"";

contract Controller is IController, Authorization, Preparable {
    using AddressProviderHelpers for IAddressProvider;

    IAddressProvider public immutable override addressProvider;

    IInflationManager public inflationManager;

    bytes32 internal constant _KEEPER_REQUIRED_STAKED_BKD = ""KEEPER_REQUIRED_STAKED_BKD"";

    constructor(IAddressProvider _addressProvider)
        Authorization(_addressProvider.getRoleManager())
    {
        addressProvider = _addressProvider;
    }

    function setInflationManager(address _inflationManager) external onlyGovernance {
        require(address(inflationManager) == address(0), Error.ADDRESS_ALREADY_SET);
        require(_inflationManager != address(0), Error.INVALID_ARGUMENT);
        inflationManager = IInflationManager(_inflationManager);
    }

    function addStakerVault(address stakerVault)
        external
        override
        onlyRoles2(Roles.GOVERNANCE, Roles.POOL_FACTORY)
        returns (bool)
    {
        if (!addressProvider.addStakerVault(stakerVault)) {
            return false;
        }
        if (address(inflationManager) != address(0)) {
            address lpGauge = IStakerVault(stakerVault).getLpGauge();
            if (lpGauge != address(0)) {
                inflationManager.whitelistGauge(lpGauge);
            }
        }
        return true;
    }

    /**
     * @notice Delists pool.
     * @param pool Address of pool to delist.
     * @return `true` if successful.
     */
    function removePool(address pool) external override onlyGovernance returns (bool) {
        if (!addressProvider.removePool(pool)) {
            return false;
        }
        address lpToken = ILiquidityPool(pool).getLpToken();

        if (address(inflationManager) != address(0)) {
            (bool exists, address stakerVault) = addressProvider.tryGetStakerVault(lpToken);
            if (exists) {
                inflationManager.removeStakerVaultFromInflation(stakerVault, lpToken);
            }
        }

        return true;
    }

    /**
     * @notice Prepares the minimum amount of staked BKD required by a keeper
     */
    function prepareKeeperRequiredStakedBKD(uint256 amount) external override onlyGovernance {
        require(addressProvider.getBKDLocker() != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        _prepare(_KEEPER_REQUIRED_STAKED_BKD, amount);
    }

    /**
     * @notice Sets the minimum amount of staked BKD required by a keeper to the prepared value
     */
    function executeKeeperRequiredStakedBKD() external override {
        _executeUInt256(_KEEPER_REQUIRED_STAKED_BKD);
    }

    /**
     * @notice Returns true if the given keeper has enough staked BKD to execute actions
     */
    function canKeeperExecuteAction(address keeper) external view override returns (bool) {
        uint256 requiredBKD = getKeeperRequiredStakedBKD();
        return
            requiredBKD == 0 ||
            IERC20(addressProvider.getBKDLocker()).balanceOf(keeper) >= requiredBKD;
    }

    /**
     * @return Returns the minimum amount of staked BKD required by a keeper
     */
    function getKeeperRequiredStakedBKD() public view override returns (uint256) {
        return currentUInts256[_KEEPER_REQUIRED_STAKED_BKD];
    }

    /**
     * @return the total amount of ETH require by `payer` to cover the fees for
     * positions registered in all actions
     */
    function getTotalEthRequiredForGas(address payer) external view override returns (uint256) {
        // solhint-disable-previous-line ordering
        uint256 totalEthRequired = 0;
        address[] memory actions = addressProvider.allActions();
        uint256 numActions = actions.length;
        for (uint256 i = 0; i < numActions; i++) {
            totalEthRequired += IAction(actions[i]).getEthRequiredForGas(payer);
        }
        return totalEthRequired;
    }
}",959
RealWorld_BA_112_IAmmGauge_RealWord_20240829205537.log,112,IAmmGauge,5727,4496,10223,79.0,0.118555,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./IRewardsGauge.sol"";

interface IAmmGauge is IRewardsGauge {
    event AmmStaked(address indexed account, address indexed token, uint256 amount);
    event AmmUnstaked(address indexed account, address indexed token, uint256 amount);

    function kill() external returns (bool);

    function stake(uint256 amount) external returns (bool);

    function unstake(uint256 amount) external returns (bool);

    function poolCheckpoint() external returns (bool);

    function getAmmToken() external view returns (address);

    function isAmmToken(address token) external view returns (bool);

    function claimableRewards(address user) external view returns (uint256);
}",170
RealWorld_BA_112_IWETH_RealWord_20240829213322.log,112,IWETH,4580,4205,8785,77.0,0.107,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/**
 * @notice Interface for WETH9
 * @dev https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code
 */
interface IWETH is IERC20 {
    function deposit() external payable;

    function withdraw(uint256 wad) external;
}",112
RealWorld_BA_112_BaseHandler_RealWord_20240829192543.log,112,BaseHandler,4575,4239,8814,73.0,0.107655,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../../../interfaces/actions/topup/ITopUpHandler.sol"";

abstract contract BaseHandler is ITopUpHandler {
    /// @dev Handlers will be called through delegatecall from the topup action
    /// so we add a gap to ensure that the children contracts do not
    /// overwrite the topup action storage
    uint256[100] private __gap;
}",99
RealWorld_BA_112_MockCurveToken_RealWord_20240829190956.log,112,MockCurveToken,4607,4461,9068,77.0,0.112255,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./MockErc20.sol"";

contract MockCurveToken is MockErc20 {
    constructor(uint8 _decimals) MockErc20(_decimals) {}

    function burnFrom(address to, uint256 value) external returns (bool) {
        _burn(to, value);
        return true;
    }
}",89
RealWorld_BA_112_ILpToken_RealWord_20240829203549.log,112,ILpToken,5569,5151,10720,106.0,0.130865,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";

interface ILpToken is IERC20Upgradeable {
    function mint(address account, uint256 lpTokens) external;

    function burn(address account, uint256 burnAmount) external returns (uint256);

    function burn(uint256 burnAmount) external;

    function minter() external view returns (address);

    function initialize(
        string memory name_,
        string memory symbol_,
        uint8 _decimals,
        address _minter
    ) external returns (bool);
}",142
RealWorld_BA_112_CvxMintAmount_RealWord_20240829182836.log,112,CvxMintAmount,9393,5160,14553,79.0,0.150165,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

abstract contract CvxMintAmount {
    uint256 private constant _CLIFF_SIZE = 100000 * 1e18; //new cliff every 100,000 tokens
    uint256 private constant _CLIFF_COUNT = 1000; // 1,000 cliffs
    uint256 private constant _MAX_SUPPLY = 100000000 * 1e18; //100 mil max supply
    IERC20 private constant _CVX_TOKEN =
        IERC20(address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)); // CVX Token

    function getCvxMintAmount(uint256 crvEarned) public view returns (uint256) {
        //first get total supply
        uint256 cvxTotalSupply = _CVX_TOKEN.totalSupply();

        //get current cliff
        uint256 currentCliff = cvxTotalSupply / _CLIFF_SIZE;

        //if current cliff is under the max
        if (currentCliff >= _CLIFF_COUNT) return 0;

        //get remaining cliffs
        uint256 remaining = _CLIFF_COUNT - currentCliff;

        //multiply ratio of remaining cliffs to total cliffs against amount CRV received
        uint256 cvxEarned = (crvEarned * remaining) / _CLIFF_COUNT;

        //double check we have not gone over the max supply
        uint256 amountTillMax = _MAX_SUPPLY - cvxTotalSupply;
        if (cvxEarned > amountTillMax) cvxEarned = amountTillMax;
        return cvxEarned;
    }
}",390
RealWorld_BA_112_Preparable_RealWord_20240829182702.log,112,Preparable,22318,5267,27585,92.0,0.21693,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../interfaces/IPreparable.sol"";
import ""../../libraries/Errors.sol"";

/**
 * @notice Implements the base logic for a two-phase commit
 * @dev This does not implements any access-control so publicly exposed
 * callers should make sure to have the proper checks in palce
 */
contract Preparable is IPreparable {
    uint256 private constant _MIN_DELAY = 3 days;

    mapping(bytes32 => address) public pendingAddresses;
    mapping(bytes32 => uint256) public pendingUInts256;

    mapping(bytes32 => address) public currentAddresses;
    mapping(bytes32 => uint256) public currentUInts256;

    /**
     * @dev Deadlines shares the same namespace regardless of the type
     * of the pending variable so this needs to be enforced in the caller
     */
    mapping(bytes32 => uint256) public deadlines;

    function _prepareDeadline(bytes32 key, uint256 delay) internal {
        require(deadlines[key] == 0, Error.DEADLINE_NOT_ZERO);
        require(delay >= _MIN_DELAY, Error.DELAY_TOO_SHORT);
        deadlines[key] = block.timestamp + delay;
    }

    /**
     * @notice Prepares an uint256 that should be commited to the contract
     * after `_MIN_DELAY` elapsed
     * @param value The value to prepare
     * @return `true` if success.
     */
    function _prepare(
        bytes32 key,
        uint256 value,
        uint256 delay
    ) internal returns (bool) {
        _prepareDeadline(key, delay);
        pendingUInts256[key] = value;
        emit ConfigPreparedNumber(key, value, delay);
        return true;
    }

    /**
     * @notice Same as `_prepare(bytes32,uint256,uint256)` but uses a default delay
     */
    function _prepare(bytes32 key, uint256 value) internal returns (bool) {
        return _prepare(key, value, _MIN_DELAY);
    }

    /**
     * @notice Prepares an address that should be commited to the contract
     * after `_MIN_DELAY` elapsed
     * @param value The value to prepare
     * @return `true` if success.
     */
    function _prepare(
        bytes32 key,
        address value,
        uint256 delay
    ) internal returns (bool) {
        _prepareDeadline(key, delay);
        pendingAddresses[key] = value;
        emit ConfigPreparedAddress(key, value, delay);
        return true;
    }

    /**
     * @notice Same as `_prepare(bytes32,address,uint256)` but uses a default delay
     */
    function _prepare(bytes32 key, address value) internal returns (bool) {
        return _prepare(key, value, _MIN_DELAY);
    }

    /**
     * @notice Reset a uint256 key
     * @return `true` if success.
     */
    function _resetUInt256Config(bytes32 key) internal returns (bool) {
        require(deadlines[key] != 0, Error.DEADLINE_NOT_ZERO);
        deadlines[key] = 0;
        pendingUInts256[key] = 0;
        emit ConfigReset(key);
        return true;
    }

    /**
     * @notice Reset an address key
     * @return `true` if success.
     */
    function _resetAddressConfig(bytes32 key) internal returns (bool) {
        require(deadlines[key] != 0, Error.DEADLINE_NOT_ZERO);
        deadlines[key] = 0;
        pendingAddresses[key] = address(0);
        emit ConfigReset(key);
        return true;
    }

    /**
     * @dev Checks the deadline of the key and reset it
     */
    function _executeDeadline(bytes32 key) internal {
        uint256 deadline = deadlines[key];
        require(block.timestamp >= deadline, Error.DEADLINE_NOT_REACHED);
        require(deadline != 0, Error.DEADLINE_NOT_SET);
        deadlines[key] = 0;
    }

    /**
     * @notice Execute uint256 config update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return New value.
     */
    function _executeUInt256(bytes32 key) internal returns (uint256) {
        _executeDeadline(key);
        uint256 newValue = pendingUInts256[key];
        _setConfig(key, newValue);
        return newValue;
    }

    /**
     * @notice Execute address config update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return New value.
     */
    function _executeAddress(bytes32 key) internal returns (address) {
        _executeDeadline(key);
        address newValue = pendingAddresses[key];
        _setConfig(key, newValue);
        return newValue;
    }

    function _setConfig(bytes32 key, address value) internal returns (address) {
        address oldValue = currentAddresses[key];
        currentAddresses[key] = value;
        pendingAddresses[key] = address(0);
        deadlines[key] = 0;
        emit ConfigUpdatedAddress(key, oldValue, value);
        return value;
    }

    function _setConfig(bytes32 key, uint256 value) internal returns (uint256) {
        uint256 oldValue = currentUInts256[key];
        currentUInts256[key] = value;
        pendingUInts256[key] = 0;
        deadlines[key] = 0;
        emit ConfigUpdatedNumber(key, oldValue, value);
        return value;
    }
}",1184
RealWorld_BA_112_IAmmConvexGauge_RealWord_20240829205844.log,112,IAmmConvexGauge,4125,4131,8256,91.0,0.103245,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IAmmConvexGauge {
    function deactivateInflationRecipient() external;

    function setInflationRecipient(address recipient) external;

    function allClaimableRewards(address user) external view returns (uint256[3] memory);
}",73
RealWorld_BA_112_LiquidityPool_RealWord_20240829194718.log,112,LiquidityPool,108231,6150,114381,110.0,0.664155,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../../interfaces/IController.sol"";
import ""../../interfaces/pool/ILiquidityPool.sol"";
import ""../../interfaces/ILpToken.sol"";
import ""../../interfaces/IStakerVault.sol"";
import ""../../interfaces/IVault.sol"";

import ""../../libraries/AddressProviderHelpers.sol"";
import ""../../libraries/Errors.sol"";
import ""../../libraries/ScaledMath.sol"";

import ""../access/Authorization.sol"";
import ""../utils/Preparable.sol"";
import ""../utils/Pausable.sol"";

/**
 * @dev Pausing/unpausing the pool will disable/re-enable deposits.
 */
abstract contract LiquidityPool is
    ILiquidityPool,
    Authorization,
    Preparable,
    Pausable,
    Initializable
{
    using AddressProviderHelpers for IAddressProvider;
    using ScaledMath for uint256;
    using SafeERC20 for IERC20;

    struct WithdrawalFeeMeta {
        uint64 timeToWait;
        uint64 feeRatio;
        uint64 lastActionTimestamp;
    }

    bytes32 internal constant _VAULT_KEY = ""Vault"";
    bytes32 internal constant _RESERVE_DEVIATION_KEY = ""ReserveDeviation"";
    bytes32 internal constant _REQUIRED_RESERVES_KEY = ""RequiredReserves"";

    bytes32 internal constant _MAX_WITHDRAWAL_FEE_KEY = ""MaxWithdrawalFee"";
    bytes32 internal constant _MIN_WITHDRAWAL_FEE_KEY = ""MinWithdrawalFee"";
    bytes32 internal constant _WITHDRAWAL_FEE_DECREASE_PERIOD_KEY = ""WithdrawalFeeDecreasePeriod"";

    uint256 internal constant _INITIAL_RESERVE_DEVIATION = 0.005e18; // 0.5%
    uint256 internal constant _INITIAL_FEE_DECREASE_PERIOD = 1 weeks;
    uint256 internal constant _INITIAL_MAX_WITHDRAWAL_FEE = 0.03e18; // 3%

    /**
     * @notice even through admin votes and later governance, the withdrawal
     * fee will never be able to go above this value
     */
    uint256 internal constant _MAX_WITHDRAWAL_FEE = 0.05e18;

    /**
     * @notice Keeps track of the withdrawal fees on a per-address basis
     */
    mapping(address => WithdrawalFeeMeta) public withdrawalFeeMetas;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    uint256 public depositCap;
    IStakerVault public staker;
    ILpToken public lpToken;
    string public name;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        require(address(_controller) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        controller = IController(_controller);
        addressProvider = IController(_controller).addressProvider();
    }

    /**
     * @notice Deposit funds into liquidity pool and mint LP tokens in exchange.
     * @param depositAmount Amount of the underlying asset to supply.
     * @return The actual amount minted.
     */
    function deposit(uint256 depositAmount) external payable override returns (uint256) {
        return depositFor(msg.sender, depositAmount, 0);
    }

    /**
     * @notice Deposit funds into liquidity pool and mint LP tokens in exchange.
     * @param depositAmount Amount of the underlying asset to supply.
     * @param minTokenAmount Minimum amount of LP tokens that should be minted.
     * @return The actual amount minted.
     */
    function deposit(uint256 depositAmount, uint256 minTokenAmount)
        external
        payable
        override
        returns (uint256)
    {
        return depositFor(msg.sender, depositAmount, minTokenAmount);
    }

    /**
     * @notice Deposit funds into liquidity pool and stake LP Tokens in Staker Vault.
     * @param depositAmount Amount of the underlying asset to supply.
     * @param minTokenAmount Minimum amount of LP tokens that should be minted.
     * @return The actual amount minted and staked.
     */
    function depositAndStake(uint256 depositAmount, uint256 minTokenAmount)
        external
        payable
        override
        returns (uint256)
    {
        uint256 amountMinted_ = depositFor(address(this), depositAmount, minTokenAmount);
        staker.stakeFor(msg.sender, amountMinted_);
        return amountMinted_;
    }

    /**
     * @notice Withdraws all funds from vault.
     * @dev Should be called in case of emergencies.
     */
    function withdrawAll() external override onlyGovernance {
        getVault().withdrawAll();
    }

    function setLpToken(address _lpToken)
        external
        override
        onlyRoles2(Roles.GOVERNANCE, Roles.POOL_FACTORY)
        returns (bool)
    {
        require(address(lpToken) == address(0), Error.ADDRESS_ALREADY_SET);
        require(ILpToken(_lpToken).minter() == address(this), Error.INVALID_MINTER);
        lpToken = ILpToken(_lpToken);
        _approveStakerVaultSpendingLpTokens();
        emit LpTokenSet(_lpToken);
        return true;
    }

    /**
     * @notice Checkpoint function to update a user's withdrawal fees on deposit and redeem
     * @param from Address sending from
     * @param to Address sending to
     * @param amount Amount to redeem or deposit
     */
    function handleLpTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) external override {
        require(
            msg.sender == address(lpToken) || msg.sender == address(staker),
            Error.UNAUTHORIZED_ACCESS
        );
        if (
            addressProvider.isStakerVault(to, address(lpToken)) ||
            addressProvider.isStakerVault(from, address(lpToken)) ||
            addressProvider.isAction(to) ||
            addressProvider.isAction(from)
        ) {
            return;
        }

        if (to != address(0)) {
            _updateUserFeesOnDeposit(to, from, amount);
        }
    }

    /**
     * @notice Prepare update of required reserve ratio (with time delay enforced).
     * @param _newRatio New required reserve ratio.
     * @return `true` if success.
     */
    function prepareNewRequiredReserves(uint256 _newRatio) external onlyGovernance returns (bool) {
        require(_newRatio <= ScaledMath.ONE, Error.INVALID_AMOUNT);
        return _prepare(_REQUIRED_RESERVES_KEY, _newRatio);
    }

    /**
     * @notice Execute required reserve ratio update (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New required reserve ratio.
     */
    function executeNewRequiredReserves() external override returns (uint256) {
        uint256 requiredReserveRatio = _executeUInt256(_REQUIRED_RESERVES_KEY);
        _rebalanceVault();
        return requiredReserveRatio;
    }

    /**
     * @notice Reset the prepared required reserves.
     * @return `true` if success.
     */
    function resetRequiredReserves() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_REQUIRED_RESERVES_KEY);
    }

    /**
     * @notice Prepare update of reserve deviation ratio (with time delay enforced).
     * @param newRatio New reserve deviation ratio.
     * @return `true` if success.
     */
    function prepareNewReserveDeviation(uint256 newRatio) external onlyGovernance returns (bool) {
        require(newRatio <= (ScaledMath.DECIMAL_SCALE * 50) / 100, Error.INVALID_AMOUNT);
        return _prepare(_RESERVE_DEVIATION_KEY, newRatio);
    }

    /**
     * @notice Execute reserve deviation ratio update (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New reserve deviation ratio.
     */
    function executeNewReserveDeviation() external override returns (uint256) {
        uint256 reserveDeviation = _executeUInt256(_RESERVE_DEVIATION_KEY);
        _rebalanceVault();
        return reserveDeviation;
    }

    /**
     * @notice Reset the prepared reserve deviation.
     * @return `true` if success.
     */
    function resetNewReserveDeviation() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_RESERVE_DEVIATION_KEY);
    }

    /**
     * @notice Prepare update of min withdrawal fee (with time delay enforced).
     * @param newFee New min withdrawal fee.
     * @return `true` if success.
     */
    function prepareNewMinWithdrawalFee(uint256 newFee) external onlyGovernance returns (bool) {
        _checkFeeInvariants(newFee, getMaxWithdrawalFee());
        return _prepare(_MIN_WITHDRAWAL_FEE_KEY, newFee);
    }

    /**
     * @notice Execute min withdrawal fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New withdrawal fee.
     */
    function executeNewMinWithdrawalFee() external returns (uint256) {
        uint256 newFee = _executeUInt256(_MIN_WITHDRAWAL_FEE_KEY);
        _checkFeeInvariants(newFee, getMaxWithdrawalFee());
        return newFee;
    }

    /**
     * @notice Reset the prepared min withdrawal fee
     * @return `true` if success.
     */
    function resetNewMinWithdrawalFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MIN_WITHDRAWAL_FEE_KEY);
    }

    /**
     * @notice Prepare update of max withdrawal fee (with time delay enforced).
     * @param newFee New max withdrawal fee.
     * @return `true` if success.
     */
    function prepareNewMaxWithdrawalFee(uint256 newFee) external onlyGovernance returns (bool) {
        _checkFeeInvariants(getMinWithdrawalFee(), newFee);
        return _prepare(_MAX_WITHDRAWAL_FEE_KEY, newFee);
    }

    /**
     * @notice Execute max withdrawal fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New max withdrawal fee.
     */
    function executeNewMaxWithdrawalFee() external override returns (uint256) {
        uint256 newFee = _executeUInt256(_MAX_WITHDRAWAL_FEE_KEY);
        _checkFeeInvariants(getMinWithdrawalFee(), newFee);
        return newFee;
    }

    /**
     * @notice Reset the prepared max fee.
     * @return `true` if success.
     */
    function resetNewMaxWithdrawalFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_WITHDRAWAL_FEE_KEY);
    }

    /**
     * @notice Prepare update of withdrawal decrease fee period (with time delay enforced).
     * @param newPeriod New withdrawal fee decrease period.
     * @return `true` if success.
     */
    function prepareNewWithdrawalFeeDecreasePeriod(uint256 newPeriod)
        external
        onlyGovernance
        returns (bool)
    {
        return _prepare(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY, newPeriod);
    }

    /**
     * @notice Execute withdrawal fee decrease period update (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New withdrawal fee decrease period.
     */
    function executeNewWithdrawalFeeDecreasePeriod() external returns (uint256) {
        return _executeUInt256(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY);
    }

    /**
     * @notice Reset the prepared withdrawal fee decrease period update.
     * @return `true` if success.
     */
    function resetNewWithdrawalFeeDecreasePeriod() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY);
    }

    /**
     * @notice Set the staker vault for this pool's LP token
     * @dev Staker vault and LP token pairs are immutable and the staker vault can only be set once for a pool.
     *      Only one vault exists per LP token. This information will be retrieved from the controller of the pool.
     * @return Address of the new staker vault for the pool.
     */
    function setStaker()
        external
        override
        onlyRoles2(Roles.GOVERNANCE, Roles.POOL_FACTORY)
        returns (bool)
    {
        require(address(staker) == address(0), Error.ADDRESS_ALREADY_SET);
        address stakerVault = addressProvider.getStakerVault(address(lpToken));
        require(stakerVault != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        staker = IStakerVault(stakerVault);
        _approveStakerVaultSpendingLpTokens();
        emit StakerVaultSet(stakerVault);
        return true;
    }

    /**
     * @notice Prepare setting a new Vault (with time delay enforced).
     * @param _vault Address of new Vault contract.
     * @return `true` if success.
     */
    function prepareNewVault(address _vault) external override onlyGovernance returns (bool) {
        _prepare(_VAULT_KEY, _vault);
        return true;
    }

    /**
     * @notice Execute Vault update (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return Address of new Vault contract.
     */
    function executeNewVault() external override returns (address) {
        IVault vault = getVault();
        if (address(vault) != address(0)) {
            vault.withdrawAll();
        }
        address newVault = _executeAddress(_VAULT_KEY);
        addressProvider.updateVault(address(vault), newVault);
        return newVault;
    }

    /**
     * @notice Reset the vault deadline.
     * @return `true` if success.
     */
    function resetNewVault() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_VAULT_KEY);
    }

    /**
     * @notice Redeems the underlying asset by burning LP tokens.
     * @param redeemLpTokens Number of tokens to burn for redeeming the underlying.
     * @return Actual amount of the underlying redeemed.
     */
    function redeem(uint256 redeemLpTokens) external override returns (uint256) {
        return redeem(redeemLpTokens, 0);
    }

    /**
     * @notice Uncap the pool to remove the deposit limit.
     * @return `true` if success.
     */
    function uncap() external override onlyGovernance returns (bool) {
        require(isCapped(), Error.NOT_CAPPED);

        depositCap = 0;
        return true;
    }

    /**
     * @notice Update the deposit cap value.
     * @param _depositCap The maximum allowed deposits per address in the pool
     * @return `true` if success.
     */
    function updateDepositCap(uint256 _depositCap) external override onlyGovernance returns (bool) {
        require(isCapped(), Error.NOT_CAPPED);
        require(depositCap != _depositCap, Error.SAME_AS_CURRENT);
        require(_depositCap > 0, Error.INVALID_AMOUNT);

        depositCap = _depositCap;
        return true;
    }

    /**
     * @notice Rebalance vault according to required underlying backing reserves.
     */
    function rebalanceVault() external onlyGovernance {
        _rebalanceVault();
    }

    /**
     * @notice Deposit funds for an address into liquidity pool and mint LP tokens in exchange.
     * @param account Account to deposit for.
     * @param depositAmount Amount of the underlying asset to supply.
     * @return Actual amount minted.
     */
    function depositFor(address account, uint256 depositAmount)
        external
        payable
        override
        returns (uint256)
    {
        return depositFor(account, depositAmount, 0);
    }

    /**
     * @notice Redeems the underlying asset by burning LP tokens, unstaking any LP tokens needed.
     * @param redeemLpTokens Number of tokens to unstake and/or burn for redeeming the underlying.
     * @param minRedeemAmount Minimum amount of underlying that should be received.
     * @return Actual amount of the underlying redeemed.
     */
    function unstakeAndRedeem(uint256 redeemLpTokens, uint256 minRedeemAmount)
        external
        override
        returns (uint256)
    {
        uint256 lpBalance_ = lpToken.balanceOf(msg.sender);
        require(
            lpBalance_ + staker.balanceOf(msg.sender) >= redeemLpTokens,
            Error.INSUFFICIENT_BALANCE
        );
        if (lpBalance_ < redeemLpTokens) {
            staker.unstakeFor(msg.sender, msg.sender, redeemLpTokens - lpBalance_);
        }
        return redeem(redeemLpTokens, minRedeemAmount);
    }

    /**
     * @notice Returns the address of the LP token of this pool
     * @return The address of the LP token
     */
    function getLpToken() external view override returns (address) {
        return address(lpToken);
    }

    /**
     * @notice Calculates the amount of LP tokens that need to be redeemed to get a certain amount of underlying (includes fees and exchange rate)
     * @param account Address of the account redeeming.
     * @param underlyingAmount The amount of underlying desired.
     * @return Amount of LP tokens that need to be redeemed.
     */
    function calcRedeem(address account, uint256 underlyingAmount)
        external
        view
        override
        returns (uint256)
    {
        require(underlyingAmount > 0, Error.INVALID_AMOUNT);
        ILpToken lpToken_ = lpToken;
        require(lpToken_.balanceOf(account) > 0, Error.INSUFFICIENT_BALANCE);

        uint256 currentExchangeRate = exchangeRate();
        uint256 withoutFeesLpAmount = underlyingAmount.scaledDiv(currentExchangeRate);
        if (withoutFeesLpAmount == lpToken_.totalSupply()) {
            return withoutFeesLpAmount;
        }

        WithdrawalFeeMeta memory meta = withdrawalFeeMetas[account];

        uint256 currentFeeRatio = 0;
        if (!addressProvider.isAction(account)) {
            currentFeeRatio = getNewCurrentFees(
                meta.timeToWait,
                meta.lastActionTimestamp,
                meta.feeRatio
            );
        }
        uint256 scalingFactor = currentExchangeRate.scaledMul((ScaledMath.ONE - currentFeeRatio));
        uint256 neededLpTokens = underlyingAmount.scaledDivRoundUp(scalingFactor);

        return neededLpTokens;
    }

    function getUnderlying() external view virtual override returns (address);

    /**
     * @notice Deposit funds for an address into liquidity pool and mint LP tokens in exchange.
     * @param account Account to deposit for.
     * @param depositAmount Amount of the underlying asset to supply.
     * @param minTokenAmount Minimum amount of LP tokens that should be minted.
     * @return Actual amount minted.
     */
    function depositFor(
        address account,
        uint256 depositAmount,
        uint256 minTokenAmount
    ) public payable override notPaused returns (uint256) {
        uint256 rate = exchangeRate();

        if (isCapped()) {
            uint256 lpBalance = lpToken.balanceOf(account);
            uint256 stakedAndLockedBalance = staker.stakedAndActionLockedBalanceOf(account);
            uint256 currentUnderlyingBalance = (lpBalance + stakedAndLockedBalance).scaledMul(rate);
            require(
                currentUnderlyingBalance + depositAmount <= depositCap,
                Error.EXCEEDS_DEPOSIT_CAP
            );
        }

        _doTransferIn(msg.sender, depositAmount);
        uint256 mintedLp = depositAmount.scaledDiv(rate);
        require(mintedLp >= minTokenAmount, Error.INVALID_AMOUNT);

        lpToken.mint(account, mintedLp);
        _rebalanceVault();

        if (msg.sender == account || address(this) == account) {
            emit Deposit(msg.sender, depositAmount, mintedLp);
        } else {
            emit DepositFor(msg.sender, account, depositAmount, mintedLp);
        }
        return mintedLp;
    }

    /**
     * @notice Redeems the underlying asset by burning LP tokens.
     * @param redeemLpTokens Number of tokens to burn for redeeming the underlying.
     * @param minRedeemAmount Minimum amount of underlying that should be received.
     * @return Actual amount of the underlying redeemed.
     */
    function redeem(uint256 redeemLpTokens, uint256 minRedeemAmount)
        public
        override
        returns (uint256)
    {
        require(redeemLpTokens > 0, Error.INVALID_AMOUNT);
        ILpToken lpToken_ = lpToken;
        require(lpToken_.balanceOf(msg.sender) >= redeemLpTokens, Error.INSUFFICIENT_BALANCE);

        uint256 withdrawalFee = addressProvider.isAction(msg.sender)
            ? 0
            : getWithdrawalFee(msg.sender, redeemLpTokens);
        uint256 redeemMinusFees = redeemLpTokens - withdrawalFee;
        // Pay no fees on the last withdrawal (avoid locking funds in the pool)
        if (redeemLpTokens == lpToken_.totalSupply()) {
            redeemMinusFees = redeemLpTokens;
        }
        uint256 redeemUnderlying = redeemMinusFees.scaledMul(exchangeRate());
        require(redeemUnderlying >= minRedeemAmount, Error.NOT_ENOUGH_FUNDS_WITHDRAWN);

        _rebalanceVault(redeemUnderlying);

        lpToken_.burn(msg.sender, redeemLpTokens);
        _doTransferOut(payable(msg.sender), redeemUnderlying);
        emit Redeem(msg.sender, redeemUnderlying, redeemLpTokens);
        return redeemUnderlying;
    }

    /**
     * @return the current required reserves ratio
     */
    function getRequiredReserveRatio() public view virtual returns (uint256) {
        return currentUInts256[_REQUIRED_RESERVES_KEY];
    }

    /**
     * @return the current maximum reserve deviation ratio
     */
    function getMaxReserveDeviationRatio() public view virtual returns (uint256) {
        return currentUInts256[_RESERVE_DEVIATION_KEY];
    }

    /**
     * @notice Returns the current minimum withdrawal fee
     */
    function getMinWithdrawalFee() public view returns (uint256) {
        return currentUInts256[_MIN_WITHDRAWAL_FEE_KEY];
    }

    /**
     * @notice Returns the current maximum withdrawal fee
     */
    function getMaxWithdrawalFee() public view returns (uint256) {
        return currentUInts256[_MAX_WITHDRAWAL_FEE_KEY];
    }

    /**
     * @notice Returns the current withdrawal fee decrease period
     */
    function getWithdrawalFeeDecreasePeriod() public view returns (uint256) {
        return currentUInts256[_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY];
    }

    /**
     * @return the current vault of the liquidity pool
     */
    function getVault() public view virtual override returns (IVault) {
        return IVault(currentAddresses[_VAULT_KEY]);
    }

    /**
     * @notice Compute current exchange rate of LP tokens to underlying scaled to 1e18.
     * @dev Exchange rate means: underlying = LP token * exchangeRate
     * @return Current exchange rate.
     */
    function exchangeRate() public view override returns (uint256) {
        uint256 totalUnderlying_ = totalUnderlying();
        uint256 totalSupply = lpToken.totalSupply();
        if (totalSupply == 0 || totalUnderlying_ == 0) {
            return ScaledMath.ONE;
        }

        return totalUnderlying_.scaledDiv(totalSupply);
    }

    /**
     * @notice Compute total amount of underlying tokens for this pool.
     * @return Total amount of underlying in pool.
     */
    function totalUnderlying() public view override returns (uint256) {
        IVault vault = getVault();
        uint256 balanceUnderlying = _getBalanceUnderlying();
        if (address(vault) == address(0)) {
            return balanceUnderlying;
        }
        uint256 investedUnderlying = vault.getTotalUnderlying();
        return investedUnderlying + balanceUnderlying;
    }

    /**
     * @notice Retuns if the pool has an active deposit limit
     * @return `true` if there is currently a deposit limit
     */
    function isCapped() public view override returns (bool) {
        return depositCap != 0;
    }

    /**
     * @notice Returns the withdrawal fee for `account`
     * @param account Address to get the withdrawal fee for
     * @param amount Amount to calculate the withdrawal fee for
     * @return Withdrawal fee in LP tokens
     */
    function getWithdrawalFee(address account, uint256 amount)
        public
        view
        override
        returns (uint256)
    {
        WithdrawalFeeMeta memory meta = withdrawalFeeMetas[account];

        if (lpToken.balanceOf(account) == 0) {
            return 0;
        }
        uint256 currentFee = getNewCurrentFees(
            meta.timeToWait,
            meta.lastActionTimestamp,
            meta.feeRatio
        );
        return amount.scaledMul(currentFee);
    }

    /**
     * @notice Calculates the withdrawal fee a user would currently need to pay on currentBalance.
     * @param timeToWait The total time to wait until the withdrawal fee reached the min. fee
     * @param lastActionTimestamp Timestamp of the last fee update
     * @param feeRatio Fees that would currently be paid on the user's entire balance
     * @return Updated fee amount on the currentBalance
     */
    function getNewCurrentFees(
        uint256 timeToWait,
        uint256 lastActionTimestamp,
        uint256 feeRatio
    ) public view returns (uint256) {
        uint256 timeElapsed = _getTime() - lastActionTimestamp;
        uint256 minFeePercentage = getMinWithdrawalFee();
        if (timeElapsed >= timeToWait) {
            return minFeePercentage;
        }
        uint256 elapsedShare = timeElapsed.scaledDiv(timeToWait);
        return feeRatio - (feeRatio - minFeePercentage).scaledMul(elapsedShare);
    }

    function _rebalanceVault() internal {
        _rebalanceVault(0);
    }

    function _initialize(
        string memory name_,
        uint256 depositCap_,
        address vault_
    ) internal initializer returns (bool) {
        name = name_;
        depositCap = depositCap_;

        _setConfig(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY, _INITIAL_FEE_DECREASE_PERIOD);
        _setConfig(_MAX_WITHDRAWAL_FEE_KEY, _INITIAL_MAX_WITHDRAWAL_FEE);
        _setConfig(_REQUIRED_RESERVES_KEY, ScaledMath.ONE);
        _setConfig(_RESERVE_DEVIATION_KEY, _INITIAL_RESERVE_DEVIATION);
        _setConfig(_VAULT_KEY, vault_);
        return true;
    }

    function _approveStakerVaultSpendingLpTokens() internal {
        address staker_ = address(staker);
        address lpToken_ = address(lpToken);
        if (staker_ == address(0) || lpToken_ == address(0)) return;
        IERC20(lpToken_).safeApprove(staker_, type(uint256).max);
    }

    function _doTransferIn(address from, uint256 amount) internal virtual;

    function _doTransferOut(address payable to, uint256 amount) internal virtual;

    /**
     * @dev Rebalances the pool's allocations to the vault
     * @param underlyingToWithdraw Amount of underlying to withdraw such that after the withdrawal the pool and vault allocations are correctly balanced.
     */
    function _rebalanceVault(uint256 underlyingToWithdraw) internal {
        IVault vault = getVault();

        if (address(vault) == address(0)) return;
        uint256 lockedLp = staker.getStakedByActions();
        uint256 totalUnderlyingStaked = lockedLp.scaledMul(exchangeRate());

        uint256 underlyingBalance = _getBalanceUnderlying(true);
        uint256 maximumDeviation = totalUnderlyingStaked.scaledMul(getMaxReserveDeviationRatio());

        uint256 nextTargetBalance = totalUnderlyingStaked.scaledMul(getRequiredReserveRatio());

        if (
            underlyingToWithdraw > underlyingBalance ||
            (underlyingBalance - underlyingToWithdraw) + maximumDeviation < nextTargetBalance
        ) {
            uint256 requiredDeposits = nextTargetBalance + underlyingToWithdraw - underlyingBalance;
            vault.withdraw(requiredDeposits);
        } else {
            uint256 nextBalance = underlyingBalance - underlyingToWithdraw;
            if (nextBalance > nextTargetBalance + maximumDeviation) {
                uint256 excessDeposits = nextBalance - nextTargetBalance;
                _doTransferOut(payable(address(vault)), excessDeposits);
                vault.deposit();
            }
        }
    }

    function _updateUserFeesOnDeposit(
        address account,
        address from,
        uint256 amountAdded
    ) internal {
        WithdrawalFeeMeta storage meta = withdrawalFeeMetas[account];
        uint256 balance = lpToken.balanceOf(account) +
            staker.stakedAndActionLockedBalanceOf(account);
        uint256 newCurrentFeeRatio = getNewCurrentFees(
            meta.timeToWait,
            meta.lastActionTimestamp,
            meta.feeRatio
        );
        uint256 shareAdded = amountAdded.scaledDiv(amountAdded + balance);
        uint256 shareExisting = ScaledMath.ONE - shareAdded;
        uint256 feeOnDeposit;
        if (from == address(0)) {
            feeOnDeposit = getMaxWithdrawalFee();
        } else {
            WithdrawalFeeMeta storage fromMeta = withdrawalFeeMetas[from];
            feeOnDeposit = getNewCurrentFees(
                fromMeta.timeToWait,
                fromMeta.lastActionTimestamp,
                fromMeta.feeRatio
            );
        }

        uint256 newFeeRatio = shareExisting.scaledMul(newCurrentFeeRatio) +
            shareAdded.scaledMul(feeOnDeposit);

        meta.feeRatio = uint64(newFeeRatio);
        meta.timeToWait = uint64(getWithdrawalFeeDecreasePeriod());
        meta.lastActionTimestamp = uint64(_getTime());
    }

    function _getBalanceUnderlying() internal view virtual returns (uint256);

    function _getBalanceUnderlying(bool transferInDone) internal view virtual returns (uint256);

    function _isAuthorizedToPause(address account) internal view override returns (bool) {
        return _roleManager().hasRole(Roles.GOVERNANCE, account);
    }

    /**
     * @dev Overriden for testing
     */
    function _getTime() internal view virtual returns (uint256) {
        return block.timestamp;
    }

    function _checkFeeInvariants(uint256 minFee, uint256 maxFee) internal pure {
        require(maxFee >= minFee, Error.INVALID_AMOUNT);
        require(maxFee <= _MAX_WITHDRAWAL_FEE, Error.INVALID_AMOUNT);
    }
}",6754
RealWorld_BA_112_IEthPool_RealWord_20240829210435.log,112,IEthPool,3838,4218,8056,80.0,0.10355,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IEthPool {
    function initialize(
        string memory name_,
        uint256 depositCap_,
        address vault_
    ) external returns (bool);
}",55
RealWorld_BA_112_IChainlinkOracleProvider_RealWord_20240829204149.log,112,IChainlinkOracleProvider,4414,4912,9326,86.0,0.12031,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./IOracleProvider.sol"";

interface IChainlinkOracleProvider is IOracleProvider {
    function setFeed(address asset, address feed) external;

    function setStalePriceDelay(uint256 stalePriceDelay_) external;
}",69
RealWorld_BA_112_LiquidityPoolProfiler_RealWord_20240829191425.log,112,LiquidityPoolProfiler,6186,4746,10932,73.0,0.12585,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../../../interfaces/pool/ILiquidityPool.sol"";

import ""../../LpToken.sol"";
import ""../../pool/LiquidityPool.sol"";

contract LiquidityPoolProfiler {
    LiquidityPool public liquidityPool;

    constructor(address _liquidityPool, address token) {
        liquidityPool = LiquidityPool(_liquidityPool);
        LpToken(address(liquidityPool.lpToken())).approve(
            address(liquidityPool),
            type(uint256).max
        );
        ERC20(token).approve(address(liquidityPool), type(uint256).max);
    }

    function profileDeposit(uint256 amount) external {
        liquidityPool.deposit(amount);
        liquidityPool.deposit(amount);
        liquidityPool.deposit(amount);

        liquidityPool.redeem(amount);
        liquidityPool.redeem(amount);
    }
}",205
RealWorld_BA_112_MockBooster_RealWord_20240829184754.log,112,MockBooster,11564,5496,17060,89.0,0.16774,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../../interfaces/vendor/IBooster.sol"";
import ""../testing/MockErc20.sol"";
import ""./MockRewardStaking.sol"";

// solhint-disable no-unused-vars
contract MockBooster is IBooster {
    address public lpToken;
    address public token;
    address public crvRewards;

    mapping(address => uint256) public balances;

    constructor(
        address _lpToken,
        address _token,
        address _crvRewards
    ) {
        lpToken = _lpToken;
        token = _token;
        crvRewards = _crvRewards;
    }

    function deposit(
        uint256 _pid,
        uint256 _amount,
        bool _stake
    ) external override returns (bool) {
        IERC20(lpToken).transferFrom(msg.sender, address(this), _amount);
        if (_stake) {
            MockErc20(token).mint_for_testing(address(this), _amount);
            balances[msg.sender] += _amount;
            MockErc20(token).approve(crvRewards, _amount);
            MockRewardStaking(crvRewards).stakeFor(msg.sender, _amount);
        } else {
            MockErc20(token).mint_for_testing(msg.sender, _amount);
        }
        return true;
    }

    function withdraw(uint256 _pid, uint256 _amount) external override returns (bool) {
        MockErc20(token).transferFrom(msg.sender, address(0), _amount);
        IERC20(lpToken).transfer(msg.sender, _amount);
        return true;
    }

    function withdrawTo(
        uint256 _pid,
        uint256 _amount,
        address _to
    ) external override returns (bool) {
        MockErc20(token).transferFrom(msg.sender, address(0), _amount);
        IERC20(lpToken).transfer(_to, _amount);
        return true;
    }

    function withdrawAll(uint256 _pid) external override returns (bool) {
        return true;
    }

    function depositAll(uint256 _pid, bool _stake) external override returns (bool) {
        return true;
    }

    function poolInfo(uint256 pid)
        external
        view
        override
        returns (
            address,
            address,
            address,
            address,
            address,
            bool
        )
    {
        return (lpToken, token, address(0), crvRewards, address(0), false);
    }
}",551
RealWorld_BA_112_MockERC20Swapper_RealWord_20240829185444.log,112,MockERC20Swapper,6232,4494,10726,77.0,0.12104,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../../libraries/ScaledMath.sol"";
import ""../../interfaces/ISwapper.sol"";

contract MockERC20Swapper is ISwapper {
    using ScaledMath for uint256;
    uint256 public constant RATE = 1.1 * 1e18;

    function swap(
        address,
        address toToken,
        uint256 swapAmount,
        uint256
    ) external override returns (uint256) {
        // Assumes a suffient amount of toTokens was minted to the contract
        uint256 amount = swapAmount.scaledMul(RATE);
        ERC20(toToken).transfer(msg.sender, amount);
        return amount;
    }

    function getRate(address, address) external pure override returns (uint256) {
        return RATE;
    }
}",197
RealWorld_BA_112_MockFeeDistributor_RealWord_20240829190548.log,112,MockFeeDistributor,4575,3558,8133,63.0,0.094035,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../interfaces/vendor/IGauge.sol"";

contract MockFeeDistributor is IFeeDistributor {
    uint256 private _feeToClaim = 100;

    // this is for mocking fees
    function setFeeToClaim(uint256 _fee) external {
        _feeToClaim = _fee;
    }

    function claim(address) external view override returns (uint256) {
        return _feeToClaim;
    }
}",111
RealWorld_BA_112_ScaledMath_RealWord_20240829200407.log,112,ScaledMath,9007,5401,14408,117.0,0.153055,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

/*
 * @dev To use functions of this contract, at least one of the numbers must
 * be scaled to `DECIMAL_SCALE`. The result will scaled to `DECIMAL_SCALE`
 * if both numbers are scaled to `DECIMAL_SCALE`, otherwise to the scale
 * of the number not scaled by `DECIMAL_SCALE`
 */
library ScaledMath {
    // solhint-disable-next-line private-vars-leading-underscore
    uint256 internal constant DECIMAL_SCALE = 1e18;
    // solhint-disable-next-line private-vars-leading-underscore
    uint256 internal constant ONE = 1e18;

    /**
     * @notice Performs a multiplication between two scaled numbers
     */
    function scaledMul(uint256 a, uint256 b) internal pure returns (uint256) {
        return (a * b) / DECIMAL_SCALE;
    }

    /**
     * @notice Performs a division between two scaled numbers
     */
    function scaledDiv(uint256 a, uint256 b) internal pure returns (uint256) {
        return (a * DECIMAL_SCALE) / b;
    }

    /**
     * @notice Performs a division between two numbers, rounding up the result
     */
    function scaledDivRoundUp(uint256 a, uint256 b) internal pure returns (uint256) {
        return (a * DECIMAL_SCALE + b - 1) / b;
    }

    /**
     * @notice Performs a division between two numbers, ignoring any scaling and rounding up the result
     */
    function divRoundUp(uint256 a, uint256 b) internal pure returns (uint256) {
        return (a + b - 1) / b;
    }
}",363
RealWorld_BA_112_IErc20Pool_RealWord_20240829210731.log,112,IErc20Pool,3976,4093,8069,71.0,0.10174,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IErc20Pool {
    function initialize(
        string memory name_,
        address underlying_,
        uint256 depositCap_,
        address vault_
    ) external returns (bool);
}",60
RealWorld_BA_112_MockLockingStrategy_RealWord_20240829183224.log,112,MockLockingStrategy,7792,5091,12883,79.0,0.14078,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./MockErc20Strategy.sol"";
import ""./MockEthStrategy.sol"";

contract MockLockingStrategy {
    uint256 public amountLocked;

    function setAmountLocked(uint256 amount) external {
        amountLocked = amount;
    }
}

contract MockLockingErc20Strategy is MockErc20Strategy, MockLockingStrategy {
    using SafeERC20 for IERC20;

    constructor(IRoleManager roleManager, address _underlying)
        MockErc20Strategy(roleManager, _underlying)
    {}

    function withdrawAll() external override returns (uint256) {
        uint256 currentBalance = IERC20(_underlying).balanceOf(address(this));
        uint256 toWithdraw = currentBalance - amountLocked;
        IERC20(_underlying).safeTransfer(_vault, toWithdraw);
        return toWithdraw;
    }
}

contract MockLockingEthStrategy is MockEthStrategy, MockLockingStrategy {
    constructor(IRoleManager roleManager) MockEthStrategy(roleManager) {}

    function withdrawAll() external override returns (uint256) {
        uint256 currentBalance = address(this).balance;
        uint256 toWithdraw = currentBalance - amountLocked;
        payable(address(_vault)).transfer(toWithdraw);
        return toWithdraw;
    }
}",282
RealWorld_BA_112_VaultReserve_RealWord_20240829195359.log,112,VaultReserve,15902,5613,21515,103.0,0.19177,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../../interfaces/IVaultReserve.sol"";
import ""../../libraries/Errors.sol"";

import ""../access/Authorization.sol"";
import ""../vault/Vault.sol"";

/**
 * @notice Contract holding vault reserves
 * @dev ETH reserves are stored under address(0)
 */
contract VaultReserve is IVaultReserve, Authorization {
    using SafeERC20 for IERC20;

    uint256 internal constant _INITIAL_WITHDRAWAL_DELAY = 3 days;

    mapping(address => mapping(address => uint256)) private _balances;
    mapping(address => uint256) private _lastWithdrawal;

    uint256 public minWithdrawalDelay;

    modifier onlyVault() {
        require(_roleManager().hasRole(Roles.VAULT, msg.sender), Error.UNAUTHORIZED_ACCESS);
        _;
    }

    constructor(IRoleManager roleManager) Authorization(roleManager) {
        minWithdrawalDelay = _INITIAL_WITHDRAWAL_DELAY;
    }

    /**
     * @notice Deposit funds into vault reserve.
     * @notice Only callable by a whitelisted vault.
     * @param token Token to deposit.
     * @param amount Amount to deposit.
     * @return True if deposit was successful.
     */
    function deposit(address token, uint256 amount)
        external
        payable
        override
        onlyVault
        returns (bool)
    {
        if (token == address(0)) {
            require(msg.value == amount, Error.INVALID_AMOUNT);
            _balances[msg.sender][token] += msg.value;
            return true;
        }
        uint256 balance = IERC20(token).balanceOf(address(this));
        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBalance = IERC20(token).balanceOf(address(this));
        uint256 received = newBalance - balance;
        require(received >= amount, Error.INVALID_AMOUNT);
        _balances[msg.sender][token] += received;
        emit Deposit(msg.sender, token, amount);
        return true;
    }

    /**
     * @notice Withdraw funds from vault reserve.
     * @notice Only callable by a whitelisted vault.
     * @param token Token to withdraw.
     * @param amount Amount to withdraw.
     * @return True if withdrawal was successful.
     */
    function withdraw(address token, uint256 amount) external override onlyVault returns (bool) {
        require(canWithdraw(msg.sender), Error.RESERVE_ACCESS_EXCEEDED);
        uint256 accountBalance = _balances[msg.sender][token];
        require(accountBalance >= amount, Error.INSUFFICIENT_BALANCE);

        _balances[msg.sender][token] -= amount;
        _lastWithdrawal[msg.sender] = block.timestamp;

        if (token == address(0)) {
            payable(msg.sender).transfer(amount);
        } else {
            IERC20(token).safeTransfer(msg.sender, amount);
        }
        emit Withdraw(msg.sender, token, amount);
        return true;
    }

    /**
     * @notice Check token balance of a specific vault.
     * @param vault Vault to check balance of.
     * @param token Token to check balance in.
     * @return Token balance of vault.
     */
    function getBalance(address vault, address token) public view override returns (uint256) {
        return _balances[vault][token];
    }

    /**
     * @notice returns true if the vault is allowed to withdraw from the reserve
     */
    function canWithdraw(address vault) public view returns (bool) {
        return block.timestamp >= _lastWithdrawal[vault] + minWithdrawalDelay;
    }
}",792
RealWorld_BA_112_IvlCvxExtraRewardDistribution_RealWord_20240829214258.log,112,IvlCvxExtraRewardDistribution,4191,4164,8355,71.0,0.104235,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

interface IvlCvxExtraRewardDistribution {
    function getReward(address _account, address _token) external;

    function getRewards(address _account, address[] calldata _tokens) external;

    function forfeitRewards(address _token, uint256 _index) external;
}",75
RealWorld_BA_112_IActionFeeHandler_RealWord_20240829204619.log,112,IActionFeeHandler,4951,4736,9687,82.0,0.119475,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../IPreparable.sol"";

interface IActionFeeHandler is IPreparable {
    function payFees(
        address payer,
        address keeper,
        uint256 amount,
        address token
    ) external returns (bool);

    function claimKeeperFeesForPool(address keeper, address token) external returns (bool);

    function claimTreasuryFees(address token) external returns (bool);

    function setInitialKeeperGaugeForToken(address lpToken, address _keeperGauge)
        external
        returns (bool);
}",132
RealWorld_BA_112_IController_RealWord_20240829204026.log,112,IController,6668,4912,11580,81.0,0.13158,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./IAddressProvider.sol"";
import ""./IPreparable.sol"";
import ""./IGasBank.sol"";
import ""./pool/ILiquidityPool.sol"";
import ""./tokenomics/IInflationManager.sol"";

// solhint-disable ordering

interface IController is IPreparable {
    function addressProvider() external view returns (IAddressProvider);

    function inflationManager() external view returns (IInflationManager);

    function addStakerVault(address stakerVault) external returns (bool);

    function removePool(address pool) external returns (bool);

    /** Keeper functions */
    function prepareKeeperRequiredStakedBKD(uint256 amount) external;

    function executeKeeperRequiredStakedBKD() external;

    function getKeeperRequiredStakedBKD() external view returns (uint256);

    function canKeeperExecuteAction(address keeper) external view returns (bool);

    /** Miscellaneous functions */

    function getTotalEthRequiredForGas(address payer) external view returns (uint256);
}",220
RealWorld_BA_112_AccountEncoding_RealWord_20240829201219.log,112,AccountEncoding,4119,4071,8190,73.0,0.102015,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

library AccountEncoding {
    function addr(bytes32 account) internal pure returns (address) {
        return address(bytes20(account));
    }

    function meta(bytes32 account) internal pure returns (bytes12) {
        return bytes12(account << 160);
    }
}",77
RealWorld_BA_112_Swapper3Crv_RealWord_20240829180542.log,112,Swapper3Crv,37464,4905,42369,80.0,0.28542,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../../interfaces/vendor/ICurveSwap.sol"";
import ""../../interfaces/vendor/UniswapRouter02.sol"";
import ""../../interfaces/ISwapper.sol"";
import ""../../libraries/Errors.sol"";
import ""../../libraries/ScaledMath.sol"";

contract Swapper3Crv is ISwapper {
    using ScaledMath for uint256;
    using SafeERC20 for IERC20;

    // Dex contracts
    address public constant UNISWAP = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    address public constant SUSHISWAP = address(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);

    // Dex factories
    address public constant UNISWAP_FACTORY = address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);
    address public constant SUSHISWAP_FACTORY = address(0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac);

    // ERC20 tokens
    address public constant DAI = address(0x6B175474E89094C44Da98b954EedeAC495271d0F);
    address public constant USDC = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    address public constant USDT = address(0xdAC17F958D2ee523a2206206994597C13D831ec7);
    address public constant WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    address public constant TRI_CRV = address(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);

    // Curve pool
    address public constant CURVE_POOL = address(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7);

    mapping(address => int128) public triPoolIndex; // dev: 3Pool is immutable so these won't change
    mapping(address => mapping(address => address)) public lpTokens;

    constructor() {
        triPoolIndex[DAI] = int128(0);
        triPoolIndex[USDC] = int128(1);
        triPoolIndex[USDT] = int128(2);

        IERC20(DAI).safeApprove(SUSHISWAP, type(uint256).max);
        IERC20(USDC).safeApprove(SUSHISWAP, type(uint256).max);
        IERC20(USDT).safeApprove(SUSHISWAP, type(uint256).max);

        IERC20(DAI).safeApprove(UNISWAP, type(uint256).max);
        IERC20(USDC).safeApprove(UNISWAP, type(uint256).max);
        IERC20(USDT).safeApprove(UNISWAP, type(uint256).max);
    }

    function swap(
        address fromToken,
        address toToken,
        uint256 swapAmount,
        uint256 minAmount
    ) external override returns (uint256) {
        require(
            fromToken == TRI_CRV && ((toToken == DAI) || (toToken == USDC) || (toToken == USDT)),
            ""Token pair not swappable""
        );
        IERC20(fromToken).transferFrom(msg.sender, address(this), swapAmount);
        (address dex, address token) = _getBestTokenToWithdraw(swapAmount, toToken);
        ICurveSwap(CURVE_POOL).remove_liquidity_one_coin(swapAmount, triPoolIndex[token], 0);
        uint256 amountReceived = _swapAll(token, toToken, dex);

        require(amountReceived >= minAmount, Error.INSUFFICIENT_FUNDS_RECEIVED);
        return amountReceived;
    }

    /**
     * @notice Calculate the exchange rate for the token pair.
     */
    function getRate(address fromToken, address toToken) external view override returns (uint256) {
        require(
            fromToken == TRI_CRV && ((toToken == DAI) || (toToken == USDC) || (toToken == USDT)),
            ""Token pair not swappable""
        );
        if (toToken == DAI) return ICurveSwap(CURVE_POOL).get_virtual_price();
        return ICurveSwap(CURVE_POOL).get_virtual_price() / 1e12;
    }

    /**
     * @dev Swaps the contracts full balance of tokenIn for tokenOut.
     * @param tokenIn Token to swap for tokenOut.
     * @param tokenOut Target token to receive in swap.
     * @return The amount of tokenOut received.
     */
    function _swapAll(
        address tokenIn,
        address tokenOut,
        address dex
    ) internal returns (uint256) {
        uint256 amountIn = IERC20(tokenIn).balanceOf(address(this));
        if (tokenIn == tokenOut) {
            IERC20(tokenOut).safeTransfer(msg.sender, amountIn);
            return amountIn;
        }
        if (amountIn == 0) return 0;
        address[] memory path = new address[](3);
        path[0] = tokenIn;
        path[1] = WETH;
        path[2] = tokenOut;
        return
            UniswapRouter02(dex).swapExactTokensForTokens(
                amountIn,
                0,
                path,
                msg.sender,
                block.timestamp
            )[2];
    }

    /**
     * @dev Gets the best token to withdraw from Curve Pool for swapping.
     * @param amount Amount of 3CRV to withdraw and swap.
     * @param tokenOut Target token to receive in swap.
     * @return The best token to withdraw from Curve Pool for swapping.
     */
    function _getBestTokenToWithdraw(uint256 amount, address tokenOut)
        internal
        view
        returns (address, address)
    {
        (address daiDex, uint256 daiOutput) = _getAmountOut(amount, DAI, tokenOut);
        (address usdcDex, uint256 usdcOutput) = _getAmountOut(amount, USDC, tokenOut);
        (address usdtDex, uint256 usdtOutput) = _getAmountOut(amount, USDT, tokenOut);
        if (daiOutput > usdcOutput && daiOutput > usdtOutput) {
            return (daiDex, DAI);
        } else if (usdcOutput > usdtOutput) {
            return (usdcDex, USDC);
        } else {
            return (usdtDex, USDT);
        }
    }

    /**
     * @dev Gets the amount of tokenOut received if swapping 3CRV via tokenIn.
     * @param amountIn The amount of 3CRV to withdraw and swap.
     * @param tokenIn Token to withdraw liquidity in from Curve Pool and to swap with tokenOut.
     * @param tokenOut Target token out.
     * @return The amount of tokenOut received.
     */
    function _getAmountOut(
        uint256 amountIn,
        address tokenIn,
        address tokenOut
    ) internal view returns (address, uint256) {
        uint256 coinReceived = ICurveSwap(CURVE_POOL).calc_withdraw_one_coin(
            amountIn,
            triPoolIndex[tokenIn]
        );
        if (tokenIn == tokenOut) return (address(0), coinReceived);
        (address dex, uint256 amountOut) = _getBestDex(tokenIn, tokenOut, coinReceived);
        return (dex, amountOut);
    }

    /**
     * @dev Gets the best DEX to use for swapping token.
     *      Compares the amount out for Uniswap and Sushiswap.
     * @param fromToken Token to swap from.
     * @param toToken Token to swap to.
     * @param amount Amount of fromToken to swap.
     * @return bestDex The address of the best DEX to use.
     * @return amountOut The amount of toToken received from swapping.
     */
    function _getBestDex(
        address fromToken,
        address toToken,
        uint256 amount
    ) internal view returns (address bestDex, uint256 amountOut) {
        address uniswap_ = UNISWAP;
        address sushiSwap_ = UNISWAP;
        uint256 amountOutUniswap = _tokenAmountOut(fromToken, toToken, amount, uniswap_);
        uint256 amountOutSushiSwap = _tokenAmountOut(fromToken, toToken, amount, sushiSwap_);
        return
            amountOutUniswap >= amountOutSushiSwap
                ? (uniswap_, amountOutUniswap)
                : (sushiSwap_, amountOutSushiSwap);
    }

    /**
     * @notice Gets the amount of tokenOut that would be received by selling the tokenIn for underlying
     * @return tokenOut amount that would be received
     */
    function _tokenAmountOut(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        address dex
    ) internal view returns (uint256) {
        address[] memory path = new address[](3);
        path[0] = tokenIn;
        path[1] = WETH;
        path[2] = tokenOut;
        return UniswapRouter02(dex).getAmountsOut(amountIn, path)[2];
    }
}",2160
RealWorld_BA_112_TopUpActionProfiler_RealWord_20240829191540.log,112,TopUpActionProfiler,13713,5244,18957,88.0,0.173445,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";

import ""../../pool/LiquidityPool.sol"";
import ""../../actions/topup/TopUpAction.sol"";
import ""../../LpToken.sol"";

contract TopUpActionProfiler {
    TopUpAction public topUpAction;

    constructor(address _topUpAction, address lpToken) {
        topUpAction = TopUpAction(payable(_topUpAction));
        LpToken(lpToken).approve(address(topUpAction), type(uint256).max);
    }

    function profileRegister(
        bytes32 account,
        bytes32 protocol,
        uint64 threshold,
        address depositToken,
        uint128 depositAmount,
        address actionToken,
        uint128 singleTopUpAmount,
        uint128 totalTopUpAmount,
        bytes memory extra
    ) external {
        topUpAction.register(
            account,
            protocol,
            depositAmount,
            ITopUpAction.Record({
                threshold: threshold,
                priorityFee: 10**9,
                maxFee: 30 * 10**9,
                actionToken: actionToken,
                depositToken: depositToken,
                singleTopUpAmount: singleTopUpAmount,
                totalTopUpAmount: totalTopUpAmount,
                depositTokenBalance: 0,
                extra: extra
            })
        );

        topUpAction.resetPosition(account, protocol, true);

        topUpAction.register(
            account,
            protocol,
            depositAmount,
            ITopUpAction.Record({
                threshold: threshold,
                priorityFee: 10**9,
                maxFee: 30 * 10**9,
                actionToken: actionToken,
                depositToken: depositToken,
                singleTopUpAmount: singleTopUpAmount,
                totalTopUpAmount: totalTopUpAmount,
                depositTokenBalance: 0,
                extra: extra
            })
        );
    }

    function simpleRegister(
        bytes32 account,
        bytes32 protocol,
        uint64 threshold,
        address depositToken,
        uint128 depositAmount,
        address actionToken,
        uint128 singleTopUpAmount,
        uint128 totalTopUpAmount,
        bytes memory extra
    ) external {
        topUpAction.register(
            account,
            protocol,
            depositAmount,
            ITopUpAction.Record({
                threshold: threshold,
                priorityFee: 10**9,
                maxFee: 30 * 10**9,
                actionToken: actionToken,
                depositToken: depositToken,
                singleTopUpAmount: singleTopUpAmount,
                totalTopUpAmount: totalTopUpAmount,
                depositTokenBalance: 0,
                extra: extra
            })
        );
    }

    function profileExecute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external {
        topUpAction.execute(payer, account, beneficiary, protocol, 0);
    }
}",647
RealWorld_BA_112_ICurveSwap_RealWord_20240829214121.log,112,ICurveSwap,9131,5057,14188,95.0,0.146795,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface ICurveSwap {
    function get_virtual_price() external view returns (uint256);

    function add_liquidity(uint256[3] calldata amounts, uint256 min_mint_amount) external;

    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount) external;

    function remove_liquidity_imbalance(uint256[3] calldata amounts, uint256 max_burn_amount)
        external;

    function remove_liquidity_imbalance(uint256[2] calldata amounts, uint256 max_burn_amount)
        external;

    function remove_liquidity(uint256 _amount, uint256[3] calldata min_amounts) external;

    function exchange(
        int128 from,
        int128 to,
        uint256 _from_amount,
        uint256 _min_to_amount
    ) external;

    function coins(uint256 i) external view returns (address);

    function get_dy(
        int128 i,
        int128 j,
        uint256 _dx
    ) external view returns (uint256);

    function calc_token_amount(uint256[4] calldata amounts, bool deposit)
        external
        view
        returns (uint256);

    function calc_token_amount(uint256[3] calldata amounts, bool deposit)
        external
        view
        returns (uint256);

    function calc_token_amount(uint256[2] calldata amounts, bool deposit)
        external
        view
        returns (uint256);

    function calc_withdraw_one_coin(uint256 _token_amount, int128 i)
        external
        view
        returns (uint256);

    function remove_liquidity_one_coin(
        uint256 _token_amount,
        int128 i,
        uint256 min_amount
    ) external;
}",386
RealWorld_BA_112_IRewardsGauge_RealWord_20240829210017.log,112,IRewardsGauge,3713,4390,8103,89.0,0.106365,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IRewardsGauge {
    function claimRewards(address beneficiary) external returns (uint256);
}",45
RealWorld_BA_112_IRoleManager_RealWord_20240829202000.log,112,IRoleManager,6644,4473,11117,77.0,0.12268,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IRoleManager {
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    function grantRole(bytes32 role, address account) external;

    function revokeRole(bytes32 role, address account) external;

    function hasRole(bytes32 role, address account) external view returns (bool);

    function hasAnyRole(bytes32[] memory roles, address account) external view returns (bool);

    function hasAnyRole(
        bytes32 role1,
        bytes32 role2,
        address account
    ) external view returns (bool);

    function hasAnyRole(
        bytes32 role1,
        bytes32 role2,
        bytes32 role3,
        address account
    ) external view returns (bool);

    function getRoleMemberCount(bytes32 role) external view returns (uint256);

    function getRoleMember(bytes32 role, uint256 index) external view returns (address);
}",229
RealWorld_BA_112_IVaultReserve_RealWord_20240829202547.log,112,IVaultReserve,5131,4671,9802,93.0,0.119075,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IVaultReserve {
    event Deposit(address indexed vault, address indexed token, uint256 amount);
    event Withdraw(address indexed vault, address indexed token, uint256 amount);
    event VaultListed(address indexed vault);

    function deposit(address token, uint256 amount) external payable returns (bool);

    function withdraw(address token, uint256 amount) external returns (bool);

    function getBalance(address vault, address token) external view returns (uint256);

    function canWithdraw(address vault) external view returns (bool);
}",130
RealWorld_BA_112_ICurveRegistry_RealWord_20240829212841.log,112,ICurveRegistry,3617,3426,7043,77.0,0.086605,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface ICurveRegistry {
    function get_A(address curvePool_) external view returns (uint256);
}",39
RealWorld_BA_112_KeeperGauge_RealWord_20240829193729.log,112,KeeperGauge,22775,5487,28262,84.0,0.223615,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""../../interfaces/IController.sol"";
import ""../../interfaces/tokenomics/IKeeperGauge.sol"";

import ""../../libraries/ScaledMath.sol"";
import ""../../libraries/Errors.sol"";
import ""../../libraries/AddressProviderHelpers.sol"";

import ""../access/Authorization.sol"";

contract KeeperGauge is IKeeperGauge, Authorization {
    using AddressProviderHelpers for IAddressProvider;
    using ScaledMath for uint256;

    struct KeeperRecord {
        mapping(uint256 => uint256) feesInPeriod;
        uint256 nextEpochToClaim;
        bool firstEpochSet;
    }

    mapping(address => KeeperRecord) public keeperRecords;
    mapping(uint256 => uint256) public perPeriodTotalFees;

    IController public immutable controller;
    address public immutable pool;
    uint256 public epoch;

    uint48 public lastUpdated;
    mapping(uint256 => uint256) public perPeriodTotalInflation;

    bool public override killed;

    modifier onlyInflationManager() {
        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);
        _;
    }

    constructor(IController _controller, address _pool)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        pool = _pool;
        lastUpdated = uint48(block.timestamp);
    }

    /**
     * @notice Shut down the gauge.
     * @dev Accrued inflation can still be claimed from the gauge after shutdown.
     * @return `true` if successful.
     */
    function kill() external override onlyInflationManager returns (bool) {
        poolCheckpoint();
        epoch++;
        killed = true;
        return true;
    }

    /**
     * @notice Report fees generated by a keeper (this is the basis for inflation accrual).
     * @dev lpTokenAddress is included for forward compatibility with a single gauge solution.
     * @param beneficiary Address of the keeper who earned the fees.
     * @param amount Amount of fees (in lp tokens) earned.
     * @param lpTokenAddress Address of the lpToken in which the fees are paid.
     * @return `true` if successful.
     */
    function reportFees(
        address beneficiary,
        uint256 amount,
        address lpTokenAddress
    ) external override returns (bool) {
        lpTokenAddress; // silencing compiler warning
        require(
            IController(controller).addressProvider().isWhiteListedFeeHandler(msg.sender),
            Error.ADDRESS_NOT_WHITELISTED
        );
        require(!killed, Error.CONTRACT_PAUSED);
        if (!keeperRecords[beneficiary].firstEpochSet) {
            keeperRecords[beneficiary].firstEpochSet = true;
            keeperRecords[beneficiary].nextEpochToClaim = epoch;
        }
        keeperRecords[beneficiary].feesInPeriod[epoch] += amount;
        perPeriodTotalFees[epoch] += amount;
        return true;
    }

    /**
     * @notice Advance the inflation accrual epoch.
     * @return `true` if successful.
     */
    function advanceEpoch() external virtual override onlyInflationManager returns (bool) {
        poolCheckpoint();
        epoch++;
        return true;
    }

    function claimRewards(address beneficiary) external override returns (uint256) {
        return claimRewards(beneficiary, epoch);
    }

    function claimableRewards(address beneficiary) external view override returns (uint256) {
        return _calcTotalClaimable(beneficiary, keeperRecords[beneficiary].nextEpochToClaim, epoch);
    }

    function poolCheckpoint() public override returns (bool) {
        if (killed) return false;
        uint256 timeElapsed = block.timestamp - uint256(lastUpdated);
        uint256 currentRate = IController(controller).inflationManager().getKeeperRateForPool(pool);
        perPeriodTotalInflation[epoch] += currentRate * timeElapsed;
        lastUpdated = uint48(block.timestamp);
        return true;
    }

    /**
     * @notice Claim rewards with an epoch up to which they should be claimed specified.
     * @param beneficiary Address to claim rewards for.
     * @param endEpoch Epoch up to which to claim rewards.
     * @return The amount of rewards claimed.
     */
    function claimRewards(address beneficiary, uint256 endEpoch) public returns (uint256) {
        require(
            msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );
        if (endEpoch > epoch) {
            endEpoch = epoch;
        }

        uint256 totalClaimable = _calcTotalClaimable(
            beneficiary,
            keeperRecords[beneficiary].nextEpochToClaim,
            endEpoch
        );
        keeperRecords[beneficiary].nextEpochToClaim = endEpoch;
        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED);
        _mintRewards(beneficiary, totalClaimable);

        return totalClaimable;
    }

    function _mintRewards(address beneficiary, uint256 amount) internal returns (bool) {
        IController(controller).inflationManager().mintRewards(beneficiary, amount);
        return true;
    }

    function _calcTotalClaimable(
        address beneficiary,
        uint256 startEpoch,
        uint256 endEpoch
    ) internal view returns (uint256) {
        uint256 totalClaimable = 0;
        for (uint256 i = startEpoch; i < endEpoch; i++) {
            totalClaimable += (
                keeperRecords[beneficiary].feesInPeriod[i].scaledDiv(perPeriodTotalFees[i])
            ).scaledMul(perPeriodTotalInflation[i]);
        }
        return totalClaimable;
    }
}",1224
RealWorld_BA_112_IRewardStaking_RealWord_20240829213441.log,112,IRewardStaking,5884,4914,10798,94.0,0.1277,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

interface IRewardStaking {
    function stakeFor(address, uint256) external;

    function stake(uint256) external;

    function stakeAll() external returns (bool);

    function withdraw(uint256 amount, bool claim) external returns (bool);

    function withdrawAndUnwrap(uint256 amount, bool claim) external returns (bool);

    function earned(address account) external view returns (uint256);

    function getReward() external;

    function getReward(address _account, bool _claimExtras) external;

    function extraRewardsLength() external view returns (uint256);

    function extraRewards(uint256 _pid) external view returns (address);

    function rewardToken() external view returns (address);

    function balanceOf(address account) external view returns (uint256);
}",175
RealWorld_BA_112_MockVotingEscrow_RealWord_20240829183727.log,112,MockVotingEscrow,10098,4760,14858,79.0,0.14569,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../interfaces/vendor/IGauge.sol"";
import ""./MockErc20.sol"";

contract MockVotingEscrow is IVotingEscrow {
    // mock total veCRV supply
    uint256 private _supply = 0;

    address private _crvToken;

    // veCRV balances
    mapping(address => uint256) private _balances;

    constructor(address crvToken_) {
        _crvToken = crvToken_;
    }

    // we don't actually lock tokens and we don't account for linear decay in balance
    // solhint-disable-next-line func-name-mixedcase
    function create_lock(
        uint256 _value,
        uint256 /* _time */
    ) external override {
        require(
            MockErc20(_crvToken).balanceOf(msg.sender) >= _value,
            ""msg.sender has insufficient funds to lock""
        );
        _deposit(_value);
    }

    // solhint-disable-next-line func-name-mixedcase
    function increase_amount(uint256 _value) external override {
        require(_balances[msg.sender] > 0, ""a lock needs to first be created"");
        _deposit(_value);
    }

    // solhint-disable-next-line func-name-mixedcase
    function increase_unlock_time(uint256 unlockTime) external override {}

    function withdraw() external override {
        // We don't withdraw; skip for mocking
    }

    // mock change in total veCRV supply
    function updateTotalSupply(uint256 amount) external {
        _supply = amount;
    }

    function balanceOf(address _address) external view override returns (uint256) {
        return _balances[_address];
    }

    function totalSupply() external view override returns (uint256) {
        return _supply;
    }

    function _deposit(uint256 amount) internal {
        MockErc20(_crvToken).transferFrom(msg.sender, address(this), amount);
        _balances[msg.sender] += amount;
        _supply += amount;
    }
}",438
RealWorld_BA_112_DecimalScale_RealWord_20240829200606.log,112,DecimalScale,5050,4119,9169,81.0,0.10763,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

library DecimalScale {
    uint8 internal constant DECIMALS = 18; // 18 decimal places

    function scaleFrom(uint256 value, uint8 decimals) internal pure returns (uint256) {
        if (decimals == DECIMALS) {
            return value;
        } else if (decimals > DECIMALS) {
            return value / 10**(decimals - DECIMALS);
        } else {
            return value * 10**(DECIMALS - decimals);
        }
    }
}",129
RealWorld_BA_113_INFTOracle_RealWord_20240829231250.log,113,INFTOracle,11166,5254,16420,102.0,0.16091,"// SPDX-License-Identifier: MIT
pragma solidity >= 0.6.12;

interface INFTOracle {
    /// @notice Get the latest exchange rate.
    /// @param pair address of the NFTPair calling the oracle
    /// @param tokenId tokenId of the NFT in question 
    /// @return success if no valid (recent) rate is available, return false else true.
    /// @return rate The rate of the requested asset / pair / pool.
    function get(address pair, uint256 tokenId) external returns (bool success, uint256 rate);

    /// @notice Check the last exchange rate without any state changes.
    /// @param pair address of the NFTPair calling the oracle
    /// @param tokenId tokenId of the NFT in question 
    /// @return success if no valid (recent) rate is available, return false else true.
    /// @return rate The rate of the requested asset / pair / pool.
    function peek(address pair, uint256 tokenId) external view returns (bool success, uint256 rate);

    /// @notice Check the current spot exchange rate without any state changes. For oracles like TWAP this will be different from peek().
    /// @param pair address of the NFTPair calling the oracle
    /// @param tokenId tokenId of the NFT in question 
    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));
    /// @return rate The rate of the requested asset / pair / pool.
    function peekSpot(address pair, uint256 tokenId) external view returns (uint256 rate);

    /// @notice Returns a human readable (short) name about this oracle.
    /// @param pair address of the NFTPair calling the oracle
    /// @param tokenId tokenId of the NFT in question 
    /// @return (string) A human readable symbol name about this oracle.
    function symbol(address pair, uint256 tokenId) external view returns (string memory);

    /// @notice Returns a human readable name about this oracle.
    /// @param pair address of the NFTPair calling the oracle
    /// @param tokenId tokenId of the NFT in question 
    /// @return (string) A human readable name about this oracle.
    function name(address pair, uint256 tokenId) external view returns (string memory);
}",487
RealWorld_BA_113_ISwapperGeneric_RealWord_20240829231600.log,113,ISwapperGeneric,12239,5522,17761,113.0,0.171635,"// SPDX-License-Identifier: MIT
pragma solidity >= 0.6.12;
interface IERC20 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /// @notice EIP 2612
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}
interface ISwapperGeneric {
    /// @notice Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.
    /// Swaps it for at least 'amountToMin' of token 'to'.
    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.
    /// Returns the amount of tokens 'to' transferred to BentoBox.
    /// (The BentoBox skim function will be used by the caller to get the swapped funds).
    function swap(
        IERC20 fromToken,
        IERC20 toToken,
        address recipient,
        uint256 shareToMin,
        uint256 shareFrom
    ) external returns (uint256 extraShare, uint256 shareReturned);

    /// @notice Calculates the amount of token 'from' needed to complete the swap (amountFrom),
    /// this should be less than or equal to amountFromMax.
    /// Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.
    /// Swaps it for exactly 'exactAmountTo' of token 'to'.
    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.
    /// Transfers allocated, but unused 'from' tokens within the BentoBox to 'refundTo' (amountFromMax - amountFrom).
    /// Returns the amount of 'from' tokens withdrawn from BentoBox (amountFrom).
    /// (The BentoBox skim function will be used by the caller to get the swapped funds).
    function swapExact(
        IERC20 fromToken,
        IERC20 toToken,
        address recipient,
        address refundTo,
        uint256 shareFromSupplied,
        uint256 shareToExact
    ) external returns (uint256 shareUsed, uint256 shareReturned);
}",564
RealWorld_BA_113_BentoBoxFlat_RealWord_20240829225141.log,113,BentoBoxFlat,0,0,0,,0.0,"// SPDX-License-Identifier: UNLICENSED
// The BentoBox

//  ▄▄▄▄· ▄▄▄ . ▐ ▄ ▄▄▄▄▄      ▄▄▄▄·       ▐▄• ▄
//  ▐█ ▀█▪▀▄.▀·█▌▐█•██  ▪     ▐█ ▀█▪▪      █▌█▌▪
//  ▐█▀▀█▄▐▀▀▪▄▐█▐▐▌ ▐█.▪ ▄█▀▄ ▐█▀▀█▄ ▄█▀▄  ·██·
//  ██▄▪▐█▐█▄▄▌██▐█▌ ▐█▌·▐█▌.▐▌██▄▪▐█▐█▌.▐▌▪▐█·█▌
//  ·▀▀▀▀  ▀▀▀ ▀▀ █▪ ▀▀▀  ▀█▄▀▪·▀▀▀▀  ▀█▄▀▪•▀▀ ▀▀

// This contract stores funds, handles their transfers, supports flash loans and strategies.

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to Keno for all his hard work and support

// Version 22-Mar-2021

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

// solhint-disable avoid-low-level-calls
// solhint-disable not-rely-on-time
// solhint-disable no-inline-assembly

// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.0
// License-Identifier: MIT

interface IERC20 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /// @notice EIP 2612
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

// File contracts/interfaces/IFlashLoan.sol
// License-Identifier: MIT

interface IFlashBorrower {
    /// @notice The flashloan callback. `amount` + `fee` needs to repayed to msg.sender before this call returns.
    /// @param sender The address of the invoker of this flashloan.
    /// @param token The address of the token that is loaned.
    /// @param amount of the `token` that is loaned.
    /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as `token`.
    /// @param data Additional data that was passed to the flashloan function.
    function onFlashLoan(
        address sender,
        IERC20 token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external;
}

interface IBatchFlashBorrower {
    /// @notice The callback for batched flashloans. Every amount + fee needs to repayed to msg.sender before this call returns.
    /// @param sender The address of the invoker of this flashloan.
    /// @param tokens Array of addresses for ERC-20 tokens that is loaned.
    /// @param amounts A one-to-one map to `tokens` that is loaned.
    /// @param fees A one-to-one map to `tokens` that needs to be paid on top for each loan. Needs to be the same token.
    /// @param data Additional data that was passed to the flashloan function.
    function onBatchFlashLoan(
        address sender,
        IERC20[] calldata tokens,
        uint256[] calldata amounts,
        uint256[] calldata fees,
        bytes calldata data
    ) external;
}

// File contracts/interfaces/IWETH.sol
// License-Identifier: MIT

interface IWETH {
    function deposit() external payable;

    function withdraw(uint256) external;
}

// File contracts/interfaces/IStrategy.sol
// License-Identifier: MIT

interface IStrategy {
    /// @notice Send the assets to the Strategy and call skim to invest them.
    /// @param amount The amount of tokens to invest.
    function skim(uint256 amount) external;

    /// @notice Harvest any profits made converted to the asset and pass them to the caller.
    /// @param balance The amount of tokens the caller thinks it has invested.
    /// @param sender The address of the initiator of this transaction. Can be used for reimbursements, etc.
    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.
    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);

    /// @notice Withdraw assets. The returned amount can differ from the requested amount due to rounding.
    /// @dev The `actualAmount` should be very close to the amount.
    /// The difference should NOT be used to report a loss. That's what harvest is for.
    /// @param amount The requested amount the caller wants to withdraw.
    /// @return actualAmount The real amount that is withdrawn.
    function withdraw(uint256 amount) external returns (uint256 actualAmount);

    /// @notice Withdraw all assets in the safest way possible. This shouldn't fail.
    /// @param balance The amount of tokens the caller thinks it has invested.
    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.
    function exit(uint256 balance) external returns (int256 amountAdded);
}

// File @boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol@v1.2.0
// License-Identifier: MIT

library BoringERC20 {
    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()
    bytes4 private constant SIG_NAME = 0x06fdde03; // name()
    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()
    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)
    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)

    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.
    /// Reverts on a failed transfer.
    /// @param token The address of the ERC-20 token.
    /// @param to Transfer tokens to.
    /// @param amount The token amount.
    function safeTransfer(
        IERC20 token,
        address to,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""BoringERC20: Transfer failed"");
    }

    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.
    /// Reverts on a failed transfer.
    /// @param token The address of the ERC-20 token.
    /// @param from Transfer tokens from.
    /// @param to Transfer tokens to.
    /// @param amount The token amount.
    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""BoringERC20: TransferFrom failed"");
    }
}

// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.0
// License-Identifier: MIT

/// @notice A library for performing overflow-/underflow-safe math,
/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).
library BoringMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b == 0 || (c = a * b) / b == a, ""BoringMath: Mul Overflow"");
    }

    function to128(uint256 a) internal pure returns (uint128 c) {
        require(a <= uint128(-1), ""BoringMath: uint128 Overflow"");
        c = uint128(a);
    }

    function to64(uint256 a) internal pure returns (uint64 c) {
        require(a <= uint64(-1), ""BoringMath: uint64 Overflow"");
        c = uint64(a);
    }

    function to32(uint256 a) internal pure returns (uint32 c) {
        require(a <= uint32(-1), ""BoringMath: uint32 Overflow"");
        c = uint32(a);
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.
library BoringMath128 {
    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.
library BoringMath64 {
    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.
library BoringMath32 {
    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

// File @boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol@v1.2.0
// License-Identifier: MIT

struct Rebase {
    uint128 elastic;
    uint128 base;
}

/// @notice A rebasing library using overflow-/underflow-safe math.
library RebaseLibrary {
    using BoringMath for uint256;
    using BoringMath128 for uint128;

    /// @notice Calculates the base value in relationship to `elastic` and `total`.
    function toBase(
        Rebase memory total,
        uint256 elastic,
        bool roundUp
    ) internal pure returns (uint256 base) {
        if (total.elastic == 0) {
            base = elastic;
        } else {
            base = elastic.mul(total.base) / total.elastic;
            if (roundUp && base.mul(total.elastic) / total.base < elastic) {
                base = base.add(1);
            }
        }
    }

    /// @notice Calculates the elastic value in relationship to `base` and `total`.
    function toElastic(
        Rebase memory total,
        uint256 base,
        bool roundUp
    ) internal pure returns (uint256 elastic) {
        if (total.base == 0) {
            elastic = base;
        } else {
            elastic = base.mul(total.elastic) / total.base;
            if (roundUp && elastic.mul(total.base) / total.elastic < base) {
                elastic = elastic.add(1);
            }
        }
    }

    /// @notice Add `elastic` to `total` and doubles `total.base`.
    /// @return (Rebase) The new total.
    /// @return base in relationship to `elastic`.
    function add(
        Rebase memory total,
        uint256 elastic,
        bool roundUp
    ) internal pure returns (Rebase memory, uint256 base) {
        base = toBase(total, elastic, roundUp);
        total.elastic = total.elastic.add(elastic.to128());
        total.base = total.base.add(base.to128());
        return (total, base);
    }

    /// @notice Sub `base` from `total` and update `total.elastic`.
    /// @return (Rebase) The new total.
    /// @return elastic in relationship to `base`.
    function sub(
        Rebase memory total,
        uint256 base,
        bool roundUp
    ) internal pure returns (Rebase memory, uint256 elastic) {
        elastic = toElastic(total, base, roundUp);
        total.elastic = total.elastic.sub(elastic.to128());
        total.base = total.base.sub(base.to128());
        return (total, elastic);
    }

    /// @notice Add `elastic` and `base` to `total`.
    function add(
        Rebase memory total,
        uint256 elastic,
        uint256 base
    ) internal pure returns (Rebase memory) {
        total.elastic = total.elastic.add(elastic.to128());
        total.base = total.base.add(base.to128());
        return total;
    }

    /// @notice Subtract `elastic` and `base` to `total`.
    function sub(
        Rebase memory total,
        uint256 elastic,
        uint256 base
    ) internal pure returns (Rebase memory) {
        total.elastic = total.elastic.sub(elastic.to128());
        total.base = total.base.sub(base.to128());
        return total;
    }

    /// @notice Add `elastic` to `total` and update storage.
    /// @return newElastic Returns updated `elastic`.
    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {
        newElastic = total.elastic = total.elastic.add(elastic.to128());
    }

    /// @notice Subtract `elastic` from `total` and update storage.
    /// @return newElastic Returns updated `elastic`.
    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {
        newElastic = total.elastic = total.elastic.sub(elastic.to128());
    }
}

// File @boringcrypto/boring-solidity/contracts/BoringOwnable.sol@v1.2.0
// License-Identifier: MIT

// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol
// Edited by BoringCrypto

contract BoringOwnableData {
    address public owner;
    address public pendingOwner;
}

contract BoringOwnable is BoringOwnableData {
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /// @notice `owner` defaults to msg.sender on construction.
    constructor() public {
        owner = msg.sender;
        emit OwnershipTransferred(address(0), msg.sender);
    }

    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.
    /// Can only be invoked by the current `owner`.
    /// @param newOwner Address of the new owner.
    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.
    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.
    function transferOwnership(
        address newOwner,
        bool direct,
        bool renounce
    ) public onlyOwner {
        if (direct) {
            // Checks
            require(newOwner != address(0) || renounce, ""Ownable: zero address"");

            // Effects
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            pendingOwner = address(0);
        } else {
            // Effects
            pendingOwner = newOwner;
        }
    }

    /// @notice Needs to be called by `pendingOwner` to claim ownership.
    function claimOwnership() public {
        address _pendingOwner = pendingOwner;

        // Checks
        require(msg.sender == _pendingOwner, ""Ownable: caller != pending owner"");

        // Effects
        emit OwnershipTransferred(owner, _pendingOwner);
        owner = _pendingOwner;
        pendingOwner = address(0);
    }

    /// @notice Only allows the `owner` to execute the function.
    modifier onlyOwner() {
        require(msg.sender == owner, ""Ownable: caller is not the owner"");
        _;
    }
}

// File @boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol@v1.2.0
// License-Identifier: MIT

interface IMasterContract {
    /// @notice Init function that gets called from `BoringFactory.deploy`.
    /// Also kown as the constructor for cloned contracts.
    /// Any ETH send to `BoringFactory.deploy` ends up here.
    /// @param data Can be abi encoded arguments or anything else.
    function init(bytes calldata data) external payable;
}

// File @boringcrypto/boring-solidity/contracts/BoringFactory.sol@v1.2.0
// License-Identifier: MIT

contract BoringFactory {
    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);

    /// @notice Mapping from clone contracts to their masterContract.
    mapping(address => address) public masterContractOf;

    /// @notice Deploys a given master Contract as a clone.
    /// Any ETH transferred with this call is forwarded to the new clone.
    /// Emits `LogDeploy`.
    /// @param masterContract The address of the contract to clone.
    /// @param data Additional abi encoded calldata that is passed to the new clone via `IMasterContract.init`.
    /// @param useCreate2 Creates the clone by using the CREATE2 opcode, in this case `data` will be used as salt.
    /// @return cloneAddress Address of the created clone contract.
    function deploy(
        address masterContract,
        bytes calldata data,
        bool useCreate2
    ) public payable returns (address cloneAddress) {
        require(masterContract != address(0), ""BoringFactory: No masterContract"");
        bytes20 targetBytes = bytes20(masterContract); // Takes the first 20 bytes of the masterContract's address

        if (useCreate2) {
            // each masterContract has different code already. So clones are distinguished by their data only.
            bytes32 salt = keccak256(data);

            // Creates clone, more info here: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/
            assembly {
                let clone := mload(0x40)
                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
                mstore(add(clone, 0x14), targetBytes)
                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
                cloneAddress := create2(0, clone, 0x37, salt)
            }
        } else {
            assembly {
                let clone := mload(0x40)
                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
                mstore(add(clone, 0x14), targetBytes)
                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
                cloneAddress := create(0, clone, 0x37)
            }
        }
        masterContractOf[cloneAddress] = masterContract;

        IMasterContract(cloneAddress).init{value: msg.value}(data);

        emit LogDeploy(masterContract, data, cloneAddress);
    }
}

// File contracts/MasterContractManager.sol
// License-Identifier: UNLICENSED

contract MasterContractManager is BoringOwnable, BoringFactory {
    event LogWhiteListMasterContract(address indexed masterContract, bool approved);
    event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool approved);
    event LogRegisterProtocol(address indexed protocol);

    /// @notice masterContract to user to approval state
    mapping(address => mapping(address => bool)) public masterContractApproved;
    /// @notice masterContract to whitelisted state for approval without signed message
    mapping(address => bool) public whitelistedMasterContracts;
    /// @notice user nonces for masterContract approvals
    mapping(address => uint256) public nonces;

    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(""EIP712Domain(string name,uint256 chainId,address verifyingContract)"");
    // See https://eips.ethereum.org/EIPS/eip-191
    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = ""\x19\x01"";
    bytes32 private constant APPROVAL_SIGNATURE_HASH =
        keccak256(""SetMasterContractApproval(string warning,address user,address masterContract,bool approved,uint256 nonce)"");

    // solhint-disable-next-line var-name-mixedcase
    bytes32 private immutable _DOMAIN_SEPARATOR;
    // solhint-disable-next-line var-name-mixedcase
    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;

    constructor() public {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);
    }

    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {
        return keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, keccak256(""BentoBox V1""), chainId, address(this)));
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() public view returns (bytes32) {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);
    }

    /// @notice Other contracts need to register with this master contract so that users can approve them for the BentoBox.
    function registerProtocol() public {
        masterContractOf[msg.sender] = msg.sender;
        emit LogRegisterProtocol(msg.sender);
    }

    /// @notice Enables or disables a contract for approval without signed message.
    function whitelistMasterContract(address masterContract, bool approved) public onlyOwner {
        // Checks
        require(masterContract != address(0), ""MasterCMgr: Cannot approve 0"");

        // Effects
        whitelistedMasterContracts[masterContract] = approved;
        emit LogWhiteListMasterContract(masterContract, approved);
    }

    /// @notice Approves or revokes a `masterContract` access to `user` funds.
    /// @param user The address of the user that approves or revokes access.
    /// @param masterContract The address who gains or loses access.
    /// @param approved If True approves access. If False revokes access.
    /// @param v Part of the signature. (See EIP-191)
    /// @param r Part of the signature. (See EIP-191)
    /// @param s Part of the signature. (See EIP-191)
    // F4 - Check behaviour for all function arguments when wrong or extreme
    // F4: Don't allow masterContract 0 to be approved. Unknown contracts will have a masterContract of 0.
    // F4: User can't be 0 for signed approvals because the recoveredAddress will be 0 if ecrecover fails
    function setMasterContractApproval(
        address user,
        address masterContract,
        bool approved,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        // Checks
        require(masterContract != address(0), ""MasterCMgr: masterC not set""); // Important for security

        // If no signature is provided, the fallback is executed
        if (r == 0 && s == 0 && v == 0) {
            require(user == msg.sender, ""MasterCMgr: user not sender"");
            require(masterContractOf[user] == address(0), ""MasterCMgr: user is clone"");
            require(whitelistedMasterContracts[masterContract], ""MasterCMgr: not whitelisted"");
        } else {
            // Important for security - any address without masterContract has address(0) as masterContract
            // So approving address(0) would approve every address, leading to full loss of funds
            // Also, ecrecover returns address(0) on failure. So we check this:
            require(user != address(0), ""MasterCMgr: User cannot be 0"");

            // C10 - Protect signatures against replay, use nonce and chainId (SWC-121)
            // C10: nonce + chainId are used to prevent replays
            // C11 - All signatures strictly EIP-712 (SWC-117 SWC-122)
            // C11: signature is EIP-712 compliant
            // C12 - abi.encodePacked can't contain variable length user input (SWC-133)
            // C12: abi.encodePacked has fixed length parameters
            bytes32 digest =
                keccak256(
                    abi.encodePacked(
                        EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,
                        DOMAIN_SEPARATOR(),
                        keccak256(
                            abi.encode(
                                APPROVAL_SIGNATURE_HASH,
                                approved
                                    ? keccak256(""Give FULL access to funds in (and approved to) BentoBox?"")
                                    : keccak256(""Revoke access to BentoBox?""),
                                user,
                                masterContract,
                                approved,
                                nonces[user]++
                            )
                        )
                    )
                );
            address recoveredAddress = ecrecover(digest, v, r, s);
            require(recoveredAddress == user, ""MasterCMgr: Invalid Signature"");
        }

        // Effects
        masterContractApproved[masterContract][user] = approved;
        emit LogSetMasterContractApproval(masterContract, user, approved);
    }
}

// File @boringcrypto/boring-solidity/contracts/BoringBatchable.sol@v1.2.0
// License-Identifier: MIT

contract BaseBoringBatchable {
    /// @dev Helper function to extract a useful revert message from a failed call.
    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.
    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {
        // If the _res length is less than 68, then the transaction failed silently (without a revert message)
        if (_returnData.length < 68) return ""Transaction reverted silently"";

        assembly {
            // Slice the sighash.
            _returnData := add(_returnData, 0x04)
        }
        return abi.decode(_returnData, (string)); // All that remains is the revert string
    }

    /// @notice Allows batched call to self (this contract).
    /// @param calls An array of inputs for each call.
    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.
    /// @return successes An array indicating the success of a call, mapped one-to-one to `calls`.
    /// @return results An array with the returned data of each function call, mapped one-to-one to `calls`.
    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense
    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value
    // C3: The length of the loop is fully under user control, so can't be exploited
    // C7: Delegatecall is only used on the same contract, so it's safe
    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results) {
        successes = new bool[](calls.length);
        results = new bytes[](calls.length);
        for (uint256 i = 0; i < calls.length; i++) {
            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);
            require(success || !revertOnFail, _getRevertMsg(result));
            successes[i] = success;
            results[i] = result;
        }
    }
}

contract BoringBatchable is BaseBoringBatchable {
    /// @notice Call wrapper that performs `ERC20.permit` on `token`.
    /// Lookup `IERC20.permit`.
    // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)
    //     if part of a batch this could be used to grief once as the second call would not need the permit
    function permitToken(
        IERC20 token,
        address from,
        address to,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        token.permit(from, to, amount, deadline, v, r, s);
    }
}

// File contracts/BentoBox.sol
// License-Identifier: UNLICENSED

/// @title BentoBox
/// @author BoringCrypto, Keno
/// @notice The BentoBox is a vault for tokens. The stored tokens can be flash loaned and used in strategies.
/// Yield from this will go to the token depositors.
/// Rebasing tokens ARE NOT supported and WILL cause loss of funds.
/// Any funds transfered directly onto the BentoBox will be lost, use the deposit function instead.
contract BentoBoxV1 is MasterContractManager, BoringBatchable {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringERC20 for IERC20;
    using RebaseLibrary for Rebase;

    // ************** //
    // *** EVENTS *** //
    // ************** //

    event LogDeposit(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);
    event LogWithdraw(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);
    event LogTransfer(IERC20 indexed token, address indexed from, address indexed to, uint256 share);

    event LogFlashLoan(address indexed borrower, IERC20 indexed token, uint256 amount, uint256 feeAmount, address indexed receiver);

    event LogStrategyTargetPercentage(IERC20 indexed token, uint256 targetPercentage);
    event LogStrategyQueued(IERC20 indexed token, IStrategy indexed strategy);
    event LogStrategySet(IERC20 indexed token, IStrategy indexed strategy);
    event LogStrategyInvest(IERC20 indexed token, uint256 amount);
    event LogStrategyDivest(IERC20 indexed token, uint256 amount);
    event LogStrategyProfit(IERC20 indexed token, uint256 amount);
    event LogStrategyLoss(IERC20 indexed token, uint256 amount);

    // *************** //
    // *** STRUCTS *** //
    // *************** //

    struct StrategyData {
        uint64 strategyStartDate;
        uint64 targetPercentage;
        uint128 balance; // the balance of the strategy that BentoBox thinks is in there
    }

    // ******************************** //
    // *** CONSTANTS AND IMMUTABLES *** //
    // ******************************** //

    // V2 - Can they be private?
    // V2: Private to save gas, to verify it's correct, check the constructor arguments
    IERC20 private immutable wethToken;

    IERC20 private constant USE_ETHEREUM = IERC20(0);
    uint256 private constant FLASH_LOAN_FEE = 50; // 0.05%
    uint256 private constant FLASH_LOAN_FEE_PRECISION = 1e5;
    uint256 private constant STRATEGY_DELAY = 2 weeks;
    uint256 private constant MAX_TARGET_PERCENTAGE = 95; // 95%
    uint256 private constant MINIMUM_SHARE_BALANCE = 1000; // To prevent the ratio going off

    // ***************** //
    // *** VARIABLES *** //
    // ***************** //

    // Balance per token per address/contract in shares
    mapping(IERC20 => mapping(address => uint256)) public balanceOf;

    // Rebase from amount to share
    mapping(IERC20 => Rebase) public totals;

    mapping(IERC20 => IStrategy) public strategy;
    mapping(IERC20 => IStrategy) public pendingStrategy;
    mapping(IERC20 => StrategyData) public strategyData;

    // ******************* //
    // *** CONSTRUCTOR *** //
    // ******************* //

    constructor(IERC20 wethToken_) public {
        wethToken = wethToken_;
    }

    // ***************** //
    // *** MODIFIERS *** //
    // ***************** //

    /// Modifier to check if the msg.sender is allowed to use funds belonging to the 'from' address.
    /// If 'from' is msg.sender, it's allowed.
    /// If 'from' is the BentoBox itself, it's allowed. Any ETH, token balances (above the known balances) or BentoBox balances
    /// can be taken by anyone.
    /// This is to enable skimming, not just for deposits, but also for withdrawals or transfers, enabling better composability.
    /// If 'from' is a clone of a masterContract AND the 'from' address has approved that masterContract, it's allowed.
    modifier allowed(address from) {
        if (from != msg.sender && from != address(this)) {
            // From is sender or you are skimming
            address masterContract = masterContractOf[msg.sender];
            require(masterContract != address(0), ""BentoBox: no masterContract"");
            require(masterContractApproved[masterContract][from], ""BentoBox: Transfer not approved"");
        }
        _;
    }

    // ************************** //
    // *** INTERNAL FUNCTIONS *** //
    // ************************** //

    /// @dev Returns the total balance of `token` this contracts holds,
    /// plus the total amount this contract thinks the strategy holds.
    function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {
        amount = token.balanceOf(address(this)).add(strategyData[token].balance);
    }

    // ************************ //
    // *** PUBLIC FUNCTIONS *** //
    // ************************ //

    /// @dev Helper function to represent an `amount` of `token` in shares.
    /// @param token The ERC-20 token.
    /// @param amount The `token` amount.
    /// @param roundUp If the result `share` should be rounded up.
    /// @return share The token amount represented in shares.
    function toShare(
        IERC20 token,
        uint256 amount,
        bool roundUp
    ) external view returns (uint256 share) {
        share = totals[token].toBase(amount, roundUp);
    }

    /// @dev Helper function represent shares back into the `token` amount.
    /// @param token The ERC-20 token.
    /// @param share The amount of shares.
    /// @param roundUp If the result should be rounded up.
    /// @return amount The share amount back into native representation.
    function toAmount(
        IERC20 token,
        uint256 share,
        bool roundUp
    ) external view returns (uint256 amount) {
        amount = totals[token].toElastic(share, roundUp);
    }

    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.
    /// @param token_ The ERC-20 token to deposit.
    /// @param from which account to pull the tokens.
    /// @param to which account to push the tokens.
    /// @param amount Token amount in native representation to deposit.
    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.
    /// @return amountOut The amount deposited.
    /// @return shareOut The deposited amount repesented in shares.
    function deposit(
        IERC20 token_,
        address from,
        address to,
        uint256 amount,
        uint256 share
    ) public payable allowed(from) returns (uint256 amountOut, uint256 shareOut) {
        // Checks
        require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds

        // Effects
        IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;
        Rebase memory total = totals[token];

        // If a new token gets added, the tokenSupply call checks that this is a deployed contract. Needed for security.
        require(total.elastic != 0 || token.totalSupply() > 0, ""BentoBox: No tokens"");
        if (share == 0) {
            // value of the share may be lower than the amount due to rounding, that's ok
            share = total.toBase(amount, false);
            // Any deposit should lead to at least the minimum share balance, otherwise it's ignored (no amount taken)
            if (total.base.add(share.to128()) < MINIMUM_SHARE_BALANCE) {
                return (0, 0);
            }
        } else {
            // amount may be lower than the value of share due to rounding, in that case, add 1 to amount (Always round up)
            amount = total.toElastic(share, true);
        }

        // In case of skimming, check that only the skimmable amount is taken.
        // For ETH, the full balance is available, so no need to check.
        // During flashloans the _tokenBalanceOf is lower than 'reality', so skimming deposits will mostly fail during a flashloan.
        require(
            from != address(this) || token_ == USE_ETHEREUM || amount <= _tokenBalanceOf(token).sub(total.elastic),
            ""BentoBox: Skim too much""
        );

        balanceOf[token][to] = balanceOf[token][to].add(share);
        total.base = total.base.add(share.to128());
        total.elastic = total.elastic.add(amount.to128());
        totals[token] = total;

        // Interactions
        // During the first deposit, we check that this token is 'real'
        if (token_ == USE_ETHEREUM) {
            // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)
            // X2: If the WETH implementation is faulty or malicious, it will block adding ETH (but we know the WETH implementation)
            IWETH(address(wethToken)).deposit{value: amount}();
        } else if (from != address(this)) {
            // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)
            // X2: If the token implementation is faulty or malicious, it may block adding tokens. Good.
            token.safeTransferFrom(from, address(this), amount);
        }
        emit LogDeposit(token, from, to, amount, share);
        amountOut = amount;
        shareOut = share;
    }

    /// @notice Withdraws an amount of `token` from a user account.
    /// @param token_ The ERC-20 token to withdraw.
    /// @param from which user to pull the tokens.
    /// @param to which user to push the tokens.
    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.
    /// @param share Like above, but `share` takes precedence over `amount`.
    function withdraw(
        IERC20 token_,
        address from,
        address to,
        uint256 amount,
        uint256 share
    ) public allowed(from) returns (uint256 amountOut, uint256 shareOut) {
        // Checks
        require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds

        // Effects
        IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;
        Rebase memory total = totals[token];
        if (share == 0) {
            // value of the share paid could be lower than the amount paid due to rounding, in that case, add a share (Always round up)
            share = total.toBase(amount, true);
        } else {
            // amount may be lower than the value of share due to rounding, that's ok
            amount = total.toElastic(share, false);
        }

        balanceOf[token][from] = balanceOf[token][from].sub(share);
        total.elastic = total.elastic.sub(amount.to128());
        total.base = total.base.sub(share.to128());
        // There have to be at least 1000 shares left to prevent reseting the share/amount ratio (unless it's fully emptied)
        require(total.base >= MINIMUM_SHARE_BALANCE || total.base == 0, ""BentoBox: cannot empty"");
        totals[token] = total;

        // Interactions
        if (token_ == USE_ETHEREUM) {
            // X2, X3: A revert or big gas usage in the WETH contract could block withdrawals, but WETH9 is fine.
            IWETH(address(wethToken)).withdraw(amount);
            // X2, X3: A revert or big gas usage could block, however, the to address is under control of the caller.
            (bool success, ) = to.call{value: amount}("""");
            require(success, ""BentoBox: ETH transfer failed"");
        } else {
            // X2, X3: A malicious token could block withdrawal of just THAT token.
            //         masterContracts may want to take care not to rely on withdraw always succeeding.
            token.safeTransfer(to, amount);
        }
        emit LogWithdraw(token, from, to, amount, share);
        amountOut = amount;
        shareOut = share;
    }

    /// @notice Transfer shares from a user account to another one.
    /// @param token The ERC-20 token to transfer.
    /// @param from which user to pull the tokens.
    /// @param to which user to push the tokens.
    /// @param share The amount of `token` in shares.
    // Clones of master contracts can transfer from any account that has approved them
    // F3 - Can it be combined with another similar function?
    // F3: This isn't combined with transferMultiple for gas optimization
    function transfer(
        IERC20 token,
        address from,
        address to,
        uint256 share
    ) public allowed(from) {
        // Checks
        require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds

        // Effects
        balanceOf[token][from] = balanceOf[token][from].sub(share);
        balanceOf[token][to] = balanceOf[token][to].add(share);

        emit LogTransfer(token, from, to, share);
    }

    /// @notice Transfer shares from a user account to multiple other ones.
    /// @param token The ERC-20 token to transfer.
    /// @param from which user to pull the tokens.
    /// @param tos The receivers of the tokens.
    /// @param shares The amount of `token` in shares for each receiver in `tos`.
    // F3 - Can it be combined with another similar function?
    // F3: This isn't combined with transfer for gas optimization
    function transferMultiple(
        IERC20 token,
        address from,
        address[] calldata tos,
        uint256[] calldata shares
    ) public allowed(from) {
        // Checks
        require(tos[0] != address(0), ""BentoBox: to[0] not set""); // To avoid a bad UI from burning funds

        // Effects
        uint256 totalAmount;
        uint256 len = tos.length;
        for (uint256 i = 0; i < len; i++) {
            address to = tos[i];
            balanceOf[token][to] = balanceOf[token][to].add(shares[i]);
            totalAmount = totalAmount.add(shares[i]);
            emit LogTransfer(token, from, to, shares[i]);
        }
        balanceOf[token][from] = balanceOf[token][from].sub(totalAmount);
    }

    /// @notice Flashloan ability.
    /// @param borrower The address of the contract that implements and conforms to `IFlashBorrower` and handles the flashloan.
    /// @param receiver Address of the token receiver.
    /// @param token The address of the token to receive.
    /// @param amount of the tokens to receive.
    /// @param data The calldata to pass to the `borrower` contract.
    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
    // F5: Not possible to follow this here, reentrancy has been reviewed
    // F6 - Check for front-running possibilities, such as the approve function (SWC-114)
    // F6: Slight grieving possible by withdrawing an amount before someone tries to flashloan close to the full amount.
    function flashLoan(
        IFlashBorrower borrower,
        address receiver,
        IERC20 token,
        uint256 amount,
        bytes calldata data
    ) public {
        uint256 fee = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;
        token.safeTransfer(receiver, amount);

        borrower.onFlashLoan(msg.sender, token, amount, fee, data);

        require(_tokenBalanceOf(token) >= totals[token].addElastic(fee.to128()), ""BentoBox: Wrong amount"");
        emit LogFlashLoan(address(borrower), token, amount, fee, receiver);
    }

    /// @notice Support for batched flashloans. Useful to request multiple different `tokens` in a single transaction.
    /// @param borrower The address of the contract that implements and conforms to `IBatchFlashBorrower` and handles the flashloan.
    /// @param receivers An array of the token receivers. A one-to-one mapping with `tokens` and `amounts`.
    /// @param tokens The addresses of the tokens.
    /// @param amounts of the tokens for each receiver.
    /// @param data The calldata to pass to the `borrower` contract.
    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
    // F5: Not possible to follow this here, reentrancy has been reviewed
    // F6 - Check for front-running possibilities, such as the approve function (SWC-114)
    // F6: Slight grieving possible by withdrawing an amount before someone tries to flashloan close to the full amount.
    function batchFlashLoan(
        IBatchFlashBorrower borrower,
        address[] calldata receivers,
        IERC20[] calldata tokens,
        uint256[] calldata amounts,
        bytes calldata data
    ) public {
        uint256[] memory fees = new uint256[](tokens.length);

        uint256 len = tokens.length;
        for (uint256 i = 0; i < len; i++) {
            uint256 amount = amounts[i];
            fees[i] = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;

            tokens[i].safeTransfer(receivers[i], amounts[i]);
        }

        borrower.onBatchFlashLoan(msg.sender, tokens, amounts, fees, data);

        for (uint256 i = 0; i < len; i++) {
            IERC20 token = tokens[i];
            require(_tokenBalanceOf(token) >= totals[token].addElastic(fees[i].to128()), ""BentoBox: Wrong amount"");
            emit LogFlashLoan(address(borrower), token, amounts[i], fees[i], receivers[i]);
        }
    }

    /// @notice Sets the target percentage of the strategy for `token`.
    /// @dev Only the owner of this contract is allowed to change this.
    /// @param token The address of the token that maps to a strategy to change.
    /// @param targetPercentage_ The new target in percent. Must be lesser or equal to `MAX_TARGET_PERCENTAGE`.
    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) public onlyOwner {
        // Checks
        require(targetPercentage_ <= MAX_TARGET_PERCENTAGE, ""StrategyManager: Target too high"");

        // Effects
        strategyData[token].targetPercentage = targetPercentage_;
        emit LogStrategyTargetPercentage(token, targetPercentage_);
    }

    /// @notice Sets the contract address of a new strategy that conforms to `IStrategy` for `token`.
    /// Must be called twice with the same arguments.
    /// A new strategy becomes pending first and can be activated once `STRATEGY_DELAY` is over.
    /// @dev Only the owner of this contract is allowed to change this.
    /// @param token The address of the token that maps to a strategy to change.
    /// @param newStrategy The address of the contract that conforms to `IStrategy`.
    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
    // F5: Total amount is updated AFTER interaction. But strategy is under our control.
    // C4 - Use block.timestamp only for long intervals (SWC-116)
    // C4: block.timestamp is used for a period of 2 weeks, which is long enough
    function setStrategy(IERC20 token, IStrategy newStrategy) public onlyOwner {
        StrategyData memory data = strategyData[token];
        IStrategy pending = pendingStrategy[token];
        if (data.strategyStartDate == 0 || pending != newStrategy) {
            pendingStrategy[token] = newStrategy;
            // C1 - All math done through BoringMath (SWC-101)
            // C1: Our sun will swallow the earth well before this overflows
            data.strategyStartDate = (block.timestamp + STRATEGY_DELAY).to64();
            emit LogStrategyQueued(token, newStrategy);
        } else {
            require(data.strategyStartDate != 0 && block.timestamp >= data.strategyStartDate, ""StrategyManager: Too early"");
            if (address(strategy[token]) != address(0)) {
                int256 balanceChange = strategy[token].exit(data.balance);
                // Effects
                if (balanceChange > 0) {
                    uint256 add = uint256(balanceChange);
                    totals[token].addElastic(add);
                    emit LogStrategyProfit(token, add);
                } else if (balanceChange < 0) {
                    uint256 sub = uint256(-balanceChange);
                    totals[token].subElastic(sub);
                    emit LogStrategyLoss(token, sub);
                }

                emit LogStrategyDivest(token, data.balance);
            }
            strategy[token] = pending;
            data.strategyStartDate = 0;
            data.balance = 0;
            pendingStrategy[token] = IStrategy(0);
            emit LogStrategySet(token, newStrategy);
        }
        strategyData[token] = data;
    }

    /// @notice The actual process of yield farming. Executes the strategy of `token`.
    /// Optionally does housekeeping if `balance` is true.
    /// `maxChangeAmount` is relevant for skimming or withdrawing if `balance` is true.
    /// @param token The address of the token for which a strategy is deployed.
    /// @param balance True if housekeeping should be done.
    /// @param maxChangeAmount The maximum amount for either pulling or pushing from/to the `IStrategy` contract.
    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
    // F5: Total amount is updated AFTER interaction. But strategy is under our control.
    // F5: Not followed to prevent reentrancy issues with flashloans and BentoBox skims?
    function harvest(
        IERC20 token,
        bool balance,
        uint256 maxChangeAmount
    ) public {
        StrategyData memory data = strategyData[token];
        IStrategy _strategy = strategy[token];
        int256 balanceChange = _strategy.harvest(data.balance, msg.sender);
        if (balanceChange == 0 && !balance) {
            return;
        }

        uint256 totalElastic = totals[token].elastic;

        if (balanceChange > 0) {
            uint256 add = uint256(balanceChange);
            totalElastic = totalElastic.add(add);
            totals[token].elastic = totalElastic.to128();
            emit LogStrategyProfit(token, add);
        } else if (balanceChange < 0) {
            // C1 - All math done through BoringMath (SWC-101)
            // C1: balanceChange could overflow if it's max negative int128.
            // But tokens with balances that large are not supported by the BentoBox.
            uint256 sub = uint256(-balanceChange);
            totalElastic = totalElastic.sub(sub);
            totals[token].elastic = totalElastic.to128();
            data.balance = data.balance.sub(sub.to128());
            emit LogStrategyLoss(token, sub);
        }

        if (balance) {
            uint256 targetBalance = totalElastic.mul(data.targetPercentage) / 100;
            // if data.balance == targetBalance there is nothing to update
            if (data.balance < targetBalance) {
                uint256 amountOut = targetBalance.sub(data.balance);
                if (maxChangeAmount != 0 && amountOut > maxChangeAmount) {
                    amountOut = maxChangeAmount;
                }
                token.safeTransfer(address(_strategy), amountOut);
                data.balance = data.balance.add(amountOut.to128());
                _strategy.skim(amountOut);
                emit LogStrategyInvest(token, amountOut);
            } else if (data.balance > targetBalance) {
                uint256 amountIn = data.balance.sub(targetBalance.to128());
                if (maxChangeAmount != 0 && amountIn > maxChangeAmount) {
                    amountIn = maxChangeAmount;
                }

                uint256 actualAmountIn = _strategy.withdraw(amountIn);

                data.balance = data.balance.sub(actualAmountIn.to128());
                emit LogStrategyDivest(token, actualAmountIn);
            }
        }

        strategyData[token] = data;
    }

    // Contract should be able to receive ETH deposits to support deposit & skim
    // solhint-disable-next-line no-empty-blocks
    receive() external payable {}
}",11873
RealWorld_BA_113_ReturnFalseERC20Mock_RealWord_20240829230755.log,113,ReturnFalseERC20Mock,15332,5171,20503,97.0,0.18008,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

// solhint-disable no-inline-assembly
// solhint-disable not-rely-on-time

// ReturnFalseERC20 does not revert on errors, it just returns false
contract ReturnFalseERC20Mock {
    string public symbol;
    string public name;
    uint8 public immutable decimals;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => uint256) public nonces;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    constructor(
        string memory name_,
        string memory symbol_,
        uint8 decimals_,
        uint256 supply
    ) public {
        name = name_;
        symbol = symbol_;
        decimals = decimals_;
        totalSupply = supply;
        balanceOf[msg.sender] = supply;
    }

    function transfer(address to, uint256 amount) public returns (bool success) {
        if (balanceOf[msg.sender] >= amount && balanceOf[to] + amount >= balanceOf[to]) {
            balanceOf[msg.sender] -= amount;
            balanceOf[to] += amount;
            emit Transfer(msg.sender, to, amount);
            return true;
        } else {
            return false;
        }
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public returns (bool success) {
        if (balanceOf[from] >= amount && allowance[from][msg.sender] >= amount && balanceOf[to] + amount >= balanceOf[to]) {
            balanceOf[from] -= amount;
            allowance[from][msg.sender] -= amount;
            balanceOf[to] += amount;
            emit Transfer(from, to, amount);
            return true;
        } else {
            return false;
        }
    }

    function approve(address spender, uint256 amount) public returns (bool success) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() public view returns (bytes32) {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        return keccak256(abi.encode(keccak256(""EIP712Domain(uint256 chainId,address verifyingContract)""), chainId, address(this)));
    }

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        require(block.timestamp < deadline, ""ReturnFalseERC20: Expired"");
        bytes32 digest =
            keccak256(
                abi.encodePacked(
                    ""\x19\x01"",
                    DOMAIN_SEPARATOR(),
                    keccak256(
                        abi.encode(
                            0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9,
                            owner,
                            spender,
                            value,
                            nonces[owner]++,
                            deadline
                        )
                    )
                )
            );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress == owner, ""ReturnFalseERC20: Invalid Sig"");
        allowance[owner][spender] = value;
        emit Approval(owner, spender, value);
    }
}",744
RealWorld_BA_113_LendingClubMock_RealWord_20240829225842.log,113,LendingClubMock,12958,5310,18268,103.0,0.17099,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"";
import ""../NFTPair.sol"";

// Minimal implementation to set up some tests.
contract LendingClubMock {
    INFTPair private immutable nftPair;
    address private immutable investor;

    constructor(INFTPair _nftPair, address _investor) public {
        nftPair = _nftPair;
        investor = _investor;
    }

    function init() public {
        nftPair.bentoBox().setMasterContractApproval(address(this), address(nftPair.masterContract()), true, 0, bytes32(0), bytes32(0));
    }

    function willLend(uint256 tokenId, TokenLoanParams memory requested) external view returns (bool) {
        if (msg.sender != address(nftPair)) {
            return false;
        }
        TokenLoanParams memory accepted = _lendingConditions(tokenId);
        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.

        return
            requested.valuation == accepted.valuation &&
            requested.duration <= accepted.duration &&
            requested.annualInterestBPS >= accepted.annualInterestBPS;
    }

    function _lendingConditions(uint256 tokenId) private pure returns (TokenLoanParams memory) {
        TokenLoanParams memory conditions;
        // No specific conditions given, but we'll take all even-numbered
        // ones at 100% APY:
        if (tokenId % 2 == 0) {
            // 256-bit addition fits by the above check.
            // Cast is.. relatively safe: this is a mock implementation,
            // production use is unlikely to follow this pattern for valuing
            // loans, and manipulating the token ID can only break the logic by
            // making the loan ""safer"" for the lender.
            conditions.valuation = uint128((tokenId + 1) * 10**18);
            conditions.duration = 365 days;
            conditions.annualInterestBPS = 10_000;
        }
        return conditions;
    }

    function lendingConditions(address _nftPair, uint256 tokenId) external view returns (TokenLoanParams memory) {
        if (_nftPair != address(nftPair)) {
            TokenLoanParams memory empty;
            return empty;
        } else {
            return _lendingConditions(tokenId);
        }
    }

    function seizeCollateral(uint256 tokenId) external {
        nftPair.removeCollateral(tokenId, investor);
    }

    function withdrawFunds(uint256 bentoShares) external {
        nftPair.bentoBox().transfer(nftPair.asset(), address(this), investor, bentoShares);
    }
}",592
RealWorld_BA_113_SushiSwapFactoryMock_RealWord_20240829225725.log,113,SushiSwapFactoryMock,4465,4123,8588,75.0,0.104785,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
import ""@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol"";
import ""@sushiswap/core/contracts/uniswapv2/UniswapV2Factory.sol"";

contract SushiSwapFactoryMock is UniswapV2Factory {
    constructor() public UniswapV2Factory(msg.sender) {
        return;
    }
}",97
RealWorld_BA_113_BentoBoxMock_RealWord_20240829230027.log,113,BentoBoxMock,5495,4950,10445,97.0,0.126475,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import ""../BentoBoxFlat.sol"";

contract BentoBoxMock is BentoBoxV1 {
    constructor(IERC20 weth) public BentoBoxV1(weth) {
        return;
    }

    function addProfit(IERC20 token, uint256 amount) public {
        token.safeTransferFrom(msg.sender, address(this), amount);
        totals[token].addElastic(amount);
    }

    function takeLoss(IERC20 token, uint256 amount) public {
        token.safeTransfer(msg.sender, amount);
        totals[token].subElastic(amount);
    }
}",142
RealWorld_BA_113_SimpleStrategyMock_RealWord_20240829230934.log,113,SimpleStrategyMock,10029,5316,15345,98.0,0.156465,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
import ""@sushiswap/bentobox-sdk/contracts/IStrategy.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"";

// solhint-disable not-rely-on-time

contract SimpleStrategyMock is IStrategy {
    using BoringMath for uint256;
    using BoringERC20 for IERC20;

    IERC20 private immutable token;
    address private immutable bentoBox;

    modifier onlyBentoBox() {
        require(msg.sender == bentoBox, ""Ownable: caller is not the owner"");
        _;
    }

    constructor(address bentoBox_, IERC20 token_) public {
        bentoBox = bentoBox_;
        token = token_;
    }

    // Send the assets to the Strategy and call skim to invest them
    function skim(uint256) external override onlyBentoBox {
        // Leave the tokens on the contract
        return;
    }

    // Harvest any profits made converted to the asset and pass them to the caller
    function harvest(uint256 balance, address) external override onlyBentoBox returns (int256 amountAdded) {
        amountAdded = int256(token.balanceOf(address(this)).sub(balance));
        token.safeTransfer(bentoBox, uint256(amountAdded)); // Add as profit
    }

    // Withdraw assets. The returned amount can differ from the requested amount due to rounding or if the request was more than there is.
    function withdraw(uint256 amount) external override onlyBentoBox returns (uint256 actualAmount) {
        token.safeTransfer(bentoBox, uint256(amount)); // Add as profit
        actualAmount = amount;
    }

    // Withdraw all assets in the safest way possible. This shouldn't fail.
    function exit(uint256 balance) external override onlyBentoBox returns (int256 amountAdded) {
        amountAdded = 0;
        token.safeTransfer(bentoBox, balance);
    }
}",434
RealWorld_BA_113_ERC721Mock_RealWord_20240829230444.log,113,ERC721Mock,4775,3953,8728,83.0,0.102935,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
import ""@boringcrypto/boring-solidity/contracts/BoringMultipleNFT.sol"";

contract ERC721Mock is BoringMultipleNFT {
    function mint(address owner) public returns (uint256 id) {
        id = totalSupply;
        _mint(owner, 0);
    }

    function _tokenURI(uint256) internal view override returns (string memory) {
        return """";
    }
}",98
RealWorld_BA_113_ERC20Mock_RealWord_20240829230313.log,113,ERC20Mock,4352,4400,8752,89.0,0.10976,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
import ""@boringcrypto/boring-solidity/contracts/ERC20.sol"";

contract ERC20Mock is ERC20 {
    uint256 public override totalSupply;

    constructor(uint256 _initialAmount) public {
        // Give the creator all initial tokens
        balanceOf[msg.sender] = _initialAmount;
        // Update total supply
        totalSupply = _initialAmount;
    }
}",95
RealWorld_BA_113_NFTPair_RealWord_20240829225039.log,113,NFTPair,0,0,0,,0.0,"// SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"";
import ""@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"";
import ""@boringcrypto/boring-solidity/contracts/Domain.sol"";
import ""@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"";
import ""@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"";
import ""./interfaces/IERC721.sol"";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPair
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPair is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(address indexed borrower, uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS);
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPair public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // ""Shares"" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns ""second-order"" interest-on-interest, which
    // itself earns ""third-order"" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why ""at least""? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator ""wins""; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the ""true"" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in ""total""
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), ""NFTPair: already initialized"");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), ""NFTPair: bad pair"");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, ""NFTPair: not the lender"");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration && params.valuation <= cur.valuation && params.annualInterestBPS <= cur.annualInterestBPS,
                ""NFTPair: worse params""
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert(""NFTPair: no collateral"");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, ""NFTPair: loan exists"");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), ""NFTPair: skim failed"");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral as the lender. The loan has to be
            // expired and not paid off:
            require(to == loan.lender, ""NFTPair: not the lender"");
            require(
                // Addition is safe: both summands are smaller than 256 bits
                uint256(loan.startTime) + tokenLoanParams[tokenId].duration <= block.timestamp,
                ""NFTPair: not expired""
            );
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, ""NFTPair: not available"");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS,
            ""NFTPair: bad params""
        );

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                ""NFTPair: skim too much""
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256(""Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint256 nonce,uint256 deadline)"")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x06bcca6f35b7c1b98f11abbb10957d273a681069ba90358de25404f49e2430f8;

    // keccak256(""Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint256 nonce,uint256 deadline)"")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xf2c9128b0fb8406af3168320897e5ff08f3bb536dd5f804c29ed276e93ec4336;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        if (v == 0 && r == bytes32(0) && s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), ""NFTPair: LendingClub does not like you"");
        } else {
            require(block.timestamp <= deadline, ""NFTPair: signature expired"");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    nonce,
                    deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), v, r, s) == lender, ""NFTPair: signature invalid"");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        require(block.timestamp <= deadline, ""NFTPair: signature expired"");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                nonce,
                deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), v, r, s) == borrower, ""NFTPair: signature invalid"");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the ""theoretical"" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, ""NFTPair: no loan"");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            ""NFTPair: loan expired""
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), ""NFTPair: skim too much"");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), ""NFTPair: can't call"");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, ""NFTPair: call failed"");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, uint256, uint8, bytes32, bytes32));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, deadline, v, r, s);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (
                    uint256 tokenId,
                    address borrower,
                    TokenLoanParams memory params,
                    bool skimFunds,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) = abi.decode(datas[i], (uint256, address, TokenLoanParams, bool, uint256, uint8, bytes32, bytes32));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, deadline, v, r, s);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}",8144
RealWorld_BA_113_RevertingERC20Mock_RealWord_20240829230609.log,113,RevertingERC20Mock,10598,4948,15546,104.0,0.15195,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

// RevertingERC20 reverts on errors
contract RevertingERC20Mock {
    string public symbol;
    string public name;
    uint8 public immutable decimals;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    constructor(
        string memory name_,
        string memory symbol_,
        uint8 decimals_,
        uint256 supply
    ) public {
        name = name_;
        symbol = symbol_;
        decimals = decimals_;
        totalSupply = supply;
        balanceOf[msg.sender] = supply;
    }

    function transfer(address to, uint256 amount) public returns (bool success) {
        require(balanceOf[msg.sender] >= amount, ""TokenB: balance too low"");
        require(amount >= 0, ""TokenB: amount should be > 0"");
        require(balanceOf[to] + amount >= balanceOf[to], ""TokenB: overflow detected"");
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        emit Transfer(msg.sender, to, amount);
        return true;
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public returns (bool success) {
        require(balanceOf[from] >= amount, ""TokenB: balance too low"");
        require(allowance[from][msg.sender] >= amount, ""TokenB: allowance too low"");
        require(amount >= 0, ""TokenB: amount should be >= 0"");
        require(balanceOf[to] + amount >= balanceOf[to], ""TokenB: overflow detected"");
        balanceOf[from] -= amount;
        allowance[from][msg.sender] -= amount;
        balanceOf[to] += amount;
        emit Transfer(from, to, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public returns (bool success) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
}",470
RealWorld_BA_113_FreelyMintableERC20Mock_RealWord_20240829225256.log,113,FreelyMintableERC20Mock,6161,4628,10789,101.0,0.123365,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"";
import ""./ERC20Mock.sol"";

contract FreelyMintableERC20Mock is ERC20Mock {
    using BoringMath for uint256;

    constructor(uint256 initialSupply) public ERC20Mock(initialSupply) {}

    function mint(address to, uint256 amount) public {
        totalSupply = totalSupply.add(amount);
        balanceOf[to] += amount;
        emit Transfer(address(0), to, amount);
    }

    function burn(uint256 amount) public {
        require(amount <= balanceOf[msg.sender], ""MIM: not enough"");
        totalSupply -= amount;
        emit Transfer(msg.sender, address(0), amount);
    }
}",167
RealWorld_BA_113_SushiSwapPairMock_RealWord_20240829225605.log,113,SushiSwapPairMock,4152,3962,8114,78.0,0.1,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
import ""@sushiswap/core/contracts/uniswapv2/UniswapV2Pair.sol"";

contract SushiSwapPairMock is UniswapV2Pair {
    constructor() public UniswapV2Pair() {
        return;
    }
}",71
RealWorld_BA_113_NFTPairWithOracle_RealWord_20240829224935.log,113,NFTPairWithOracle,0,0,0,,0.0,"// SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"";
import ""@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"";
import ""@boringcrypto/boring-solidity/contracts/Domain.sol"";
import ""@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"";
import ""@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"";
import ""./interfaces/IERC721.sol"";
import ""./interfaces/INFTOracle.sol"";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // ""Shares"" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns ""second-order"" interest-on-interest, which
    // itself earns ""third-order"" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why ""at least""? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator ""wins""; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the ""true"" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in ""total""
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), ""NFTPair: already initialized"");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), ""NFTPair: bad pair"");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, ""NFTPair: not the lender"");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                ""NFTPair: worse params""
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert(""NFTPair: no collateral"");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, ""NFTPair: loan exists"");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), ""NFTPair: skim failed"");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, ""NFTPair: not the lender"");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, ""NFT is still valued"");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, ""NFTPair: not available"");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            ""NFTPair: bad params""
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, ""Oracle: price too low."");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                ""NFTPair: skim too much""
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256(""Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)"")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256(""Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)"")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), ""NFTPair: LendingClub does not like you"");
        } else {
            require(block.timestamp <= signature.deadline, ""NFTPair: signature expired"");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, ""NFTPair: signature invalid"");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, ""NFTPair: signature expired"");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, ""NFTPair: signature invalid"");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the ""theoretical"" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, ""NFTPair: no loan"");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            ""NFTPair: loan expired""
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), ""NFTPair: skim too much"");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), ""NFTPair: can't call"");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, ""NFTPair: call failed"");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}",8413
RealWorld_BA_113_IERC165_RealWord_20240829231434.log,113,IERC165,6424,4010,10434,84.0,0.11232,"// SPDX-License-Identifier: MIT
// Taken from OpenZeppelin contracts v3

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}",209
RealWorld_BA_113_IERC721_RealWord_20240829231114.log,113,IERC721,21611,5154,26765,94.0,0.211135,"// SPDX-License-Identifier: MIT
// Taken from OpenZeppelin contracts v3

pragma solidity >=0.6.2 <0.8.0;

import ""./IERC165.sol"";

/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721 is IERC165 {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId) external view returns (address operator);

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool _approved) external;

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);

    /**
      * @dev Safely transfers `tokenId` token from `from` to `to`.
      *
      * Requirements:
      *
      * - `from` cannot be the zero address.
      * - `to` cannot be the zero address.
      * - `tokenId` token must exist and be owned by `from`.
      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
      *
      * Emits a {Transfer} event.
      */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
}",1102
RealWorld_BA_113_ExternalFunctionMock_RealWord_20240829230206.log,113,ExternalFunctionMock,4533,3820,8353,65.0,0.099065,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"";

contract ExternalFunctionMock {
    using BoringMath for uint256;

    event Result(uint256 output);

    function sum(uint256 a, uint256 b) external returns (uint256 c) {
        c = a.add(b);
        emit Result(c);
    }
}",89
RealWorld_BA_113_WETH9Mock_RealWord_20240829225439.log,113,WETH9Mock,10605,5025,15630,84.0,0.153525,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.6.12;

contract WETH9Mock {
    string public name = ""Wrapped Ether"";
    string public symbol = ""WETH"";
    uint8 public decimals = 18;

    event Approval(address indexed src, address indexed guy, uint256 wad);
    event Transfer(address indexed src, address indexed dst, uint256 wad);
    event Deposit(address indexed dst, uint256 wad);
    event Withdrawal(address indexed src, uint256 wad);

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    /*fallback () external payable {
        deposit();
    }*/
    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 wad) public {
        require(balanceOf[msg.sender] >= wad, ""WETH9: Error"");
        balanceOf[msg.sender] -= wad;
        msg.sender.transfer(wad);
        emit Withdrawal(msg.sender, wad);
    }

    function totalSupply() public view returns (uint256) {
        return address(this).balance;
    }

    function approve(address guy, uint256 wad) public returns (bool) {
        allowance[msg.sender][guy] = wad;
        emit Approval(msg.sender, guy, wad);
        return true;
    }

    function transfer(address dst, uint256 wad) public returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }

    function transferFrom(
        address src,
        address dst,
        uint256 wad
    ) public returns (bool) {
        require(balanceOf[src] >= wad, ""WETH9: Error"");

        if (src != msg.sender && allowance[src][msg.sender] != uint256(-1)) {
            require(allowance[src][msg.sender] >= wad, ""WETH9: Error"");
            allowance[src][msg.sender] -= wad;
        }

        balanceOf[src] -= wad;
        balanceOf[dst] += wad;

        emit Transfer(src, dst, wad);

        return true;
    }
}",466
RealWorld_BA_114_AaveV3YieldSource_RealWord_20240830081801.log,114,AaveV3YieldSource,62192,5641,67833,82.0,0.42378,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.10;

import { IAToken } from ""@aave/core-v3/contracts/interfaces/IAToken.sol"";
import { IPool } from ""@aave/core-v3/contracts/interfaces/IPool.sol"";
import { IPoolAddressesProvider } from ""@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol"";
import { IPoolAddressesProviderRegistry } from ""@aave/core-v3/contracts/interfaces/IPoolAddressesProviderRegistry.sol"";
import { IRewardsController } from ""@aave/periphery-v3/contracts/rewards/interfaces/IRewardsController.sol"";

import { ERC20 } from ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { SafeMath } from ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

import { Manageable, Ownable } from ""@pooltogether/owner-manager-contracts/contracts/Manageable.sol"";
import { IYieldSource } from ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";

/**
 * @title Aave V3 Yield Source contract, implementing PoolTogether's generic yield source interface.
 * @dev This contract inherits from the ERC20 implementation to keep track of users deposits.
 * @notice Yield Source for a PoolTogether prize pool that generates yield by depositing into Aave V3.
 */
contract AaveV3YieldSource is ERC20, IYieldSource, Manageable, ReentrancyGuard {
  using SafeMath for uint256;
  using SafeERC20 for IERC20;

  /* ============ Events ============ */

  /**
   * @notice Emitted when the yield source is initialized.
   * @param aToken Aave aToken address
   * @param rewardsController Aave rewardsController address
   * @param poolAddressesProviderRegistry Aave poolAddressesProviderRegistry address
   * @param name Token name for the underlying ERC20 shares
   * @param symbol Token symbol for the underlying ERC20 shares
   * @param decimals Number of decimals the shares (inhereted ERC20) will have. Same as underlying asset to ensure sane exchange rates for shares.
   * @param owner Owner of this contract
   */
  event AaveV3YieldSourceInitialized(
    IAToken indexed aToken,
    IRewardsController rewardsController,
    IPoolAddressesProviderRegistry poolAddressesProviderRegistry,
    string name,
    string symbol,
    uint8 decimals,
    address owner
  );

  /**
   * @notice Emitted when asset tokens are supplied to the yield source.
   * @param from Address that supplied the tokens
   * @param shares Amount of shares minted to the user
   * @param amount Amount of tokens supplied
   * @param to Address that received the shares
   */
  event SuppliedTokenTo(address indexed from, uint256 shares, uint256 amount, address indexed to);

  /**
   * @notice Emitted when asset tokens are redeemed from the yield source.
   * @param from Address who redeemed the tokens
   * @param shares Amount of shares burnt
   * @param amount Amount of tokens redeemed
   */
  event RedeemedToken(address indexed from, uint256 shares, uint256 amount);

  /**
   * @notice Emitted when Aave rewards have been claimed.
   * @param from Address who claimed the rewards
   * @param to Address that received the rewards
   * @param rewardsList List of addresses of the reward tokens
   * @param claimedAmounts List that contains the claimed amount per reward token
   */
  event Claimed(
    address indexed from,
    address indexed to,
    address[] rewardsList,
    uint256[] claimedAmounts
  );

  /**
   * @notice Emitted when decreasing allowance of ERC20 tokens other than yield source's aToken.
   * @param from Address of the caller
   * @param spender Address of the spender
   * @param amount Amount of `token` to decrease allowance by
   * @param token Address of the ERC20 token to decrease allowance for
   */
  event DecreasedERC20Allowance(
    address indexed from,
    address indexed spender,
    uint256 amount,
    IERC20 indexed token
  );

  /**
   * @notice Emitted when increasing allowance of ERC20 tokens other than yield source's aToken.
   * @param from Address of the caller
   * @param spender Address of the spender
   * @param amount Amount of `token` to increase allowance by
   * @param token Address of the ERC20 token to increase allowance for
   */
  event IncreasedERC20Allowance(
    address indexed from,
    address indexed spender,
    uint256 amount,
    IERC20 indexed token
  );

  /**
   * @notice Emitted when ERC20 tokens other than yield source's aToken are withdrawn from the yield source.
   * @param from Address of the caller
   * @param to Address of the recipient
   * @param amount Amount of `token` transferred
   * @param token Address of the ERC20 token transferred
   */
  event TransferredERC20(
    address indexed from,
    address indexed to,
    uint256 amount,
    IERC20 indexed token
  );

  /* ============ Variables ============ */

  /// @notice Yield-bearing Aave aToken address.
  IAToken public aToken;

  /// @notice Aave RewardsController address.
  IRewardsController public rewardsController;

  /// @notice Aave poolAddressesProviderRegistry address.
  IPoolAddressesProviderRegistry public poolAddressesProviderRegistry;

  /// @notice ERC20 token decimals.
  uint8 private immutable _decimals;

  /**
   * @dev Aave genesis market PoolAddressesProvider's ID.
   * @dev This variable could evolve in the future if we decide to support other markets.
   */
  uint256 private constant ADDRESSES_PROVIDER_ID = uint256(0);

  /// @dev PoolTogether's Aave Referral Code
  uint16 private constant REFERRAL_CODE = uint16(188);

  /* ============ Constructor ============ */

  /**
   * @notice Initializes the yield source with Aave aToken.
   * @param _aToken Aave aToken address
   * @param _rewardsController Aave rewardsController address
   * @param _poolAddressesProviderRegistry Aave poolAddressesProviderRegistry address
   * @param _name Token name for the underlying ERC20 shares
   * @param _symbol Token symbol for the underlying ERC20 shares
   * @param decimals_ Number of decimals the shares (inhereted ERC20) will have. Same as underlying asset to ensure sane exchange rates for shares.
   * @param _owner Owner of this contract
   */
  constructor(
    IAToken _aToken,
    IRewardsController _rewardsController,
    IPoolAddressesProviderRegistry _poolAddressesProviderRegistry,
    string memory _name,
    string memory _symbol,
    uint8 decimals_,
    address _owner
  ) Ownable(_owner) ERC20(_name, _symbol) ReentrancyGuard() {
    require(address(_aToken) != address(0), ""AaveV3YS/aToken-not-zero-address"");
    aToken = _aToken;

    require(address(_rewardsController) != address(0), ""AaveV3YS/RC-not-zero-address"");
    rewardsController = _rewardsController;

    require(address(_poolAddressesProviderRegistry) != address(0), ""AaveV3YS/PR-not-zero-address"");
    poolAddressesProviderRegistry = _poolAddressesProviderRegistry;

    require(_owner != address(0), ""AaveV3YS/owner-not-zero-address"");

    require(decimals_ > 0, ""AaveV3YS/decimals-gt-zero"");
    _decimals = decimals_;

    // Approve once for max amount
    IERC20(_tokenAddress()).safeApprove(address(_pool()), type(uint256).max);

    emit AaveV3YieldSourceInitialized(
      _aToken,
      _rewardsController,
      _poolAddressesProviderRegistry,
      _name,
      _symbol,
      decimals_,
      _owner
    );
  }

  /* ============ External Functions ============ */

  /**
   * @notice Returns user total balance (in asset tokens). This includes their deposit and interest.
   * @param _user Address of the user to get balance of token for
   * @return The underlying balance of asset tokens.
   */
  function balanceOfToken(address _user) external override returns (uint256) {
    return _sharesToToken(balanceOf(_user));
  }

  /**
   * @notice Returns the ERC20 asset token used for deposits.
   * @return The ERC20 asset token address.
   */
  function depositToken() public view override returns (address) {
    return _tokenAddress();
  }

  /**
   * @notice Returns the Yield Source ERC20 token decimals.
   * @dev This value should be equal to the decimals of the token used to deposit into the pool.
   * @return The number of decimals.
   */
  function decimals() public view virtual override returns (uint8) {
    return _decimals;
  }

  /**
   * @notice Supplies asset tokens to the yield source.
   * @dev Shares corresponding to the number of tokens supplied are minted to the user's balance.
   * @dev Asset tokens are supplied to the yield source, then deposited into Aave.
   * @param _depositAmount The amount of asset tokens to be supplied
   * @param _to The user whose balance will receive the tokens
   */
  function supplyTokenTo(uint256 _depositAmount, address _to) external override nonReentrant {
    uint256 _shares = _tokenToShares(_depositAmount);
    require(_shares > 0, ""AaveV3YS/shares-gt-zero"");

    address _underlyingAssetAddress = _tokenAddress();
    IERC20(_underlyingAssetAddress).safeTransferFrom(msg.sender, address(this), _depositAmount);
    _pool().supply(_underlyingAssetAddress, _depositAmount, address(this), REFERRAL_CODE);

    _mint(_to, _shares);

    emit SuppliedTokenTo(msg.sender, _shares, _depositAmount, _to);
  }

  /**
   * @notice Redeems asset tokens from the yield source.
   * @dev Shares corresponding to the number of tokens withdrawn are burnt from the user's balance.
   * @dev Asset tokens are withdrawn from Aave, then transferred from the yield source to the user's wallet.
   * @param _redeemAmount The amount of asset tokens to be redeemed
   * @return The actual amount of asset tokens that were redeemed.
   */
  function redeemToken(uint256 _redeemAmount) external override nonReentrant returns (uint256) {
    address _underlyingAssetAddress = _tokenAddress();
    IERC20 _assetToken = IERC20(_underlyingAssetAddress);

    uint256 _shares = _tokenToShares(_redeemAmount);
    _burn(msg.sender, _shares);

    uint256 _beforeBalance = _assetToken.balanceOf(address(this));
    _pool().withdraw(_underlyingAssetAddress, _redeemAmount, address(this));
    uint256 _afterBalance = _assetToken.balanceOf(address(this));

    uint256 _balanceDiff = _afterBalance.sub(_beforeBalance);
    _assetToken.safeTransfer(msg.sender, _balanceDiff);

    emit RedeemedToken(msg.sender, _shares, _redeemAmount);
    return _balanceDiff;
  }

  /**
   * @notice Claims the accrued rewards for the aToken, accumulating any pending rewards.
   * @dev Only callable by the owner or manager.
   * @param _to Address where the claimed rewards will be sent
   * @return True if operation was successful.
   */
  function claimRewards(address _to) external onlyManagerOrOwner returns (bool) {
    require(_to != address(0), ""AaveV3YS/payee-not-zero-address"");

    address[] memory _assets = new address[](1);
    _assets[0] = address(aToken);

    (address[] memory _rewardsList, uint256[] memory _claimedAmounts) = rewardsController
      .claimAllRewards(_assets, _to);

    emit Claimed(msg.sender, _to, _rewardsList, _claimedAmounts);
    return true;
  }

  /**
   * @notice Decrease allowance of ERC20 tokens other than the aTokens held by this contract.
   * @dev This function is only callable by the owner or asset manager.
   * @dev Current allowance should be computed off-chain to avoid any underflow.
   * @param _token Address of the ERC20 token to decrease allowance for
   * @param _spender Address of the spender of the tokens
   * @param _amount Amount of tokens to decrease allowance by
   */
  function decreaseERC20Allowance(
    IERC20 _token,
    address _spender,
    uint256 _amount
  ) external onlyManagerOrOwner {
    _requireNotAToken(address(_token));
    _token.safeDecreaseAllowance(_spender, _amount);
    emit DecreasedERC20Allowance(msg.sender, _spender, _amount, _token);
  }

  /**
   * @notice Increase allowance of ERC20 tokens other than the aTokens held by this contract.
   * @dev This function is only callable by the owner or asset manager.
   * @dev Allows another contract or address to withdraw funds from the yield source.
   * @dev Current allowance should be computed off-chain to avoid any overflow.
   * @param _token Address of the ERC20 token to increase allowance for
   * @param _spender Address of the spender of the tokens
   * @param _amount Amount of tokens to increase allowance by
   */
  function increaseERC20Allowance(
    IERC20 _token,
    address _spender,
    uint256 _amount
  ) external onlyManagerOrOwner {
    _requireNotAToken(address(_token));
    _token.safeIncreaseAllowance(_spender, _amount);
    emit IncreasedERC20Allowance(msg.sender, _spender, _amount, _token);
  }

  /**
   * @notice Transfer ERC20 tokens other than the aTokens held by this contract to the recipient address.
   * @dev This function is only callable by the owner or asset manager.
   * @param _token Address of the ERC20 token to transfer
   * @param _to Address of the recipient of the tokens
   * @param _amount Amount of tokens to transfer
   */
  function transferERC20(
    IERC20 _token,
    address _to,
    uint256 _amount
  ) external onlyManagerOrOwner {
    require(address(_token) != address(aToken), ""AaveV3YS/forbid-aToken-transfer"");
    _token.safeTransfer(_to, _amount);
    emit TransferredERC20(msg.sender, _to, _amount, _token);
  }

  /* ============ Internal Functions ============ */

  /**
   * @notice Check that the token address passed is not the aToken address.
   * @param _token Address of the ERC20 token to check
   */
  function _requireNotAToken(address _token) internal view {
    require(_token != address(aToken), ""AaveV3YS/forbid-aToken-allowance"");
  }

  /**
   * @notice Calculates the number of shares that should be minted or burnt when a user deposit or withdraw.
   * @param _tokens Amount of asset tokens
   * @return Number of shares.
   */
  function _tokenToShares(uint256 _tokens) internal view returns (uint256) {
    uint256 _supply = totalSupply();

    // shares = (tokens * totalShares) / yieldSourceATokenTotalSupply
    return _supply == 0 ? _tokens : _tokens.mul(_supply).div(aToken.balanceOf(address(this)));
  }

  /**
   * @notice Calculates the number of asset tokens a user has in the yield source.
   * @param _shares Amount of shares
   * @return Number of asset tokens.
   */
  function _sharesToToken(uint256 _shares) internal view returns (uint256) {
    uint256 _supply = totalSupply();

    // tokens = (shares * yieldSourceATokenTotalSupply) / totalShares
    return _supply == 0 ? _shares : _shares.mul(aToken.balanceOf(address(this))).div(_supply);
  }

  /**
   * @notice Returns the underlying asset token address.
   * @return Underlying asset token address.
   */
  function _tokenAddress() internal view returns (address) {
    return aToken.UNDERLYING_ASSET_ADDRESS();
  }

  /**
   * @notice Retrieves Aave PoolAddressesProvider address.
   * @return A reference to PoolAddressesProvider interface.
   */
  function _poolProvider() internal view returns (IPoolAddressesProvider) {
    return
      IPoolAddressesProvider(
        poolAddressesProviderRegistry.getAddressesProvidersList()[ADDRESSES_PROVIDER_ID]
      );
  }

  /**
   * @notice Retrieves Aave Pool address.
   * @return A reference to Pool interface.
   */
  function _pool() internal view returns (IPool) {
    return IPool(_poolProvider().getPool());
  }
}",3727
RealWorld_BA_114_SafeERC20Wrapper_RealWord_20240830081925.log,114,SafeERC20Wrapper,13040,5176,18216,69.0,0.16872,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.10;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

// Mock implementation from OpenZeppelin modified for our usage in tests
// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/mocks/SafeERC20Helper.sol
contract ERC20ReturnTrueMock is ERC20 {
  mapping(address => uint256) private _allowances;

  // IERC20's functions are not pure, but these mock implementations are: to prevent Solidity from issuing warnings,
  // we write to a dummy state variable.
  uint256 private _dummy;

  constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}

  function transfer(address, uint256) public override returns (bool) {
    _dummy = 0;
    return true;
  }

  function transferFrom(
    address,
    address,
    uint256
  ) public override returns (bool) {
    _dummy = 0;
    return true;
  }

  function approve(address, uint256) public override returns (bool) {
    _dummy = 0;
    return true;
  }

  function setAllowance(uint256 allowance_) public {
    _allowances[_msgSender()] = allowance_;
  }

  function allowance(address owner, address) public view override returns (uint256) {
    return _allowances[owner];
  }

  uint256[48] private __gap;
}

contract SafeERC20Wrapper {
  using SafeERC20 for IERC20;

  IERC20 private _token;

  constructor(IERC20 token) {
    _token = token;
  }

  function balanceOf(address account) public view returns (uint256) {
    return _token.balanceOf(account);
  }

  function transfer(address recipient, uint256 amount) public {
    _token.safeTransfer(recipient, amount);
  }

  function transferFrom(
    address sender,
    address recipient,
    uint256 amount
  ) public {
    _token.safeTransferFrom(sender, recipient, amount);
  }

  function approve(address spender, uint256 amount) public {
    _token.safeApprove(spender, amount);
  }

  function increaseAllowance(uint256 amount) public {
    _token.safeIncreaseAllowance(address(0), amount);
  }

  function decreaseAllowance(uint256 amount) public {
    _token.safeDecreaseAllowance(address(0), amount);
  }

  function setAllowance(uint256 allowance_) public {
    ERC20ReturnTrueMock(address(_token)).setAllowance(allowance_);
  }

  function allowance(address owner, address spender) public view returns (uint256) {
    return _token.allowance(owner, spender);
  }

  uint256[49] private __gap;
}",624
RealWorld_BA_114_AaveV3YieldSourceHarness_RealWord_20240830082143.log,114,AaveV3YieldSourceHarness,8180,5557,13737,78.0,0.15204,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.10;

import ""../AaveV3YieldSource.sol"";

contract AaveV3YieldSourceHarness is AaveV3YieldSource {
  constructor(
    IAToken _aToken,
    IRewardsController _rewardsController,
    IPoolAddressesProviderRegistry _poolAddressesProviderRegistry,
    string memory _name,
    string memory _symbol,
    uint8 _decimals,
    address _owner
  )
    AaveV3YieldSource(
      _aToken,
      _rewardsController,
      _poolAddressesProviderRegistry,
      _name,
      _symbol,
      _decimals,
      _owner
    )
  {}

  function mint(address account, uint256 amount) public returns (bool) {
    _mint(account, amount);
    return true;
  }

  function tokenToShares(uint256 tokens) external view returns (uint256) {
    return _tokenToShares(tokens);
  }

  function sharesToToken(uint256 shares) external view returns (uint256) {
    return _sharesToToken(shares);
  }

  function tokenAddress() external view returns (address) {
    return _tokenAddress();
  }

  function poolProvider() external view returns (IPoolAddressesProvider) {
    return _poolProvider();
  }

  function pool() external view returns (IPool) {
    return _pool();
  }
}",303
RealWorld_BA_114_ERC20Mintable_RealWord_20240830082036.log,114,ERC20Mintable,7976,5034,13010,65.0,0.14056,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.10;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol"";

/**
 * @dev Extension of {ERC20} that adds a set of accounts with the {MinterRole},
 * which have permission to mint (create) new tokens as they see fit.
 *
 * At construction, the deployer of the contract is the only minter.
 */
contract ERC20Mintable is ERC20Permit {
  uint8 internal _decimals;

  constructor(
    string memory _name,
    string memory _symbol,
    uint8 decimals_
  ) ERC20(_name, _symbol) ERC20Permit(_name) {
    _decimals = decimals_;
  }

  function decimals() public view override returns (uint8) {
    return _decimals;
  }

  /**
   * @dev See {ERC20-_mint}.
   *
   * Requirements:
   *
   * - the caller must have the {MinterRole}.
   */
  function mint(address account, uint256 amount) public returns (bool) {
    _mint(account, amount);
    return true;
  }

  function burn(address account, uint256 amount) public returns (bool) {
    _burn(account, amount);
    return true;
  }
}",297
RealWorld_BA_115_BConst_RealWord_20240830105134.log,115,BConst,10404,4565,14969,66.0,0.14332,"// https://github.com/balancer-labs/balancer-core/blob/master/contracts/BConst.sol

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity 0.6.12;

contract BConst {
  uint256 public constant BONE = 10**18;

  uint256 public constant MIN_BOUND_TOKENS = 2;
  uint256 public constant MAX_BOUND_TOKENS = 8;

  uint256 public constant MIN_FEE = BONE / 10**6;
  uint256 public constant MAX_FEE = BONE / 10;
  uint256 public constant EXIT_FEE = 0;

  uint256 public constant MIN_WEIGHT = BONE;
  uint256 public constant MAX_WEIGHT = BONE * 50;
  uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;
  uint256 public constant MIN_BALANCE = BONE / 10**12;

  uint256 public constant INIT_POOL_SUPPLY = BONE * 100;

  uint256 public constant MIN_BPOW_BASE = 1 wei;
  uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;
  uint256 public constant BPOW_PRECISION = BONE / 10**10;

  uint256 public constant MAX_IN_RATIO = BONE / 2;
  uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;
}",421
RealWorld_BA_115_DistributorManager_RealWord_20240830094804.log,115,DistributorManager,7597,5300,12897,89.0,0.143985,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""../governance/interfaces/IGovernanceAddressProvider.sol"";
import ""./interfaces/IBaseDistributor.sol"";

contract DistributorManager {
  using SafeMath for uint256;

  IGovernanceAddressProvider public a;
  IBaseDistributor public mimmoDistributor;

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), ""Caller is not Manager"");
    _;
  }

  constructor(IGovernanceAddressProvider _a, IBaseDistributor _mimmoDistributor) public {
    require(address(_a) != address(0));
    require(address(_mimmoDistributor) != address(0));

    a = _a;
    mimmoDistributor = _mimmoDistributor;
  }

  /**
    Public function to release the accumulated new MIMO tokens to the payees.
    @dev anyone can call this.
  */
  function releaseAll() public {
    mimmoDistributor.release();
    address[] memory distributors = mimmoDistributor.getPayees();
    for (uint256 i = 0; i < distributors.length; i++) {
      IBaseDistributor(distributors[i]).release();
    }
  }
}",290
RealWorld_BA_115_ChainlinkInceptionPriceFeed_RealWord_20240830104231.log,115,ChainlinkInceptionPriceFeed,18946,5915,24861,74.0,0.21303,"//SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/proxy/Initializable.sol"";

import ""../interfaces/IInceptionVaultPriceFeed.sol"";
import ""../../chainlink/AggregatorV3Interface.sol"";
import ""../../interfaces/IAddressProvider.sol"";
import ""../../libraries/MathPow.sol"";
import ""../../libraries/WadRayMath.sol"";

contract ChainlinkInceptionPriceFeed is IInceptionVaultPriceFeed, Initializable {
  using SafeMath for uint256;
  using SafeMath for uint8;
  using WadRayMath for uint256;

  uint256 private constant _PRICE_ORACLE_STALE_THRESHOLD = 1 days;

  IAddressProvider private _a;

  ERC20 private _inceptionCollateral;

  AggregatorV3Interface private _assetOracle;

  AggregatorV3Interface private _eurOracle;

  function initialize(
    IAddressProvider _addresses,
    address inceptionCollateral,
    address assetOracle,
    AggregatorV3Interface eurOracle
  ) external override initializer {
    _a = _addresses;
    _inceptionCollateral = ERC20(inceptionCollateral);
    _assetOracle = AggregatorV3Interface(assetOracle);
    _eurOracle = eurOracle;
  }

  /**
   * @notice Converts asset balance into stablecoin balance at current price
   * @param _amount amount of collateral
   */
  function convertFrom(uint256 _amount) external view override returns (uint256) {
    uint256 price = getAssetPrice();
    uint8 collateralDecimals = ERC20(_inceptionCollateral).decimals();
    uint8 parDecimals = ERC20(address(_a.stablex())).decimals(); // Needs re-casting because ISTABLEX does not expose decimals()
    uint8 oracleDecimals = _assetOracle.decimals();
    uint256 parAccuracy = MathPow.pow(10, parDecimals);
    uint256 collateralAccuracy = MathPow.pow(10, oracleDecimals.add(collateralDecimals));
    return _amount.mul(price).mul(parAccuracy).div(collateralAccuracy);
  }

  /**
   * @notice Converts stablecoin balance into collateral balance at current price
   * @param _amount amount of stablecoin
   */
  function convertTo(uint256 _amount) external view override returns (uint256) {
    uint256 price = getAssetPrice();
    uint8 collateralDecimals = ERC20(_inceptionCollateral).decimals();
    uint8 parDecimals = ERC20(address(_a.stablex())).decimals(); // Needs re-casting because ISTABLEX does not expose decimals()
    uint8 oracleDecimals = _assetOracle.decimals();
    uint256 parAccuracy = MathPow.pow(10, parDecimals);
    uint256 collateralAccuracy = MathPow.pow(10, oracleDecimals.add(collateralDecimals));
    return _amount.mul(collateralAccuracy).div(price).div(parAccuracy);
  }

  /**
   * Gets the asset price in EUR (PAR)
   * @dev returned value has matching decimals to the asset oracle (not the EUR oracle)
   */
  function getAssetPrice() public view override returns (uint256 price) {
    (, int256 eurAnswer, , uint256 eurUpdatedAt, ) = _eurOracle.latestRoundData();
    require(eurAnswer > 0, ""EUR price data not valid"");
    require(block.timestamp - eurUpdatedAt < _PRICE_ORACLE_STALE_THRESHOLD, ""EUR price data is stale"");

    (, int256 answer, , uint256 assetUpdatedAt, ) = _assetOracle.latestRoundData();
    require(answer > 0, ""Price data not valid"");
    require(block.timestamp - assetUpdatedAt < _PRICE_ORACLE_STALE_THRESHOLD, ""Price data is stale"");

    uint8 eurDecimals = _eurOracle.decimals();
    uint256 eurAccuracy = MathPow.pow(10, eurDecimals);
    return uint256(answer).mul(eurAccuracy).div(uint256(eurAnswer));
  }

  function a() public view override returns (IAddressProvider) {
    return _a;
  }

  function inceptionCollateral() public view override returns (ERC20) {
    return _inceptionCollateral;
  }

  function assetOracle() public view override returns (AggregatorV3Interface) {
    return _assetOracle;
  }

  function eurOracle() public view override returns (AggregatorV3Interface) {
    return _eurOracle;
  }
}",964
RealWorld_BA_115_InceptionVaultsCore_RealWord_20240830103532.log,115,InceptionVaultsCore,58359,5578,63937,89.0,0.403355,"//SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/proxy/Initializable.sol"";

import ""./BoringOwnable.sol"";
import ""./interfaces/IInceptionVaultsCore.sol"";
import ""./interfaces/IAdminInceptionVault.sol"";
import ""./interfaces/IInceptionVaultsDataProvider.sol"";
import ""./interfaces/IInceptionVaultPriceFeed.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../libraries/WadRayMath.sol"";

contract InceptionVaultsCore is IInceptionVaultsCore, BoringOwnable, ReentrancyGuard, Initializable {
  using SafeMath for uint256;
  using SafeERC20 for IERC20;
  using WadRayMath for uint256;

  uint256 internal constant _MAX_INT = 2**256 - 1;

  uint256 private _cumulativeRate;
  uint256 private _lastRefresh;
  VaultConfig private _vaultConfig;

  IAddressProvider private _a;
  IERC20 private _inceptionCollateral;
  IAdminInceptionVault private _adminInceptionVault;
  IInceptionVaultsDataProvider private _inceptionVaultsData;
  IInceptionVaultPriceFeed private _inceptionPriceFeed;

  modifier onlyVaultOwner(uint256 _vaultId) {
    require(_inceptionVaultsData.vaultOwner(_vaultId) == msg.sender, ""IV010"");
    _;
  }

  function initialize(
    address _owner,
    VaultConfig memory vaultConfig,
    IERC20 inceptionCollateral,
    IAddressProvider addressProvider,
    IAdminInceptionVault adminInceptionVault,
    IInceptionVaultsDataProvider inceptionVaultsDataProvider,
    IInceptionVaultPriceFeed inceptionPriceFeed
  ) external override initializer {
    _vaultConfig = vaultConfig;
    _inceptionCollateral = inceptionCollateral;
    _lastRefresh = block.timestamp;
    _cumulativeRate = WadRayMath.ray();
    _a = addressProvider;
    _adminInceptionVault = adminInceptionVault;
    _inceptionVaultsData = inceptionVaultsDataProvider;
    owner = _owner;
    _inceptionPriceFeed = inceptionPriceFeed;
  }

  /**
    Deposit inceptionCollateral ERC20 token into the specified vault as collateral
    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.
    @param _vaultId the ID of the vault in which to deposit the inceptioCollateral.
    @param _amount the amount of tokens to be deposited in WEI.
  **/
  function depositByVaultId(uint256 _vaultId, uint256 _amount) external override {
    _inceptionCollateral.safeTransferFrom(msg.sender, address(this), _amount);

    _addCollateralToVaultById(_vaultId, _amount);
  }

  /**
    Deposit inceptionCollateral ERC20 token into the vault of the msg.sender as collateral and borrows the specified amount of tokens in WEI
    @dev see deposit() and borrow()
    @param _depositAmount the amount of inceptionCollateral to be deposited in WEI.
    @param _borrowAmount the amount of borrowed StableX tokens in WEI.
  **/
  function depositAndBorrow(uint256 _depositAmount, uint256 _borrowAmount) external override {
    deposit(_depositAmount);
    uint256 vaultId = _inceptionVaultsData.vaultId(msg.sender);
    borrow(vaultId, _borrowAmount);
  }

  /**
    Withdraws inceptionCollateral ERC20 token from a vault.
    @dev Only the owner of a vault can withdraw collateral from it.
    `withdraw()` will fail if it would bring the vault below the minimum collateralization treshold.
    @param _vaultId the ID of the vault from which to withdraw the inceptionCollateral.
    @param _amount the amount of inceptionCollateral ERC20 tokens to be withdrawn in WEI.
  **/
  function withdraw(uint256 _vaultId, uint256 _amount) external override onlyVaultOwner(_vaultId) nonReentrant {
    _removeCollateralFromVault(_vaultId, _amount);
    _inceptionCollateral.safeTransfer(msg.sender, _amount);
  }

  /**
    Convenience function to repay all debt of a vault
    @dev `repayAll()` will update the outstanding vault debt to the current time.
    @param _vaultId the ID of the vault for which to repay the debt.
  **/
  function repayAll(uint256 _vaultId) external override {
    repay(_vaultId, _MAX_INT);
  }

  /**
    Liquidate a vault that is below the liquidation treshold by repaying its outstanding debt.
    @dev `liquidate()` will update the outstanding vault debt to the current time and pay a `liquidationBonus`
    to the liquidator. `liquidate()` can be called by anyone.
    @param _vaultId the ID of the vault to be liquidated.
  **/
  function liquidate(uint256 _vaultId) external override {
    liquidatePartial(_vaultId, _MAX_INT);
  }

  /**
    Deposit inceptionCollateral ERC20 token into the vault of the msg.sender as collateral
    @dev A new vault is created if no vault exists for the `msg.sender` with the specified collateral type.
    this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.
    @param _amount the amount of tokens to be deposited in WEI.
  **/
  function deposit(uint256 _amount) public override {
    require(_amount > 0, ""IV100"");
    _inceptionCollateral.safeTransferFrom(msg.sender, address(this), _amount);

    _addCollateralToVault(_amount);
  }

  /**
    Borrow new PAR tokens from a vault.
    @dev Only the owner of a vault can borrow from it.
    `borrow()` will update the outstanding vault debt to the current time before attempting the withdrawal.
     `borrow()` will fail if it would bring the vault below the minimum collateralization treshold.
    @param _vaultId the ID of the vault from which to borrow.
    @param _amount the amount of borrowed inceptionCollateral tokens in WEI.
  **/
  function borrow(uint256 _vaultId, uint256 _amount) public override onlyVaultOwner(_vaultId) nonReentrant {
    IERC20 stablex = IERC20(_a.stablex());
    require(_amount <= stablex.balanceOf(address(_adminInceptionVault)), ""IV104"");
    IInceptionVaultsDataProvider.InceptionVault memory v = _inceptionVaultsData.vaults(_vaultId);

    // Make sure current rate is up to date
    _refreshCumulativeRate();

    uint256 newDebt = _amount;
    if (_vaultConfig.originationFee > 0) {
      newDebt = newDebt.add(_amount.wadMul(_vaultConfig.originationFee));
    }

    // Increment vault borrow balance

    uint256 newBaseDebt = _a.ratesManager().calculateBaseDebt(newDebt, _cumulativeRate);

    _inceptionVaultsData.setBaseDebt(_vaultId, v.baseDebt.add(newBaseDebt));

    uint256 collateralValue = _inceptionPriceFeed.convertFrom(v.collateralBalance);
    uint256 newVaultDebt = _inceptionVaultsData.vaultDebt(_vaultId);

    bool isHealthy = _a.liquidationManager().isHealthy(collateralValue, newVaultDebt, _vaultConfig.minCollateralRatio);

    require(isHealthy, ""IV102"");

    _adminInceptionVault.lendPAR(_amount, msg.sender);

    emit Borrowed(_vaultId, _amount, msg.sender);
  }

  /**
    Repay an outstanding PAR balance to a vault.
    @dev `repay()` will update the outstanding vault debt to the current time.
    @param _vaultId the ID of the vault for which to repay the outstanding debt balance.
    @param _amount the amount of PAR tokens in WEI to be repaid.
  **/
  function repay(uint256 _vaultId, uint256 _amount) public override nonReentrant {
    // Make sure current rate is up to date
    _refreshCumulativeRate();

    uint256 currentVaultDebt = _inceptionVaultsData.vaultDebt(_vaultId);
    // Decrement vault borrow balance
    if (_amount >= currentVaultDebt) {
      // Full repayment
      _amount = currentVaultDebt; //only pay back what's outstanding
    }
    _reduceVaultDebt(_vaultId, _amount);
    // This will require a user allowance first
    IERC20 stablex = IERC20(_a.stablex());
    stablex.safeTransferFrom(msg.sender, address(_adminInceptionVault), _amount);
    emit Repaid(_vaultId, _amount, msg.sender);
  }

  /**
    Liquidate a vault partially that is below the liquidation treshold by repaying part of its outstanding debt.
    @dev `liquidatePartial()` will update the outstanding vault debt to the current time and pay a `liquidationBonus`
    to the liquidator. A LiquidationFee will be applied to the borrower during the liquidation.
    This means that the change in outstanding debt can be smaller than the repaid amount.
    `liquidatePartial()` can be called by anyone.
    @param _vaultId the ID of the vault to be liquidated.
    @param _amount the amount of debt+liquidationFee to repay.
  **/
  function liquidatePartial(uint256 _vaultId, uint256 _amount) public override nonReentrant {
    IInceptionVaultsDataProvider.InceptionVault memory v = _inceptionVaultsData.vaults(_vaultId);
    _refreshCumulativeRate();
    uint256 collateralValue = _inceptionPriceFeed.convertFrom(v.collateralBalance);
    uint256 currentVaultDebt = _inceptionVaultsData.vaultDebt(_vaultId);
    require(
      !_a.liquidationManager().isHealthy(collateralValue, currentVaultDebt, _vaultConfig.liquidationRatio),
      ""IV103""
    );
    uint256 repaymentAfterLiquidationFeeRatio = WadRayMath.wad().sub(_vaultConfig.liquidationFee);
    uint256 maxLiquidationCost = currentVaultDebt.wadDiv(repaymentAfterLiquidationFeeRatio);
    uint256 repayAmount;
    if (_amount > maxLiquidationCost) {
      _amount = maxLiquidationCost;
      repayAmount = currentVaultDebt;
    } else {
      repayAmount = _amount.wadMul(repaymentAfterLiquidationFeeRatio);
    }
    uint256 collateralValueToReceive = _amount.add(_amount.wadMul(_vaultConfig.liquidationBonus));
    uint256 insuranceAmount = 0;
    if (collateralValueToReceive >= collateralValue) {
      // Not enough collateral for debt & liquidation bonus
      collateralValueToReceive = collateralValue;
      uint256 discountedCollateralValue = collateralValue.wadDiv(_vaultConfig.liquidationBonus.add(WadRayMath.wad()));
      if (currentVaultDebt > discountedCollateralValue) {
        // Not enough collateral for debt alone
        insuranceAmount = currentVaultDebt.sub(discountedCollateralValue);
        require(_a.stablex().balanceOf(address(_adminInceptionVault)) >= insuranceAmount, ""IV104"");
      }
      repayAmount = currentVaultDebt.sub(insuranceAmount);
      _amount = discountedCollateralValue;
    }
    // Reduce the vault debt by repayAmount
    _reduceVaultDebt(_vaultId, repayAmount.add(insuranceAmount));
    IERC20 stablex = IERC20(_a.stablex());
    stablex.safeTransferFrom(msg.sender, address(this), _amount);
    stablex.safeTransfer(address(_adminInceptionVault), _amount);
    // Send the claimed collateral to the liquidator
    uint256 collateralToReceive = _inceptionPriceFeed.convertTo(collateralValueToReceive);
    _inceptionVaultsData.setCollateralBalance(_vaultId, v.collateralBalance.sub(collateralToReceive));
    _inceptionCollateral.safeTransfer(msg.sender, collateralToReceive);
    emit Liquidated(_vaultId, repayAmount, collateralToReceive, v.owner, msg.sender);
  }

  function cumulativeRate() public view override returns (uint256) {
    return _cumulativeRate;
  }

  function lastRefresh() public view override returns (uint256) {
    return _lastRefresh;
  }

  function vaultConfig() public view override returns (VaultConfig memory) {
    return _vaultConfig;
  }

  function a() public view override returns (IAddressProvider) {
    return _a;
  }

  function inceptionCollateral() public view override returns (IERC20) {
    return _inceptionCollateral;
  }

  function adminInceptionVault() public view override returns (IAdminInceptionVault) {
    return _adminInceptionVault;
  }

  function inceptionVaultsData() public view override returns (IInceptionVaultsDataProvider) {
    return _inceptionVaultsData;
  }

  function inceptionPriceFeed() public view override returns (IInceptionVaultPriceFeed) {
    return _inceptionPriceFeed;
  }

  function _addCollateralToVault(uint256 _amount) internal {
    uint256 vaultId = _inceptionVaultsData.vaultId(msg.sender);
    if (vaultId == 0) {
      vaultId = _inceptionVaultsData.createVault(msg.sender);
    }
    _addCollateralToVaultById(vaultId, _amount);
  }

  function _removeCollateralFromVault(uint256 _vaultId, uint256 _amount) internal {
    IInceptionVaultsDataProvider.InceptionVault memory v = _inceptionVaultsData.vaults(_vaultId);
    require(_amount <= v.collateralBalance, ""IV101"");
    uint256 newCollateralBalance = v.collateralBalance.sub(_amount);
    _inceptionVaultsData.setCollateralBalance(_vaultId, newCollateralBalance);
    if (v.baseDebt > 0) {
      _refreshCumulativeRate();
      uint256 newCollateralValue = _inceptionPriceFeed.convertFrom(newCollateralBalance);
      require(
        _a.liquidationManager().isHealthy(
          newCollateralValue,
          _inceptionVaultsData.vaults(_vaultId).baseDebt,
          _vaultConfig.minCollateralRatio
        ),
        ""IV102""
      );
    }

    emit Withdrawn(_vaultId, _amount, msg.sender);
  }

  function _addCollateralToVaultById(uint256 _vaultId, uint256 _amount) internal {
    IInceptionVaultsDataProvider.InceptionVault memory v = _inceptionVaultsData.vaults(_vaultId);
    _inceptionVaultsData.setCollateralBalance(_vaultId, v.collateralBalance.add(_amount));
    emit Deposited(_vaultId, _amount, msg.sender);
  }

  function _refreshCumulativeRate() internal {
    uint256 timestamp = block.timestamp;
    uint256 _timeElapsed = block.timestamp.sub(_lastRefresh);
    _cumulativeRate = _a.ratesManager().calculateCumulativeRate(_vaultConfig.borrowRate, _cumulativeRate, _timeElapsed);
    _lastRefresh = timestamp;
    emit CumulativeRateUpdated(_timeElapsed, _cumulativeRate);
  }

  /**
    Internal helper function to reduce the debt of a vault.
    @dev assumes cumulative rates for the vault's collateral type are up to date.
    please call `refreshCollateral()` before calling this function.
    @param _vaultId the ID of the vault for which to reduce the debt.
    @param _amount the amount of debt to be reduced.
  **/
  function _reduceVaultDebt(uint256 _vaultId, uint256 _amount) internal {
    uint256 currentVaultDebt = _inceptionVaultsData.vaultDebt(_vaultId);
    uint256 remainder = currentVaultDebt.sub(_amount);

    if (remainder == 0) {
      _inceptionVaultsData.setBaseDebt(_vaultId, 0);
    } else {
      uint256 newBaseDebt = _a.ratesManager().calculateBaseDebt(remainder, _cumulativeRate);
      _inceptionVaultsData.setBaseDebt(_vaultId, newBaseDebt);
    }
  }
}",3535
RealWorld_BA_115_IConfigProvider_RealWord_20240830114039.log,115,IConfigProvider,14768,6018,20786,88.0,0.1942,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../interfaces/IAddressProvider.sol"";

interface IConfigProvider {
  struct CollateralConfig {
    address collateralType;
    uint256 debtLimit;
    uint256 liquidationRatio;
    uint256 minCollateralRatio;
    uint256 borrowRate;
    uint256 originationFee;
    uint256 liquidationBonus;
    uint256 liquidationFee;
  }

  event CollateralUpdated(
    address indexed collateralType,
    uint256 debtLimit,
    uint256 liquidationRatio,
    uint256 minCollateralRatio,
    uint256 borrowRate,
    uint256 originationFee,
    uint256 liquidationBonus,
    uint256 liquidationFee
  );
  event CollateralRemoved(address indexed collateralType);

  function setCollateralConfig(
    address _collateralType,
    uint256 _debtLimit,
    uint256 _liquidationRatio,
    uint256 _minCollateralRatio,
    uint256 _borrowRate,
    uint256 _originationFee,
    uint256 _liquidationBonus,
    uint256 _liquidationFee
  ) external;

  function removeCollateral(address _collateralType) external;

  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) external;

  function setCollateralLiquidationRatio(address _collateralType, uint256 _liquidationRatio) external;

  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio) external;

  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) external;

  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) external;

  function setCollateralLiquidationBonus(address _collateralType, uint256 _liquidationBonus) external;

  function setCollateralLiquidationFee(address _collateralType, uint256 _liquidationFee) external;

  function setMinVotingPeriod(uint256 _minVotingPeriod) external;

  function setMaxVotingPeriod(uint256 _maxVotingPeriod) external;

  function setVotingQuorum(uint256 _votingQuorum) external;

  function setProposalThreshold(uint256 _proposalThreshold) external;

  function a() external view returns (IAddressProvider);

  function collateralConfigs(uint256 _id) external view returns (CollateralConfig memory);

  function collateralIds(address _collateralType) external view returns (uint256);

  function numCollateralConfigs() external view returns (uint256);

  function minVotingPeriod() external view returns (uint256);

  function maxVotingPeriod() external view returns (uint256);

  function votingQuorum() external view returns (uint256);

  function proposalThreshold() external view returns (uint256);

  function collateralDebtLimit(address _collateralType) external view returns (uint256);

  function collateralLiquidationRatio(address _collateralType) external view returns (uint256);

  function collateralMinCollateralRatio(address _collateralType) external view returns (uint256);

  function collateralBorrowRate(address _collateralType) external view returns (uint256);

  function collateralOriginationFee(address _collateralType) external view returns (uint256);

  function collateralLiquidationBonus(address _collateralType) external view returns (uint256);

  function collateralLiquidationFee(address _collateralType) external view returns (uint256);
}",732
RealWorld_BA_115_AccessController_RealWord_20240830103300.log,115,AccessController,4649,5002,9651,68.0,0.123285,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract AccessController is AccessControl {
  bytes32 public constant MANAGER_ROLE = keccak256(""MANAGER_ROLE"");
  bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");

  constructor() public {
    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    _setupRole(MANAGER_ROLE, msg.sender);
  }
}",101
RealWorld_BA_115_BaseDistributor_RealWord_20240830093907.log,115,BaseDistributor,19437,5846,25283,91.0,0.214105,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""../libraries/WadRayMath.sol"";
import ""../governance/interfaces/IGovernanceAddressProvider.sol"";
import ""./interfaces/IBaseDistributor.sol"";

/*
  	Distribution Formula:
  	55.5m MIMO in first week
  	-5.55% redution per week

  	total(timestamp) = _SECONDS_PER_WEEK * ( (1-weeklyR^(timestamp/_SECONDS_PER_WEEK)) / (1-weeklyR) )
  		+ timestamp % _SECONDS_PER_WEEK * (1-weeklyR^(timestamp/_SECONDS_PER_WEEK)
  */

abstract contract BaseDistributor is IBaseDistributor {
  using SafeMath for uint256;
  using WadRayMath for uint256;

  uint256 public override totalShares;
  mapping(address => uint256) public override shares;
  address[] public payees;

  IGovernanceAddressProvider public override a;

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), ""Caller is not Manager"");
    _;
  }

  /**
    Public function to release the accumulated new MIMO tokens to the payees.
    @dev anyone can call this.
  */
  function release() public override {
    uint256 newTokens = mintableTokens();
    require(newTokens > 0, ""newTokens is 0"");
    require(payees.length > 0, ""Payees not configured yet"");
    // Mint MIMO to all receivers
    for (uint256 i = 0; i < payees.length; i++) {
      address payee = payees[i];
      _release(newTokens, payee);
    }
    emit TokensReleased(newTokens, now);
  }

  /**
    Updates the payee configuration to a new one.
    @dev will release existing fees before the update.
    @param _payees Array of payees
    @param _shares Array of shares for each payee
  */
  function changePayees(address[] memory _payees, uint256[] memory _shares) public override onlyManager {
    require(_payees.length == _shares.length, ""Payees and shares mismatched"");
    require(_payees.length > 0, ""No payees"");

    if (payees.length > 0 && mintableTokens() > 0) {
      release();
    }

    for (uint256 i = 0; i < payees.length; i++) {
      delete shares[payees[i]];
    }
    delete payees;
    totalShares = 0;

    for (uint256 i = 0; i < _payees.length; i++) {
      _addPayee(_payees[i], _shares[i]);
    }
  }

  /**
    Get current configured payees.
    @return array of current payees.
  */
  function getPayees() public view override returns (address[] memory) {
    return payees;
  }

  /**
    Calculates how many MIMO tokens can be minted since the last time tokens were minted
    @return number of mintable tokens available right now.
  */
  function mintableTokens() public view virtual override returns (uint256);

  /**
    Internal function to release a percentage of newTokens to a specific payee
    @dev uses totalShares to calculate correct share
    @param _totalnewTokensReceived Total newTokens for all payees, will be split according to shares
    @param _payee The address of the payee to whom to distribute the fees.
  */
  function _release(uint256 _totalnewTokensReceived, address _payee) internal virtual;

  /**
    Internal function to add a new payee.
    @dev will update totalShares and therefore reduce the relative share of all other payees.
    @param _payee The address of the payee to add.
    @param _shares The number of shares owned by the payee.
  */
  function _addPayee(address _payee, uint256 _shares) internal {
    require(_payee != address(0), ""payee is the zero address"");
    require(_shares > 0, ""shares are 0"");
    require(shares[_payee] == 0, ""payee already has shares"");

    payees.push(_payee);
    shares[_payee] = _shares;
    totalShares = totalShares.add(_shares);
    emit PayeeAdded(_payee, _shares);
  }
}",967
RealWorld_BA_115_IDemandMinerV2_RealWord_20240830095707.log,115,IDemandMinerV2,6280,4772,11052,64.0,0.12684,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IDemandMinerV2 {
  event FeeCollectorSet(address feeCollector);

  event FeeConfigSet(FeeConfig);

  event DepositFeeReleased(uint256 income);

  event WithdrawFeeReleased(uint256 income);

  struct FeeConfig {
    uint256 depositFee;
    uint256 withdrawFee;
  }

  function setFeeCollector(address feeCollector) external;

  function setFeeConfig(FeeConfig memory newFeeConfig) external;

  function deposit(uint256 amount) external;

  function withdraw(uint256 amount) external;

  function token() external view returns (IERC20);

  function feeCollector() external view returns (address);

  function feeConfig() external view returns (FeeConfig memory);
}",185
RealWorld_BA_115_IAddressProviderV1_RealWord_20240830091516.log,115,IAddressProviderV1,10245,5233,15478,78.0,0.155885,"// SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""./IConfigProviderV1.sol"";
import ""./ILiquidationManagerV1.sol"";
import ""./IVaultsCoreV1.sol"";
import ""../../interfaces/IVaultsCore.sol"";
import ""../../interfaces/IAccessController.sol"";
import ""../../interfaces/ISTABLEX.sol"";
import ""../../interfaces/IPriceFeed.sol"";
import ""../../interfaces/IRatesManager.sol"";
import ""../../interfaces/IVaultsDataProvider.sol"";
import ""../../interfaces/IFeeDistributor.sol"";

interface IAddressProviderV1 {
  function setAccessController(IAccessController _controller) external;

  function setConfigProvider(IConfigProviderV1 _config) external;

  function setVaultsCore(IVaultsCoreV1 _core) external;

  function setStableX(ISTABLEX _stablex) external;

  function setRatesManager(IRatesManager _ratesManager) external;

  function setPriceFeed(IPriceFeed _priceFeed) external;

  function setLiquidationManager(ILiquidationManagerV1 _liquidationManager) external;

  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) external;

  function setFeeDistributor(IFeeDistributor _feeDistributor) external;

  function controller() external view returns (IAccessController);

  function config() external view returns (IConfigProviderV1);

  function core() external view returns (IVaultsCoreV1);

  function stablex() external view returns (ISTABLEX);

  function ratesManager() external view returns (IRatesManager);

  function priceFeed() external view returns (IPriceFeed);

  function liquidationManager() external view returns (ILiquidationManagerV1);

  function vaultsData() external view returns (IVaultsDataProvider);

  function feeDistributor() external view returns (IFeeDistributor);
}",398
RealWorld_BA_115_IMIMO_RealWord_20240830100557.log,115,IMIMO,3970,4210,8180,59.0,0.10405,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IMIMO is IERC20 {
  function burn(address account, uint256 amount) external;

  function mint(address account, uint256 amount) external;
}",66
RealWorld_BA_115_IMIMODistributor_RealWord_20240830100225.log,115,IMIMODistributor,5565,4863,10428,74.0,0.125085,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../../governance/interfaces/IGovernanceAddressProvider.sol"";
import ""./IBaseDistributor.sol"";

interface IMIMODistributorExtension {
  function startTime() external view returns (uint256);

  function currentIssuance() external view returns (uint256);

  function weeklyIssuanceAt(uint256 timestamp) external view returns (uint256);

  function totalSupplyAt(uint256 timestamp) external view returns (uint256);
}

interface IMIMODistributor is IBaseDistributor, IMIMODistributorExtension {}",130
RealWorld_BA_115_GenericMinerV2_RealWord_20240830094935.log,115,GenericMinerV2,54468,5476,59944,87.0,0.38186,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./interfaces/IGenericMinerV2.sol"";
import ""../../libraries/WadRayMath.sol"";
import ""../../libraries/ABDKMath64x64.sol"";

/*
    GenericMiner is based on ERC2917. https://github.com/gnufoo/ERC2917-Proposal

    The Objective of GenericMiner is to implement a decentralized staking mechanism, which calculates _users' share
    by accumulating stake * time. And calculates _users revenue from anytime t0 to t1 by the formula below:

        user_accumulated_stake(time1) - user_accumulated_stake(time0)
       _____________________________________________________________________________  * (gross_stake(t1) - gross_stake(t0))
       total_accumulated_stake(time1) - total_accumulated_stake(time0)

    The boost feature reuses the same principle and applies a multiplier to the stake.

    The boost multiplier formula is the following : a + b / (c + e^-((veMIMO / d) - e))
*/

contract GenericMinerV2 is IGenericMinerV2 {
  using ABDKMath64x64 for int128;
  using ABDKMath64x64 for uint256;
  using SafeMath for uint256;
  using WadRayMath for uint256;

  IERC20 internal immutable _par;
  IGovernanceAddressProvider internal immutable _a;

  BoostConfig internal _boostConfig;

  mapping(address => UserInfo) internal _users;

  uint256 internal _totalStake;
  uint256 internal _totalStakeWithBoost;

  uint256 internal _mimoBalanceTracker;
  uint256 internal _accMimoAmountPerShare;

  uint256 internal _parBalanceTracker;
  uint256 internal _accParAmountPerShare;

  modifier onlyManager {
    require(_a.parallel().controller().hasRole(_a.parallel().controller().MANAGER_ROLE(), msg.sender), ""LM010"");
    _;
  }

  constructor(IGovernanceAddressProvider _addresses, BoostConfig memory boostConfig) public {
    require(address(_addresses) != address(0), ""LM000"");
    _a = _addresses;
    _par = IERC20(_addresses.parallel().stablex());
    require(boostConfig.a >= 1 && boostConfig.d > 0 && boostConfig.maxBoost >= 1, ""LM004"");
    _boostConfig = boostConfig;

    emit BoostConfigSet(_boostConfig);
  }

  /**
    Sets new boost config
    @dev can only be called by protocol manager
    @param newBoostConfig contains all boost multiplier parameters, see {IGenericMinerV2 - BoostConfig}
   */
  function setBoostConfig(BoostConfig memory newBoostConfig) external onlyManager {
    require(newBoostConfig.a >= 1 && newBoostConfig.d > 0 && newBoostConfig.maxBoost >= 1, ""LM004"");
    _boostConfig = newBoostConfig;

    emit BoostConfigSet(_boostConfig);
  }

  /**
    Releases outstanding rewards balances to the user
    @param _user the address of the user for which the reward tokens will be released
  */
  function releaseRewards(address _user) public virtual override {
    UserInfo memory _userInfo = _users[_user];
    _releaseRewards(_user, _userInfo);
    _userInfo.accAmountPerShare = _accMimoAmountPerShare;
    _userInfo.accParAmountPerShare = _accParAmountPerShare;
    _updateBoost(_user, _userInfo);
  }

  /**
    Reapplies the boost of the user, useful if a whale's vMIMO has decreased but their boost is still the original value
  */
  function updateBoost(address _user) public {
    UserInfo memory userInfo = _users[_user];
    _updateBoost(_user, userInfo);
  }

  /**
    Returns the number of tokens a user has staked
    @param _user the address of the user
    @return number of staked tokens
  */
  function stake(address _user) public view override returns (uint256) {
    return _users[_user].stake;
  }

  /**
    Returns the number of tokens a user has staked with the boost
    @param _user the address of the user
    @return number of staked tokens with boost
  */
  function stakeWithBoost(address _user) public view override returns (uint256) {
    return _users[_user].stakeWithBoost;
  }

  /**
    Returns the number of tokens a user can claim via `releaseMIMO`
    @param _user the address of the user
    @return number of MIMO tokens that the user can claim
  */
  function pendingMIMO(address _user) public view override returns (uint256) {
    UserInfo memory _userInfo = _users[_user];
    return _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);
  }

  /**
    Returns the number of PAR tokens the user has earned as a reward
    @param _user the address of the user
    @return number of PAR tokens that will be sent automatically when staking/unstaking
  */
  function pendingPAR(address _user) public view override returns (uint256) {
    UserInfo memory _userInfo = _users[_user];
    return _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);
  }

  function par() public view override returns (IERC20) {
    return _par;
  }

  function a() public view override returns (IGovernanceAddressProvider) {
    return _a;
  }

  function boostConfig() public view override returns (BoostConfig memory) {
    return _boostConfig;
  }

  function totalStake() public view override returns (uint256) {
    return _totalStake;
  }

  function totalStakeWithBoost() public view override returns (uint256) {
    return _totalStakeWithBoost;
  }

  /**
    Returns the userInfo stored of a user
    @param _user the address of the user
    @return `struct UserInfo {
      uint256 stake;
      uint256 stakeWithBoost;
      uint256 accAmountPerShare;
      uint256 accParAmountPerShare;
    }`
  **/
  function userInfo(address _user) public view override returns (UserInfo memory) {
    return _users[_user];
  }

  /**
    Refreshes the global state and subsequently increases a user's stake
    This is an internal call and meant to be called within derivative contracts
    @param user the address of the user
    @param value the amount by which the stake will be increased
  */
  function _increaseStake(address user, uint256 value) internal {
    require(value > 0, ""LM101"");
    UserInfo memory _userInfo = _users[user];

    _releaseRewards(user, _userInfo);
    _totalStake = _totalStake.add(value);
    _userInfo.stake = _userInfo.stake.add(value);
    _userInfo.accAmountPerShare = _accMimoAmountPerShare;
    _userInfo.accParAmountPerShare = _accParAmountPerShare;
    _updateBoost(user, _userInfo);

    emit StakeIncreased(user, value);
  }

  /**
    Refreshes the global state and subsequently decreases the stake a user has
    This is an internal call and meant to be called within derivative contracts
    @param user the address of the user
    @param value the amount by which the stake will be reduced
  */
  function _decreaseStake(address user, uint256 value) internal {
    require(value > 0, ""LM101"");
    UserInfo memory _userInfo = _users[user];
    require(_userInfo.stake >= value, ""LM102"");

    _releaseRewards(user, _userInfo);
    _totalStake = _totalStake.sub(value);
    _userInfo.stake = _userInfo.stake.sub(value);
    _userInfo.accAmountPerShare = _accMimoAmountPerShare;
    _userInfo.accParAmountPerShare = _accParAmountPerShare;
    _updateBoost(user, _userInfo);

    emit StakeDecreased(user, value);
  }

  function _releaseRewards(address _user, UserInfo memory _userInfo) internal {
    uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);
    uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);
    _refresh();

    if (_userInfo.stakeWithBoost > 0) {
      _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);
      _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);
    }

    if (pendingMIMO > 0) {
      require(_a.mimo().transfer(_user, pendingMIMO), ""LM100"");
    }
    if (pendingPAR > 0) {
      require(_par.transfer(_user, pendingPAR), ""LM100"");
    }
  }

  /**
    Updates the internal state variables based on user's veMIMO hodlings
    @param _user the address of the user
   */
  function _updateBoost(address _user, UserInfo memory _userInfo) internal {
    // if user had a boost already, first remove it from the totalStakeWithBoost
    if (_userInfo.stakeWithBoost > 0) {
      _totalStakeWithBoost = _totalStakeWithBoost.sub(_userInfo.stakeWithBoost);
    }
    uint256 multiplier = _getBoostMultiplier(_user);
    _userInfo.stakeWithBoost = _userInfo.stake.wadMul(multiplier);
    _totalStakeWithBoost = _totalStakeWithBoost.add(_userInfo.stakeWithBoost);
    _users[_user] = _userInfo;
  }

  /**
    Refreshes the global state and subsequently updates a user's stake
    This is an internal call and meant to be called within derivative contracts
    @param user the address of the user
    @param stake the new amount of stake for the user
  */
  function _updateStake(address user, uint256 stake) internal returns (bool) {
    uint256 oldStake = _users[user].stake;
    if (stake > oldStake) {
      _increaseStake(user, stake.sub(oldStake));
    }
    if (stake < oldStake) {
      _decreaseStake(user, oldStake.sub(stake));
    }
  }

  /**
    Updates the internal state variables after accounting for newly received MIMO and PAR reward tokens
  */
  function _refresh() internal {
    if (_totalStake == 0) {
      return;
    }
    uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));
    uint256 currentParBalance = _par.balanceOf(address(this));
    uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);
    uint256 parReward = currentParBalance.sub(_parBalanceTracker);

    _mimoBalanceTracker = currentMimoBalance;
    _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));
    _parBalanceTracker = currentParBalance;
    _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));
  }

  /**
    Returns the number of tokens a user can claim via `releaseMIMO`
    @return number of MIMO tokens that the user can claim
  */
  function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {
    if (_totalStakeWithBoost == 0) {
      return 0;
    }
    uint256 currentBalance = _a.mimo().balanceOf(address(this));
    uint256 reward = currentBalance.sub(_mimoBalanceTracker);
    uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));
    return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));
  }

  /**
    Returns the number of PAR tokens the user has earned as a reward
    @return number of PAR tokens that will be sent automatically when staking/unstaking
  */
  function _pendingPAR(uint256 _userStakeWithBoost, uint256 _userAccParAmountPerShare) internal view returns (uint256) {
    if (_totalStakeWithBoost == 0) {
      return 0;
    }
    uint256 currentBalance = _par.balanceOf(address(this));
    uint256 reward = currentBalance.sub(_parBalanceTracker);
    uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));

    return _userStakeWithBoost.rayMul(accParAmountPerShare.sub(_userAccParAmountPerShare));
  }

  /**
    Returns the boost multiplier the user is eligible for
    @param _user the address of the user
    @return the boost multiplier based on the user's veMIMO per the boost formula : a + b / (c + e^-((veMIMO / d) - e))
   */
  function _getBoostMultiplier(address _user) internal view returns (uint256) {
    uint256 veMIMO = _a.votingEscrow().balanceOf(_user);

    if (veMIMO == 0) return 1e18;

    // Convert boostConfig variables to signed 64.64-bit fixed point numbers
    int128 a = ABDKMath64x64.fromUInt(_boostConfig.a);
    int128 b = ABDKMath64x64.fromUInt(_boostConfig.b);
    int128 c = ABDKMath64x64.fromUInt(_boostConfig.c);
    int128 e = ABDKMath64x64.fromUInt(_boostConfig.e);
    int128 DECIMALS = ABDKMath64x64.fromUInt(1e18);

    int128 e1 = veMIMO.divu(_boostConfig.d); // x/25000
    int128 e2 = e1.sub(e); // x/25000 - 6
    int128 e3 = e2.neg(); // -(x/25000 - 6)
    int128 e4 = e3.exp(); // e^-(x/25000 - 6)
    int128 e5 = e4.add(c); // 1 + e^-(x/25000 - 6)
    int128 e6 = b.div(e5).add(a); // 1 + 3/(1 + e^-(x/25000 - 6))
    uint64 e7 = e6.mul(DECIMALS).toUInt(); // convert back to uint64
    uint256 multiplier = uint256(e7); // convert to uint256

    require(multiplier >= 1e18 && multiplier <= _boostConfig.maxBoost, ""LM103"");

    return multiplier;
  }
}",3234
RealWorld_BA_115_DemandMiner_RealWord_20240830094040.log,115,DemandMiner,8975,5225,14200,91.0,0.149375,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""./GenericMiner.sol"";
import ""./interfaces/IMIMO.sol"";
import ""./interfaces/IDemandMiner.sol"";

contract DemandMiner is IDemandMiner, GenericMiner {
  using SafeMath for uint256;
  using SafeERC20 for IERC20;

  IERC20 public override token;

  constructor(IGovernanceAddressProvider _addresses, IERC20 _token) public GenericMiner(_addresses) {
    require(address(_token) != address(0));
    require(address(_token) != address(_addresses.mimo()));
    token = _token;
  }

  /**
    Deposit an ERC20 pool token for staking
    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.
    @param amount the amount of tokens to be deposited. Unit is in WEI.
  **/
  function deposit(uint256 amount) public override {
    token.safeTransferFrom(msg.sender, address(this), amount);
    _increaseStake(msg.sender, amount);
  }

  /**
    Withdraw staked ERC20 pool tokens. Will fail if user does not have enough tokens staked.
    @param amount the amount of tokens to be withdrawn. Unit is in WEI.
  **/
  function withdraw(uint256 amount) public override {
    token.safeTransfer(msg.sender, amount);
    _decreaseStake(msg.sender, amount);
  }
}",361
RealWorld_BA_115_IGUniPool_RealWord_20240830112514.log,115,IGUniPool,4257,4173,8430,67.0,0.104745,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

interface IGUniPool {
  function token0() external view returns (address);

  function token1() external view returns (address);

  function totalSupply() external view returns (uint256);

  function getUnderlyingBalancesAtPrice(uint160) external view returns (uint256, uint256);
}",78
RealWorld_BA_115_IInceptionVaultPriceFeed_RealWord_20240830104914.log,115,IInceptionVaultPriceFeed,6587,4831,11418,81.0,0.129555,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../../chainlink/AggregatorV3Interface.sol"";
import ""../../interfaces/IAddressProvider.sol"";

interface IInceptionVaultPriceFeed {
  event PriceFeedAdded(uint16 _id, address _priceFeed);

  function initialize(
    IAddressProvider _addresses,
    address _inceptionCollateral,
    address _assetOracle,
    AggregatorV3Interface _eurOracle
  ) external;

  function a() external view returns (IAddressProvider);

  function inceptionCollateral() external view returns (ERC20);

  function assetOracle() external view returns (AggregatorV3Interface);

  function eurOracle() external view returns (AggregatorV3Interface);

  function getAssetPrice() external view returns (uint256);

  function convertFrom(uint256 _amount) external view returns (uint256);

  function convertTo(uint256 _amount) external view returns (uint256);
}",216
RealWorld_BA_115_IConfigProviderV1_RealWord_20240830092029.log,115,IConfigProviderV1,10352,5182,15534,74.0,0.1554,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""./IAddressProviderV1.sol"";

interface IConfigProviderV1 {
  struct CollateralConfig {
    address collateralType;
    uint256 debtLimit;
    uint256 minCollateralRatio;
    uint256 borrowRate;
    uint256 originationFee;
  }

  event CollateralUpdated(
    address indexed collateralType,
    uint256 debtLimit,
    uint256 minCollateralRatio,
    uint256 borrowRate,
    uint256 originationFee
  );
  event CollateralRemoved(address indexed collateralType);

  function setCollateralConfig(
    address _collateralType,
    uint256 _debtLimit,
    uint256 _minCollateralRatio,
    uint256 _borrowRate,
    uint256 _originationFee
  ) external;

  function removeCollateral(address _collateralType) external;

  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) external;

  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio) external;

  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) external;

  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) external;

  function setLiquidationBonus(uint256 _bonus) external;

  function a() external view returns (IAddressProviderV1);

  function collateralConfigs(uint256 _id) external view returns (CollateralConfig memory);

  function collateralIds(address _collateralType) external view returns (uint256);

  function numCollateralConfigs() external view returns (uint256);

  function liquidationBonus() external view returns (uint256);

  function collateralDebtLimit(address _collateralType) external view returns (uint256);

  function collateralMinCollateralRatio(address _collateralType) external view returns (uint256);

  function collateralBorrowRate(address _collateralType) external view returns (uint256);

  function collateralOriginationFee(address _collateralType) external view returns (uint256);
}",454
RealWorld_BA_115_GovernorAlpha_RealWord_20240830110859.log,115,GovernorAlpha,38373,5601,43974,100.0,0.303885,"// SPDX-License-Identifier: BSD-3-Clause
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./interfaces/IGovernorAlpha.sol"";
import ""./interfaces/IGovernanceAddressProvider.sol"";
import ""../libraries/WadRayMath.sol"";

contract GovernorAlpha is IGovernorAlpha {
  using SafeMath for uint256;
  using WadRayMath for uint256;

  /// @notice The maximum number of actions that can be included in a proposal
  function proposalMaxOperations() public pure returns (uint256) {
    return 10;
  } // 10 actions

  IGovernanceAddressProvider public a;

  /// @notice The address of the Governor Guardian
  address public guardian;

  /// @notice The total number of proposals
  uint256 public proposalCount;

  /// @notice The official record of all proposals ever proposed
  mapping(uint256 => Proposal) public proposals;

  /// @notice The latest proposal for each proposer
  mapping(address => uint256) public latestProposalIds;

  constructor(IGovernanceAddressProvider _addresses, address _guardian) public {
    require(address(_addresses) != address(0));
    require(address(_guardian) != address(0));

    a = _addresses;
    guardian = _guardian;
  }

  function propose(
    address[] memory targets,
    uint256[] memory values,
    string[] memory signatures,
    bytes[] memory calldatas,
    string memory description,
    uint256 endTime
  ) public override returns (uint256) {
    uint256 votingDuration = endTime.sub(block.timestamp);
    require(votingDuration >= a.parallel().config().minVotingPeriod(), ""Proposal end-time too early"");
    require(votingDuration <= a.parallel().config().maxVotingPeriod(), ""Proposal end-time too late"");

    require(
      a.votingEscrow().balanceOfAt(msg.sender, endTime) > proposalThreshold(),
      ""GovernorAlpha::propose: proposer votes below proposal threshold""
    );
    require(
      targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length,
      ""GovernorAlpha::propose: proposal function information arity mismatch""
    );
    require(targets.length != 0, ""GovernorAlpha::propose: must provide actions"");
    require(targets.length <= proposalMaxOperations(), ""GovernorAlpha::propose: too many actions"");

    uint256 latestProposalId = latestProposalIds[msg.sender];
    if (latestProposalId != 0) {
      ProposalState proposersLatestProposalState = state(latestProposalId);
      require(
        proposersLatestProposalState != ProposalState.Active,
        ""GovernorAlpha::propose: one live proposal per proposer, found an already active proposal""
      );
    }

    proposalCount++;
    Proposal memory newProposal = Proposal({
      id: proposalCount,
      proposer: msg.sender,
      eta: 0,
      targets: targets,
      values: values,
      signatures: signatures,
      calldatas: calldatas,
      startTime: block.timestamp,
      endTime: endTime,
      forVotes: 0,
      againstVotes: 0,
      canceled: false,
      executed: false
    });

    proposals[newProposal.id] = newProposal;
    latestProposalIds[newProposal.proposer] = newProposal.id;

    emit ProposalCreated(
      newProposal.id,
      msg.sender,
      targets,
      values,
      signatures,
      calldatas,
      block.timestamp,
      endTime,
      description
    );
    return newProposal.id;
  }

  function queue(uint256 proposalId) public override {
    require(
      state(proposalId) == ProposalState.Succeeded,
      ""GovernorAlpha::queue: proposal can only be queued if it is succeeded""
    );
    Proposal storage proposal = proposals[proposalId];
    uint256 eta = block.timestamp.add(a.timelock().delay());
    for (uint256 i = 0; i < proposal.targets.length; i++) {
      _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);
    }
    proposal.eta = eta;
    emit ProposalQueued(proposalId, eta);
  }

  function execute(uint256 proposalId) public payable override {
    require(
      state(proposalId) == ProposalState.Queued,
      ""GovernorAlpha::execute: proposal can only be executed if it is queued""
    );
    Proposal storage proposal = proposals[proposalId];
    proposal.executed = true;
    for (uint256 i = 0; i < proposal.targets.length; i++) {
      a.timelock().executeTransaction{ value: proposal.values[i] }(
        proposal.targets[i],
        proposal.values[i],
        proposal.signatures[i],
        proposal.calldatas[i],
        proposal.eta
      );
    }
    emit ProposalExecuted(proposalId);
  }

  function cancel(uint256 proposalId) public override {
    ProposalState state = state(proposalId);
    require(state != ProposalState.Executed, ""GovernorAlpha::cancel: cannot cancel executed proposal"");

    Proposal storage proposal = proposals[proposalId];
    require(msg.sender == guardian, ""Only Guardian can cancel"");

    proposal.canceled = true;
    for (uint256 i = 0; i < proposal.targets.length; i++) {
      a.timelock().cancelTransaction(
        proposal.targets[i],
        proposal.values[i],
        proposal.signatures[i],
        proposal.calldatas[i],
        proposal.eta
      );
    }

    emit ProposalCanceled(proposalId);
  }

  function castVote(uint256 proposalId, bool support) public override {
    require(state(proposalId) == ProposalState.Active, ""GovernorAlpha::_castVote: voting is closed"");
    Proposal storage proposal = proposals[proposalId];
    Receipt storage receipt = proposal.receipts[msg.sender];
    require(receipt.hasVoted == false, ""GovernorAlpha::_castVote: voter already voted"");
    uint256 votes = a.votingEscrow().balanceOfAt(msg.sender, proposal.endTime);

    if (support) {
      proposal.forVotes = proposal.forVotes.add(votes);
    } else {
      proposal.againstVotes = proposal.againstVotes.add(votes);
    }

    receipt.hasVoted = true;
    receipt.support = support;
    receipt.votes = votes;

    emit VoteCast(msg.sender, proposalId, support, votes);
  }

  // solhint-disable-next-line private-vars-leading-underscore
  function __acceptAdmin() public {
    require(msg.sender == guardian, ""GovernorAlpha::__acceptAdmin: sender must be gov guardian"");
    a.timelock().acceptAdmin();
  }

  // solhint-disable-next-line private-vars-leading-underscore
  function __abdicate() public {
    require(msg.sender == guardian, ""GovernorAlpha::__abdicate: sender must be gov guardian"");
    guardian = address(0);
  }

  // solhint-disable-next-line private-vars-leading-underscore
  function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {
    require(msg.sender == guardian, ""GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian"");
    a.timelock().queueTransaction(
      address(a.timelock()),
      0,
      ""setPendingAdmin(address)"",
      abi.encode(newPendingAdmin),
      eta
    );
  }

  // solhint-disable-next-line private-vars-leading-underscore
  function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {
    require(msg.sender == guardian, ""GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian"");
    a.timelock().executeTransaction(
      address(a.timelock()),
      0,
      ""setPendingAdmin(address)"",
      abi.encode(newPendingAdmin),
      eta
    );
  }

  /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed
  function quorumVotes() public view override returns (uint256) {
    return a.votingEscrow().stakingToken().totalSupply().wadMul(a.parallel().config().votingQuorum());
  }

  /// @notice The number of votes required in order for a voter to become a proposer
  function proposalThreshold() public view override returns (uint256) {
    return a.votingEscrow().stakingToken().totalSupply().wadMul(a.parallel().config().proposalThreshold());
  }

  function getActions(uint256 proposalId)
    public
    view
    override
    returns (
      address[] memory targets,
      uint256[] memory values,
      string[] memory signatures,
      bytes[] memory calldatas
    )
  {
    Proposal storage p = proposals[proposalId];
    return (p.targets, p.values, p.signatures, p.calldatas);
  }

  function getReceipt(uint256 proposalId, address voter) public view override returns (Receipt memory) {
    return proposals[proposalId].receipts[voter];
  }

  function state(uint256 proposalId) public view override returns (ProposalState) {
    require(proposalCount >= proposalId && proposalId > 0, ""GovernorAlpha::state: invalid proposal id"");
    Proposal storage proposal = proposals[proposalId];
    if (proposal.canceled) {
      return ProposalState.Canceled;
    } else if (block.timestamp <= proposal.endTime) {
      return ProposalState.Active;
    } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {
      return ProposalState.Defeated;
    } else if (proposal.eta == 0) {
      return ProposalState.Succeeded;
    } else if (proposal.executed) {
      return ProposalState.Executed;
    } else if (block.timestamp >= a.timelock().GRACE_PERIOD().add(proposal.endTime)) {
      return ProposalState.Expired;
    } else {
      return ProposalState.Queued;
    }
  }

  function _queueOrRevert(
    address target,
    uint256 value,
    string memory signature,
    bytes memory data,
    uint256 eta
  ) internal {
    require(
      !a.timelock().queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),
      ""GovernorAlpha::_queueOrRevert: proposal action already queued at eta""
    );
    a.timelock().queueTransaction(target, value, signature, data, eta);
  }
}",2229
RealWorld_BA_115_AddressProvider_RealWord_20240830102154.log,115,AddressProvider,13292,4917,18209,73.0,0.1648,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/IVaultsCore.sol"";
import ""../interfaces/IAccessController.sol"";
import ""../interfaces/IConfigProvider.sol"";
import ""../interfaces/ISTABLEX.sol"";
import ""../interfaces/IPriceFeed.sol"";
import ""../interfaces/IRatesManager.sol"";
import ""../interfaces/ILiquidationManager.sol"";
import ""../interfaces/IVaultsCore.sol"";
import ""../interfaces/IVaultsDataProvider.sol"";

contract AddressProvider is IAddressProvider {
  IAccessController public override controller;
  IConfigProvider public override config;
  IVaultsCore public override core;

  ISTABLEX public override stablex;
  IRatesManager public override ratesManager;
  IPriceFeed public override priceFeed;
  ILiquidationManager public override liquidationManager;
  IVaultsDataProvider public override vaultsData;
  IFeeDistributor public override feeDistributor;

  constructor(IAccessController _controller) public {
    controller = _controller;
  }

  modifier onlyManager() {
    require(controller.hasRole(controller.MANAGER_ROLE(), msg.sender), ""Caller is not a Manager"");
    _;
  }

  function setAccessController(IAccessController _controller) public override onlyManager {
    require(address(_controller) != address(0));
    controller = _controller;
  }

  function setConfigProvider(IConfigProvider _config) public override onlyManager {
    require(address(_config) != address(0));
    config = _config;
  }

  function setVaultsCore(IVaultsCore _core) public override onlyManager {
    require(address(_core) != address(0));
    core = _core;
  }

  function setStableX(ISTABLEX _stablex) public override onlyManager {
    require(address(_stablex) != address(0));
    stablex = _stablex;
  }

  function setRatesManager(IRatesManager _ratesManager) public override onlyManager {
    require(address(_ratesManager) != address(0));
    ratesManager = _ratesManager;
  }

  function setLiquidationManager(ILiquidationManager _liquidationManager) public override onlyManager {
    require(address(_liquidationManager) != address(0));
    liquidationManager = _liquidationManager;
  }

  function setPriceFeed(IPriceFeed _priceFeed) public override onlyManager {
    require(address(_priceFeed) != address(0));
    priceFeed = _priceFeed;
  }

  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) public override onlyManager {
    require(address(_vaultsData) != address(0));
    vaultsData = _vaultsData;
  }

  function setFeeDistributor(IFeeDistributor _feeDistributor) public override onlyManager {
    require(address(_feeDistributor) != address(0));
    feeDistributor = _feeDistributor;
  }
}",624
RealWorld_BA_115_IPriceFeed_RealWord_20240830113442.log,115,IPriceFeed,6170,4999,11169,68.0,0.13083,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""../chainlink/AggregatorV3Interface.sol"";
import ""../interfaces/IAddressProvider.sol"";

interface IPriceFeed {
  event OracleUpdated(address indexed asset, address oracle, address sender);
  event EurOracleUpdated(address oracle, address sender);

  function setAssetOracle(address _asset, address _oracle) external;

  function setEurOracle(address _oracle) external;

  function a() external view returns (IAddressProvider);

  function assetOracles(address _asset) external view returns (AggregatorV3Interface);

  function eurOracle() external view returns (AggregatorV3Interface);

  function getAssetPrice(address _asset) external view returns (uint256);

  function convertFrom(address _asset, uint256 _amount) external view returns (uint256);

  function convertTo(address _asset, uint256 _amount) external view returns (uint256);
}",197
RealWorld_BA_115_BNum_RealWord_20240830105527.log,115,BNum,22541,5622,28163,80.0,0.225145,"// https://github.com/balancer-labs/balancer-core/blob/master/contracts/BNum.sol

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

/* solhint-disable private-vars-leading-underscore */

pragma solidity 0.6.12;

import ""./BConst.sol"";

contract BNum is BConst {
  function btoi(uint256 a) internal pure returns (uint256) {
    return a / BONE;
  }

  function bfloor(uint256 a) internal pure returns (uint256) {
    return btoi(a) * BONE;
  }

  function badd(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a, ""ERR_ADD_OVERFLOW"");
    return c;
  }

  function bsub(uint256 a, uint256 b) internal pure returns (uint256) {
    (uint256 c, bool flag) = bsubSign(a, b);
    require(!flag, ""ERR_SUB_UNDERFLOW"");
    return c;
  }

  function bsubSign(uint256 a, uint256 b) internal pure returns (uint256, bool) {
    if (a >= b) {
      return (a - b, false);
    } else {
      return (b - a, true);
    }
  }

  function bmul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c0 = a * b;
    require(a == 0 || c0 / a == b, ""ERR_MUL_OVERFLOW"");
    uint256 c1 = c0 + (BONE / 2);
    require(c1 >= c0, ""ERR_MUL_OVERFLOW"");
    uint256 c2 = c1 / BONE;
    return c2;
  }

  function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0, ""ERR_DIV_ZERO"");
    uint256 c0 = a * BONE;
    require(a == 0 || c0 / a == BONE, ""ERR_DIV_INTERNAL""); // bmul overflow
    uint256 c1 = c0 + (b / 2);
    require(c1 >= c0, ""ERR_DIV_INTERNAL""); //  badd require
    uint256 c2 = c1 / b;
    return c2;
  }

  // DSMath.wpow
  function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {
    uint256 z = n % 2 != 0 ? a : BONE;

    for (n /= 2; n != 0; n /= 2) {
      a = bmul(a, a);

      if (n % 2 != 0) {
        z = bmul(z, a);
      }
    }
    return z;
  }

  // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).
  // Use `bpowi` for `b^e` and `bpowK` for k iterations
  // of approximation of b^0.w
  function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {
    require(base >= MIN_BPOW_BASE, ""ERR_BPOW_BASE_TOO_LOW"");
    require(base <= MAX_BPOW_BASE, ""ERR_BPOW_BASE_TOO_HIGH"");

    uint256 whole = bfloor(exp);
    uint256 remain = bsub(exp, whole);

    uint256 wholePow = bpowi(base, btoi(whole));

    if (remain == 0) {
      return wholePow;
    }

    uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);
    return bmul(wholePow, partialResult);
  }

  function bpowApprox(
    uint256 base,
    uint256 exp,
    uint256 precision
  ) internal pure returns (uint256) {
    // term 0:
    uint256 a = exp;
    (uint256 x, bool xneg) = bsubSign(base, BONE);
    uint256 term = BONE;
    uint256 sum = term;
    bool negative = false;

    // term(k) = numer / denom
    //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)
    // each iteration, multiply previous term by (a-(k-1)) * x / k
    // continue until term is less than precision
    for (uint256 i = 1; term >= precision; i++) {
      uint256 bigK = i * BONE;
      (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));
      term = bmul(term, bmul(c, x));
      term = bdiv(term, bigK);
      if (term == 0) break;

      if (xneg) negative = !negative;
      if (cneg) negative = !negative;
      if (negative) {
        sum = bsub(sum, term);
      } else {
        sum = badd(sum, term);
      }
    }

    return sum;
  }
}",1220
RealWorld_BA_115_IDexAddressProvider_RealWord_20240830120429.log,115,IDexAddressProvider,5150,4789,9939,57.0,0.12153,"// SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;
pragma solidity 0.8.10;

import ""./IAddressProvider.sol"";

interface IDexAddressProvider {
  event DexSet(uint8);

  struct Dex {
    address proxy;
    address router;
  }

  function setDexMapping(
    uint256 _index,
    address _proxy,
    address _dex
  ) external;

  function parallel() external view returns (IAddressProvider);

  function dexMapping(uint256 index) external view returns (address, address);
}",114
RealWorld_BA_115_IFeeDistributor_RealWord_20240830113205.log,115,IFeeDistributor,5894,5022,10916,69.0,0.12991,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""../interfaces/IAddressProvider.sol"";

interface IFeeDistributor {
  event PayeeAdded(address indexed account, uint256 shares);
  event FeeReleased(uint256 income, uint256 releasedAt);

  function release() external;

  function changePayees(address[] memory _payees, uint256[] memory _shares) external;

  function a() external view returns (IAddressProvider);

  function lastReleasedAt() external view returns (uint256);

  function getPayees() external view returns (address[] memory);

  function totalShares() external view returns (uint256);

  function shares(address payee) external view returns (uint256);
}",149
RealWorld_BA_115_IAdminInceptionVault_RealWord_20240830104631.log,115,IAdminInceptionVault,9544,4998,14542,81.0,0.14768,"//SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./IInceptionVaultsCore.sol"";
import ""../../interfaces/IAddressProvider.sol"";
import ""../../interfaces/IWETH.sol"";
import ""../../liquidityMining/interfaces/IDebtNotifier.sol"";

interface IAdminInceptionVault {
  function initialize(
    address owner,
    IAddressProvider _addressProvider,
    IDebtNotifier _debtNotifier,
    IWETH _WETH,
    IERC20 _mimo,
    IInceptionVaultsCore _inceptionVaultsCore
  ) external;

  function depositETH() external payable;

  function depositETHAndBorrow(uint256 _borrowAmount) external payable;

  function deposit(address _collateralType, uint256 _amount) external;

  function depositAndBorrow(
    address _collateralType,
    uint256 _depositAmount,
    uint256 _vaultId
  ) external;

  function borrow(uint256 _vaultId, uint256 _amount) external;

  function withdraw(uint256 _vaultId, uint256 _amount) external;

  function claimMimo() external;

  function lendPAR(uint256 _amoutn, address _to) external;

  function transferMimo(uint256 _amount, address _to) external;

  function transferPar(uint256 _amount, address _to) external;

  function inceptionCore() external view returns (IInceptionVaultsCore);

  function collateralCount() external view returns (uint8);

  function collaterals(uint8 _id) external view returns (address);

  function collateralId(address _collateral) external view returns (uint8);

  // Read only
  function a() external view returns (IAddressProvider);

  function debtNotifier() external view returns (IDebtNotifier);

  function weth() external view returns (IWETH);

  function mimo() external view returns (IERC20);
}",416
RealWorld_BA_115_BPool_RealWord_20240830110343.log,115,BPool,11940,4990,16930,87.0,0.1595,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface BPool is IERC20 {
  function gulp(address token) external;

  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;

  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;

  function swapExactAmountIn(
    address tokenIn,
    uint256 tokenAmountIn,
    address tokenOut,
    uint256 minAmountOut,
    uint256 maxPrice
  ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);

  function swapExactAmountOut(
    address tokenIn,
    uint256 maxAmountIn,
    address tokenOut,
    uint256 tokenAmountOut,
    uint256 maxPrice
  ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);

  function joinswapExternAmountIn(
    address tokenIn,
    uint256 tokenAmountIn,
    uint256 minPoolAmountOut
  ) external returns (uint256 poolAmountOut);

  function joinswapPoolAmountOut(
    address tokenIn,
    uint256 poolAmountOut,
    uint256 maxAmountIn
  ) external returns (uint256 tokenAmountIn);

  function exitswapPoolAmountIn(
    address tokenOut,
    uint256 poolAmountIn,
    uint256 minAmountOut
  ) external returns (uint256 tokenAmountOut);

  function exitswapExternAmountOut(
    address tokenOut,
    uint256 tokenAmountOut,
    uint256 maxPoolAmountIn
  ) external returns (uint256 poolAmountIn);

  function calcPoolOutGivenSingleIn(
    uint256 tokenBalanceIn,
    uint256 tokenWeightIn,
    uint256 poolSupply,
    uint256 totalWeight,
    uint256 tokenAmountIn,
    uint256 swapFee
  ) external pure returns (uint256 poolAmountOut);

  function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);

  function getSpotPriceSansFee(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);

  function getSwapFee() external view returns (uint256);

  function getBalance(address token) external view returns (uint256);

  function getDenormalizedWeight(address token) external view returns (uint256);

  function getTotalDenormalizedWeight() external view returns (uint256);

  function getNormalizedWeight(address token) external view returns (uint256);

  function isPublicSwap() external view returns (bool);

  function isFinalized() external view returns (bool);
}",568
RealWorld_BA_115_ABDKMath64x64_RealWord_20240830105037.log,115,ABDKMath64x64,0,0,0,,0.0,"// SPDX-License-Identifier: BSD-4-Clause
/*
 * ABDK Math 64.64 Smart Contract Library.  Copyright © 2019 by ABDK Consulting.
 * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>
 */
pragma solidity 0.6.12;

/**
 * Smart contract library of mathematical functions operating with signed
 * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is
 * basically a simple fraction whose numerator is signed 128-bit integer and
 * denominator is 2^64.  As long as denominator is always the same, there is no
 * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are
 * represented by int128 type holding only the numerator.
 */
library ABDKMath64x64 {
  /*
   * Minimum value signed 64.64-bit fixed point number may have.
   */
  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;

  /*
   * Maximum value signed 64.64-bit fixed point number may have.
   */
  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

  /**
   * Convert signed 256-bit integer number into signed 64.64-bit fixed point
   * number.  Revert on overflow.
   *
   * @param x signed 256-bit integer number
   * @return signed 64.64-bit fixed point number
   */
  function fromInt(int256 x) internal pure returns (int128) {
    require(x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);
    return int128(x << 64);
  }

  /**
   * Convert signed 64.64 fixed point number into signed 64-bit integer number
   * rounding down.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64-bit integer number
   */
  function toInt(int128 x) internal pure returns (int64) {
    return int64(x >> 64);
  }

  /**
   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point
   * number.  Revert on overflow.
   *
   * @param x unsigned 256-bit integer number
   * @return signed 64.64-bit fixed point number
   */
  function fromUInt(uint256 x) internal pure returns (int128) {
    require(x <= 0x7FFFFFFFFFFFFFFF);
    return int128(x << 64);
  }

  /**
   * Convert signed 64.64 fixed point number into unsigned 64-bit integer
   * number rounding down.  Revert on underflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @return unsigned 64-bit integer number
   */
  function toUInt(int128 x) internal pure returns (uint64) {
    require(x >= 0);
    return uint64(x >> 64);
  }

  /**
   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point
   * number rounding down.  Revert on overflow.
   *
   * @param x signed 128.128-bin fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function from128x128(int256 x) internal pure returns (int128) {
    int256 result = x >> 64;
    require(result >= MIN_64x64 && result <= MAX_64x64);
    return int128(result);
  }

  /**
   * Convert signed 64.64 fixed point number into signed 128.128 fixed point
   * number.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 128.128 fixed point number
   */
  function to128x128(int128 x) internal pure returns (int256) {
    return int256(x) << 64;
  }

  /**
   * Calculate x + y.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @param y signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function add(int128 x, int128 y) internal pure returns (int128) {
    int256 result = int256(x) + y;
    require(result >= MIN_64x64 && result <= MAX_64x64);
    return int128(result);
  }

  /**
   * Calculate x - y.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @param y signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function sub(int128 x, int128 y) internal pure returns (int128) {
    int256 result = int256(x) - y;
    require(result >= MIN_64x64 && result <= MAX_64x64);
    return int128(result);
  }

  /**
   * Calculate x * y rounding down.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @param y signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function mul(int128 x, int128 y) internal pure returns (int128) {
    int256 result = (int256(x) * y) >> 64;
    require(result >= MIN_64x64 && result <= MAX_64x64);
    return int128(result);
  }

  /**
   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point
   * number and y is signed 256-bit integer number.  Revert on overflow.
   *
   * @param x signed 64.64 fixed point number
   * @param y signed 256-bit integer number
   * @return signed 256-bit integer number
   */
  function muli(int128 x, int256 y) internal pure returns (int256) {
    if (x == MIN_64x64) {
      require(
        y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&
          y <= 0x1000000000000000000000000000000000000000000000000
      );
      return -y << 63;
    } else {
      bool negativeResult = false;
      if (x < 0) {
        x = -x;
        negativeResult = true;
      }
      if (y < 0) {
        y = -y; // We rely on overflow behavior here
        negativeResult = !negativeResult;
      }
      uint256 absoluteResult = mulu(x, uint256(y));
      if (negativeResult) {
        require(absoluteResult <= 0x8000000000000000000000000000000000000000000000000000000000000000);
        return -int256(absoluteResult); // We rely on overflow behavior here
      } else {
        require(absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
        return int256(absoluteResult);
      }
    }
  }

  /**
   * Calculate x * y rounding down, where x is signed 64.64 fixed point number
   * and y is unsigned 256-bit integer number.  Revert on overflow.
   *
   * @param x signed 64.64 fixed point number
   * @param y unsigned 256-bit integer number
   * @return unsigned 256-bit integer number
   */
  function mulu(int128 x, uint256 y) internal pure returns (uint256) {
    if (y == 0) return 0;

    require(x >= 0);

    uint256 lo = (uint256(x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;
    uint256 hi = uint256(x) * (y >> 128);

    require(hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
    hi <<= 64;

    require(hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);
    return hi + lo;
  }

  /**
   * Calculate x / y rounding towards zero.  Revert on overflow or when y is
   * zero.
   *
   * @param x signed 64.64-bit fixed point number
   * @param y signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function div(int128 x, int128 y) internal pure returns (int128) {
    require(y != 0);
    int256 result = (int256(x) << 64) / y;
    require(result >= MIN_64x64 && result <= MAX_64x64);
    return int128(result);
  }

  /**
   * Calculate x / y rounding towards zero, where x and y are signed 256-bit
   * integer numbers.  Revert on overflow or when y is zero.
   *
   * @param x signed 256-bit integer number
   * @param y signed 256-bit integer number
   * @return signed 64.64-bit fixed point number
   */
  function divi(int256 x, int256 y) internal pure returns (int128) {
    require(y != 0);

    bool negativeResult = false;
    if (x < 0) {
      x = -x; // We rely on overflow behavior here
      negativeResult = true;
    }
    if (y < 0) {
      y = -y; // We rely on overflow behavior here
      negativeResult = !negativeResult;
    }
    uint128 absoluteResult = divuu(uint256(x), uint256(y));
    if (negativeResult) {
      require(absoluteResult <= 0x80000000000000000000000000000000);
      return -int128(absoluteResult); // We rely on overflow behavior here
    } else {
      require(absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
      return int128(absoluteResult); // We rely on overflow behavior here
    }
  }

  /**
   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit
   * integer numbers.  Revert on overflow or when y is zero.
   *
   * @param x unsigned 256-bit integer number
   * @param y unsigned 256-bit integer number
   * @return signed 64.64-bit fixed point number
   */
  function divu(uint256 x, uint256 y) internal pure returns (int128) {
    require(y != 0);
    uint128 result = divuu(x, y);
    require(result <= uint128(MAX_64x64));
    return int128(result);
  }

  /**
   * Calculate -x.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function neg(int128 x) internal pure returns (int128) {
    require(x != MIN_64x64);
    return -x;
  }

  /**
   * Calculate |x|.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function abs(int128 x) internal pure returns (int128) {
    require(x != MIN_64x64);
    return x < 0 ? -x : x;
  }

  /**
   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is
   * zero.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function inv(int128 x) internal pure returns (int128) {
    require(x != 0);
    int256 result = int256(0x100000000000000000000000000000000) / x;
    require(result >= MIN_64x64 && result <= MAX_64x64);
    return int128(result);
  }

  /**
   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.
   *
   * @param x signed 64.64-bit fixed point number
   * @param y signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function avg(int128 x, int128 y) internal pure returns (int128) {
    return int128((int256(x) + int256(y)) >> 1);
  }

  /**
   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.
   * Revert on overflow or in case x * y is negative.
   *
   * @param x signed 64.64-bit fixed point number
   * @param y signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function gavg(int128 x, int128 y) internal pure returns (int128) {
    int256 m = int256(x) * int256(y);
    require(m >= 0);
    require(m < 0x4000000000000000000000000000000000000000000000000000000000000000);
    return int128(sqrtu(uint256(m)));
  }

  /**
   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number
   * and y is unsigned 256-bit integer number.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @param y uint256 value
   * @return signed 64.64-bit fixed point number
   */
  function pow(int128 x, uint256 y) internal pure returns (int128) {
    bool negative = x < 0 && y & 1 == 1;

    uint256 absX = uint128(x < 0 ? -x : x);
    uint256 absResult;
    absResult = 0x100000000000000000000000000000000;

    if (absX <= 0x10000000000000000) {
      absX <<= 63;
      while (y != 0) {
        if (y & 0x1 != 0) {
          absResult = (absResult * absX) >> 127;
        }
        absX = (absX * absX) >> 127;

        if (y & 0x2 != 0) {
          absResult = (absResult * absX) >> 127;
        }
        absX = (absX * absX) >> 127;

        if (y & 0x4 != 0) {
          absResult = (absResult * absX) >> 127;
        }
        absX = (absX * absX) >> 127;

        if (y & 0x8 != 0) {
          absResult = (absResult * absX) >> 127;
        }
        absX = (absX * absX) >> 127;

        y >>= 4;
      }

      absResult >>= 64;
    } else {
      uint256 absXShift = 63;
      if (absX < 0x1000000000000000000000000) {
        absX <<= 32;
        absXShift -= 32;
      }
      if (absX < 0x10000000000000000000000000000) {
        absX <<= 16;
        absXShift -= 16;
      }
      if (absX < 0x1000000000000000000000000000000) {
        absX <<= 8;
        absXShift -= 8;
      }
      if (absX < 0x10000000000000000000000000000000) {
        absX <<= 4;
        absXShift -= 4;
      }
      if (absX < 0x40000000000000000000000000000000) {
        absX <<= 2;
        absXShift -= 2;
      }
      if (absX < 0x80000000000000000000000000000000) {
        absX <<= 1;
        absXShift -= 1;
      }

      uint256 resultShift = 0;
      while (y != 0) {
        require(absXShift < 64);

        if (y & 0x1 != 0) {
          absResult = (absResult * absX) >> 127;
          resultShift += absXShift;
          if (absResult > 0x100000000000000000000000000000000) {
            absResult >>= 1;
            resultShift += 1;
          }
        }
        absX = (absX * absX) >> 127;
        absXShift <<= 1;
        if (absX >= 0x100000000000000000000000000000000) {
          absX >>= 1;
          absXShift += 1;
        }

        y >>= 1;
      }

      require(resultShift < 64);
      absResult >>= 64 - resultShift;
    }
    int256 result = negative ? -int256(absResult) : int256(absResult);
    require(result >= MIN_64x64 && result <= MAX_64x64);
    return int128(result);
  }

  /**
   * Calculate sqrt (x) rounding down.  Revert if x < 0.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function sqrt(int128 x) internal pure returns (int128) {
    require(x >= 0);
    return int128(sqrtu(uint256(x) << 64));
  }

  /**
   * Calculate binary logarithm of x.  Revert if x <= 0.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function log_2(int128 x) internal pure returns (int128) {
    require(x > 0);

    int256 msb = 0;
    int256 xc = x;
    if (xc >= 0x10000000000000000) {
      xc >>= 64;
      msb += 64;
    }
    if (xc >= 0x100000000) {
      xc >>= 32;
      msb += 32;
    }
    if (xc >= 0x10000) {
      xc >>= 16;
      msb += 16;
    }
    if (xc >= 0x100) {
      xc >>= 8;
      msb += 8;
    }
    if (xc >= 0x10) {
      xc >>= 4;
      msb += 4;
    }
    if (xc >= 0x4) {
      xc >>= 2;
      msb += 2;
    }
    if (xc >= 0x2) msb += 1; // No need to shift xc anymore

    int256 result = (msb - 64) << 64;
    uint256 ux = uint256(x) << uint256(127 - msb);
    for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {
      ux *= ux;
      uint256 b = ux >> 255;
      ux >>= 127 + b;
      result += bit * int256(b);
    }

    return int128(result);
  }

  /**
   * Calculate natural logarithm of x.  Revert if x <= 0.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function ln(int128 x) internal pure returns (int128) {
    require(x > 0);

    return int128((uint256(log_2(x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF) >> 128);
  }

  /**
   * Calculate binary exponent of x.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function exp_2(int128 x) internal pure returns (int128) {
    require(x < 0x400000000000000000); // Overflow

    if (x < -0x400000000000000000) return 0; // Underflow

    uint256 result = 0x80000000000000000000000000000000;

    if (x & 0x8000000000000000 > 0) result = (result * 0x16A09E667F3BCC908B2FB1366EA957D3E) >> 128;
    if (x & 0x4000000000000000 > 0) result = (result * 0x1306FE0A31B7152DE8D5A46305C85EDEC) >> 128;
    if (x & 0x2000000000000000 > 0) result = (result * 0x1172B83C7D517ADCDF7C8C50EB14A791F) >> 128;
    if (x & 0x1000000000000000 > 0) result = (result * 0x10B5586CF9890F6298B92B71842A98363) >> 128;
    if (x & 0x800000000000000 > 0) result = (result * 0x1059B0D31585743AE7C548EB68CA417FD) >> 128;
    if (x & 0x400000000000000 > 0) result = (result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8) >> 128;
    if (x & 0x200000000000000 > 0) result = (result * 0x10163DA9FB33356D84A66AE336DCDFA3F) >> 128;
    if (x & 0x100000000000000 > 0) result = (result * 0x100B1AFA5ABCBED6129AB13EC11DC9543) >> 128;
    if (x & 0x80000000000000 > 0) result = (result * 0x10058C86DA1C09EA1FF19D294CF2F679B) >> 128;
    if (x & 0x40000000000000 > 0) result = (result * 0x1002C605E2E8CEC506D21BFC89A23A00F) >> 128;
    if (x & 0x20000000000000 > 0) result = (result * 0x100162F3904051FA128BCA9C55C31E5DF) >> 128;
    if (x & 0x10000000000000 > 0) result = (result * 0x1000B175EFFDC76BA38E31671CA939725) >> 128;
    if (x & 0x8000000000000 > 0) result = (result * 0x100058BA01FB9F96D6CACD4B180917C3D) >> 128;
    if (x & 0x4000000000000 > 0) result = (result * 0x10002C5CC37DA9491D0985C348C68E7B3) >> 128;
    if (x & 0x2000000000000 > 0) result = (result * 0x1000162E525EE054754457D5995292026) >> 128;
    if (x & 0x1000000000000 > 0) result = (result * 0x10000B17255775C040618BF4A4ADE83FC) >> 128;
    if (x & 0x800000000000 > 0) result = (result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB) >> 128;
    if (x & 0x400000000000 > 0) result = (result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9) >> 128;
    if (x & 0x200000000000 > 0) result = (result * 0x10000162E43F4F831060E02D839A9D16D) >> 128;
    if (x & 0x100000000000 > 0) result = (result * 0x100000B1721BCFC99D9F890EA06911763) >> 128;
    if (x & 0x80000000000 > 0) result = (result * 0x10000058B90CF1E6D97F9CA14DBCC1628) >> 128;
    if (x & 0x40000000000 > 0) result = (result * 0x1000002C5C863B73F016468F6BAC5CA2B) >> 128;
    if (x & 0x20000000000 > 0) result = (result * 0x100000162E430E5A18F6119E3C02282A5) >> 128;
    if (x & 0x10000000000 > 0) result = (result * 0x1000000B1721835514B86E6D96EFD1BFE) >> 128;
    if (x & 0x8000000000 > 0) result = (result * 0x100000058B90C0B48C6BE5DF846C5B2EF) >> 128;
    if (x & 0x4000000000 > 0) result = (result * 0x10000002C5C8601CC6B9E94213C72737A) >> 128;
    if (x & 0x2000000000 > 0) result = (result * 0x1000000162E42FFF037DF38AA2B219F06) >> 128;
    if (x & 0x1000000000 > 0) result = (result * 0x10000000B17217FBA9C739AA5819F44F9) >> 128;
    if (x & 0x800000000 > 0) result = (result * 0x1000000058B90BFCDEE5ACD3C1CEDC823) >> 128;
    if (x & 0x400000000 > 0) result = (result * 0x100000002C5C85FE31F35A6A30DA1BE50) >> 128;
    if (x & 0x200000000 > 0) result = (result * 0x10000000162E42FF0999CE3541B9FFFCF) >> 128;
    if (x & 0x100000000 > 0) result = (result * 0x100000000B17217F80F4EF5AADDA45554) >> 128;
    if (x & 0x80000000 > 0) result = (result * 0x10000000058B90BFBF8479BD5A81B51AD) >> 128;
    if (x & 0x40000000 > 0) result = (result * 0x1000000002C5C85FDF84BD62AE30A74CC) >> 128;
    if (x & 0x20000000 > 0) result = (result * 0x100000000162E42FEFB2FED257559BDAA) >> 128;
    if (x & 0x10000000 > 0) result = (result * 0x1000000000B17217F7D5A7716BBA4A9AE) >> 128;
    if (x & 0x8000000 > 0) result = (result * 0x100000000058B90BFBE9DDBAC5E109CCE) >> 128;
    if (x & 0x4000000 > 0) result = (result * 0x10000000002C5C85FDF4B15DE6F17EB0D) >> 128;
    if (x & 0x2000000 > 0) result = (result * 0x1000000000162E42FEFA494F1478FDE05) >> 128;
    if (x & 0x1000000 > 0) result = (result * 0x10000000000B17217F7D20CF927C8E94C) >> 128;
    if (x & 0x800000 > 0) result = (result * 0x1000000000058B90BFBE8F71CB4E4B33D) >> 128;
    if (x & 0x400000 > 0) result = (result * 0x100000000002C5C85FDF477B662B26945) >> 128;
    if (x & 0x200000 > 0) result = (result * 0x10000000000162E42FEFA3AE53369388C) >> 128;
    if (x & 0x100000 > 0) result = (result * 0x100000000000B17217F7D1D351A389D40) >> 128;
    if (x & 0x80000 > 0) result = (result * 0x10000000000058B90BFBE8E8B2D3D4EDE) >> 128;
    if (x & 0x40000 > 0) result = (result * 0x1000000000002C5C85FDF4741BEA6E77E) >> 128;
    if (x & 0x20000 > 0) result = (result * 0x100000000000162E42FEFA39FE95583C2) >> 128;
    if (x & 0x10000 > 0) result = (result * 0x1000000000000B17217F7D1CFB72B45E1) >> 128;
    if (x & 0x8000 > 0) result = (result * 0x100000000000058B90BFBE8E7CC35C3F0) >> 128;
    if (x & 0x4000 > 0) result = (result * 0x10000000000002C5C85FDF473E242EA38) >> 128;
    if (x & 0x2000 > 0) result = (result * 0x1000000000000162E42FEFA39F02B772C) >> 128;
    if (x & 0x1000 > 0) result = (result * 0x10000000000000B17217F7D1CF7D83C1A) >> 128;
    if (x & 0x800 > 0) result = (result * 0x1000000000000058B90BFBE8E7BDCBE2E) >> 128;
    if (x & 0x400 > 0) result = (result * 0x100000000000002C5C85FDF473DEA871F) >> 128;
    if (x & 0x200 > 0) result = (result * 0x10000000000000162E42FEFA39EF44D91) >> 128;
    if (x & 0x100 > 0) result = (result * 0x100000000000000B17217F7D1CF79E949) >> 128;
    if (x & 0x80 > 0) result = (result * 0x10000000000000058B90BFBE8E7BCE544) >> 128;
    if (x & 0x40 > 0) result = (result * 0x1000000000000002C5C85FDF473DE6ECA) >> 128;
    if (x & 0x20 > 0) result = (result * 0x100000000000000162E42FEFA39EF366F) >> 128;
    if (x & 0x10 > 0) result = (result * 0x1000000000000000B17217F7D1CF79AFA) >> 128;
    if (x & 0x8 > 0) result = (result * 0x100000000000000058B90BFBE8E7BCD6D) >> 128;
    if (x & 0x4 > 0) result = (result * 0x10000000000000002C5C85FDF473DE6B2) >> 128;
    if (x & 0x2 > 0) result = (result * 0x1000000000000000162E42FEFA39EF358) >> 128;
    if (x & 0x1 > 0) result = (result * 0x10000000000000000B17217F7D1CF79AB) >> 128;

    result >>= uint256(63 - (x >> 64));
    require(result <= uint256(MAX_64x64));

    return int128(result);
  }

  /**
   * Calculate natural exponent of x.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function exp(int128 x) internal pure returns (int128) {
    require(x < 0x400000000000000000); // Overflow

    if (x < -0x400000000000000000) return 0; // Underflow

    return exp_2(int128((int256(x) * 0x171547652B82FE1777D0FFDA0D23A7D12) >> 128));
  }

  /**
   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit
   * integer numbers.  Revert on overflow or when y is zero.
   *
   * @param x unsigned 256-bit integer number
   * @param y unsigned 256-bit integer number
   * @return unsigned 64.64-bit fixed point number
   */
  function divuu(uint256 x, uint256 y) private pure returns (uint128) {
    require(y != 0);

    uint256 result;

    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) result = (x << 64) / y;
    else {
      uint256 msb = 192;
      uint256 xc = x >> 192;
      if (xc >= 0x100000000) {
        xc >>= 32;
        msb += 32;
      }
      if (xc >= 0x10000) {
        xc >>= 16;
        msb += 16;
      }
      if (xc >= 0x100) {
        xc >>= 8;
        msb += 8;
      }
      if (xc >= 0x10) {
        xc >>= 4;
        msb += 4;
      }
      if (xc >= 0x4) {
        xc >>= 2;
        msb += 2;
      }
      if (xc >= 0x2) msb += 1; // No need to shift xc anymore

      result = (x << (255 - msb)) / (((y - 1) >> (msb - 191)) + 1);
      require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);

      uint256 hi = result * (y >> 128);
      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);

      uint256 xh = x >> 192;
      uint256 xl = x << 64;

      if (xl < lo) xh -= 1;
      xl -= lo; // We rely on overflow behavior here
      lo = hi << 128;
      if (xl < lo) xh -= 1;
      xl -= lo; // We rely on overflow behavior here

      assert(xh == hi >> 128);

      result += xl / y;
    }

    require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
    return uint128(result);
  }

  /**
   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer
   * number.
   *
   * @param x unsigned 256-bit integer number
   * @return unsigned 128-bit integer number
   */
  function sqrtu(uint256 x) private pure returns (uint128) {
    if (x == 0) return 0;
    else {
      uint256 xx = x;
      uint256 r = 1;
      if (xx >= 0x100000000000000000000000000000000) {
        xx >>= 128;
        r <<= 64;
      }
      if (xx >= 0x10000000000000000) {
        xx >>= 64;
        r <<= 32;
      }
      if (xx >= 0x100000000) {
        xx >>= 32;
        r <<= 16;
      }
      if (xx >= 0x10000) {
        xx >>= 16;
        r <<= 8;
      }
      if (xx >= 0x100) {
        xx >>= 8;
        r <<= 4;
      }
      if (xx >= 0x10) {
        xx >>= 4;
        r <<= 2;
      }
      if (xx >= 0x8) {
        r <<= 1;
      }
      r = (r + x / r) >> 1;
      r = (r + x / r) >> 1;
      r = (r + x / r) >> 1;
      r = (r + x / r) >> 1;
      r = (r + x / r) >> 1;
      r = (r + x / r) >> 1;
      r = (r + x / r) >> 1; // Seven iterations should be enough
      uint256 r1 = x / r;
      return uint128(r < r1 ? r : r1);
    }
  }
}",8578
RealWorld_BA_115_IDemandMiner_RealWord_20240830100813.log,115,IDemandMiner,4939,5282,10221,73.0,0.130335,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IDemandMiner {
  function deposit(uint256 amount) external;

  function withdraw(uint256 amount) external;

  function token() external view returns (IERC20);
}",78
RealWorld_BA_115_IRatesManager_RealWord_20240830114209.log,115,IRatesManager,6638,4512,11150,72.0,0.12343,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../interfaces/IAddressProvider.sol"";

interface IRatesManager {
  function a() external view returns (IAddressProvider);

  //current annualized borrow rate
  function annualizedBorrowRate(uint256 _currentBorrowRate) external pure returns (uint256);

  //uses current cumulative rate to calculate totalDebt based on baseDebt at time T0
  function calculateDebt(uint256 _baseDebt, uint256 _cumulativeRate) external pure returns (uint256);

  //uses current cumulative rate to calculate baseDebt at time T0
  function calculateBaseDebt(uint256 _debt, uint256 _cumulativeRate) external pure returns (uint256);

  //calculate a new cumulative rate
  function calculateCumulativeRate(
    uint256 _borrowRate,
    uint256 _cumulativeRate,
    uint256 _timeElapsed
  ) external view returns (uint256);
}",215
RealWorld_BA_115_IFeeDistributorV1_RealWord_20240830091636.log,115,IFeeDistributorV1,5916,5474,11390,68.0,0.13906,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""./IAddressProviderV1.sol"";

interface IFeeDistributorV1 {
  event PayeeAdded(address indexed account, uint256 shares);
  event FeeReleased(uint256 income, uint256 releasedAt);

  function release() external;

  function changePayees(address[] memory _payees, uint256[] memory _shares) external;

  function a() external view returns (IAddressProviderV1);

  function lastReleasedAt() external view returns (uint256);

  function getPayees() external view returns (address[] memory);

  function totalShares() external view returns (uint256);

  function shares(address payee) external view returns (uint256);
}",154
RealWorld_BA_115_IInceptionVaultsCore_RealWord_20240830104501.log,115,IInceptionVaultsCore,13563,6553,20116,88.0,0.198875,"//SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import ""./IInceptionVaultsDataProvider.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../../interfaces/IAddressProvider.sol"";
import ""./IAdminInceptionVault.sol"";
import ""./IInceptionVaultPriceFeed.sol"";

interface IInceptionVaultsCore {
  struct VaultConfig {
    uint256 liquidationRatio;
    uint256 minCollateralRatio;
    uint256 borrowRate;
    uint256 originationFee;
    uint256 liquidationBonus;
    uint256 liquidationFee;
  }

  event Deposited(uint256 indexed vaultId, uint256 amount, address indexed sender);

  event Withdrawn(uint256 indexed vautlId, uint256 amount, address indexed sender);

  event CumulativeRateUpdated(uint256 elapsedTime, uint256 newCumulativeRate);

  event Borrowed(uint256 indexed vaultId, uint256 amount, address indexed sender);

  event Repaid(uint256 indexed vaultId, uint256 amount, address indexed sender);

  event Liquidated(
    uint256 indexed vaultId,
    uint256 debtRepaid,
    uint256 collateralLiquidated,
    address indexed owner,
    address indexed sender
  );

  function initialize(
    address _owner,
    VaultConfig calldata vaultConfig,
    IERC20 _inceptionCollateral,
    IAddressProvider _addressProvider,
    IAdminInceptionVault _adminInceptionVault,
    IInceptionVaultsDataProvider _inceptionVaultsDataProvider,
    IInceptionVaultPriceFeed _inceptionPriceFeed
  ) external;

  function deposit(uint256 _amount) external;

  function depositByVaultId(uint256 _vaultId, uint256 _amount) external;

  function depositAndBorrow(uint256 _depositAmount, uint256 _borrowAmount) external;

  function withdraw(uint256 _vaultId, uint256 _amount) external;

  function borrow(uint256 _vaultId, uint256 _amount) external;

  function repayAll(uint256 _vaultId) external;

  function repay(uint256 _vaultId, uint256 _amount) external;

  function liquidate(uint256 _vaultId) external;

  function liquidatePartial(uint256 _vaultId, uint256 _amount) external;

  // Read only
  function a() external view returns (IAddressProvider);

  function cumulativeRate() external view returns (uint256);

  function lastRefresh() external view returns (uint256);

  function vaultConfig() external view returns (VaultConfig memory);

  function adminInceptionVault() external view returns (IAdminInceptionVault);

  function inceptionVaultsData() external view returns (IInceptionVaultsDataProvider);

  function inceptionCollateral() external view returns (IERC20);

  function inceptionPriceFeed() external view returns (IInceptionVaultPriceFeed);
}",603
RealWorld_BA_115_IGovernanceAddressProvider_RealWord_20240830115754.log,115,IGovernanceAddressProvider,3732,3697,7429,69.0,0.0926,"// SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;

pragma solidity 0.8.10;

import ""./IMIMO.sol"";

interface IGovernanceAddressProvider {
  function mimo() external view returns (IMIMO);
}",50
RealWorld_BA_115_AddressProviderV1_RealWord_20240830091405.log,115,AddressProviderV1,13590,5061,18651,69.0,0.16917,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/IVaultsCore.sol"";
import ""../interfaces/IAccessController.sol"";
import ""../interfaces/IConfigProvider.sol"";
import ""../interfaces/ISTABLEX.sol"";
import ""../interfaces/IPriceFeed.sol"";
import ""../interfaces/IRatesManager.sol"";
import ""../interfaces/IVaultsDataProvider.sol"";
import ""./interfaces/IConfigProviderV1.sol"";
import ""./interfaces/ILiquidationManagerV1.sol"";
import ""./interfaces/IVaultsCoreV1.sol"";

contract AddressProviderV1 is IAddressProvider {
  IAccessController public override controller;
  IConfigProvider public override config;
  IVaultsCore public override core;

  ISTABLEX public override stablex;
  IRatesManager public override ratesManager;
  IPriceFeed public override priceFeed;
  ILiquidationManager public override liquidationManager;
  IVaultsDataProvider public override vaultsData;
  IFeeDistributor public override feeDistributor;

  constructor(IAccessController _controller) public {
    controller = _controller;
  }

  modifier onlyManager() {
    require(controller.hasRole(controller.MANAGER_ROLE(), msg.sender), ""Caller is not a Manager"");
    _;
  }

  function setAccessController(IAccessController _controller) public override onlyManager {
    require(address(_controller) != address(0));
    controller = _controller;
  }

  function setConfigProvider(IConfigProvider _config) public override onlyManager {
    require(address(_config) != address(0));
    config = _config;
  }

  function setVaultsCore(IVaultsCore _core) public override onlyManager {
    require(address(_core) != address(0));
    core = _core;
  }

  function setStableX(ISTABLEX _stablex) public override onlyManager {
    require(address(_stablex) != address(0));
    stablex = _stablex;
  }

  function setRatesManager(IRatesManager _ratesManager) public override onlyManager {
    require(address(_ratesManager) != address(0));
    ratesManager = _ratesManager;
  }

  function setLiquidationManager(ILiquidationManager _liquidationManager) public override onlyManager {
    require(address(_liquidationManager) != address(0));
    liquidationManager = _liquidationManager;
  }

  function setPriceFeed(IPriceFeed _priceFeed) public override onlyManager {
    require(address(_priceFeed) != address(0));
    priceFeed = _priceFeed;
  }

  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) public override onlyManager {
    require(address(_vaultsData) != address(0));
    vaultsData = _vaultsData;
  }

  function setFeeDistributor(IFeeDistributor _feeDistributor) public override onlyManager {
    require(address(_feeDistributor) != address(0));
    feeDistributor = _feeDistributor;
  }
}",640
RealWorld_BA_115_IGenericMiner_RealWord_20240830120321.log,115,IGenericMiner,4596,4794,9390,66.0,0.11886,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.8.10;

import ""./IGovernanceAddressProvider.sol"";

interface IGenericMiner {
  function a() external view returns (IGovernanceAddressProvider);

  function releaseMIMO(address _user) external;
}",65
RealWorld_BA_115_IPriceFeed_RealWord_20240830120119.log,115,IPriceFeed,5184,4525,9709,62.0,0.11642,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.10;

interface IPriceFeed {
  event OracleUpdated(address indexed asset, address oracle, address sender);
  event EurOracleUpdated(address oracle, address sender);

  function setAssetOracle(address _asset, address _oracle) external;

  function setEurOracle(address _oracle) external;

  function getAssetPrice(address _asset) external view returns (uint256);

  function convertFrom(address _asset, uint256 _amount) external view returns (uint256);

  function convertTo(address _asset, uint256 _amount) external view returns (uint256);
}",130
RealWorld_BA_115_ILiquidationManager_RealWord_20240830113316.log,115,ILiquidationManager,6360,5034,11394,83.0,0.13248,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../interfaces/IAddressProvider.sol"";

interface ILiquidationManager {
  function a() external view returns (IAddressProvider);

  function calculateHealthFactor(
    uint256 _collateralValue,
    uint256 _vaultDebt,
    uint256 _minRatio
  ) external view returns (uint256 healthFactor);

  function liquidationBonus(address _collateralType, uint256 _amount) external view returns (uint256 bonus);

  function applyLiquidationDiscount(address _collateralType, uint256 _amount)
    external
    view
    returns (uint256 discountedAmount);

  function isHealthy(
    uint256 _collateralValue,
    uint256 _vaultDebt,
    uint256 _minRatio
  ) external view returns (bool);
}",182
RealWorld_BA_115_IBaseDistributor_RealWord_20240830100658.log,115,IBaseDistributor,7622,5385,13007,73.0,0.14581,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../../governance/interfaces/IGovernanceAddressProvider.sol"";

interface IBaseDistributor {
  event PayeeAdded(address account, uint256 shares);
  event TokensReleased(uint256 newTokens, uint256 releasedAt);

  /**
    Public function to release the accumulated new MIMO tokens to the payees.
    @dev anyone can call this.
  */
  function release() external;

  /**
    Updates the payee configuration to a new one.
    @dev will release existing fees before the update.
    @param _payees Array of payees
    @param _shares Array of shares for each payee
  */
  function changePayees(address[] memory _payees, uint256[] memory _shares) external;

  function totalShares() external view returns (uint256);

  function shares(address) external view returns (uint256);

  function a() external view returns (IGovernanceAddressProvider);

  function mintableTokens() external view returns (uint256);

  /**
    Get current configured payees.
    @return array of current payees.
  */
  function getPayees() external view returns (address[] memory);
}",261
RealWorld_BA_115_IRootChainManager_RealWord_20240830110225.log,115,IRootChainManager,5586,5393,10979,76.0,0.13579,"pragma solidity 0.6.12;

interface IRootChainManager {
  event TokenMapped(address indexed rootToken, address indexed childToken, bytes32 indexed tokenType);

  event PredicateRegistered(bytes32 indexed tokenType, address indexed predicateAddress);

  function registerPredicate(bytes32 tokenType, address predicateAddress) external;

  function mapToken(
    address rootToken,
    address childToken,
    bytes32 tokenType
  ) external;

  function depositEtherFor(address user) external payable;

  function depositFor(
    address user,
    address rootToken,
    bytes calldata depositData
  ) external;

  function exit(bytes calldata inputData) external;
}",137
RealWorld_BA_115_IDebtNotifier_RealWord_20240830101054.log,115,IDebtNotifier,4949,4412,9361,70.0,0.112985,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../../governance/interfaces/IGovernanceAddressProvider.sol"";
import ""./ISupplyMiner.sol"";

interface IDebtNotifier {
  function debtChanged(uint256 _vaultId) external;

  function setCollateralSupplyMiner(address collateral, ISupplyMiner supplyMiner) external;

  function a() external view returns (IGovernanceAddressProvider);

  function collateralSupplyMinerMapping(address collateral) external view returns (ISupplyMiner);
}",119
RealWorld_BA_115_IDexAddressProvider_RealWord_20240830112051.log,115,IDexAddressProvider,5181,5003,10184,74.0,0.125965,"// SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../../interfaces/IAddressProvider.sol"";

interface IDexAddressProvider {
  event DexSet(uint8);

  struct Dex {
    address proxy;
    address router;
  }

  function setDexMapping(
    uint256 _index,
    address _proxy,
    address _dex
  ) external;

  function parallel() external view returns (IAddressProvider);

  function dexMapping(uint256 index) external view returns (address, address);
}",115
RealWorld_BA_115_DebtNotifier_RealWord_20240830094523.log,115,DebtNotifier,10728,5502,16230,86.0,0.16368,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../governance/interfaces/IGovernanceAddressProvider.sol"";
import ""./interfaces/ISupplyMiner.sol"";
import ""../interfaces/IVaultsDataProvider.sol"";

contract DebtNotifier is IDebtNotifier {
  IGovernanceAddressProvider public override a;
  mapping(address => ISupplyMiner) public override collateralSupplyMinerMapping;

  constructor(IGovernanceAddressProvider _addresses) public {
    require(address(_addresses) != address(0));
    a = _addresses;
  }

  modifier onlyVaultsCore() {
    require(msg.sender == address(a.parallel().core()), ""Caller is not VaultsCore"");
    _;
  }

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender));
    _;
  }

  /**
    Notifies the correct supplyMiner of a change in debt.
    @dev Only the vaultsCore can call this.
    `debtChanged` will silently return if collateralType is not known to prevent any problems in vaultscore.
    @param _vaultId the ID of the vault of which the debt has changed.
  **/
  function debtChanged(uint256 _vaultId) public override onlyVaultsCore {
    IVaultsDataProvider.Vault memory v = a.parallel().vaultsData().vaults(_vaultId);

    ISupplyMiner supplyMiner = collateralSupplyMinerMapping[v.collateralType];
    if (address(supplyMiner) == address(0)) {
      // not throwing error so VaultsCore keeps working
      return;
    }
    supplyMiner.baseDebtChanged(v.owner, v.baseDebt);
  }

  /**
    Updates the collateral to supplyMiner mapping.
    @dev Manager role in the AccessController is required to call this.
    @param collateral the address of the collateralType.
    @param supplyMiner the address of the supplyMiner which will be notified on debt changes for this collateralType.
  **/
  function setCollateralSupplyMiner(address collateral, ISupplyMiner supplyMiner) public override onlyManager {
    collateralSupplyMinerMapping[collateral] = supplyMiner;
  }
}",471
RealWorld_BA_115_FeeDistributor_RealWord_20240830103410.log,115,FeeDistributor,18089,5448,23537,80.0,0.199405,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"";
import ""../libraries/WadRayMath.sol"";
import ""../interfaces/ISTABLEX.sol"";
import ""../interfaces/IFeeDistributor.sol"";
import ""../interfaces/IAddressProvider.sol"";

contract FeeDistributor is IFeeDistributor, ReentrancyGuard {
  using SafeMath for uint256;

  event PayeeAdded(address account, uint256 shares);
  event FeeReleased(uint256 income, uint256 releasedAt);

  uint256 public override lastReleasedAt;
  IAddressProvider public override a;

  uint256 public override totalShares;
  mapping(address => uint256) public override shares;
  address[] public payees;

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), ""Caller is not Manager"");
    _;
  }

  constructor(IAddressProvider _addresses) public {
    require(address(_addresses) != address(0));
    a = _addresses;
  }

  /**
    Public function to release the accumulated fee income to the payees.
    @dev anyone can call this.
  */
  function release() public override nonReentrant {
    uint256 income = a.core().state().availableIncome();
    require(income > 0, ""income is 0"");
    require(payees.length > 0, ""Payees not configured yet"");
    lastReleasedAt = now;

    // Mint USDX to all receivers
    for (uint256 i = 0; i < payees.length; i++) {
      address payee = payees[i];
      _release(income, payee);
    }
    emit FeeReleased(income, lastReleasedAt);
  }

  /**
    Updates the payee configuration to a new one.
    @dev will release existing fees before the update.
    @param _payees Array of payees
    @param _shares Array of shares for each payee
  */
  function changePayees(address[] memory _payees, uint256[] memory _shares) public override onlyManager {
    require(_payees.length == _shares.length, ""Payees and shares mismatched"");
    require(_payees.length > 0, ""No payees"");

    uint256 income = a.core().state().availableIncome();
    if (income > 0 && payees.length > 0) {
      release();
    }

    for (uint256 i = 0; i < payees.length; i++) {
      delete shares[payees[i]];
    }
    delete payees;
    totalShares = 0;

    for (uint256 i = 0; i < _payees.length; i++) {
      _addPayee(_payees[i], _shares[i]);
    }
  }

  /**
    Get current configured payees.
    @return array of current payees.
  */
  function getPayees() public view override returns (address[] memory) {
    return payees;
  }

  /**
    Internal function to release a percentage of income to a specific payee
    @dev uses totalShares to calculate correct share
    @param _totalIncomeReceived Total income for all payees, will be split according to shares
    @param _payee The address of the payee to whom to distribute the fees.
  */
  function _release(uint256 _totalIncomeReceived, address _payee) internal {
    uint256 payment = _totalIncomeReceived.mul(shares[_payee]).div(totalShares);
    a.stablex().mint(_payee, payment);
  }

  /**
    Internal function to add a new payee.
    @dev will update totalShares and therefore reduce the relative share of all other payees.
    @param _payee The address of the payee to add.
    @param _shares The number of shares owned by the payee.
  */
  function _addPayee(address _payee, uint256 _shares) internal {
    require(_payee != address(0), ""payee is the zero address"");
    require(_shares > 0, ""shares are 0"");
    require(shares[_payee] == 0, ""payee already has shares"");

    payees.push(_payee);
    shares[_payee] = _shares;
    totalShares = totalShares.add(_shares);
    emit PayeeAdded(_payee, _shares);
  }
}",952
RealWorld_BA_115_AdminInceptionVault_RealWord_20240830103704.log,115,AdminInceptionVault,33262,5671,38933,68.0,0.27973,"//SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/proxy/Initializable.sol"";

import ""./BoringOwnable.sol"";
import ""./interfaces/IAdminInceptionVault.sol"";
import ""./interfaces/IInceptionVaultsCore.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/IVaultsDataProvider.sol"";
import ""../interfaces/IWETH.sol"";
import ""../liquidityMining/interfaces/IDebtNotifier.sol"";
import ""../liquidityMining/interfaces/IGenericMiner.sol"";

contract AdminInceptionVault is IAdminInceptionVault, BoringOwnable, Initializable {
  using SafeERC20 for IERC20;

  IAddressProvider private _a;
  IDebtNotifier private _debtNotifier;
  IWETH private _weth;
  IERC20 private _mimo;
  IInceptionVaultsCore private _inceptionCore;

  uint8 private _collateralCount;
  mapping(uint8 => address) private _collaterals;
  mapping(address => uint8) private _collateralId;

  modifier onlyInceptionVaultsCore() {
    require(address(_inceptionCore) == msg.sender, ""IV011"");
    _;
  }

  function initialize(
    address _owner,
    IAddressProvider addressProvider,
    IDebtNotifier debtNotifier,
    IWETH weth,
    IERC20 mimo,
    IInceptionVaultsCore inceptionVaultsCore
  ) external override initializer {
    _a = addressProvider;
    _debtNotifier = debtNotifier;
    _weth = weth;
    _mimo = mimo;
    _inceptionCore = inceptionVaultsCore;
    owner = _owner;
  }

  /**
    Wraps ETH and deposits WETH into the vault of the msg.sender as collateral
    @dev A new vault is created if no WETH vault exists
  **/
  function depositETH() external payable override onlyOwner {
    _a.core().depositETH{ value: msg.value }();
  }

  /**
    Wraps ETH and deposits WETH into the vault of the msg.sender as collateral and borrows the specified amount of tokens in WEI
    @dev see depositETH() and borrow()
    @param _borrowAmount the amount of borrowed StableX tokens in WEI.
  **/
  function depositETHAndBorrow(uint256 _borrowAmount) external payable override onlyOwner {
    _a.core().depositETHAndBorrow{ value: msg.value }(_borrowAmount);
  }

  /**
    Deposit an ERC20 token into the vault of the msg.sender as collateral and borrows the specified amount of tokens in WEI
    @dev see deposit() and borrow()
    @param _collateralType the address of the collateral type to be deposited
    @param _depositAmount the amount of tokens to be deposited in WEI.
    @param _borrowAmount the amount of borrowed StableX tokens in WEI.
  **/
  function depositAndBorrow(
    address _collateralType,
    uint256 _depositAmount,
    uint256 _borrowAmount
  ) external override onlyOwner {
    IERC20 asset = IERC20(_collateralType);
    asset.safeTransferFrom(msg.sender, address(this), _depositAmount);
    asset.safeIncreaseAllowance(address(_a.core()), _depositAmount);
    _a.core().depositAndBorrow(_collateralType, _depositAmount, _borrowAmount);
    if (_collateralId[_collateralType] == 0) {
      uint8 newId = ++_collateralCount;
      _collateralId[_collateralType] = newId;
      _collaterals[newId] = _collateralType;
    }
  }

  /**
    Withdraws ERC20 tokens from a vault.
    @dev Only the owner of a vault can withdraw collateral from it.
    `withdraw()` will fail if it would bring the vault below the minimum collateralization treshold.
    @param _vaultId the ID of the vault from which to withdraw the collateral.
    @param _amount the amount of ERC20 tokens to be withdrawn in WEI.
  **/
  function withdraw(uint256 _vaultId, uint256 _amount) external override onlyOwner {
    _a.core().withdraw(_vaultId, _amount);
    IERC20 asset = IERC20(_a.vaultsData().vaultCollateralType(_vaultId));
    asset.safeTransfer(msg.sender, _amount);
  }

  /**
    Releases the outstanding MIMO balance.
  */
  function claimMimo() external override {
    for (uint8 i = 1; i < _collateralCount + 1; i++) {
      IGenericMiner supplyMiner = IGenericMiner(address(_debtNotifier.collateralSupplyMinerMapping(_collaterals[i])));
      if (supplyMiner.pendingMIMO(address(this)) != 0) {
        supplyMiner.releaseMIMO(address(this));
      }
    }
  }

  /**
    Lends PAR to inceptionVault user. 
    @dev This function cn only be called by the InceptionVaultsCore.
    @param _amount the amount of PAR to be lended.
    @param _to the address of the inceptionVault user.
  */
  function lendPAR(uint256 _amount, address _to) external override onlyInceptionVaultsCore() {
    IERC20 stablex = IERC20(_a.stablex());
    stablex.safeTransfer(_to, _amount);
  }

  /**
    @dev See {IERC20-transfer}.
  */
  function transferMimo(uint256 _amount, address _to) external override onlyOwner {
    _mimo.safeTransfer(_to, _amount);
  }

  /**
    @dev See {IERC20-transfer}.
  */
  function transferPar(uint256 _amount, address _to) external override onlyOwner {
    IERC20 par = IERC20(address(_a.stablex()));
    par.safeTransfer(_to, _amount);
  }

  /**
    Deposit an ERC20 token into the vault of the msg.sender as collateral
    @dev A new vault is created if no vault exists for the `msg.sender` with the specified collateral type.
    this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.
    @param _collateralType the address of the collateral type to be deposited
    @param _amount the amount of tokens to be deposited in WEI.
  **/
  function deposit(address _collateralType, uint256 _amount) public override onlyOwner {
    IERC20 asset = IERC20(_collateralType);
    asset.safeTransferFrom(msg.sender, address(this), _amount);
    asset.safeIncreaseAllowance(address(_a.core()), _amount);
    _a.core().deposit(_collateralType, _amount);
  }

  /**
    Borrow new PAR tokens from a vault.
    @dev Only the owner of a vault can borrow from it.
    `borrow()` will update the outstanding vault debt to the current time before attempting the withdrawal.
     `borrow()` will fail if it would bring the vault below the minimum collateralization treshold.
    @param _vaultId the ID of the vault from which to borrow.
    @param _amount the amount of borrowed PAR tokens in WEI.
  **/
  function borrow(uint256 _vaultId, uint256 _amount) public override onlyOwner {
    _a.core().borrow(_vaultId, _amount);
    IVaultsDataProvider vaultsData = IVaultsDataProvider(_a.vaultsData());
    address vaultCollateral = vaultsData.vaultCollateralType(_vaultId);
    if (_collateralId[vaultCollateral] == 0) {
      uint8 newId = ++_collateralCount;
      _collateralId[vaultCollateral] = newId;
      _collaterals[newId] = vaultCollateral;
    }
  }

  function a() public view override returns (IAddressProvider) {
    return _a;
  }

  function debtNotifier() public view override returns (IDebtNotifier) {
    return _debtNotifier;
  }

  function weth() public view override returns (IWETH) {
    return _weth;
  }

  function mimo() public view override returns (IERC20) {
    return _mimo;
  }

  function inceptionCore() public view override returns (IInceptionVaultsCore) {
    return _inceptionCore;
  }

  function collateralCount() public view override returns (uint8) {
    return _collateralCount;
  }

  function collaterals(uint8 _id) public view override returns (address) {
    return _collaterals[_id];
  }

  function collateralId(address _collateral) public view override returns (uint8) {
    return _collateralId[_collateral];
  }
}",1894
RealWorld_BA_115_DexAddressProvider_RealWord_20240830111927.log,115,DexAddressProvider,10464,5370,15834,82.0,0.15972,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""./interfaces/IDexAddressProvider.sol"";
import ""../interfaces/IAddressProvider.sol"";

contract DexAddressProvider is IDexAddressProvider {
  IAddressProvider private _a;
  mapping(uint256 => Dex) private _dexMapping;

  constructor(IAddressProvider a, Dex[] memory dexes) public {
    require(address(a) != address(0), ""LM000"");
    _a = a;
    for (uint256 i; i < dexes.length; i++) {
      _dexMapping[i] = Dex({ proxy: dexes[i].proxy, router: dexes[i].router });
    }
  }

  modifier onlyManager() {
    require(_a.controller().hasRole(_a.controller().MANAGER_ROLE(), msg.sender), ""LM010"");
    _;
  }

  /**
    Set the dex address for dexMapping
    @dev only manager or address(this) can call this method.
    @param _index the index for the dex.
    @param _proxy the address for the proxy.
    @param _router the address for the router.
  */
  function setDexMapping(
    uint256 _index,
    address _proxy,
    address _router
  ) external override onlyManager {
    require(_proxy != address(0), ""LM000"");
    require(_router != address(0), ""LM000"");
    _dexMapping[_index] = Dex({ proxy: _proxy, router: _router });
  }

  function parallel() public view override returns (IAddressProvider) {
    return _a;
  }

  /** 
    Returns proxy and router address for a specific dex index
    @param index the index for the dex
    @return (proxy address, router address)
  */
  function dexMapping(uint256 index) public view override returns (address, address) {
    return (_dexMapping[index].proxy, _dexMapping[index].router);
  }
}",419
RealWorld_BA_115_ConfigProviderV1_RealWord_20240830090643.log,115,ConfigProviderV1,34091,5869,39960,79.0,0.287835,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../libraries/WadRayMath.sol"";
import ""./interfaces/IConfigProviderV1.sol"";
import ""./interfaces/IAddressProviderV1.sol"";
import ""./interfaces/IVaultsCoreV1.sol"";

contract ConfigProviderV1 is IConfigProviderV1 {
  IAddressProviderV1 public override a;

  mapping(uint256 => CollateralConfig) private _collateralConfigs; //indexing starts at 1
  mapping(address => uint256) public override collateralIds;

  uint256 public override numCollateralConfigs;
  uint256 public override liquidationBonus = 5e16; // 5%

  constructor(IAddressProviderV1 _addresses) public {
    a = _addresses;
  }

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), ""Caller is not a Manager"");
    _;
  }

  /**
    Creates or overwrites an existing config for a collateral type
    @param _collateralType address of the collateral type
    @param _debtLimit the debt ceiling for the collateral type
    @param _minCollateralRatio the minimum ratio to maintain to avoid liquidation
    @param _borrowRate the borrowing rate specified in 1 second interval in RAY accuracy.
    @param _originationFee an optional origination fee for newly created debt. Can be 0.
  */
  function setCollateralConfig(
    address _collateralType,
    uint256 _debtLimit,
    uint256 _minCollateralRatio,
    uint256 _borrowRate,
    uint256 _originationFee
  ) public override onlyManager {
    require(address(_collateralType) != address(0));
    if (collateralIds[_collateralType] == 0) {
      //new collateral
      IVaultsCoreV1(address(a.core())).initializeRates(_collateralType);
      CollateralConfig memory config = CollateralConfig({
        collateralType: _collateralType,
        debtLimit: _debtLimit,
        minCollateralRatio: _minCollateralRatio,
        borrowRate: _borrowRate,
        originationFee: _originationFee
      });

      numCollateralConfigs++;
      _collateralConfigs[numCollateralConfigs] = config;
      collateralIds[_collateralType] = numCollateralConfigs;
    } else {
      // Update collateral config
      IVaultsCoreV1(address(a.core())).refreshCollateral(_collateralType);
      uint256 id = collateralIds[_collateralType];

      _collateralConfigs[id].collateralType = _collateralType;
      _collateralConfigs[id].debtLimit = _debtLimit;
      _collateralConfigs[id].minCollateralRatio = _minCollateralRatio;
      _collateralConfigs[id].borrowRate = _borrowRate;
      _collateralConfigs[id].originationFee = _originationFee;
    }
    emit CollateralUpdated(_collateralType, _debtLimit, _minCollateralRatio, _borrowRate, _originationFee);
  }

  function _emitUpdateEvent(address _collateralType) internal {
    emit CollateralUpdated(
      _collateralType,
      _collateralConfigs[collateralIds[_collateralType]].debtLimit,
      _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio,
      _collateralConfigs[collateralIds[_collateralType]].borrowRate,
      _collateralConfigs[collateralIds[_collateralType]].originationFee
    );
  }

  /**
    Remove the config for a collateral type
    @param _collateralType address of the collateral type
  */
  function removeCollateral(address _collateralType) public override onlyManager {
    uint256 id = collateralIds[_collateralType];
    require(id != 0, ""collateral does not exist"");

    collateralIds[_collateralType] = 0;

    _collateralConfigs[id] = _collateralConfigs[numCollateralConfigs]; //move last entry forward
    collateralIds[_collateralConfigs[id].collateralType] = id; //update id for last entry
    delete _collateralConfigs[numCollateralConfigs];
    numCollateralConfigs--;

    emit CollateralRemoved(_collateralType);
  }

  /**
    Sets the debt limit for a collateral type
    @param _collateralType address of the collateral type
    @param _debtLimit the new debt limit
  */
  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) public override onlyManager {
    _collateralConfigs[collateralIds[_collateralType]].debtLimit = _debtLimit;
    _emitUpdateEvent(_collateralType);
  }

  /**
    Sets the minimum collateralization ratio for a collateral type
    @dev this is the liquidation treshold under which a vault is considered open for liquidation.
    @param _collateralType address of the collateral type
    @param _minCollateralRatio the new minimum collateralization ratio
  */
  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio)
    public
    override
    onlyManager
  {
    _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio = _minCollateralRatio;
    _emitUpdateEvent(_collateralType);
  }

  /**
    Sets the borrowing rate for a collateral type
    @dev borrowing rate is specified for a 1 sec interval and accurancy is in RAY.
    @param _collateralType address of the collateral type
    @param _borrowRate the new borrowing rate for a 1 sec interval
  */
  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) public override onlyManager {
    IVaultsCoreV1(address(a.core())).refreshCollateral(_collateralType);
    _collateralConfigs[collateralIds[_collateralType]].borrowRate = _borrowRate;
    _emitUpdateEvent(_collateralType);
  }

  /**
    Sets the origiation fee for a collateral type
    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD
    @param _collateralType address of the collateral type
    @param _originationFee new origination fee in WAD
  */
  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) public override onlyManager {
    _collateralConfigs[collateralIds[_collateralType]].originationFee = _originationFee;
    _emitUpdateEvent(_collateralType);
  }

  /**
    Get the debt limit for a collateral type
    @dev this is a platform wide limit for new debt issuance against a specific collateral type
    @param _collateralType address of the collateral type
  */
  function collateralDebtLimit(address _collateralType) public view override returns (uint256) {
    return _collateralConfigs[collateralIds[_collateralType]].debtLimit;
  }

  /**
    Get the minimum collateralization ratio for a collateral type
    @dev this is the liquidation treshold under which a vault is considered open for liquidation.
    @param _collateralType address of the collateral type
  */
  function collateralMinCollateralRatio(address _collateralType) public view override returns (uint256) {
    return _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio;
  }

  /**
    Get the borrowing rate for a collateral type
    @dev borrowing rate is specified for a 1 sec interval and accurancy is in RAY.
    @param _collateralType address of the collateral type
  */
  function collateralBorrowRate(address _collateralType) public view override returns (uint256) {
    return _collateralConfigs[collateralIds[_collateralType]].borrowRate;
  }

  /**
    Get the origiation fee for a collateral type
    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD
    @param _collateralType address of the collateral type
  */
  function collateralOriginationFee(address _collateralType) public view override returns (uint256) {
    return _collateralConfigs[collateralIds[_collateralType]].originationFee;
  }

  /**
    Set the platform wide incentive for liquidations.
    @dev the liquidation bonus is specified in WAD
    @param _bonus the liquidation bonus to be paid to liquidators
  */
  function setLiquidationBonus(uint256 _bonus) public override onlyManager {
    liquidationBonus = _bonus;
  }

  /**
    Retreives the entire config for a specific config id.
    @param _id the ID of the conifg to be returned
  */
  function collateralConfigs(uint256 _id) public view override returns (CollateralConfig memory) {
    require(_id <= numCollateralConfigs, ""Invalid config id"");
    return _collateralConfigs[_id];
  }
}",1938
RealWorld_BA_115_IGovernorAlpha_RealWord_20240830111453.log,115,IGovernorAlpha,16933,6291,23224,91.0,0.210485,"// SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

interface IGovernorAlpha {
  /// @notice Possible states that a proposal may be in
  enum ProposalState { Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed }

  struct Proposal {
    // Unique id for looking up a proposal
    uint256 id;
    // Creator of the proposal
    address proposer;
    // The timestamp that the proposal will be available for execution, set once the vote succeeds
    uint256 eta;
    // the ordered list of target addresses for calls to be made
    address[] targets;
    // The ordered list of values (i.e. msg.value) to be passed to the calls to be made
    uint256[] values;
    // The ordered list of function signatures to be called
    string[] signatures;
    // The ordered list of calldata to be passed to each call
    bytes[] calldatas;
    // The timestamp at which voting begins: holders must delegate their votes prior to this timestamp
    uint256 startTime;
    // The timestamp at which voting ends: votes must be cast prior to this timestamp
    uint256 endTime;
    // Current number of votes in favor of this proposal
    uint256 forVotes;
    // Current number of votes in opposition to this proposal
    uint256 againstVotes;
    // Flag marking whether the proposal has been canceled
    bool canceled;
    // Flag marking whether the proposal has been executed
    bool executed;
    // Receipts of ballots for the entire set of voters
    mapping(address => Receipt) receipts;
  }

  /// @notice Ballot receipt record for a voter
  struct Receipt {
    // Whether or not a vote has been cast
    bool hasVoted;
    // Whether or not the voter supports the proposal
    bool support;
    // The number of votes the voter had, which were cast
    uint256 votes;
  }

  /// @notice An event emitted when a new proposal is created
  event ProposalCreated(
    uint256 id,
    address proposer,
    address[] targets,
    uint256[] values,
    string[] signatures,
    bytes[] calldatas,
    uint256 startTime,
    uint256 endTime,
    string description
  );

  /// @notice An event emitted when a vote has been cast on a proposal
  event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);

  /// @notice An event emitted when a proposal has been canceled
  event ProposalCanceled(uint256 id);

  /// @notice An event emitted when a proposal has been queued in the Timelock
  event ProposalQueued(uint256 id, uint256 eta);

  /// @notice An event emitted when a proposal has been executed in the Timelock
  event ProposalExecuted(uint256 id);

  function propose(
    address[] memory targets,
    uint256[] memory values,
    string[] memory signatures,
    bytes[] memory calldatas,
    string memory description,
    uint256 endTime
  ) external returns (uint256);

  function queue(uint256 proposalId) external;

  function execute(uint256 proposalId) external payable;

  function cancel(uint256 proposalId) external;

  function castVote(uint256 proposalId, bool support) external;

  function getActions(uint256 proposalId)
    external
    view
    returns (
      address[] memory targets,
      uint256[] memory values,
      string[] memory signatures,
      bytes[] memory calldatas
    );

  function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory);

  function state(uint256 proposalId) external view returns (ProposalState);

  function quorumVotes() external view returns (uint256);

  function proposalThreshold() external view returns (uint256);
}",803
RealWorld_BA_115_IMIMO_RealWord_20240830120016.log,115,IMIMO,3974,4126,8100,61.0,0.10239,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IMIMO is IERC20 {
  function burn(address account, uint256 amount) external;

  function mint(address account, uint256 amount) external;
}",66
RealWorld_BA_115_AggregatorV3Interface_RealWord_20240830110513.log,115,AggregatorV3Interface,5705,4300,10005,74.0,0.114525,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.12;

interface AggregatorV3Interface {
  function decimals() external view returns (uint8);

  function description() external view returns (string memory);

  function version() external view returns (uint256);

  function getRoundData(uint80 _roundId)
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );

  function latestRoundData()
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );
}",156
RealWorld_BA_115_InceptionVaultFactory_RealWord_20240830104059.log,115,InceptionVaultFactory,30132,5826,35958,90.0,0.26718,"//SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/proxy/Clones.sol"";

import ""./BoringOwnable.sol"";
import ""./interfaces/IInceptionVaultFactory.sol"";
import ""./interfaces/IAdminInceptionVault.sol"";
import ""./interfaces/IInceptionVaultsCore.sol"";
import ""./interfaces/IInceptionVaultsDataProvider.sol"";
import ""./interfaces/IInceptionVaultPriceFeed.sol"";
import ""../chainlink/AggregatorV3Interface.sol"";
import ""../interfaces/IWETH.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../liquidityMining/interfaces/IGenericMiner.sol"";
import ""../liquidityMining/interfaces/IDebtNotifier.sol"";

contract InceptionVaultFactory is IInceptionVaultFactory, BoringOwnable {
  using Clones for address;

  IAddressProvider private immutable _a;
  IDebtNotifier private immutable _debtNotifier;
  IWETH private immutable _weth;
  IERC20 private immutable _mimo;
  address private immutable _adminInceptionVaultBase;
  address private immutable _inceptionVaultsCoreBase;
  address private immutable _inceptionVaultsDataProviderBase;

  uint8 private _priceFeedCount;
  uint256 private _inceptionVaultCount;

  mapping(uint256 => InceptionVault) private _inceptionVaults;
  mapping(uint8 => address) private _priceFeeds;
  mapping(address => uint8) private _priceFeedIds;

  constructor(
    address adminInceptionVaultBase,
    address inceptionVaultsCoreBase,
    address inceptionVaultsDataProviderBase,
    IAddressProvider addressProvider,
    IDebtNotifier debtNotifier,
    IWETH weth,
    IERC20 mimo
  ) public {
    require(adminInceptionVaultBase != address(0), ""IV000"");
    require(inceptionVaultsCoreBase != address(0), ""IV000"");
    require(inceptionVaultsDataProviderBase != address(0), ""IV000"");
    require(address(addressProvider) != address(0), ""IV000"");
    require(address(debtNotifier) != address(0), ""IV000"");
    require(address(weth) != address(0), ""IV000"");
    require(address(mimo) != address(0), ""IV000"");
    _adminInceptionVaultBase = adminInceptionVaultBase;
    _inceptionVaultsCoreBase = inceptionVaultsCoreBase;
    _inceptionVaultsDataProviderBase = inceptionVaultsDataProviderBase;
    _a = addressProvider;
    _debtNotifier = debtNotifier;
    _weth = weth;
    _mimo = mimo;
  }

  /**
    Clones and initializes all 3 Inception Vault contracts : AdminInceptionVault, InceptionVaultsCore, InceptionVaultsDataProvider.
    @param _vaultConfig the inception vault configuration paramaters, see {IInceptionVaultFactory - VaultConfig}.
    @param _inceptionCollateral the address of the ERC20 token that will be set as inceptionCollateral
  */
  function cloneInceptionVault(
    IInceptionVaultsCore.VaultConfig calldata _vaultConfig,
    IERC20 _inceptionCollateral,
    address _inceptionVaultPriceFeed,
    address _assetOracle
  ) external override {
    require(address(_inceptionCollateral) != address(0), ""IV000"");
    require(_inceptionVaultPriceFeed != address(0), ""IV000"");
    IAdminInceptionVault adminInceptionVault = IAdminInceptionVault(_adminInceptionVaultBase.clone());
    IInceptionVaultsCore inceptionVaultsCore = IInceptionVaultsCore(_inceptionVaultsCoreBase.clone());
    IInceptionVaultsDataProvider inceptionVaultsDataProvider = IInceptionVaultsDataProvider(
      _inceptionVaultsDataProviderBase.clone()
    );
    IInceptionVaultPriceFeed inceptionVaultPriceFeed;
    bool isCustomPriceFeed;

    if (_priceFeedIds[_inceptionVaultPriceFeed] != 0) {
      require(address(_assetOracle) != address(0), ""IV000"");
      inceptionVaultPriceFeed = IInceptionVaultPriceFeed(_inceptionVaultPriceFeed.clone());
      inceptionVaultPriceFeed.initialize(_a, address(_inceptionCollateral), _assetOracle, _a.priceFeed().eurOracle());
    } else {
      require(address(_assetOracle) == address(0), ""IV001"");
      inceptionVaultPriceFeed = IInceptionVaultPriceFeed(_inceptionVaultPriceFeed);
      isCustomPriceFeed = true;
    }

    adminInceptionVault.initialize(msg.sender, _a, _debtNotifier, _weth, _mimo, inceptionVaultsCore);

    inceptionVaultsCore.initialize(
      msg.sender,
      _vaultConfig,
      _inceptionCollateral,
      _a,
      adminInceptionVault,
      inceptionVaultsDataProvider,
      inceptionVaultPriceFeed
    );

    inceptionVaultsDataProvider.initialize(inceptionVaultsCore, _a);

    uint256 newId = ++_inceptionVaultCount;
    InceptionVault memory v = InceptionVault({
      owner: msg.sender,
      adminInceptionVault: adminInceptionVault,
      inceptionVaultsCore: inceptionVaultsCore,
      inceptionVaultsDataProvider: inceptionVaultsDataProvider,
      inceptionVaultPriceFeed: inceptionVaultPriceFeed,
      isCustomPriceFeed: isCustomPriceFeed
    });

    _inceptionVaults[newId] = v;

    emit InceptionVaultDeployed(
      msg.sender,
      adminInceptionVault,
      inceptionVaultsCore,
      inceptionVaultsDataProvider,
      inceptionVaultPriceFeed
    );
  }

  function addPriceFeed(address _address) external override onlyOwner {
    require(_address != address(0), ""IV000"");
    require(_priceFeedIds[_address] == 0, ""IV002"");
    uint8 newId = ++_priceFeedCount;
    _priceFeeds[newId] = _address;
    _priceFeedIds[_address] = newId;
    emit PriceFeedAdded(newId, _address);
  }

  function a() public view override returns (IAddressProvider) {
    return _a;
  }

  function debtNotifier() public view override returns (IDebtNotifier) {
    return _debtNotifier;
  }

  function weth() public view override returns (IWETH) {
    return _weth;
  }

  function mimo() public view override returns (IERC20) {
    return _mimo;
  }

  function adminInceptionVaultBase() public view override returns (address) {
    return _adminInceptionVaultBase;
  }

  function inceptionVaultsCoreBase() public view override returns (address) {
    return _inceptionVaultsCoreBase;
  }

  function inceptionVaultsDataProviderBase() public view override returns (address) {
    return _inceptionVaultsDataProviderBase;
  }

  function inceptionVaultCount() public view override returns (uint256) {
    return _inceptionVaultCount;
  }

  function priceFeedCount() public view override returns (uint8) {
    return _priceFeedCount;
  }

  function inceptionVaults(uint256 _id) public view override returns (InceptionVault memory) {
    return _inceptionVaults[_id];
  }

  function priceFeeds(uint8 _id) public view override returns (address) {
    return _priceFeeds[_id];
  }

  function priceFeedIds(address _priceFeed) public view override returns (uint16) {
    return _priceFeedIds[_priceFeed];
  }
}",1622
RealWorld_BA_115_IAccessController_RealWord_20240830112207.log,115,IAccessController,6581,4730,11311,81.0,0.127505,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

interface IAccessController {
  event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

  function grantRole(bytes32 role, address account) external;

  function revokeRole(bytes32 role, address account) external;

  function renounceRole(bytes32 role, address account) external;

  function MANAGER_ROLE() external view returns (bytes32);

  function MINTER_ROLE() external view returns (bytes32);

  function hasRole(bytes32 role, address account) external view returns (bool);

  function getRoleMemberCount(bytes32 role) external view returns (uint256);

  function getRoleMember(bytes32 role, uint256 index) external view returns (address);

  function getRoleAdmin(bytes32 role) external view returns (bytes32);
}",216
RealWorld_BA_115_ILiquidationManagerV1_RealWord_20240830091905.log,115,ILiquidationManagerV1,6121,5222,11343,82.0,0.135045,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""./IAddressProviderV1.sol"";

interface ILiquidationManagerV1 {
  function a() external view returns (IAddressProviderV1);

  function calculateHealthFactor(
    address _collateralType,
    uint256 _collateralValue,
    uint256 _vaultDebt
  ) external view returns (uint256 healthFactor);

  function liquidationBonus(uint256 _amount) external view returns (uint256 bonus);

  function applyLiquidationDiscount(uint256 _amount) external view returns (uint256 discountedAmount);

  function isHealthy(
    address _collateralType,
    uint256 _collateralValue,
    uint256 _vaultDebt
  ) external view returns (bool);
}",170
RealWorld_BA_115_IMerkleDistributor_RealWord_20240830112939.log,115,IMerkleDistributor,7461,5546,13007,80.0,0.148225,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

// Allows anyone to claim a token if they exist in a merkle root.
interface IMerkleDistributor {
  // This event is triggered whenever a call to #claim succeeds.
  event Claimed(uint256 index, address account, uint256 amount);

  // Claim the given amount of the token to the given address. Reverts if the inputs are invalid.
  function claim(
    uint256 index,
    address account,
    uint256 amount,
    bytes32[] calldata merkleProof
  ) external;

  // Returns the address of the token distributed by this contract.
  function token() external view returns (address);

  // Returns the merkle root of the merkle tree containing account balances available to claim.
  function merkleRoot() external view returns (bytes32);

  // Returns true if the index has been marked claimed.
  function isClaimed(uint256 index) external view returns (bool);

  // Returns the block timestamp when claims will end
  function endTime() external view returns (uint256);

  // Returns true if the claim period has not ended.
  function isActive() external view returns (bool);
}",249
RealWorld_BA_115_IBalancerVault_RealWord_20240830113655.log,115,IBalancerVault,8809,4848,13657,98.0,0.141005,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

interface IBalancerVault {
  enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }

  /**
   * @dev Returns a Pool's contract address and specialization setting.
   */
  function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);

  /**
   * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of
   * the tokens' `balances` changed.
   *
   * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all
   * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.
   *
   * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same
   * order as passed to `registerTokens`.
   *
   * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are
   * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`
   * instead.
   */
  function getPoolTokens(bytes32 poolId)
    external
    view
    returns (
      address[] memory tokens,
      uint256[] memory balances,
      uint256 lastChangeBlock
    );
}",314
RealWorld_BA_115_IGovernanceAddressProvider_RealWord_20240830111626.log,115,IGovernanceAddressProvider,7672,4591,12263,91.0,0.13018,"// SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;
pragma solidity >=0.6.12;

import ""./IGovernorAlpha.sol"";
import ""./ITimelock.sol"";
import ""./IVotingEscrow.sol"";
import ""../../interfaces/IAccessController.sol"";
import ""../../interfaces/IAddressProvider.sol"";
import ""../../liquidityMining/interfaces/IMIMO.sol"";
import ""../../liquidityMining/interfaces/IDebtNotifier.sol"";

interface IGovernanceAddressProvider {
  function setParallelAddressProvider(IAddressProvider _parallel) external;

  function setMIMO(IMIMO _mimo) external;

  function setDebtNotifier(IDebtNotifier _debtNotifier) external;

  function setGovernorAlpha(IGovernorAlpha _governorAlpha) external;

  function setTimelock(ITimelock _timelock) external;

  function setVotingEscrow(IVotingEscrow _votingEscrow) external;

  function controller() external view returns (IAccessController);

  function parallel() external view returns (IAddressProvider);

  function mimo() external view returns (IMIMO);

  function debtNotifier() external view returns (IDebtNotifier);

  function governorAlpha() external view returns (IGovernorAlpha);

  function timelock() external view returns (ITimelock);

  function votingEscrow() external view returns (IVotingEscrow);
}",291
RealWorld_BA_115_GUniLPOracle_RealWord_20240830103016.log,115,GUniLPOracle,20545,6010,26555,83.0,0.222925,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../chainlink/AggregatorV3Interface.sol"";
import ""../interfaces/IGUniPool.sol"";
import ""../libraries/MathPow.sol"";

contract GUniLPOracle is AggregatorV3Interface {
  using SafeMath for uint256;

  string public override description;
  uint256 public override version = 3;
  uint8 public override decimals;

  IGUniPool public immutable pool;
  AggregatorV3Interface public immutable oracleA;
  AggregatorV3Interface public immutable oracleB;

  uint256 private immutable _tokenDecimalsUnitA;
  uint256 private immutable _tokenDecimalsOffsetA;
  uint256 private immutable _tokenDecimalsUnitB;
  uint256 private immutable _tokenDecimalsOffsetB;

  constructor(
    uint8 _decimals,
    string memory _description,
    IGUniPool _pool,
    AggregatorV3Interface _oracleA,
    AggregatorV3Interface _oracleB
  ) public {
    require(address(_pool) != address(0), ""C000"");
    require(address(_oracleA) != address(0), ""C000"");
    require(address(_oracleB) != address(0), ""C000"");

    decimals = _decimals;
    description = _description;
    pool = _pool;
    oracleA = _oracleA;
    oracleB = _oracleB;

    uint256 decimalsA = ERC20(_pool.token0()).decimals();
    _tokenDecimalsUnitA = 10**decimalsA;
    _tokenDecimalsOffsetA = 10**(18 - decimalsA);

    uint256 decimalsB = ERC20(_pool.token1()).decimals();
    _tokenDecimalsUnitB = 10**decimalsB;
    _tokenDecimalsOffsetB = 10**(18 - decimalsB);
  }

  function getRoundData(uint80 _roundId)
    public
    view
    override
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    )
  {
    // Skip the implementation since it is not used by price feed
  }

  /**
   * @notice get data about the latest round. Consumers are encouraged to check
   * that they're receiving fresh data by inspecting the updatedAt and
   * answeredInRound return values.
   * Note that different underlying implementations of AggregatorV3Interface
   * have slightly different semantics for some of the return values. Consumers
   * should determine what implementations they expect to receive
   * data from and validate that they can properly handle return data from all
   * of them.
   * @return roundId is the round ID from the aggregator for which the data was
   * retrieved combined with an phase to ensure that round IDs get larger as
   * time moves forward.
   * @return answer is the answer for the given round
   * @return startedAt is the timestamp when the round was started.
   * (Only some AggregatorV3Interface implementations return meaningful values)
   * @return updatedAt is the timestamp when the round last was updated (i.e.
   * answer was last computed)
   * @return answeredInRound is the round ID of the round in which the answer
   * was computed.
   * (Only some AggregatorV3Interface implementations return meaningful values)
   * @dev Note that answer and updatedAt may change between queries.
   */
  function latestRoundData()
    public
    view
    override
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    )
  {
    (, int256 answerA, , uint256 assetUpdatedAtA, ) = oracleA.latestRoundData();
    (, int256 answerB, , uint256 assetUpdatedAtB, ) = oracleB.latestRoundData();
    uint256 priceA = uint256(answerA);
    uint256 priceB = uint256(answerB);
    uint160 sqrtPriceX96 = uint160(
      MathPow.sqrt((priceA.mul(_tokenDecimalsUnitB).mul(1 << 96)) / (priceB.mul(_tokenDecimalsUnitA))) << 48
    );

    (uint256 rA, uint256 rB) = pool.getUnderlyingBalancesAtPrice(sqrtPriceX96);
    require(rA > 0 || rB > 0, ""C100"");
    uint256 totalSupply = pool.totalSupply();
    require(totalSupply >= 1e9, ""C101"");

    answer = int256(
      priceA.mul(rA.mul(_tokenDecimalsOffsetA)).add(priceB.mul(rB.mul(_tokenDecimalsOffsetB))).div(totalSupply)
    );
    updatedAt = assetUpdatedAtA;

    // use ealier time for updateAt
    if (assetUpdatedAtA > assetUpdatedAtB) {
      updatedAt = assetUpdatedAtB;
    }
  }
}",1080
RealWorld_BA_115_IAddressProvider_RealWord_20240830113835.log,115,IAddressProvider,8920,4860,13780,68.0,0.1418,"// SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""./IAccessController.sol"";
import ""./IConfigProvider.sol"";
import ""./ISTABLEX.sol"";
import ""./IPriceFeed.sol"";
import ""./IRatesManager.sol"";
import ""./ILiquidationManager.sol"";
import ""./IVaultsCore.sol"";
import ""./IVaultsDataProvider.sol"";
import ""./IFeeDistributor.sol"";

interface IAddressProvider {
  function setAccessController(IAccessController _controller) external;

  function setConfigProvider(IConfigProvider _config) external;

  function setVaultsCore(IVaultsCore _core) external;

  function setStableX(ISTABLEX _stablex) external;

  function setRatesManager(IRatesManager _ratesManager) external;

  function setPriceFeed(IPriceFeed _priceFeed) external;

  function setLiquidationManager(ILiquidationManager _liquidationManager) external;

  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) external;

  function setFeeDistributor(IFeeDistributor _feeDistributor) external;

  function controller() external view returns (IAccessController);

  function config() external view returns (IConfigProvider);

  function core() external view returns (IVaultsCore);

  function stablex() external view returns (ISTABLEX);

  function ratesManager() external view returns (IRatesManager);

  function priceFeed() external view returns (IPriceFeed);

  function liquidationManager() external view returns (ILiquidationManager);

  function vaultsData() external view returns (IVaultsDataProvider);

  function feeDistributor() external view returns (IFeeDistributor);
}",357
RealWorld_BA_115_InceptionVaultsDataProvider_RealWord_20240830103814.log,115,InceptionVaultsDataProvider,25100,5706,30806,79.0,0.23962,"//SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/proxy/Initializable.sol"";

import ""./interfaces/IInceptionVaultsCore.sol"";
import ""./interfaces/IInceptionVaultsDataProvider.sol"";
import ""../interfaces/IAddressProvider.sol"";

contract InceptionVaultsDataProvider is IInceptionVaultsDataProvider, Initializable {
  using SafeMath for uint256;

  IAddressProvider private _a;
  IInceptionVaultsCore private _inceptionVaultsCore;

  uint256 private _inceptionVaultCount;

  uint256 private _baseDebt;

  mapping(uint256 => InceptionVault) private _vaults;
  mapping(address => uint256) private _vaultOwners;

  modifier onlyInceptionCore() {
    require(msg.sender == address(_inceptionVaultsCore), ""IV011"");
    _;
  }

  function initialize(IInceptionVaultsCore inceptionVaultsCore, IAddressProvider addressProvider)
    external
    override
    initializer
  {
    _inceptionVaultsCore = inceptionVaultsCore;
    _a = addressProvider;
  }

  /**
    Opens a new vault.
    @dev only the vaultsCore module can call this function
    @param _owner the owner of the new vault.
  */
  function createVault(address _owner) external override onlyInceptionCore returns (uint256) {
    uint256 newId = ++_inceptionVaultCount;
    InceptionVault memory v = InceptionVault({
      owner: _owner,
      collateralBalance: 0,
      baseDebt: 0,
      createdAt: block.timestamp
    });
    _vaults[newId] = v;
    _vaultOwners[_owner] = newId;
    return newId;
  }

  /**
    Set the collateral balance of a vault.
    @dev only the vaultsCore module can call this function
    @param _vaultId Vault ID of which the collateral balance will be updated
    @param _balance the new balance of the vault.
  */
  function setCollateralBalance(uint256 _vaultId, uint256 _balance) external override onlyInceptionCore {
    require(vaultExists(_vaultId), ""IV105"");
    InceptionVault storage v = _vaults[_vaultId];
    v.collateralBalance = _balance;
  }

  /**
   Set the base debt of a vault.
    @dev only the vaultsCore module can call this function
    @param _id Vault ID of which the base debt will be updated
    @param _newBaseDebt the new base debt of the vault.
  */
  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) external override onlyInceptionCore {
    InceptionVault storage _vault = _vaults[_id];
    if (_newBaseDebt > _vault.baseDebt) {
      uint256 increase = _newBaseDebt.sub(_vault.baseDebt);
      _baseDebt = _baseDebt.add(increase);
    } else {
      uint256 decrease = _vault.baseDebt.sub(_newBaseDebt);
      _baseDebt = _baseDebt.sub(decrease);
    }
    _vault.baseDebt = _newBaseDebt;
  }

  /**
    Get a vault by vault ID.
    @param _id The vault's ID to be retrieved
    @return struct InceptionVault {
      address owner;
      uint256 collateralBalance;
      uint256 baseDebt;
      uint256 createdAt;
    }
  */
  function vaults(uint256 _id) external view override returns (InceptionVault memory) {
    InceptionVault memory v = _vaults[_id];
    return v;
  }

  /**
    Get the owner of a vault.
    @param _id the ID of the vault
    @return owner of the vault
  */
  function vaultOwner(uint256 _id) external view override returns (address) {
    return _vaults[_id].owner;
  }

  /**
   Get the collateral balance of a vault.
@param _id the ID of the vault
    @return collateral balance of the vault
  */
  function vaultCollateralBalance(uint256 _id) external view override returns (uint256) {
    return _vaults[_id].collateralBalance;
  }

  /**
   Get the base debt of a vault.
@param _id the ID of the vault
    @return base debt of the vault
  */
  function vaultBaseDebt(uint256 _id) external view override returns (uint256) {
    return _vaults[_id].baseDebt;
  }

  /**
    Retrieve the vault id for a specified owner and collateral type.
    @dev returns 0 for non-existing vaults
    @param _owner address of the owner of the vault
    @return vault id of the vault or 0
  */
  function vaultId(address _owner) external view override returns (uint256) {
    return _vaultOwners[_owner];
  }

  /**
    Calculated the total outstanding debt for a specific vault.
    @dev uses the existing cumulative rate. Call `refreshCollateral()` on `VaultsCore`
    to make sure it's up to date.
    @param _vaultId the ID of the vault
    @return total debt of one vault
  */
  function vaultDebt(uint256 _vaultId) external view override returns (uint256) {
    InceptionVault memory v = _vaults[_vaultId];
    return _a.ratesManager().calculateDebt(v.baseDebt, _inceptionVaultsCore.cumulativeRate());
  }

  /**
    Checks if a specified vault exists.
    @param _id the ID of the vault
    @return boolean if the vault exists
  */
  function vaultExists(uint256 _id) public view override returns (bool) {
    InceptionVault memory v = _vaults[_id];
    return v.owner != address(0);
  }

  function a() public view override returns (IAddressProvider) {
    return _a;
  }

  function inceptionVaultsCore() public view override returns (IInceptionVaultsCore) {
    return _inceptionVaultsCore;
  }

  function inceptionVaultCount() public view override returns (uint256) {
    return _inceptionVaultCount;
  }

  function baseDebt() public view override returns (uint256) {
    return _baseDebt;
  }
}",1382
RealWorld_BA_115_GovernanceAddressProvider_RealWord_20240830110629.log,115,GovernanceAddressProvider,15095,5282,20377,75.0,0.181115,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""./interfaces/IGovernanceAddressProvider.sol"";
import ""./interfaces/IGovernorAlpha.sol"";
import ""./interfaces/ITimelock.sol"";
import ""./interfaces/IVotingEscrow.sol"";
import ""../interfaces/IAccessController.sol"";
import ""../liquidityMining/interfaces/IDebtNotifier.sol"";
import ""../liquidityMining/interfaces/IMIMO.sol"";

contract GovernanceAddressProvider is IGovernanceAddressProvider {
  IAddressProvider public override parallel;
  IMIMO public override mimo;
  IDebtNotifier public override debtNotifier;
  IGovernorAlpha public override governorAlpha;
  ITimelock public override timelock;
  IVotingEscrow public override votingEscrow;

  constructor(IAddressProvider _parallel) public {
    require(address(_parallel) != address(0));
    parallel = _parallel;
  }

  modifier onlyManager() {
    require(controller().hasRole(controller().MANAGER_ROLE(), msg.sender), ""Caller is not a Manager"");
    _;
  }

  /**
    Update the `AddressProvider` address that points to main AddressProvider
    used in the Parallel Protocol
    @dev only manager can call this.
    @param _parallel the address of the new `AddressProvider` address.
  */
  function setParallelAddressProvider(IAddressProvider _parallel) public override onlyManager {
    require(address(_parallel) != address(0));
    parallel = _parallel;
  }

  /**
    Update the `MIMO` ERC20 token address
    @dev only manager can call this.
    @param _mimo the address of the new `MIMO` token address.
  */
  function setMIMO(IMIMO _mimo) public override onlyManager {
    require(address(_mimo) != address(0));
    mimo = _mimo;
  }

  /**
    Update the `DebtNotifier` address
    @dev only manager can call this.
    @param _debtNotifier the address of the new `DebtNotifier`.
  */
  function setDebtNotifier(IDebtNotifier _debtNotifier) public override onlyManager {
    require(address(_debtNotifier) != address(0));
    debtNotifier = _debtNotifier;
  }

  /**
    Update the `GovernorAlpha` address
    @dev only manager can call this.
    @param _governorAlpha the address of the new `GovernorAlpha`.
  */
  function setGovernorAlpha(IGovernorAlpha _governorAlpha) public override onlyManager {
    require(address(_governorAlpha) != address(0));
    governorAlpha = _governorAlpha;
  }

  /**
    Update the `Timelock` address
    @dev only manager can call this.
    @param _timelock the address of the new `Timelock`.
  */
  function setTimelock(ITimelock _timelock) public override onlyManager {
    require(address(_timelock) != address(0));
    timelock = _timelock;
  }

  /**
    Update the `VotingEscrow` address
    @dev only manager can call this.
    @param _votingEscrow the address of the new `VotingEscrow`.
  */
  function setVotingEscrow(IVotingEscrow _votingEscrow) public override onlyManager {
    require(address(_votingEscrow) != address(0));
    votingEscrow = _votingEscrow;
  }

  function controller() public view override returns (IAccessController) {
    return parallel.controller();
  }
}",770
RealWorld_BA_115_ConfigProvider_RealWord_20240830102846.log,115,ConfigProvider,54691,5540,60231,87.0,0.384255,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../libraries/WadRayMath.sol"";
import ""../interfaces/IConfigProvider.sol"";
import ""../interfaces/IAddressProvider.sol"";

contract ConfigProvider is IConfigProvider {
  IAddressProvider public override a;

  mapping(uint256 => CollateralConfig) private _collateralConfigs; //indexing starts at 1
  mapping(address => uint256) public override collateralIds;

  uint256 public override numCollateralConfigs;
  /// @notice The minimum duration of voting on a proposal, in seconds
  uint256 public override minVotingPeriod = 3 days;
  /// @notice The max duration of voting on a proposal, in seconds
  uint256 public override maxVotingPeriod = 2 weeks;
  /// @notice The percentage of votes in support of a proposal required in order for a quorum to be reached and for a proposal to succeed
  uint256 public override votingQuorum = 1e16; // 1%
  /// @notice The percentage of votes required in order for a voter to become a proposer
  uint256 public override proposalThreshold = 2e14; // 0.02%

  constructor(IAddressProvider _addresses) public {
    require(address(_addresses) != address(0));

    a = _addresses;
  }

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), ""Caller is not a Manager"");
    _;
  }

  /**
    Creates or overwrites an existing config for a collateral type
    @param _collateralType address of the collateral type
    @param _debtLimit the debt ceiling for the collateral type
    @param _liquidationRatio the minimum ratio to maintain to avoid liquidation
    @param _minCollateralRatio the minimum ratio to maintain to borrow new money or withdraw collateral
    @param _borrowRate the borrowing rate specified in 1 second interval in RAY accuracy.
    @param _originationFee an optional origination fee for newly created debt. Can be 0.
    @param _liquidationBonus the liquidation bonus to be paid to liquidators.
    @param _liquidationFee an optional fee for liquidation debt. Can be 0.
  */
  function setCollateralConfig(
    address _collateralType,
    uint256 _debtLimit,
    uint256 _liquidationRatio,
    uint256 _minCollateralRatio,
    uint256 _borrowRate,
    uint256 _originationFee,
    uint256 _liquidationBonus,
    uint256 _liquidationFee
  ) public override onlyManager {
    require(address(_collateralType) != address(0));
    require(_minCollateralRatio >= _liquidationRatio);
    if (collateralIds[_collateralType] == 0) {
      // Initialize new collateral
      a.core().state().initializeRates(_collateralType);
      CollateralConfig memory config = CollateralConfig({
        collateralType: _collateralType,
        debtLimit: _debtLimit,
        liquidationRatio: _liquidationRatio,
        minCollateralRatio: _minCollateralRatio,
        borrowRate: _borrowRate,
        originationFee: _originationFee,
        liquidationBonus: _liquidationBonus,
        liquidationFee: _liquidationFee
      });

      numCollateralConfigs++;
      _collateralConfigs[numCollateralConfigs] = config;
      collateralIds[_collateralType] = numCollateralConfigs;
    } else {
      // Update collateral config
      a.core().state().refreshCollateral(_collateralType);
      uint256 id = collateralIds[_collateralType];

      _collateralConfigs[id].collateralType = _collateralType;
      _collateralConfigs[id].debtLimit = _debtLimit;
      _collateralConfigs[id].liquidationRatio = _liquidationRatio;
      _collateralConfigs[id].minCollateralRatio = _minCollateralRatio;
      _collateralConfigs[id].borrowRate = _borrowRate;
      _collateralConfigs[id].originationFee = _originationFee;
      _collateralConfigs[id].liquidationBonus = _liquidationBonus;
      _collateralConfigs[id].liquidationFee = _liquidationFee;
    }
    emit CollateralUpdated(
      _collateralType,
      _debtLimit,
      _liquidationRatio,
      _minCollateralRatio,
      _borrowRate,
      _originationFee,
      _liquidationBonus,
      _liquidationFee
    );
  }

  function _emitUpdateEvent(address _collateralType) internal {
    emit CollateralUpdated(
      _collateralType,
      _collateralConfigs[collateralIds[_collateralType]].debtLimit,
      _collateralConfigs[collateralIds[_collateralType]].liquidationRatio,
      _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio,
      _collateralConfigs[collateralIds[_collateralType]].borrowRate,
      _collateralConfigs[collateralIds[_collateralType]].originationFee,
      _collateralConfigs[collateralIds[_collateralType]].liquidationBonus,
      _collateralConfigs[collateralIds[_collateralType]].liquidationFee
    );
  }

  /**
    Remove the config for a collateral type
    @param _collateralType address of the collateral type
  */
  function removeCollateral(address _collateralType) public override onlyManager {
    uint256 id = collateralIds[_collateralType];
    require(id != 0, ""collateral does not exist"");

    _collateralConfigs[id] = _collateralConfigs[numCollateralConfigs]; //move last entry forward
    collateralIds[_collateralConfigs[id].collateralType] = id; //update id for last entry
    delete _collateralConfigs[numCollateralConfigs]; // delete last entry
    delete collateralIds[_collateralType];

    numCollateralConfigs--;

    emit CollateralRemoved(_collateralType);
  }

  /**
    Sets the debt limit for a collateral type
    @param _collateralType address of the collateral type
    @param _debtLimit the new debt limit
  */
  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) public override onlyManager {
    _collateralConfigs[collateralIds[_collateralType]].debtLimit = _debtLimit;
    _emitUpdateEvent(_collateralType);
  }

  /**
    Sets the minimum liquidation ratio for a collateral type
    @dev this is the liquidation treshold under which a vault is considered open for liquidation.
    @param _collateralType address of the collateral type
    @param _liquidationRatio the new minimum collateralization ratio
  */
  function setCollateralLiquidationRatio(address _collateralType, uint256 _liquidationRatio)
    public
    override
    onlyManager
  {
    require(_liquidationRatio <= _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio);
    _collateralConfigs[collateralIds[_collateralType]].liquidationRatio = _liquidationRatio;
    _emitUpdateEvent(_collateralType);
  }

  /**
    Sets the minimum ratio for a collateral type for new borrowing or collateral withdrawal
    @param _collateralType address of the collateral type
    @param _minCollateralRatio the new minimum open ratio
  */
  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio)
    public
    override
    onlyManager
  {
    require(_minCollateralRatio >= _collateralConfigs[collateralIds[_collateralType]].liquidationRatio);
    _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio = _minCollateralRatio;
    _emitUpdateEvent(_collateralType);
  }

  /**
    Sets the borrowing rate for a collateral type
    @dev borrowing rate is specified for a 1 sec interval and accurancy is in RAY.
    @param _collateralType address of the collateral type
    @param _borrowRate the new borrowing rate for a 1 sec interval
  */
  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) public override onlyManager {
    a.core().state().refreshCollateral(_collateralType);
    _collateralConfigs[collateralIds[_collateralType]].borrowRate = _borrowRate;
    _emitUpdateEvent(_collateralType);
  }

  /**
    Sets the origiation fee for a collateral type
    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD
    @param _collateralType address of the collateral type
    @param _originationFee new origination fee in WAD
  */
  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) public override onlyManager {
    _collateralConfigs[collateralIds[_collateralType]].originationFee = _originationFee;
    _emitUpdateEvent(_collateralType);
  }

  /**
    Sets the liquidation bonus for a collateral type
    @dev the liquidation bonus is specified in WAD
    @param _collateralType address of the collateral type
    @param _liquidationBonus the liquidation bonus to be paid to liquidators.
  */
  function setCollateralLiquidationBonus(address _collateralType, uint256 _liquidationBonus)
    public
    override
    onlyManager
  {
    _collateralConfigs[collateralIds[_collateralType]].liquidationBonus = _liquidationBonus;
    _emitUpdateEvent(_collateralType);
  }

  /**
    Sets the liquidation fee for a collateral type
    @dev this rate is applied as a fee for liquidation and is specified in WAD
    @param _collateralType address of the collateral type
    @param _liquidationFee new liquidation fee in WAD
  */
  function setCollateralLiquidationFee(address _collateralType, uint256 _liquidationFee) public override onlyManager {
    require(_liquidationFee < 1e18); // fee < 100%
    _collateralConfigs[collateralIds[_collateralType]].liquidationFee = _liquidationFee;
    _emitUpdateEvent(_collateralType);
  }

  /**
    Set the min voting period for a gov proposal.
    @param _minVotingPeriod the min voting period for a gov proposal
  */
  function setMinVotingPeriod(uint256 _minVotingPeriod) public override onlyManager {
    minVotingPeriod = _minVotingPeriod;
  }

  /**
    Set the max voting period for a gov proposal.
    @param _maxVotingPeriod the max voting period for a gov proposal
  */
  function setMaxVotingPeriod(uint256 _maxVotingPeriod) public override onlyManager {
    maxVotingPeriod = _maxVotingPeriod;
  }

  /**
    Set the voting quora for a gov proposal.
    @param _votingQuorum the voting quora for a gov proposal
  */
  function setVotingQuorum(uint256 _votingQuorum) public override onlyManager {
    require(_votingQuorum < 1e18);
    votingQuorum = _votingQuorum;
  }

  /**
    Set the proposal threshold for a gov proposal.
    @param _proposalThreshold the proposal threshold for a gov proposal
  */
  function setProposalThreshold(uint256 _proposalThreshold) public override onlyManager {
    require(_proposalThreshold < 1e18);
    proposalThreshold = _proposalThreshold;
  }

  /**
    Get the debt limit for a collateral type
    @dev this is a platform wide limit for new debt issuance against a specific collateral type
    @param _collateralType address of the collateral type
  */
  function collateralDebtLimit(address _collateralType) public view override returns (uint256) {
    return _collateralConfigs[collateralIds[_collateralType]].debtLimit;
  }

  /**
    Get the liquidation ratio that needs to be maintained for a collateral type to avoid liquidation.
    @param _collateralType address of the collateral type
  */
  function collateralLiquidationRatio(address _collateralType) public view override returns (uint256) {
    return _collateralConfigs[collateralIds[_collateralType]].liquidationRatio;
  }

  /**
    Get the minimum collateralization ratio for a collateral type for new borrowing or collateral withdrawal.
    @param _collateralType address of the collateral type
  */
  function collateralMinCollateralRatio(address _collateralType) public view override returns (uint256) {
    return _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio;
  }

  /**
    Get the borrowing rate for a collateral type
    @dev borrowing rate is specified for a 1 sec interval and accurancy is in RAY.
    @param _collateralType address of the collateral type
  */
  function collateralBorrowRate(address _collateralType) public view override returns (uint256) {
    return _collateralConfigs[collateralIds[_collateralType]].borrowRate;
  }

  /**
    Get the origiation fee for a collateral type
    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD
    @param _collateralType address of the collateral type
  */
  function collateralOriginationFee(address _collateralType) public view override returns (uint256) {
    return _collateralConfigs[collateralIds[_collateralType]].originationFee;
  }

  /**
    Get the liquidation bonus for a collateral type
    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD
    @param _collateralType address of the collateral type
  */
  function collateralLiquidationBonus(address _collateralType) public view override returns (uint256) {
    return _collateralConfigs[collateralIds[_collateralType]].liquidationBonus;
  }

  /**
    Get the liquidation fee for a collateral type
    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD
    @param _collateralType address of the collateral type
  */
  function collateralLiquidationFee(address _collateralType) public view override returns (uint256) {
    return _collateralConfigs[collateralIds[_collateralType]].liquidationFee;
  }

  /**
    Retreives the entire config for a specific config id.
    @param _id the ID of the conifg to be returned
  */
  function collateralConfigs(uint256 _id) public view override returns (CollateralConfig memory) {
    require(_id <= numCollateralConfigs, ""Invalid config id"");
    return _collateralConfigs[_id];
  }
}",3182
RealWorld_BA_115_FeeDistributorV1_RealWord_20240830090936.log,115,FeeDistributorV1,18417,5901,24318,76.0,0.210105,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"";
import ""../libraries/WadRayMath.sol"";
import ""../interfaces/ISTABLEX.sol"";
import ""./interfaces/IFeeDistributorV1.sol"";
import ""./interfaces/IAddressProviderV1.sol"";

contract FeeDistributorV1 is IFeeDistributorV1, ReentrancyGuard {
  using SafeMath for uint256;

  event PayeeAdded(address account, uint256 shares);
  event FeeReleased(uint256 income, uint256 releasedAt);

  uint256 public override lastReleasedAt;
  IAddressProviderV1 public override a;

  uint256 public override totalShares;
  mapping(address => uint256) public override shares;
  address[] public payees;

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), ""Caller is not Manager"");
    _;
  }

  constructor(IAddressProviderV1 _addresses) public {
    require(address(_addresses) != address(0));
    a = _addresses;
  }

  /**
    Public function to release the accumulated fee income to the payees.
    @dev anyone can call this.
  */
  function release() public override nonReentrant {
    uint256 income = a.core().availableIncome();
    require(income > 0, ""income is 0"");
    require(payees.length > 0, ""Payees not configured yet"");
    lastReleasedAt = now;

    // Mint USDX to all receivers
    for (uint256 i = 0; i < payees.length; i++) {
      address payee = payees[i];
      _release(income, payee);
    }
    emit FeeReleased(income, lastReleasedAt);
  }

  /**
    Get current configured payees.
    @return array of current payees.
  */
  function getPayees() public view override returns (address[] memory) {
    return payees;
  }

  /**
    Internal function to release a percentage of income to a specific payee
    @dev uses totalShares to calculate correct share
    @param _totalIncomeReceived Total income for all payees, will be split according to shares
    @param _payee The address of the payee to whom to distribute the fees.
  */
  function _release(uint256 _totalIncomeReceived, address _payee) internal {
    uint256 payment = _totalIncomeReceived.mul(shares[_payee]).div(totalShares);
    a.stablex().mint(_payee, payment);
  }

  /**
    Internal function to add a new payee.
    @dev will update totalShares and therefore reduce the relative share of all other payees.
    @param _payee The address of the payee to add.
    @param _shares The number of shares owned by the payee.
  */
  function _addPayee(address _payee, uint256 _shares) internal {
    require(_payee != address(0), ""payee is the zero address"");
    require(_shares > 0, ""shares are 0"");
    require(shares[_payee] == 0, ""payee already has shares"");

    payees.push(_payee);
    shares[_payee] = _shares;
    totalShares = totalShares.add(_shares);
    emit PayeeAdded(_payee, _shares);
  }

  /**
    Updates the payee configuration to a new one.
    @dev will release existing fees before the update.
    @param _payees Array of payees
    @param _shares Array of shares for each payee
  */
  function changePayees(address[] memory _payees, uint256[] memory _shares) public override onlyManager {
    require(_payees.length == _shares.length, ""Payees and shares mismatched"");
    require(_payees.length > 0, ""No payees"");

    uint256 income = a.core().availableIncome();
    if (income > 0 && payees.length > 0) {
      release();
    }

    for (uint256 i = 0; i < payees.length; i++) {
      delete shares[payees[i]];
    }
    delete payees;
    totalShares = 0;

    for (uint256 i = 0; i < _payees.length; i++) {
      _addPayee(_payees[i], _shares[i]);
    }
  }
}",960
RealWorld_BA_115_BalancerV2LPOracle_RealWord_20240830103141.log,115,BalancerV2LPOracle,29093,5615,34708,77.0,0.257765,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../chainlink/AggregatorV3Interface.sol"";
import ""../interfaces/IBalancerVault.sol"";
import ""../interfaces/IBalancerPool.sol"";
import ""../libraries/BNum.sol"";
import ""../libraries/MathPow.sol"";

contract BalancerV2LPOracle is AggregatorV3Interface, BNum {
  using SafeMath for uint256;

  string public override description;
  uint256 public override version = 3;
  uint8 public override decimals;

  bytes32 public poolId;
  IBalancerVault public vault;
  IBalancerPool public pool;
  AggregatorV3Interface public oracleA;
  AggregatorV3Interface public oracleB;

  constructor(
    uint8 _decimals,
    string memory _description,
    IBalancerVault _vault,
    bytes32 _poolId,
    AggregatorV3Interface _oracleA,
    AggregatorV3Interface _oracleB
  ) public {
    require(address(_vault) != address(0), ""C000"");
    require(address(_oracleA) != address(0), ""C000"");
    require(address(_oracleB) != address(0), ""C000"");

    vault = _vault;
    poolId = _poolId;
    (address _pool, IBalancerVault.PoolSpecialization tokensNum) = vault.getPool(poolId);
    require(tokensNum == IBalancerVault.PoolSpecialization.TWO_TOKEN, ""C001"");

    decimals = _decimals;
    description = _description;
    pool = IBalancerPool(_pool);
    oracleA = _oracleA;
    oracleB = _oracleB;
  }

  function getRoundData(uint80 _roundId)
    public
    view
    override
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    )
  {
    // Skip the implementation since it is not used by price feed
  }

  /**
   * @notice get data about the latest round. Consumers are encouraged to check
   * that they're receiving fresh data by inspecting the updatedAt and
   * answeredInRound return values.
   * Note that different underlying implementations of AggregatorV3Interface
   * have slightly different semantics for some of the return values. Consumers
   * should determine what implementations they expect to receive
   * data from and validate that they can properly handle return data from all
   * of them.
   * @return roundId is the round ID from the aggregator for which the data was
   * retrieved combined with an phase to ensure that round IDs get larger as
   * time moves forward.
   * @return answer is the answer for the given round
   * @return startedAt is the timestamp when the round was started.
   * (Only some AggregatorV3Interface implementations return meaningful values)
   * @return updatedAt is the timestamp when the round last was updated (i.e.
   * answer was last computed)
   * @return answeredInRound is the round ID of the round in which the answer
   * was computed.
   * (Only some AggregatorV3Interface implementations return meaningful values)
   * @dev Note that answer and updatedAt may change between queries.
   */
  function latestRoundData()
    public
    view
    override
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    )
  {
    (address[] memory tokens, uint256[] memory balances, ) = vault.getPoolTokens(poolId);
    (, int256 answerA, , uint256 assetUpdatedAtA, ) = oracleA.latestRoundData();
    (, int256 answerB, , uint256 assetUpdatedAtB, ) = oracleB.latestRoundData();

    uint256[] memory normalizedWeights = pool.getNormalizedWeights();

    uint256 pxA = uint256(answerA);
    uint256 pxB = uint256(answerB);
    (uint256 fairResA, uint256 fairResB) = _computeFairReserves(
      _getNormalizedBalance(tokens[0], balances[0]),
      _getNormalizedBalance(tokens[1], balances[1]),
      normalizedWeights[0],
      normalizedWeights[1],
      pxA,
      pxB
    );

    answer = int256(fairResA.mul(pxA).add(fairResB.mul(pxB)).div(pool.totalSupply()));
    updatedAt = assetUpdatedAtA;

    // use oldest timestamp for updatedAt
    if (assetUpdatedAtA > assetUpdatedAtB) {
      updatedAt = assetUpdatedAtB;
    }
  }

  function _getNormalizedBalance(address token, uint256 balance) internal view returns (uint256) {
    uint8 decimals = ERC20(token).decimals();
    return balance.mul(MathPow.pow(10, 18 - decimals));
  }

  /// @dev Return fair reserve amounts given spot reserves, weights, and fair prices.
  /// @param resA Reserve of the first asset
  /// @param resB Reserve of the second asset
  /// @param wA Weight of the first asset
  /// @param wB Weight of the second asset
  /// @param pxA Fair price of the first asset
  /// @param pxB Fair price of the second asset
  function _computeFairReserves(
    uint256 resA,
    uint256 resB,
    uint256 wA,
    uint256 wB,
    uint256 pxA,
    uint256 pxB
  ) internal pure returns (uint256 fairResA, uint256 fairResB) {
    // NOTE: wA + wB = 1 (normalize weights)
    // constant product = resA^wA * resB^wB
    // constraints:
    // - fairResA^wA * fairResB^wB = constant product
    // - fairResA * pxA / wA = fairResB * pxB / wB
    // Solving equations:
    // --> fairResA^wA * (fairResA * (pxA * wB) / (wA * pxB))^wB = constant product
    // --> fairResA / r1^wB = constant product
    // --> fairResA = resA^wA * resB^wB * r1^wB
    // --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB
    uint256 r0 = bdiv(resA, resB);
    uint256 r1 = bdiv(bmul(wA, pxB), bmul(wB, pxA));
    // fairResA = resA * (r1 / r0) ^ wB
    // fairResB = resB * (r0 / r1) ^ wA
    if (r0 > r1) {
      uint256 ratio = bdiv(r1, r0);
      fairResA = bmul(resA, bpow(ratio, wB));
      fairResB = bdiv(resB, bpow(ratio, wA));
    } else {
      uint256 ratio = bdiv(r0, r1);
      fairResA = bdiv(resA, bpow(ratio, wB));
      fairResB = bmul(resB, bpow(ratio, wA));
    }
  }
}",1611
RealWorld_BA_115_DemandMinerV2_RealWord_20240830095222.log,115,DemandMinerV2,17142,5143,22285,81.0,0.18857,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./GenericMinerV2.sol"";
import ""./interfaces/IDemandMinerV2.sol"";
import ""../../governance/interfaces/IGovernanceAddressProvider.sol"";
import ""../../libraries/WadRayMath.sol"";

contract DemandMinerV2 is IDemandMinerV2, GenericMinerV2 {
  using SafeERC20 for IERC20;
  using SafeMath for uint256;
  using WadRayMath for uint256;

  address private _feeCollector;
  IERC20 private immutable _token;

  FeeConfig private _feeConfig;

  constructor(
    IGovernanceAddressProvider _addresses,
    IERC20 token,
    address feeCollector,
    BoostConfig memory _boostConfig,
    FeeConfig memory feeConfig
  ) public GenericMinerV2(_addresses, _boostConfig) {
    require(address(token) != address(0), ""LM000"");
    require(address(token) != address(_addresses.mimo()), ""LM001"");
    require(feeCollector != address(0), ""LM000"");
    _token = token;
    _feeCollector = feeCollector;
    _feeConfig = feeConfig;
    emit FeeCollectorSet(feeCollector);
    emit FeeConfigSet(feeConfig);
  }

  /**
    Sets new _feeCollector
    @dev can only be called by protocol manager
    @param feeCollector new feeCollector address
   */
  function setFeeCollector(address feeCollector) external override onlyManager {
    _feeCollector = feeCollector;
    emit FeeCollectorSet(feeCollector);
  }

  /**
    Sets new _feeConfig
    @dev can only be called by protocol manager
    @param newFeeConfig new FeeConfig struct see {IDemandMinerV2.FeeConfig}
   */
  function setFeeConfig(FeeConfig memory newFeeConfig) external override onlyManager {
    _feeConfig = newFeeConfig;
    emit FeeConfigSet(newFeeConfig);
  }

  /**
    Deposit an ERC20 pool token for staking
    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20
    @param amount the amount of tokens to be deposited. Unit is in WEI
  **/
  function deposit(uint256 amount) public override {
    _token.safeTransferFrom(msg.sender, address(this), amount);
    uint256 depositAmount = amount;
    if (_feeConfig.depositFee > 0) {
      uint256 fee = amount.wadMul(_feeConfig.depositFee);
      depositAmount = depositAmount.sub(fee);
      _token.safeTransfer(_feeCollector, fee);
      emit DepositFeeReleased(fee);
    }
    _increaseStake(msg.sender, depositAmount);
  }

  /**
    Withdraw staked ERC20 pool tokens. Will fail if user does not have enough tokens staked
    @param amount the amount of tokens to be withdrawn. Unit is in WEI
  **/
  function withdraw(uint256 amount) public override {
    uint256 withdrawAmount = amount;
    if (_feeConfig.withdrawFee > 0) {
      uint256 fee = amount.wadMul(_feeConfig.withdrawFee);
      withdrawAmount = withdrawAmount.sub(fee);
      _token.safeTransfer(_feeCollector, fee);
      emit WithdrawFeeReleased(fee);
    }
    _token.safeTransfer(msg.sender, withdrawAmount);
    _decreaseStake(msg.sender, amount);
  }

  function token() public view override returns (IERC20) {
    return _token;
  }

  function feeCollector() public view override returns (address) {
    return _feeCollector;
  }

  function feeConfig() public view override returns (FeeConfig memory) {
    return _feeConfig;
  }
}",847
RealWorld_BA_115_IAddressProvider_RealWord_20240830120223.log,115,IAddressProvider,4734,3824,8558,56.0,0.10015,"// SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;
pragma solidity 0.8.10;

import ""./IVaultsCore.sol"";
import ""./IPriceFeed.sol"";
import ""./IVaultsDataProvider.sol"";

interface IAddressProvider {
  function core() external view returns (IVaultsCore);

  function priceFeed() external view returns (IPriceFeed);

  function vaultsData() external view returns (IVaultsDataProvider);

  function stablex() external view returns (address);
}",105
RealWorld_BA_115_GenericMiner_RealWord_20240830094213.log,115,GenericMiner,28009,5665,33674,97.0,0.253345,"//SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""../libraries/WadRayMath.sol"";
import ""./interfaces/IGenericMiner.sol"";

/*
    GenericMiner is based on ERC2917. https://github.com/gnufoo/ERC2917-Proposal

    The Objective of GenericMiner is to implement a decentralized staking mechanism, which calculates _users' share
    by accumulating stake * time. And calculates _users revenue from anytime t0 to t1 by the formula below:

        user_accumulated_stake(time1) - user_accumulated_stake(time0)
       _____________________________________________________________________________  * (gross_stake(t1) - gross_stake(t0))
       total_accumulated_stake(time1) - total_accumulated_stake(time0)

*/
contract GenericMiner is IGenericMiner {
  using SafeMath for uint256;
  using WadRayMath for uint256;

  mapping(address => UserInfo) internal _users;

  uint256 public override totalStake;
  IGovernanceAddressProvider public override a;

  uint256 internal _balanceTracker;
  uint256 internal _accAmountPerShare;

  constructor(IGovernanceAddressProvider _addresses) public {
    require(address(_addresses) != address(0));
    a = _addresses;
  }

  /**
    Releases the outstanding MIMO balance to the user.
    @param _user the address of the user for which the MIMO tokens will be released.
  */
  function releaseMIMO(address _user) public virtual override {
    UserInfo storage userInfo = _users[_user];
    _refresh();
    uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));
    _balanceTracker = _balanceTracker.sub(pending);
    userInfo.accAmountPerShare = _accAmountPerShare;
    require(a.mimo().transfer(_user, pending));
  }

  /**
    Returns the number of tokens a user has staked.
    @param _user the address of the user.
    @return number of staked tokens
  */
  function stake(address _user) public view override returns (uint256) {
    return _users[_user].stake;
  }

  /**
    Returns the number of tokens a user can claim via `releaseMIMO`.
    @param _user the address of the user.
    @return number of MIMO tokens that the user can claim
  */
  function pendingMIMO(address _user) public view override returns (uint256) {
    uint256 currentBalance = a.mimo().balanceOf(address(this));
    uint256 reward = currentBalance.sub(_balanceTracker);
    uint256 accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));

    return _users[_user].stake.rayMul(accAmountPerShare.sub(_users[_user].accAmountPerShare));
  }

  /**
    Returns the userInfo stored of a user.
    @param _user the address of the user.
    @return `struct UserInfo {
      uint256 stake;
      uint256 rewardDebt;
    }`
  **/
  function userInfo(address _user) public view override returns (UserInfo memory) {
    return _users[_user];
  }

  /**
    Refreshes the global state and subsequently decreases the stake a user has.
    This is an internal call and meant to be called within derivative contracts.
    @param user the address of the user
    @param value the amount by which the stake will be reduced
  */
  function _decreaseStake(address user, uint256 value) internal {
    require(value > 0, ""STAKE_MUST_BE_GREATER_THAN_ZERO""); //TODO cleanup error message

    UserInfo storage userInfo = _users[user];
    require(userInfo.stake >= value, ""INSUFFICIENT_STAKE_FOR_USER""); //TODO cleanup error message
    _refresh();
    uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));
    _balanceTracker = _balanceTracker.sub(pending);
    userInfo.stake = userInfo.stake.sub(value);
    userInfo.accAmountPerShare = _accAmountPerShare;
    totalStake = totalStake.sub(value);

    require(a.mimo().transfer(user, pending));
    emit StakeDecreased(user, value);
  }

  /**
    Refreshes the global state and subsequently increases a user's stake.
    This is an internal call and meant to be called within derivative contracts.
    @param user the address of the user
    @param value the amount by which the stake will be increased
  */
  function _increaseStake(address user, uint256 value) internal {
    require(value > 0, ""STAKE_MUST_BE_GREATER_THAN_ZERO""); //TODO cleanup error message

    UserInfo storage userInfo = _users[user];
    _refresh();

    uint256 pending;
    if (userInfo.stake > 0) {
      pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));
      _balanceTracker = _balanceTracker.sub(pending);
    }

    totalStake = totalStake.add(value);
    userInfo.stake = userInfo.stake.add(value);
    userInfo.accAmountPerShare = _accAmountPerShare;

    if (pending > 0) {
      require(a.mimo().transfer(user, pending));
    }

    emit StakeIncreased(user, value);
  }

  /**
    Refreshes the global state and subsequently updates a user's stake.
    This is an internal call and meant to be called within derivative contracts.
    @param user the address of the user
    @param stake the new amount of stake for the user
  */
  function _updateStake(address user, uint256 stake) internal returns (bool) {
    uint256 oldStake = _users[user].stake;
    if (stake > oldStake) {
      _increaseStake(user, stake.sub(oldStake));
    }
    if (stake < oldStake) {
      _decreaseStake(user, oldStake.sub(stake));
    }
  }

  /**
    Internal read function to calculate the number of MIMO tokens that
    have accumulated since the last token release.
    @dev This is an internal call and meant to be called within derivative contracts.
    @return newly accumulated token balance
  */
  function _newTokensReceived() internal view returns (uint256) {
    return a.mimo().balanceOf(address(this)).sub(_balanceTracker);
  }

  /**
    Updates the internal state variables after accounting for newly received MIMO tokens.
  */
  function _refresh() internal {
    if (totalStake == 0) {
      return;
    }
    uint256 currentBalance = a.mimo().balanceOf(address(this));
    uint256 reward = currentBalance.sub(_balanceTracker);
    _balanceTracker = currentBalance;

    _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));
  }
}",1481
RealWorld_BA_115_IInceptionVaultsDataProvider_RealWord_20240830104754.log,115,IInceptionVaultsDataProvider,8776,5447,14223,78.0,0.15282,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import ""./IInceptionVaultsCore.sol"";
import ""../../interfaces/IAddressProvider.sol"";

interface IInceptionVaultsDataProvider {
  struct InceptionVault {
    address owner;
    uint256 collateralBalance;
    uint256 baseDebt;
    uint256 createdAt;
  }

  //Write
  function initialize(IInceptionVaultsCore _inceptionVaultsCore, IAddressProvider _addressProvider) external;

  function createVault(address _owner) external returns (uint256);

  function setCollateralBalance(uint256 _id, uint256 _balance) external;

  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) external;

  // Read
  function a() external view returns (IAddressProvider);

  function inceptionVaultsCore() external view returns (IInceptionVaultsCore);

  function inceptionVaultCount() external view returns (uint256);

  function baseDebt() external view returns (uint256);

  function vaults(uint256 _id) external view returns (InceptionVault memory);

  function vaultOwner(uint256 _id) external view returns (address);

  function vaultCollateralBalance(uint256 _id) external view returns (uint256);

  function vaultBaseDebt(uint256 _id) external view returns (uint256);

  function vaultId(address _owner) external view returns (uint256);

  function vaultExists(uint256 _id) external view returns (bool);

  function vaultDebt(uint256 _vaultId) external view returns (uint256);
}",340
RealWorld_BA_115_IBalancerPool_RealWord_20240830113945.log,115,IBalancerPool,3630,3421,7051,52.0,0.08657,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

interface IBalancerPool {
  function getNormalizedWeights() external view returns (uint256[] memory);

  function totalSupply() external view returns (uint256);
}",50
RealWorld_BA_115_IInceptionVaultFactory_RealWord_20240830104348.log,115,IInceptionVaultFactory,11544,5586,17130,71.0,0.16944,"//SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./IAdminInceptionVault.sol"";
import ""./IInceptionVaultsCore.sol"";
import ""./IInceptionVaultsDataProvider.sol"";
import ""./IInceptionVaultPriceFeed.sol"";
import ""../../interfaces/IWETH.sol"";
import ""../../interfaces/IAddressProvider.sol"";
import ""../../liquidityMining/interfaces/IDebtNotifier.sol"";

interface IInceptionVaultFactory {
  struct InceptionVault {
    address owner;
    IAdminInceptionVault adminInceptionVault;
    IInceptionVaultsCore inceptionVaultsCore;
    IInceptionVaultsDataProvider inceptionVaultsDataProvider;
    IInceptionVaultPriceFeed inceptionVaultPriceFeed;
    bool isCustomPriceFeed;
  }

  event InceptionVaultDeployed(
    address owner,
    IAdminInceptionVault adminInceptionVault,
    IInceptionVaultsCore inceptionVaultsCore,
    IInceptionVaultsDataProvider inceptionVaultsDataProvider,
    IInceptionVaultPriceFeed inceptionVaultPriceFeed
  );

  event PriceFeedAdded(uint16 _id, address _address);

  function cloneInceptionVault(
    IInceptionVaultsCore.VaultConfig calldata _vaultConfig,
    IERC20 _inceptionCollateral,
    address _inceptionVaultPriceFeed,
    address _assetOracle
  ) external;

  function addPriceFeed(address _address) external;

  // Read only
  function a() external view returns (IAddressProvider);

  function debtNotifier() external view returns (IDebtNotifier);

  function weth() external view returns (IWETH);

  function mimo() external view returns (IERC20);

  function adminInceptionVaultBase() external view returns (address);

  function inceptionVaultsCoreBase() external view returns (address);

  function inceptionVaultsDataProviderBase() external view returns (address);

  function inceptionVaultCount() external view returns (uint256);

  function priceFeedCount() external view returns (uint8);

  function inceptionVaults(uint256 _id) external view returns (InceptionVault memory);

  function priceFeeds(uint8 _id) external view returns (address);

  function priceFeedIds(address _priceFeed) external view returns (uint16);
}",498
RealWorld_BA_115_BoringOwnable_RealWord_20240830103935.log,115,BoringOwnable,10872,5167,16039,82.0,0.1577,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

// Audit on 5-Jan-2021 by Keno and BoringCrypto
// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol
// Edited by BoringCrypto

contract BoringOwnableData {
  address public owner;
  address public pendingOwner;
}

contract BoringOwnable is BoringOwnableData {
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  /// @notice `owner` defaults to msg.sender on construction.
  constructor() public {
    owner = msg.sender;
    emit OwnershipTransferred(address(0), msg.sender);
  }

  /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.
  /// Can only be invoked by the current `owner`.
  /// @param newOwner Address of the new owner.
  /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.
  /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.
  function transferOwnership(
    address newOwner,
    bool direct,
    bool renounce
  ) public onlyOwner {
    if (direct) {
      // Checks
      require(newOwner != address(0) || renounce, ""Ownable: zero address"");

      // Effects
      emit OwnershipTransferred(owner, newOwner);
      owner = newOwner;
      pendingOwner = address(0);
    } else {
      // Effects
      pendingOwner = newOwner;
    }
  }

  /// @notice Needs to be called by `pendingOwner` to claim ownership.
  function claimOwnership() public {
    address _pendingOwner = pendingOwner;

    // Checks
    require(msg.sender == _pendingOwner, ""Ownable: caller != pending owner"");

    // Effects
    emit OwnershipTransferred(owner, _pendingOwner);
    owner = _pendingOwner;
    pendingOwner = address(0);
  }

  /// @notice Only allows the `owner` to execute the function.
  modifier onlyOwner() {
    require(msg.sender == owner, ""Ownable: caller is not the owner"");
    _;
  }
}",499
RealWorld_BA_115_IGenericMinerV2_RealWord_20240830095813.log,115,IGenericMinerV2,9626,5714,15340,100.0,0.16241,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../../../interfaces/IAddressProvider.sol"";
import ""../../../governance/interfaces/IGovernanceAddressProvider.sol"";

interface IGenericMinerV2 {
  struct UserInfo {
    uint256 stake;
    uint256 stakeWithBoost;
    uint256 accAmountPerShare;
    uint256 accParAmountPerShare;
  }

  struct BoostConfig {
    uint256 a;
    uint256 b;
    uint256 c;
    uint256 d;
    uint256 e;
    uint256 maxBoost;
  }

  /// @dev This emit when a users' productivity has changed
  /// It emits with the user's address and the the value after the change.
  event StakeIncreased(address indexed user, uint256 stake);

  /// @dev This emit when a users' productivity has changed
  /// It emits with the user's address and the the value after the change.
  event StakeDecreased(address indexed user, uint256 stake);

  event BoostConfigSet(BoostConfig);

  function releaseRewards(address _user) external;

  function stake(address _user) external view returns (uint256);

  function stakeWithBoost(address _user) external view returns (uint256);

  // Read only
  function a() external view returns (IGovernanceAddressProvider);

  function pendingMIMO(address _user) external view returns (uint256);

  function pendingPAR(address _user) external view returns (uint256);

  function par() external view returns (IERC20);

  function boostConfig() external view returns (BoostConfig memory);

  function totalStake() external view returns (uint256);

  function totalStakeWithBoost() external view returns (uint256);

  function userInfo(address _user) external view returns (UserInfo memory);
}",399
RealWorld_BA_115_IGenericMiner_RealWord_20240830100928.log,115,IGenericMiner,7760,5509,13269,84.0,0.14898,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../../interfaces/IAddressProvider.sol"";
import ""../../governance/interfaces/IGovernanceAddressProvider.sol"";

interface IGenericMiner {
  struct UserInfo {
    uint256 stake;
    uint256 accAmountPerShare; // User's accAmountPerShare
  }

  /// @dev This emit when a users' productivity has changed
  /// It emits with the user's address and the the value after the change.
  event StakeIncreased(address indexed user, uint256 stake);

  /// @dev This emit when a users' productivity has changed
  /// It emits with the user's address and the the value after the change.
  event StakeDecreased(address indexed user, uint256 stake);

  function releaseMIMO(address _user) external;

  function a() external view returns (IGovernanceAddressProvider);

  function stake(address _user) external view returns (uint256);

  function pendingMIMO(address _user) external view returns (uint256);

  function totalStake() external view returns (uint256);

  function userInfo(address _user) external view returns (UserInfo memory);
}",249
RealWorld_BA_115_EthereumDistributor_RealWord_20240830094651.log,115,EthereumDistributor,8700,5005,13705,71.0,0.1436,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import { SafeERC20, IERC20 } from ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""../governance/interfaces/IGovernanceAddressProvider.sol"";
import ""./BaseDistributor.sol"";

contract EthereumDistributor is BaseDistributor {
  using SafeMath for uint256;
  using SafeERC20 for IERC20;

  constructor(IGovernanceAddressProvider _a) public {
    require(address(_a) != address(0));

    a = _a;
  }

  /**
    Calculates how many MIMO tokens can be minted since the last time tokens were minted
    @return number of mintable tokens available right now.
  */
  function mintableTokens() public view override returns (uint256) {
    return a.mimo().balanceOf(address(this));
  }

  /**
    Internal function to release a percentage of newTokens to a specific payee
    @dev uses totalShares to calculate correct share
    @param _totalnewTokensReceived Total newTokens for all payees, will be split according to shares
    @param _payee The address of the payee to whom to distribute the fees.
  */
  function _release(uint256 _totalnewTokensReceived, address _payee) internal override {
    uint256 payment = _totalnewTokensReceived.mul(shares[_payee]).div(totalShares);
    IERC20(a.mimo()).safeTransfer(_payee, payment);
  }
}",341
