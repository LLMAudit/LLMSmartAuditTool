filename,contest_id,contract_name,input_token,completion_token,total_token,execution_time,cost,contract_content,contract_size
RealWorld_BA_31_IERC721Metadata_RealWord_20240819161508.log,31,IERC721Metadata,5554,4292,9846,68.0,0.11361,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""./IERC721.sol"";

/**
 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */
interface IERC721Metadata is IERC721 {
    /**
     * @dev Returns the token collection name.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the token collection symbol.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
     */
    function tokenURI(uint256 tokenId) external view returns (string memory);
}",158
RealWorld_BA_31_IERC777Upgradeable_RealWord_20240819183433.log,31,IERC777Upgradeable,26091,5239,31330,135.0,0.235235,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface of the ERC777Token standard as defined in the EIP.
 *
 * This contract uses the
 * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let
 * token holders and recipients react to token movements by using setting implementers
 * for the associated interfaces in said registry. See {IERC1820Registry} and
 * {ERC1820Implementer}.
 */
interface IERC777Upgradeable {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the smallest part of the token that is not divisible. This
     * means all token operations (creation, movement and destruction) must have
     * amounts that are a multiple of this number.
     *
     * For most token contracts, this value will equal 1.
     */
    function granularity() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by an account (`owner`).
     */
    function balanceOf(address owner) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * If send or receive hooks are registered for the caller and `recipient`,
     * the corresponding functions will be called with `data` and empty
     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.
     *
     * Emits a {Sent} event.
     *
     * Requirements
     *
     * - the caller must have at least `amount` tokens.
     * - `recipient` cannot be the zero address.
     * - if `recipient` is a contract, it must implement the {IERC777Recipient}
     * interface.
     */
    function send(
        address recipient,
        uint256 amount,
        bytes calldata data
    ) external;

    /**
     * @dev Destroys `amount` tokens from the caller's account, reducing the
     * total supply.
     *
     * If a send hook is registered for the caller, the corresponding function
     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.
     *
     * Emits a {Burned} event.
     *
     * Requirements
     *
     * - the caller must have at least `amount` tokens.
     */
    function burn(uint256 amount, bytes calldata data) external;

    /**
     * @dev Returns true if an account is an operator of `tokenHolder`.
     * Operators can send and burn tokens on behalf of their owners. All
     * accounts are their own operator.
     *
     * See {operatorSend} and {operatorBurn}.
     */
    function isOperatorFor(address operator, address tokenHolder)
        external
        view
        returns (bool);

    /**
     * @dev Make an account an operator of the caller.
     *
     * See {isOperatorFor}.
     *
     * Emits an {AuthorizedOperator} event.
     *
     * Requirements
     *
     * - `operator` cannot be calling address.
     */
    function authorizeOperator(address operator) external;

    /**
     * @dev Revoke an account's operator status for the caller.
     *
     * See {isOperatorFor} and {defaultOperators}.
     *
     * Emits a {RevokedOperator} event.
     *
     * Requirements
     *
     * - `operator` cannot be calling address.
     */
    function revokeOperator(address operator) external;

    /**
     * @dev Returns the list of default operators. These accounts are operators
     * for all token holders, even if {authorizeOperator} was never called on
     * them.
     *
     * This list is immutable, but individual holders may revoke these via
     * {revokeOperator}, in which case {isOperatorFor} will return false.
     */
    function defaultOperators() external view returns (address[] memory);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must
     * be an operator of `sender`.
     *
     * If send or receive hooks are registered for `sender` and `recipient`,
     * the corresponding functions will be called with `data` and
     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.
     *
     * Emits a {Sent} event.
     *
     * Requirements
     *
     * - `sender` cannot be the zero address.
     * - `sender` must have at least `amount` tokens.
     * - the caller must be an operator for `sender`.
     * - `recipient` cannot be the zero address.
     * - if `recipient` is a contract, it must implement the {IERC777Recipient}
     * interface.
     */
    function operatorSend(
        address sender,
        address recipient,
        uint256 amount,
        bytes calldata data,
        bytes calldata operatorData
    ) external;

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the total supply.
     * The caller must be an operator of `account`.
     *
     * If a send hook is registered for `account`, the corresponding function
     * will be called with `data` and `operatorData`. See {IERC777Sender}.
     *
     * Emits a {Burned} event.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     * - the caller must be an operator for `account`.
     */
    function operatorBurn(
        address account,
        uint256 amount,
        bytes calldata data,
        bytes calldata operatorData
    ) external;

    event Sent(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256 amount,
        bytes data,
        bytes operatorData
    );

    event Minted(
        address indexed operator,
        address indexed to,
        uint256 amount,
        bytes data,
        bytes operatorData
    );

    event Burned(
        address indexed operator,
        address indexed from,
        uint256 amount,
        bytes data,
        bytes operatorData
    );

    event AuthorizedOperator(
        address indexed operator,
        address indexed tokenHolder
    );

    event RevokedOperator(
        address indexed operator,
        address indexed tokenHolder
    );
}",1441
RealWorld_BA_31_IERC20Detailed_RealWord_20240819210305.log,31,IERC20Detailed,13473,5022,18495,112.0,0.167805,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20Detailed {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}",654
RealWorld_BA_31_IERC777Sender_RealWord_20240819160925.log,31,IERC777Sender,7650,4939,12589,79.0,0.13703,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface of the ERC777TokensSender standard as defined in the EIP.
 *
 * {IERC777} Token holders can be notified of operations performed on their
 * tokens by having a contract implement this interface (contract holders can be
 *  their own implementer) and registering it on the
 * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].
 *
 * See {IERC1820Registry} and {ERC1820Implementer}.
 */
interface IERC777Sender {
    /**
     * @dev Called by an {IERC777} token contract whenever a registered holder's
     * (`from`) tokens are about to be moved or destroyed. The type of operation
     * is conveyed by `to` being the zero address or not.
     *
     * This call occurs _before_ the token contract's state is updated, so
     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.
     *
     * This function may revert to prevent the operation from being executed.
     */
    function tokensToSend(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external;
}",284
RealWorld_BA_31_IToken_RealWord_20240819211213.log,31,IToken,4199,4648,8847,103.0,0.113955,"// SPDX-License-Identifier: MIT

// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

// NOTE: Basically an alias for Vaults
interface IbERC20 {
    function deposit(uint256 _amount) external;

    function withdraw(uint256 _amount) external;

    function getPricePerFullShare() external view returns (uint256);
}",78
RealWorld_BA_31_IERC777Recipient_RealWord_20240819160819.log,31,IERC777Recipient,7394,4441,11835,64.0,0.12579,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.
 *
 * Accounts can be notified of {IERC777} tokens being sent to them by having a
 * contract implement this interface (contract holders can be their own
 * implementer) and registering it on the
 * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].
 *
 * See {IERC1820Registry} and {ERC1820Implementer}.
 */
interface IERC777Recipient {
    /**
     * @dev Called by an {IERC777} token contract whenever tokens are being
     * moved or created into a registered account (`to`). The type of operation
     * is conveyed by `from` being the zero address or not.
     *
     * This call occurs _after_ the token contract's state is updated, so
     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.
     *
     * This function may revert to prevent the operation from being executed.
     */
    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external;
}",279
RealWorld_BA_31_GuestlistApi_RealWord_20240819203353.log,31,GuestlistApi,3686,4215,7901,90.0,0.10273,"// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0 <0.7.0;

interface GuestListAPI {
    function authorized(address guest, uint256 amount)
        external
        view
        returns (bool);
}",49
RealWorld_BA_31_TokenTimelock_RealWord_20240819155826.log,31,TokenTimelock,10152,5374,15526,82.0,0.15824,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./SafeERC20.sol"";

/**
 * @dev A token holder contract that will allow a beneficiary to extract the
 * tokens after a given release time.
 *
 * Useful for simple vesting schedules like ""advisors get all of their tokens
 * after 1 year"".
 */
contract TokenTimelock {
    using SafeERC20 for IERC20;

    // ERC20 basic token contract being held
    IERC20 private _token;

    // beneficiary of tokens after they are released
    address private _beneficiary;

    // timestamp when token release is enabled
    uint256 private _releaseTime;

    constructor(
        IERC20 token,
        address beneficiary,
        uint256 releaseTime
    ) public {
        // solhint-disable-next-line not-rely-on-time
        require(
            releaseTime > block.timestamp,
            ""TokenTimelock: release time is before current time""
        );
        _token = token;
        _beneficiary = beneficiary;
        _releaseTime = releaseTime;
    }

    /**
     * @return the token being held.
     */
    function token() public view returns (IERC20) {
        return _token;
    }

    /**
     * @return the beneficiary of the tokens.
     */
    function beneficiary() public view returns (address) {
        return _beneficiary;
    }

    /**
     * @return the time when the tokens are released.
     */
    function releaseTime() public view returns (uint256) {
        return _releaseTime;
    }

    /**
     * @notice Transfers tokens held by timelock to beneficiary.
     */
    function release() public virtual {
        // solhint-disable-next-line not-rely-on-time
        require(
            block.timestamp >= _releaseTime,
            ""TokenTimelock: current time is before release time""
        );

        uint256 amount = _token.balanceOf(address(this));
        require(amount > 0, ""TokenTimelock: no tokens to release"");

        _token.safeTransfer(_beneficiary, amount);
    }
}",440
RealWorld_BA_31_PaymentSplitterUpgradeable_RealWord_20240819193739.log,31,PaymentSplitterUpgradeable,23415,5510,28925,152.0,0.227275,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../GSN/ContextUpgradeable.sol"";
import ""../math/SafeMathUpgradeable.sol"";
import ""../proxy/Initializable.sol"";

/**
 * @title PaymentSplitter
 * @dev This contract allows to split Ether payments among a group of accounts. The sender does not need to be aware
 * that the Ether will be split in this way, since it is handled transparently by the contract.
 *
 * The split can be in equal parts or in any other arbitrary proportion. The way this is specified is by assigning each
 * account to a number of shares. Of all the Ether that this contract receives, each account will then be able to claim
 * an amount proportional to the percentage of total shares they were assigned.
 *
 * `PaymentSplitter` follows a _pull payment_ model. This means that payments are not automatically forwarded to the
 * accounts but kept in this contract, and the actual transfer is triggered as a separate step by calling the {release}
 * function.
 */
contract PaymentSplitterUpgradeable is Initializable, ContextUpgradeable {
    using SafeMathUpgradeable for uint256;

    event PayeeAdded(address account, uint256 shares);
    event PaymentReleased(address to, uint256 amount);
    event PaymentReceived(address from, uint256 amount);

    uint256 private _totalShares;
    uint256 private _totalReleased;

    mapping(address => uint256) private _shares;
    mapping(address => uint256) private _released;
    address[] private _payees;

    /**
     * @dev Creates an instance of `PaymentSplitter` where each account in `payees` is assigned the number of shares at
     * the matching position in the `shares` array.
     *
     * All addresses in `payees` must be non-zero. Both arrays must have the same non-zero length, and there must be no
     * duplicates in `payees`.
     */
    function __PaymentSplitter_init(
        address[] memory payees,
        uint256[] memory shares
    ) internal initializer {
        __Context_init_unchained();
        __PaymentSplitter_init_unchained(payees, shares);
    }

    function __PaymentSplitter_init_unchained(
        address[] memory payees,
        uint256[] memory shares
    ) internal initializer {
        // solhint-disable-next-line max-line-length
        require(
            payees.length == shares.length,
            ""PaymentSplitter: payees and shares length mismatch""
        );
        require(payees.length > 0, ""PaymentSplitter: no payees"");

        for (uint256 i = 0; i < payees.length; i++) {
            _addPayee(payees[i], shares[i]);
        }
    }

    /**
     * @dev The Ether received will be logged with {PaymentReceived} events. Note that these events are not fully
     * reliable: it's possible for a contract to receive Ether without triggering this function. This only affects the
     * reliability of the events, and not the actual splitting of Ether.
     *
     * To learn more about this see the Solidity documentation for
     * https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function[fallback
     * functions].
     */
    receive() external payable {
        emit PaymentReceived(_msgSender(), msg.value);
    }

    /**
     * @dev Getter for the total shares held by payees.
     */
    function totalShares() public view returns (uint256) {
        return _totalShares;
    }

    /**
     * @dev Getter for the total amount of Ether already released.
     */
    function totalReleased() public view returns (uint256) {
        return _totalReleased;
    }

    /**
     * @dev Getter for the amount of shares held by an account.
     */
    function shares(address account) public view returns (uint256) {
        return _shares[account];
    }

    /**
     * @dev Getter for the amount of Ether already released to a payee.
     */
    function released(address account) public view returns (uint256) {
        return _released[account];
    }

    /**
     * @dev Getter for the address of the payee number `index`.
     */
    function payee(uint256 index) public view returns (address) {
        return _payees[index];
    }

    /**
     * @dev Triggers a transfer to `account` of the amount of Ether they are owed, according to their percentage of the
     * total shares and their previous withdrawals.
     */
    function release(address payable account) public virtual {
        require(_shares[account] > 0, ""PaymentSplitter: account has no shares"");

        uint256 totalReceived = address(this).balance.add(_totalReleased);
        uint256 payment =
            totalReceived.mul(_shares[account]).div(_totalShares).sub(
                _released[account]
            );

        require(payment != 0, ""PaymentSplitter: account is not due payment"");

        _released[account] = _released[account].add(payment);
        _totalReleased = _totalReleased.add(payment);

        account.transfer(payment);
        emit PaymentReleased(account, payment);
    }

    /**
     * @dev Add a new payee to the contract.
     * @param account The address of the payee to add.
     * @param shares_ The number of shares owned by the payee.
     */
    function _addPayee(address account, uint256 shares_) private {
        require(
            account != address(0),
            ""PaymentSplitter: account is the zero address""
        );
        require(shares_ > 0, ""PaymentSplitter: shares are 0"");
        require(
            _shares[account] == 0,
            ""PaymentSplitter: account already has shares""
        );

        _payees.push(account);
        _shares[account] = shares_;
        _totalShares = _totalShares.add(shares_);
        emit PayeeAdded(account, shares_);
    }

    uint256[45] private __gap;
}",1272
RealWorld_BA_31_ICvxLocker_RealWord_20240819204930.log,31,ICvxLocker,6791,4761,11552,95.0,0.129175,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

interface ICvxLocker {
    function maximumBoostPayment() external returns (uint256);

    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external;

    function getReward(address _account, bool _stake) external;

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount);

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount);

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external;

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external;
}",228
RealWorld_BA_31_IBadgerTreeV2_RealWord_20240819212557.log,31,IBadgerTreeV2,10794,5863,16657,122.0,0.17123,"// SPDX-License-Identifier: MIT

// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface IBadgerTreeV2 {
    /// @dev Return true if account has outstanding claims in any token from the given input data
    function isClaimAvailableFor(
        address user,
        address[] memory tokens,
        uint256[] memory cumulativeAmounts
    ) external view;

    /// @dev Get the number of tokens claimable for an account, given a list of tokens and latest cumulativeAmounts data
    function getClaimableFor(
        address user,
        address[] memory tokens,
        uint256[] memory cumulativeAmounts
    ) external view;

    /// @dev Get the cumulative number of tokens claimed for an account, given a list of tokens
    function getClaimedFor(address user, address[] memory tokens) external view;

    /// @dev Utility function to encode a merkle tree node
    function encodeClaim(
        address[] calldata tokens,
        uint256[] calldata cumulativeAmounts,
        address account,
        uint256 index,
        uint256 cycle
    ) external pure;

    /// @notice Claim specifiedrewards for a set of tokens at a given cycle number
    /// @notice Can choose to skip certain tokens by setting amount to claim to zero for that token index
    function claim(
        address[] calldata tokens,
        uint256[] calldata cumulativeAmounts,
        uint256 index,
        uint256 cycle,
        bytes32[] calldata merkleProof,
        uint256[] calldata amountsToClaim
    ) external;

    // ===== Root Updater Restricted =====

    /// @notice Propose a new root and content hash, which will be stored as pending until approved
    function proposeRoot(
        bytes32 root,
        bytes32 contentHash,
        uint256 cycle,
        uint256 startBlock,
        uint256 endBlock
    ) external;

    /// ===== Guardian Restricted =====

    /// @notice Approve the current pending root and content hash
    function approveRoot(
        bytes32 root,
        bytes32 contentHash,
        uint256 cycle,
        uint256 startBlock,
        uint256 endBlock
    ) external;
}",462
RealWorld_BA_31_EscrowUpgradeable_RealWord_20240819194455.log,31,EscrowUpgradeable,13013,5078,18091,130.0,0.166625,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../../math/SafeMathUpgradeable.sol"";
import ""../../access/OwnableUpgradeable.sol"";
import ""../../utils/AddressUpgradeable.sol"";
import ""../../proxy/Initializable.sol"";

/**
 * @title Escrow
 * @dev Base escrow contract, holds funds designated for a payee until they
 * withdraw them.
 *
 * Intended usage: This contract (and derived escrow contracts) should be a
 * standalone contract, that only interacts with the contract that instantiated
 * it. That way, it is guaranteed that all Ether will be handled according to
 * the `Escrow` rules, and there is no need to check for payable functions or
 * transfers in the inheritance tree. The contract that uses the escrow as its
 * payment method should be its owner, and provide public methods redirecting
 * to the escrow's deposit and withdraw.
 */
contract EscrowUpgradeable is Initializable, OwnableUpgradeable {
    function initialize() public virtual initializer {
        __Escrow_init();
    }

    function __Escrow_init() internal initializer {
        __Context_init_unchained();
        __Ownable_init_unchained();
        __Escrow_init_unchained();
    }

    function __Escrow_init_unchained() internal initializer {}

    using SafeMathUpgradeable for uint256;
    using AddressUpgradeable for address payable;

    event Deposited(address indexed payee, uint256 weiAmount);
    event Withdrawn(address indexed payee, uint256 weiAmount);

    mapping(address => uint256) private _deposits;

    function depositsOf(address payee) public view returns (uint256) {
        return _deposits[payee];
    }

    /**
     * @dev Stores the sent amount as credit to be withdrawn.
     * @param payee The destination address of the funds.
     */
    function deposit(address payee) public payable virtual onlyOwner {
        uint256 amount = msg.value;
        _deposits[payee] = _deposits[payee].add(amount);

        emit Deposited(payee, amount);
    }

    /**
     * @dev Withdraw accumulated balance for a payee, forwarding all gas to the
     * recipient.
     *
     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.
     * Make sure you trust the recipient, or are either following the
     * checks-effects-interactions pattern or using {ReentrancyGuard}.
     *
     * @param payee The address whose funds will be withdrawn and transferred to.
     */
    function withdraw(address payable payee) public virtual onlyOwner {
        uint256 payment = _deposits[payee];

        _deposits[payee] = 0;

        payee.sendValue(payment);

        emit Withdrawn(payee, payment);
    }

    uint256[49] private __gap;
}",612
RealWorld_BA_31_IAddressWhitelist_RealWord_20240819211720.log,31,IAddressWhitelist,3996,4162,8158,108.0,0.10322,"// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0;

// Generic address whitelist.
interface IAddressWhitelist {
    // Checks if address exists in whitelist.
    function exists(address addr) external returns (bool);
}",48
RealWorld_BA_31_IWETH_RealWord_20240819210132.log,31,IWETH,4015,4108,8123,91.0,0.102235,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface IWETH {
    function deposit() external payable;

    function withdraw(uint256 wad) external;

    event Deposit(address indexed dst, uint256 wad);
    event Withdrawal(address indexed src, uint256 wad);
}",69
RealWorld_BA_31_IStakingRewards_RealWord_20240819204121.log,31,IStakingRewards,5243,4710,9953,106.0,0.120415,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface IStakingRewards {
    function stakingToken() external view returns (address);

    function rewardsToken() external view returns (address);

    function withdraw(uint256) external;

    function getReward() external;

    function earned(address account) external view returns (uint256);

    function stake(uint256) external;

    function balanceOf(address) external view returns (uint256);

    function exit() external;

    function notifyRewardAmount(uint256 startTimestamp, uint256 reward)
        external;

    function setRewardsDuration(uint256 _rewardsDuration) external;
}",140
RealWorld_BA_31_ISwapStrategyRouter_RealWord_20240819213119.log,31,ISwapStrategyRouter,6295,4855,11150,125.0,0.128575,"//  SPDX-License-Identifier: MIT

pragma solidity >=0.6.0;

// ISwapStrategyRouter performs optimal routing of swaps.
interface ISwapStrategyRouter {
    // Return the optimal rate and the strategy ID.
    function optimizeSwap(
        address _from,
        address _to,
        uint256 _amount
    ) external returns (address strategy, uint256 amount);
}

// ISwapStrategy enforces a standard API for swaps.
interface ISwapStrategy {
    function swapTokens(
        address _from,
        address _to,
        uint256 _amount,
        // Slippage is in bps.
        uint256 _slippage
    ) external returns (uint256 amount);

    // Estimate swap amount returns the swap rate.
    function estimateSwapAmount(
        address _from,
        address _to,
        uint256 _amount
    ) external returns (uint256 amount);
}",186
RealWorld_BA_31_USDT_RealWord_20240819205937.log,31,USDT,4194,4183,8377,113.0,0.10463,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

// https://forum.openzeppelin.com/t/can-not-call-the-function-approve-of-the-usdt-contract/2130/2
interface USDT {
    function approve(address guy, uint256 wad) external;

    function transfer(address _to, uint256 _value) external;
}",83
RealWorld_BA_31_IOwnable_RealWord_20240819210636.log,31,IOwnable,3572,3852,7424,91.0,0.0949,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface IOwnable {
    function transferOwnership(address newOwner) external;
}",38
RealWorld_BA_31_IERC1155Receiver_RealWord_20240819162753.log,31,IERC1155Receiver,11943,5054,16997,71.0,0.160795,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../../introspection/IERC165.sol"";

/**
 * _Available since v3.1._
 */
interface IERC1155Receiver is IERC165 {
    /**
        @dev Handles the receipt of a single ERC1155 token type. This function is
        called at the end of a `safeTransferFrom` after the balance has been updated.
        To accept the transfer, this must return
        `bytes4(keccak256(""onERC1155Received(address,address,uint256,uint256,bytes)""))`
        (i.e. 0xf23a6e61, or its own function selector).
        @param operator The address which initiated the transfer (i.e. msg.sender)
        @param from The address which previously owned the token
        @param id The ID of the token being transferred
        @param value The amount of tokens being transferred
        @param data Additional data with no specified format
        @return `bytes4(keccak256(""onERC1155Received(address,address,uint256,uint256,bytes)""))` if transfer is allowed
    */
    function onERC1155Received(
        address operator,
        address from,
        uint256 id,
        uint256 value,
        bytes calldata data
    ) external returns (bytes4);

    /**
        @dev Handles the receipt of a multiple ERC1155 token types. This function
        is called at the end of a `safeBatchTransferFrom` after the balances have
        been updated. To accept the transfer(s), this must return
        `bytes4(keccak256(""onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)""))`
        (i.e. 0xbc197c81, or its own function selector).
        @param operator The address which initiated the batch transfer (i.e. msg.sender)
        @param from The address which previously owned the token
        @param ids An array containing ids of each token being transferred (order and length must match values array)
        @param values An array containing amounts of each token being transferred (order and length must match ids array)
        @param data Additional data with no specified format
        @return `bytes4(keccak256(""onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)""))` if transfer is allowed
    */
    function onERC1155BatchReceived(
        address operator,
        address from,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external returns (bytes4);
}",547
RealWorld_BA_31_SafeMathUpgradeable_RealWord_20240819202129.log,31,SafeMathUpgradeable,23208,4467,27675,91.0,0.20538,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMathUpgradeable {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, ""SafeMath: subtraction overflow"");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, ""SafeMath: division by zero"");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, ""SafeMath: modulo by zero"");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}",1231
RealWorld_BA_31_IOneSplitAudit_RealWord_20240819213326.log,31,IOneSplitAudit,5135,4668,9803,124.0,0.119035,"// SPDX-License-Identifier: MIT
// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface IOneSplitAudit {
    function swap(
        address fromToken,
        address destToken,
        uint256 amount,
        uint256 minReturn,
        uint256[] calldata distribution,
        uint256 flags
    ) external payable returns (uint256 returnAmount);

    function getExpectedReturn(
        address fromToken,
        address destToken,
        uint256 amount,
        uint256 parts,
        uint256 flags // See constants in IOneSplit.sol
    )
        external
        view
        returns (uint256 returnAmount, uint256[] memory distribution);
}",146
RealWorld_BA_31_IDefender_RealWord_20240819211358.log,31,IDefender,3679,4298,7977,94.0,0.104355,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface IDefender {
    function isAllowed(address) external returns (bool);
}",39
RealWorld_BA_31_IRelayHubUpgradeable_RealWord_20240819192004.log,31,IRelayHubUpgradeable,48390,5419,53809,142.0,0.35033,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface for `RelayHub`, the core contract of the GSN. Users should not need to interact with this contract
 * directly.
 *
 * See the https://github.com/OpenZeppelin/openzeppelin-gsn-helpers[OpenZeppelin GSN helpers] for more information on
 * how to deploy an instance of `RelayHub` on your local test network.
 */
interface IRelayHubUpgradeable {
    // Relay management

    /**
     * @dev Adds stake to a relay and sets its `unstakeDelay`. If the relay does not exist, it is created, and the caller
     * of this function becomes its owner. If the relay already exists, only the owner can call this function. A relay
     * cannot be its own owner.
     *
     * All Ether in this function call will be added to the relay's stake.
     * Its unstake delay will be assigned to `unstakeDelay`, but the new value must be greater or equal to the current one.
     *
     * Emits a {Staked} event.
     */
    function stake(address relayaddr, uint256 unstakeDelay) external payable;

    /**
     * @dev Emitted when a relay's stake or unstakeDelay are increased
     */
    event Staked(address indexed relay, uint256 stake, uint256 unstakeDelay);

    /**
     * @dev Registers the caller as a relay.
     * The relay must be staked for, and not be a contract (i.e. this function must be called directly from an EOA).
     *
     * This function can be called multiple times, emitting new {RelayAdded} events. Note that the received
     * `transactionFee` is not enforced by {relayCall}.
     *
     * Emits a {RelayAdded} event.
     */
    function registerRelay(uint256 transactionFee, string calldata url)
        external;

    /**
     * @dev Emitted when a relay is registered or re-registered. Looking at these events (and filtering out
     * {RelayRemoved} events) lets a client discover the list of available relays.
     */
    event RelayAdded(
        address indexed relay,
        address indexed owner,
        uint256 transactionFee,
        uint256 stake,
        uint256 unstakeDelay,
        string url
    );

    /**
     * @dev Removes (deregisters) a relay. Unregistered (but staked for) relays can also be removed.
     *
     * Can only be called by the owner of the relay. After the relay's `unstakeDelay` has elapsed, {unstake} will be
     * callable.
     *
     * Emits a {RelayRemoved} event.
     */
    function removeRelayByOwner(address relay) external;

    /**
     * @dev Emitted when a relay is removed (deregistered). `unstakeTime` is the time when unstake will be callable.
     */
    event RelayRemoved(address indexed relay, uint256 unstakeTime);

    /** Deletes the relay from the system, and gives back its stake to the owner.
     *
     * Can only be called by the relay owner, after `unstakeDelay` has elapsed since {removeRelayByOwner} was called.
     *
     * Emits an {Unstaked} event.
     */
    function unstake(address relay) external;

    /**
     * @dev Emitted when a relay is unstaked for, including the returned stake.
     */
    event Unstaked(address indexed relay, uint256 stake);

    // States a relay can be in
    enum RelayState {
        Unknown, // The relay is unknown to the system: it has never been staked for
        Staked, // The relay has been staked for, but it is not yet active
        Registered, // The relay has registered itself, and is active (can relay calls)
        Removed // The relay has been removed by its owner and can no longer relay calls. It must wait for its unstakeDelay to elapse before it can unstake
    }

    /**
     * @dev Returns a relay's status. Note that relays can be deleted when unstaked or penalized, causing this function
     * to return an empty entry.
     */
    function getRelay(address relay)
        external
        view
        returns (
            uint256 totalStake,
            uint256 unstakeDelay,
            uint256 unstakeTime,
            address payable owner,
            RelayState state
        );

    // Balance management

    /**
     * @dev Deposits Ether for a contract, so that it can receive (and pay for) relayed transactions.
     *
     * Unused balance can only be withdrawn by the contract itself, by calling {withdraw}.
     *
     * Emits a {Deposited} event.
     */
    function depositFor(address target) external payable;

    /**
     * @dev Emitted when {depositFor} is called, including the amount and account that was funded.
     */
    event Deposited(
        address indexed recipient,
        address indexed from,
        uint256 amount
    );

    /**
     * @dev Returns an account's deposits. These can be either a contract's funds, or a relay owner's revenue.
     */
    function balanceOf(address target) external view returns (uint256);

    /**
     * Withdraws from an account's balance, sending it back to it. Relay owners call this to retrieve their revenue, and
     * contracts can use it to reduce their funding.
     *
     * Emits a {Withdrawn} event.
     */
    function withdraw(uint256 amount, address payable dest) external;

    /**
     * @dev Emitted when an account withdraws funds from `RelayHub`.
     */
    event Withdrawn(
        address indexed account,
        address indexed dest,
        uint256 amount
    );

    // Relaying

    /**
     * @dev Checks if the `RelayHub` will accept a relayed operation.
     * Multiple things must be true for this to happen:
     *  - all arguments must be signed for by the sender (`from`)
     *  - the sender's nonce must be the current one
     *  - the recipient must accept this transaction (via {acceptRelayedCall})
     *
     * Returns a `PreconditionCheck` value (`OK` when the transaction can be relayed), or a recipient-specific error
     * code if it returns one in {acceptRelayedCall}.
     */
    function canRelay(
        address relay,
        address from,
        address to,
        bytes calldata encodedFunction,
        uint256 transactionFee,
        uint256 gasPrice,
        uint256 gasLimit,
        uint256 nonce,
        bytes calldata signature,
        bytes calldata approvalData
    ) external view returns (uint256 status, bytes memory recipientContext);

    // Preconditions for relaying, checked by canRelay and returned as the corresponding numeric values.
    enum PreconditionCheck {
        OK, // All checks passed, the call can be relayed
        WrongSignature, // The transaction to relay is not signed by requested sender
        WrongNonce, // The provided nonce has already been used by the sender
        AcceptRelayedCallReverted, // The recipient rejected this call via acceptRelayedCall
        InvalidRecipientStatusCode // The recipient returned an invalid (reserved) status code
    }

    /**
     * @dev Relays a transaction.
     *
     * For this to succeed, multiple conditions must be met:
     *  - {canRelay} must `return PreconditionCheck.OK`
     *  - the sender must be a registered relay
     *  - the transaction's gas price must be larger or equal to the one that was requested by the sender
     *  - the transaction must have enough gas to not run out of gas if all internal transactions (calls to the
     * recipient) use all gas available to them
     *  - the recipient must have enough balance to pay the relay for the worst-case scenario (i.e. when all gas is
     * spent)
     *
     * If all conditions are met, the call will be relayed and the recipient charged. {preRelayedCall}, the encoded
     * function and {postRelayedCall} will be called in that order.
     *
     * Parameters:
     *  - `from`: the client originating the request
     *  - `to`: the target {IRelayRecipient} contract
     *  - `encodedFunction`: the function call to relay, including data
     *  - `transactionFee`: fee (%) the relay takes over actual gas cost
     *  - `gasPrice`: gas price the client is willing to pay
     *  - `gasLimit`: gas to forward when calling the encoded function
     *  - `nonce`: client's nonce
     *  - `signature`: client's signature over all previous params, plus the relay and RelayHub addresses
     *  - `approvalData`: dapp-specific data forwarded to {acceptRelayedCall}. This value is *not* verified by the
     * `RelayHub`, but it still can be used for e.g. a signature.
     *
     * Emits a {TransactionRelayed} event.
     */
    function relayCall(
        address from,
        address to,
        bytes calldata encodedFunction,
        uint256 transactionFee,
        uint256 gasPrice,
        uint256 gasLimit,
        uint256 nonce,
        bytes calldata signature,
        bytes calldata approvalData
    ) external;

    /**
     * @dev Emitted when an attempt to relay a call failed.
     *
     * This can happen due to incorrect {relayCall} arguments, or the recipient not accepting the relayed call. The
     * actual relayed call was not executed, and the recipient not charged.
     *
     * The `reason` parameter contains an error code: values 1-10 correspond to `PreconditionCheck` entries, and values
     * over 10 are custom recipient error codes returned from {acceptRelayedCall}.
     */
    event CanRelayFailed(
        address indexed relay,
        address indexed from,
        address indexed to,
        bytes4 selector,
        uint256 reason
    );

    /**
     * @dev Emitted when a transaction is relayed.
     * Useful when monitoring a relay's operation and relayed calls to a contract
     *
     * Note that the actual encoded function might be reverted: this is indicated in the `status` parameter.
     *
     * `charge` is the Ether value deducted from the recipient's balance, paid to the relay's owner.
     */
    event TransactionRelayed(
        address indexed relay,
        address indexed from,
        address indexed to,
        bytes4 selector,
        RelayCallStatus status,
        uint256 charge
    );

    // Reason error codes for the TransactionRelayed event
    enum RelayCallStatus {
        OK, // The transaction was successfully relayed and execution successful - never included in the event
        RelayedCallFailed, // The transaction was relayed, but the relayed call failed
        PreRelayedFailed, // The transaction was not relayed due to preRelatedCall reverting
        PostRelayedFailed, // The transaction was relayed and reverted due to postRelatedCall reverting
        RecipientBalanceChanged // The transaction was relayed and reverted due to the recipient's balance changing
    }

    /**
     * @dev Returns how much gas should be forwarded to a call to {relayCall}, in order to relay a transaction that will
     * spend up to `relayedCallStipend` gas.
     */
    function requiredGas(uint256 relayedCallStipend)
        external
        view
        returns (uint256);

    /**
     * @dev Returns the maximum recipient charge, given the amount of gas forwarded, gas price and relay fee.
     */
    function maxPossibleCharge(
        uint256 relayedCallStipend,
        uint256 gasPrice,
        uint256 transactionFee
    ) external view returns (uint256);

    // Relay penalization.
    // Any account can penalize relays, removing them from the system immediately, and rewarding the
    // reporter with half of the relay's stake. The other half is burned so that, even if the relay penalizes itself, it
    // still loses half of its stake.

    /**
     * @dev Penalize a relay that signed two transactions using the same nonce (making only the first one valid) and
     * different data (gas price, gas limit, etc. may be different).
     *
     * The (unsigned) transaction data and signature for both transactions must be provided.
     */
    function penalizeRepeatedNonce(
        bytes calldata unsignedTx1,
        bytes calldata signature1,
        bytes calldata unsignedTx2,
        bytes calldata signature2
    ) external;

    /**
     * @dev Penalize a relay that sent a transaction that didn't target ``RelayHub``'s {registerRelay} or {relayCall}.
     */
    function penalizeIllegalTransaction(
        bytes calldata unsignedTx,
        bytes calldata signature
    ) external;

    /**
     * @dev Emitted when a relay is penalized.
     */
    event Penalized(address indexed relay, address sender, uint256 amount);

    /**
     * @dev Returns an account's nonce in `RelayHub`.
     */
    function getNonce(address from) external view returns (uint256);
}",2851
RealWorld_BA_31_Strings_RealWord_20240819171650.log,31,Strings,6744,3847,10591,87.0,0.11066,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev String operations.
 */
library Strings {
    /**
     * @dev Converts a `uint256` to its ASCII `string` representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return ""0"";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        uint256 index = digits - 1;
        temp = value;
        while (temp != 0) {
            buffer[index--] = bytes1(uint8(48 + (temp % 10)));
            temp /= 10;
        }
        return string(buffer);
    }
}",242
RealWorld_BA_31_IMintr_RealWord_20240819213920.log,31,IMintr,3618,3926,7544,103.0,0.09661,"// SPDX-License-Identifier: MIT

// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface IMintr {
    function mint(address) external;
}",42
RealWorld_BA_31_ReentrancyGuardUpgradeable_RealWord_20240819195126.log,31,ReentrancyGuardUpgradeable,14143,5299,19442,115.0,0.176695,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;
import ""../proxy/Initializable.sol"";

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
contract ReentrancyGuardUpgradeable is Initializable {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    function __ReentrancyGuard_init() internal initializer {
        __ReentrancyGuard_init_unchained();
    }

    function __ReentrancyGuard_init_unchained() internal initializer {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
    uint256[49] private __gap;
}",675
RealWorld_BA_31_VaultApi_RealWord_20240819203210.log,31,VaultApi,19613,5260,24873,101.0,0.203265,"// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0 <0.7.0;
pragma experimental ABIEncoderV2;

import ""deps/@openzeppelin/contracts/token/ERC20/IERC20.sol"";

struct StrategyParams {
    uint256 performanceFee;
    uint256 activation;
    uint256 debtRatio;
    uint256 minDebtPerHarvest;
    uint256 maxDebtPerHarvest;
    uint256 lastReport;
    uint256 totalDebt;
    uint256 totalGain;
    uint256 totalLoss;
}

interface VaultAPI is IERC20 {
    function name() external view returns (string calldata);

    function symbol() external view returns (string calldata);

    function decimals() external view returns (uint256);

    function apiVersion() external pure returns (string memory);

    function permit(
        address owner,
        address spender,
        uint256 amount,
        uint256 expiry,
        bytes calldata signature
    ) external returns (bool);

    // NOTE: Vyper produces multiple signatures for a given function with ""default"" args
    function deposit() external returns (uint256);

    function deposit(uint256 amount) external returns (uint256);

    function deposit(uint256 amount, address recipient)
        external
        returns (uint256);

    // NOTE: Vyper produces multiple signatures for a given function with ""default"" args
    function withdraw() external returns (uint256);

    function withdraw(uint256 maxShares) external returns (uint256);

    function withdraw(uint256 maxShares, address recipient)
        external
        returns (uint256);

    function token() external view returns (address);

    function guestList() external view returns (address);

    function strategies(address _strategy)
        external
        view
        returns (StrategyParams memory);

    function pricePerShare() external view returns (uint256);

    function totalAssets() external view returns (uint256);

    function setDepositLimit(uint256 limit) external;

    function depositLimit() external view returns (uint256);

    function maxAvailableShares() external view returns (uint256);

    function setGuestList(address guestlist) external;

    /**
     * View how much the Vault would increase this Strategy's borrow limit,
     * based on its present performance (since its last report). Can be used to
     * determine expectedReturn in your Strategy.
     */
    function creditAvailable() external view returns (uint256);

    /**
     * View how much the Vault would like to pull back from the Strategy,
     * based on its present performance (since its last report). Can be used to
     * determine expectedReturn in your Strategy.
     */
    function debtOutstanding() external view returns (uint256);

    /**
     * View how much the Vault expect this Strategy to return at the current
     * block, based on its present performance (since its last report). Can be
     * used to determine expectedReturn in your Strategy.
     */
    function expectedReturn() external view returns (uint256);

    /**
     * This is the main contact point where the Strategy interacts with the
     * Vault. It is critical that this call is handled as intended by the
     * Strategy. Therefore, this function will be called by BaseStrategy to
     * make sure the integration is correct.
     */
    function report(
        uint256 _gain,
        uint256 _loss,
        uint256 _debtPayment
    ) external returns (uint256);

    /**
     * This function should only be used in the scenario where the Strategy is
     * being retired but no migration of the positions are possible, or in the
     * extreme scenario that the Strategy needs to be put into ""Emergency Exit""
     * mode in order for it to exit as quickly as possible. The latter scenario
     * could be for any reason that is considered ""critical"" that the Strategy
     * exits its position as fast as possible, such as a sudden change in
     * market conditions leading to losses, or an imminent failure in an
     * external dependency.
     */
    function revokeStrategy() external;

    /**
     * View the governance address of the Vault to assert privileged functions
     * can only be called by governance. The Strategy serves the Vault, so it
     * is subject to governance defined by the Vault.
     */
    function governance() external view returns (address);

    /**
     * View the management address of the Vault to assert privileged functions
     * can only be called by management. The Strategy serves the Vault, so it
     * is subject to management defined by the Vault.
     */
    function management() external view returns (address);

    /**
     * View the guardian address of the Vault to assert privileged functions
     * can only be called by guardian. The Strategy serves the Vault, so it
     * is subject to guardian defined by the Vault.
     */
    function guardian() external view returns (address);
}",1019
RealWorld_BA_31_SettAccessControl_RealWord_20240819155251.log,31,SettAccessControl,8800,4815,13615,69.0,0.1403,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.11;

import ""./@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"";

/*
    Common base for permissioned roles throughout Sett ecosystem
*/
contract SettAccessControl is Initializable {
    address public governance;
    address public strategist;
    address public keeper;

    // ===== MODIFIERS =====
    function _onlyGovernance() internal view {
        require(msg.sender == governance, ""onlyGovernance"");
    }

    function _onlyGovernanceOrStrategist() internal view {
        require(
            msg.sender == strategist || msg.sender == governance,
            ""onlyGovernanceOrStrategist""
        );
    }

    function _onlyAuthorizedActors() internal view {
        require(
            msg.sender == keeper || msg.sender == governance,
            ""onlyAuthorizedActors""
        );
    }

    // ===== PERMISSIONED ACTIONS =====

    /// @notice Change strategist address
    /// @notice Can only be changed by governance itself
    function setStrategist(address _strategist) external {
        _onlyGovernance();
        strategist = _strategist;
    }

    /// @notice Change keeper address
    /// @notice Can only be changed by governance itself
    function setKeeper(address _keeper) external {
        _onlyGovernance();
        keeper = _keeper;
    }

    /// @notice Change governance address
    /// @notice Can only be changed by governance itself
    function setGovernance(address _governance) public {
        _onlyGovernance();
        governance = _governance;
    }

    uint256[50] private __gap;
}",344
RealWorld_BA_31_Package_RealWord_20240819175014.log,31,Package,26887,5517,32404,118.0,0.244775,"pragma solidity ^0.5.0;

import ""../ownership/Ownable.sol"";

/**
 * @title Package
 * @dev A package is composed by a set of versions, identified via semantic versioning,
 * where each version has a contract address that refers to a reusable implementation,
 * plus an optional content URI with metadata. Note that the semver identifier is restricted
 * to major, minor, and patch, as prerelease tags are not supported.
 */
contract Package is OpenZeppelinUpgradesOwnable {
    /**
     * @dev Emitted when a version is added to the package.
     * @param semanticVersion Name of the added version.
     * @param contractAddress Contract associated with the version.
     * @param contentURI Optional content URI with metadata of the version.
     */
    event VersionAdded(
        uint64[3] semanticVersion,
        address contractAddress,
        bytes contentURI
    );

    struct Version {
        uint64[3] semanticVersion;
        address contractAddress;
        bytes contentURI;
    }

    mapping(bytes32 => Version) internal versions;
    mapping(uint64 => bytes32) internal majorToLatestVersion;
    uint64 internal latestMajor;

    /**
     * @dev Returns a version given its semver identifier.
     * @param semanticVersion Semver identifier of the version.
     * @return Contract address and content URI for the version, or zero if not exists.
     */
    function getVersion(uint64[3] memory semanticVersion)
        public
        view
        returns (address contractAddress, bytes memory contentURI)
    {
        Version storage version =
            versions[semanticVersionHash(semanticVersion)];
        return (version.contractAddress, version.contentURI);
    }

    /**
     * @dev Returns a contract for a version given its semver identifier.
     * This method is equivalent to `getVersion`, but returns only the contract address.
     * @param semanticVersion Semver identifier of the version.
     * @return Contract address for the version, or zero if not exists.
     */
    function getContract(uint64[3] memory semanticVersion)
        public
        view
        returns (address contractAddress)
    {
        Version storage version =
            versions[semanticVersionHash(semanticVersion)];
        return version.contractAddress;
    }

    /**
     * @dev Adds a new version to the package. Only the Owner can add new versions.
     * Reverts if the specified semver identifier already exists.
     * Emits a `VersionAdded` event if successful.
     * @param semanticVersion Semver identifier of the version.
     * @param contractAddress Contract address for the version, must be non-zero.
     * @param contentURI Optional content URI for the version.
     */
    function addVersion(
        uint64[3] memory semanticVersion,
        address contractAddress,
        bytes memory contentURI
    ) public onlyOwner {
        require(contractAddress != address(0), ""Contract address is required"");
        require(
            !hasVersion(semanticVersion),
            ""Given version is already registered in package""
        );
        require(
            !semanticVersionIsZero(semanticVersion),
            ""Version must be non zero""
        );

        // Register version
        bytes32 versionId = semanticVersionHash(semanticVersion);
        versions[versionId] = Version(
            semanticVersion,
            contractAddress,
            contentURI
        );

        // Update latest major
        uint64 major = semanticVersion[0];
        if (major > latestMajor) {
            latestMajor = semanticVersion[0];
        }

        // Update latest version for this major
        uint64 minor = semanticVersion[1];
        uint64 patch = semanticVersion[2];
        uint64[3] storage latestVersionForMajor =
            versions[majorToLatestVersion[major]].semanticVersion;
        if (
            semanticVersionIsZero(latestVersionForMajor) || // No latest was set for this major
            (minor > latestVersionForMajor[1]) || // Or current minor is greater
            (minor == latestVersionForMajor[1] &&
                patch > latestVersionForMajor[2]) // Or current patch is greater
        ) {
            majorToLatestVersion[major] = versionId;
        }

        emit VersionAdded(semanticVersion, contractAddress, contentURI);
    }

    /**
     * @dev Checks whether a version is present in the package.
     * @param semanticVersion Semver identifier of the version.
     * @return true if the version is registered in this package, false otherwise.
     */
    function hasVersion(uint64[3] memory semanticVersion)
        public
        view
        returns (bool)
    {
        Version storage version =
            versions[semanticVersionHash(semanticVersion)];
        return address(version.contractAddress) != address(0);
    }

    /**
     * @dev Returns the version with the highest semver identifier registered in the package.
     * For instance, if `1.2.0`, `1.3.0`, and `2.0.0` are present, will always return `2.0.0`, regardless
     * of the order in which they were registered. Returns zero if no versions are registered.
     * @return Semver identifier, contract address, and content URI for the version, or zero if not exists.
     */
    function getLatest()
        public
        view
        returns (
            uint64[3] memory semanticVersion,
            address contractAddress,
            bytes memory contentURI
        )
    {
        return getLatestByMajor(latestMajor);
    }

    /**
     * @dev Returns the version with the highest semver identifier for the given major.
     * For instance, if `1.2.0`, `1.3.0`, and `2.0.0` are present, will return `1.3.0` for major `1`,
     * regardless of the order in which they were registered. Returns zero if no versions are registered
     * for the specified major.
     * @param major Major identifier to query
     * @return Semver identifier, contract address, and content URI for the version, or zero if not exists.
     */
    function getLatestByMajor(uint64 major)
        public
        view
        returns (
            uint64[3] memory semanticVersion,
            address contractAddress,
            bytes memory contentURI
        )
    {
        Version storage version = versions[majorToLatestVersion[major]];
        return (
            version.semanticVersion,
            version.contractAddress,
            version.contentURI
        );
    }

    function semanticVersionHash(uint64[3] memory version)
        internal
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(version[0], version[1], version[2]));
    }

    function semanticVersionIsZero(uint64[3] memory version)
        internal
        pure
        returns (bool)
    {
        return version[0] == 0 && version[1] == 0 && version[2] == 0;
    }
}",1470
RealWorld_BA_31_SafeERC20Upgradeable_RealWord_20240819182437.log,31,SafeERC20Upgradeable,17728,5087,22815,106.0,0.19038,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./IERC20Upgradeable.sol"";
import ""../../math/SafeMathUpgradeable.sol"";
import ""../../utils/AddressUpgradeable.sol"";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20Upgradeable {
    using SafeMathUpgradeable for uint256;
    using AddressUpgradeable for address;

    function safeTransfer(
        IERC20Upgradeable token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transfer.selector, to, value)
        );
    }

    function safeTransferFrom(
        IERC20Upgradeable token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)
        );
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(
        IERC20Upgradeable token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            ""SafeERC20: approve from non-zero to non-zero allowance""
        );
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.approve.selector, spender, value)
        );
    }

    function safeIncreaseAllowance(
        IERC20Upgradeable token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance =
            token.allowance(address(this), spender).add(value);
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(
                token.approve.selector,
                spender,
                newAllowance
            )
        );
    }

    function safeDecreaseAllowance(
        IERC20Upgradeable token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance =
            token.allowance(address(this), spender).sub(
                value,
                ""SafeERC20: decreased allowance below zero""
            );
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(
                token.approve.selector,
                spender,
                newAllowance
            )
        );
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data)
        private
    {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata =
            address(token).functionCall(
                data,
                ""SafeERC20: low-level call failed""
            );
        if (returndata.length > 0) {
            // Return data is optional
            // solhint-disable-next-line max-line-length
            require(
                abi.decode(returndata, (bool)),
                ""SafeERC20: ERC20 operation did not succeed""
            );
        }
    }
}",957
RealWorld_BA_31_ProxyAdmin_RealWord_20240819163645.log,31,ProxyAdmin,13346,5395,18741,84.0,0.17463,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../access/Ownable.sol"";
import ""./TransparentUpgradeableProxy.sol"";

/**
 * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an
 * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.
 */
contract ProxyAdmin is Ownable {
    /**
     * @dev Returns the current implementation of `proxy`.
     *
     * Requirements:
     *
     * - This contract must be the admin of `proxy`.
     */
    function getProxyImplementation(TransparentUpgradeableProxy proxy)
        public
        view
        returns (address)
    {
        // We need to manually run the static call since the getter cannot be flagged as view
        // bytes4(keccak256(""implementation()"")) == 0x5c60da1b
        (bool success, bytes memory returndata) =
            address(proxy).staticcall(hex""5c60da1b"");
        require(success);
        return abi.decode(returndata, (address));
    }

    /**
     * @dev Returns the current admin of `proxy`.
     *
     * Requirements:
     *
     * - This contract must be the admin of `proxy`.
     */
    function getProxyAdmin(TransparentUpgradeableProxy proxy)
        public
        view
        returns (address)
    {
        // We need to manually run the static call since the getter cannot be flagged as view
        // bytes4(keccak256(""admin()"")) == 0xf851a440
        (bool success, bytes memory returndata) =
            address(proxy).staticcall(hex""f851a440"");
        require(success);
        return abi.decode(returndata, (address));
    }

    /**
     * @dev Changes the admin of `proxy` to `newAdmin`.
     *
     * Requirements:
     *
     * - This contract must be the current admin of `proxy`.
     */
    function changeProxyAdmin(
        TransparentUpgradeableProxy proxy,
        address newAdmin
    ) public onlyOwner {
        proxy.changeAdmin(newAdmin);
    }

    /**
     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.
     *
     * Requirements:
     *
     * - This contract must be the admin of `proxy`.
     */
    function upgrade(TransparentUpgradeableProxy proxy, address implementation)
        public
        onlyOwner
    {
        proxy.upgradeTo(implementation);
    }

    /**
     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See
     * {TransparentUpgradeableProxy-upgradeToAndCall}.
     *
     * Requirements:
     *
     * - This contract must be the admin of `proxy`.
     */
    function upgradeAndCall(
        TransparentUpgradeableProxy proxy,
        address implementation,
        bytes memory data
    ) public payable onlyOwner {
        proxy.upgradeToAndCall{value: msg.value}(implementation, data);
    }
}",643
RealWorld_BA_31_SafeMath_RealWord_20240819173012.log,31,SafeMath,23281,4281,27562,88.0,0.202025,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, ""SafeMath: subtraction overflow"");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, ""SafeMath: division by zero"");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, ""SafeMath: modulo by zero"");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}",1229
RealWorld_BA_31_IBadgerGeyser_RealWord_20240819214831.log,31,IBadgerGeyser,4881,5158,10039,110.0,0.127565,"// SPDX-License-Identifier: MIT

// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface IBadgerGeyser {
    function stake(address) external returns (uint256);

    function signalTokenLock(
        address token,
        uint256 amount,
        uint256 durationSec,
        uint256 startTime
    ) external;

    function modifyTokenLock(
        address token,
        uint256 index,
        uint256 amount,
        uint256 durationSec,
        uint256 startTime
    ) external;
}",114
RealWorld_BA_31_Initializable_RealWord_20240819174101.log,31,Initializable,10584,4821,15405,96.0,0.14934,"pragma solidity >=0.4.24 <0.7.0;

/**
 * @title Initializable
 *
 * @dev Helper contract to support initializer functions. To use it, replace
 * the constructor with a function that has the `initializer` modifier.
 * WARNING: Unlike constructors, initializer functions must be manually
 * invoked. This applies both to deploying an Initializable contract, as well
 * as extending an Initializable contract via inheritance.
 * WARNING: When used with inheritance, manual care must be taken to not invoke
 * a parent initializer twice, or ensure that all initializers are idempotent,
 * because this is not dealt with automatically as with constructors.
 */
contract Initializable {
    /**
     * @dev Indicates that the contract has been initialized.
     */
    bool private initialized;

    /**
     * @dev Indicates that the contract is in the process of being initialized.
     */
    bool private initializing;

    /**
     * @dev Modifier to use in the initializer function of a contract.
     */
    modifier initializer() {
        require(
            initializing || isConstructor() || !initialized,
            ""Contract instance has already been initialized""
        );

        bool isTopLevelCall = !initializing;
        if (isTopLevelCall) {
            initializing = true;
            initialized = true;
        }

        _;

        if (isTopLevelCall) {
            initializing = false;
        }
    }

    /// @dev Returns true if and only if the function is running in the constructor
    function isConstructor() private view returns (bool) {
        // extcodesize checks the size of the code stored in an address, and
        // address returns the current address. Since the code is still not
        // deployed when running a constructor, any checks on its code size will
        // yield zero, making it an effective way to detect if a contract is
        // under construction or not.
        address self = address(this);
        uint256 cs;
        assembly {
            cs := extcodesize(self)
        }
        return cs == 0;
    }

    // Reserved storage space to allow for layout changes in the future.
    uint256[50] private ______gap;
}",451
RealWorld_BA_31_WETH_RealWord_20240819210459.log,31,WETH,4115,3924,8039,95.0,0.099055,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface WETH {
    function deposit() external payable;

    function withdraw(uint256 wad) external;

    event Deposit(address indexed dst, uint256 wad);
    event Withdrawal(address indexed src, uint256 wad);
}",69
RealWorld_BA_31_StrategyCvxHelper_RealWord_20240819215421.log,31,StrategyCvxHelper,39967,5397,45364,129.0,0.307775,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.11;
pragma experimental ABIEncoderV2;

import ""deps/@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol"";

import ""interfaces/convex/IBooster.sol"";
import ""interfaces/convex/CrvDepositor.sol"";
import ""interfaces/convex/IBaseRewardsPool.sol"";
import ""interfaces/convex/ICvxRewardsPool.sol"";

import ""../../libraries/CurveSwapper.sol"";
import ""../../libraries/UniswapSwapper.sol"";
import ""../../libraries/TokenSwapPathRegistry.sol"";

import ""../BaseStrategy.sol"";

/*
    1. Stake cvxCrv
    2. Sell earned rewards into cvxCrv position and restake
*/
contract StrategyCvxHelper is BaseStrategy, CurveSwapper, UniswapSwapper, TokenSwapPathRegistry {
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using AddressUpgradeable for address;
    using SafeMathUpgradeable for uint256;
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;

    // ===== Token Registry =====
    address public constant wbtc = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;
    address public constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address public constant crv = 0xD533a949740bb3306d119CC777fa900bA034cd52;
    address public constant cvx = 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;
    address public constant cvxCrv = 0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7;
    address public constant usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address public constant threeCrv = 0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490;

    IERC20Upgradeable public constant crvToken = IERC20Upgradeable(0xD533a949740bb3306d119CC777fa900bA034cd52);
    IERC20Upgradeable public constant cvxToken = IERC20Upgradeable(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);
    IERC20Upgradeable public constant cvxCrvToken = IERC20Upgradeable(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);
    IERC20Upgradeable public constant usdcToken = IERC20Upgradeable(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    IERC20Upgradeable public constant threeCrvToken = IERC20Upgradeable(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);

    // ===== Convex Registry =====
    CrvDepositor public constant crvDepositor = CrvDepositor(0x8014595F2AB54cD7c604B00E9fb932176fDc86Ae); // Convert CRV -> cvxCRV/ETH SLP
    IBooster public constant booster = IBooster(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);
    ICvxRewardsPool public constant cvxRewardsPool = ICvxRewardsPool(0xCF50b810E57Ac33B91dCF525C6ddd9881B139332);
    IBaseRewardsPool public constant cvxCrvRewardsPool = IBaseRewardsPool(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant MAX_UINT_256 = uint256(-1);

    event HarvestState(uint256 timestamp, uint256 blockNumber);

    event WithdrawState(uint256 toWithdraw, uint256 preWant, uint256 postWant, uint256 withdrawn);

    struct TokenSwapData {
        address tokenIn;
        uint256 totalSold;
        uint256 wantGained;
    }

    event TendState(uint256 crvTended, uint256 cvxTended, uint256 cvxCrvHarvested);

    function initialize(
        address _governance,
        address _strategist,
        address _controller,
        address _keeper,
        address _guardian,
        uint256[3] memory _feeConfig
    ) public initializer whenNotPaused {
        __BaseStrategy_init(_governance, _strategist, _controller, _keeper, _guardian);

        want = cvx;

        performanceFeeGovernance = _feeConfig[0];
        performanceFeeStrategist = _feeConfig[1];
        withdrawalFee = _feeConfig[2];

        address[] memory path = new address[](3);
        path[0] = cvxCrv;
        path[1] = weth;
        path[2] = cvx;
        _setTokenSwapPath(cvxCrv, cvx, path);

        // Approvals: Staking Pool
        cvxToken.approve(address(cvxRewardsPool), MAX_UINT_256);
    }

    /// ===== View Functions =====
    function version() external pure returns (string memory) {
        return ""1.0"";
    }

    function getName() external override pure returns (string memory) {
        return ""StrategyCvxHelper"";
    }

    function balanceOfPool() public override view returns (uint256) {
        return cvxRewardsPool.balanceOf(address(this));
    }

    function getProtectedTokens() public override view returns (address[] memory) {
        address[] memory protectedTokens = new address[](2);
        protectedTokens[0] = want;
        protectedTokens[1] = cvx;
        return protectedTokens;
    }

    function isTendable() public override view returns (bool) {
        return false;
    }
    
    /// ===== Internal Core Implementations =====
    function _onlyNotProtectedTokens(address _asset) internal override {
        require(!isProtectedToken(_asset));
    }

    /// @dev Deposit Badger into the staking contract
    function _deposit(uint256 _want) internal override {
        // Deposit all want in core staking pool
        cvxRewardsPool.stake(_want);
    }

    /// @dev Unroll from all strategy positions, and transfer non-core tokens to controller rewards
    function _withdrawAll() internal override {
        // TODO: Functionality not required for initial migration
        // Note: All want is automatically withdrawn outside this ""inner hook"" in base strategy function
    }

    /// @dev Withdraw want from staking rewards, using earnings first
    function _withdrawSome(uint256 _amount) internal override returns (uint256) {
        // Get idle want in the strategy
        uint256 _preWant = IERC20Upgradeable(want).balanceOf(address(this));

        // If we lack sufficient idle want, withdraw the difference from the strategy position
        if (_preWant < _amount) {
            uint256 _toWithdraw = _amount.sub(_preWant);
            cvxRewardsPool.withdraw(_toWithdraw, false);

            // Note: Withdrawl process will earn sushi, this will be deposited into SushiBar on next tend()
        }

        // Confirm how much want we actually end up with
        uint256 _postWant = IERC20Upgradeable(want).balanceOf(address(this));

        // Return the actual amount withdrawn if less than requested
        uint256 _withdrawn = MathUpgradeable.min(_postWant, _amount);
        emit WithdrawState(_amount, _preWant, _postWant, _withdrawn);

        return _withdrawn;
    }

    function _tendGainsFromPositions() internal {
        if (cvxRewardsPool.earned(address(this)) > 0) {
            cvxRewardsPool.getReward(false);
        }
    }   

    function patchPaths() external {
        _onlyGovernance();
        address[] memory path = new address[](4);
        path[0] = cvx;
        path[1] = weth;
        path[2] = crv;
        path[3] = cvxCrv;
        _setTokenSwapPath(cvx, cvxCrv, path);

        path = new address[](4);
        path[0] = usdc;
        path[1] = weth;
        path[2] = crv;
        path[3] = cvxCrv;
        _setTokenSwapPath(usdc, cvxCrv, path);
    }

    function harvest() external whenNotPaused returns (uint256 cvxHarvested) {
        _onlyAuthorizedActors();
        // 1. Harvest gains from positions
        _tendGainsFromPositions();

        uint256 stakedCvxCrv = cvxCrvRewardsPool.balanceOf(address(this));
        if (stakedCvxCrv > 0) {
            cvxCrvRewardsPool.withdraw(stakedCvxCrv, true);
        }
        
        // 2. Swap cvxCRV tokens to CVX
        uint256 cvxCrvBalance = cvxCrvToken.balanceOf(address(this));

        if (cvxCrvBalance > 0) {
            _swapExactTokensForTokens(sushiswap, cvxCrv, cvxCrvBalance, getTokenSwapPath(cvxCrv, cvx));
        }

        // Track harvested + converted coin balance of want
        cvxHarvested = cvxToken.balanceOf(address(this));
        _processFee(cvx, cvxHarvested, performanceFeeGovernance, IController(controller).rewards());

        // 3. Stake all CVX
        if (cvxHarvested > 0) {
            cvxRewardsPool.stake(cvxToken.balanceOf(address(this)));
        }

        emit Harvest(cvxHarvested, block.number);
        return cvxHarvested;
    }
}",2328
RealWorld_BA_31_PaymentSplitter_RealWord_20240819165624.log,31,PaymentSplitter,22072,5535,27607,94.0,0.22106,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../GSN/Context.sol"";
import ""../math/SafeMath.sol"";

/**
 * @title PaymentSplitter
 * @dev This contract allows to split Ether payments among a group of accounts. The sender does not need to be aware
 * that the Ether will be split in this way, since it is handled transparently by the contract.
 *
 * The split can be in equal parts or in any other arbitrary proportion. The way this is specified is by assigning each
 * account to a number of shares. Of all the Ether that this contract receives, each account will then be able to claim
 * an amount proportional to the percentage of total shares they were assigned.
 *
 * `PaymentSplitter` follows a _pull payment_ model. This means that payments are not automatically forwarded to the
 * accounts but kept in this contract, and the actual transfer is triggered as a separate step by calling the {release}
 * function.
 */
contract PaymentSplitter is Context {
    using SafeMath for uint256;

    event PayeeAdded(address account, uint256 shares);
    event PaymentReleased(address to, uint256 amount);
    event PaymentReceived(address from, uint256 amount);

    uint256 private _totalShares;
    uint256 private _totalReleased;

    mapping(address => uint256) private _shares;
    mapping(address => uint256) private _released;
    address[] private _payees;

    /**
     * @dev Creates an instance of `PaymentSplitter` where each account in `payees` is assigned the number of shares at
     * the matching position in the `shares` array.
     *
     * All addresses in `payees` must be non-zero. Both arrays must have the same non-zero length, and there must be no
     * duplicates in `payees`.
     */
    constructor(address[] memory payees, uint256[] memory shares)
        public
        payable
    {
        // solhint-disable-next-line max-line-length
        require(
            payees.length == shares.length,
            ""PaymentSplitter: payees and shares length mismatch""
        );
        require(payees.length > 0, ""PaymentSplitter: no payees"");

        for (uint256 i = 0; i < payees.length; i++) {
            _addPayee(payees[i], shares[i]);
        }
    }

    /**
     * @dev The Ether received will be logged with {PaymentReceived} events. Note that these events are not fully
     * reliable: it's possible for a contract to receive Ether without triggering this function. This only affects the
     * reliability of the events, and not the actual splitting of Ether.
     *
     * To learn more about this see the Solidity documentation for
     * https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function[fallback
     * functions].
     */
    receive() external payable {
        emit PaymentReceived(_msgSender(), msg.value);
    }

    /**
     * @dev Getter for the total shares held by payees.
     */
    function totalShares() public view returns (uint256) {
        return _totalShares;
    }

    /**
     * @dev Getter for the total amount of Ether already released.
     */
    function totalReleased() public view returns (uint256) {
        return _totalReleased;
    }

    /**
     * @dev Getter for the amount of shares held by an account.
     */
    function shares(address account) public view returns (uint256) {
        return _shares[account];
    }

    /**
     * @dev Getter for the amount of Ether already released to a payee.
     */
    function released(address account) public view returns (uint256) {
        return _released[account];
    }

    /**
     * @dev Getter for the address of the payee number `index`.
     */
    function payee(uint256 index) public view returns (address) {
        return _payees[index];
    }

    /**
     * @dev Triggers a transfer to `account` of the amount of Ether they are owed, according to their percentage of the
     * total shares and their previous withdrawals.
     */
    function release(address payable account) public virtual {
        require(_shares[account] > 0, ""PaymentSplitter: account has no shares"");

        uint256 totalReceived = address(this).balance.add(_totalReleased);
        uint256 payment =
            totalReceived.mul(_shares[account]).div(_totalShares).sub(
                _released[account]
            );

        require(payment != 0, ""PaymentSplitter: account is not due payment"");

        _released[account] = _released[account].add(payment);
        _totalReleased = _totalReleased.add(payment);

        account.transfer(payment);
        emit PaymentReleased(account, payment);
    }

    /**
     * @dev Add a new payee to the contract.
     * @param account The address of the payee to add.
     * @param shares_ The number of shares owned by the payee.
     */
    function _addPayee(address account, uint256 shares_) private {
        require(
            account != address(0),
            ""PaymentSplitter: account is the zero address""
        );
        require(shares_ > 0, ""PaymentSplitter: shares are 0"");
        require(
            _shares[account] == 0,
            ""PaymentSplitter: account already has shares""
        );

        _payees.push(account);
        _shares[account] = shares_;
        _totalShares = _totalShares.add(shares_);
        emit PayeeAdded(account, shares_);
    }
}",1181
RealWorld_BA_31_IERC1155MetadataURI_RealWord_20240819163142.log,31,IERC1155MetadataURI,5427,3879,9306,79.0,0.104715,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""./IERC1155.sol"";

/**
 * @dev Interface of the optional ERC1155MetadataExtension interface, as defined
 * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].
 *
 * _Available since v3.1._
 */
interface IERC1155MetadataURI is IERC1155 {
    /**
     * @dev Returns the URI for token type `id`.
     *
     * If the `\{id\}` substring is present in the URI, it must be replaced by
     * clients with the actual token type ID.
     */
    function uri(uint256 id) external view returns (string memory);
}",156
RealWorld_BA_31_IBadgerERC1155_RealWord_20240819211910.log,31,IBadgerERC1155,4720,4160,8880,100.0,0.1068,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface IBadgerERC1155 {
    function balanceOf(address account, uint256 id)
        external
        view
        returns (uint256);

    function totalSupply(uint256 id) external view returns (uint256);

    function tokenSupply(uint256 id) external view returns (uint256);

    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) external;
}",117
RealWorld_BA_31_ISettV3_RealWord_20240819211008.log,31,ISettV3,4188,4674,8862,122.0,0.11442,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.11;
pragma experimental ABIEncoderV2;

interface ISettV3 {
    function deposit(uint256 _amount) external;

    function withdraw(uint256 _amount) external;

    function getPricePerFullShare() external view returns (uint256);

    function balanceOf(address) external view returns (uint256);
}",79
RealWorld_BA_31_UpgradeableProxy_RealWord_20240819163812.log,31,UpgradeableProxy,13892,5340,19232,80.0,0.17626,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./Proxy.sol"";
import ""../utils/Address.sol"";

/**
 * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an
 * implementation address that can be changed. This address is stored in storage in the location specified by
 * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the
 * implementation behind the proxy.
 *
 * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see
 * {TransparentUpgradeableProxy}.
 */
contract UpgradeableProxy is Proxy {
    /**
     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.
     *
     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded
     * function call, and allows initializating the storage of the proxy like a Solidity constructor.
     */
    constructor(address _logic, bytes memory _data) public payable {
        assert(
            _IMPLEMENTATION_SLOT ==
                bytes32(uint256(keccak256(""eip1967.proxy.implementation"")) - 1)
        );
        _setImplementation(_logic);
        if (_data.length > 0) {
            // solhint-disable-next-line avoid-low-level-calls
            (bool success, ) = _logic.delegatecall(_data);
            require(success);
        }
    }

    /**
     * @dev Emitted when the implementation is upgraded.
     */
    event Upgraded(address indexed implementation);

    /**
     * @dev Storage slot with the address of the current implementation.
     * This is the keccak-256 hash of ""eip1967.proxy.implementation"" subtracted by 1, and is
     * validated in the constructor.
     */
    bytes32 private constant _IMPLEMENTATION_SLOT =
        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    /**
     * @dev Returns the current implementation address.
     */
    function _implementation() internal view override returns (address impl) {
        bytes32 slot = _IMPLEMENTATION_SLOT;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            impl := sload(slot)
        }
    }

    /**
     * @dev Upgrades the proxy to a new implementation.
     *
     * Emits an {Upgraded} event.
     */
    function _upgradeTo(address newImplementation) internal {
        _setImplementation(newImplementation);
        emit Upgraded(newImplementation);
    }

    /**
     * @dev Stores a new address in the EIP1967 implementation slot.
     */
    function _setImplementation(address newImplementation) private {
        require(
            Address.isContract(newImplementation),
            ""UpgradeableProxy: new implementation is not a contract""
        );

        bytes32 slot = _IMPLEMENTATION_SLOT;

        // solhint-disable-next-line no-inline-assembly
        assembly {
            sstore(slot, newImplementation)
        }
    }
}",662
RealWorld_BA_31_Initializable_RealWord_20240819163536.log,31,Initializable,11605,4587,16192,66.0,0.149765,"// SPDX-License-Identifier: MIT

pragma solidity >=0.4.24 <0.7.0;

/**
 * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed
 * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an
 * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer
 * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.
 *
 * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as
 * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.
 *
 * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure
 * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.
 */
abstract contract Initializable {
    /**
     * @dev Indicates that the contract has been initialized.
     */
    bool private _initialized;

    /**
     * @dev Indicates that the contract is in the process of being initialized.
     */
    bool private _initializing;

    /**
     * @dev Modifier to protect an initializer function from being invoked twice.
     */
    modifier initializer() {
        require(
            _initializing || _isConstructor() || !_initialized,
            ""Initializable: contract is already initialized""
        );

        bool isTopLevelCall = !_initializing;
        if (isTopLevelCall) {
            _initializing = true;
            _initialized = true;
        }

        _;

        if (isTopLevelCall) {
            _initializing = false;
        }
    }

    /// @dev Returns true if and only if the function is running in the constructor
    function _isConstructor() private view returns (bool) {
        // extcodesize checks the size of the code stored in an address, and
        // address returns the current address. Since the code is still not
        // deployed when running a constructor, any checks on its code size will
        // yield zero, making it an effective way to detect if a contract is
        // under construction or not.
        address self = address(this);
        uint256 cs;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            cs := extcodesize(self)
        }
        return cs == 0;
    }
}",530
RealWorld_BA_31_IMerkleAddressWhitelist_RealWord_20240819212942.log,31,IMerkleAddressWhitelist,3961,4466,8427,95.0,0.109125,"// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0;

// Generic address whitelist impl as a merkle tree.
interface IMerkleAddressWhitelist {
    // Checks if address exists in whitelist.
    function exists(address addr, bytes32[] calldata merkleProof)
        external
        returns (bool);
}",68
RealWorld_BA_31_IERC1820Implementer_RealWord_20240819172204.log,31,IERC1820Implementer,5735,3974,9709,100.0,0.108155,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface for an ERC1820 implementer, as defined in the
 * https://eips.ethereum.org/EIPS/eip-1820#interface-implementation-erc1820implementerinterface[EIP].
 * Used by contracts that will be registered as implementers in the
 * {IERC1820Registry}.
 */
interface IERC1820Implementer {
    /**
     * @dev Returns a special value (`ERC1820_ACCEPT_MAGIC`) if this contract
     * implements `interfaceHash` for `account`.
     *
     * See {IERC1820Registry-setInterfaceImplementer}.
     */
    function canImplementInterfaceForAddress(
        bytes32 interfaceHash,
        address account
    ) external view returns (bytes32);
}",172
RealWorld_BA_31_IERC20_RealWord_20240819205752.log,31,IERC20,13654,5204,18858,102.0,0.17235,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}",664
RealWorld_BA_31_IERC721MetadataUpgradeable_RealWord_20240819184621.log,31,IERC721MetadataUpgradeable,5988,4820,10808,135.0,0.12634,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""./IERC721Upgradeable.sol"";

/**
 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */
interface IERC721MetadataUpgradeable is IERC721Upgradeable {
    /**
     * @dev Returns the token collection name.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the token collection symbol.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
     */
    function tokenURI(uint256 tokenId) external view returns (string memory);
}",164
RealWorld_BA_31_GSNRecipientERC20Fee_RealWord_20240819164805.log,31,GSNRecipientERC20Fee,26162,5456,31618,85.0,0.23993,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./GSNRecipient.sol"";
import ""../math/SafeMath.sol"";
import ""../access/Ownable.sol"";
import ""../token/ERC20/SafeERC20.sol"";
import ""../token/ERC20/ERC20.sol"";

/**
 * @dev A xref:ROOT:gsn-strategies.adoc#gsn-strategies[GSN strategy] that charges transaction fees in a special purpose ERC20
 * token, which we refer to as the gas payment token. The amount charged is exactly the amount of Ether charged to the
 * recipient. This means that the token is essentially pegged to the value of Ether.
 *
 * The distribution strategy of the gas payment token to users is not defined by this contract. It's a mintable token
 * whose only minter is the recipient, so the strategy must be implemented in a derived contract, making use of the
 * internal {_mint} function.
 */
contract GSNRecipientERC20Fee is GSNRecipient {
    using SafeERC20 for __unstable__ERC20Owned;
    using SafeMath for uint256;

    enum GSNRecipientERC20FeeErrorCodes {INSUFFICIENT_BALANCE}

    __unstable__ERC20Owned private _token;

    /**
     * @dev The arguments to the constructor are the details that the gas payment token will have: `name` and `symbol`. `decimals` is hard-coded to 18.
     */
    constructor(string memory name, string memory symbol) public {
        _token = new __unstable__ERC20Owned(name, symbol);
    }

    /**
     * @dev Returns the gas payment token.
     */
    function token() public view returns (IERC20) {
        return IERC20(_token);
    }

    /**
     * @dev Internal function that mints the gas payment token. Derived contracts should expose this function in their public API, with proper access control mechanisms.
     */
    function _mint(address account, uint256 amount) internal virtual {
        _token.mint(account, amount);
    }

    /**
     * @dev Ensures that only users with enough gas payment token balance can have transactions relayed through the GSN.
     */
    function acceptRelayedCall(
        address,
        address from,
        bytes memory,
        uint256 transactionFee,
        uint256 gasPrice,
        uint256,
        uint256,
        bytes memory,
        uint256 maxPossibleCharge
    ) public view virtual override returns (uint256, bytes memory) {
        if (_token.balanceOf(from) < maxPossibleCharge) {
            return
                _rejectRelayedCall(
                    uint256(GSNRecipientERC20FeeErrorCodes.INSUFFICIENT_BALANCE)
                );
        }

        return
            _approveRelayedCall(
                abi.encode(from, maxPossibleCharge, transactionFee, gasPrice)
            );
    }

    /**
     * @dev Implements the precharge to the user. The maximum possible charge (depending on gas limit, gas price, and
     * fee) will be deducted from the user balance of gas payment token. Note that this is an overestimation of the
     * actual charge, necessary because we cannot predict how much gas the execution will actually need. The remainder
     * is returned to the user in {_postRelayedCall}.
     */
    function _preRelayedCall(bytes memory context)
        internal
        virtual
        override
        returns (bytes32)
    {
        (address from, uint256 maxPossibleCharge) =
            abi.decode(context, (address, uint256));

        // The maximum token charge is pre-charged from the user
        _token.safeTransferFrom(from, address(this), maxPossibleCharge);
    }

    /**
     * @dev Returns to the user the extra amount that was previously charged, once the actual execution cost is known.
     */
    function _postRelayedCall(
        bytes memory context,
        bool,
        uint256 actualCharge,
        bytes32
    ) internal virtual override {
        (
            address from,
            uint256 maxPossibleCharge,
            uint256 transactionFee,
            uint256 gasPrice
        ) = abi.decode(context, (address, uint256, uint256, uint256));

        // actualCharge is an _estimated_ charge, which assumes postRelayedCall will use all available gas.
        // This implementation's gas cost can be roughly estimated as 10k gas, for the two SSTORE operations in an
        // ERC20 transfer.
        uint256 overestimation =
            _computeCharge(
                _POST_RELAYED_CALL_MAX_GAS.sub(10000),
                gasPrice,
                transactionFee
            );
        actualCharge = actualCharge.sub(overestimation);

        // After the relayed call has been executed and the actual charge estimated, the excess pre-charge is returned
        _token.safeTransfer(from, maxPossibleCharge.sub(actualCharge));
    }
}

/**
 * @title __unstable__ERC20Owned
 * @dev An ERC20 token owned by another contract, which has minting permissions and can use transferFrom to receive
 * anyone's tokens. This contract is an internal helper for GSNRecipientERC20Fee, and should not be used
 * outside of this context.
 */
// solhint-disable-next-line contract-name-camelcase
contract __unstable__ERC20Owned is ERC20, Ownable {
    uint256 private constant _UINT256_MAX = 2**256 - 1;

    constructor(string memory name, string memory symbol)
        public
        ERC20(name, symbol)
    {}

    // The owner (GSNRecipientERC20Fee) can mint tokens
    function mint(address account, uint256 amount) public onlyOwner {
        _mint(account, amount);
    }

    // The owner has 'infinite' allowance for all token holders
    function allowance(address tokenOwner, address spender)
        public
        view
        override
        returns (uint256)
    {
        if (spender == owner()) {
            return _UINT256_MAX;
        } else {
            return super.allowance(tokenOwner, spender);
        }
    }

    // Allowance for the owner cannot be changed (it is always 'infinite')
    function _approve(
        address tokenOwner,
        address spender,
        uint256 value
    ) internal override {
        if (spender == owner()) {
            return;
        } else {
            super._approve(tokenOwner, spender, value);
        }
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public override returns (bool) {
        if (recipient == owner()) {
            _transfer(sender, recipient, amount);
            return true;
        } else {
            return super.transferFrom(sender, recipient, amount);
        }
    }
}",1417
RealWorld_BA_31_UniSwapper_RealWord_20240819215912.log,31,UniSwapper,18626,5408,24034,137.0,0.20129,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.11;

import ""deps/@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol"";

import ""./BaseSwapper.sol"";
import ""interfaces/uniswap/IUniswapRouterV2.sol"";
import ""interfaces/uniswap/IUniswapV2Factory.sol"";

/*
    Expands swapping functionality over base strategy
    - ETH in and ETH out Variants
    - Sushiswap support in addition to Uniswap
*/
contract UniswapSwapper is BaseSwapper {
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using AddressUpgradeable for address;
    using SafeMathUpgradeable for uint256;

    address internal constant uniswap = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // Uniswap router
    address internal constant sushiswap = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F; // Sushiswap router

    function _swapExactTokensForTokens(
        address router,
        address startToken,
        uint256 balance,
        address[] memory path
    ) internal {
        _safeApproveHelper(startToken, router, balance);
        IUniswapRouterV2(router).swapExactTokensForTokens(balance, 0, path, address(this), now);
    }

    function _swapExactETHForTokens(
        address router,
        uint256 balance,
        address[] memory path
    ) internal {
        IUniswapRouterV2(uniswap).swapExactETHForTokens{value: balance}(0, path, address(this), now);
    }

    function _swapExactTokensForETH(
        address router,
        address startToken,
        uint256 balance,
        address[] memory path
    ) internal {
        _safeApproveHelper(startToken, router, balance);
        IUniswapRouterV2(router).swapExactTokensForETH(balance, 0, path, address(this), now);
    }

    function _getPair(
        address router,
        address token0,
        address token1
    ) internal view returns (address) {
        address factory = IUniswapRouterV2(router).factory();
        return IUniswapV2Factory(factory).getPair(token0, token1);
    }

    /// @notice Add liquidity to uniswap for specified token pair, utilizing the maximum balance possible
    function _addMaxLiquidity(
        address router,
        address token0,
        address token1
    ) internal {
        uint256 _token0Balance = IERC20Upgradeable(token0).balanceOf(address(this));
        uint256 _token1Balance = IERC20Upgradeable(token1).balanceOf(address(this));

        _safeApproveHelper(token0, router, _token0Balance);
        _safeApproveHelper(token1, router, _token1Balance);

        IUniswapRouterV2(router).addLiquidity(token0, token1, _token0Balance, _token1Balance, 0, 0, address(this), block.timestamp);
    }

    function _addMaxLiquidityEth(address router, address token0) internal {
        uint256 _token0Balance = IERC20Upgradeable(token0).balanceOf(address(this));
        uint256 _ethBalance = address(this).balance;

        _safeApproveHelper(token0, router, _token0Balance);
        IUniswapRouterV2(router).addLiquidityETH{value: address(this).balance}(token0, _token0Balance, 0, 0, address(this), block.timestamp);
    }
}",923
RealWorld_BA_31_SettAccessControlDefended_RealWord_20240819155535.log,31,SettAccessControlDefended,5439,4843,10282,87.0,0.124055,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.11;

import ""./SettAccessControl.sol"";

/*
    Add ability to prevent unwanted contract access to Sett permissions
*/
contract SettAccessControlDefended is SettAccessControl {
    mapping(address => bool) public approved;

    function approveContractAccess(address account) external {
        _onlyGovernance();
        approved[account] = true;
    }

    function revokeContractAccess(address account) external {
        _onlyGovernance();
        approved[account] = false;
    }

    function _defend() internal view returns (bool) {
        require(
            approved[msg.sender] || msg.sender == tx.origin,
            ""Access denied for caller""
        );
    }

    uint256[50] private __gap;
}",163
RealWorld_BA_31_Pausable_RealWord_20240819170556.log,31,Pausable,10988,4707,15695,92.0,0.14908,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../GSN/Context.sol"";

/**
 * @dev Contract module which allows children to implement an emergency stop
 * mechanism that can be triggered by an authorized account.
 *
 * This module is used through inheritance. It will make available the
 * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
 * the functions of your contract. Note that they will not be pausable by
 * simply including this module, only once the modifiers are put in place.
 */
contract Pausable is Context {
    /**
     * @dev Emitted when the pause is triggered by `account`.
     */
    event Paused(address account);

    /**
     * @dev Emitted when the pause is lifted by `account`.
     */
    event Unpaused(address account);

    bool private _paused;

    /**
     * @dev Initializes the contract in unpaused state.
     */
    constructor() internal {
        _paused = false;
    }

    /**
     * @dev Returns true if the contract is paused, and false otherwise.
     */
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    modifier whenNotPaused() {
        require(!_paused, ""Pausable: paused"");
        _;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is paused.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    modifier whenPaused() {
        require(_paused, ""Pausable: not paused"");
        _;
    }

    /**
     * @dev Triggers stopped state.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(_msgSender());
    }

    /**
     * @dev Returns to normal state.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(_msgSender());
    }
}",490
RealWorld_BA_31_ISettAccessControlDefended_RealWord_20240819211534.log,31,ISettAccessControlDefended,3771,4197,7968,104.0,0.102795,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.11;

interface ISettAccessControlDefended {
    function approveContractAccess(address account) external;

    function revokeContractAccess(address account) external;
}",46
RealWorld_BA_31_TokenTimelockUpgradeable_RealWord_20240819181512.log,31,TokenTimelockUpgradeable,11630,5334,16964,124.0,0.16483,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./SafeERC20Upgradeable.sol"";
import ""../../proxy/Initializable.sol"";

/**
 * @dev A token holder contract that will allow a beneficiary to extract the
 * tokens after a given release time.
 *
 * Useful for simple vesting schedules like ""advisors get all of their tokens
 * after 1 year"".
 */
contract TokenTimelockUpgradeable is Initializable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    // ERC20 basic token contract being held
    IERC20Upgradeable private _token;

    // beneficiary of tokens after they are released
    address private _beneficiary;

    // timestamp when token release is enabled
    uint256 private _releaseTime;

    function __TokenTimelock_init(
        IERC20Upgradeable token,
        address beneficiary,
        uint256 releaseTime
    ) internal initializer {
        __TokenTimelock_init_unchained(token, beneficiary, releaseTime);
    }

    function __TokenTimelock_init_unchained(
        IERC20Upgradeable token,
        address beneficiary,
        uint256 releaseTime
    ) internal initializer {
        // solhint-disable-next-line not-rely-on-time
        require(
            releaseTime > block.timestamp,
            ""TokenTimelock: release time is before current time""
        );
        _token = token;
        _beneficiary = beneficiary;
        _releaseTime = releaseTime;
    }

    /**
     * @return the token being held.
     */
    function token() public view returns (IERC20Upgradeable) {
        return _token;
    }

    /**
     * @return the beneficiary of the tokens.
     */
    function beneficiary() public view returns (address) {
        return _beneficiary;
    }

    /**
     * @return the time when the tokens are released.
     */
    function releaseTime() public view returns (uint256) {
        return _releaseTime;
    }

    /**
     * @notice Transfers tokens held by timelock to beneficiary.
     */
    function release() public virtual {
        // solhint-disable-next-line not-rely-on-time
        require(
            block.timestamp >= _releaseTime,
            ""TokenTimelock: current time is before release time""
        );

        uint256 amount = _token.balanceOf(address(this));
        require(amount > 0, ""TokenTimelock: no tokens to release"");

        _token.safeTransfer(_beneficiary, amount);
    }

    uint256[47] private __gap;
}",536
RealWorld_BA_31_IUniswapV2Factory_RealWord_20240819204446.log,31,IUniswapV2Factory,5487,4489,9976,92.0,0.117215,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface IUniswapV2Factory {
    event PairCreated(
        address indexed token0,
        address indexed token1,
        address pair,
        uint256
    );

    function getPair(address tokenA, address tokenB)
        external
        view
        returns (address pair);

    function allPairs(uint256) external view returns (address pair);

    function allPairsLength() external view returns (uint256);

    function feeTo() external view returns (address);

    function feeToSetter() external view returns (address);

    function createPair(address tokenA, address tokenB)
        external
        returns (address pair);
}",154
RealWorld_BA_31_SafeCastUpgradeable_RealWord_20240819200333.log,31,SafeCastUpgradeable,30151,4370,34521,140.0,0.238155,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow
 * checks.
 *
 * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can
 * easily result in undesired exploitation or bugs, since developers usually
 * assume that overflows raise errors. `SafeCast` restores this intuition by
 * reverting the transaction when such an operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 *
 * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing
 * all math on `uint256` and `int256` and then downcasting.
 */
library SafeCastUpgradeable {
    /**
     * @dev Returns the downcasted uint128 from uint256, reverting on
     * overflow (when the input is greater than largest uint128).
     *
     * Counterpart to Solidity's `uint128` operator.
     *
     * Requirements:
     *
     * - input must fit into 128 bits
     */
    function toUint128(uint256 value) internal pure returns (uint128) {
        require(value < 2**128, ""SafeCast: value doesn't fit in 128 bits"");
        return uint128(value);
    }

    /**
     * @dev Returns the downcasted uint64 from uint256, reverting on
     * overflow (when the input is greater than largest uint64).
     *
     * Counterpart to Solidity's `uint64` operator.
     *
     * Requirements:
     *
     * - input must fit into 64 bits
     */
    function toUint64(uint256 value) internal pure returns (uint64) {
        require(value < 2**64, ""SafeCast: value doesn't fit in 64 bits"");
        return uint64(value);
    }

    /**
     * @dev Returns the downcasted uint32 from uint256, reverting on
     * overflow (when the input is greater than largest uint32).
     *
     * Counterpart to Solidity's `uint32` operator.
     *
     * Requirements:
     *
     * - input must fit into 32 bits
     */
    function toUint32(uint256 value) internal pure returns (uint32) {
        require(value < 2**32, ""SafeCast: value doesn't fit in 32 bits"");
        return uint32(value);
    }

    /**
     * @dev Returns the downcasted uint16 from uint256, reverting on
     * overflow (when the input is greater than largest uint16).
     *
     * Counterpart to Solidity's `uint16` operator.
     *
     * Requirements:
     *
     * - input must fit into 16 bits
     */
    function toUint16(uint256 value) internal pure returns (uint16) {
        require(value < 2**16, ""SafeCast: value doesn't fit in 16 bits"");
        return uint16(value);
    }

    /**
     * @dev Returns the downcasted uint8 from uint256, reverting on
     * overflow (when the input is greater than largest uint8).
     *
     * Counterpart to Solidity's `uint8` operator.
     *
     * Requirements:
     *
     * - input must fit into 8 bits.
     */
    function toUint8(uint256 value) internal pure returns (uint8) {
        require(value < 2**8, ""SafeCast: value doesn't fit in 8 bits"");
        return uint8(value);
    }

    /**
     * @dev Converts a signed int256 into an unsigned uint256.
     *
     * Requirements:
     *
     * - input must be greater than or equal to 0.
     */
    function toUint256(int256 value) internal pure returns (uint256) {
        require(value >= 0, ""SafeCast: value must be positive"");
        return uint256(value);
    }

    /**
     * @dev Returns the downcasted int128 from int256, reverting on
     * overflow (when the input is less than smallest int128 or
     * greater than largest int128).
     *
     * Counterpart to Solidity's `int128` operator.
     *
     * Requirements:
     *
     * - input must fit into 128 bits
     *
     * _Available since v3.1._
     */
    function toInt128(int256 value) internal pure returns (int128) {
        require(
            value >= -2**127 && value < 2**127,
            ""SafeCast: value doesn't fit in 128 bits""
        );
        return int128(value);
    }

    /**
     * @dev Returns the downcasted int64 from int256, reverting on
     * overflow (when the input is less than smallest int64 or
     * greater than largest int64).
     *
     * Counterpart to Solidity's `int64` operator.
     *
     * Requirements:
     *
     * - input must fit into 64 bits
     *
     * _Available since v3.1._
     */
    function toInt64(int256 value) internal pure returns (int64) {
        require(
            value >= -2**63 && value < 2**63,
            ""SafeCast: value doesn't fit in 64 bits""
        );
        return int64(value);
    }

    /**
     * @dev Returns the downcasted int32 from int256, reverting on
     * overflow (when the input is less than smallest int32 or
     * greater than largest int32).
     *
     * Counterpart to Solidity's `int32` operator.
     *
     * Requirements:
     *
     * - input must fit into 32 bits
     *
     * _Available since v3.1._
     */
    function toInt32(int256 value) internal pure returns (int32) {
        require(
            value >= -2**31 && value < 2**31,
            ""SafeCast: value doesn't fit in 32 bits""
        );
        return int32(value);
    }

    /**
     * @dev Returns the downcasted int16 from int256, reverting on
     * overflow (when the input is less than smallest int16 or
     * greater than largest int16).
     *
     * Counterpart to Solidity's `int16` operator.
     *
     * Requirements:
     *
     * - input must fit into 16 bits
     *
     * _Available since v3.1._
     */
    function toInt16(int256 value) internal pure returns (int16) {
        require(
            value >= -2**15 && value < 2**15,
            ""SafeCast: value doesn't fit in 16 bits""
        );
        return int16(value);
    }

    /**
     * @dev Returns the downcasted int8 from int256, reverting on
     * overflow (when the input is less than smallest int8 or
     * greater than largest int8).
     *
     * Counterpart to Solidity's `int8` operator.
     *
     * Requirements:
     *
     * - input must fit into 8 bits.
     *
     * _Available since v3.1._
     */
    function toInt8(int256 value) internal pure returns (int8) {
        require(
            value >= -2**7 && value < 2**7,
            ""SafeCast: value doesn't fit in 8 bits""
        );
        return int8(value);
    }

    /**
     * @dev Converts an unsigned uint256 into a signed int256.
     *
     * Requirements:
     *
     * - input must be less than or equal to maxInt256.
     */
    function toInt256(uint256 value) internal pure returns (int256) {
        require(value < 2**255, ""SafeCast: value doesn't fit in an int256"");
        return int256(value);
    }
}",1709
RealWorld_BA_31_Proxy_RealWord_20240819164100.log,31,Proxy,14305,4943,19248,80.0,0.170385,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM
 * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to
 * be specified by overriding the virtual {_implementation} function.
 *
 * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a
 * different contract through the {_delegate} function.
 *
 * The success and return data of the delegated call will be returned back to the caller of the proxy.
 */
abstract contract Proxy {
    /**
     * @dev Delegates the current call to `implementation`.
     *
     * This function does not return to its internall call site, it will return directly to the external caller.
     */
    function _delegate(address implementation) internal {
        // solhint-disable-next-line no-inline-assembly
        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(
                gas(),
                implementation,
                0,
                calldatasize(),
                0,
                0
            )

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize())
                }
                default {
                    return(0, returndatasize())
                }
        }
    }

    /**
     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function
     * and {_fallback} should delegate.
     */
    function _implementation() internal view virtual returns (address);

    /**
     * @dev Delegates the current call to the address returned by `_implementation()`.
     *
     * This function does not return to its internall call site, it will return directly to the external caller.
     */
    function _fallback() internal {
        _beforeFallback();
        _delegate(_implementation());
    }

    /**
     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other
     * function in the contract matches the call data.
     */
    fallback() external payable {
        _fallback();
    }

    /**
     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data
     * is empty.
     */
    receive() external payable {
        _fallback();
    }

    /**
     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`
     * call, or as part of the Solidity `fallback` or `receive` functions.
     *
     * If overriden should call `super._beforeFallback()`.
     */
    function _beforeFallback() internal virtual {}
}",689
RealWorld_BA_31_GSNRecipientSignature_RealWord_20240819164502.log,31,GSNRecipientSignature,11982,5053,17035,79.0,0.16097,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./GSNRecipient.sol"";
import ""../cryptography/ECDSA.sol"";

/**
 * @dev A xref:ROOT:gsn-strategies.adoc#gsn-strategies[GSN strategy] that allows relayed transactions through when they are
 * accompanied by the signature of a trusted signer. The intent is for this signature to be generated by a server that
 * performs validations off-chain. Note that nothing is charged to the user in this scheme. Thus, the server should make
 * sure to account for this in their economic and threat model.
 */
contract GSNRecipientSignature is GSNRecipient {
    using ECDSA for bytes32;

    address private _trustedSigner;

    enum GSNRecipientSignatureErrorCodes {INVALID_SIGNER}

    /**
     * @dev Sets the trusted signer that is going to be producing signatures to approve relayed calls.
     */
    constructor(address trustedSigner) public {
        require(
            trustedSigner != address(0),
            ""GSNRecipientSignature: trusted signer is the zero address""
        );
        _trustedSigner = trustedSigner;
    }

    /**
     * @dev Ensures that only transactions with a trusted signature can be relayed through the GSN.
     */
    function acceptRelayedCall(
        address relay,
        address from,
        bytes memory encodedFunction,
        uint256 transactionFee,
        uint256 gasPrice,
        uint256 gasLimit,
        uint256 nonce,
        bytes memory approvalData,
        uint256
    ) public view virtual override returns (uint256, bytes memory) {
        bytes memory blob =
            abi.encodePacked(
                relay,
                from,
                encodedFunction,
                transactionFee,
                gasPrice,
                gasLimit,
                nonce, // Prevents replays on RelayHub
                getHubAddr(), // Prevents replays in multiple RelayHubs
                address(this) // Prevents replays in multiple recipients
            );
        if (
            keccak256(blob).toEthSignedMessageHash().recover(approvalData) ==
            _trustedSigner
        ) {
            return _approveRelayedCall();
        } else {
            return
                _rejectRelayedCall(
                    uint256(GSNRecipientSignatureErrorCodes.INVALID_SIGNER)
                );
        }
    }

    function _preRelayedCall(bytes memory)
        internal
        virtual
        override
        returns (bytes32)
    {}

    function _postRelayedCall(
        bytes memory,
        bool,
        uint256,
        bytes32
    ) internal virtual override {}
}",544
RealWorld_BA_31_GSNRecipientERC20FeeUpgradeable_RealWord_20240819192628.log,31,GSNRecipientERC20FeeUpgradeable,30285,5387,35672,138.0,0.259165,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./GSNRecipientUpgradeable.sol"";
import ""../math/SafeMathUpgradeable.sol"";
import ""../access/OwnableUpgradeable.sol"";
import ""../token/ERC20/SafeERC20Upgradeable.sol"";
import ""../token/ERC20/ERC20Upgradeable.sol"";
import ""../proxy/Initializable.sol"";

/**
 * @dev A xref:ROOT:gsn-strategies.adoc#gsn-strategies[GSN strategy] that charges transaction fees in a special purpose ERC20
 * token, which we refer to as the gas payment token. The amount charged is exactly the amount of Ether charged to the
 * recipient. This means that the token is essentially pegged to the value of Ether.
 *
 * The distribution strategy of the gas payment token to users is not defined by this contract. It's a mintable token
 * whose only minter is the recipient, so the strategy must be implemented in a derived contract, making use of the
 * internal {_mint} function.
 */
contract GSNRecipientERC20FeeUpgradeable is
    Initializable,
    GSNRecipientUpgradeable
{
    using SafeERC20Upgradeable for __unstable__ERC20OwnedUpgradeable;
    using SafeMathUpgradeable for uint256;

    enum GSNRecipientERC20FeeErrorCodes {INSUFFICIENT_BALANCE}

    __unstable__ERC20OwnedUpgradeable private _token;

    /**
     * @dev The arguments to the constructor are the details that the gas payment token will have: `name` and `symbol`. `decimals` is hard-coded to 18.
     */
    function __GSNRecipientERC20Fee_init(
        string memory name,
        string memory symbol
    ) internal initializer {
        __Context_init_unchained();
        __GSNRecipient_init_unchained();
        __GSNRecipientERC20Fee_init_unchained(name, symbol);
    }

    function __GSNRecipientERC20Fee_init_unchained(
        string memory name,
        string memory symbol
    ) internal initializer {
        _token = new __unstable__ERC20OwnedUpgradeable();
        _token.initialize(name, symbol);
    }

    /**
     * @dev Returns the gas payment token.
     */
    function token() public view returns (IERC20Upgradeable) {
        return IERC20Upgradeable(_token);
    }

    /**
     * @dev Internal function that mints the gas payment token. Derived contracts should expose this function in their public API, with proper access control mechanisms.
     */
    function _mint(address account, uint256 amount) internal virtual {
        _token.mint(account, amount);
    }

    /**
     * @dev Ensures that only users with enough gas payment token balance can have transactions relayed through the GSN.
     */
    function acceptRelayedCall(
        address,
        address from,
        bytes memory,
        uint256 transactionFee,
        uint256 gasPrice,
        uint256,
        uint256,
        bytes memory,
        uint256 maxPossibleCharge
    ) public view virtual override returns (uint256, bytes memory) {
        if (_token.balanceOf(from) < maxPossibleCharge) {
            return
                _rejectRelayedCall(
                    uint256(GSNRecipientERC20FeeErrorCodes.INSUFFICIENT_BALANCE)
                );
        }

        return
            _approveRelayedCall(
                abi.encode(from, maxPossibleCharge, transactionFee, gasPrice)
            );
    }

    /**
     * @dev Implements the precharge to the user. The maximum possible charge (depending on gas limit, gas price, and
     * fee) will be deducted from the user balance of gas payment token. Note that this is an overestimation of the
     * actual charge, necessary because we cannot predict how much gas the execution will actually need. The remainder
     * is returned to the user in {_postRelayedCall}.
     */
    function _preRelayedCall(bytes memory context)
        internal
        virtual
        override
        returns (bytes32)
    {
        (address from, uint256 maxPossibleCharge) =
            abi.decode(context, (address, uint256));

        // The maximum token charge is pre-charged from the user
        _token.safeTransferFrom(from, address(this), maxPossibleCharge);
    }

    /**
     * @dev Returns to the user the extra amount that was previously charged, once the actual execution cost is known.
     */
    function _postRelayedCall(
        bytes memory context,
        bool,
        uint256 actualCharge,
        bytes32
    ) internal virtual override {
        (
            address from,
            uint256 maxPossibleCharge,
            uint256 transactionFee,
            uint256 gasPrice
        ) = abi.decode(context, (address, uint256, uint256, uint256));

        // actualCharge is an _estimated_ charge, which assumes postRelayedCall will use all available gas.
        // This implementation's gas cost can be roughly estimated as 10k gas, for the two SSTORE operations in an
        // ERC20 transfer.
        uint256 overestimation =
            _computeCharge(
                _POST_RELAYED_CALL_MAX_GAS.sub(10000),
                gasPrice,
                transactionFee
            );
        actualCharge = actualCharge.sub(overestimation);

        // After the relayed call has been executed and the actual charge estimated, the excess pre-charge is returned
        _token.safeTransfer(from, maxPossibleCharge.sub(actualCharge));
    }

    uint256[49] private __gap;
}

/**
 * @title __unstable__ERC20Owned
 * @dev An ERC20 token owned by another contract, which has minting permissions and can use transferFrom to receive
 * anyone's tokens. This contract is an internal helper for GSNRecipientERC20Fee, and should not be used
 * outside of this context.
 */
// solhint-disable-next-line contract-name-camelcase
contract __unstable__ERC20OwnedUpgradeable is
    Initializable,
    ERC20Upgradeable,
    OwnableUpgradeable
{
    function initialize(string memory name, string memory symbol)
        public
        virtual
        initializer
    {
        ____unstable__ERC20Owned_init(name, symbol);
    }

    uint256 private constant _UINT256_MAX = 2**256 - 1;

    function ____unstable__ERC20Owned_init(
        string memory name,
        string memory symbol
    ) internal initializer {
        __Context_init_unchained();
        __ERC20_init_unchained(name, symbol);
        __Ownable_init_unchained();
        ____unstable__ERC20Owned_init_unchained(name, symbol);
    }

    function ____unstable__ERC20Owned_init_unchained(
        string memory name,
        string memory symbol
    ) internal initializer {}

    // The owner (GSNRecipientERC20Fee) can mint tokens
    function mint(address account, uint256 amount) public onlyOwner {
        _mint(account, amount);
    }

    // The owner has 'infinite' allowance for all token holders
    function allowance(address tokenOwner, address spender)
        public
        view
        override
        returns (uint256)
    {
        if (spender == owner()) {
            return _UINT256_MAX;
        } else {
            return super.allowance(tokenOwner, spender);
        }
    }

    // Allowance for the owner cannot be changed (it is always 'infinite')
    function _approve(
        address tokenOwner,
        address spender,
        uint256 value
    ) internal override {
        if (spender == owner()) {
            return;
        } else {
            super._approve(tokenOwner, spender, value);
        }
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public override returns (bool) {
        if (recipient == owner()) {
            _transfer(sender, recipient, amount);
            return true;
        } else {
            return super.transferFrom(sender, recipient, amount);
        }
    }

    uint256[50] private __gap;
}",1695
RealWorld_BA_31_SafeERC20_RealWord_20240819160247.log,31,SafeERC20,17445,5123,22568,73.0,0.189685,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./IERC20.sol"";
import ""../../math/SafeMath.sol"";
import ""../../utils/Address.sol"";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transfer.selector, to, value)
        );
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)
        );
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            ""SafeERC20: approve from non-zero to non-zero allowance""
        );
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.approve.selector, spender, value)
        );
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance =
            token.allowance(address(this), spender).add(value);
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(
                token.approve.selector,
                spender,
                newAllowance
            )
        );
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance =
            token.allowance(address(this), spender).sub(
                value,
                ""SafeERC20: decreased allowance below zero""
            );
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(
                token.approve.selector,
                spender,
                newAllowance
            )
        );
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata =
            address(token).functionCall(
                data,
                ""SafeERC20: low-level call failed""
            );
        if (returndata.length > 0) {
            // Return data is optional
            // solhint-disable-next-line max-line-length
            require(
                abi.decode(returndata, (bool)),
                ""SafeERC20: ERC20 operation did not succeed""
            );
        }
    }
}",930
RealWorld_BA_31_Ownable_RealWord_20240819164222.log,31,Ownable,11031,4670,15701,72.0,0.148555,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../GSN/Context.sol"";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(_owner == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(
            newOwner != address(0),
            ""Ownable: new owner is the zero address""
        );
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}",497
RealWorld_BA_31_SafeCast_RealWord_20240819171819.log,31,SafeCast,30095,4493,34588,93.0,0.240335,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow
 * checks.
 *
 * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can
 * easily result in undesired exploitation or bugs, since developers usually
 * assume that overflows raise errors. `SafeCast` restores this intuition by
 * reverting the transaction when such an operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 *
 * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing
 * all math on `uint256` and `int256` and then downcasting.
 */
library SafeCast {
    /**
     * @dev Returns the downcasted uint128 from uint256, reverting on
     * overflow (when the input is greater than largest uint128).
     *
     * Counterpart to Solidity's `uint128` operator.
     *
     * Requirements:
     *
     * - input must fit into 128 bits
     */
    function toUint128(uint256 value) internal pure returns (uint128) {
        require(value < 2**128, ""SafeCast: value doesn't fit in 128 bits"");
        return uint128(value);
    }

    /**
     * @dev Returns the downcasted uint64 from uint256, reverting on
     * overflow (when the input is greater than largest uint64).
     *
     * Counterpart to Solidity's `uint64` operator.
     *
     * Requirements:
     *
     * - input must fit into 64 bits
     */
    function toUint64(uint256 value) internal pure returns (uint64) {
        require(value < 2**64, ""SafeCast: value doesn't fit in 64 bits"");
        return uint64(value);
    }

    /**
     * @dev Returns the downcasted uint32 from uint256, reverting on
     * overflow (when the input is greater than largest uint32).
     *
     * Counterpart to Solidity's `uint32` operator.
     *
     * Requirements:
     *
     * - input must fit into 32 bits
     */
    function toUint32(uint256 value) internal pure returns (uint32) {
        require(value < 2**32, ""SafeCast: value doesn't fit in 32 bits"");
        return uint32(value);
    }

    /**
     * @dev Returns the downcasted uint16 from uint256, reverting on
     * overflow (when the input is greater than largest uint16).
     *
     * Counterpart to Solidity's `uint16` operator.
     *
     * Requirements:
     *
     * - input must fit into 16 bits
     */
    function toUint16(uint256 value) internal pure returns (uint16) {
        require(value < 2**16, ""SafeCast: value doesn't fit in 16 bits"");
        return uint16(value);
    }

    /**
     * @dev Returns the downcasted uint8 from uint256, reverting on
     * overflow (when the input is greater than largest uint8).
     *
     * Counterpart to Solidity's `uint8` operator.
     *
     * Requirements:
     *
     * - input must fit into 8 bits.
     */
    function toUint8(uint256 value) internal pure returns (uint8) {
        require(value < 2**8, ""SafeCast: value doesn't fit in 8 bits"");
        return uint8(value);
    }

    /**
     * @dev Converts a signed int256 into an unsigned uint256.
     *
     * Requirements:
     *
     * - input must be greater than or equal to 0.
     */
    function toUint256(int256 value) internal pure returns (uint256) {
        require(value >= 0, ""SafeCast: value must be positive"");
        return uint256(value);
    }

    /**
     * @dev Returns the downcasted int128 from int256, reverting on
     * overflow (when the input is less than smallest int128 or
     * greater than largest int128).
     *
     * Counterpart to Solidity's `int128` operator.
     *
     * Requirements:
     *
     * - input must fit into 128 bits
     *
     * _Available since v3.1._
     */
    function toInt128(int256 value) internal pure returns (int128) {
        require(
            value >= -2**127 && value < 2**127,
            ""SafeCast: value doesn't fit in 128 bits""
        );
        return int128(value);
    }

    /**
     * @dev Returns the downcasted int64 from int256, reverting on
     * overflow (when the input is less than smallest int64 or
     * greater than largest int64).
     *
     * Counterpart to Solidity's `int64` operator.
     *
     * Requirements:
     *
     * - input must fit into 64 bits
     *
     * _Available since v3.1._
     */
    function toInt64(int256 value) internal pure returns (int64) {
        require(
            value >= -2**63 && value < 2**63,
            ""SafeCast: value doesn't fit in 64 bits""
        );
        return int64(value);
    }

    /**
     * @dev Returns the downcasted int32 from int256, reverting on
     * overflow (when the input is less than smallest int32 or
     * greater than largest int32).
     *
     * Counterpart to Solidity's `int32` operator.
     *
     * Requirements:
     *
     * - input must fit into 32 bits
     *
     * _Available since v3.1._
     */
    function toInt32(int256 value) internal pure returns (int32) {
        require(
            value >= -2**31 && value < 2**31,
            ""SafeCast: value doesn't fit in 32 bits""
        );
        return int32(value);
    }

    /**
     * @dev Returns the downcasted int16 from int256, reverting on
     * overflow (when the input is less than smallest int16 or
     * greater than largest int16).
     *
     * Counterpart to Solidity's `int16` operator.
     *
     * Requirements:
     *
     * - input must fit into 16 bits
     *
     * _Available since v3.1._
     */
    function toInt16(int256 value) internal pure returns (int16) {
        require(
            value >= -2**15 && value < 2**15,
            ""SafeCast: value doesn't fit in 16 bits""
        );
        return int16(value);
    }

    /**
     * @dev Returns the downcasted int8 from int256, reverting on
     * overflow (when the input is less than smallest int8 or
     * greater than largest int8).
     *
     * Counterpart to Solidity's `int8` operator.
     *
     * Requirements:
     *
     * - input must fit into 8 bits.
     *
     * _Available since v3.1._
     */
    function toInt8(int256 value) internal pure returns (int8) {
        require(
            value >= -2**7 && value < 2**7,
            ""SafeCast: value doesn't fit in 8 bits""
        );
        return int8(value);
    }

    /**
     * @dev Converts an unsigned uint256 into a signed int256.
     *
     * Requirements:
     *
     * - input must be less than or equal to maxInt256.
     */
    function toInt256(uint256 value) internal pure returns (int256) {
        require(value < 2**255, ""SafeCast: value doesn't fit in an int256"");
        return int256(value);
    }
}",1707
RealWorld_BA_31_SignedSafeMathUpgradeable_RealWord_20240819201936.log,31,SignedSafeMathUpgradeable,14377,4854,19231,111.0,0.168965,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @title SignedSafeMath
 * @dev Signed math operations with safety checks that revert on error.
 */
library SignedSafeMathUpgradeable {
    int256 private constant _INT256_MIN = -2**255;

    /**
     * @dev Returns the multiplication of two signed integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(int256 a, int256 b) internal pure returns (int256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        require(
            !(a == -1 && b == _INT256_MIN),
            ""SignedSafeMath: multiplication overflow""
        );

        int256 c = a * b;
        require(c / a == b, ""SignedSafeMath: multiplication overflow"");

        return c;
    }

    /**
     * @dev Returns the integer division of two signed integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(int256 a, int256 b) internal pure returns (int256) {
        require(b != 0, ""SignedSafeMath: division by zero"");
        require(
            !(b == -1 && a == _INT256_MIN),
            ""SignedSafeMath: division overflow""
        );

        int256 c = a / b;

        return c;
    }

    /**
     * @dev Returns the subtraction of two signed integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(int256 a, int256 b) internal pure returns (int256) {
        int256 c = a - b;
        require(
            (b >= 0 && c <= a) || (b < 0 && c > a),
            ""SignedSafeMath: subtraction overflow""
        );

        return c;
    }

    /**
     * @dev Returns the addition of two signed integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(int256 a, int256 b) internal pure returns (int256) {
        int256 c = a + b;
        require(
            (b >= 0 && c >= a) || (b < 0 && c < a),
            ""SignedSafeMath: addition overflow""
        );

        return c;
    }
}",696
RealWorld_BA_31_IERC1155Upgradeable_RealWord_20240819185419.log,31,IERC1155Upgradeable,19118,5462,24580,137.0,0.20483,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""../../introspection/IERC165Upgradeable.sol"";

/**
 * @dev Required interface of an ERC1155 compliant contract, as defined in the
 * https://eips.ethereum.org/EIPS/eip-1155[EIP].
 *
 * _Available since v3.1._
 */
interface IERC1155Upgradeable is IERC165Upgradeable {
    /**
     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.
     */
    event TransferSingle(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256 id,
        uint256 value
    );

    /**
     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all
     * transfers.
     */
    event TransferBatch(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256[] ids,
        uint256[] values
    );

    /**
     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to
     * `approved`.
     */
    event ApprovalForAll(
        address indexed account,
        address indexed operator,
        bool approved
    );

    /**
     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.
     *
     * If an {URI} event was emitted for `id`, the standard
     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value
     * returned by {IERC1155MetadataURI-uri}.
     */
    event URI(string value, uint256 indexed id);

    /**
     * @dev Returns the amount of tokens of token type `id` owned by `account`.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function balanceOf(address account, uint256 id)
        external
        view
        returns (uint256);

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.
     *
     * Requirements:
     *
     * - `accounts` and `ids` must have the same length.
     */
    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)
        external
        view
        returns (uint256[] memory);

    /**
     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,
     *
     * Emits an {ApprovalForAll} event.
     *
     * Requirements:
     *
     * - `operator` cannot be the caller.
     */
    function setApprovalForAll(address operator, bool approved) external;

    /**
     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.
     *
     * See {setApprovalForAll}.
     */
    function isApprovedForAll(address account, address operator)
        external
        view
        returns (bool);

    /**
     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.
     * - `from` must have a balance of tokens of type `id` of at least `amount`.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes calldata data
    ) external;

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.
     *
     * Emits a {TransferBatch} event.
     *
     * Requirements:
     *
     * - `ids` and `amounts` must have the same length.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
     * acceptance magic value.
     */
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts,
        bytes calldata data
    ) external;
}",1028
RealWorld_BA_31_TokenSwapPathRegistry_RealWord_20240819220132.log,31,TokenSwapPathRegistry,8014,5151,13165,125.0,0.14309,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.11;

import ""deps/@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""interfaces/curve/ICurveFi.sol"";

/*
    Expands swapping functionality over base strategy
    - ETH in and ETH out Variants
    - Sushiswap support in addition to Uniswap
*/
contract TokenSwapPathRegistry {
    mapping(address => mapping(address => address[])) public tokenSwapPaths;

    event TokenSwapPathSet(address tokenIn, address tokenOut, address[] path);

    function getTokenSwapPath(address tokenIn, address tokenOut) public view returns (address[] memory) {
        return tokenSwapPaths[tokenIn][tokenOut];
    }

    function _setTokenSwapPath(
        address tokenIn,
        address tokenOut,
        address[] memory path
    ) internal {
        tokenSwapPaths[tokenIn][tokenOut] = path;
        emit TokenSwapPathSet(tokenIn, tokenOut, path);
    }
}",301
RealWorld_BA_31_IController_RealWord_20240819215219.log,31,IController,4510,4645,9155,119.0,0.11545,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface IController {
    function withdraw(address, uint256) external;

    function strategies(address) external view returns (address);

    function balanceOf(address) external view returns (uint256);

    function earn(address, uint256) external;

    function want(address) external view returns (address);

    function rewards() external view returns (address);

    function vaults(address) external view returns (address);
}",104
RealWorld_BA_31_SignedSafeMath_RealWord_20240819173142.log,31,SignedSafeMath,13904,4560,18464,110.0,0.16072,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @title SignedSafeMath
 * @dev Signed math operations with safety checks that revert on error.
 */
library SignedSafeMath {
    int256 private constant _INT256_MIN = -2**255;

    /**
     * @dev Returns the multiplication of two signed integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(int256 a, int256 b) internal pure returns (int256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        require(
            !(a == -1 && b == _INT256_MIN),
            ""SignedSafeMath: multiplication overflow""
        );

        int256 c = a * b;
        require(c / a == b, ""SignedSafeMath: multiplication overflow"");

        return c;
    }

    /**
     * @dev Returns the integer division of two signed integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(int256 a, int256 b) internal pure returns (int256) {
        require(b != 0, ""SignedSafeMath: division by zero"");
        require(
            !(b == -1 && a == _INT256_MIN),
            ""SignedSafeMath: division overflow""
        );

        int256 c = a / b;

        return c;
    }

    /**
     * @dev Returns the subtraction of two signed integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(int256 a, int256 b) internal pure returns (int256) {
        int256 c = a - b;
        require(
            (b >= 0 && c <= a) || (b < 0 && c > a),
            ""SignedSafeMath: subtraction overflow""
        );

        return c;
    }

    /**
     * @dev Returns the addition of two signed integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(int256 a, int256 b) internal pure returns (int256) {
        int256 c = a + b;
        require(
            (b >= 0 && c >= a) || (b < 0 && c < a),
            ""SignedSafeMath: addition overflow""
        );

        return c;
    }
}",694
RealWorld_BA_31_IStakingRewardsSignalOnly_RealWord_20240819212229.log,31,IStakingRewardsSignalOnly,4716,4666,9382,102.0,0.1169,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface IStakingRewardsSignalOnly {
    function stakingToken() external view returns (address);

    function rewardsToken() external view returns (address);

    function withdraw(uint256) external;

    function getReward() external;

    function earned(address account) external view returns (uint256);

    function stake(uint256) external;

    function balanceOf(address) external view returns (uint256);

    function exit() external;
}",110
RealWorld_BA_31_IERC1155MetadataURIUpgradeable_RealWord_20240819190024.log,31,IERC1155MetadataURIUpgradeable,5562,4214,9776,102.0,0.11209,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""./IERC1155Upgradeable.sol"";

/**
 * @dev Interface of the optional ERC1155MetadataExtension interface, as defined
 * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].
 *
 * _Available since v3.1._
 */
interface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {
    /**
     * @dev Returns the URI for token type `id`.
     *
     * If the `\{id\}` substring is present in the URI, it must be replaced by
     * clients with the actual token type ID.
     */
    function uri(uint256 id) external view returns (string memory);
}",162
RealWorld_BA_31_PullPaymentUpgradeable_RealWord_20240819193529.log,31,PullPaymentUpgradeable,13821,5240,19061,128.0,0.173905,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""./escrow/EscrowUpgradeable.sol"";
import ""../proxy/Initializable.sol"";

/**
 * @dev Simple implementation of a
 * https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls[pull-payment]
 * strategy, where the paying contract doesn't interact directly with the
 * receiver account, which must withdraw its payments itself.
 *
 * Pull-payments are often considered the best practice when it comes to sending
 * Ether, security-wise. It prevents recipients from blocking execution, and
 * eliminates reentrancy concerns.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 *
 * To use, derive from the `PullPayment` contract, and use {_asyncTransfer}
 * instead of Solidity's `transfer` function. Payees can query their due
 * payments with {payments}, and retrieve them with {withdrawPayments}.
 */
contract PullPaymentUpgradeable is Initializable {
    EscrowUpgradeable private _escrow;

    function __PullPayment_init() internal initializer {
        __PullPayment_init_unchained();
    }

    function __PullPayment_init_unchained() internal initializer {
        _escrow = new EscrowUpgradeable();
        _escrow.initialize();
    }

    /**
     * @dev Withdraw accumulated payments, forwarding all gas to the recipient.
     *
     * Note that _any_ account can call this function, not just the `payee`.
     * This means that contracts unaware of the `PullPayment` protocol can still
     * receive funds this way, by having a separate account call
     * {withdrawPayments}.
     *
     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.
     * Make sure you trust the recipient, or are either following the
     * checks-effects-interactions pattern or using {ReentrancyGuard}.
     *
     * @param payee Whose payments will be withdrawn.
     */
    function withdrawPayments(address payable payee) public virtual {
        _escrow.withdraw(payee);
    }

    /**
     * @dev Returns the payments owed to an address.
     * @param dest The creditor's address.
     */
    function payments(address dest) public view returns (uint256) {
        return _escrow.depositsOf(dest);
    }

    /**
     * @dev Called by the payer to store the sent amount as credit to be pulled.
     * Funds sent in this way are stored in an intermediate {Escrow} contract, so
     * there is no danger of them being spent before withdrawal.
     *
     * @param dest The destination address of the funds.
     * @param amount The amount to transfer.
     */
    function _asyncTransfer(address dest, uint256 amount) internal virtual {
        _escrow.deposit{value: amount}(dest);
    }

    uint256[49] private __gap;
}",660
RealWorld_BA_31_IERC721EnumerableUpgradeable_RealWord_20240819183911.log,31,IERC721EnumerableUpgradeable,7819,5133,12952,142.0,0.141755,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""./IERC721Upgradeable.sol"";

/**
 * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */
interface IERC721EnumerableUpgradeable is IERC721Upgradeable {
    /**
     * @dev Returns the total amount of tokens stored by the contract.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.
     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.
     */
    function tokenOfOwnerByIndex(address owner, uint256 index)
        external
        view
        returns (uint256 tokenId);

    /**
     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.
     * Use along with {totalSupply} to enumerate all tokens.
     */
    function tokenByIndex(uint256 index) external view returns (uint256);
}",240
RealWorld_BA_31_IUniswapPair_RealWord_20240819203650.log,31,IUniswapPair,4181,3538,7719,70.0,0.091665,"//SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

interface IUniswapPair {
    function token0() external view returns (address);

    function token1() external view returns (address);

    function getReserves()
        external
        view
        returns (
            uint112 reserve0,
            uint112 reserve1,
            uint32 blockTimestampLast
        );
}",83
RealWorld_BA_31_MathUpgradeable_RealWord_20240819202302.log,31,MathUpgradeable,6745,3985,10730,88.0,0.113425,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Standard math utilities missing in the Solidity language.
 */
library MathUpgradeable {
    /**
     * @dev Returns the largest of two numbers.
     */
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? a : b;
    }

    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two numbers. The result is rounded towards
     * zero.
     */
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow, so we distribute
        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);
    }
}",225
RealWorld_BA_31_RefundEscrow_RealWord_20240819170100.log,31,RefundEscrow,14188,6035,20223,106.0,0.19164,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./ConditionalEscrow.sol"";

/**
 * @title RefundEscrow
 * @dev Escrow that holds funds for a beneficiary, deposited from multiple
 * parties.
 * @dev Intended usage: See {Escrow}. Same usage guidelines apply here.
 * @dev The owner account (that is, the contract that instantiates this
 * contract) may deposit, close the deposit period, and allow for either
 * withdrawal by the beneficiary, or refunds to the depositors. All interactions
 * with `RefundEscrow` will be made through the owner contract.
 */
contract RefundEscrow is ConditionalEscrow {
    enum State {Active, Refunding, Closed}

    event RefundsClosed();
    event RefundsEnabled();

    State private _state;
    address payable private _beneficiary;

    /**
     * @dev Constructor.
     * @param beneficiary The beneficiary of the deposits.
     */
    constructor(address payable beneficiary) public {
        require(
            beneficiary != address(0),
            ""RefundEscrow: beneficiary is the zero address""
        );
        _beneficiary = beneficiary;
        _state = State.Active;
    }

    /**
     * @return The current state of the escrow.
     */
    function state() public view returns (State) {
        return _state;
    }

    /**
     * @return The beneficiary of the escrow.
     */
    function beneficiary() public view returns (address) {
        return _beneficiary;
    }

    /**
     * @dev Stores funds that may later be refunded.
     * @param refundee The address funds will be sent to if a refund occurs.
     */
    function deposit(address refundee) public payable virtual override {
        require(
            _state == State.Active,
            ""RefundEscrow: can only deposit while active""
        );
        super.deposit(refundee);
    }

    /**
     * @dev Allows for the beneficiary to withdraw their funds, rejecting
     * further deposits.
     */
    function close() public virtual onlyOwner {
        require(
            _state == State.Active,
            ""RefundEscrow: can only close while active""
        );
        _state = State.Closed;
        emit RefundsClosed();
    }

    /**
     * @dev Allows for refunds to take place, rejecting further deposits.
     */
    function enableRefunds() public virtual onlyOwner {
        require(
            _state == State.Active,
            ""RefundEscrow: can only enable refunds while active""
        );
        _state = State.Refunding;
        emit RefundsEnabled();
    }

    /**
     * @dev Withdraws the beneficiary's funds.
     */
    function beneficiaryWithdraw() public virtual {
        require(
            _state == State.Closed,
            ""RefundEscrow: beneficiary can only withdraw while closed""
        );
        _beneficiary.transfer(address(this).balance);
    }

    /**
     * @dev Returns whether refundees can withdraw their deposits (be refunded). The overridden function receives a
     * 'payee' argument, but we ignore it here since the condition is global, not per-payee.
     */
    function withdrawalAllowed(address) public view override returns (bool) {
        return _state == State.Refunding;
    }
}",683
RealWorld_BA_31_IERC165Upgradeable_RealWord_20240819201342.log,31,IERC165Upgradeable,6064,3400,9464,95.0,0.09832,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165Upgradeable {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}",195
RealWorld_BA_31_InitializableAdminUpgradeabilityProxy_RealWord_20240819180920.log,31,InitializableAdminUpgradeabilityProxy,8272,5248,13520,119.0,0.14632,"pragma solidity ^0.5.0;

import ""./BaseAdminUpgradeabilityProxy.sol"";
import ""./InitializableUpgradeabilityProxy.sol"";

/**
 * @title InitializableAdminUpgradeabilityProxy
 * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for
 * initializing the implementation, admin, and init data.
 */
contract InitializableAdminUpgradeabilityProxy is
    BaseAdminUpgradeabilityProxy,
    InitializableUpgradeabilityProxy
{
    /**
     * Contract initializer.
     * @param _logic address of the initial implementation.
     * @param _admin Address of the proxy administrator.
     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.
     * It should include the signature and the parameters of the function to be called, as described in
     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.
     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.
     */
    function initialize(
        address _logic,
        address _admin,
        bytes memory _data
    ) public payable {
        require(_implementation() == address(0));
        InitializableUpgradeabilityProxy.initialize(_logic, _data);
        assert(
            ADMIN_SLOT == bytes32(uint256(keccak256(""eip1967.proxy.admin"")) - 1)
        );
        _setAdmin(_admin);
    }
}",306
RealWorld_BA_31_StringsUpgradeable_RealWord_20240819195324.log,31,StringsUpgradeable,6922,3987,10909,95.0,0.11435,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev String operations.
 */
library StringsUpgradeable {
    /**
     * @dev Converts a `uint256` to its ASCII `string` representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return ""0"";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        uint256 index = digits - 1;
        temp = value;
        while (temp != 0) {
            buffer[index--] = bytes1(uint8(48 + (temp % 10)));
            temp /= 10;
        }
        return string(buffer);
    }
}",244
RealWorld_BA_31_OwnableUpgradeable_RealWord_20240819191457.log,31,OwnableUpgradeable,12205,5298,17503,150.0,0.166985,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../GSN/ContextUpgradeable.sol"";
import ""../proxy/Initializable.sol"";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
contract OwnableUpgradeable is Initializable, ContextUpgradeable {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    function __Ownable_init() internal initializer {
        __Context_init_unchained();
        __Ownable_init_unchained();
    }

    function __Ownable_init_unchained() internal initializer {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(_owner == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(
            newOwner != address(0),
            ""Ownable: new owner is the zero address""
        );
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }

    uint256[49] private __gap;
}",561
RealWorld_BA_31_SettV3_RealWord_20240819154703.log,31,SettV3,46764,5642,52406,97.0,0.34666,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.11;

import ""../../deps/@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""../../deps/@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol"";
import ""../../deps/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""../../deps/@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""../../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""../../deps/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""../../deps/@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol"";

import ""interfaces/badger/IController.sol"";
import ""interfaces/erc20/IERC20Detailed.sol"";
import ""../../deps/SettAccessControlDefended.sol"";
import ""interfaces/yearn/BadgerGuestlistApi.sol"";

/* 
    Source: https://github.com/iearn-finance/yearn-protocol/blob/develop/contracts/vaults/yVault.sol
    
    Changelog:

    V1.1
    * Strategist no longer has special function calling permissions
    * Version function added to contract
    * All write functions, with the exception of transfer, are pausable
    * Keeper or governance can pause
    * Only governance can unpause

    V1.2
    * Transfer functions are now pausable along with all other non-permissioned write functions
    * All permissioned write functions, with the exception of pause() & unpause(), are pausable as well

    V1.3
    * Add guest list functionality
    * All deposits can be optionally gated by external guestList approval logic on set guestList contract
*/

contract SettV3 is
    ERC20Upgradeable,
    SettAccessControlDefended,
    PausableUpgradeable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using AddressUpgradeable for address;
    using SafeMathUpgradeable for uint256;

    IERC20Upgradeable public token;

    uint256 public min;
    uint256 public constant max = 10000;

    address public controller;

    mapping(address => uint256) public blockLock;

    string internal constant _defaultNamePrefix = ""Badger Sett "";
    string internal constant _symbolSymbolPrefix = ""b"";

    address public guardian;

    BadgerGuestListAPI public guestList;

    event FullPricePerShareUpdated(
        uint256 value,
        uint256 indexed timestamp,
        uint256 indexed blockNumber
    );

    function initialize(
        address _token,
        address _controller,
        address _governance,
        address _keeper,
        address _guardian,
        bool _overrideTokenName,
        string memory _namePrefix,
        string memory _symbolPrefix
    ) public initializer whenNotPaused {
        IERC20Detailed namedToken = IERC20Detailed(_token);
        string memory tokenName = namedToken.name();
        string memory tokenSymbol = namedToken.symbol();

        string memory name;
        string memory symbol;

        if (_overrideTokenName) {
            name = string(abi.encodePacked(_namePrefix, tokenName));
            symbol = string(abi.encodePacked(_symbolPrefix, tokenSymbol));
        } else {
            name = string(abi.encodePacked(_defaultNamePrefix, tokenName));
            symbol = string(abi.encodePacked(_symbolSymbolPrefix, tokenSymbol));
        }

        __ERC20_init(name, symbol);

        token = IERC20Upgradeable(_token);
        governance = _governance;
        strategist = address(0);
        keeper = _keeper;
        controller = _controller;
        guardian = _guardian;

        min = 9500;

        emit FullPricePerShareUpdated(
            getPricePerFullShare(),
            now,
            block.number
        );

        // Paused on launch
        _pause();
    }

    /// ===== Modifiers =====

    function _onlyController() internal view {
        require(msg.sender == controller, ""onlyController"");
    }

    function _onlyAuthorizedPausers() internal view {
        require(
            msg.sender == guardian || msg.sender == governance,
            ""onlyPausers""
        );
    }

    function _blockLocked() internal view {
        require(blockLock[msg.sender] < block.number, ""blockLocked"");
    }

    /// ===== View Functions =====

    function version() public view returns (string memory) {
        return ""1.3"";
    }

    function getPricePerFullShare() public view virtual returns (uint256) {
        if (totalSupply() == 0) {
            return 1e18;
        }
        return balance().mul(1e18).div(totalSupply());
    }

    /// @notice Return the total balance of the underlying token within the system
    /// @notice Sums the balance in the Sett, the Controller, and the Strategy
    function balance() public view virtual returns (uint256) {
        return
            token.balanceOf(address(this)).add(
                IController(controller).balanceOf(address(token))
            );
    }

    /// @notice Defines how much of the Setts' underlying can be borrowed by the Strategy for use
    /// @notice Custom logic in here for how much the vault allows to be borrowed
    /// @notice Sets minimum required on-hand to keep small withdrawals cheap
    function available() public view virtual returns (uint256) {
        return token.balanceOf(address(this)).mul(min).div(max);
    }

    /// ===== Public Actions =====

    /// @notice Deposit assets into the Sett, and return corresponding shares to the user
    /// @notice Only callable by EOA accounts that pass the _defend() check
    function deposit(uint256 _amount) public whenNotPaused {
        _defend();
        _blockLocked();

        _lockForBlock(msg.sender);
        _depositWithAuthorization(_amount, new bytes32[](0));
    }

    /// @notice Deposit variant with proof for merkle guest list
    function deposit(uint256 _amount, bytes32[] memory proof)
        public
        whenNotPaused
    {
        _defend();
        _blockLocked();

        _lockForBlock(msg.sender);
        _depositWithAuthorization(_amount, proof);
    }

    /// @notice Convenience function: Deposit entire balance of asset into the Sett, and return corresponding shares to the user
    /// @notice Only callable by EOA accounts that pass the _defend() check
    function depositAll() external whenNotPaused {
        _defend();
        _blockLocked();

        _lockForBlock(msg.sender);
        _depositWithAuthorization(
            token.balanceOf(msg.sender),
            new bytes32[](0)
        );
    }

    /// @notice DepositAll variant with proof for merkle guest list
    function depositAll(bytes32[] memory proof) external whenNotPaused {
        _defend();
        _blockLocked();

        _lockForBlock(msg.sender);
        _depositWithAuthorization(token.balanceOf(msg.sender), proof);
    }

    /// @notice No rebalance implementation for lower fees and faster swaps
    function withdraw(uint256 _shares) public whenNotPaused {
        _defend();
        _blockLocked();

        _lockForBlock(msg.sender);
        _withdraw(_shares);
    }

    /// @notice Convenience function: Withdraw all shares of the sender
    function withdrawAll() external whenNotPaused {
        _defend();
        _blockLocked();

        _lockForBlock(msg.sender);
        _withdraw(balanceOf(msg.sender));
    }

    /// ===== Permissioned Actions: Governance =====

    function setGuestList(address _guestList) external whenNotPaused {
        _onlyGovernance();
        guestList = BadgerGuestListAPI(_guestList);
    }

    /// @notice Set minimum threshold of underlying that must be deposited in strategy
    /// @notice Can only be changed by governance
    function setMin(uint256 _min) external whenNotPaused {
        _onlyGovernance();
        min = _min;
    }

    /// @notice Change controller address
    /// @notice Can only be changed by governance
    function setController(address _controller) public whenNotPaused {
        _onlyGovernance();
        controller = _controller;
    }

    /// @notice Change guardian address
    /// @notice Can only be changed by governance
    function setGuardian(address _guardian) external whenNotPaused {
        _onlyGovernance();
        guardian = _guardian;
    }

    /// ===== Permissioned Actions: Controller =====

    /// @notice Used to swap any borrowed reserve over the debt limit to liquidate to 'token'
    /// @notice Only controller can trigger harvests
    function harvest(address reserve, uint256 amount) external whenNotPaused {
        _onlyController();
        require(reserve != address(token), ""token"");
        IERC20Upgradeable(reserve).safeTransfer(controller, amount);
    }

    /// ===== Permissioned Functions: Trusted Actors =====

    /// @notice Transfer the underlying available to be claimed to the controller
    /// @notice The controller will deposit into the Strategy for yield-generating activities
    /// @notice Permissionless operation
    function earn() public whenNotPaused {
        _onlyAuthorizedActors();

        uint256 _bal = available();
        token.safeTransfer(controller, _bal);
        IController(controller).earn(address(token), _bal);
    }

    /// @notice Transfer the specified amount
    /// @notice used so you can specify how many tokens to lock
    function earn(uint256 amount) public whenNotPaused {
        _onlyAuthorizedActors();

        token.safeTransfer(controller, amount);
        IController(controller).earn(address(token), amount);
    }

    /// @dev Emit event tracking current full price per share
    /// @dev Provides a pure on-chain way of approximating APY
    function trackFullPricePerShare() external whenNotPaused {
        _onlyAuthorizedActors();
        emit FullPricePerShareUpdated(
            getPricePerFullShare(),
            now,
            block.number
        );
    }

    function pause() external {
        _onlyAuthorizedPausers();
        _pause();
    }

    function unpause() external {
        _onlyGovernance();
        _unpause();
    }

    /// ===== Internal Implementations =====

    /// @dev Calculate the number of shares to issue for a given deposit
    /// @dev This is based on the realized value of underlying assets between Sett & associated Strategy
    function _deposit(uint256 _amount) internal virtual {
        uint256 _pool = balance();
        uint256 _before = token.balanceOf(address(this));
        token.safeTransferFrom(msg.sender, address(this), _amount);
        uint256 _after = token.balanceOf(address(this));
        _amount = _after.sub(_before); // Additional check for deflationary tokens
        uint256 shares = 0;
        if (totalSupply() == 0) {
            shares = _amount;
        } else {
            shares = (_amount.mul(totalSupply())).div(_pool);
        }
        _mint(msg.sender, shares);
    }

    function _depositWithAuthorization(uint256 _amount, bytes32[] memory proof)
        internal
        virtual
    {
        if (address(guestList) != address(0)) {
            require(
                guestList.authorized(msg.sender, _amount, proof),
                ""guest-list-authorization""
            );
        }
        _deposit(_amount);
    }

    // No rebalance implementation for lower fees and faster swaps
    function _withdraw(uint256 _shares) internal virtual {
        uint256 r = (balance().mul(_shares)).div(totalSupply());
        _burn(msg.sender, _shares);

        // Check balance
        uint256 b = token.balanceOf(address(this));
        if (b < r) {
            uint256 _toWithdraw = r.sub(b);
            IController(controller).withdraw(address(token), _toWithdraw);
            uint256 _after = token.balanceOf(address(this));
            uint256 _diff = _after.sub(b);
            if (_diff < _toWithdraw) {
                r = b.add(_diff);
            }
        }

        token.safeTransfer(msg.sender, r);
    }

    function _lockForBlock(address account) internal {
        blockLock[account] = block.number;
    }

    /// ===== ERC20 Overrides =====

    /// @dev Add blockLock to transfers, users cannot transfer tokens in the same block as a deposit or withdrawal.
    function transfer(address recipient, uint256 amount)
        public
        virtual
        override
        whenNotPaused
        returns (bool)
    {
        _blockLocked();
        return super.transfer(recipient, amount);
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override whenNotPaused returns (bool) {
        _blockLocked();
        return super.transferFrom(sender, recipient, amount);
    }
}",2715
RealWorld_BA_31_IERC1820RegistryUpgradeable_RealWord_20240819201519.log,31,IERC1820RegistryUpgradeable,21311,4901,26212,116.0,0.204575,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface of the global ERC1820 Registry, as defined in the
 * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register
 * implementers for interfaces in this registry, as well as query support.
 *
 * Implementers may be shared by multiple accounts, and can also implement more
 * than a single interface for each account. Contracts can implement interfaces
 * for themselves, but externally-owned accounts (EOA) must delegate this to a
 * contract.
 *
 * {IERC165} interfaces can also be queried via the registry.
 *
 * For an in-depth explanation and source code analysis, see the EIP text.
 */
interface IERC1820RegistryUpgradeable {
    /**
     * @dev Sets `newManager` as the manager for `account`. A manager of an
     * account is able to set interface implementers for it.
     *
     * By default, each account is its own manager. Passing a value of `0x0` in
     * `newManager` will reset the manager to this initial state.
     *
     * Emits a {ManagerChanged} event.
     *
     * Requirements:
     *
     * - the caller must be the current manager for `account`.
     */
    function setManager(address account, address newManager) external;

    /**
     * @dev Returns the manager for `account`.
     *
     * See {setManager}.
     */
    function getManager(address account) external view returns (address);

    /**
     * @dev Sets the `implementer` contract as ``account``'s implementer for
     * `interfaceHash`.
     *
     * `account` being the zero address is an alias for the caller's address.
     * The zero address can also be used in `implementer` to remove an old one.
     *
     * See {interfaceHash} to learn how these are created.
     *
     * Emits an {InterfaceImplementerSet} event.
     *
     * Requirements:
     *
     * - the caller must be the current manager for `account`.
     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not
     * end in 28 zeroes).
     * - `implementer` must implement {IERC1820Implementer} and return true when
     * queried for support, unless `implementer` is the caller. See
     * {IERC1820Implementer-canImplementInterfaceForAddress}.
     */
    function setInterfaceImplementer(
        address account,
        bytes32 interfaceHash,
        address implementer
    ) external;

    /**
     * @dev Returns the implementer of `interfaceHash` for `account`. If no such
     * implementer is registered, returns the zero address.
     *
     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28
     * zeroes), `account` will be queried for support of it.
     *
     * `account` being the zero address is an alias for the caller's address.
     */
    function getInterfaceImplementer(address account, bytes32 interfaceHash)
        external
        view
        returns (address);

    /**
     * @dev Returns the interface hash for an `interfaceName`, as defined in the
     * corresponding
     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].
     */
    function interfaceHash(string calldata interfaceName)
        external
        pure
        returns (bytes32);

    /**
     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.
     *  @param account Address of the contract for which to update the cache.
     *  @param interfaceId ERC165 interface for which to update the cache.
     */
    function updateERC165Cache(address account, bytes4 interfaceId) external;

    /**
     *  @notice Checks whether a contract implements an ERC165 interface or not.
     *  If the result is not cached a direct lookup on the contract address is performed.
     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling
     *  {updateERC165Cache} with the contract address.
     *  @param account Address of the contract to check.
     *  @param interfaceId ERC165 interface to check.
     *  @return True if `account` implements `interfaceId`, false otherwise.
     */
    function implementsERC165Interface(address account, bytes4 interfaceId)
        external
        view
        returns (bool);

    /**
     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.
     *  @param account Address of the contract to check.
     *  @param interfaceId ERC165 interface to check.
     *  @return True if `account` implements `interfaceId`, false otherwise.
     */
    function implementsERC165InterfaceNoCache(
        address account,
        bytes4 interfaceId
    ) external view returns (bool);

    event InterfaceImplementerSet(
        address indexed account,
        bytes32 indexed interfaceHash,
        address indexed implementer
    );

    event ManagerChanged(address indexed account, address indexed newManager);
}",1130
RealWorld_BA_31_ProxyAdmin_RealWord_20240819175937.log,31,ProxyAdmin,14184,5025,19209,100.0,0.17142,"pragma solidity ^0.5.0;

import ""../ownership/Ownable.sol"";
import ""./AdminUpgradeabilityProxy.sol"";

/**
 * @title ProxyAdmin
 * @dev This contract is the admin of a proxy, and is in charge
 * of upgrading it as well as transferring it to another admin.
 */
contract ProxyAdmin is OpenZeppelinUpgradesOwnable {
    /**
     * @dev Returns the current implementation of a proxy.
     * This is needed because only the proxy admin can query it.
     * @return The address of the current implementation of the proxy.
     */
    function getProxyImplementation(AdminUpgradeabilityProxy proxy)
        public
        view
        returns (address)
    {
        // We need to manually run the static call since the getter cannot be flagged as view
        // bytes4(keccak256(""implementation()"")) == 0x5c60da1b
        (bool success, bytes memory returndata) =
            address(proxy).staticcall(hex""5c60da1b"");
        require(success);
        return abi.decode(returndata, (address));
    }

    /**
     * @dev Returns the admin of a proxy. Only the admin can query it.
     * @return The address of the current admin of the proxy.
     */
    function getProxyAdmin(AdminUpgradeabilityProxy proxy)
        public
        view
        returns (address)
    {
        // We need to manually run the static call since the getter cannot be flagged as view
        // bytes4(keccak256(""admin()"")) == 0xf851a440
        (bool success, bytes memory returndata) =
            address(proxy).staticcall(hex""f851a440"");
        require(success);
        return abi.decode(returndata, (address));
    }

    /**
     * @dev Changes the admin of a proxy.
     * @param proxy Proxy to change admin.
     * @param newAdmin Address to transfer proxy administration to.
     */
    function changeProxyAdmin(AdminUpgradeabilityProxy proxy, address newAdmin)
        public
        onlyOwner
    {
        proxy.changeAdmin(newAdmin);
    }

    /**
     * @dev Upgrades a proxy to the newest implementation of a contract.
     * @param proxy Proxy to be upgraded.
     * @param implementation the address of the Implementation.
     */
    function upgrade(AdminUpgradeabilityProxy proxy, address implementation)
        public
        onlyOwner
    {
        proxy.upgradeTo(implementation);
    }

    /**
     * @dev Upgrades a proxy to the newest implementation of a contract and forwards a function call to it.
     * This is useful to initialize the proxied contract.
     * @param proxy Proxy to be upgraded.
     * @param implementation Address of the Implementation.
     * @param data Data to send as msg.data in the low level call.
     * It should include the signature and the parameters of the function to be called, as described in
     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.
     */
    function upgradeAndCall(
        AdminUpgradeabilityProxy proxy,
        address implementation,
        bytes memory data
    ) public payable onlyOwner {
        proxy.upgradeToAndCall.value(msg.value)(implementation, data);
    }
}",690
RealWorld_BA_31_MerkleProof_RealWord_20240819165508.log,31,MerkleProof,8110,4626,12736,74.0,0.13307,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev These functions deal with verification of Merkle trees (hash trees),
 */
library MerkleProof {
    /**
     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree
     * defined by `root`. For this, a `proof` must be provided, containing
     * sibling hashes on the branch from the leaf to the root of the tree. Each
     * pair of leaves and each pair of pre-images are assumed to be sorted.
     */
    function verify(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool) {
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash <= proofElement) {
                // Hash(current computed hash + current element of the proof)
                computedHash = keccak256(
                    abi.encodePacked(computedHash, proofElement)
                );
            } else {
                // Hash(current element of the proof + current computed hash)
                computedHash = keccak256(
                    abi.encodePacked(proofElement, computedHash)
                );
            }
        }

        // Check if the computed hash (root) is equal to the provided root
        return computedHash == root;
    }
}",303
RealWorld_BA_31_IERC165_RealWord_20240819172901.log,31,IERC165,5954,3223,9177,69.0,0.09423,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}",193
RealWorld_BA_31_UpgradeabilityProxy_RealWord_20240819181121.log,31,UpgradeabilityProxy,7848,5463,13311,104.0,0.1485,"pragma solidity ^0.5.0;

import ""./BaseUpgradeabilityProxy.sol"";

/**
 * @title UpgradeabilityProxy
 * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing
 * implementation and init data.
 */
contract UpgradeabilityProxy is BaseUpgradeabilityProxy {
    /**
     * @dev Contract constructor.
     * @param _logic Address of the initial implementation.
     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.
     * It should include the signature and the parameters of the function to be called, as described in
     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.
     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.
     */
    constructor(address _logic, bytes memory _data) public payable {
        assert(
            IMPLEMENTATION_SLOT ==
                bytes32(uint256(keccak256(""eip1967.proxy.implementation"")) - 1)
        );
        _setImplementation(_logic);
        if (_data.length > 0) {
            (bool success, ) = _logic.delegatecall(_data);
            require(success);
        }
    }
}",262
RealWorld_BA_31_MathUtil_RealWord_20240819205634.log,31,MathUtil,4312,3421,7733,76.0,0.08998,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

/**
 * @dev Standard math utilities missing in the Solidity language.
 */
library MathUtil {
    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }
}",82
RealWorld_BA_31_Ownable_RealWord_20240819174629.log,31,Ownable,11786,5017,16803,123.0,0.15927,"pragma solidity ^0.5.0;

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of ""user permissions"".
 *
 * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/ownership/Ownable.sol
 * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts
 * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the
 * build/artifacts folder) as well as the vanilla Ownable implementation from an openzeppelin version.
 */
contract OpenZeppelinUpgradesOwnable {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    /**
     * @dev The Ownable constructor sets the original `owner` of the contract to the sender
     * account.
     */
    constructor() internal {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    /**
     * @return the address of the owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(isOwner());
        _;
    }

    /**
     * @return true if `msg.sender` is the owner of the contract.
     */
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * @notice Renouncing to ownership will leave the contract without an owner.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     */
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}",564
RealWorld_BA_31_ImplementationDirectory_RealWord_20240819175214.log,31,ImplementationDirectory,12360,5203,17563,121.0,0.16586,"pragma solidity ^0.5.0;

import ""./ImplementationProvider.sol"";
import ""../ownership/Ownable.sol"";
import ""../utils/Address.sol"";

/**
 * @title ImplementationDirectory
 * @dev Implementation provider that stores contract implementations in a mapping.
 */
contract ImplementationDirectory is
    ImplementationProvider,
    OpenZeppelinUpgradesOwnable
{
    /**
     * @dev Emitted when the implementation of a contract is changed.
     * @param contractName Name of the contract.
     * @param implementation Address of the added implementation.
     */
    event ImplementationChanged(
        string contractName,
        address indexed implementation
    );

    /**
     * @dev Emitted when the implementation directory is frozen.
     */
    event Frozen();

    /// @dev Mapping where the addresses of the implementations are stored.
    mapping(string => address) internal implementations;

    /// @dev Mutability state of the directory.
    bool public frozen;

    /**
     * @dev Modifier that allows functions to be called only before the contract is frozen.
     */
    modifier whenNotFrozen() {
        require(
            !frozen,
            ""Cannot perform action for a frozen implementation directory""
        );
        _;
    }

    /**
     * @dev Makes the directory irreversibly immutable.
     * It can only be called once, by the owner.
     */
    function freeze() public onlyOwner whenNotFrozen {
        frozen = true;
        emit Frozen();
    }

    /**
     * @dev Returns the implementation address of a contract.
     * @param contractName Name of the contract.
     * @return Address of the implementation.
     */
    function getImplementation(string memory contractName)
        public
        view
        returns (address)
    {
        return implementations[contractName];
    }

    /**
     * @dev Sets the address of the implementation of a contract in the directory.
     * @param contractName Name of the contract.
     * @param implementation Address of the implementation.
     */
    function setImplementation(
        string memory contractName,
        address implementation
    ) public onlyOwner whenNotFrozen {
        require(
            OpenZeppelinUpgradesAddress.isContract(implementation),
            ""Cannot set implementation in directory with a non-contract address""
        );
        implementations[contractName] = implementation;
        emit ImplementationChanged(contractName, implementation);
    }

    /**
     * @dev Removes the address of a contract implementation from the directory.
     * @param contractName Name of the contract.
     */
    function unsetImplementation(string memory contractName)
        public
        onlyOwner
        whenNotFrozen
    {
        implementations[contractName] = address(0);
        emit ImplementationChanged(contractName, address(0));
    }
}",556
RealWorld_BA_31_IUniswapV2Pair_RealWord_20240819204620.log,31,IUniswapV2Pair,12420,4907,17327,97.0,0.16024,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface IUniswapV2Pair {
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
    event Transfer(address indexed from, address indexed to, uint256 value);

    function name() external pure returns (string memory);

    function symbol() external pure returns (string memory);

    function decimals() external pure returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address owner) external view returns (uint256);

    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function transfer(address to, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PERMIT_TYPEHASH() external pure returns (bytes32);

    function nonces(address owner) external view returns (uint256);

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    event Mint(address indexed sender, uint256 amount0, uint256 amount1);
    event Burn(
        address indexed sender,
        uint256 amount0,
        uint256 amount1,
        address indexed to
    );
    event Swap(
        address indexed sender,
        uint256 amount0In,
        uint256 amount1In,
        uint256 amount0Out,
        uint256 amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint256);

    function factory() external view returns (address);

    function token0() external view returns (address);

    function token1() external view returns (address);

    function getReserves()
        external
        view
        returns (
            uint112 reserve0,
            uint112 reserve1,
            uint32 blockTimestampLast
        );

    function price0CumulativeLast() external view returns (uint256);

    function price1CumulativeLast() external view returns (uint256);

    function kLast() external view returns (uint256);

    function mint(address to) external returns (uint256 liquidity);

    function burn(address to)
        external
        returns (uint256 amount0, uint256 amount1);

    function swap(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        bytes calldata data
    ) external;

    function skim(address to) external;

    function sync() external;
}",594
RealWorld_BA_31_IERC721ReceiverUpgradeable_RealWord_20240819185216.log,31,IERC721ReceiverUpgradeable,6459,4014,10473,120.0,0.112575,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @title ERC721 token receiver interface
 * @dev Interface for any contract that wants to support safeTransfers
 * from ERC721 asset contracts.
 */
interface IERC721ReceiverUpgradeable {
    /**
     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
     * by `operator` from `from`, this function is called.
     *
     * It must return its Solidity selector to confirm the token transfer.
     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
     *
     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
     */
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}",204
RealWorld_BA_31_RefundEscrowUpgradeable_RealWord_20240819194239.log,31,RefundEscrowUpgradeable,16060,5311,21371,134.0,0.18652,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./ConditionalEscrowUpgradeable.sol"";
import ""../../proxy/Initializable.sol"";

/**
 * @title RefundEscrow
 * @dev Escrow that holds funds for a beneficiary, deposited from multiple
 * parties.
 * @dev Intended usage: See {Escrow}. Same usage guidelines apply here.
 * @dev The owner account (that is, the contract that instantiates this
 * contract) may deposit, close the deposit period, and allow for either
 * withdrawal by the beneficiary, or refunds to the depositors. All interactions
 * with `RefundEscrow` will be made through the owner contract.
 */
contract RefundEscrowUpgradeable is
    Initializable,
    ConditionalEscrowUpgradeable
{
    enum State {Active, Refunding, Closed}

    event RefundsClosed();
    event RefundsEnabled();

    State private _state;
    address payable private _beneficiary;

    /**
     * @dev Constructor.
     * @param beneficiary The beneficiary of the deposits.
     */
    function __RefundEscrow_init(address payable beneficiary)
        internal
        initializer
    {
        __Context_init_unchained();
        __Ownable_init_unchained();
        __Escrow_init_unchained();
        __ConditionalEscrow_init_unchained();
        __RefundEscrow_init_unchained(beneficiary);
    }

    function __RefundEscrow_init_unchained(address payable beneficiary)
        internal
        initializer
    {
        require(
            beneficiary != address(0),
            ""RefundEscrow: beneficiary is the zero address""
        );
        _beneficiary = beneficiary;
        _state = State.Active;
    }

    /**
     * @return The current state of the escrow.
     */
    function state() public view returns (State) {
        return _state;
    }

    /**
     * @return The beneficiary of the escrow.
     */
    function beneficiary() public view returns (address) {
        return _beneficiary;
    }

    /**
     * @dev Stores funds that may later be refunded.
     * @param refundee The address funds will be sent to if a refund occurs.
     */
    function deposit(address refundee) public payable virtual override {
        require(
            _state == State.Active,
            ""RefundEscrow: can only deposit while active""
        );
        super.deposit(refundee);
    }

    /**
     * @dev Allows for the beneficiary to withdraw their funds, rejecting
     * further deposits.
     */
    function close() public virtual onlyOwner {
        require(
            _state == State.Active,
            ""RefundEscrow: can only close while active""
        );
        _state = State.Closed;
        emit RefundsClosed();
    }

    /**
     * @dev Allows for refunds to take place, rejecting further deposits.
     */
    function enableRefunds() public virtual onlyOwner {
        require(
            _state == State.Active,
            ""RefundEscrow: can only enable refunds while active""
        );
        _state = State.Refunding;
        emit RefundsEnabled();
    }

    /**
     * @dev Withdraws the beneficiary's funds.
     */
    function beneficiaryWithdraw() public virtual {
        require(
            _state == State.Closed,
            ""RefundEscrow: beneficiary can only withdraw while closed""
        );
        _beneficiary.transfer(address(this).balance);
    }

    /**
     * @dev Returns whether refundees can withdraw their deposits (be refunded). The overridden function receives a
     * 'payee' argument, but we ignore it here since the condition is global, not per-payee.
     */
    function withdrawalAllowed(address) public view override returns (bool) {
        return _state == State.Refunding;
    }

    uint256[49] private __gap;
}",801
RealWorld_BA_31_ISimpleTimelockWithVoting_RealWord_20240819214106.log,31,ISimpleTimelockWithVoting,4294,5002,9296,120.0,0.12151,"//SPDX-License-Identifier: Unlicense
pragma solidity >=0.5.0 <0.8.0;

interface ISimpleTimelockWithVoting {
    function release() external;

    function vote(
        uint256 _voteId,
        bool _supports,
        bool _executesIfDecided
    ) external payable;
}",71
RealWorld_BA_31_Initializable_RealWord_20240819191021.log,31,Initializable,11791,4801,16592,124.0,0.154975,"// SPDX-License-Identifier: MIT

pragma solidity >=0.4.24 <0.7.0;

/**
 * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed
 * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an
 * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer
 * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.
 *
 * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as
 * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.
 *
 * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure
 * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.
 */
abstract contract Initializable {
    /**
     * @dev Indicates that the contract has been initialized.
     */
    bool private _initialized;

    /**
     * @dev Indicates that the contract is in the process of being initialized.
     */
    bool private _initializing;

    /**
     * @dev Modifier to protect an initializer function from being invoked twice.
     */
    modifier initializer() {
        require(
            _initializing || _isConstructor() || !_initialized,
            ""Initializable: contract is already initialized""
        );

        bool isTopLevelCall = !_initializing;
        if (isTopLevelCall) {
            _initializing = true;
            _initialized = true;
        }

        _;

        if (isTopLevelCall) {
            _initializing = false;
        }
    }

    /// @dev Returns true if and only if the function is running in the constructor
    function _isConstructor() private view returns (bool) {
        // extcodesize checks the size of the code stored in an address, and
        // address returns the current address. Since the code is still not
        // deployed when running a constructor, any checks on its code size will
        // yield zero, making it an effective way to detect if a contract is
        // under construction or not.
        address self = address(this);
        uint256 cs;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            cs := extcodesize(self)
        }
        return cs == 0;
    }
}",530
RealWorld_BA_31_IERC20_RealWord_20240819155704.log,31,IERC20,12970,5150,18120,80.0,0.16785,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}",631
RealWorld_BA_31_GSNRecipient_RealWord_20240819165056.log,31,GSNRecipient,42523,5653,48176,93.0,0.325675,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./IRelayRecipient.sol"";
import ""./IRelayHub.sol"";
import ""./Context.sol"";

/**
 * @dev Base GSN recipient contract: includes the {IRelayRecipient} interface
 * and enables GSN support on all contracts in the inheritance tree.
 *
 * TIP: This contract is abstract. The functions {IRelayRecipient-acceptRelayedCall},
 *  {_preRelayedCall}, and {_postRelayedCall} are not implemented and must be
 * provided by derived contracts. See the
 * xref:ROOT:gsn-strategies.adoc#gsn-strategies[GSN strategies] for more
 * information on how to use the pre-built {GSNRecipientSignature} and
 * {GSNRecipientERC20Fee}, or how to write your own.
 */
abstract contract GSNRecipient is IRelayRecipient, Context {
    // Default RelayHub address, deployed on mainnet and all testnets at the same address
    address private _relayHub = 0xD216153c06E857cD7f72665E0aF1d7D82172F494;

    uint256 private constant _RELAYED_CALL_ACCEPTED = 0;
    uint256 private constant _RELAYED_CALL_REJECTED = 11;

    // How much gas is forwarded to postRelayedCall
    uint256 internal constant _POST_RELAYED_CALL_MAX_GAS = 100000;

    /**
     * @dev Emitted when a contract changes its {IRelayHub} contract to a new one.
     */
    event RelayHubChanged(
        address indexed oldRelayHub,
        address indexed newRelayHub
    );

    /**
     * @dev Returns the address of the {IRelayHub} contract for this recipient.
     */
    function getHubAddr() public view override returns (address) {
        return _relayHub;
    }

    /**
     * @dev Switches to a new {IRelayHub} instance. This method is added for future-proofing: there's no reason to not
     * use the default instance.
     *
     * IMPORTANT: After upgrading, the {GSNRecipient} will no longer be able to receive relayed calls from the old
     * {IRelayHub} instance. Additionally, all funds should be previously withdrawn via {_withdrawDeposits}.
     */
    function _upgradeRelayHub(address newRelayHub) internal virtual {
        address currentRelayHub = _relayHub;
        require(
            newRelayHub != address(0),
            ""GSNRecipient: new RelayHub is the zero address""
        );
        require(
            newRelayHub != currentRelayHub,
            ""GSNRecipient: new RelayHub is the current one""
        );

        emit RelayHubChanged(currentRelayHub, newRelayHub);

        _relayHub = newRelayHub;
    }

    /**
     * @dev Returns the version string of the {IRelayHub} for which this recipient implementation was built. If
     * {_upgradeRelayHub} is used, the new {IRelayHub} instance should be compatible with this version.
     */
    // This function is view for future-proofing, it may require reading from
    // storage in the future.
    function relayHubVersion() public view returns (string memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return ""1.0.0"";
    }

    /**
     * @dev Withdraws the recipient's deposits in `RelayHub`.
     *
     * Derived contracts should expose this in an external interface with proper access control.
     */
    function _withdrawDeposits(uint256 amount, address payable payee)
        internal
        virtual
    {
        IRelayHub(_relayHub).withdraw(amount, payee);
    }

    // Overrides for Context's functions: when called from RelayHub, sender and
    // data require some pre-processing: the actual sender is stored at the end
    // of the call data, which in turns means it needs to be removed from it
    // when handling said data.

    /**
     * @dev Replacement for msg.sender. Returns the actual sender of a transaction: msg.sender for regular transactions,
     * and the end-user for GSN relayed calls (where msg.sender is actually `RelayHub`).
     *
     * IMPORTANT: Contracts derived from {GSNRecipient} should never use `msg.sender`, and use {_msgSender} instead.
     */
    function _msgSender()
        internal
        view
        virtual
        override
        returns (address payable)
    {
        if (msg.sender != _relayHub) {
            return msg.sender;
        } else {
            return _getRelayedCallSender();
        }
    }

    /**
     * @dev Replacement for msg.data. Returns the actual calldata of a transaction: msg.data for regular transactions,
     * and a reduced version for GSN relayed calls (where msg.data contains additional information).
     *
     * IMPORTANT: Contracts derived from {GSNRecipient} should never use `msg.data`, and use {_msgData} instead.
     */
    function _msgData() internal view virtual override returns (bytes memory) {
        if (msg.sender != _relayHub) {
            return msg.data;
        } else {
            return _getRelayedCallData();
        }
    }

    // Base implementations for pre and post relayedCall: only RelayHub can invoke them, and data is forwarded to the
    // internal hook.

    /**
     * @dev See `IRelayRecipient.preRelayedCall`.
     *
     * This function should not be overridden directly, use `_preRelayedCall` instead.
     *
     * * Requirements:
     *
     * - the caller must be the `RelayHub` contract.
     */
    function preRelayedCall(bytes memory context)
        public
        virtual
        override
        returns (bytes32)
    {
        require(
            msg.sender == getHubAddr(),
            ""GSNRecipient: caller is not RelayHub""
        );
        return _preRelayedCall(context);
    }

    /**
     * @dev See `IRelayRecipient.preRelayedCall`.
     *
     * Called by `GSNRecipient.preRelayedCall`, which asserts the caller is the `RelayHub` contract. Derived contracts
     * must implement this function with any relayed-call preprocessing they may wish to do.
     *
     */
    function _preRelayedCall(bytes memory context)
        internal
        virtual
        returns (bytes32);

    /**
     * @dev See `IRelayRecipient.postRelayedCall`.
     *
     * This function should not be overridden directly, use `_postRelayedCall` instead.
     *
     * * Requirements:
     *
     * - the caller must be the `RelayHub` contract.
     */
    function postRelayedCall(
        bytes memory context,
        bool success,
        uint256 actualCharge,
        bytes32 preRetVal
    ) public virtual override {
        require(
            msg.sender == getHubAddr(),
            ""GSNRecipient: caller is not RelayHub""
        );
        _postRelayedCall(context, success, actualCharge, preRetVal);
    }

    /**
     * @dev See `IRelayRecipient.postRelayedCall`.
     *
     * Called by `GSNRecipient.postRelayedCall`, which asserts the caller is the `RelayHub` contract. Derived contracts
     * must implement this function with any relayed-call postprocessing they may wish to do.
     *
     */
    function _postRelayedCall(
        bytes memory context,
        bool success,
        uint256 actualCharge,
        bytes32 preRetVal
    ) internal virtual;

    /**
     * @dev Return this in acceptRelayedCall to proceed with the execution of a relayed call. Note that this contract
     * will be charged a fee by RelayHub
     */
    function _approveRelayedCall()
        internal
        pure
        returns (uint256, bytes memory)
    {
        return _approveRelayedCall("""");
    }

    /**
     * @dev See `GSNRecipient._approveRelayedCall`.
     *
     * This overload forwards `context` to _preRelayedCall and _postRelayedCall.
     */
    function _approveRelayedCall(bytes memory context)
        internal
        pure
        returns (uint256, bytes memory)
    {
        return (_RELAYED_CALL_ACCEPTED, context);
    }

    /**
     * @dev Return this in acceptRelayedCall to impede execution of a relayed call. No fees will be charged.
     */
    function _rejectRelayedCall(uint256 errorCode)
        internal
        pure
        returns (uint256, bytes memory)
    {
        return (_RELAYED_CALL_REJECTED + errorCode, """");
    }

    /*
     * @dev Calculates how much RelayHub will charge a recipient for using `gas` at a `gasPrice`, given a relayer's
     * `serviceFee`.
     */
    function _computeCharge(
        uint256 gas,
        uint256 gasPrice,
        uint256 serviceFee
    ) internal pure returns (uint256) {
        // The fee is expressed as a percentage. E.g. a value of 40 stands for a 40% fee, so the recipient will be
        // charged for 1.4 times the spent amount.
        return (gas * gasPrice * (100 + serviceFee)) / 100;
    }

    function _getRelayedCallSender()
        private
        pure
        returns (address payable result)
    {
        // We need to read 20 bytes (an address) located at array index msg.data.length - 20. In memory, the array
        // is prefixed with a 32-byte length value, so we first add 32 to get the memory read index. However, doing
        // so would leave the address in the upper 20 bytes of the 32-byte word, which is inconvenient and would
        // require bit shifting. We therefore subtract 12 from the read index so the address lands on the lower 20
        // bytes. This can always be done due to the 32-byte prefix.

        // The final memory read index is msg.data.length - 20 + 32 - 12 = msg.data.length. Using inline assembly is the
        // easiest/most-efficient way to perform this operation.

        // These fields are not accessible from assembly
        bytes memory array = msg.data;
        uint256 index = msg.data.length;

        // solhint-disable-next-line no-inline-assembly
        assembly {
            // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.
            result := and(
                mload(add(array, index)),
                0xffffffffffffffffffffffffffffffffffffffff
            )
        }
        return result;
    }

    function _getRelayedCallData() private pure returns (bytes memory) {
        // RelayHub appends the sender address at the end of the calldata, so in order to retrieve the actual msg.data,
        // we must strip the last 20 bytes (length of an address type) from it.

        uint256 actualDataLength = msg.data.length - 20;
        bytes memory actualData = new bytes(actualDataLength);

        for (uint256 i = 0; i < actualDataLength; ++i) {
            actualData[i] = msg.data[i];
        }

        return actualData;
    }
}",2440
RealWorld_BA_31_GSNRecipientSignatureUpgradeable_RealWord_20240819192848.log,31,GSNRecipientSignatureUpgradeable,13590,5094,18684,143.0,0.16983,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./GSNRecipientUpgradeable.sol"";
import ""../cryptography/ECDSAUpgradeable.sol"";
import ""../proxy/Initializable.sol"";

/**
 * @dev A xref:ROOT:gsn-strategies.adoc#gsn-strategies[GSN strategy] that allows relayed transactions through when they are
 * accompanied by the signature of a trusted signer. The intent is for this signature to be generated by a server that
 * performs validations off-chain. Note that nothing is charged to the user in this scheme. Thus, the server should make
 * sure to account for this in their economic and threat model.
 */
contract GSNRecipientSignatureUpgradeable is
    Initializable,
    GSNRecipientUpgradeable
{
    using ECDSAUpgradeable for bytes32;

    address private _trustedSigner;

    enum GSNRecipientSignatureErrorCodes {INVALID_SIGNER}

    /**
     * @dev Sets the trusted signer that is going to be producing signatures to approve relayed calls.
     */
    function __GSNRecipientSignature_init(address trustedSigner)
        internal
        initializer
    {
        __Context_init_unchained();
        __GSNRecipient_init_unchained();
        __GSNRecipientSignature_init_unchained(trustedSigner);
    }

    function __GSNRecipientSignature_init_unchained(address trustedSigner)
        internal
        initializer
    {
        require(
            trustedSigner != address(0),
            ""GSNRecipientSignature: trusted signer is the zero address""
        );
        _trustedSigner = trustedSigner;
    }

    /**
     * @dev Ensures that only transactions with a trusted signature can be relayed through the GSN.
     */
    function acceptRelayedCall(
        address relay,
        address from,
        bytes memory encodedFunction,
        uint256 transactionFee,
        uint256 gasPrice,
        uint256 gasLimit,
        uint256 nonce,
        bytes memory approvalData,
        uint256
    ) public view virtual override returns (uint256, bytes memory) {
        bytes memory blob =
            abi.encodePacked(
                relay,
                from,
                encodedFunction,
                transactionFee,
                gasPrice,
                gasLimit,
                nonce, // Prevents replays on RelayHub
                getHubAddr(), // Prevents replays in multiple RelayHubs
                address(this) // Prevents replays in multiple recipients
            );
        if (
            keccak256(blob).toEthSignedMessageHash().recover(approvalData) ==
            _trustedSigner
        ) {
            return _approveRelayedCall();
        } else {
            return
                _rejectRelayedCall(
                    uint256(GSNRecipientSignatureErrorCodes.INVALID_SIGNER)
                );
        }
    }

    function _preRelayedCall(bytes memory)
        internal
        virtual
        override
        returns (bytes32)
    {}

    function _postRelayedCall(
        bytes memory,
        bool,
        uint256,
        bytes32
    ) internal virtual override {}

    uint256[49] private __gap;
}",650
RealWorld_BA_31_Proxy_RealWord_20240819180516.log,31,Proxy,11005,5475,16480,101.0,0.164525,"pragma solidity ^0.5.0;

/**
 * @title Proxy
 * @dev Implements delegation of calls to other contracts, with proper
 * forwarding of return values and bubbling of failures.
 * It defines a fallback function that delegates all calls to the address
 * returned by the abstract _implementation() internal function.
 */
contract Proxy {
    /**
     * @dev Fallback function.
     * Implemented entirely in `_fallback`.
     */
    function() external payable {
        _fallback();
    }

    /**
     * @return The Address of the implementation.
     */
    function _implementation() internal view returns (address);

    /**
     * @dev Delegates execution to an implementation contract.
     * This is a low level function that doesn't return to its internal call site.
     * It will return to the external caller whatever the implementation returns.
     * @param implementation Address to delegate.
     */
    function _delegate(address implementation) internal {
        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize)

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(
                gas,
                implementation,
                0,
                calldatasize,
                0,
                0
            )

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize)

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize)
                }
                default {
                    return(0, returndatasize)
                }
        }
    }

    /**
     * @dev Function that is run as the first thing in the fallback function.
     * Can be redefined in derived contracts to add functionality.
     * Redefinitions must call super._willFallback().
     */
    function _willFallback() internal {}

    /**
     * @dev fallback implementation.
     * Extracted to enable manual triggering.
     */
    function _fallback() internal {
        _willFallback();
        _delegate(_implementation());
    }
}",485
RealWorld_BA_31_PullPayment_RealWord_20240819165801.log,31,PullPayment,12741,4827,17568,80.0,0.160245,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""./escrow/Escrow.sol"";

/**
 * @dev Simple implementation of a
 * https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls[pull-payment]
 * strategy, where the paying contract doesn't interact directly with the
 * receiver account, which must withdraw its payments itself.
 *
 * Pull-payments are often considered the best practice when it comes to sending
 * Ether, security-wise. It prevents recipients from blocking execution, and
 * eliminates reentrancy concerns.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 *
 * To use, derive from the `PullPayment` contract, and use {_asyncTransfer}
 * instead of Solidity's `transfer` function. Payees can query their due
 * payments with {payments}, and retrieve them with {withdrawPayments}.
 */
contract PullPayment {
    Escrow private _escrow;

    constructor() internal {
        _escrow = new Escrow();
    }

    /**
     * @dev Withdraw accumulated payments, forwarding all gas to the recipient.
     *
     * Note that _any_ account can call this function, not just the `payee`.
     * This means that contracts unaware of the `PullPayment` protocol can still
     * receive funds this way, by having a separate account call
     * {withdrawPayments}.
     *
     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.
     * Make sure you trust the recipient, or are either following the
     * checks-effects-interactions pattern or using {ReentrancyGuard}.
     *
     * @param payee Whose payments will be withdrawn.
     */
    function withdrawPayments(address payable payee) public virtual {
        _escrow.withdraw(payee);
    }

    /**
     * @dev Returns the payments owed to an address.
     * @param dest The creditor's address.
     */
    function payments(address dest) public view returns (uint256) {
        return _escrow.depositsOf(dest);
    }

    /**
     * @dev Called by the payer to store the sent amount as credit to be pulled.
     * Funds sent in this way are stored in an intermediate {Escrow} contract, so
     * there is no danger of them being spent before withdrawal.
     *
     * @param dest The destination address of the funds.
     * @param amount The amount to transfer.
     */
    function _asyncTransfer(address dest, uint256 amount) internal virtual {
        _escrow.deposit{value: amount}(dest);
    }
}",596
RealWorld_BA_31_TransparentUpgradeableProxy_RealWord_20240819163934.log,31,TransparentUpgradeableProxy,26402,5620,32022,84.0,0.24441,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./UpgradeableProxy.sol"";

/**
 * @dev This contract implements a proxy that is upgradeable by an admin.
 *
 * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector
 * clashing], which can potentially be used in an attack, this contract uses the
 * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two
 * things that go hand in hand:
 *
 * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if
 * that call matches one of the admin functions exposed by the proxy itself.
 * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the
 * implementation. If the admin tries to call a function on the implementation it will fail with an error that says
 * ""admin cannot fallback to proxy target"".
 *
 * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing
 * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due
 * to sudden errors when trying to call a function from the proxy implementation.
 *
 * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,
 * you should think of the `ProxyAdmin` instance as the real administrative inerface of your proxy.
 */
contract TransparentUpgradeableProxy is UpgradeableProxy {
    /**
     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and
     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.
     */
    constructor(
        address _logic,
        address _admin,
        bytes memory _data
    ) public payable UpgradeableProxy(_logic, _data) {
        assert(
            _ADMIN_SLOT ==
                bytes32(uint256(keccak256(""eip1967.proxy.admin"")) - 1)
        );
        _setAdmin(_admin);
    }

    /**
     * @dev Emitted when the admin account has changed.
     */
    event AdminChanged(address previousAdmin, address newAdmin);

    /**
     * @dev Storage slot with the admin of the contract.
     * This is the keccak-256 hash of ""eip1967.proxy.admin"" subtracted by 1, and is
     * validated in the constructor.
     */
    bytes32 private constant _ADMIN_SLOT =
        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;

    /**
     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.
     */
    modifier ifAdmin() {
        if (msg.sender == _admin()) {
            _;
        } else {
            _fallback();
        }
    }

    /**
     * @dev Returns the current admin.
     *
     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.
     *
     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the
     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.
     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`
     */
    function admin() external ifAdmin returns (address) {
        return _admin();
    }

    /**
     * @dev Returns the current implementation.
     *
     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.
     *
     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the
     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.
     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`
     */
    function implementation() external ifAdmin returns (address) {
        return _implementation();
    }

    /**
     * @dev Changes the admin of the proxy.
     *
     * Emits an {AdminChanged} event.
     *
     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.
     */
    function changeAdmin(address newAdmin) external ifAdmin {
        require(
            newAdmin != address(0),
            ""TransparentUpgradeableProxy: new admin is the zero address""
        );
        emit AdminChanged(_admin(), newAdmin);
        _setAdmin(newAdmin);
    }

    /**
     * @dev Upgrade the implementation of the proxy.
     *
     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.
     */
    function upgradeTo(address newImplementation) external ifAdmin {
        _upgradeTo(newImplementation);
    }

    /**
     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified
     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the
     * proxied contract.
     *
     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.
     */
    function upgradeToAndCall(address newImplementation, bytes calldata data)
        external
        payable
        ifAdmin
    {
        _upgradeTo(newImplementation);
        // solhint-disable-next-line avoid-low-level-calls
        (bool success, ) = newImplementation.delegatecall(data);
        require(success);
    }

    /**
     * @dev Returns the current admin.
     */
    function _admin() internal view returns (address adm) {
        bytes32 slot = _ADMIN_SLOT;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            adm := sload(slot)
        }
    }

    /**
     * @dev Stores a new address in the EIP1967 admin slot.
     */
    function _setAdmin(address newAdmin) private {
        bytes32 slot = _ADMIN_SLOT;

        // solhint-disable-next-line no-inline-assembly
        assembly {
            sstore(slot, newAdmin)
        }
    }

    /**
     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.
     */
    function _beforeFallback() internal virtual override {
        require(
            msg.sender != _admin(),
            ""TransparentUpgradeableProxy: admin cannot fallback to proxy target""
        );
        super._beforeFallback();
    }
}",1475
RealWorld_BA_31_IERC20Upgradeable_RealWord_20240819182626.log,31,IERC20Upgradeable,13536,5308,18844,111.0,0.17384,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20Upgradeable {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}",633
RealWorld_BA_31_IAccessControl_RealWord_20240819213725.log,31,IAccessControl,13661,4807,18468,113.0,0.164445,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface IAccessControl {
    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account)
        external
        view
        returns (bool);

    /**
     * @dev Returns the number of accounts that have `role`. Can be used
     * together with {getRoleMember} to enumerate all bearers of a role.
     */
    function getRoleMemberCount(bytes32 role) external view returns (uint256);

    /**
     * @dev Returns one of the accounts that have `role`. `index` must be a
     * value between 0 and {getRoleMemberCount}, non-inclusive.
     *
     * Role bearers are not sorted in any particular way, and their ordering may
     * change at any point.
     *
     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure
     * you perform all queries on the same block. See the following
     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]
     * for more information.
     */
    function getRoleMember(bytes32 role, uint256 index)
        external
        view
        returns (address);

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) external;
}",646
RealWorld_BA_31_IERC1155ReceiverUpgradeable_RealWord_20240819185824.log,31,IERC1155ReceiverUpgradeable,12185,5259,17444,118.0,0.166105,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../../introspection/IERC165Upgradeable.sol"";

/**
 * _Available since v3.1._
 */
interface IERC1155ReceiverUpgradeable is IERC165Upgradeable {
    /**
        @dev Handles the receipt of a single ERC1155 token type. This function is
        called at the end of a `safeTransferFrom` after the balance has been updated.
        To accept the transfer, this must return
        `bytes4(keccak256(""onERC1155Received(address,address,uint256,uint256,bytes)""))`
        (i.e. 0xf23a6e61, or its own function selector).
        @param operator The address which initiated the transfer (i.e. msg.sender)
        @param from The address which previously owned the token
        @param id The ID of the token being transferred
        @param value The amount of tokens being transferred
        @param data Additional data with no specified format
        @return `bytes4(keccak256(""onERC1155Received(address,address,uint256,uint256,bytes)""))` if transfer is allowed
    */
    function onERC1155Received(
        address operator,
        address from,
        uint256 id,
        uint256 value,
        bytes calldata data
    ) external returns (bytes4);

    /**
        @dev Handles the receipt of a multiple ERC1155 token types. This function
        is called at the end of a `safeBatchTransferFrom` after the balances have
        been updated. To accept the transfer(s), this must return
        `bytes4(keccak256(""onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)""))`
        (i.e. 0xbc197c81, or its own function selector).
        @param operator The address which initiated the batch transfer (i.e. msg.sender)
        @param from The address which previously owned the token
        @param ids An array containing ids of each token being transferred (order and length must match values array)
        @param values An array containing amounts of each token being transferred (order and length must match ids array)
        @param data Additional data with no specified format
        @return `bytes4(keccak256(""onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)""))` if transfer is allowed
    */
    function onERC1155BatchReceived(
        address operator,
        address from,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external returns (bytes4);
}",553
RealWorld_BA_31_VipCappedGuestListWrapperUpgradeable_RealWord_20240819155004.log,31,VipCappedGuestListWrapperUpgradeable,28473,5481,33954,85.0,0.251985,"// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.6.0 <0.7.0;
pragma experimental ABIEncoderV2;

import ""../../deps/@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol"";
import ""../../deps/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""../../deps/@openzeppelin/contracts-upgradeable/cryptography/MerkleProofUpgradeable.sol"";
import ""interfaces/yearn/GuestlistApi.sol"";
import ""interfaces/yearn/BadgerWrapperApi.sol"";

/**
 * @notice A basic guest list contract for testing.
 * @dev For a Vyper implementation of this contract containing additional
 * functionality, see https://github.com/banteg/guest-list/blob/master/contracts/GuestList.vy
 * The owner can invite arbitrary guests
 * A guest can be added permissionlessly with proof of inclusion in current merkle set
 * The owner can change the merkle root at any time
 * Merkle-based permission that has been claimed cannot be revoked permissionlessly.
 * Any guests can be revoked by the owner at-will
 * The TVL cap is based on the number of want tokens in the underlying vaults.
 * This can only be made more permissive over time. If decreased, existing TVL is maintained and no deposits are possible until the TVL has gone below the threshold
 * A variant of the yearn AffiliateToken that supports guest list control of deposits
 * A guest list that gates access by merkle root and a TVL cap
 */
contract VipCappedGuestListWrapperUpgradeable is OwnableUpgradeable {
    using SafeMathUpgradeable for uint256;

    address public wrapper;

    bytes32 public guestRoot;
    uint256 public userDepositCap;
    uint256 public totalDepositCap;

    mapping(address => bool) public guests;

    event ProveInvitation(address indexed account, bytes32 indexed guestRoot);
    event SetGuestRoot(bytes32 indexed guestRoot);
    event SetUserDepositCap(uint256 cap);
    event SetTotalDepositCap(uint256 cap);

    /**
     * @notice Create the test guest list, setting the message sender as
     * `owner`.
     * @dev Note that since this is just for testing, you're unable to change
     * `owner`.
     */
    function initialize(address wrapper_) public initializer {
        __Ownable_init();
        wrapper = wrapper_;
    }

    /**
     * @notice Invite guests or kick them from the party.
     * @param _guests The guests to add or update.
     * @param _invited A flag for each guest at the matching index, inviting or
     * uninviting the guest.
     */
    function setGuests(address[] calldata _guests, bool[] calldata _invited)
        external
        onlyOwner
    {
        _setGuests(_guests, _invited);
    }

    function vaultBalance(address account) public view returns (uint256) {
        return BadgerWrapperAPI(wrapper).totalVaultBalance(account);
    }

    function wrapperBalance(address user) public view returns (uint256) {
        return BadgerWrapperAPI(wrapper).totalWrapperBalance(user);
    }

    function remainingTotalDepositAllowed() public view returns (uint256) {
        return totalDepositCap.sub(vaultBalance(wrapper));
    }

    function remainingUserDepositAllowed(address user)
        public
        view
        returns (uint256)
    {
        return userDepositCap.sub(wrapperBalance(user));
    }

    /**
     * @notice Permissionly prove an address is included in the current merkle root, thereby granting access
     * @notice Note that the list is designed to ONLY EXPAND in future instances
     * @notice The admin does retain the ability to ban individual addresses
     */
    function proveInvitation(address account, bytes32[] calldata merkleProof)
        public
    {
        // Verify Merkle Proof
        require(_verifyInvitationProof(account, merkleProof));

        address[] memory accounts = new address[](1);
        bool[] memory invited = new bool[](1);

        accounts[0] = account;
        invited[0] = true;

        _setGuests(accounts, invited);

        emit ProveInvitation(account, guestRoot);
    }

    /**
     * @notice Set the merkle root to verify invitation proofs against.
     * @notice Note that accounts not included in the root will still be invited if their inviation was previously approved.
     * @notice Setting to 0 removes proof verification versus the root, opening access
     */
    function setGuestRoot(bytes32 guestRoot_) external onlyOwner {
        guestRoot = guestRoot_;

        emit SetGuestRoot(guestRoot);
    }

    function setUserDepositCap(uint256 cap_) external onlyOwner {
        userDepositCap = cap_;

        emit SetUserDepositCap(userDepositCap);
    }

    function setTotalDepositCap(uint256 cap_) external onlyOwner {
        totalDepositCap = cap_;

        emit SetTotalDepositCap(totalDepositCap);
    }

    /**
     * @notice Check if a guest with a bag of a certain size is allowed into
     * the party.
     * @dev Note that `_amount` isn't checked to keep test setup simple, since
     * from the wrapper tests' perspective this is a pass/fail call anyway.
     * @param _guest The guest's address to check.
     */
    function authorized(
        address _guest,
        uint256 _amount,
        bytes32[] calldata _merkleProof
    ) external view returns (bool) {
        // Yes: If the user is on the list, and under the cap
        // Yes: If the user is not on the list, supplies a valid proof (thereby being added to the list), and is under the cap
        // No: If the user is not on the list, does not supply a valid proof, or is over the cap
        bool invited = guests[_guest];

        // If there is no guest root, all users are invited
        if (!invited && guestRoot == bytes32(0)) {
            invited = true;
        }

        // If the user is not already invited and there is an active guestList, require verification of merkle proof to grant temporary invitation (does not set storage variable)
        if (!invited && guestRoot != bytes32(0)) {
            // Will revert on invalid proof
            invited = _verifyInvitationProof(_guest, _merkleProof);
        }

        // If the user was previously invited, or proved invitiation via list, verify if the amount to deposit keeps them under the cap
        if (
            invited &&
            remainingUserDepositAllowed(_guest) >= _amount &&
            remainingTotalDepositAllowed() >= _amount
        ) {
            return true;
        } else {
            return false;
        }
    }

    function _setGuests(address[] memory _guests, bool[] memory _invited)
        internal
    {
        require(_guests.length == _invited.length);
        for (uint256 i = 0; i < _guests.length; i++) {
            if (_guests[i] == address(0)) {
                break;
            }
            guests[_guests[i]] = _invited[i];
        }
    }

    function _verifyInvitationProof(
        address account,
        bytes32[] calldata merkleProof
    ) internal view returns (bool) {
        bytes32 node = keccak256(abi.encodePacked(account));
        return MerkleProofUpgradeable.verify(merkleProof, guestRoot, node);
    }
}",1593
RealWorld_BA_31_ISett_RealWord_20240819214308.log,31,ISett,5546,4803,10349,121.0,0.12379,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface ISett {
    function token() external view returns (address);

    function deposit(uint256) external;

    function depositFor(address, uint256) external;

    function depositAll() external;

    function withdraw(uint256) external;

    function withdrawAll() external;

    function earn() external;

    function balanceOf(address account) external view returns (uint256);

    function totalSupply() external view returns (uint256);

    function claimInsurance() external; // NOTE: Only yDelegatedVault implements this

    function getPricePerFullShare() external view returns (uint256);
}",144
RealWorld_BA_31_IERC777_RealWord_20240819161215.log,31,IERC777,26347,6361,32708,106.0,0.258955,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface of the ERC777Token standard as defined in the EIP.
 *
 * This contract uses the
 * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let
 * token holders and recipients react to token movements by using setting implementers
 * for the associated interfaces in said registry. See {IERC1820Registry} and
 * {ERC1820Implementer}.
 */
interface IERC777 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the smallest part of the token that is not divisible. This
     * means all token operations (creation, movement and destruction) must have
     * amounts that are a multiple of this number.
     *
     * For most token contracts, this value will equal 1.
     */
    function granularity() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by an account (`owner`).
     */
    function balanceOf(address owner) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * If send or receive hooks are registered for the caller and `recipient`,
     * the corresponding functions will be called with `data` and empty
     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.
     *
     * Emits a {Sent} event.
     *
     * Requirements
     *
     * - the caller must have at least `amount` tokens.
     * - `recipient` cannot be the zero address.
     * - if `recipient` is a contract, it must implement the {IERC777Recipient}
     * interface.
     */
    function send(
        address recipient,
        uint256 amount,
        bytes calldata data
    ) external;

    /**
     * @dev Destroys `amount` tokens from the caller's account, reducing the
     * total supply.
     *
     * If a send hook is registered for the caller, the corresponding function
     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.
     *
     * Emits a {Burned} event.
     *
     * Requirements
     *
     * - the caller must have at least `amount` tokens.
     */
    function burn(uint256 amount, bytes calldata data) external;

    /**
     * @dev Returns true if an account is an operator of `tokenHolder`.
     * Operators can send and burn tokens on behalf of their owners. All
     * accounts are their own operator.
     *
     * See {operatorSend} and {operatorBurn}.
     */
    function isOperatorFor(address operator, address tokenHolder)
        external
        view
        returns (bool);

    /**
     * @dev Make an account an operator of the caller.
     *
     * See {isOperatorFor}.
     *
     * Emits an {AuthorizedOperator} event.
     *
     * Requirements
     *
     * - `operator` cannot be calling address.
     */
    function authorizeOperator(address operator) external;

    /**
     * @dev Revoke an account's operator status for the caller.
     *
     * See {isOperatorFor} and {defaultOperators}.
     *
     * Emits a {RevokedOperator} event.
     *
     * Requirements
     *
     * - `operator` cannot be calling address.
     */
    function revokeOperator(address operator) external;

    /**
     * @dev Returns the list of default operators. These accounts are operators
     * for all token holders, even if {authorizeOperator} was never called on
     * them.
     *
     * This list is immutable, but individual holders may revoke these via
     * {revokeOperator}, in which case {isOperatorFor} will return false.
     */
    function defaultOperators() external view returns (address[] memory);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must
     * be an operator of `sender`.
     *
     * If send or receive hooks are registered for `sender` and `recipient`,
     * the corresponding functions will be called with `data` and
     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.
     *
     * Emits a {Sent} event.
     *
     * Requirements
     *
     * - `sender` cannot be the zero address.
     * - `sender` must have at least `amount` tokens.
     * - the caller must be an operator for `sender`.
     * - `recipient` cannot be the zero address.
     * - if `recipient` is a contract, it must implement the {IERC777Recipient}
     * interface.
     */
    function operatorSend(
        address sender,
        address recipient,
        uint256 amount,
        bytes calldata data,
        bytes calldata operatorData
    ) external;

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the total supply.
     * The caller must be an operator of `account`.
     *
     * If a send hook is registered for `account`, the corresponding function
     * will be called with `data` and `operatorData`. See {IERC777Sender}.
     *
     * Emits a {Burned} event.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     * - the caller must be an operator for `account`.
     */
    function operatorBurn(
        address account,
        uint256 amount,
        bytes calldata data,
        bytes calldata operatorData
    ) external;

    event Sent(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256 amount,
        bytes data,
        bytes operatorData
    );

    event Minted(
        address indexed operator,
        address indexed to,
        uint256 amount,
        bytes data,
        bytes operatorData
    );

    event Burned(
        address indexed operator,
        address indexed from,
        uint256 amount,
        bytes data,
        bytes operatorData
    );

    event AuthorizedOperator(
        address indexed operator,
        address indexed tokenHolder
    );

    event RevokedOperator(
        address indexed operator,
        address indexed tokenHolder
    );
}",1439
RealWorld_BA_31_IUniswapFactory_RealWord_20240819204309.log,31,IUniswapFactory,7512,4848,12360,95.0,0.13452,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface IUniswapFactory {
    event PairCreated(
        address indexed token0,
        address indexed token1,
        address pair,
        uint256
    );

    function getPair(address tokenA, address tokenB)
        external
        view
        returns (address pair);

    function allPairs(uint256) external view returns (address pair);

    function allPairsLength() external view returns (uint256);

    function feeTo() external view returns (address);

    function feeToSetter() external view returns (address);

    function createPair(address tokenA, address tokenB)
        external
        returns (address pair);

    // Create Exchange
    function createExchange(address token) external returns (address exchange);

    // Get Exchange and Token Info
    function getExchange(address token)
        external
        view
        returns (address exchange);

    function getToken(address exchange) external view returns (address token);

    function getTokenWithId(uint256 tokenId)
        external
        view
        returns (address token);

    // Never use
    function initializeFactory(address template) external;
}",245
RealWorld_BA_31_IPing_RealWord_20240819212052.log,31,IPing,3530,3778,7308,95.0,0.09321,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface IPing {
    function ping() external pure returns (uint256);
}",38
RealWorld_BA_31_veCVXStrategy_RealWord_20240819153920.log,31,veCVXStrategy,74099,5874,79973,97.0,0.487975,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.11;
pragma experimental ABIEncoderV2;

import ""../deps/@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/math/MathUpgradeable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";

import ""../interfaces/uniswap/IUniswapRouterV2.sol"";
import ""../interfaces/badger/ISettV3.sol"";
import ""../interfaces/badger/IController.sol"";
import ""../interfaces/cvx/ICvxLocker.sol"";
import ""../interfaces/snapshot/IDelegateRegistry.sol"";

import {BaseStrategy} from ""../deps/BaseStrategy.sol"";

contract MyStrategy is BaseStrategy {
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using AddressUpgradeable for address;
    using SafeMathUpgradeable for uint256;

    uint256 MAX_BPS = 10_000;

    // address public want // Inherited from BaseStrategy, the token the strategy wants, swaps into and tries to grow
    address public lpComponent; // Token we provide liquidity with
    address public reward; // Token we farm and swap to want / lpComponent
    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address public constant CVX = 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;

    address public constant SUSHI_ROUTER =
        0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;

    IDelegateRegistry public constant SNAPSHOT =
        IDelegateRegistry(0x469788fE6E9E9681C6ebF3bF78e7Fd26Fc015446);

    // The address this strategies delegates voting to
    address public constant DELEGATE =
        0xB65cef03b9B89f99517643226d76e286ee999e77;

    bytes32 public constant DELEGATED_SPACE =
        0x6376782e65746800000000000000000000000000000000000000000000000000;

    ICvxLocker public LOCKER;

    ISettV3 public CVX_VAULT =
        ISettV3(0x53C8E199eb2Cb7c01543C137078a038937a68E40);

    bool public withdrawalSafetyCheck = true;
    bool public harvestOnRebalance = true;
    // If nothing is unlocked, processExpiredLocks will revert
    bool public processLocksOnReinvest = true;
    bool public processLocksOnRebalance = true;

    event Debug(string name, uint256 value);

    // Used to signal to the Badger Tree that rewards where sent to it
    event TreeDistribution(
        address indexed token,
        uint256 amount,
        uint256 indexed blockNumber,
        uint256 timestamp
    );

    function initialize(
        address _governance,
        address _strategist,
        address _controller,
        address _keeper,
        address _guardian,
        address[3] memory _wantConfig,
        uint256[3] memory _feeConfig,
        address _locker ///@dev TODO: Add this to deploy
    ) public initializer {
        __BaseStrategy_init(
            _governance,
            _strategist,
            _controller,
            _keeper,
            _guardian
        );

        /// @dev Add config here
        want = _wantConfig[0];
        lpComponent = _wantConfig[1];
        reward = _wantConfig[2];

        performanceFeeGovernance = _feeConfig[0];
        performanceFeeStrategist = _feeConfig[1];
        withdrawalFee = _feeConfig[2];

        LOCKER = ICvxLocker(_locker); //TODO: Make locker hardcoded at top of file

        /// @dev do one off approvals here
        // IERC20Upgradeable(want).safeApprove(gauge, type(uint256).max);
        // Permissions for Locker
        IERC20Upgradeable(CVX).safeApprove(_locker, type(uint256).max);
        IERC20Upgradeable(CVX).safeApprove(
            address(CVX_VAULT),
            type(uint256).max
        );

        // Permissions for Sushiswap
        IERC20Upgradeable(reward).safeApprove(SUSHI_ROUTER, type(uint256).max);

        // Delegate voting to DELEGATE
        SNAPSHOT.setDelegate(DELEGATED_SPACE, DELEGATE);
    }

    /// ===== Extra Functions =====
    ///@dev Should we check if the amount requested is more than what we can return on withdrawal?
    function setWithdrawalSafetyCheck(bool newWithdrawalSafetyCheck) public {
        _onlyGovernance();
        withdrawalSafetyCheck = newWithdrawalSafetyCheck;
    }

    ///@dev Should we harvest before doing manual rebalancing
    ///@notice you most likely want to skip harvest if everything is unlocked, or there's something wrong and you just want out
    function setHarvestOnRebalance(bool newHarvestOnRebalance) public {
        _onlyGovernance();
        harvestOnRebalance = newHarvestOnRebalance;
    }

    ///@dev Should we processExpiredLocks during reinvest?
    function setProcessLocksOnReinvest(bool newProcessLocksOnReinvest) public {
        _onlyGovernance();
        processLocksOnReinvest = newProcessLocksOnReinvest;
    }

    ///@dev Should we processExpiredLocks during manualRebalance?
    function setProcessLocksOnRebalance(bool newProcessLocksOnRebalance)
        public
    {
        _onlyGovernance();
        processLocksOnRebalance = newProcessLocksOnRebalance;
    }

    /// ===== View Functions =====

    /// @dev Specify the name of the strategy
    function getName() external pure override returns (string memory) {
        return ""veCVX Voting Strategy"";
    }

    /// @dev Specify the version of the Strategy, for upgrades
    function version() external pure returns (string memory) {
        return ""1.0"";
    }

    /// @dev From CVX Token to Helper Vault Token
    function CVXToWant(uint256 cvx) public view returns (uint256) {
        uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare();
        return cvx.mul(10**18).div(bCVXToCVX);
    }

    /// @dev From Helper Vault Token to CVX Token
    function wantToCVX(uint256 want) public view returns (uint256) {
        uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare();
        return want.mul(bCVXToCVX).div(10**18);
    }

    /// @dev Balance of want currently held in strategy positions
    function balanceOfPool() public view override returns (uint256) {
        if (withdrawalSafetyCheck) {
            uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare(); // 18 decimals
            require(bCVXToCVX > 10**18, ""Loss Of Peg""); // Avoid trying to redeem for less / loss of peg
        }

        // Return the balance in locker + unlocked but not withdrawn, better estimate to allow some withdrawals
        // then multiply it by the price per share as we need to convert CVX to bCVX
        uint256 valueInLocker =
            CVXToWant(LOCKER.lockedBalanceOf(address(this))).add(
                CVXToWant(IERC20Upgradeable(CVX).balanceOf(address(this)))
            );

        return (valueInLocker);
    }

    /// @dev Returns true if this strategy requires tending
    function isTendable() public view override returns (bool) {
        return false;
    }

    // @dev These are the tokens that cannot be moved except by the vault
    function getProtectedTokens()
        public
        view
        override
        returns (address[] memory)
    {
        address[] memory protectedTokens = new address[](4);
        protectedTokens[0] = want;
        protectedTokens[1] = lpComponent;
        protectedTokens[2] = reward;
        protectedTokens[3] = CVX;
        return protectedTokens;
    }

    /// ===== Permissioned Actions: Governance =====
    /// @notice Delete if you don't need!
    function setKeepReward(uint256 _setKeepReward) external {
        _onlyGovernance();
    }

    /// ===== Internal Core Implementations =====

    /// @dev security check to avoid moving tokens that would cause a rugpull, edit based on strat
    function _onlyNotProtectedTokens(address _asset) internal override {
        address[] memory protectedTokens = getProtectedTokens();

        for (uint256 x = 0; x < protectedTokens.length; x++) {
            require(
                address(protectedTokens[x]) != _asset,
                ""Asset is protected""
            );
        }
    }

    /// @dev invest the amount of want
    /// @notice When this function is called, the controller has already sent want to this
    /// @notice Just get the current balance and then invest accordingly
    function _deposit(uint256 _amount) internal override {
        // We receive bCVX -> Convert to bCVX
        CVX_VAULT.withdraw(_amount);

        uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));

        // Lock tokens for 17 weeks, send credit to strat, always use max boost cause why not?
        LOCKER.lock(address(this), toDeposit, LOCKER.maximumBoostPayment());
    }

    /// @dev utility function to convert all we can to bCVX
    /// @notice You may want to harvest before calling this to maximize the amount of bCVX you'll have
    function prepareWithdrawAll() external {
        _onlyGovernance();

        LOCKER.processExpiredLocks(false);

        uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));
        if (toDeposit > 0) {
            CVX_VAULT.deposit(toDeposit);
        }
    }

    /// @dev utility function to withdraw everything for migration
    /// @dev NOTE: You cannot call this unless you have rebalanced to have only bCVX left in the vault
    function _withdrawAll() internal override {
        //NOTE: This probably will always fail unless we have all tokens expired
        require(
            LOCKER.lockedBalanceOf(address(this)) == 0 &&
                LOCKER.balanceOf(address(this)) == 0,
            ""You have to wait for unlock and have to manually rebalance out of it""
        );

        // NO-OP because you can't deposit AND transfer with bCVX
        // See prepareWithdrawAll above
    }

    /// @dev withdraw the specified amount of want, liquidate from lpComponent to want, paying off any necessary debt for the conversion
    function _withdrawSome(uint256 _amount)
        internal
        override
        returns (uint256)
    {
        uint256 max = IERC20Upgradeable(want).balanceOf(address(this));

        if (withdrawalSafetyCheck) {
            uint256 bCVXToCVX = CVX_VAULT.getPricePerFullShare(); // 18 decimals
            require(bCVXToCVX > 10**18, ""Loss Of Peg""); // Avoid trying to redeem for less / loss of peg
            require(
                max >= _amount.mul(9_980).div(MAX_BPS),
                ""Withdrawal Safety Check""
            ); // 20 BP of slippage
        }

        if (max < _amount) {
            return max;
        }

        return _amount;
    }

    /// @dev Harvest from strategy mechanics, realizing increase in underlying position
    function harvest() public whenNotPaused returns (uint256 harvested) {
        _onlyAuthorizedActors();

        uint256 _before = IERC20Upgradeable(want).balanceOf(address(this));

        uint256 _beforeCVX = IERC20Upgradeable(reward).balanceOf(address(this));

        // Get cvxCRV
        LOCKER.getReward(address(this), false);

        // Rewards Math
        uint256 earnedReward =
            IERC20Upgradeable(reward).balanceOf(address(this)).sub(_beforeCVX);

        // Because we are using bCVX we take fees in reward
        //NOTE: This will probably revert because we deposit and transfer on same block
        (uint256 governancePerformanceFee, uint256 strategistPerformanceFee) =
            _processRewardsFees(earnedReward, reward);

        // Swap cvxCRV for want (bCVX)
        _swapcvxCRVToWant();

        uint256 earned =
            IERC20Upgradeable(want).balanceOf(address(this)).sub(_before);

        /// @dev Harvest event that every strategy MUST have, see BaseStrategy
        emit Harvest(earned, block.number);

        /// @dev Harvest must return the amount of want increased
        return earned;
    }

    /// @dev Rebalance, Compound or Pay off debt here
    function tend() external whenNotPaused {
        _onlyAuthorizedActors();
        revert(); // NOTE: For now tend is replaced by manualRebalance
    }

    /// @dev Swap from reward to CVX, then deposit into bCVX vault
    function _swapcvxCRVToWant() internal {
        uint256 toSwap = IERC20Upgradeable(reward).balanceOf(address(this));

        if (toSwap == 0) {
            return;
        }

        // Sushi reward to WETH to want
        address[] memory path = new address[](3);
        path[0] = reward;
        path[1] = WETH;
        path[2] = CVX;
        IUniswapRouterV2(SUSHI_ROUTER).swapExactTokensForTokens(
            toSwap,
            0,
            path,
            address(this),
            now
        );

        // Deposit into vault
        uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));
        if (toDeposit > 0) {
            CVX_VAULT.deposit(toDeposit);
        }
    }

    /// ===== Internal Helper Functions =====

    /// @dev used to manage the governance and strategist fee, make sure to use it to get paid!
    function _processPerformanceFees(uint256 _amount)
        internal
        returns (
            uint256 governancePerformanceFee,
            uint256 strategistPerformanceFee
        )
    {
        governancePerformanceFee = _processFee(
            want,
            _amount,
            performanceFeeGovernance,
            IController(controller).rewards()
        );

        strategistPerformanceFee = _processFee(
            want,
            _amount,
            performanceFeeStrategist,
            strategist
        );
    }

    /// @dev used to manage the governance and strategist fee on earned rewards, make sure to use it to get paid!
    function _processRewardsFees(uint256 _amount, address _token)
        internal
        returns (uint256 governanceRewardsFee, uint256 strategistRewardsFee)
    {
        governanceRewardsFee = _processFee(
            _token,
            _amount,
            performanceFeeGovernance,
            IController(controller).rewards()
        );

        strategistRewardsFee = _processFee(
            _token,
            _amount,
            performanceFeeStrategist,
            strategist
        );
    }

    /// MANUAL FUNCTIONS ///

    /// @dev manual function to reinvest all CVX that was locked
    function reinvest() external whenNotPaused returns (uint256 reinvested) {
        _onlyGovernance();

        if (processLocksOnReinvest) {
            // Withdraw all we can
            LOCKER.processExpiredLocks(false);
        }

        // Redeposit all into veCVX
        uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));

        // Redeposit into veCVX
        LOCKER.lock(address(this), toDeposit, LOCKER.maximumBoostPayment());
    }

    /// @dev process all locks, to redeem
    function manualProcessExpiredLocks() external whenNotPaused {
        _onlyGovernance();
        LOCKER.processExpiredLocks(false);
        // Unlock veCVX that is expired and redeem CVX back to this strat
        // Processed in the next harvest or during prepareMigrateAll
    }

    /// @dev Take all CVX and deposits in the CVX_VAULT
    function manualDepositCVXIntoVault() external whenNotPaused {
        _onlyGovernance();

        uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));
        if (toDeposit > 0) {
            CVX_VAULT.deposit(toDeposit);
        }
    }

    /// @dev Send all available bCVX to the Vault
    /// @notice you can do this so you can earn again (re-lock), or just to add to the redemption pool
    function manualSendbCVXToVault() external whenNotPaused {
        _onlyGovernance();
        uint256 bCvxAmount = IERC20Upgradeable(want).balanceOf(address(this));
        _transferToVault(bCvxAmount);
    }

    /// @dev use the currently available CVX to either lock or add to bCVX
    /// @notice toLock = 0, lock nothing, deposit in bCVX as much as you can
    /// @notice toLock = 100, lock everything (CVX) you have
    function manualRebalance(uint256 toLock) external whenNotPaused {
        _onlyGovernance();
        require(toLock <= MAX_BPS, ""Max is 100%"");

        if (processLocksOnRebalance) {
            // manualRebalance will revert if you have no expired locks
            LOCKER.processExpiredLocks(false);
        }

        if (harvestOnRebalance) {
            harvest();
        }

        // Token that is highly liquid
        uint256 balanceOfWant =
            IERC20Upgradeable(want).balanceOf(address(this));
        // CVX uninvested we got from harvest and unlocks
        uint256 balanceOfCVX = IERC20Upgradeable(CVX).balanceOf(address(this));
        // Locked CVX in the locker
        uint256 balanceInLock = LOCKER.balanceOf(address(this));
        uint256 totalCVXBalance =
            balanceOfCVX.add(balanceInLock).add(wantToCVX(balanceOfWant));

        //Ratios
        uint256 currentLockRatio =
            balanceInLock.mul(10**18).div(totalCVXBalance);
        // Amount we want to have in lock
        uint256 newLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS);
        // Amount we want to have in bCVX
        uint256 toWantRatio =
            totalCVXBalance.mul(MAX_BPS.sub(toLock)).div(MAX_BPS);

        // We can't unlock enough, just deposit rest into bCVX
        if (newLockRatio <= currentLockRatio) {
            // Deposit into vault
            uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));
            if (toDeposit > 0) {
                CVX_VAULT.deposit(toDeposit);
            }

            return;
        }

        // If we're continuing, then we are going to lock something (unless it's zero)
        uint256 cvxToLock = newLockRatio.sub(currentLockRatio);

        // NOTE: We only lock the CVX we have and not the bCVX
        // bCVX should be sent back to vault and then go through earn
        // We do this because bCVX has ""blockLock"" and we can't both deposit and withdraw on the same block
        uint256 maxCVX = IERC20Upgradeable(CVX).balanceOf(address(this));
        if (cvxToLock > maxCVX) {
            // Just lock what we can
            LOCKER.lock(address(this), maxCVX, LOCKER.maximumBoostPayment());
        } else {
            // Lock proper
            LOCKER.lock(address(this), cvxToLock, LOCKER.maximumBoostPayment());
        }

        // If anything else is left, deposit into vault
        uint256 cvxLeft = IERC20Upgradeable(CVX).balanceOf(address(this));
        if (cvxLeft > 0) {
            CVX_VAULT.deposit(cvxLeft);
        }
        // At the end of the rebalance, there won't be any balanceOfCVX as that token is not considered by our strat
    }
}",4491
RealWorld_BA_31_IDelegateRegistry_RealWord_20240819204759.log,31,IDelegateRegistry,4134,4554,8688,88.0,0.11175,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

///@dev Snapshot Delegate registry so we can delegate voting to XYZ
interface IDelegateRegistry {
    function setDelegate(bytes32 id, address delegate) external;

    function delegation(address, bytes32) external returns (address);
}",62
RealWorld_BA_31_ImplementationProvider_RealWord_20240819175417.log,31,ImplementationProvider,4425,3663,8088,84.0,0.095385,"pragma solidity ^0.5.0;

/**
 * @title ImplementationProvider
 * @dev Abstract contract for providing implementation addresses for other contracts by name.
 */
contract ImplementationProvider {
    /**
     * @dev Abstract function to return the implementation address of a contract.
     * @param contractName Name of the contract.
     * @return Implementation address of the contract.
     */
    function getImplementation(string memory contractName)
        public
        view
        returns (address);
}",97
RealWorld_BA_31_MockToken_RealWord_20240819154539.log,31,MockToken,5991,4932,10923,82.0,0.128595,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";

contract MockToken is ERC20Upgradeable {
    function initialize(address[] memory holders, uint256[] memory balances)
        public
        initializer
    {
        __ERC20_init(""Mock"", ""Mock"");
        require(
            holders.length == balances.length,
            ""Constructor array size mismatch""
        );
        for (uint256 i = 0; i < holders.length; i++) {
            _mint(holders[i], balances[i]);
        }
    }

    /// @dev Open minting capabilities
    function mint(address account, uint256 amount) public {
        _mint(account, amount);
    }

    /// @dev Open burning capabilities, from any account
    function burn(address account, uint256 amount) public {
        _burn(account, amount);
    }
}",196
RealWorld_BA_31_IERC777RecipientUpgradeable_RealWord_20240819182820.log,31,IERC777RecipientUpgradeable,7445,4483,11928,107.0,0.126885,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.
 *
 * Accounts can be notified of {IERC777} tokens being sent to them by having a
 * contract implement this interface (contract holders can be their own
 * implementer) and registering it on the
 * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].
 *
 * See {IERC1820Registry} and {ERC1820Implementer}.
 */
interface IERC777RecipientUpgradeable {
    /**
     * @dev Called by an {IERC777} token contract whenever tokens are being
     * moved or created into a registered account (`to`). The type of operation
     * is conveyed by `from` being the zero address or not.
     *
     * This call occurs _after_ the token contract's state is updated, so
     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.
     *
     * This function may revert to prevent the operation from being executed.
     */
    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external;
}",281
RealWorld_BA_31_IMiniMe_RealWord_20240819210809.log,31,IMiniMe,6027,4580,10607,117.0,0.121735,"// SPDX-License-Identifier: MIT

// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface IMiniMe {
    event ClaimedTokens(
        address indexed _token,
        address indexed _controller,
        uint256 _amount
    );
    event Transfer(address indexed _from, address indexed _to, uint256 _amount);
    event NewCloneToken(address indexed _cloneToken, uint256 _snapshotBlock);
    event Approval(
        address indexed _owner,
        address indexed _spender,
        uint256 _amount
    );

    function claimTokens(address _token) external;

    function enableTransfers(bool _transfersEnabled) external;

    function generateTokens(address _owner, uint256 _amount)
        external
        returns (bool);

    function destroyTokens(address _owner, uint256 _amount)
        external
        returns (bool);
}",185
RealWorld_BA_31_PausableUpgradeable_RealWord_20240819194912.log,31,PausableUpgradeable,11961,4998,16959,131.0,0.159765,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../GSN/ContextUpgradeable.sol"";
import ""../proxy/Initializable.sol"";

/**
 * @dev Contract module which allows children to implement an emergency stop
 * mechanism that can be triggered by an authorized account.
 *
 * This module is used through inheritance. It will make available the
 * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
 * the functions of your contract. Note that they will not be pausable by
 * simply including this module, only once the modifiers are put in place.
 */
contract PausableUpgradeable is Initializable, ContextUpgradeable {
    /**
     * @dev Emitted when the pause is triggered by `account`.
     */
    event Paused(address account);

    /**
     * @dev Emitted when the pause is lifted by `account`.
     */
    event Unpaused(address account);

    bool private _paused;

    /**
     * @dev Initializes the contract in unpaused state.
     */
    function __Pausable_init() internal initializer {
        __Context_init_unchained();
        __Pausable_init_unchained();
    }

    function __Pausable_init_unchained() internal initializer {
        _paused = false;
    }

    /**
     * @dev Returns true if the contract is paused, and false otherwise.
     */
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    modifier whenNotPaused() {
        require(!_paused, ""Pausable: paused"");
        _;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is paused.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    modifier whenPaused() {
        require(_paused, ""Pausable: not paused"");
        _;
    }

    /**
     * @dev Triggers stopped state.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(_msgSender());
    }

    /**
     * @dev Returns to normal state.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(_msgSender());
    }

    uint256[49] private __gap;
}",557
RealWorld_BA_31_IUnifiedLogger_RealWord_20240819212801.log,31,IUnifiedLogger,3529,4328,7857,99.0,0.104205,"//SPDX-License-Identifier: Unlicense
pragma solidity >=0.5.0 <0.8.0;

interface IUnifiedLogger {
    function batchLogs(bytes memory logs) external;
}",40
RealWorld_BA_31_IERC1155_RealWord_20240819162906.log,31,IERC1155,19305,4975,24280,75.0,0.196025,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""../../introspection/IERC165.sol"";

/**
 * @dev Required interface of an ERC1155 compliant contract, as defined in the
 * https://eips.ethereum.org/EIPS/eip-1155[EIP].
 *
 * _Available since v3.1._
 */
interface IERC1155 is IERC165 {
    /**
     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.
     */
    event TransferSingle(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256 id,
        uint256 value
    );

    /**
     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all
     * transfers.
     */
    event TransferBatch(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256[] ids,
        uint256[] values
    );

    /**
     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to
     * `approved`.
     */
    event ApprovalForAll(
        address indexed account,
        address indexed operator,
        bool approved
    );

    /**
     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.
     *
     * If an {URI} event was emitted for `id`, the standard
     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value
     * returned by {IERC1155MetadataURI-uri}.
     */
    event URI(string value, uint256 indexed id);

    /**
     * @dev Returns the amount of tokens of token type `id` owned by `account`.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function balanceOf(address account, uint256 id)
        external
        view
        returns (uint256);

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.
     *
     * Requirements:
     *
     * - `accounts` and `ids` must have the same length.
     */
    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)
        external
        view
        returns (uint256[] memory);

    /**
     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,
     *
     * Emits an {ApprovalForAll} event.
     *
     * Requirements:
     *
     * - `operator` cannot be the caller.
     */
    function setApprovalForAll(address operator, bool approved) external;

    /**
     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.
     *
     * See {setApprovalForAll}.
     */
    function isApprovedForAll(address account, address operator)
        external
        view
        returns (bool);

    /**
     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.
     * - `from` must have a balance of tokens of type `id` of at least `amount`.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes calldata data
    ) external;

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.
     *
     * Emits a {TransferBatch} event.
     *
     * Requirements:
     *
     * - `ids` and `amounts` must have the same length.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
     * acceptance magic value.
     */
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts,
        bytes calldata data
    ) external;
}",1022
RealWorld_BA_31_IERC721_RealWord_20240819162058.log,31,IERC721,21822,5327,27149,67.0,0.21565,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""../../introspection/IERC165.sol"";

/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721 is IERC165 {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(
        address indexed from,
        address indexed to,
        uint256 indexed tokenId
    );

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(
        address indexed owner,
        address indexed approved,
        uint256 indexed tokenId
    );

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(
        address indexed owner,
        address indexed operator,
        bool approved
    );

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId)
        external
        view
        returns (address operator);

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool _approved) external;

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator)
        external
        view
        returns (bool);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;
}",1136
RealWorld_BA_31_IPausable_RealWord_20240819214511.log,31,IPausable,3704,3775,7479,106.0,0.09402,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface IPausable {
    function pause() external;

    function unpause() external;
}",41
RealWorld_BA_31_IMerkleDistributor_RealWord_20240819212414.log,31,IMerkleDistributor,5503,4529,10032,100.0,0.118095,"// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.5.0;

// Allows anyone to claim a token if they exist in a merkle root.
interface IMerkleDistributor {
    // Returns true if the index has been marked claimed.
    function isClaimed(uint256 index) external view returns (bool);

    // Claim the given amount of the token to the given address. Reverts if the inputs are invalid.
    function claim(
        uint256 index,
        address account,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external;

    // This event is triggered whenever a call to #claim succeeds.
    event Claimed(uint256 index, address account, uint256 amount);
}",152
RealWorld_BA_31_IRelayRecipient_RealWord_20240819164932.log,31,IRelayRecipient,18113,5175,23288,82.0,0.194065,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Base interface for a contract that will be called via the GSN from {IRelayHub}.
 *
 * TIP: You don't need to write an implementation yourself! Inherit from {GSNRecipient} instead.
 */
interface IRelayRecipient {
    /**
     * @dev Returns the address of the {IRelayHub} instance this recipient interacts with.
     */
    function getHubAddr() external view returns (address);

    /**
     * @dev Called by {IRelayHub} to validate if this recipient accepts being charged for a relayed call. Note that the
     * recipient will be charged regardless of the execution result of the relayed call (i.e. if it reverts or not).
     *
     * The relay request was originated by `from` and will be served by `relay`. `encodedFunction` is the relayed call
     * calldata, so its first four bytes are the function selector. The relayed call will be forwarded `gasLimit` gas,
     * and the transaction executed with a gas price of at least `gasPrice`. ``relay``'s fee is `transactionFee`, and the
     * recipient will be charged at most `maxPossibleCharge` (in wei). `nonce` is the sender's (`from`) nonce for
     * replay attack protection in {IRelayHub}, and `approvalData` is a optional parameter that can be used to hold a signature
     * over all or some of the previous values.
     *
     * Returns a tuple, where the first value is used to indicate approval (0) or rejection (custom non-zero error code,
     * values 1 to 10 are reserved) and the second one is data to be passed to the other {IRelayRecipient} functions.
     *
     * {acceptRelayedCall} is called with 50k gas: if it runs out during execution, the request will be considered
     * rejected. A regular revert will also trigger a rejection.
     */
    function acceptRelayedCall(
        address relay,
        address from,
        bytes calldata encodedFunction,
        uint256 transactionFee,
        uint256 gasPrice,
        uint256 gasLimit,
        uint256 nonce,
        bytes calldata approvalData,
        uint256 maxPossibleCharge
    ) external view returns (uint256, bytes memory);

    /**
     * @dev Called by {IRelayHub} on approved relay call requests, before the relayed call is executed. This allows to e.g.
     * pre-charge the sender of the transaction.
     *
     * `context` is the second value returned in the tuple by {acceptRelayedCall}.
     *
     * Returns a value to be passed to {postRelayedCall}.
     *
     * {preRelayedCall} is called with 100k gas: if it runs out during execution or otherwise reverts, the relayed call
     * will not be executed, but the recipient will still be charged for the transaction's cost.
     */
    function preRelayedCall(bytes calldata context) external returns (bytes32);

    /**
     * @dev Called by {IRelayHub} on approved relay call requests, after the relayed call is executed. This allows to e.g.
     * charge the user for the relayed call costs, return any overcharges from {preRelayedCall}, or perform
     * contract-specific bookkeeping.
     *
     * `context` is the second value returned in the tuple by {acceptRelayedCall}. `success` is the execution status of
     * the relayed call. `actualCharge` is an estimate of how much the recipient will be charged for the transaction,
     * not including any gas used by {postRelayedCall} itself. `preRetVal` is {preRelayedCall}'s return value.
     *
     *
     * {postRelayedCall} is called with 100k gas: if it runs out during execution or otherwise reverts, the relayed call
     * and the call to {preRelayedCall} will be reverted retroactively, but the recipient will still be charged for the
     * transaction's cost.
     */
    function postRelayedCall(
        bytes calldata context,
        bool success,
        uint256 actualCharge,
        bytes32 preRetVal
    ) external;
}",917
RealWorld_BA_31_IERC1820Registry_RealWord_20240819171954.log,31,IERC1820Registry,22322,6045,28367,128.0,0.23251,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface of the global ERC1820 Registry, as defined in the
 * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register
 * implementers for interfaces in this registry, as well as query support.
 *
 * Implementers may be shared by multiple accounts, and can also implement more
 * than a single interface for each account. Contracts can implement interfaces
 * for themselves, but externally-owned accounts (EOA) must delegate this to a
 * contract.
 *
 * {IERC165} interfaces can also be queried via the registry.
 *
 * For an in-depth explanation and source code analysis, see the EIP text.
 */
interface IERC1820Registry {
    /**
     * @dev Sets `newManager` as the manager for `account`. A manager of an
     * account is able to set interface implementers for it.
     *
     * By default, each account is its own manager. Passing a value of `0x0` in
     * `newManager` will reset the manager to this initial state.
     *
     * Emits a {ManagerChanged} event.
     *
     * Requirements:
     *
     * - the caller must be the current manager for `account`.
     */
    function setManager(address account, address newManager) external;

    /**
     * @dev Returns the manager for `account`.
     *
     * See {setManager}.
     */
    function getManager(address account) external view returns (address);

    /**
     * @dev Sets the `implementer` contract as ``account``'s implementer for
     * `interfaceHash`.
     *
     * `account` being the zero address is an alias for the caller's address.
     * The zero address can also be used in `implementer` to remove an old one.
     *
     * See {interfaceHash} to learn how these are created.
     *
     * Emits an {InterfaceImplementerSet} event.
     *
     * Requirements:
     *
     * - the caller must be the current manager for `account`.
     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not
     * end in 28 zeroes).
     * - `implementer` must implement {IERC1820Implementer} and return true when
     * queried for support, unless `implementer` is the caller. See
     * {IERC1820Implementer-canImplementInterfaceForAddress}.
     */
    function setInterfaceImplementer(
        address account,
        bytes32 interfaceHash,
        address implementer
    ) external;

    /**
     * @dev Returns the implementer of `interfaceHash` for `account`. If no such
     * implementer is registered, returns the zero address.
     *
     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28
     * zeroes), `account` will be queried for support of it.
     *
     * `account` being the zero address is an alias for the caller's address.
     */
    function getInterfaceImplementer(address account, bytes32 interfaceHash)
        external
        view
        returns (address);

    /**
     * @dev Returns the interface hash for an `interfaceName`, as defined in the
     * corresponding
     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].
     */
    function interfaceHash(string calldata interfaceName)
        external
        pure
        returns (bytes32);

    /**
     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.
     *  @param account Address of the contract for which to update the cache.
     *  @param interfaceId ERC165 interface for which to update the cache.
     */
    function updateERC165Cache(address account, bytes4 interfaceId) external;

    /**
     *  @notice Checks whether a contract implements an ERC165 interface or not.
     *  If the result is not cached a direct lookup on the contract address is performed.
     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling
     *  {updateERC165Cache} with the contract address.
     *  @param account Address of the contract to check.
     *  @param interfaceId ERC165 interface to check.
     *  @return True if `account` implements `interfaceId`, false otherwise.
     */
    function implementsERC165Interface(address account, bytes4 interfaceId)
        external
        view
        returns (bool);

    /**
     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.
     *  @param account Address of the contract to check.
     *  @param interfaceId ERC165 interface to check.
     *  @return True if `account` implements `interfaceId`, false otherwise.
     */
    function implementsERC165InterfaceNoCache(
        address account,
        bytes4 interfaceId
    ) external view returns (bool);

    event InterfaceImplementerSet(
        address indexed account,
        bytes32 indexed interfaceHash,
        address indexed implementer
    );

    event ManagerChanged(address indexed account, address indexed newManager);
}",1128
RealWorld_BA_31_MerkleProofUpgradeable_RealWord_20240819193113.log,31,MerkleProofUpgradeable,7809,4455,12264,106.0,0.128145,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev These functions deal with verification of Merkle trees (hash trees),
 */
library MerkleProofUpgradeable {
    /**
     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree
     * defined by `root`. For this, a `proof` must be provided, containing
     * sibling hashes on the branch from the leaf to the root of the tree. Each
     * pair of leaves and each pair of pre-images are assumed to be sorted.
     */
    function verify(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool) {
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash <= proofElement) {
                // Hash(current computed hash + current element of the proof)
                computedHash = keccak256(
                    abi.encodePacked(computedHash, proofElement)
                );
            } else {
                // Hash(current element of the proof + current computed hash)
                computedHash = keccak256(
                    abi.encodePacked(proofElement, computedHash)
                );
            }
        }

        // Check if the computed hash (root) is equal to the provided root
        return computedHash == root;
    }
}",305
RealWorld_BA_31_IStakingProxy_RealWord_20240819205247.log,31,IStakingProxy,4070,4562,8632,98.0,0.11159,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

interface IStakingProxy {
    function getBalance() external view returns (uint256);

    function withdraw(uint256 _amount) external;

    function stake() external;

    function distribute() external;
}",57
RealWorld_BA_31_IERC721Enumerable_RealWord_20240819161404.log,31,IERC721Enumerable,6720,4482,11202,62.0,0.12324,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""./IERC721.sol"";

/**
 * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */
interface IERC721Enumerable is IERC721 {
    /**
     * @dev Returns the total amount of tokens stored by the contract.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.
     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.
     */
    function tokenOfOwnerByIndex(address owner, uint256 index)
        external
        view
        returns (uint256 tokenId);

    /**
     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.
     * Use along with {totalSupply} to enumerate all tokens.
     */
    function tokenByIndex(uint256 index) external view returns (uint256);
}",234
RealWorld_BA_31_IUniswapExchange_RealWord_20240819203802.log,31,IUniswapExchange,22502,5329,27831,94.0,0.21909,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface IUniswapExchange {
    // Address of ERC20 token sold on this exchange
    function tokenAddress() external view returns (address token);

    // Address of Uniswap Factory
    function factoryAddress() external view returns (address factory);

    // Provide Liquidity
    function addLiquidity(
        uint256 min_liquidity,
        uint256 max_tokens,
        uint256 deadline
    ) external payable returns (uint256);

    function removeLiquidity(
        uint256 amount,
        uint256 min_eth,
        uint256 min_tokens,
        uint256 deadline
    ) external returns (uint256, uint256);

    // Get Prices
    function getEthToTokenInputPrice(uint256 eth_sold)
        external
        view
        returns (uint256 tokens_bought);

    function getEthToTokenOutputPrice(uint256 tokens_bought)
        external
        view
        returns (uint256 eth_sold);

    function getTokenToEthInputPrice(uint256 tokens_sold)
        external
        view
        returns (uint256 eth_bought);

    function getTokenToEthOutputPrice(uint256 eth_bought)
        external
        view
        returns (uint256 tokens_sold);

    // Trade ETH to ERC20
    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline)
        external
        payable
        returns (uint256 tokens_bought);

    function ethToTokenTransferInput(
        uint256 min_tokens,
        uint256 deadline,
        address recipient
    ) external payable returns (uint256 tokens_bought);

    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline)
        external
        payable
        returns (uint256 eth_sold);

    function ethToTokenTransferOutput(
        uint256 tokens_bought,
        uint256 deadline,
        address recipient
    ) external payable returns (uint256 eth_sold);

    // Trade ERC20 to ETH
    function tokenToEthSwapInput(
        uint256 tokens_sold,
        uint256 min_eth,
        uint256 deadline
    ) external returns (uint256 eth_bought);

    function tokenToEthTransferInput(
        uint256 tokens_sold,
        uint256 min_eth,
        uint256 deadline,
        address recipient
    ) external returns (uint256 eth_bought);

    function tokenToEthSwapOutput(
        uint256 eth_bought,
        uint256 max_tokens,
        uint256 deadline
    ) external returns (uint256 tokens_sold);

    function tokenToEthTransferOutput(
        uint256 eth_bought,
        uint256 max_tokens,
        uint256 deadline,
        address recipient
    ) external returns (uint256 tokens_sold);

    // Trade ERC20 to ERC20
    function tokenToTokenSwapInput(
        uint256 tokens_sold,
        uint256 min_tokens_bought,
        uint256 min_eth_bought,
        uint256 deadline,
        address token_addr
    ) external returns (uint256 tokens_bought);

    function tokenToTokenTransferInput(
        uint256 tokens_sold,
        uint256 min_tokens_bought,
        uint256 min_eth_bought,
        uint256 deadline,
        address recipient,
        address token_addr
    ) external returns (uint256 tokens_bought);

    function tokenToTokenSwapOutput(
        uint256 tokens_bought,
        uint256 max_tokens_sold,
        uint256 max_eth_sold,
        uint256 deadline,
        address token_addr
    ) external returns (uint256 tokens_sold);

    function tokenToTokenTransferOutput(
        uint256 tokens_bought,
        uint256 max_tokens_sold,
        uint256 max_eth_sold,
        uint256 deadline,
        address recipient,
        address token_addr
    ) external returns (uint256 tokens_sold);

    // Trade ERC20 to Custom Pool
    function tokenToExchangeSwapInput(
        uint256 tokens_sold,
        uint256 min_tokens_bought,
        uint256 min_eth_bought,
        uint256 deadline,
        address exchange_addr
    ) external returns (uint256 tokens_bought);

    function tokenToExchangeTransferInput(
        uint256 tokens_sold,
        uint256 min_tokens_bought,
        uint256 min_eth_bought,
        uint256 deadline,
        address recipient,
        address exchange_addr
    ) external returns (uint256 tokens_bought);

    function tokenToExchangeSwapOutput(
        uint256 tokens_bought,
        uint256 max_tokens_sold,
        uint256 max_eth_sold,
        uint256 deadline,
        address exchange_addr
    ) external returns (uint256 tokens_sold);

    function tokenToExchangeTransferOutput(
        uint256 tokens_bought,
        uint256 max_tokens_sold,
        uint256 max_eth_sold,
        uint256 deadline,
        address recipient,
        address exchange_addr
    ) external returns (uint256 tokens_sold);

    // ERC20 comaptibility for liquidity tokens
    function name() external view returns (bytes32);

    function symbol() external view returns (bytes32);

    function decimals() external view returns (uint256);

    function transfer(address _to, uint256 _value) external returns (bool);

    function transferFrom(
        address _from,
        address _to,
        uint256 value
    ) external returns (bool);

    function approve(address _spender, uint256 _value) external returns (bool);

    function allowance(address _owner, address _spender)
        external
        view
        returns (uint256);

    function balanceOf(address _owner) external view returns (uint256);

    function totalSupply() external view returns (uint256);

    // Never use
    function setup(address token_addr) external;
}",1174
RealWorld_BA_31_IERC721Upgradeable_RealWord_20240819184135.log,31,IERC721Upgradeable,22517,5802,28319,133.0,0.228625,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""../../introspection/IERC165Upgradeable.sol"";

/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721Upgradeable is IERC165Upgradeable {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(
        address indexed from,
        address indexed to,
        uint256 indexed tokenId
    );

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(
        address indexed owner,
        address indexed approved,
        uint256 indexed tokenId
    );

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(
        address indexed owner,
        address indexed operator,
        bool approved
    );

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId)
        external
        view
        returns (address operator);

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool _approved) external;

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator)
        external
        view
        returns (bool);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;
}",1142
RealWorld_BA_31_Math_RealWord_20240819173334.log,31,Math,6768,4763,11531,101.0,0.1291,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Standard math utilities missing in the Solidity language.
 */
library Math {
    /**
     * @dev Returns the largest of two numbers.
     */
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? a : b;
    }

    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two numbers. The result is rounded towards
     * zero.
     */
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow, so we distribute
        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);
    }
}",223
RealWorld_BA_31_IERC777SenderUpgradeable_RealWord_20240819183220.log,31,IERC777SenderUpgradeable,7675,5318,12993,131.0,0.144735,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface of the ERC777TokensSender standard as defined in the EIP.
 *
 * {IERC777} Token holders can be notified of operations performed on their
 * tokens by having a contract implement this interface (contract holders can be
 *  their own implementer) and registering it on the
 * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].
 *
 * See {IERC1820Registry} and {ERC1820Implementer}.
 */
interface IERC777SenderUpgradeable {
    /**
     * @dev Called by an {IERC777} token contract whenever a registered holder's
     * (`from`) tokens are about to be moved or destroyed. The type of operation
     * is conveyed by `to` being the zero address or not.
     *
     * This call occurs _before_ the token contract's state is updated, so
     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.
     *
     * This function may revert to prevent the operation from being executed.
     */
    function tokensToSend(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external;
}",286
RealWorld_BA_31_IRelayHub_RealWord_20240819164623.log,31,IRelayHub,48870,5829,54699,100.0,0.36093,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface for `RelayHub`, the core contract of the GSN. Users should not need to interact with this contract
 * directly.
 *
 * See the https://github.com/OpenZeppelin/openzeppelin-gsn-helpers[OpenZeppelin GSN helpers] for more information on
 * how to deploy an instance of `RelayHub` on your local test network.
 */
interface IRelayHub {
    // Relay management

    /**
     * @dev Adds stake to a relay and sets its `unstakeDelay`. If the relay does not exist, it is created, and the caller
     * of this function becomes its owner. If the relay already exists, only the owner can call this function. A relay
     * cannot be its own owner.
     *
     * All Ether in this function call will be added to the relay's stake.
     * Its unstake delay will be assigned to `unstakeDelay`, but the new value must be greater or equal to the current one.
     *
     * Emits a {Staked} event.
     */
    function stake(address relayaddr, uint256 unstakeDelay) external payable;

    /**
     * @dev Emitted when a relay's stake or unstakeDelay are increased
     */
    event Staked(address indexed relay, uint256 stake, uint256 unstakeDelay);

    /**
     * @dev Registers the caller as a relay.
     * The relay must be staked for, and not be a contract (i.e. this function must be called directly from an EOA).
     *
     * This function can be called multiple times, emitting new {RelayAdded} events. Note that the received
     * `transactionFee` is not enforced by {relayCall}.
     *
     * Emits a {RelayAdded} event.
     */
    function registerRelay(uint256 transactionFee, string calldata url)
        external;

    /**
     * @dev Emitted when a relay is registered or re-registered. Looking at these events (and filtering out
     * {RelayRemoved} events) lets a client discover the list of available relays.
     */
    event RelayAdded(
        address indexed relay,
        address indexed owner,
        uint256 transactionFee,
        uint256 stake,
        uint256 unstakeDelay,
        string url
    );

    /**
     * @dev Removes (deregisters) a relay. Unregistered (but staked for) relays can also be removed.
     *
     * Can only be called by the owner of the relay. After the relay's `unstakeDelay` has elapsed, {unstake} will be
     * callable.
     *
     * Emits a {RelayRemoved} event.
     */
    function removeRelayByOwner(address relay) external;

    /**
     * @dev Emitted when a relay is removed (deregistered). `unstakeTime` is the time when unstake will be callable.
     */
    event RelayRemoved(address indexed relay, uint256 unstakeTime);

    /** Deletes the relay from the system, and gives back its stake to the owner.
     *
     * Can only be called by the relay owner, after `unstakeDelay` has elapsed since {removeRelayByOwner} was called.
     *
     * Emits an {Unstaked} event.
     */
    function unstake(address relay) external;

    /**
     * @dev Emitted when a relay is unstaked for, including the returned stake.
     */
    event Unstaked(address indexed relay, uint256 stake);

    // States a relay can be in
    enum RelayState {
        Unknown, // The relay is unknown to the system: it has never been staked for
        Staked, // The relay has been staked for, but it is not yet active
        Registered, // The relay has registered itself, and is active (can relay calls)
        Removed // The relay has been removed by its owner and can no longer relay calls. It must wait for its unstakeDelay to elapse before it can unstake
    }

    /**
     * @dev Returns a relay's status. Note that relays can be deleted when unstaked or penalized, causing this function
     * to return an empty entry.
     */
    function getRelay(address relay)
        external
        view
        returns (
            uint256 totalStake,
            uint256 unstakeDelay,
            uint256 unstakeTime,
            address payable owner,
            RelayState state
        );

    // Balance management

    /**
     * @dev Deposits Ether for a contract, so that it can receive (and pay for) relayed transactions.
     *
     * Unused balance can only be withdrawn by the contract itself, by calling {withdraw}.
     *
     * Emits a {Deposited} event.
     */
    function depositFor(address target) external payable;

    /**
     * @dev Emitted when {depositFor} is called, including the amount and account that was funded.
     */
    event Deposited(
        address indexed recipient,
        address indexed from,
        uint256 amount
    );

    /**
     * @dev Returns an account's deposits. These can be either a contract's funds, or a relay owner's revenue.
     */
    function balanceOf(address target) external view returns (uint256);

    /**
     * Withdraws from an account's balance, sending it back to it. Relay owners call this to retrieve their revenue, and
     * contracts can use it to reduce their funding.
     *
     * Emits a {Withdrawn} event.
     */
    function withdraw(uint256 amount, address payable dest) external;

    /**
     * @dev Emitted when an account withdraws funds from `RelayHub`.
     */
    event Withdrawn(
        address indexed account,
        address indexed dest,
        uint256 amount
    );

    // Relaying

    /**
     * @dev Checks if the `RelayHub` will accept a relayed operation.
     * Multiple things must be true for this to happen:
     *  - all arguments must be signed for by the sender (`from`)
     *  - the sender's nonce must be the current one
     *  - the recipient must accept this transaction (via {acceptRelayedCall})
     *
     * Returns a `PreconditionCheck` value (`OK` when the transaction can be relayed), or a recipient-specific error
     * code if it returns one in {acceptRelayedCall}.
     */
    function canRelay(
        address relay,
        address from,
        address to,
        bytes calldata encodedFunction,
        uint256 transactionFee,
        uint256 gasPrice,
        uint256 gasLimit,
        uint256 nonce,
        bytes calldata signature,
        bytes calldata approvalData
    ) external view returns (uint256 status, bytes memory recipientContext);

    // Preconditions for relaying, checked by canRelay and returned as the corresponding numeric values.
    enum PreconditionCheck {
        OK, // All checks passed, the call can be relayed
        WrongSignature, // The transaction to relay is not signed by requested sender
        WrongNonce, // The provided nonce has already been used by the sender
        AcceptRelayedCallReverted, // The recipient rejected this call via acceptRelayedCall
        InvalidRecipientStatusCode // The recipient returned an invalid (reserved) status code
    }

    /**
     * @dev Relays a transaction.
     *
     * For this to succeed, multiple conditions must be met:
     *  - {canRelay} must `return PreconditionCheck.OK`
     *  - the sender must be a registered relay
     *  - the transaction's gas price must be larger or equal to the one that was requested by the sender
     *  - the transaction must have enough gas to not run out of gas if all internal transactions (calls to the
     * recipient) use all gas available to them
     *  - the recipient must have enough balance to pay the relay for the worst-case scenario (i.e. when all gas is
     * spent)
     *
     * If all conditions are met, the call will be relayed and the recipient charged. {preRelayedCall}, the encoded
     * function and {postRelayedCall} will be called in that order.
     *
     * Parameters:
     *  - `from`: the client originating the request
     *  - `to`: the target {IRelayRecipient} contract
     *  - `encodedFunction`: the function call to relay, including data
     *  - `transactionFee`: fee (%) the relay takes over actual gas cost
     *  - `gasPrice`: gas price the client is willing to pay
     *  - `gasLimit`: gas to forward when calling the encoded function
     *  - `nonce`: client's nonce
     *  - `signature`: client's signature over all previous params, plus the relay and RelayHub addresses
     *  - `approvalData`: dapp-specific data forwarded to {acceptRelayedCall}. This value is *not* verified by the
     * `RelayHub`, but it still can be used for e.g. a signature.
     *
     * Emits a {TransactionRelayed} event.
     */
    function relayCall(
        address from,
        address to,
        bytes calldata encodedFunction,
        uint256 transactionFee,
        uint256 gasPrice,
        uint256 gasLimit,
        uint256 nonce,
        bytes calldata signature,
        bytes calldata approvalData
    ) external;

    /**
     * @dev Emitted when an attempt to relay a call failed.
     *
     * This can happen due to incorrect {relayCall} arguments, or the recipient not accepting the relayed call. The
     * actual relayed call was not executed, and the recipient not charged.
     *
     * The `reason` parameter contains an error code: values 1-10 correspond to `PreconditionCheck` entries, and values
     * over 10 are custom recipient error codes returned from {acceptRelayedCall}.
     */
    event CanRelayFailed(
        address indexed relay,
        address indexed from,
        address indexed to,
        bytes4 selector,
        uint256 reason
    );

    /**
     * @dev Emitted when a transaction is relayed.
     * Useful when monitoring a relay's operation and relayed calls to a contract
     *
     * Note that the actual encoded function might be reverted: this is indicated in the `status` parameter.
     *
     * `charge` is the Ether value deducted from the recipient's balance, paid to the relay's owner.
     */
    event TransactionRelayed(
        address indexed relay,
        address indexed from,
        address indexed to,
        bytes4 selector,
        RelayCallStatus status,
        uint256 charge
    );

    // Reason error codes for the TransactionRelayed event
    enum RelayCallStatus {
        OK, // The transaction was successfully relayed and execution successful - never included in the event
        RelayedCallFailed, // The transaction was relayed, but the relayed call failed
        PreRelayedFailed, // The transaction was not relayed due to preRelatedCall reverting
        PostRelayedFailed, // The transaction was relayed and reverted due to postRelatedCall reverting
        RecipientBalanceChanged // The transaction was relayed and reverted due to the recipient's balance changing
    }

    /**
     * @dev Returns how much gas should be forwarded to a call to {relayCall}, in order to relay a transaction that will
     * spend up to `relayedCallStipend` gas.
     */
    function requiredGas(uint256 relayedCallStipend)
        external
        view
        returns (uint256);

    /**
     * @dev Returns the maximum recipient charge, given the amount of gas forwarded, gas price and relay fee.
     */
    function maxPossibleCharge(
        uint256 relayedCallStipend,
        uint256 gasPrice,
        uint256 transactionFee
    ) external view returns (uint256);

    // Relay penalization.
    // Any account can penalize relays, removing them from the system immediately, and rewarding the
    // reporter with half of the relay's stake. The other half is burned so that, even if the relay penalizes itself, it
    // still loses half of its stake.

    /**
     * @dev Penalize a relay that signed two transactions using the same nonce (making only the first one valid) and
     * different data (gas price, gas limit, etc. may be different).
     *
     * The (unsigned) transaction data and signature for both transactions must be provided.
     */
    function penalizeRepeatedNonce(
        bytes calldata unsignedTx1,
        bytes calldata signature1,
        bytes calldata unsignedTx2,
        bytes calldata signature2
    ) external;

    /**
     * @dev Penalize a relay that sent a transaction that didn't target ``RelayHub``'s {registerRelay} or {relayCall}.
     */
    function penalizeIllegalTransaction(
        bytes calldata unsignedTx,
        bytes calldata signature
    ) external;

    /**
     * @dev Emitted when a relay is penalized.
     */
    event Penalized(address indexed relay, address sender, uint256 amount);

    /**
     * @dev Returns an account's nonce in `RelayHub`.
     */
    function getNonce(address from) external view returns (uint256);
}",2849
RealWorld_BA_31_GSNRecipientUpgradeable_RealWord_20240819191729.log,31,GSNRecipientUpgradeable,43712,5352,49064,152.0,0.3256,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./IRelayRecipientUpgradeable.sol"";
import ""./IRelayHubUpgradeable.sol"";
import ""./ContextUpgradeable.sol"";
import ""../proxy/Initializable.sol"";

/**
 * @dev Base GSN recipient contract: includes the {IRelayRecipient} interface
 * and enables GSN support on all contracts in the inheritance tree.
 *
 * TIP: This contract is abstract. The functions {IRelayRecipient-acceptRelayedCall},
 *  {_preRelayedCall}, and {_postRelayedCall} are not implemented and must be
 * provided by derived contracts. See the
 * xref:ROOT:gsn-strategies.adoc#gsn-strategies[GSN strategies] for more
 * information on how to use the pre-built {GSNRecipientSignature} and
 * {GSNRecipientERC20Fee}, or how to write your own.
 */
abstract contract GSNRecipientUpgradeable is
    Initializable,
    IRelayRecipientUpgradeable,
    ContextUpgradeable
{
    function __GSNRecipient_init() internal initializer {
        __Context_init_unchained();
        __GSNRecipient_init_unchained();
    }

    function __GSNRecipient_init_unchained() internal initializer {
        _relayHub = 0xD216153c06E857cD7f72665E0aF1d7D82172F494;
    }

    // Default RelayHub address, deployed on mainnet and all testnets at the same address
    address private _relayHub;

    uint256 private constant _RELAYED_CALL_ACCEPTED = 0;
    uint256 private constant _RELAYED_CALL_REJECTED = 11;

    // How much gas is forwarded to postRelayedCall
    uint256 internal constant _POST_RELAYED_CALL_MAX_GAS = 100000;

    /**
     * @dev Emitted when a contract changes its {IRelayHub} contract to a new one.
     */
    event RelayHubChanged(
        address indexed oldRelayHub,
        address indexed newRelayHub
    );

    /**
     * @dev Returns the address of the {IRelayHub} contract for this recipient.
     */
    function getHubAddr() public view override returns (address) {
        return _relayHub;
    }

    /**
     * @dev Switches to a new {IRelayHub} instance. This method is added for future-proofing: there's no reason to not
     * use the default instance.
     *
     * IMPORTANT: After upgrading, the {GSNRecipient} will no longer be able to receive relayed calls from the old
     * {IRelayHub} instance. Additionally, all funds should be previously withdrawn via {_withdrawDeposits}.
     */
    function _upgradeRelayHub(address newRelayHub) internal virtual {
        address currentRelayHub = _relayHub;
        require(
            newRelayHub != address(0),
            ""GSNRecipient: new RelayHub is the zero address""
        );
        require(
            newRelayHub != currentRelayHub,
            ""GSNRecipient: new RelayHub is the current one""
        );

        emit RelayHubChanged(currentRelayHub, newRelayHub);

        _relayHub = newRelayHub;
    }

    /**
     * @dev Returns the version string of the {IRelayHub} for which this recipient implementation was built. If
     * {_upgradeRelayHub} is used, the new {IRelayHub} instance should be compatible with this version.
     */
    // This function is view for future-proofing, it may require reading from
    // storage in the future.
    function relayHubVersion() public view returns (string memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return ""1.0.0"";
    }

    /**
     * @dev Withdraws the recipient's deposits in `RelayHub`.
     *
     * Derived contracts should expose this in an external interface with proper access control.
     */
    function _withdrawDeposits(uint256 amount, address payable payee)
        internal
        virtual
    {
        IRelayHubUpgradeable(_relayHub).withdraw(amount, payee);
    }

    // Overrides for Context's functions: when called from RelayHub, sender and
    // data require some pre-processing: the actual sender is stored at the end
    // of the call data, which in turns means it needs to be removed from it
    // when handling said data.

    /**
     * @dev Replacement for msg.sender. Returns the actual sender of a transaction: msg.sender for regular transactions,
     * and the end-user for GSN relayed calls (where msg.sender is actually `RelayHub`).
     *
     * IMPORTANT: Contracts derived from {GSNRecipient} should never use `msg.sender`, and use {_msgSender} instead.
     */
    function _msgSender()
        internal
        view
        virtual
        override
        returns (address payable)
    {
        if (msg.sender != _relayHub) {
            return msg.sender;
        } else {
            return _getRelayedCallSender();
        }
    }

    /**
     * @dev Replacement for msg.data. Returns the actual calldata of a transaction: msg.data for regular transactions,
     * and a reduced version for GSN relayed calls (where msg.data contains additional information).
     *
     * IMPORTANT: Contracts derived from {GSNRecipient} should never use `msg.data`, and use {_msgData} instead.
     */
    function _msgData() internal view virtual override returns (bytes memory) {
        if (msg.sender != _relayHub) {
            return msg.data;
        } else {
            return _getRelayedCallData();
        }
    }

    // Base implementations for pre and post relayedCall: only RelayHub can invoke them, and data is forwarded to the
    // internal hook.

    /**
     * @dev See `IRelayRecipient.preRelayedCall`.
     *
     * This function should not be overridden directly, use `_preRelayedCall` instead.
     *
     * * Requirements:
     *
     * - the caller must be the `RelayHub` contract.
     */
    function preRelayedCall(bytes memory context)
        public
        virtual
        override
        returns (bytes32)
    {
        require(
            msg.sender == getHubAddr(),
            ""GSNRecipient: caller is not RelayHub""
        );
        return _preRelayedCall(context);
    }

    /**
     * @dev See `IRelayRecipient.preRelayedCall`.
     *
     * Called by `GSNRecipient.preRelayedCall`, which asserts the caller is the `RelayHub` contract. Derived contracts
     * must implement this function with any relayed-call preprocessing they may wish to do.
     *
     */
    function _preRelayedCall(bytes memory context)
        internal
        virtual
        returns (bytes32);

    /**
     * @dev See `IRelayRecipient.postRelayedCall`.
     *
     * This function should not be overridden directly, use `_postRelayedCall` instead.
     *
     * * Requirements:
     *
     * - the caller must be the `RelayHub` contract.
     */
    function postRelayedCall(
        bytes memory context,
        bool success,
        uint256 actualCharge,
        bytes32 preRetVal
    ) public virtual override {
        require(
            msg.sender == getHubAddr(),
            ""GSNRecipient: caller is not RelayHub""
        );
        _postRelayedCall(context, success, actualCharge, preRetVal);
    }

    /**
     * @dev See `IRelayRecipient.postRelayedCall`.
     *
     * Called by `GSNRecipient.postRelayedCall`, which asserts the caller is the `RelayHub` contract. Derived contracts
     * must implement this function with any relayed-call postprocessing they may wish to do.
     *
     */
    function _postRelayedCall(
        bytes memory context,
        bool success,
        uint256 actualCharge,
        bytes32 preRetVal
    ) internal virtual;

    /**
     * @dev Return this in acceptRelayedCall to proceed with the execution of a relayed call. Note that this contract
     * will be charged a fee by RelayHub
     */
    function _approveRelayedCall()
        internal
        pure
        returns (uint256, bytes memory)
    {
        return _approveRelayedCall("""");
    }

    /**
     * @dev See `GSNRecipient._approveRelayedCall`.
     *
     * This overload forwards `context` to _preRelayedCall and _postRelayedCall.
     */
    function _approveRelayedCall(bytes memory context)
        internal
        pure
        returns (uint256, bytes memory)
    {
        return (_RELAYED_CALL_ACCEPTED, context);
    }

    /**
     * @dev Return this in acceptRelayedCall to impede execution of a relayed call. No fees will be charged.
     */
    function _rejectRelayedCall(uint256 errorCode)
        internal
        pure
        returns (uint256, bytes memory)
    {
        return (_RELAYED_CALL_REJECTED + errorCode, """");
    }

    /*
     * @dev Calculates how much RelayHub will charge a recipient for using `gas` at a `gasPrice`, given a relayer's
     * `serviceFee`.
     */
    function _computeCharge(
        uint256 gas,
        uint256 gasPrice,
        uint256 serviceFee
    ) internal pure returns (uint256) {
        // The fee is expressed as a percentage. E.g. a value of 40 stands for a 40% fee, so the recipient will be
        // charged for 1.4 times the spent amount.
        return (gas * gasPrice * (100 + serviceFee)) / 100;
    }

    function _getRelayedCallSender()
        private
        pure
        returns (address payable result)
    {
        // We need to read 20 bytes (an address) located at array index msg.data.length - 20. In memory, the array
        // is prefixed with a 32-byte length value, so we first add 32 to get the memory read index. However, doing
        // so would leave the address in the upper 20 bytes of the 32-byte word, which is inconvenient and would
        // require bit shifting. We therefore subtract 12 from the read index so the address lands on the lower 20
        // bytes. This can always be done due to the 32-byte prefix.

        // The final memory read index is msg.data.length - 20 + 32 - 12 = msg.data.length. Using inline assembly is the
        // easiest/most-efficient way to perform this operation.

        // These fields are not accessible from assembly
        bytes memory array = msg.data;
        uint256 index = msg.data.length;

        // solhint-disable-next-line no-inline-assembly
        assembly {
            // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.
            result := and(
                mload(add(array, index)),
                0xffffffffffffffffffffffffffffffffffffffff
            )
        }
        return result;
    }

    function _getRelayedCallData() private pure returns (bytes memory) {
        // RelayHub appends the sender address at the end of the calldata, so in order to retrieve the actual msg.data,
        // we must strip the last 20 bytes (length of an address type) from it.

        uint256 actualDataLength = msg.data.length - 20;
        bytes memory actualData = new bytes(actualDataLength);

        for (uint256 i = 0; i < actualDataLength; ++i) {
            actualData[i] = msg.data[i];
        }

        return actualData;
    }

    uint256[49] private __gap;
}",2532
RealWorld_BA_31_ProxyFactory_RealWord_20240819180700.log,31,ProxyFactory,20492,6316,26808,137.0,0.22878,"pragma solidity ^0.5.3;

import ""./InitializableAdminUpgradeabilityProxy.sol"";
import ""../cryptography/ECDSA.sol"";

contract ProxyFactory {
    event ProxyCreated(address proxy);

    bytes32 private contractCodeHash;

    constructor() public {
        contractCodeHash = keccak256(
            type(InitializableAdminUpgradeabilityProxy).creationCode
        );
    }

    function deployMinimal(address _logic, bytes memory _data)
        public
        returns (address proxy)
    {
        // Adapted from https://github.com/optionality/clone-factory/blob/32782f82dfc5a00d103a7e61a17a5dedbd1e8e9d/contracts/CloneFactory.sol
        bytes20 targetBytes = bytes20(_logic);
        assembly {
            let clone := mload(0x40)
            mstore(
                clone,
                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000
            )
            mstore(add(clone, 0x14), targetBytes)
            mstore(
                add(clone, 0x28),
                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000
            )
            proxy := create(0, clone, 0x37)
        }

        emit ProxyCreated(address(proxy));

        if (_data.length > 0) {
            (bool success, ) = proxy.call(_data);
            require(success);
        }
    }

    function deploy(
        uint256 _salt,
        address _logic,
        address _admin,
        bytes memory _data
    ) public returns (address) {
        return _deployProxy(_salt, _logic, _admin, _data, msg.sender);
    }

    function deploySigned(
        uint256 _salt,
        address _logic,
        address _admin,
        bytes memory _data,
        bytes memory _signature
    ) public returns (address) {
        address signer = getSigner(_salt, _logic, _admin, _data, _signature);
        require(signer != address(0), ""Invalid signature"");
        return _deployProxy(_salt, _logic, _admin, _data, signer);
    }

    function getDeploymentAddress(uint256 _salt, address _sender)
        public
        view
        returns (address)
    {
        // Adapted from https://github.com/archanova/solidity/blob/08f8f6bedc6e71c24758d20219b7d0749d75919d/contracts/contractCreator/ContractCreator.sol
        bytes32 salt = _getSalt(_salt, _sender);
        bytes32 rawAddress =
            keccak256(
                abi.encodePacked(
                    bytes1(0xff),
                    address(this),
                    salt,
                    contractCodeHash
                )
            );

        return address(bytes20(rawAddress << 96));
    }

    function getSigner(
        uint256 _salt,
        address _logic,
        address _admin,
        bytes memory _data,
        bytes memory _signature
    ) public view returns (address) {
        bytes32 msgHash =
            OpenZeppelinUpgradesECDSA.toEthSignedMessageHash(
                keccak256(
                    abi.encodePacked(
                        _salt,
                        _logic,
                        _admin,
                        _data,
                        address(this)
                    )
                )
            );

        return OpenZeppelinUpgradesECDSA.recover(msgHash, _signature);
    }

    function _deployProxy(
        uint256 _salt,
        address _logic,
        address _admin,
        bytes memory _data,
        address _sender
    ) internal returns (address) {
        InitializableAdminUpgradeabilityProxy proxy =
            _createProxy(_salt, _sender);
        emit ProxyCreated(address(proxy));
        proxy.initialize(_logic, _admin, _data);
        return address(proxy);
    }

    function _createProxy(uint256 _salt, address _sender)
        internal
        returns (InitializableAdminUpgradeabilityProxy)
    {
        address payable addr;
        bytes memory code =
            type(InitializableAdminUpgradeabilityProxy).creationCode;
        bytes32 salt = _getSalt(_salt, _sender);

        assembly {
            addr := create2(0, add(code, 0x20), mload(code), salt)
            if iszero(extcodesize(addr)) {
                revert(0, 0)
            }
        }

        return InitializableAdminUpgradeabilityProxy(addr);
    }

    function _getSalt(uint256 _salt, address _sender)
        internal
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(_salt, _sender));
    }
}",1017
RealWorld_BA_31_IConverter_RealWord_20240819214659.log,31,IConverter,3735,3967,7702,90.0,0.098015,"// SPDX-License-Identifier: MIT

// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface IConverter {
    function convert(address) external returns (uint256);
}",45
RealWorld_BA_31_IRelayRecipientUpgradeable_RealWord_20240819192228.log,31,IRelayRecipientUpgradeable,18015,5463,23478,133.0,0.199335,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Base interface for a contract that will be called via the GSN from {IRelayHub}.
 *
 * TIP: You don't need to write an implementation yourself! Inherit from {GSNRecipient} instead.
 */
interface IRelayRecipientUpgradeable {
    /**
     * @dev Returns the address of the {IRelayHub} instance this recipient interacts with.
     */
    function getHubAddr() external view returns (address);

    /**
     * @dev Called by {IRelayHub} to validate if this recipient accepts being charged for a relayed call. Note that the
     * recipient will be charged regardless of the execution result of the relayed call (i.e. if it reverts or not).
     *
     * The relay request was originated by `from` and will be served by `relay`. `encodedFunction` is the relayed call
     * calldata, so its first four bytes are the function selector. The relayed call will be forwarded `gasLimit` gas,
     * and the transaction executed with a gas price of at least `gasPrice`. ``relay``'s fee is `transactionFee`, and the
     * recipient will be charged at most `maxPossibleCharge` (in wei). `nonce` is the sender's (`from`) nonce for
     * replay attack protection in {IRelayHub}, and `approvalData` is a optional parameter that can be used to hold a signature
     * over all or some of the previous values.
     *
     * Returns a tuple, where the first value is used to indicate approval (0) or rejection (custom non-zero error code,
     * values 1 to 10 are reserved) and the second one is data to be passed to the other {IRelayRecipient} functions.
     *
     * {acceptRelayedCall} is called with 50k gas: if it runs out during execution, the request will be considered
     * rejected. A regular revert will also trigger a rejection.
     */
    function acceptRelayedCall(
        address relay,
        address from,
        bytes calldata encodedFunction,
        uint256 transactionFee,
        uint256 gasPrice,
        uint256 gasLimit,
        uint256 nonce,
        bytes calldata approvalData,
        uint256 maxPossibleCharge
    ) external view returns (uint256, bytes memory);

    /**
     * @dev Called by {IRelayHub} on approved relay call requests, before the relayed call is executed. This allows to e.g.
     * pre-charge the sender of the transaction.
     *
     * `context` is the second value returned in the tuple by {acceptRelayedCall}.
     *
     * Returns a value to be passed to {postRelayedCall}.
     *
     * {preRelayedCall} is called with 100k gas: if it runs out during execution or otherwise reverts, the relayed call
     * will not be executed, but the recipient will still be charged for the transaction's cost.
     */
    function preRelayedCall(bytes calldata context) external returns (bytes32);

    /**
     * @dev Called by {IRelayHub} on approved relay call requests, after the relayed call is executed. This allows to e.g.
     * charge the user for the relayed call costs, return any overcharges from {preRelayedCall}, or perform
     * contract-specific bookkeeping.
     *
     * `context` is the second value returned in the tuple by {acceptRelayedCall}. `success` is the execution status of
     * the relayed call. `actualCharge` is an estimate of how much the recipient will be charged for the transaction,
     * not including any gas used by {postRelayedCall} itself. `preRetVal` is {preRelayedCall}'s return value.
     *
     *
     * {postRelayedCall} is called with 100k gas: if it runs out during execution or otherwise reverts, the relayed call
     * and the call to {preRelayedCall} will be reverted retroactively, but the recipient will still be charged for the
     * transaction's cost.
     */
    function postRelayedCall(
        bytes calldata context,
        bool success,
        uint256 actualCharge,
        bytes32 preRetVal
    ) external;
}",919
RealWorld_BA_31_InitializableUpgradeabilityProxy_RealWord_20240819180316.log,31,InitializableUpgradeabilityProxy,7969,5302,13271,118.0,0.145885,"pragma solidity ^0.5.0;

import ""./BaseUpgradeabilityProxy.sol"";

/**
 * @title InitializableUpgradeabilityProxy
 * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing
 * implementation and init data.
 */
contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {
    /**
     * @dev Contract initializer.
     * @param _logic Address of the initial implementation.
     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.
     * It should include the signature and the parameters of the function to be called, as described in
     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.
     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.
     */
    function initialize(address _logic, bytes memory _data) public payable {
        require(_implementation() == address(0));
        assert(
            IMPLEMENTATION_SLOT ==
                bytes32(uint256(keccak256(""eip1967.proxy.implementation"")) - 1)
        );
        _setImplementation(_logic);
        if (_data.length > 0) {
            (bool success, ) = _logic.delegatecall(_data);
            require(success);
        }
    }
}",277
RealWorld_BA_31_IERC1820ImplementerUpgradeable_RealWord_20240819200753.log,31,IERC1820ImplementerUpgradeable,6137,4599,10736,114.0,0.122665,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface for an ERC1820 implementer, as defined in the
 * https://eips.ethereum.org/EIPS/eip-1820#interface-implementation-erc1820implementerinterface[EIP].
 * Used by contracts that will be registered as implementers in the
 * {IERC1820Registry}.
 */
interface IERC1820ImplementerUpgradeable {
    /**
     * @dev Returns a special value (`ERC1820_ACCEPT_MAGIC`) if this contract
     * implements `interfaceHash` for `account`.
     *
     * See {IERC1820Registry-setInterfaceImplementer}.
     */
    function canImplementInterfaceForAddress(
        bytes32 interfaceHash,
        address account
    ) external view returns (bytes32);
}",174
RealWorld_BA_31_IERC721Receiver_RealWord_20240819161618.log,31,IERC721Receiver,6271,4198,10469,69.0,0.115315,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @title ERC721 token receiver interface
 * @dev Interface for any contract that wants to support safeTransfers
 * from ERC721 asset contracts.
 */
interface IERC721Receiver {
    /**
     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
     * by `operator` from `from`, this function is called.
     *
     * It must return its Solidity selector to confirm the token transfer.
     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
     *
     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
     */
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}",202
RealWorld_BA_31_ICumulativeMultiTokenMerkleDistributor_RealWord_20240819215023.log,31,ICumulativeMultiTokenMerkleDistributor,6521,4881,11402,114.0,0.130225,"// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.5.0;

/*
    Cumulative Merkle distributor
*/
interface ICumulativeMultiTokenMerkleDistributor {
    /// @notice Emit when insufficient funds to handle incoming root totals
    event InsufficientFundsForRoot(bytes32 indexed root);
    event RootProposed(
        uint256 indexed cycle,
        bytes32 indexed root,
        bytes32 indexed contentHash,
        uint256 startBlock,
        uint256 endBlock,
        uint256 timestamp,
        uint256 blockNumber
    );
    event RootUpdated(
        uint256 indexed cycle,
        bytes32 indexed root,
        bytes32 indexed contentHash,
        uint256 startBlock,
        uint256 endBlock,
        uint256 timestamp,
        uint256 blockNumber
    );
    event Claimed(
        address indexed user,
        address indexed token,
        uint256 amount,
        uint256 indexed cycle,
        uint256 timestamp,
        uint256 blockNumber
    );
}",205
RealWorld_BA_31_IUniswapRouterV2_RealWord_20240819203939.log,31,IUniswapRouterV2,12434,5609,18043,100.0,0.17435,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface IUniswapRouterV2 {
    function factory() external view returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    )
        external
        returns (
            uint256 amountA,
            uint256 amountB,
            uint256 liquidity
        );

    function addLiquidityETH(
        address token,
        uint256 amountTokenDesired,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    )
        external
        payable
        returns (
            uint256 amountToken,
            uint256 amountETH,
            uint256 liquidity
        );

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB);

    function getAmountsOut(uint256 amountIn, address[] calldata path)
        external
        view
        returns (uint256[] memory amounts);

    function getAmountsIn(uint256 amountOut, address[] calldata path)
        external
        view
        returns (uint256[] memory amounts);

    function swapETHForExactTokens(
        uint256 amountOut,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function swapExactETHForTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function swapExactTokensForETH(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapTokensForExactETH(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapTokensForExactTokens(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);
}",599
RealWorld_BA_31_IStrategy_RealWord_20240819213532.log,31,IStrategy,7193,5191,12384,111.0,0.139785,"// SPDX-License-Identifier: MIT

// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;

interface IStrategy {
    function want() external view returns (address);

    function deposit() external;

    // NOTE: must exclude any tokens used in the yield
    // Controller role - withdraw should return to Controller
    function withdrawOther(address) external returns (uint256 balance);

    // Controller | Vault role - withdraw should always return to Vault
    function withdraw(uint256) external;

    // Controller | Vault role - withdraw should always return to Vault
    function withdrawAll() external returns (uint256);

    function balanceOf() external view returns (uint256);

    function getName() external pure returns (string memory);

    function setStrategist(address _strategist) external;

    function setWithdrawalFee(uint256 _withdrawalFee) external;

    function setPerformanceFeeStrategist(uint256 _performanceFeeStrategist)
        external;

    function setPerformanceFeeGovernance(uint256 _performanceFeeGovernance)
        external;

    function setGovernance(address _governance) external;

    function setController(address _controller) external;

    function tend() external;

    function harvest() external;
}",259
RealWorld_BA_31_IRewardStaking_RealWord_20240819205427.log,31,IRewardStaking,5574,5088,10662,124.0,0.12963,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

interface IRewardStaking {
    function stakeFor(address, uint256) external;

    function stake(uint256) external;

    function withdraw(uint256 amount, bool claim) external;

    function withdrawAndUnwrap(uint256 amount, bool claim) external;

    function earned(address account) external view returns (uint256);

    function getReward() external;

    function getReward(address _account, bool _claimExtras) external;

    function extraRewardsLength() external returns (uint256);

    function extraRewards(uint256 _pid) external returns (address);

    function rewardToken() external returns (address);
}",142
RealWorld_BA_31_ReentrancyGuard_RealWord_20240819170426.log,31,ReentrancyGuard,13565,4861,18426,88.0,0.165045,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() internal {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}",617
RealWorld_BA_32_ERC20_RealWord_20240819224100.log,32,ERC20,13316,5616,18932,138.0,0.1789,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.6;

import '../interfaces/IERC20.sol';

contract ERC20 is IERC20 {

  event Transfer(address indexed from, address indexed to, uint value);
  event Approval(address indexed owner, address indexed spender, uint value);

  mapping (address => uint) public override balanceOf;
  mapping (address => mapping (address => uint)) public override allowance;

  string public name;
  string public symbol;
  uint8  public override decimals;
  uint   public override totalSupply;

  constructor(
    string memory _name,
    string memory _symbol,
    uint8 _decimals
  ) {
    name = _name;
    symbol = _symbol;
    decimals = _decimals;
    require(_decimals > 0, ""decimals"");
  }

  function transfer(address _recipient, uint _amount) external override returns (bool) {
    _transfer(msg.sender, _recipient, _amount);
    return true;
  }

  function approve(address _spender, uint _amount) external override returns (bool) {
    _approve(msg.sender, _spender, _amount);
    return true;
  }

  function transferFrom(address _sender, address _recipient, uint _amount) external override returns (bool) {
    require(allowance[_sender][msg.sender] >= _amount, ""ERC20: insufficient approval"");
    _transfer(_sender, _recipient, _amount);
    _approve(_sender, msg.sender, allowance[_sender][msg.sender] - _amount);
    return true;
  }

  function _transfer(address _sender, address _recipient, uint _amount) internal virtual {
    require(_sender != address(0), ""ERC20: transfer from the zero address"");
    require(_recipient != address(0), ""ERC20: transfer to the zero address"");
    require(balanceOf[_sender] >= _amount, ""ERC20: insufficient funds"");

    balanceOf[_sender] -= _amount;
    balanceOf[_recipient] += _amount;
    emit Transfer(_sender, _recipient, _amount);
  }

  function _mint(address _account, uint _amount) internal {
    require(_account != address(0), ""ERC20: mint to the zero address"");

    totalSupply += _amount;
    balanceOf[_account] += _amount;
    emit Transfer(address(0), _account, _amount);
  }

  function _burn(address _account, uint _amount) internal {
    require(_account != address(0), ""ERC20: burn from the zero address"");

    balanceOf[_account] -= _amount;
    totalSupply -= _amount;
    emit Transfer(_account, address(0), _amount);
  }

  function _approve(address _owner, address _spender, uint _amount) internal {
    require(_owner != address(0), ""ERC20: approve from the zero address"");
    require(_spender != address(0), ""ERC20: approve to the zero address"");

    allowance[_owner][_spender] = _amount;
    emit Approval(_owner, _spender, _amount);
  }
}",651
RealWorld_BA_32_IWETH_RealWord_20240819231403.log,32,IWETH,3681,4112,7793,103.0,0.100645,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.6;

import './IERC20.sol';

interface IWETH is IERC20 {
  function deposit() external payable;
  function withdraw(uint wad) external;
}",50
RealWorld_BA_32_InterestRateModel_RealWord_20240819223119.log,32,InterestRateModel,18480,5067,23547,109.0,0.19374,"// SPDX-License-Identifier: UNLICENSED

// Copyright (c) 2021 0xdev0 - All rights reserved
// https://twitter.com/0xdev0

pragma solidity 0.8.6;

import './interfaces/IERC20.sol';
import './interfaces/IInterestRateModel.sol';

import './external/Math.sol';
import './external/Ownable.sol';

contract InterestRateModel is IInterestRateModel, Ownable {

  // InterestRateModel can be re-deployed later
  uint private constant BLOCK_TIME = 132e17; // 13.2 seconds
  uint private constant LP_RATE = 50e18; // 50%

  // Per block
  uint public minRate;
  uint public lowRate;
  uint public highRate;
  uint public targetUtilization; // 80e18 = 80%

  event NewMinRate(uint value);
  event NewLowRate(uint value);
  event NewHighRate(uint value);
  event NewTargetUtilization(uint value);

  constructor(
    uint _minRate,
    uint _lowRate,
    uint _highRate,
    uint _targetUtilization
  ) {
    minRate           = _timeRateToBlockRate(_minRate);
    lowRate           = _timeRateToBlockRate(_lowRate);
    highRate          = _timeRateToBlockRate(_highRate);
    targetUtilization = _targetUtilization;
  }

  function setMinRate(uint _value) external onlyOwner {
    require(_value < lowRate, ""InterestRateModel: _value < lowRate"");
    minRate = _timeRateToBlockRate(_value);
    emit NewMinRate(_value);
  }

  function setLowRate(uint _value) external onlyOwner {
    require(_value < highRate, ""InterestRateModel: _value < lowRate"");
    lowRate = _timeRateToBlockRate(_value);
    emit NewLowRate(_value);
  }

  function setHighRate(uint _value) external onlyOwner {
    highRate = _timeRateToBlockRate(_value);
    emit NewHighRate(_value);
  }

  function setTargetUtilization(uint _value) external onlyOwner {
    require(_value < 99e18, ""InterestRateModel: _value < 100e18"");
    targetUtilization = _value;
    emit NewTargetUtilization(_value);
  }

  // InterestRateModel can later be replaced for more granular fees per _pair
  function interestRatePerBlock(
    address _pair,
    address _token,
    uint    _totalSupply,
    uint    _totalDebt
  ) external view override returns(uint) {
    if (_totalSupply == 0 || _totalDebt == 0) { return minRate; }

    uint utilization = (_totalDebt * 100e18 / _totalSupply) * 100e18 / targetUtilization;

    if (utilization < 100e18) {
      uint rate = lowRate * utilization / 100e18;
      return Math.max(rate, minRate);
    } else {
      utilization = 100e18 * ( _totalDebt - (_totalSupply * targetUtilization / 100e18) ) / (_totalSupply * (100e18 - targetUtilization) / 100e18);
      utilization = Math.min(utilization, 100e18);
      return lowRate + (highRate - lowRate) * utilization / 100e18;
    }
  }

  // InterestRateModel can later be replaced for more granular fees per _pair
  function utilizationRate(
    address _pair,
    address _token,
    uint    _totalDebt,
    uint    _totalSupply
  ) external view returns(uint) {
    if (_totalSupply == 0 || _totalDebt == 0) { return 0; }
    return Math.min(_totalDebt * 100e18 / _totalSupply, 100e18);
  }

  // InterestRateModel can later be replaced for more granular fees per _pair
  function lpRate(address _pair, address _token) external view override returns(uint) {
    return LP_RATE;
  }

  // _uint is set as 1e18 = 1% (annual) and converted to the block rate
  function _timeRateToBlockRate(uint _uint) private view returns(uint) {
    return _uint / 365 / 86400 * BLOCK_TIME / 1e18;
  }
}",950
RealWorld_BA_32_IInterestRateModel_RealWord_20240819230111.log,32,IInterestRateModel,4384,4593,8977,94.0,0.11378,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.6;

interface IInterestRateModel {
  function lpRate(address _pair, address _token) external view returns(uint);
  function interestRatePerBlock(address _pair, address _token, uint _totalSupply, uint _totalDebt) external view returns(uint);
}",72
RealWorld_BA_32_IPeripheryPayments_RealWord_20240819233717.log,32,IPeripheryPayments,8612,5288,13900,116.0,0.14882,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.7.5;

/// @title Periphery Payments
/// @notice Functions to ease deposits and withdrawals of ETH
interface IPeripheryPayments {
    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.
    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.
    /// @param amountMinimum The minimum amount of WETH9 to unwrap
    /// @param recipient The address receiving ETH
    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;

    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`
    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps
    /// that use ether for the input amount
    function refundETH() external payable;

    /// @notice Transfers the full amount of a token held by this contract to recipient
    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users
    /// @param token The contract address of the token which will be transferred to `recipient`
    /// @param amountMinimum The minimum amount of token required for a transfer
    /// @param recipient The destination address of the token
    function sweepToken(
        address token,
        uint256 amountMinimum,
        address recipient
    ) external payable;
}",300
RealWorld_BA_32_IUniswapV3PoolActions_RealWord_20240819232524.log,32,IUniswapV3PoolActions,26629,5437,32066,135.0,0.241885,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.7.5;

/// @title Permissionless pool actions
/// @notice Contains pool methods that can be called by anyone
interface IUniswapV3PoolActions {
    /// @notice Sets the initial price for the pool
    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value
    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96
    function initialize(uint160 sqrtPriceX96) external;

    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position
    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback
    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends
    /// on tickLower, tickUpper, the amount of liquidity, and the current price.
    /// @param recipient The address for which the liquidity will be created
    /// @param tickLower The lower tick of the position in which to add liquidity
    /// @param tickUpper The upper tick of the position in which to add liquidity
    /// @param amount The amount of liquidity to mint
    /// @param data Any data that should be passed through to the callback
    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback
    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback
    function mint(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount,
        bytes calldata data
    ) external returns (uint256 amount0, uint256 amount1);

    /// @notice Collects tokens owed to a position
    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.
    /// @param recipient The address which should receive the fees collected
    /// @param tickLower The lower tick of the position for which to collect fees
    /// @param tickUpper The upper tick of the position for which to collect fees
    /// @param amount0Requested How much token0 should be withdrawn from the fees owed
    /// @param amount1Requested How much token1 should be withdrawn from the fees owed
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collect(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount0Requested,
        uint128 amount1Requested
    ) external returns (uint128 amount0, uint128 amount1);

    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position
    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0
    /// @dev Fees must be collected separately via a call to #collect
    /// @param tickLower The lower tick of the position for which to burn liquidity
    /// @param tickUpper The upper tick of the position for which to burn liquidity
    /// @param amount How much liquidity to burn
    /// @return amount0 The amount of token0 sent to the recipient
    /// @return amount1 The amount of token1 sent to the recipient
    function burn(
        int24 tickLower,
        int24 tickUpper,
        uint128 amount
    ) external returns (uint256 amount0, uint256 amount1);

    /// @notice Swap token0 for token1, or token1 for token0
    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback
    /// @param recipient The address to receive the output of the swap
    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0
    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this
    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap
    /// @param data Any data to be passed through to the callback
    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive
    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive
    function swap(
        address recipient,
        bool zeroForOne,
        int256 amountSpecified,
        uint160 sqrtPriceLimitX96,
        bytes calldata data
    ) external returns (int256 amount0, int256 amount1);

    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback
    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback
    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling
    /// with 0 amount{0,1} and sending the donation amount(s) from the callback
    /// @param recipient The address which will receive the token0 and token1 amounts
    /// @param amount0 The amount of token0 to send
    /// @param amount1 The amount of token1 to send
    /// @param data Any data to be passed through to the callback
    function flash(
        address recipient,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external;

    /// @notice Increase the maximum number of price and liquidity observations that this pool will store
    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to
    /// the input observationCardinalityNext.
    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store
    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
}",1453
RealWorld_BA_32_ILinkOracle_RealWord_20240819231029.log,32,ILinkOracle,3723,4259,7982,97.0,0.103795,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.6;

interface ILinkOracle {
  function latestAnswer() external view returns(uint);
  function decimals() external view returns(int256);
}",44
RealWorld_BA_32_Address_RealWord_20240819225011.log,32,Address,31527,5324,36851,124.0,0.264115,"// SPDX-License-Identifier: MIT

pragma solidity >=0.6.2;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, ""Address: insufficient balance"");

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }("""");
        require(success, ""Address: unable to send value, recipient may have reverted"");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain`call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, ""Address: low-level call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, ""Address: insufficient balance for call"");
        require(isContract(target), ""Address: call to non-contract"");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, ""Address: low-level static call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
        require(isContract(target), ""Address: static call to non-contract"");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        require(isContract(target), ""Address: delegate call to non-contract"");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}",1774
RealWorld_BA_32_PairFactory_RealWord_20240819222510.log,32,PairFactory,12308,5746,18054,117.0,0.17646,"// SPDX-License-Identifier: UNLICENSED

// Copyright (c) 2021 0xdev0 - All rights reserved
// https://twitter.com/0xdev0

pragma solidity 0.8.6;

import './interfaces/IPairFactory.sol';
import './interfaces/ILendingController.sol';

import './external/Ownable.sol';
import './external/Address.sol';
import './external/Clones.sol';

import './LendingPair.sol';

contract PairFactory is IPairFactory, Ownable {

  using Address for address;
  using Clones  for address;

  address public lendingPairMaster;
  address public lpTokenMaster;
  address public uniV3Helper;
  address public feeRecipient;
  ILendingController public lendingController;

  mapping(address => mapping(address => address)) public override pairByTokens;

  event PairCreated(address indexed pair, address indexed tokenA, address indexed tokenB);

  constructor(
    address _lendingPairMaster,
    address _lpTokenMaster,
    address _uniV3Helper,
    address _feeRecipient,
    ILendingController _lendingController
  ) {
    lendingPairMaster = _lendingPairMaster;
    lpTokenMaster     = _lpTokenMaster;
    uniV3Helper       = _uniV3Helper;
    feeRecipient      = _feeRecipient;
    lendingController = _lendingController;
  }

  function createPair(
    address _token0,
    address _token1
  ) external returns(address) {

    require(_token0 != _token1, 'PairFactory: duplicate tokens');
    require(_token0 != address(0) && _token1 != address(0), 'PairFactory: zero address');
    require(pairByTokens[_token0][_token1] == address(0), 'PairFactory: already exists');

    (address tokenA, address tokenB) = _token0 < _token1 ? (_token0, _token1) : (_token1, _token0);

    require(
      lendingController.tokenSupported(tokenA) && lendingController.tokenSupported(tokenB),
      ""PairFactory: token not supported""
    );

    LendingPair lendingPair = LendingPair(payable(lendingPairMaster.clone()));

    lendingPair.initialize(
      lpTokenMaster,
      address(lendingController),
      uniV3Helper,
      feeRecipient,
      tokenA,
      tokenB
    );

    pairByTokens[tokenA][tokenB] = address(lendingPair);
    pairByTokens[tokenB][tokenA] = address(lendingPair);

    emit PairCreated(address(lendingPair), tokenA, tokenB);

    return address(lendingPair);
  }
}",556
RealWorld_BA_32_ISwapRouter_RealWord_20240819233508.log,32,ISwapRouter,11914,4885,16799,127.0,0.15727,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.6;
pragma abicoder v2;

interface ISwapRouter {

    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    /// @notice Swaps `amountIn` of one token for as much as possible of another token
    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata
    /// @return amountOut The amount of the received token
    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);

    struct ExactInputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
    }

    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path
    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata
    /// @return amountOut The amount of the received token
    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);

    struct ExactOutputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
        uint160 sqrtPriceLimitX96;
    }

    /// @notice Swaps as little as possible of one token for `amountOut` of another token
    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata
    /// @return amountIn The amount of the input token
    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);

    struct ExactOutputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
    }

    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)
    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata
    /// @return amountIn The amount of the input token
    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);
}",549
RealWorld_BA_32_IUniswapV3Factory_RealWord_20240819232335.log,32,IUniswapV3Factory,18188,4785,22973,107.0,0.18664,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.6;

/// @title The interface for the Uniswap V3 Factory
/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees
interface IUniswapV3Factory {
    /// @notice Emitted when the owner of the factory is changed
    /// @param oldOwner The owner before the owner was changed
    /// @param newOwner The owner after the owner was changed
    event OwnerChanged(address indexed oldOwner, address indexed newOwner);

    /// @notice Emitted when a pool is created
    /// @param token0 The first token of the pool by address sort order
    /// @param token1 The second token of the pool by address sort order
    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
    /// @param tickSpacing The minimum number of ticks between initialized ticks
    /// @param pool The address of the created pool
    event PoolCreated(
        address indexed token0,
        address indexed token1,
        uint24 indexed fee,
        int24 tickSpacing,
        address pool
    );

    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory
    /// @param fee The enabled fee, denominated in hundredths of a bip
    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee
    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);

    /// @notice Returns the current owner of the factory
    /// @dev Can be changed by the current owner via setOwner
    /// @return The address of the factory owner
    function owner() external view returns (address);

    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled
    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context
    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee
    /// @return The tick spacing
    function feeAmountTickSpacing(uint24 fee) external view returns (int24);

    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist
    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order
    /// @param tokenA The contract address of either token0 or token1
    /// @param tokenB The contract address of the other token
    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
    /// @return pool The pool address
    function getPool(
        address tokenA,
        address tokenB,
        uint24 fee
    ) external view returns (address pool);

    /// @notice Creates a pool for the given two tokens and fee
    /// @param tokenA One of the two tokens in the desired pool
    /// @param tokenB The other of the two tokens in the desired pool
    /// @param fee The desired fee for the pool
    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved
    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments
    /// are invalid.
    /// @return pool The address of the newly created pool
    function createPool(
        address tokenA,
        address tokenB,
        uint24 fee
    ) external returns (address pool);

    /// @notice Updates the owner of the factory
    /// @dev Must be called by the current owner
    /// @param _owner The new owner of the factory
    function setOwner(address _owner) external;

    /// @notice Enables a fee amount with the given tickSpacing
    /// @dev Fee amounts may never be removed once enabled
    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)
    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount
    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
}",939
RealWorld_BA_32_ILendingController_RealWord_20240819231549.log,32,ILendingController,6789,5635,12424,113.0,0.146645,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.6;

import './IOwnable.sol';

interface ILendingController is IOwnable {
  function interestRateModel() external view returns(address);
  function liqFeeSystem(address _token) external view returns(uint);
  function liqFeeCaller(address _token) external view returns(uint);
  function uniMinOutputPct() external view returns(uint);
  function colFactor(address _token) external view returns(uint);
  function depositLimit(address _lendingPair, address _token) external view returns(uint);
  function borrowLimit(address _lendingPair, address _token) external view returns(uint);
  function depositsEnabled() external view returns(bool);
  function borrowingEnabled() external view returns(bool);
  function tokenPrice(address _token) external view returns(uint);
  function tokenPrices(address _tokenA, address _tokenB) external view returns (uint, uint);
  function tokenSupported(address _token) external view returns(bool);
}",208
RealWorld_BA_32_LendingPair_RealWord_20240819222709.log,32,LendingPair,104961,6189,111150,248.0,0.648585,"// SPDX-License-Identifier: UNLICENSED

// Copyright (c) 2021 0xdev0 - All rights reserved
// https://twitter.com/0xdev0

pragma solidity 0.8.6;

import './interfaces/IERC20.sol';
import './interfaces/IERC721.sol';
import './interfaces/ILPTokenMaster.sol';
import './interfaces/ILendingPair.sol';
import './interfaces/ILendingController.sol';
import './interfaces/univ3/IUniswapV3Helper.sol';
import './interfaces/IInterestRateModel.sol';

import './external/Math.sol';
import './external/Address.sol';
import './external/Clones.sol';
import './external/ReentrancyGuard.sol';
import './external/ERC721Receivable.sol';

import './TransferHelper.sol';

contract LendingPair is ILendingPair, ReentrancyGuard, TransferHelper, ERC721Receivable {

  IERC721 internal constant uniManager = IERC721(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);
  uint    public   constant LIQ_MIN_HEALTH = 1e18;

  using Address for address;
  using Clones for address;

  mapping (address => mapping (address => uint)) public override supplySharesOf;
  mapping (address => mapping (address => uint)) public debtSharesOf;
  mapping (address => uint) public pendingSystemFees;
  mapping (address => uint) public lastBlockAccrued;
  mapping (address => uint) public override totalSupplyShares;
  mapping (address => uint) public totalSupplyAmount;
  mapping (address => uint) public totalDebtShares;
  mapping (address => uint) public totalDebtAmount;
  mapping (address => uint) public uniPosition;
  mapping (address => uint) private decimals;
  mapping (address => address) public override lpToken;

  IUniswapV3Helper   private uniV3Helper;
  ILendingController public  lendingController;

  address public feeRecipient;
  address public override tokenA;
  address public override tokenB;

  event Liquidation(
    address indexed account,
    address indexed repayToken,
    address indexed supplyToken,
    uint repayAmount,
    uint supplyAmount
  );

  event Deposit(address indexed account, address indexed token, uint amount);
  event Withdraw(address indexed token, uint amount);
  event Borrow(address indexed token, uint amount);
  event Repay(address indexed account, address indexed token, uint amount);
  event CollectSystemFee(address indexed token, uint amount);
  event DepositUniPosition(address indexed account, uint positionID);
  event WithdrawUniPosition(uint positionID);

  receive() external payable {}

  modifier onlyLpToken() {
    require(lpToken[tokenA] == msg.sender || lpToken[tokenB] == msg.sender, ""LendingController: caller must be LP token"");
    _;
  }

  function initialize(
    address _lpTokenMaster,
    address _lendingController,
    address _uniV3Helper,
    address _feeRecipient,
    address _tokenA,
    address _tokenB
  ) external {
    require(tokenA == address(0), ""LendingPair: already initialized"");
    require(_tokenA != address(0) && _tokenB != address(0), ""LendingPair: cannot be ZERO address"");

    lendingController = ILendingController(_lendingController);
    uniV3Helper       = IUniswapV3Helper(_uniV3Helper);
    feeRecipient      = _feeRecipient;
    tokenA = _tokenA;
    tokenB = _tokenB;
    lastBlockAccrued[tokenA] = block.number;
    lastBlockAccrued[tokenB] = block.number;

    decimals[tokenA] = IERC20(tokenA).decimals();
    decimals[tokenB] = IERC20(tokenB).decimals();

    require(decimals[tokenA] >= 6 && decimals[tokenB] >= 6, ""LendingPair: min 6 decimals"");

    lpToken[tokenA] = _createLpToken(_lpTokenMaster, tokenA);
    lpToken[tokenB] = _createLpToken(_lpTokenMaster, tokenB);
  }

  // Deposit limits do not apply to Uniswap positions
  function depositUniPosition(address _account, uint _positionID) external {
    _checkDepositsEnabled();
    _validateUniPosition(_positionID);
    require(uniPosition[_account] == 0, ""LendingPair: one position per account"");

    uniManager.safeTransferFrom(msg.sender, address(this), _positionID);
    uniPosition[_account] = _positionID;

    emit DepositUniPosition(_account, _positionID);
  }

  function withdrawUniPosition() external {
    uint positionID = uniPosition[msg.sender];
    uniManager.safeTransferFrom(address(this), msg.sender, positionID);

    uniPosition[msg.sender] = 0;
    checkAccountHealth(msg.sender);

    emit WithdrawUniPosition(positionID);
  }

  // claim & mint supply from uniswap fees
  function uniClaimDeposit() external {
    (uint amountA, uint amountB) = _uniCollectFees(msg.sender);
    _mintSupplyAmount(tokenA, msg.sender, amountA);
    _mintSupplyAmount(tokenB, msg.sender, amountB);
  }

  // claim & withdraw uniswap fees
  function uniClaimWithdraw() external {
    (uint amountA, uint amountB) = _uniCollectFees(msg.sender);
    _safeTransfer(tokenA, msg.sender, amountA);
    _safeTransfer(tokenB, msg.sender, amountB);
  }

  function depositRepay(address _account, address _token, uint _amount) external nonReentrant {
    _validateToken(_token);
    accrue(_token);

    _depositRepay(_account, _token, _amount);
    _safeTransferFrom(_token, msg.sender, _amount);
  }

  function depositRepayETH(address _account) external payable nonReentrant {
    _validateToken(address(WETH));
    accrue(address(WETH));

    _depositRepay(_account, address(WETH), msg.value);
    _depositWeth();
  }

  function deposit(address _account, address _token, uint _amount) external override nonReentrant {
    _validateToken(_token);
    accrue(_token);

    _deposit(_account, _token, _amount);
    _safeTransferFrom(_token, msg.sender, _amount);
  }

  function withdrawBorrow(address _token, uint _amount) external nonReentrant {
    _validateToken(_token);
    accrue(_token);

    _withdrawBorrow(_token, _amount);
    _safeTransfer(_token, msg.sender, _amount);
  }

  function withdrawBorrowETH(uint _amount) external nonReentrant {
    _validateToken(address(WETH));
    accrue(address(WETH));

    _withdrawBorrow(address(WETH), _amount);
    _wethWithdrawTo(msg.sender, _amount);
  }

  function withdraw(address _token, uint _amount) external override nonReentrant {
    _validateToken(_token);
    accrue(_token);

    _withdrawShares(_token, _supplyToShares(_token, _amount));
    _safeTransfer(_token, msg.sender, _amount);
  }

  function withdrawAll(address _token) external override nonReentrant {
    _validateToken(_token);
    accrue(_token);

    uint shares = supplySharesOf[_token][msg.sender];
    _withdrawShares(_token, shares);
    _safeTransfer(_token, msg.sender, _sharesToSupply(_token, shares));
  }

  function withdrawAllETH() external nonReentrant {
    _validateToken(address(WETH));
    accrue(address(WETH));

    uint shares = supplySharesOf[address(WETH)][msg.sender];
    _withdrawShares(address(WETH), shares);
    _wethWithdrawTo(msg.sender, _sharesToSupply(address(WETH), shares));
  }

  function borrow(address _token, uint _amount) external nonReentrant {
    _validateToken(_token);
    accrue(_token);

    _borrow(_token, _amount);
    _safeTransfer(_token, msg.sender, _amount);
  }

  function repayAll(address _account, address _token, uint _maxAmount) external nonReentrant {
    _validateToken(_token);
    accrue(_token);

    uint amount = _repayShares(_account, _token, debtSharesOf[_token][_account]);
    require(amount <= _maxAmount, ""LendingPair: amount <= _maxAmount"");
    _safeTransferFrom(_token, msg.sender, amount);
  }

  function repayAllETH(address _account, uint _maxAmount) external payable nonReentrant {
    _validateToken(address(WETH));
    accrue(address(WETH));

    uint amount = _repayShares(_account, address(WETH), debtSharesOf[address(WETH)][_account]);
    require(msg.value >= amount, ""LendingPair: insufficient ETH deposit"");
    require(amount <= _maxAmount, ""LendingPair: amount <= _maxAmount"");

    _depositWeth();
    uint refundAmount = msg.value > amount ? (msg.value - amount) : 0;

    if (refundAmount > 0) {
      _wethWithdrawTo(msg.sender, refundAmount);
    }
  }

  function repay(address _account, address _token, uint _amount) external nonReentrant {
    _validateToken(_token);
    accrue(_token);

    _repayShares(_account, _token, _debtToShares(_token, _amount));
    _safeTransferFrom(_token, msg.sender, _amount);
  }

  function accrue(address _token) public {
    if (lastBlockAccrued[_token] < block.number) {
      uint newDebt   = _accrueDebt(_token);
      uint newSupply = newDebt * _lpRate(_token) / 100e18;
      totalSupplyAmount[_token] += newSupply;
      pendingSystemFees[_token] += (newDebt - newSupply);
      lastBlockAccrued[_token]   = block.number;
    }
  }

  function collectSystemFee(address _token, uint _amount) external nonReentrant {
    _validateToken(_token);
    pendingSystemFees[_token] -= _amount;
    _safeTransfer(_token, feeRecipient, _amount);
    emit CollectSystemFee(_token, _amount);
  }

  function transferLp(address _token, address _from, address _to, uint _amount) external override onlyLpToken {
    require(debtSharesOf[_token][_to] == 0, ""LendingPair: cannot deposit borrowed token"");
    supplySharesOf[_token][_from] -= _amount;
    supplySharesOf[_token][_to]   += _amount;
    checkAccountHealth(_from);
  }

  // Sell collateral to reduce debt and increase accountHealth
  // Set _repayAmount to type(uint).max to repay all debt, inc. pending interest
  function liquidateAccount(
    address _account,
    address _repayToken,
    uint    _repayAmount,
    uint    _minSupplyOutput
  ) external nonReentrant {

    // Input validation and adjustments

    _validateToken(_repayToken);

    address supplyToken = _repayToken == tokenA ? tokenB : tokenA;

    // Check account is underwater after interest

    accrue(supplyToken);
    accrue(_repayToken);

    uint health = accountHealth(_account);
    require(health < LIQ_MIN_HEALTH, ""LendingPair: account health < LIQ_MIN_HEALTH"");

    // Fully unwrap Uni position - withdraw & mint supply

    _unwrapUniPosition(_account);

    // Calculate balance adjustments

    _repayAmount = Math.min(_repayAmount, _debtOf(_repayToken, _account));
    (uint repayPrice, uint supplyPrice) = lendingController.tokenPrices(_repayToken, supplyToken);

    uint supplyDebt   = _convertTokenValues(_repayToken, supplyToken, _repayAmount, repayPrice, supplyPrice);
    uint callerFee    = supplyDebt * lendingController.liqFeeCaller(_repayToken) / 100e18;
    uint systemFee    = supplyDebt * lendingController.liqFeeSystem(_repayToken) / 100e18;
    uint supplyBurn   = supplyDebt + callerFee + systemFee;
    uint supplyOutput = supplyDebt + callerFee;

    require(supplyOutput >= _minSupplyOutput, ""LendingPair: supplyOutput >= _minSupplyOutput"");

    // Adjust balances

    _burnSupplyShares(supplyToken, _account, _supplyToShares(supplyToken, supplyBurn));
    pendingSystemFees[supplyToken] += systemFee;
    _burnDebtShares(_repayToken, _account, _debtToShares(_repayToken, _repayAmount));

    // Uni position unwrapping can mint supply of already borrowed tokens

    _repayDebtFromSupply(_account, tokenA);
    _repayDebtFromSupply(_account, tokenB);

    // Settle token transfers

    _safeTransferFrom(_repayToken, msg.sender, _repayAmount);
    _mintSupplyAmount(supplyToken, msg.sender, supplyOutput);

    emit Liquidation(_account, _repayToken, supplyToken, _repayAmount, supplyOutput);
  }

  function accountHealth(address _account) public view returns(uint) {

    if (debtSharesOf[tokenA][_account] == 0 && debtSharesOf[tokenB][_account] == 0) {
      return LIQ_MIN_HEALTH;
    }

    (uint priceA, uint priceB) = lendingController.tokenPrices(tokenA, tokenB);
    uint colFactorA = lendingController.colFactor(tokenA);
    uint colFactorB = lendingController.colFactor(tokenB);

    uint creditA   = _supplyBalanceConverted(_account, tokenA, tokenA, priceA, priceA) * colFactorA / 100e18;
    uint creditB   = _supplyBalanceConverted(_account, tokenB, tokenA, priceB, priceA) * colFactorB / 100e18;
    uint creditUni = _supplyCreditUni(_account, tokenA, priceA, priceB, colFactorA, colFactorB);

    uint totalAccountSupply = creditA + creditB + creditUni;

    uint totalAccountBorrow =
      _borrowBalanceConverted(_account, tokenA, tokenA, priceA, priceA) +
      _borrowBalanceConverted(_account, tokenB, tokenA, priceB, priceA);

    return totalAccountSupply * 1e18 / totalAccountBorrow;
  }

  function debtOf(address _token, address _account) external view returns(uint) {
    _validateToken(_token);
    return _debtOf(_token, _account);
  }

  function supplyOf(address _token, address _account) external view override returns(uint) {
    _validateToken(_token);
    return _supplyOf(_token, _account);
  }

  // Get borow balance converted to the units of _returnToken
  function borrowBalanceConverted(
    address _account,
    address _borrowedToken,
    address _returnToken
  ) external view returns(uint) {

    _validateToken(_borrowedToken);
    _validateToken(_returnToken);

    (uint borrowPrice, uint returnPrice) = lendingController.tokenPrices(_borrowedToken, _returnToken);
    return _borrowBalanceConverted(_account, _borrowedToken, _returnToken, borrowPrice, returnPrice);
  }

  function supplyBalanceConverted(
    address _account,
    address _suppliedToken,
    address _returnToken
  ) external view override returns(uint) {

    _validateToken(_suppliedToken);
    _validateToken(_returnToken);

    (uint supplyPrice, uint returnPrice) = lendingController.tokenPrices(_suppliedToken, _returnToken);
    return _supplyBalanceConverted(_account, _suppliedToken, _returnToken, supplyPrice, returnPrice);
  }

  function supplyRatePerBlock(address _token) external view returns(uint) {
    _validateToken(_token);
    return _interestRatePerBlock(_token) * _lpRate(_token) / 100e18;
  }

  function borrowRatePerBlock(address _token) external view returns(uint) {
    _validateToken(_token);
    return _interestRatePerBlock(_token);
  }

  function checkAccountHealth(address _account) public view  {
    uint health = accountHealth(_account);
    require(health >= LIQ_MIN_HEALTH, ""LendingPair: insufficient accountHealth"");
  }

  function convertTokenValues(
    address _fromToken,
    address _toToken,
    uint    _inputAmount
  ) external view returns(uint) {

    _validateToken(_fromToken);
    _validateToken(_toToken);

    (uint fromPrice, uint toPrice) = lendingController.tokenPrices(_fromToken, _toToken);
    return _convertTokenValues(_fromToken, _toToken, _inputAmount, fromPrice, toPrice);
  }

  function _depositRepay(address _account, address _token, uint _amount) internal {

    uint debt          = _debtOf(_token, _account);
    uint repayAmount   = debt > _amount ? _amount : debt;
    uint depositAmount = _amount - repayAmount;

    if (repayAmount > 0) {
      _repayShares(_account, _token, _debtToShares(_token, repayAmount));
    }

    if (depositAmount > 0) {
      _deposit(_account, _token, depositAmount);
    }
  }

  function _withdrawBorrow(address _token, uint _amount) internal {

    uint supplyAmount   = _supplyOf(_token, msg.sender);
    uint withdrawAmount = supplyAmount > _amount ? _amount : supplyAmount;
    uint borrowAmount   = _amount - withdrawAmount;

    if (withdrawAmount > 0) {
      _withdrawShares(_token, _supplyToShares(_token, withdrawAmount));
    }

    if (borrowAmount > 0) {
      _borrow(_token, borrowAmount);
    }
  }

  // Uses TWAP to estimate min outputs to reduce MEV
  // Liquidation might be temporarily unavailable due to this
  function _unwrapUniPosition(address _account) internal {

    if (uniPosition[_account] > 0) {

      (uint priceA, uint priceB) = lendingController.tokenPrices(tokenA, tokenB);
      (uint amount0, uint amount1) = uniV3Helper.positionAmounts(uniPosition[_account], priceA, priceB);
      uint uniMinOutput = lendingController.uniMinOutputPct();

      uniManager.approve(address(uniV3Helper), uniPosition[_account]);
      (uint amountA, uint amountB) = uniV3Helper.removeLiquidity(
        uniPosition[_account],
        amount0 * uniMinOutput / 100e18,
        amount1 * uniMinOutput / 100e18
      );
      uniPosition[_account] = 0;

      _mintSupplyAmount(tokenA, _account, amountA);
      _mintSupplyAmount(tokenB, _account, amountB);
    }
  }

  // Ensure we never have borrow + supply balances of the same token on the same account
  function _repayDebtFromSupply(address _account, address _token) internal {

    uint burnAmount = Math.min(_debtOf(_token, _account), _supplyOf(_token, _account));

    if (burnAmount > 0) {
      _burnDebtShares(_token, _account, _debtToShares(_token, burnAmount));
      _burnSupplyShares(_token, _account, _supplyToShares(_token, burnAmount));
    }
  }

  function _uniCollectFees(address _account) internal returns(uint, uint) {
    uniManager.approve(address(uniV3Helper), uniPosition[_account]);
    return uniV3Helper.collectFees(uniPosition[_account]);
  }

  function _mintSupplyAmount(address _token, address _account, uint _amount) internal returns(uint shares) {
    if (_amount > 0) {
      shares = _supplyToShares(_token, _amount);
      supplySharesOf[_token][_account] += shares;
      totalSupplyShares[_token] += shares;
      totalSupplyAmount[_token] += _amount;
    }
  }

  function _burnSupplyShares(address _token, address _account, uint _shares) internal returns(uint amount) {
    if (_shares > 0) {
      amount = _sharesToSupply(_token, _shares);
      supplySharesOf[_token][_account] -= _shares;
      totalSupplyShares[_token] -= _shares;
      totalSupplyAmount[_token] -= amount;
    }
  }

  function _mintDebtAmount(address _token, address _account, uint _amount) internal returns(uint shares) {
    if (_amount > 0) {
      shares = _debtToShares(_token, _amount);
      debtSharesOf[_token][_account] += shares;
      totalDebtShares[_token] += shares;
      totalDebtAmount[_token] += _amount;
    }
  }

  function _burnDebtShares(address _token, address _account, uint _shares) internal returns(uint amount) {
    if (_shares > 0) {
      amount = _sharesToDebt(_token, _shares);
      debtSharesOf[_token][_account] -= _shares;
      totalDebtShares[_token] -= _shares;
      totalDebtAmount[_token] -= amount;
    }
  }

  function _accrueDebt(address _token) internal returns(uint newDebt) {
    if (totalDebtAmount[_token] > 0) {
      uint blocksElapsed = block.number - lastBlockAccrued[_token];
      uint pendingInterestRate = _interestRatePerBlock(_token) * blocksElapsed;
      newDebt = totalDebtAmount[_token] * pendingInterestRate / 100e18;
      totalDebtAmount[_token] += newDebt;
    }
  }

  function _withdrawShares(address _token, uint _shares) internal {
    uint amount = _burnSupplyShares(_token, msg.sender, _shares);
    checkAccountHealth(msg.sender);
    emit Withdraw(_token, amount);
  }

  function _borrow(address _token, uint _amount) internal {

    require(supplySharesOf[_token][msg.sender] == 0, ""LendingPair: cannot borrow supplied token"");

    _mintDebtAmount(_token, msg.sender, _amount);

    _checkBorrowEnabled();
    _checkBorrowLimits(_token, msg.sender);
    checkAccountHealth(msg.sender);

    emit Borrow(_token, _amount);
  }

  function _repayShares(address _account, address _token, uint _shares) internal returns(uint amount) {
    amount = _burnDebtShares(_token, _account, _shares);
    emit Repay(_account, _token, amount);
  }

  function _deposit(address _account, address _token, uint _amount) internal {

    require(debtSharesOf[_token][_account] == 0, ""LendingPair: cannot deposit borrowed token"");

    _mintSupplyAmount(_token, _account, _amount);
    _checkDepositsEnabled();
    _checkDepositLimit(_token);

    emit Deposit(_account, _token, _amount);
  }

  function _createLpToken(address _lpTokenMaster, address _underlying) internal returns(address) {
    ILPTokenMaster newLPToken = ILPTokenMaster(_lpTokenMaster.clone());
    newLPToken.initialize(_underlying, address(lendingController));
    return address(newLPToken);
  }

  function _amountToShares(uint _totalShares, uint _totalAmount, uint _inputSupply) internal view returns(uint) {
    if (_totalShares > 0 && _totalAmount > 0) {
      return _inputSupply * _totalShares / _totalAmount;
    } else {
      return _inputSupply;
    }
  }

  function _sharesToAmount(uint _totalShares, uint _totalAmount, uint _inputShares) internal view returns(uint) {
    if (_totalShares > 0 && _totalAmount > 0) {
      return _inputShares * _totalAmount / _totalShares;
    } else {
      return _inputShares;
    }
  }

  function _debtToShares(address _token, uint _amount) internal view returns(uint) {
    return _amountToShares(totalDebtShares[_token], totalDebtAmount[_token], _amount);
  }

  function _sharesToDebt(address _token, uint _shares) internal view returns(uint) {
    return _sharesToAmount(totalDebtShares[_token], totalDebtAmount[_token], _shares);
  }

  function _supplyToShares(address _token, uint _amount) internal view returns(uint) {
    return _amountToShares(totalSupplyShares[_token], totalSupplyAmount[_token], _amount);
  }

  function _sharesToSupply(address _token, uint _shares) internal view returns(uint) {
    return _sharesToAmount(totalSupplyShares[_token], totalSupplyAmount[_token], _shares);
  }

  function _debtOf(address _token, address _account) internal view returns(uint) {
    return _sharesToDebt(_token, debtSharesOf[_token][_account]);
  }

  function _supplyOf(address _token, address _account) internal view returns(uint) {
    return _sharesToSupply(_token, supplySharesOf[_token][_account]);
  }

  function _interestRatePerBlock(address _token) internal view returns(uint) {
    return _interestRateModel().interestRatePerBlock(
      address(this),
      _token,
      totalSupplyAmount[_token],
      totalDebtAmount[_token]
    );
  }

  function _interestRateModel() internal view returns(IInterestRateModel) {
    return IInterestRateModel(lendingController.interestRateModel());
  }

  // Get borrow balance converted to the units of _returnToken
  function _borrowBalanceConverted(
    address _account,
    address _borrowedToken,
    address _returnToken,
    uint    _borrowPrice,
    uint    _returnPrice
  ) internal view returns(uint) {

    return _convertTokenValues(
      _borrowedToken,
      _returnToken,
      _debtOf(_borrowedToken, _account),
      _borrowPrice,
      _returnPrice
    );
  }

  // Get supply balance converted to the units of _returnToken
  function _supplyBalanceConverted(
    address _account,
    address _suppliedToken,
    address _returnToken,
    uint    _supplyPrice,
    uint    _returnPrice
  ) internal view returns(uint) {

    return _convertTokenValues(
      _suppliedToken,
      _returnToken,
      _supplyOf(_suppliedToken, _account),
      _supplyPrice,
      _returnPrice
    );
  }

  function _supplyCreditUni(
    address _account,
    address _returnToken,
    uint    _priceA,
    uint    _priceB,
    uint    _colFactorA,
    uint    _colFactorB
  ) internal view returns(uint) {

    if (uniPosition[_account] > 0) {

      (uint amountA, uint amountB) = uniV3Helper.positionAmounts(uniPosition[_account], _priceA, _priceB);

      uint supplyA = _convertTokenValues(tokenA, _returnToken, amountA, _priceA, _priceB);
      uint supplyB = _convertTokenValues(tokenB, _returnToken, amountB, _priceB, _priceB);

      uint creditA = supplyA * _colFactorA / 100e18;
      uint creditB = supplyB * _colFactorB / 100e18;

      return (creditA + creditB);

    } else {
      return 0;
    }
  }

  // Not calling priceOracle.convertTokenValues() to save gas by reusing already fetched prices
  function _convertTokenValues(
    address _fromToken,
    address _toToken,
    uint    _inputAmount,
    uint    _fromPrice,
    uint    _toPrice
  ) internal view returns(uint) {

    uint priceFrom = _fromPrice * 1e18 / 10 ** decimals[_fromToken];
    uint priceTo   = _toPrice   * 1e18 / 10 ** decimals[_toToken];

    return _inputAmount * priceFrom / priceTo;
  }

  function _validateToken(address _token) internal view {
    require(_token == tokenA || _token == tokenB, ""LendingPair: invalid token"");
  }

  function _validateUniPosition(uint _positionID) internal view {
    (address uniTokenA, address uniTokenB) = uniV3Helper.positionTokens(_positionID);
    _validateToken(uniTokenA);
    _validateToken(uniTokenB);
  }

  function _checkDepositLimit(address _token) internal view {
    uint depositLimit = lendingController.depositLimit(address(this), _token);

    if (depositLimit > 0) {
      require(totalSupplyAmount[_token] <= depositLimit, ""LendingPair: deposit limit reached"");
    }
  }

  function _checkDepositsEnabled() internal view {
    require(lendingController.depositsEnabled(), ""LendingPair: deposits disabled"");
  }

  function _checkBorrowEnabled() internal view {
    require(lendingController.borrowingEnabled(), ""LendingPair: borrowing disabled"");
  }

  function _checkBorrowLimits(address _token, address _account) internal view {
    uint borrowLimit = lendingController.borrowLimit(address(this), _token);

    if (borrowLimit > 0) {
      require(totalDebtAmount[_token] <= borrowLimit, ""LendingPair: borrow limit reached"");
    }
  }

  function _lpRate(address _token) internal view returns(uint) {
    return _interestRateModel().lpRate(address(this), _token);
  }
}",6460
RealWorld_BA_32_IERC20_RealWord_20240819230247.log,32,IERC20,4934,4789,9723,123.0,0.12045,"// SPDX-License-Identifier: UNLICENSED

pragma solidity >=0.7.0;

interface IERC20 {
  function totalSupply() external view returns (uint);
  function balanceOf(address account) external view returns(uint);
  function transfer(address recipient, uint256 amount) external returns(bool);
  function allowance(address owner, address spender) external view returns(uint);
  function decimals() external view returns(uint8);
  function approve(address spender, uint amount) external returns(bool);
  function transferFrom(address sender, address recipient, uint amount) external returns(bool);
}",115
RealWorld_BA_32_IPoolInitializer_RealWord_20240819232741.log,32,IPoolInitializer,7304,4279,11583,119.0,0.1221,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.7.5;
pragma abicoder v2;

/// @title Creates and initializes V3 Pools
/// @notice Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that
/// require the pool to exist.
interface IPoolInitializer {
  /// @notice Creates a new pool if it does not exist, then initializes if not initialized
  /// @dev This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool
  /// @param token0 The contract address of token0 of the pool
  /// @param token1 The contract address of token1 of the pool
  /// @param fee The fee amount of the v3 pool for the specified token pair
  /// @param sqrtPriceX96 The initial square root price of the pool as a Q64.96 value
  /// @return pool Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary
  function createAndInitializePoolIfNecessary(
      address token0,
      address token1,
      uint24 fee,
      uint160 sqrtPriceX96
  ) external payable returns (address pool);
}",274
RealWorld_BA_32_Ownable_RealWord_20240819224320.log,32,Ownable,7524,5290,12814,99.0,0.14342,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.6;

import '../interfaces/IOwnable.sol';

contract Ownable is IOwnable {

  address public override owner;
  address public pendingOwner;

  event OwnershipTransferInitiated(address indexed previousOwner, address indexed newOwner);
  event OwnershipTransferConfirmed(address indexed previousOwner, address indexed newOwner);

  constructor() {
    owner = msg.sender;
    emit OwnershipTransferConfirmed(address(0), owner);
  }

  modifier onlyOwner() {
    require(isOwner(), ""Ownable: caller is not the owner"");
    _;
  }

  function isOwner() public view returns (bool) {
    return msg.sender == owner;
  }

  function transferOwnership(address _newOwner) external override onlyOwner {
    require(_newOwner != address(0), ""Ownable: new owner is the zero address"");
    emit OwnershipTransferInitiated(owner, _newOwner);
    pendingOwner = _newOwner;
  }

  function acceptOwnership() external override {
    require(msg.sender == pendingOwner, ""Ownable: caller is not pending owner"");
    emit OwnershipTransferConfirmed(owner, pendingOwner);
    owner = pendingOwner;
    pendingOwner = address(0);
  }
}",258
RealWorld_BA_32_LPTokenMaster_RealWord_20240819223657.log,32,LPTokenMaster,15618,5755,21373,117.0,0.19319,"// SPDX-License-Identifier: UNLICENSED

// Copyright (c) 2021 0xdev0 - All rights reserved
// https://twitter.com/0xdev0

pragma solidity 0.8.6;

import './interfaces/IERC20.sol';
import './interfaces/ILPTokenMaster.sol';
import './interfaces/ILendingPair.sol';
import './interfaces/ILendingController.sol';
import './external/Ownable.sol';

contract LPTokenMaster is ILPTokenMaster, Ownable {

  event Transfer(address indexed from, address indexed to, uint value);
  event Approval(address indexed owner, address indexed spender, uint value);

  mapping (address => mapping (address => uint)) public override allowance;

  bool    private initialized;
  address public override underlying;
  address public lendingController;
  string  public name;
  string  public symbol;
  uint8   public constant override decimals = 18;

  modifier onlyOperator() {
    require(msg.sender == ILendingController(lendingController).owner(), ""LPToken: caller is not an operator"");
    _;
  }

  function initialize(address _underlying, address _lendingController) external override {
    require(initialized != true, ""LPToken: already intialized"");
    owner = msg.sender;
    underlying = _underlying;
    lendingController = _lendingController;
    name   = ""WILD-LP"";
    symbol = ""WILD-LP"";
    initialized = true;
  }

  // LP tokens can be created by anyone. Some tokens are not suitable for automated naming.
  // This function allow the operator to set a unique name for each LP token.
  function updateName(string memory _name, string memory _symbol) external onlyOperator {
    name   = _name;
    symbol = _symbol;
  }

  function transfer(address _recipient, uint _amount) external override returns(bool) {
    _transfer(msg.sender, _recipient, _amount);
    return true;
  }

  function approve(address _spender, uint _amount) external override returns(bool) {
    _approve(msg.sender, _spender, _amount);
    return true;
  }

  function transferFrom(address _sender, address _recipient, uint _amount) external override returns(bool) {
    _approve(_sender, msg.sender, allowance[_sender][msg.sender] - _amount);
    _transfer(_sender, _recipient, _amount);
    return true;
  }

  function lendingPair() external view override returns(address) {
    return owner;
  }

  function balanceOf(address _account) external view override returns(uint) {
    return ILendingPair(owner).supplySharesOf(underlying, _account);
  }

  function totalSupply() external view override returns(uint) {
    return ILendingPair(owner).totalSupplyShares(underlying);
  }

  function _transfer(address _sender, address _recipient, uint _amount) internal {
    require(_sender != address(0), ""ERC20: transfer from the zero address"");
    require(_recipient != address(0), ""ERC20: transfer to the zero address"");

    ILendingPair(owner).transferLp(underlying, _sender, _recipient, _amount);

    emit Transfer(_sender, _recipient, _amount);
  }

  function _approve(address _owner, address _spender, uint _amount) internal {
    require(_owner != address(0), ""ERC20: approve from the zero address"");
    require(_spender != address(0), ""ERC20: approve to the zero address"");

    allowance[_owner][_spender] = _amount;
    emit Approval(_owner, _spender, _amount);
  }
}",761
RealWorld_BA_32_IUniswapPriceConverter_RealWord_20240819231927.log,32,IUniswapPriceConverter,4569,4396,8965,135.0,0.110765,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.6;

interface IUniswapPriceConverter {

  function assetToAssetThruRoute(
    address _tokenIn,
    uint256 _amountIn,
    address _tokenOut,
    uint32 _twapPeriod,
    address _routeThruToken,
    uint24[2] memory _poolFees
  ) external view returns (uint256 amountOut);
}",92
RealWorld_BA_32_PoolAddress_RealWord_20240819225351.log,32,PoolAddress,10385,4646,15031,91.0,0.144845,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.7.5;

/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee
library PoolAddress {

    bytes32
        internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;

    /// @notice The identifying key of the pool
    struct PoolKey {
        address token0;
        address token1;
        uint24 fee;
    }

    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels
    /// @param tokenA The first token of a pool, unsorted
    /// @param tokenB The second token of a pool, unsorted
    /// @param fee The fee level of the pool
    /// @return Poolkey The pool details with ordered token0 and token1 assignments
    function getPoolKey(
        address tokenA,
        address tokenB,
        uint24 fee
    ) internal pure returns (PoolKey memory) {
        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);
        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});
    }

    /// @notice Deterministically computes the pool address given the factory and PoolKey
    /// @param factory The Uniswap V3 factory contract address
    /// @param key The PoolKey
    /// @return pool The contract address of the V3 pool
    function computeAddress(address factory, PoolKey memory key)
        internal
        pure
        returns (address pool)
    {
        require(key.token0 < key.token1);
        pool = address(
            uint256(
                keccak256(
                    abi.encodePacked(
                        hex""ff"",
                        factory,
                        keccak256(abi.encode(key.token0, key.token1, key.fee)),
                        POOL_INIT_CODE_HASH
                    )
                )
            )
        );
    }
}",447
RealWorld_BA_32_TransferHelper_RealWord_20240819223310.log,32,TransferHelper,8941,5097,14038,109.0,0.146645,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.6;

import './interfaces/IWETH.sol';
import './interfaces/IERC20.sol';
import './external/SafeERC20.sol';

contract TransferHelper {

  using SafeERC20 for IERC20;

  IWETH internal constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

  function _safeTransferFrom(address _token, address _sender, uint _amount) internal {
    require(_amount > 0, ""TransferHelper: amount must be > 0"");
    IERC20(_token).safeTransferFrom(_sender, address(this), _amount);
  }

  function _safeTransfer(address _token, address _recipient, uint _amount) internal {
    require(_amount > 0, ""TransferHelper: amount must be > 0"");
    IERC20(_token).safeTransfer(_recipient, _amount);
  }

  function _wethWithdrawTo(address _to, uint _amount) internal {
    require(_amount > 0, ""TransferHelper: amount must be > 0"");
    require(_to != address(0), ""TransferHelper: invalid recipient"");

    WETH.withdraw(_amount);
    (bool success, ) = _to.call { value: _amount }(new bytes(0));
    require(success, 'TransferHelper: ETH transfer failed');
  }

  function _depositWeth() internal {
    require(msg.value > 0, ""TransferHelper: amount must be > 0"");
    WETH.deposit { value: msg.value }();
  }
}",349
RealWorld_BA_32_SafeMath_RealWord_20240819224817.log,32,SafeMath,31277,4358,35635,112.0,0.243545,"// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        uint256 c = a + b;
        if (c < a) return (false, 0);
        return (true, c);
    }

    /**
     * @dev Returns the substraction of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b > a) return (false, 0);
        return (true, a - b);
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) return (true, 0);
        uint256 c = a * b;
        if (c / a != b) return (false, 0);
        return (true, c);
    }

    /**
     * @dev Returns the division of two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a / b);
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a % b);
    }

    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: modulo by zero"");
        return a % b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {trySub}.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        return a - b;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryDiv}.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting with custom message when dividing by zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryMod}.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a % b;
    }
}",1726
RealWorld_BA_32_Math_RealWord_20240819225644.log,32,Math,7262,4472,11734,89.0,0.12575,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.6;

library Math {

  function max(uint256 a, uint256 b) internal pure returns (uint256) {
    return a >= b ? a : b;
  }

  function min(uint256 a, uint256 b) internal pure returns (uint256) {
    return a < b ? a : b;
  }

  function average(uint256 a, uint256 b) internal pure returns (uint256) {
    // (a + b) / 2 can overflow, so we distribute.
    return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);
  }

  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
    // (a + b - 1) / b can overflow on addition, so we distribute.
    return a / b + (a % b == 0 ? 0 : 1);
  }
}",216
RealWorld_BA_32_IOwnable_RealWord_20240819225946.log,32,IOwnable,3744,3741,7485,83.0,0.09354,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.6;

interface IOwnable {
  function owner() external view returns(address);
  function transferOwnership(address _newOwner) external;
  function acceptOwnership() external;
}",51
RealWorld_BA_32_IERC721Permit_RealWord_20240819230833.log,32,IERC721Permit,9414,5138,14552,114.0,0.14983,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.7.5;

import 'openzeppelin/openzeppelin-contracts@3.4.1-solc-0.7-2/contracts/token/ERC721/IERC721.sol';

/// @title ERC721 with permit
/// @notice Extension to ERC721 that includes a permit function for signature based approvals
interface IERC721Permit is IERC721 {
    /// @notice The permit typehash used in the permit signature
    /// @return The typehash for the permit
    function PERMIT_TYPEHASH() external pure returns (bytes32);

    /// @notice The domain separator used in the permit signature
    /// @return The domain seperator used in encoding of permit signature
    function DOMAIN_SEPARATOR() external view returns (bytes32);

    /// @notice Approve of a specific token ID for spending by spender via signature
    /// @param spender The account that is being approved
    /// @param tokenId The ID of the token that is being approved for spending
    /// @param deadline The deadline timestamp by which the call must be mined for the approve to work
    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`
    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`
    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`
    function permit(
        address spender,
        uint256 tokenId,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external payable;
}",360
RealWorld_BA_32_SafeERC20_RealWord_20240819224501.log,32,SafeERC20,16200,4887,21087,98.0,0.17874,"// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0;

import ""../interfaces/IERC20.sol"";
import ""./SafeMath.sol"";
import ""./Address.sol"";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            ""SafeERC20: approve from non-zero to non-zero allowance""
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, ""SafeERC20: decreased allowance below zero"");
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, ""SafeERC20: low-level call failed"");
        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), ""SafeERC20: ERC20 operation did not succeed"");
        }
    }
}",840
RealWorld_BA_32_IUniswapV3Helper_RealWord_20240819232144.log,32,IUniswapV3Helper,5333,5070,10403,109.0,0.128065,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.6;

interface IUniswapV3Helper {
  function removeLiquidity(uint _tokenId, uint _minOutput0, uint _minOutput1) external returns (uint, uint);
  function collectFees(uint _tokenId) external returns (uint amount0, uint amount1);
  function positionTokens(uint _tokenId) external view returns(address, address);
  function positionAmounts(uint _tokenId, uint _price0, uint _price1) external view returns(uint, uint);
}",118
RealWorld_BA_32_PositionKey_RealWord_20240819225217.log,32,PositionKey,4169,3974,8143,92.0,0.100325,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.7.5;

library PositionKey {
    /// @dev Returns the key of the position in the core library
    function compute(
        address owner,
        int24 tickLower,
        int24 tickUpper
    ) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(owner, tickLower, tickUpper));
    }
}",93
RealWorld_BA_32_IERC721_RealWord_20240819231208.log,32,IERC721,4217,4515,8732,113.0,0.111385,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.6;

interface IERC721 {

  function approve(address to, uint tokenId) external;
  function ownerOf(uint _tokenId) external view returns (address);

  function safeTransferFrom(
    address from,
    address to,
    uint tokenId
  ) external;
}",71
RealWorld_BA_32_IPriceOracle_RealWord_20240819230452.log,32,IPriceOracle,4388,5239,9627,117.0,0.12672,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.6;

interface IPriceOracle {

  function tokenPrice(address _token) external view returns(uint);
  function tokenSupported(address _token) external view returns(bool);
  function convertTokenValues(address _fromToken, address _toToken, uint _amount) external view returns(uint);
}",74
RealWorld_BA_32_ILPTokenMaster_RealWord_20240819231745.log,32,ILPTokenMaster,4263,4310,8573,100.0,0.107515,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.6;

import './IOwnable.sol';
import './IERC20.sol';

interface ILPTokenMaster is IOwnable, IERC20 {
  function initialize(address _underlying, address _lendingController) external;
  function underlying() external view returns(address);
  function lendingPair() external view returns(address);
}",82
RealWorld_BA_32_ILendingPair_RealWord_20240819225815.log,32,ILendingPair,6226,4606,10832,89.0,0.12325,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.6;

interface ILendingPair {

  function tokenA() external view returns(address);
  function tokenB() external view returns(address);
  function lpToken(address _token) external view returns(address);
  function deposit(address _account, address _token, uint _amount) external;
  function withdraw(address _token, uint _amount) external;
  function withdrawAll(address _token) external;
  function transferLp(address _token, address _from, address _to, uint _amount) external;
  function supplySharesOf(address _token, address _account) external view returns(uint);
  function totalSupplyShares(address _token) external view returns(uint);
  function supplyOf(address _token, address _account) external view returns(uint);

  function supplyBalanceConverted(
    address _account,
    address _suppliedToken,
    address _returnToken
  ) external view returns(uint);
}",200
RealWorld_BA_32_IPairFactory_RealWord_20240819230651.log,32,IPairFactory,3782,4046,7828,100.0,0.09983,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.6;

interface IPairFactory {
  function pairByTokens(address _tokenA, address _tokenB) external view returns(address);
}",44
RealWorld_BA_32_ERC721Receivable_RealWord_20240819225524.log,32,ERC721Receivable,4607,3923,8530,78.0,0.101495,"// SPDX-License-Identifier: UNLICENSED

// Copyright (c) 2021 0xdev0 - All rights reserved
// https://twitter.com/0xdev0

pragma solidity >0.7.0;

contract ERC721Receivable {

  function onERC721Received(
    address _operator,
    address _user,
    uint _tokenId,
    bytes memory _data
  ) public returns (bytes4) {
    return 0x150b7a02;
  }
}",105
RealWorld_BA_32_Clones_RealWord_20240819224641.log,32,Clones,19489,5275,24764,94.0,0.202945,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.6;

/**
 * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for
 * deploying minimal proxy contracts, also known as ""clones"".
 *
 * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies
 * > a minimal bytecode implementation that delegates all calls to a known, fixed address.
 *
 * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`
 * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the
 * deterministic method.
 *
 * _Available since v3.4._
 */
library Clones {
    /**
     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.
     *
     * This function uses the create opcode, which should never revert.
     */
    function clone(address master) internal returns (address instance) {
        // solhint-disable-next-line no-inline-assembly
        assembly {
            let ptr := mload(0x40)
            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
            mstore(add(ptr, 0x14), shl(0x60, master))
            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
            instance := create(0, ptr, 0x37)
        }
        require(instance != address(0), ""ERC1167: create failed"");
    }

    /**
     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.
     *
     * This function uses the create2 opcode and a `salt` to deterministically deploy
     * the clone. Using the same `master` and `salt` multiple time will revert, since
     * the clones cannot be deployed twice at the same address.
     */
    function cloneDeterministic(address master, bytes32 salt) internal returns (address instance) {
        // solhint-disable-next-line no-inline-assembly
        assembly {
            let ptr := mload(0x40)
            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
            mstore(add(ptr, 0x14), shl(0x60, master))
            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
            instance := create2(0, ptr, 0x37, salt)
        }
        require(instance != address(0), ""ERC1167: create2 failed"");
    }

    /**
     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.
     */
    function predictDeterministicAddress(address master, bytes32 salt, address deployer) internal pure returns (address predicted) {
        // solhint-disable-next-line no-inline-assembly
        assembly {
            let ptr := mload(0x40)
            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
            mstore(add(ptr, 0x14), shl(0x60, master))
            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)
            mstore(add(ptr, 0x38), shl(0x60, deployer))
            mstore(add(ptr, 0x4c), salt)
            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))
            predicted := keccak256(add(ptr, 0x37), 0x55)
        }
    }

    /**
     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.
     */
    function predictDeterministicAddress(address master, bytes32 salt) internal view returns (address predicted) {
        return predictDeterministicAddress(master, salt, address(this));
    }
}",970
RealWorld_BA_32_INonFungiblePositionManager_RealWord_20240819233244.log,32,INonFungiblePositionManager,34811,5917,40728,142.0,0.292395,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.7.5;
pragma abicoder v2;

import ""openzeppelin/openzeppelin-contracts@3.4.1-solc-0.7-2/contracts/token/ERC721/IERC721Metadata.sol"";
import ""openzeppelin/openzeppelin-contracts@3.4.1-solc-0.7-2/contracts/token/ERC721/IERC721Enumerable.sol"";

import ""./IPoolInitializer.sol"";
import ""../IERC721Permit.sol"";
import ""./IPeripheryPayments.sol"";
import ""./IPeripheryImmutableState.sol"";
import ""../../external/PoolAddress.sol"";

/// @title Non-fungible token for positions
/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred
/// and authorized.
interface INonfungiblePositionManager is
    IPeripheryPayments,
    IPeripheryImmutableState,
    IERC721Metadata,
    IERC721Enumerable,
    IERC721Permit,
    IPoolInitializer
{
    /// @notice Emitted when liquidity is increased for a position NFT
    /// @dev Also emitted when a token is minted
    /// @param tokenId The ID of the token for which liquidity was increased
    /// @param liquidity The amount by which liquidity for the NFT position was increased
    /// @param amount0 The amount of token0 that was paid for the increase in liquidity
    /// @param amount1 The amount of token1 that was paid for the increase in liquidity
    event IncreaseLiquidity(
        uint256 indexed tokenId,
        uint128 liquidity,
        uint256 amount0,
        uint256 amount1
    );
    /// @notice Emitted when liquidity is decreased for a position NFT
    /// @param tokenId The ID of the token for which liquidity was decreased
    /// @param liquidity The amount by which liquidity for the NFT position was decreased
    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity
    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity
    event DecreaseLiquidity(
        uint256 indexed tokenId,
        uint128 liquidity,
        uint256 amount0,
        uint256 amount1
    );
    /// @notice Emitted when tokens are collected for a position NFT
    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior
    /// @param tokenId The ID of the token for which underlying tokens were collected
    /// @param recipient The address of the account that received the collected tokens
    /// @param amount0 The amount of token0 owed to the position that was collected
    /// @param amount1 The amount of token1 owed to the position that was collected
    event Collect(
        uint256 indexed tokenId,
        address recipient,
        uint256 amount0,
        uint256 amount1
    );

    /// @notice Returns the position information associated with a given token ID.
    /// @dev Throws if the token ID is not valid.
    /// @param tokenId The ID of the token that represents the position
    /// @return nonce The nonce for permits
    /// @return operator The address that is approved for spending
    /// @return token0 The address of the token0 for a specific pool
    /// @return token1 The address of the token1 for a specific pool
    /// @return fee The fee associated with the pool
    /// @return tickLower The lower end of the tick range for the position
    /// @return tickUpper The higher end of the tick range for the position
    /// @return liquidity The liquidity of the position
    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position
    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position
    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation
    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation
    function positions(uint256 tokenId)
        external
        view
        returns (
            uint96 nonce,
            address operator,
            address token0,
            address token1,
            uint24 fee,
            int24 tickLower,
            int24 tickUpper,
            uint128 liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );

    struct MintParams {
        address token0;
        address token1;
        uint24 fee;
        int24 tickLower;
        int24 tickUpper;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        address recipient;
        uint256 deadline;
    }

    /// @notice Creates a new position wrapped in a NFT
    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized
    /// a method does not exist, i.e. the pool is assumed to be initialized.
    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata
    /// @return tokenId The ID of the token that represents the minted position
    /// @return liquidity The amount of liquidity for this position
    /// @return amount0 The amount of token0
    /// @return amount1 The amount of token1
    function mint(MintParams calldata params)
        external
        payable
        returns (
            uint256 tokenId,
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        );

    struct IncreaseLiquidityParams {
        uint256 tokenId;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`
    /// @param params tokenId The ID of the token for which liquidity is being increased,
    /// amount0Desired The desired amount of token0 to be spent,
    /// amount1Desired The desired amount of token1 to be spent,
    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,
    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,
    /// deadline The time by which the transaction must be included to effect the change
    /// @return liquidity The new liquidity amount as a result of the increase
    /// @return amount0 The amount of token0 to acheive resulting liquidity
    /// @return amount1 The amount of token1 to acheive resulting liquidity
    function increaseLiquidity(IncreaseLiquidityParams calldata params)
        external
        payable
        returns (
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        );

    struct DecreaseLiquidityParams {
        uint256 tokenId;
        uint128 liquidity;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    /// @notice Decreases the amount of liquidity in a position and accounts it to the position
    /// @param params tokenId The ID of the token for which liquidity is being decreased,
    /// amount The amount by which liquidity will be decreased,
    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,
    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,
    /// deadline The time by which the transaction must be included to effect the change
    /// @return amount0 The amount of token0 accounted to the position's tokens owed
    /// @return amount1 The amount of token1 accounted to the position's tokens owed
    function decreaseLiquidity(DecreaseLiquidityParams calldata params)
        external
        payable
        returns (uint256 amount0, uint256 amount1);

    struct CollectParams {
        uint256 tokenId;
        address recipient;
        uint128 amount0Max;
        uint128 amount1Max;
    }

    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient
    /// @param params tokenId The ID of the NFT for which tokens are being collected,
    /// recipient The account that should receive the tokens,
    /// amount0Max The maximum amount of token0 to collect,
    /// amount1Max The maximum amount of token1 to collect
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collect(CollectParams calldata params)
        external
        payable
        returns (uint256 amount0, uint256 amount1);

    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens
    /// must be collected first.
    /// @param tokenId The ID of the token that is being burned
    function burn(uint256 tokenId) external payable;
}",1979
RealWorld_BA_32_IUniswapV3Pool_RealWord_20240819233106.log,32,IUniswapV3Pool,4734,4143,8877,96.0,0.10653,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.6;

interface IUniswapV3Pool {

  function slot0() external view returns (
    uint160 sqrtPriceX96,
    int24 tick,
    uint16 observationIndex,
    uint16 observationCardinality,
    uint16 observationCardinalityNext,
    uint8 feeProtocol,
    bool unlocked
  );

  function increaseObservationCardinalityNext(
    uint16 observationCardinalityNext
  ) external;
}",102
RealWorld_BA_32_UniswapV3Oracle_RealWord_20240819223501.log,32,UniswapV3Oracle,22081,5625,27706,114.0,0.222905,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.6;

import './interfaces/IERC20.sol';
import './interfaces/uniV3/IUniswapV3Pool.sol';
import './interfaces/uniV3/IUniswapV3Factory.sol';
import './interfaces/ILinkOracle.sol';
import './interfaces/IPriceOracle.sol';
import './interfaces/IUniswapPriceConverter.sol';
import './external/Ownable.sol';

contract UniswapV3Oracle is IPriceOracle, Ownable {

  IUniswapV3Factory public constant uniFactory    = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);
  ILinkOracle       public constant wethOracle    = ILinkOracle(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);
  address           public constant WETH          = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
  uint24            public constant WETH_POOL_FEE = 3000;

  struct Pool {
    address pairToken;
    uint24  poolFee;
  }

  uint32 public twapPeriod;
  uint16 public minObservations;

  IUniswapPriceConverter public uniPriceConverter;

  mapping(address => Pool) public pools;

  event PoolAdded(address indexed token);
  event PoolRemoved(address indexed token);
  event NewTwapPeriod(uint32 value);
  event NewMinObservations(uint16 value);
  event NewUniPriceConverter(IUniswapPriceConverter value);

  constructor(
    IUniswapPriceConverter _uniPriceConverter,
    uint32 _twapPeriod,
    uint16 _minObservations
  ) {
    uniPriceConverter = _uniPriceConverter;
    twapPeriod        = _twapPeriod;
    minObservations   = _minObservations;
  }

  function addPool(
    address _token,
    address _pairToken,
    uint24  _poolFee
  ) external onlyOwner {

    _validatePool(_token, _pairToken, _poolFee);

    pools[_token] = Pool({
      pairToken: _pairToken,
      poolFee: _poolFee
    });

    emit PoolAdded(_token);
  }

  function removePool(address _token) external onlyOwner {
    pools[_token] = Pool(address(0), 0);
    emit PoolRemoved(_token);
  }

  function setUniPriceConverter(IUniswapPriceConverter _value) external onlyOwner {
    uniPriceConverter = _value;
    emit NewUniPriceConverter(_value);
  }

  function setTwapPeriod(uint32 _value) external onlyOwner {
    twapPeriod = _value;
    emit NewTwapPeriod(_value);
  }

  function setMinObservations(uint16 _value) external onlyOwner {
    minObservations = _value;
    emit NewMinObservations(_value);
  }

  function tokenPrice(address _token) public view override returns(uint) {
    require(pools[_token].pairToken != address(0), ""UniswapV3Oracle: token not supported"");
    _validatePool(_token, pools[_token].pairToken, pools[_token].poolFee);

    uint ethValue = uniPriceConverter.assetToAssetThruRoute(
      _token,
      10 ** IERC20(_token).decimals(),
      WETH,
      twapPeriod,
      pools[_token].pairToken,
      [pools[_token].poolFee, WETH_POOL_FEE]
    );

    return ethValue * ethPrice() / 1e18;
  }

  function ethPrice() public view returns(uint) {
    uint latestAnswer = wethOracle.latestAnswer();
    require(latestAnswer > 1, ""LinkPriceOracle: invalid oracle value"");
    return latestAnswer * 1e10;
  }

  // Not used in any LendingPair to save gas. But useful for external usage.
  function convertTokenValues(address _fromToken, address _toToken, uint _amount) external view override returns(uint) {
    uint priceFrom = tokenPrice(_fromToken) * 1e18 / 10 ** IERC20(_fromToken).decimals();
    uint priceTo   = tokenPrice(_toToken)   * 1e18 / 10 ** IERC20(_toToken).decimals();
    return _amount * priceFrom / priceTo;
  }

  function isPoolValid(address _token, address _pairToken, uint24 _poolFee) public view returns(bool) {
    address poolAddress = uniFactory.getPool(_token, _pairToken, _poolFee);
    if (poolAddress == address(0)) { return false; }

    (, , , , uint16 observationSlots, ,) = IUniswapV3Pool(poolAddress).slot0();
    return observationSlots >= minObservations;
  }

  function tokenSupported(address _token) external view override returns(bool) {
    return pools[_token].pairToken != address(0);
  }

  function _validatePool(address _token, address _pairToken, uint24 _poolFee) internal view {
    require(isPoolValid(_token, _pairToken, _poolFee), ""UniswapV3Oracle: invalid pool"");
  }
}",1150
RealWorld_BA_32_ReentrancyGuard_RealWord_20240819223856.log,32,ReentrancyGuard,5055,4208,9263,122.0,0.109435,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.6;

contract ReentrancyGuard {
  uint256 private constant _NOT_ENTERED = 1;
  uint256 private constant _ENTERED = 2;

  uint256 private _status;

  constructor () {
    _status = _NOT_ENTERED;
  }

  modifier nonReentrant() {
    require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");
    _status = _ENTERED;
    _;
    _status = _NOT_ENTERED;
  }
}",120
RealWorld_BA_32_IPeripheryImmutableState_RealWord_20240819232942.log,32,IPeripheryImmutableState,4476,3274,7750,82.0,0.08786,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.7.5;

/// @title Immutable state
/// @notice Functions that return immutable state of the router
interface IPeripheryImmutableState {
    /// @return Returns the address of the Uniswap V3 factory
    function factory() external view returns (address);

    /// @return Returns the address of WETH9
    function WETH9() external view returns (address);
}",99
RealWorld_BA_32_UniswapV3Helper_RealWord_20240819222308.log,32,UniswapV3Helper,29615,5221,34836,120.0,0.252495,"// SPDX-License-Identifier: MIT

pragma solidity 0.7.5;
pragma abicoder v2;

import 'uniswap/uniswap-v3-core@1.0.0/contracts/libraries/TickMath.sol';
import 'uniswap/uniswap-v3-core@1.0.0/contracts/libraries/FixedPoint128.sol';
import 'uniswap/uniswap-v3-core@1.0.0/contracts/libraries/FullMath.sol';
import 'uniswap/uniswap-v3-core@1.0.0/contracts/libraries/SqrtPriceMath.sol';

import './external/PositionKey.sol';
import './external/PoolAddress.sol';
import './external/SafeERC20.sol';
import './external/ERC721Receivable.sol';

import 'uniswap/uniswap-v3-core@1.0.0/contracts/interfaces/IUniswapV3Pool.sol';

import './interfaces/IERC20.sol';
import './interfaces/univ3/INonfungiblePositionManager.sol';

contract UniswapV3Helper is ERC721Receivable {

  using SafeERC20 for IERC20;

  INonfungiblePositionManager internal constant positionManager = INonfungiblePositionManager(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);

  function removeLiquidity(
    uint _tokenId,
    uint _minOutput0,
    uint _minOutput1
  ) external returns (uint, uint) {

    positionManager.safeTransferFrom(msg.sender, address(this), _tokenId);
    uint128 liquidity = uint128(positionLiquidity(_tokenId));

    INonfungiblePositionManager.DecreaseLiquidityParams memory params =
      INonfungiblePositionManager.DecreaseLiquidityParams({
        tokenId:    _tokenId,
        liquidity:  liquidity,
        amount0Min: _minOutput0,
        amount1Min: _minOutput1,
        deadline:   block.timestamp
      });

    positionManager.decreaseLiquidity(params);
    (uint amount0, uint amount1) = _collectFees(_tokenId);
    _safeTransferAmounts(_tokenId, amount0, amount1);
    positionManager.burn(_tokenId);

    return (amount0, amount1);
  }

  function collectFees(uint _tokenId) external returns (uint, uint) {

    positionManager.safeTransferFrom(msg.sender, address(this), _tokenId);

    (uint amount0, uint amount1) = _collectFees(_tokenId);

    _safeTransferAmounts(_tokenId, amount0, amount1);
    positionManager.safeTransferFrom(address(this), msg.sender, _tokenId);

    return (amount0, amount1);
  }

  // This function answer the question:
  // If the current token prices were as follows (_price0, _price1),
  // what would be token amounts of this position look like?
  // This function is used to determine USD value of the position inside of the lending pair
  // Price inputs are token TWAP prices
  function positionAmounts(
    uint _tokenId,
    uint _price0,
    uint _price1
  ) external view returns(uint, uint) {
    uint160 sqrtPriceX96 = uint160(getSqrtPriceX96(_price0, _price1));
    int24 tick = getTickAtSqrtRatio(sqrtPriceX96);
    return getUserTokenAmount(_tokenId, tick);
  }

  function getSqrtRatioAtTick(int24 _tick) public pure returns (uint160) {
    return TickMath.getSqrtRatioAtTick(_tick);
  }

  function getTickAtSqrtRatio(uint160 _sqrtPriceX96) public pure returns (int24) {
    return TickMath.getTickAtSqrtRatio(_sqrtPriceX96);
  }

  function positionTokens(uint _tokenId) public view returns(address, address) {
    (, , address tokenA, address tokenB, , , , , , , ,) = positionManager.positions(_tokenId);
    return (tokenA, tokenB);
  }

  function positionLiquidity(uint _tokenId) public view returns(uint) {
    (, , , , , , , uint liquidity, , , ,) = positionManager.positions(_tokenId);
    return liquidity;
  }

  function getUserTokenAmount(
    uint  _tokenId,
    int24 _tick
  ) public view returns (uint amount0, uint amount1) {
    (
      ,
      ,
      address token0,
      address token1,
      uint24 fee,
      int24 tickLower,
      int24 tickUpper,
      uint128 liquidity,
      ,
      ,
      ,

    ) = positionManager.positions(_tokenId);

    IUniswapV3Pool pool =
      IUniswapV3Pool(
        PoolAddress.computeAddress(
          positionManager.factory(),
          PoolAddress.PoolKey({
            token0: token0,
            token1: token1,
            fee: fee
          })
        )
      );

    // (, int24 currentTick, , , , , ) = pool.slot0();

    if (_tick < tickLower) {
      amount0 = uint(SqrtPriceMath.getAmount0Delta(
        TickMath.getSqrtRatioAtTick(tickLower),
        TickMath.getSqrtRatioAtTick(tickUpper),
        (int128)(liquidity)
      ));
    } else if (_tick < tickUpper) {
      amount0 = uint(SqrtPriceMath.getAmount0Delta(
        TickMath.getSqrtRatioAtTick(_tick),
        TickMath.getSqrtRatioAtTick(tickUpper),
        (int128)(liquidity)
      ));
      amount1 = uint(SqrtPriceMath.getAmount1Delta(
        TickMath.getSqrtRatioAtTick(tickLower),
        TickMath.getSqrtRatioAtTick(_tick),
        (int128)(liquidity)
      ));
    } else {
      amount1 = uint(SqrtPriceMath.getAmount1Delta(
        TickMath.getSqrtRatioAtTick(tickLower),
        TickMath.getSqrtRatioAtTick(tickUpper),
        (int128)(liquidity)
      ));
    }
  }

  function getSqrtPriceX96(uint _amount0, uint _amount1) public view returns(uint) {
    uint ratioX192 = (_amount0 << 192) / _amount1;
    return _sqrt(ratioX192);
  }

  function _collectFees(uint _tokenId) internal returns (uint, uint) {

    INonfungiblePositionManager.CollectParams memory params =
      INonfungiblePositionManager.CollectParams({
      tokenId: _tokenId,
      recipient: address(this),
      amount0Max: type(uint128).max,
      amount1Max: type(uint128).max
      });

    return positionManager.collect(params);
  }

  function _safeTransferAmounts(uint _tokenId, uint _amount0, uint _amount1) internal {
    (address token0, address token1) = positionTokens(_tokenId);
    _safeTransfer(token0, msg.sender, _amount0);
    _safeTransfer(token1, msg.sender, _amount1);
  }

  // Can't use TransferHelper due since it's on another version of Solidity
  function _safeTransfer(address _token, address _recipient, uint _amount) internal {
    require(_amount > 0, ""UniswapV3Helper: amount must be > 0"");
    IERC20(_token).safeTransfer(_recipient, _amount);
  }

  function _sqrt(uint _x) internal view returns (uint y) {
    uint z = (_x + 1) / 2;
    y = _x;
    while (z < y) {
      y = z;
      z = (_x / z + z) / 2;
    }
  }
}",1637
RealWorld_BA_34_IPrizeSplit_RealWord_20240820012119.log,34,IPrizeSplit,16155,5091,21246,93.0,0.182595,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""./IControlledToken.sol"";
import ""./IPrizePool.sol"";

/**
 * @title Abstract prize split contract for adding unique award distribution to static addresses.
 * @author PoolTogether Inc Team
 */
interface IPrizeSplit {
    /**
     * @notice Emit when an individual prize split is awarded.
     * @param user          User address being awarded
     * @param prizeAwarded  Awarded prize amount
     * @param token         Token address
     */
    event PrizeSplitAwarded(
        address indexed user,
        uint256 prizeAwarded,
        IControlledToken indexed token
    );

    /**
     * @notice The prize split configuration struct.
     * @dev    The prize split configuration struct used to award prize splits during distribution.
     * @param target     Address of recipient receiving the prize split distribution
     * @param percentage Percentage of prize split using a 0-1000 range for single decimal precision i.e. 125 = 12.5%
     */
    struct PrizeSplitConfig {
        address target;
        uint16 percentage;
    }

    /**
     * @notice Emitted when a PrizeSplitConfig config is added or updated.
     * @dev    Emitted when a PrizeSplitConfig config is added or updated in setPrizeSplits or setPrizeSplit.
     * @param target     Address of prize split recipient
     * @param percentage Percentage of prize split. Must be between 0 and 1000 for single decimal precision
     * @param index      Index of prize split in the prizeSplts array
     */
    event PrizeSplitSet(address indexed target, uint16 percentage, uint256 index);

    /**
     * @notice Emitted when a PrizeSplitConfig config is removed.
     * @dev    Emitted when a PrizeSplitConfig config is removed from the prizeSplits array.
     * @param target Index of a previously active prize split config
     */
    event PrizeSplitRemoved(uint256 indexed target);

    /**
     * @notice Read prize split config from active PrizeSplits.
     * @dev    Read PrizeSplitConfig struct from prizeSplits array.
     * @param prizeSplitIndex Index position of PrizeSplitConfig
     * @return PrizeSplitConfig Single prize split config
     */
    function getPrizeSplit(uint256 prizeSplitIndex) external view returns (PrizeSplitConfig memory);

    /**
     * @notice Read all prize splits configs.
     * @dev    Read all PrizeSplitConfig structs stored in prizeSplits.
     * @return Array of PrizeSplitConfig structs
     */
    function getPrizeSplits() external view returns (PrizeSplitConfig[] memory);

    /**
     * @notice Get PrizePool address
     * @return IPrizePool
     */
    function getPrizePool() external view returns (IPrizePool);

    /**
     * @notice Set and remove prize split(s) configs. Only callable by owner.
     * @dev Set and remove prize split configs by passing a new PrizeSplitConfig structs array. Will remove existing PrizeSplitConfig(s) if passed array length is less than existing prizeSplits length.
     * @param newPrizeSplits Array of PrizeSplitConfig structs
     */
    function setPrizeSplits(PrizeSplitConfig[] calldata newPrizeSplits) external;

    /**
     * @notice Updates a previously set prize split config.
     * @dev Updates a prize split config by passing a new PrizeSplitConfig struct and current index position. Limited to contract owner.
     * @param prizeStrategySplit PrizeSplitConfig config struct
     * @param prizeSplitIndex Index position of PrizeSplitConfig to update
     */
    function setPrizeSplit(PrizeSplitConfig memory prizeStrategySplit, uint8 prizeSplitIndex)
        external;
}",809
RealWorld_BA_34_ERC721Mintable_RealWord_20240820003215.log,34,ERC721Mintable,5253,4260,9513,95.0,0.111465,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";

/**
 * @dev Extension of {ERC721} for Minting/Burning
 */
contract ERC721Mintable is ERC721 {
    constructor() ERC721(""ERC 721"", ""NFT"") {}

    /**
     * @dev See {ERC721-_mint}.
     */
    function mint(address to, uint256 tokenId) public {
        _mint(to, tokenId);
    }

    /**
     * @dev See {ERC721-_burn}.
     */
    function burn(uint256 tokenId) public {
        _burn(tokenId);
    }
}",147
RealWorld_BA_34_IStrategy_RealWord_20240820013043.log,34,IStrategy,5331,4827,10158,109.0,0.123195,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

interface IStrategy {
    /**
     * @notice Emit when a strategy captures award amount from PrizePool.
     * @param totalPrizeCaptured  Total prize captured from the PrizePool
     */
    event Distributed(uint256 totalPrizeCaptured);

    /**
     * @notice Capture the award balance and distribute to prize splits.
     * @dev    Permissionless function to initialize distribution of interst
     * @return Prize captured from PrizePool
     */
    function distribute() external returns (uint256);
}",126
RealWorld_BA_34_PrizeSplitStrategyHarness_RealWord_20240820002425.log,34,PrizeSplitStrategyHarness,4494,4102,8596,86.0,0.10451,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../prize-strategy/PrizeSplitStrategy.sol"";

contract PrizeSplitStrategyHarness is PrizeSplitStrategy {
    constructor(address _owner, IPrizePool _prizePool) PrizeSplitStrategy(_owner, _prizePool) {}

    function awardPrizeSplitAmount(address target, uint256 amount) external {
        return _awardPrizeSplitAmount(target, amount);
    }
}",101
RealWorld_BA_34_IDrawBeacon_RealWord_20240820013435.log,34,IDrawBeacon,27261,6095,33356,132.0,0.258205,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/pooltogether-rng-contracts/contracts/RNGInterface.sol"";
import ""./IDrawBuffer.sol"";

/** @title  IDrawBeacon
  * @author PoolTogether Inc Team
  * @notice The DrawBeacon interface.
*/
interface IDrawBeacon {

    /// @notice Draw struct created every draw
    /// @param winningRandomNumber The random number returned from the RNG service
    /// @param drawId The monotonically increasing drawId for each draw
    /// @param timestamp Unix timestamp of the draw. Recorded when the draw is created by the DrawBeacon.
    /// @param beaconPeriodStartedAt Unix timestamp of when the draw started
    /// @param beaconPeriodSeconds Unix timestamp of the beacon draw period for this draw.
    struct Draw {
        uint256 winningRandomNumber;
        uint32 drawId;
        uint64 timestamp;
        uint64 beaconPeriodStartedAt;
        uint32 beaconPeriodSeconds;
    }

    /**
     * @notice Emit when a new DrawBuffer has been set.
     * @param newDrawBuffer       The new DrawBuffer address
     */
    event DrawBufferUpdated(IDrawBuffer indexed newDrawBuffer);

    /**
     * @notice Emit when a draw has opened.
     * @param startedAt Start timestamp
     */
    event BeaconPeriodStarted(uint64 indexed startedAt);

    /**
     * @notice Emit when a draw has started.
     * @param rngRequestId  draw id
     * @param rngLockBlock  Block when draw becomes invalid
     */
    event DrawStarted(uint32 indexed rngRequestId, uint32 rngLockBlock);

    /**
     * @notice Emit when a draw has been cancelled.
     * @param rngRequestId  draw id
     * @param rngLockBlock  Block when draw becomes invalid
     */
    event DrawCancelled(uint32 indexed rngRequestId, uint32 rngLockBlock);

    /**
     * @notice Emit when a draw has been completed.
     * @param randomNumber  Random number generated from draw
     */
    event DrawCompleted(uint256 randomNumber);

    /**
     * @notice Emit when a RNG service address is set.
     * @param rngService  RNG service address
     */
    event RngServiceUpdated(RNGInterface indexed rngService);

    /**
     * @notice Emit when a draw timeout param is set.
     * @param rngTimeout  draw timeout param in seconds
     */
    event RngTimeoutSet(uint32 rngTimeout);

    /**
     * @notice Emit when the drawPeriodSeconds is set.
     * @param drawPeriodSeconds Time between draw
     */
    event BeaconPeriodSecondsUpdated(uint32 drawPeriodSeconds);

    /**
     * @notice Returns the number of seconds remaining until the beacon period can be complete.
     * @return The number of seconds remaining until the beacon period can be complete.
     */
    function beaconPeriodRemainingSeconds() external view returns (uint64);

    /**
     * @notice Returns the timestamp at which the beacon period ends
     * @return The timestamp at which the beacon period ends.
     */
    function beaconPeriodEndAt() external view returns (uint64);

    /**
     * @notice Returns whether a Draw can be started.
     * @return True if a Draw can be started, false otherwise.
     */
    function canStartDraw() external view returns (bool);

    /**
     * @notice Returns whether a Draw can be completed.
     * @return True if a Draw can be completed, false otherwise.
     */
    function canCompleteDraw() external view returns (bool);

    /**
     * @notice Calculates when the next beacon period will start.
     * @param time The timestamp to use as the current time
     * @return The timestamp at which the next beacon period would start
     */
    function calculateNextBeaconPeriodStartTime(uint256 time) external view returns (uint64);

    /**
     * @notice Can be called by anyone to cancel the draw request if the RNG has timed out.
     */
    function cancelDraw() external;

    /**
     * @notice Completes the Draw (RNG) request and pushes a Draw onto DrawBuffer.
     */
    function completeDraw() external;

    /**
     * @notice Returns the block number that the current RNG request has been locked to.
     * @return The block number that the RNG request is locked to
     */
    function getLastRngLockBlock() external view returns (uint32);

    /**
     * @notice Returns the current RNG Request ID.
     * @return The current Request ID
     */
    function getLastRngRequestId() external view returns (uint32);

    /**
     * @notice Returns whether the beacon period is over
     * @return True if the beacon period is over, false otherwise
     */
    function isBeaconPeriodOver() external view returns (bool);

    /**
     * @notice Returns whether the random number request has completed.
     * @return True if a random number request has completed, false otherwise.
     */
    function isRngCompleted() external view returns (bool);

    /**
     * @notice Returns whether a random number has been requested
     * @return True if a random number has been requested, false otherwise.
     */
    function isRngRequested() external view returns (bool);

    /**
     * @notice Returns whether the random number request has timed out.
     * @return True if a random number request has timed out, false otherwise.
     */
    function isRngTimedOut() external view returns (bool);

    /**
     * @notice Allows the owner to set the beacon period in seconds.
     * @param beaconPeriodSeconds The new beacon period in seconds.  Must be greater than zero.
     */
    function setBeaconPeriodSeconds(uint32 beaconPeriodSeconds) external;

    /**
     * @notice Allows the owner to set the RNG request timeout in seconds. This is the time that must elapsed before the RNG request can be cancelled and the pool unlocked.
     * @param rngTimeout The RNG request timeout in seconds.
     */
    function setRngTimeout(uint32 rngTimeout) external;

    /**
     * @notice Sets the RNG service that the Prize Strategy is connected to
     * @param rngService The address of the new RNG service interface
     */
    function setRngService(RNGInterface rngService) external;

    /**
     * @notice Starts the Draw process by starting random number request. The previous beacon period must have ended.
     * @dev The RNG-Request-Fee is expected to be held within this contract before calling this function
     */
    function startDraw() external;

    /**
     * @notice Set global DrawBuffer variable.
     * @dev    All subsequent Draw requests/completions will be pushed to the new DrawBuffer.
     * @param newDrawBuffer DrawBuffer address
     * @return DrawBuffer
     */
    function setDrawBuffer(IDrawBuffer newDrawBuffer) external returns (IDrawBuffer);
}",1458
RealWorld_BA_34_ObservationLibHarness_RealWord_20240820005707.log,34,ObservationLibHarness,8503,5483,13986,102.0,0.152175,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../../libraries/ObservationLib.sol"";

/// @title Time-Weighted Average Balance Library
/// @notice This library allows you to efficiently track a user's historic balance.  You can get a
/// @author PoolTogether Inc.
contract ObservationLibHarness {
    /// @notice The maximum number of twab entries
    uint24 public constant MAX_CARDINALITY = 16777215; // 2**24

    ObservationLib.Observation[MAX_CARDINALITY] observations;

    function setObservations(ObservationLib.Observation[] calldata _observations) external {
        for (uint256 i = 0; i < _observations.length; i++) {
            observations[i] = _observations[i];
        }
    }

    function binarySearch(
        uint24 _observationIndex,
        uint24 _oldestObservationIndex,
        uint32 _target,
        uint24 _cardinality,
        uint32 _time
    )
        external
        view
        returns (
            ObservationLib.Observation memory beforeOrAt,
            ObservationLib.Observation memory atOrAfter
        )
    {
        return
            ObservationLib.binarySearch(
                observations,
                _observationIndex,
                _oldestObservationIndex,
                _target,
                _cardinality,
                _time
            );
    }
}",293
RealWorld_BA_34_OverflowSafeComparatorLibHarness_RealWord_20240820005530.log,34,OverflowSafeComparatorLibHarness,6333,4643,10976,95.0,0.124525,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../../libraries/OverflowSafeComparatorLib.sol"";

contract OverflowSafeComparatorLibHarness {
    using OverflowSafeComparatorLib for uint32;

    function ltHarness(
        uint32 _a,
        uint32 _b,
        uint32 _timestamp
    ) external pure returns (bool) {
        return _a.lt(_b, _timestamp);
    }

    function lteHarness(
        uint32 _a,
        uint32 _b,
        uint32 _timestamp
    ) external pure returns (bool) {
        return _a.lte(_b, _timestamp);
    }

    function checkedSub(
        uint256 _a,
        uint256 _b,
        uint256 _timestamp
    ) external pure returns (uint32) {
        return uint32(_a).checkedSub(uint32(_b), uint32(_timestamp));
    }
}",194
RealWorld_BA_34_DrawCalculatorTimelock_RealWord_20240819235247.log,34,DrawCalculatorTimelock,23534,5605,29139,143.0,0.22977,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/owner-manager-contracts/contracts/Manageable.sol"";

import ""./interfaces/IDrawCalculatorTimelock.sol"";

/**
  * @title  PoolTogether V4 OracleTimelock
  * @author PoolTogether Inc Team
  * @notice OracleTimelock(s) acts as an intermediary between multiple V4 smart contracts.
            The OracleTimelock is responsible for pushing Draws to a DrawBuffer and routing
            claim requests from a PrizeDistributor to a DrawCalculator. The primary objective is
            to include a ""cooldown"" period for all new Draws. Allowing the correction of a
            maliciously set Draw in the unfortunate event an Owner is compromised.
*/
contract DrawCalculatorTimelock is IDrawCalculatorTimelock, Manageable {
    /* ============ Global Variables ============ */

    /// @notice Internal DrawCalculator reference.
    IDrawCalculator internal immutable calculator;

    /// @notice Seconds required to elapse before newest Draw is available.
    uint32 internal timelockDuration;

    /// @notice Internal Timelock struct reference.
    Timelock internal timelock;

    /* ============ Events ============ */

    /**
     * @notice Deployed event when the constructor is called
     * @param drawCalculator DrawCalculator address bound to this timelock
     * @param timelockDuration Initial timelock duration
     */
    event Deployed(IDrawCalculator indexed drawCalculator, uint32 timelockDuration);

    /* ============ Deploy ============ */

    /**
     * @notice Initialize DrawCalculatorTimelockTrigger smart contract.
     * @param _owner                       Address of the DrawCalculator owner.
     * @param _calculator                 DrawCalculator address.
     * @param _timelockDuration           Elapsed seconds before new Draw is available.
     */
    constructor(
        address _owner,
        IDrawCalculator _calculator,
        uint32 _timelockDuration
    ) Ownable(_owner) {
        calculator = _calculator;
        _setTimelockDuration(_timelockDuration);

        emit Deployed(_calculator, _timelockDuration);
    }

    /* ============ External Functions ============ */

    /// @inheritdoc IDrawCalculatorTimelock
    function calculate(
        address user,
        uint32[] calldata drawIds,
        bytes calldata data
    ) external view override returns (uint256[] memory, bytes memory) {
        Timelock memory _timelock = timelock;

        for (uint256 i = 0; i < drawIds.length; i++) {
            // if draw id matches timelock and not expired, revert
            if (drawIds[i] == _timelock.drawId) {
                _requireTimelockElapsed(_timelock);
            }
        }

        return calculator.calculate(user, drawIds, data);
    }

    /// @inheritdoc IDrawCalculatorTimelock
    function lock(uint32 _drawId) external override onlyManagerOrOwner returns (bool) {
        Timelock memory _timelock = timelock;
        require(_drawId == _timelock.drawId + 1, ""OM/not-drawid-plus-one"");

        _requireTimelockElapsed(_timelock);

        uint128 _timestamp = uint128(block.timestamp);
        timelock = Timelock({ drawId: _drawId, timestamp: _timestamp });
        emit LockedDraw(_drawId, uint32(_timestamp));

        return true;
    }

    /// @inheritdoc IDrawCalculatorTimelock
    function getDrawCalculator() external view override returns (IDrawCalculator) {
        return calculator;
    }

    /// @inheritdoc IDrawCalculatorTimelock
    function getTimelock() external view override returns (Timelock memory) {
        return timelock;
    }

    /// @inheritdoc IDrawCalculatorTimelock
    function getTimelockDuration() external view override returns (uint32) {
        return timelockDuration;
    }

    /// @inheritdoc IDrawCalculatorTimelock
    function setTimelock(Timelock memory _timelock) external override onlyOwner {
        timelock = _timelock;

        emit TimelockSet(_timelock);
    }

    /// @inheritdoc IDrawCalculatorTimelock
    function setTimelockDuration(uint32 _timelockDuration) external override onlyOwner {
        _setTimelockDuration(_timelockDuration);
    }

    /// @inheritdoc IDrawCalculatorTimelock
    function hasElapsed() external view override returns (bool) {
        return _timelockHasElapsed(timelock);
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Set global timelockDuration variable.
     */
    function _setTimelockDuration(uint32 _timelockDuration) internal {
        timelockDuration = _timelockDuration;
        emit TimelockDurationSet(_timelockDuration);
    }

    /**
     * @notice Read global DrawCalculator variable.
     * @return IDrawCalculator
     */
    function _timelockHasElapsed(Timelock memory _timelock) internal view returns (bool) {
        // If the timelock hasn't been initialized, then it's elapsed
        if (_timelock.timestamp == 0) {
            return true;
        }

        // Otherwise if the timelock has expired, we're good.
        return (block.timestamp > _timelock.timestamp + timelockDuration);
    }

    /**
     * @notice Require the timelock ""cooldown"" period has elapsed
     * @param _timelock the Timelock to check
     */
    function _requireTimelockElapsed(Timelock memory _timelock) internal view {
        require(_timelockHasElapsed(_timelock), ""OM/timelock-not-expired"");
    }
}",1261
RealWorld_BA_34_ReserveHarness_RealWord_20240820004301.log,34,ReserveHarness,6988,5091,12079,104.0,0.13676,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../Reserve.sol"";
import ""./ERC20Mintable.sol"";

contract ReserveHarness is Reserve {
    constructor(address _owner, IERC20 _token) Reserve(_owner, _token) {}

    function getReserveAccumulatedAt(
        ObservationLib.Observation memory _newestObservation,
        ObservationLib.Observation memory _oldestObservation,
        uint24 _cardinality,
        uint32 timestamp
    ) public view returns (uint224) {
        return
            _getReserveAccumulatedAt(
                _newestObservation,
                _oldestObservation,
                _cardinality,
                timestamp
            );
    }

    function setObservationsAt(ObservationLib.Observation[] calldata observations) external {
        for (uint256 i = 0; i < observations.length; i++) {
            reserveAccumulators[i] = observations[i];
        }

        cardinality = uint16(observations.length);
    }

    function doubleCheckpoint(ERC20Mintable _token, uint256 _amount) external {
        _checkpoint();
        _token.mint(address(this), _amount);
        _checkpoint();
    }
}",263
RealWorld_BA_34_DrawRingBufferLib_RealWord_20240820010031.log,34,DrawRingBufferLib,11741,5025,16766,103.0,0.159205,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""./RingBufferLib.sol"";

/// @title Library for creating and managing a draw ring buffer.
library DrawRingBufferLib {
    /// @notice Draw buffer struct.
    struct Buffer {
        uint32 lastDrawId;
        uint32 nextIndex;
        uint32 cardinality;
    }

    /// @notice Helper function to know if the draw ring buffer has been initialized.
    /// @dev since draws start at 1 and are monotonically increased, we know we are uninitialized if nextIndex = 0 and lastDrawId = 0.
    /// @param _buffer The buffer to check.
    function isInitialized(Buffer memory _buffer) internal pure returns (bool) {
        return !(_buffer.nextIndex == 0 && _buffer.lastDrawId == 0);
    }

    /// @notice Push a draw to the buffer.
    /// @param _buffer The buffer to push to.
    /// @param _drawId The drawID to push.
    /// @return The new buffer.
    function push(Buffer memory _buffer, uint32 _drawId) internal pure returns (Buffer memory) {
        require(!isInitialized(_buffer) || _drawId == _buffer.lastDrawId + 1, ""DRB/must-be-contig"");

        return
            Buffer({
                lastDrawId: _drawId,
                nextIndex: uint32(RingBufferLib.nextIndex(_buffer.nextIndex, _buffer.cardinality)),
                cardinality: _buffer.cardinality
            });
    }

    /// @notice Get draw ring buffer index pointer.
    /// @param _buffer The buffer to get the `nextIndex` from.
    /// @param _drawId The draw id to get the index for.
    /// @return The draw ring buffer index pointer.
    function getIndex(Buffer memory _buffer, uint32 _drawId) internal pure returns (uint32) {
        require(isInitialized(_buffer) && _drawId <= _buffer.lastDrawId, ""DRB/future-draw"");

        uint32 indexOffset = _buffer.lastDrawId - _drawId;
        require(indexOffset < _buffer.cardinality, ""DRB/expired-draw"");

        uint256 mostRecent = RingBufferLib.newestIndex(_buffer.nextIndex, _buffer.cardinality);

        return uint32(RingBufferLib.offset(uint32(mostRecent), indexOffset, _buffer.cardinality));
    }
}",513
RealWorld_BA_34_PrizeSplitHarness_RealWord_20240820003557.log,34,PrizeSplitHarness,5338,4630,9968,95.0,0.11929,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../prize-strategy/PrizeSplit.sol"";
import ""../interfaces/IControlledToken.sol"";

contract PrizeSplitHarness is PrizeSplit {
    constructor(address _owner) Ownable(_owner) {}

    function _awardPrizeSplitAmount(address target, uint256 amount) internal override {
        emit PrizeSplitAwarded(target, amount, IControlledToken(address(0)));
    }

    function awardPrizeSplitAmount(address target, uint256 amount) external {
        return _awardPrizeSplitAmount(target, amount);
    }

    function getPrizePool() external pure override returns (IPrizePool) {
        return IPrizePool(address(0));
    }
}",160
RealWorld_BA_34_DrawBuffer_RealWord_20240820001138.log,34,DrawBuffer,27151,6650,33801,149.0,0.268755,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/owner-manager-contracts/contracts/Manageable.sol"";

import ""./interfaces/IDrawBuffer.sol"";
import ""./interfaces/IDrawBeacon.sol"";
import ""./interfaces/IDrawBeacon.sol"";
import ""./libraries/DrawRingBufferLib.sol"";

/**
  * @title  PoolTogether V4 DrawBuffer
  * @author PoolTogether Inc Team
  * @notice The DrawBuffer provides historical lookups of Draws via a circular ring buffer.
            Historical Draws can be accessed on-chain using a drawId to calculate ring buffer storage slot.
            The Draw settings can be created by manager/owner and existing Draws can only be updated the owner.
            Once a starting Draw has been added to the ring buffer, all following draws must have a sequential Draw ID.
    @dev    A DrawBuffer store a limited number of Draws before beginning to overwrite (managed via the cardinality) previous Draws.
    @dev    All mainnet DrawBuffer(s) are updated directly from a DrawBeacon, but non-mainnet DrawBuffer(s) (Matic, Optimism, Arbitrum, etc...)
            will receive a cross-chain message, duplicating the mainnet Draw configuration - enabling a prize savings liquidity network.
*/
contract DrawBuffer is IDrawBuffer, Manageable {
    using DrawRingBufferLib for DrawRingBufferLib.Buffer;

    /// @notice Draws ring buffer max length.
    uint16 public constant MAX_CARDINALITY = 256;

    /// @notice Draws ring buffer array.
    IDrawBeacon.Draw[MAX_CARDINALITY] private _draws;

    /// @notice Holds ring buffer information
    DrawRingBufferLib.Buffer internal drawRingBuffer;

    /* ============ Deploy ============ */

    /**
     * @notice Deploy DrawBuffer smart contract.
     * @param _owner Address of the owner of the DrawBuffer.
     * @param _cardinality Draw ring buffer cardinality.
     */
    constructor(address _owner, uint8 _cardinality) Ownable(_owner) {
        drawRingBuffer.cardinality = _cardinality;
    }

    /* ============ External Functions ============ */

    /// @inheritdoc IDrawBuffer
    function getBufferCardinality() external view override returns (uint32) {
        return drawRingBuffer.cardinality;
    }

    /// @inheritdoc IDrawBuffer
    function getDraw(uint32 drawId) external view override returns (IDrawBeacon.Draw memory) {
        return _draws[_drawIdToDrawIndex(drawRingBuffer, drawId)];
    }

    /// @inheritdoc IDrawBuffer
    function getDraws(uint32[] calldata _drawIds)
        external
        view
        override
        returns (IDrawBeacon.Draw[] memory)
    {
        IDrawBeacon.Draw[] memory draws = new IDrawBeacon.Draw[](_drawIds.length);
        DrawRingBufferLib.Buffer memory buffer = drawRingBuffer;

        for (uint256 index = 0; index < _drawIds.length; index++) {
            draws[index] = _draws[_drawIdToDrawIndex(buffer, _drawIds[index])];
        }

        return draws;
    }

    /// @inheritdoc IDrawBuffer
    function getDrawCount() external view override returns (uint32) {
        DrawRingBufferLib.Buffer memory buffer = drawRingBuffer;

        if (buffer.lastDrawId == 0) {
            return 0;
        }

        uint32 bufferNextIndex = buffer.nextIndex;

        if (_draws[bufferNextIndex].timestamp != 0) {
            return buffer.cardinality;
        } else {
            return bufferNextIndex;
        }
    }

    /// @inheritdoc IDrawBuffer
    function getNewestDraw() external view override returns (IDrawBeacon.Draw memory) {
        return _getNewestDraw(drawRingBuffer);
    }

    /// @inheritdoc IDrawBuffer
    function getOldestDraw() external view override returns (IDrawBeacon.Draw memory) {
        // oldest draw should be next available index, otherwise it's at 0
        DrawRingBufferLib.Buffer memory buffer = drawRingBuffer;
        IDrawBeacon.Draw memory draw = _draws[buffer.nextIndex];

        if (draw.timestamp == 0) {
            // if draw is not init, then use draw at 0
            draw = _draws[0];
        }

        return draw;
    }

    /// @inheritdoc IDrawBuffer
    function pushDraw(IDrawBeacon.Draw memory _draw)
        external
        override
        onlyManagerOrOwner
        returns (uint32)
    {
        return _pushDraw(_draw);
    }

    /// @inheritdoc IDrawBuffer
    function setDraw(IDrawBeacon.Draw memory _newDraw) external override onlyOwner returns (uint32) {
        DrawRingBufferLib.Buffer memory buffer = drawRingBuffer;
        uint32 index = buffer.getIndex(_newDraw.drawId);
        _draws[index] = _newDraw;
        emit DrawSet(_newDraw.drawId, _newDraw);
        return _newDraw.drawId;
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Convert a Draw.drawId to a Draws ring buffer index pointer.
     * @dev    The getNewestDraw.drawId() is used to calculate a Draws ID delta position.
     * @param _drawId Draw.drawId
     * @return Draws ring buffer index pointer
     */
    function _drawIdToDrawIndex(DrawRingBufferLib.Buffer memory _buffer, uint32 _drawId)
        internal
        pure
        returns (uint32)
    {
        return _buffer.getIndex(_drawId);
    }

    /**
     * @notice Read newest Draw from the draws ring buffer.
     * @dev    Uses the lastDrawId to calculate the most recently added Draw.
     * @param _buffer Draw ring buffer
     * @return IDrawBeacon.Draw
     */
    function _getNewestDraw(DrawRingBufferLib.Buffer memory _buffer)
        internal
        view
        returns (IDrawBeacon.Draw memory)
    {
        return _draws[_buffer.getIndex(_buffer.lastDrawId)];
    }

    /**
     * @notice Push Draw onto draws ring buffer history.
     * @dev    Push new draw onto draws list via authorized manager or owner.
     * @param _newDraw IDrawBeacon.Draw
     * @return Draw.drawId
     */
    function _pushDraw(IDrawBeacon.Draw memory _newDraw) internal returns (uint32) {
        DrawRingBufferLib.Buffer memory _buffer = drawRingBuffer;
        _draws[_buffer.nextIndex] = _newDraw;
        drawRingBuffer = _buffer.push(_newDraw.drawId);

        emit DrawSet(_newDraw.drawId, _newDraw);

        return _newDraw.drawId;
    }
}",1442
RealWorld_BA_34_IReserve_RealWord_20240820013234.log,34,IReserve,9951,5820,15771,119.0,0.166155,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IReserve {
    /**
     * @notice Emit when checkpoint is created.
     * @param reserveAccumulated  Total depsosited
     * @param withdrawAccumulated Total withdrawn
     */

    event Checkpoint(uint256 reserveAccumulated, uint256 withdrawAccumulated);
    /**
     * @notice Emit when the withdrawTo function has executed.
     * @param recipient Address receiving funds
     * @param amount    Amount of tokens transfered.
     */
    event Withdrawn(address indexed recipient, uint256 amount);

    /**
     * @notice Create observation checkpoint in ring bufferr.
     * @dev    Calculates total desposited tokens since last checkpoint and creates new accumulator checkpoint.
     */
    function checkpoint() external;

    /**
     * @notice Read global token value.
     * @return IERC20
     */
    function getToken() external view returns (IERC20);

    /**
     * @notice Calculate token accumulation beween timestamp range.
     * @dev    Search the ring buffer for two checkpoint observations and diffs accumulator amount.
     * @param startTimestamp Account address
     * @param endTimestamp   Transfer amount
     */
    function getReserveAccumulatedBetween(uint32 startTimestamp, uint32 endTimestamp)
        external
        returns (uint224);

    /**
     * @notice Transfer Reserve token balance to recipient address.
     * @dev    Creates checkpoint before token transfer. Increments withdrawAccumulator with amount.
     * @param recipient Account address
     * @param amount    Transfer amount
     */
    function withdrawTo(address recipient, uint256 amount) external;
}",372
RealWorld_BA_34_CTokenInterface_RealWord_20240820011221.log,34,CTokenInterface,5913,4781,10694,91.0,0.125185,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface CTokenInterface is IERC20 {
    function decimals() external view returns (uint8);

    function totalSupply() external view override returns (uint256);

    function underlying() external view returns (address);

    function balanceOfUnderlying(address owner) external returns (uint256);

    function supplyRatePerBlock() external returns (uint256);

    function exchangeRateCurrent() external returns (uint256);

    function mint(uint256 mintAmount) external returns (uint256);

    function redeem(uint256 amount) external returns (uint256);

    function balanceOf(address user) external view override returns (uint256);

    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);
}",179
RealWorld_BA_34_IPrizeFlush_RealWord_20240819234622.log,34,IPrizeFlush,9593,4872,14465,116.0,0.145405,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/v4-core/contracts/interfaces/IReserve.sol"";
import ""@pooltogether/v4-core/contracts/interfaces/IStrategy.sol"";

interface IPrizeFlush {
    /**
     * @notice Emit when the flush function has executed.
     * @param destination Address receiving funds
     * @param amount      Amount of tokens transferred
     */
    event Flushed(address indexed destination, uint256 amount);

    /**
     * @notice Emit when destination is set.
     * @param destination Destination address
     */
    event DestinationSet(address destination);

    /**
     * @notice Emit when strategy is set.
     * @param strategy Strategy address
     */
    event StrategySet(IStrategy strategy);

    /**
     * @notice Emit when reserve is set.
     * @param reserve Reserve address
     */
    event ReserveSet(IReserve reserve);

    /// @notice Read global destination variable.
    function getDestination() external view returns (address);

    /// @notice Read global reserve variable.
    function getReserve() external view returns (IReserve);

    /// @notice Read global strategy variable.
    function getStrategy() external view returns (IStrategy);

    /// @notice Set global destination variable.
    function setDestination(address _destination) external returns (address);

    /// @notice Set global reserve variable.
    function setReserve(IReserve _reserve) external returns (IReserve);

    /// @notice Set global strategy variable.
    function setStrategy(IStrategy _strategy) external returns (IStrategy);

    /**
     * @notice Migrate interest from PrizePool to DrawPrizes in single transaction.
     * @dev    Captures interest, checkpoint data and transfers tokens to final destination.
     * @return True if operation is successful.
     */
    function flush() external returns (bool);
}",398
RealWorld_BA_34_L1TimelockTrigger_RealWord_20240819235724.log,34,L1TimelockTrigger,14224,5707,19931,143.0,0.18526,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;
import ""@pooltogether/owner-manager-contracts/contracts/Manageable.sol"";
import ""@pooltogether/v4-core/contracts/interfaces/IPrizeDistributionBuffer.sol"";
import ""./interfaces/IDrawCalculatorTimelock.sol"";

/**
  * @title  PoolTogether V4 L1TimelockTrigger
  * @author PoolTogether Inc Team
  * @notice L1TimelockTrigger(s) acts as an intermediary between multiple V4 smart contracts.
            The L1TimelockTrigger is responsible for pushing Draws to a DrawBuffer and routing
            claim requests from a PrizeDistributor to a DrawCalculator. The primary objective is
            to  include a ""cooldown"" period for all new Draws. Allowing the correction of a
            malicously set Draw in the unfortunate event an Owner is compromised.
*/
contract L1TimelockTrigger is Manageable {
    /* ============ Events ============ */

    /// @notice Emitted when the contract is deployed.
    /// @param prizeDistributionBuffer The address of the prize distribution buffer contract.
    /// @param timelock The address of the DrawCalculatorTimelock
    event Deployed(
        IPrizeDistributionBuffer indexed prizeDistributionBuffer,
        IDrawCalculatorTimelock indexed timelock
    );

    /**
     * @notice Emitted when target prize distribution is pushed.
     * @param drawId    Draw ID
     * @param prizeDistribution PrizeDistribution
     */
    event PrizeDistributionPushed(uint32 indexed drawId, IPrizeDistributionBuffer.PrizeDistribution prizeDistribution);


    /* ============ Global Variables ============ */

    /// @notice Internal PrizeDistributionBuffer reference.
    IPrizeDistributionBuffer public immutable prizeDistributionBuffer;

    /// @notice Timelock struct reference.
    IDrawCalculatorTimelock public timelock;

    /* ============ Deploy ============ */

    /**
     * @notice Initialize L1TimelockTrigger smart contract.
     * @param _owner                    Address of the L1TimelockTrigger owner.
     * @param _prizeDistributionBuffer PrizeDistributionBuffer address
     * @param _timelock                 Elapsed seconds before new Draw is available
     */
    constructor(
        address _owner,
        IPrizeDistributionBuffer _prizeDistributionBuffer,
        IDrawCalculatorTimelock _timelock
    ) Ownable(_owner) {
        prizeDistributionBuffer = _prizeDistributionBuffer;
        timelock = _timelock;

        emit Deployed(_prizeDistributionBuffer, _timelock);
    }

    /**
     * @notice Push Draw onto draws ring buffer history.
     * @dev    Restricts new draws by forcing a push timelock.
     * @param _drawId draw id
     * @param _prizeDistribution PrizeDistribution parameters
     */
    function push(uint32 _drawId, IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution)
        external
        onlyManagerOrOwner
    {
        timelock.lock(_drawId);
        prizeDistributionBuffer.pushPrizeDistribution(_drawId, _prizeDistribution);
        emit PrizeDistributionPushed(_drawId, _prizeDistribution);
    }
}",684
RealWorld_BA_34_IDrawCalculatorTimelock_RealWord_20240819235949.log,34,IDrawCalculatorTimelock,14642,5302,19944,132.0,0.17925,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/v4-core/contracts/interfaces/IDrawCalculator.sol"";

interface IDrawCalculatorTimelock {
    struct Timelock {
        uint128 timestamp;
        uint32 drawId;
    }

    /**
     * @notice Emitted when target draw id is locked.
     * @param drawId    Draw ID
     * @param timestamp Block timestamp
     */
    event LockedDraw(uint32 indexed drawId, uint32 timestamp);

    /**
     * @notice Emitted event when the timelock struct is updated
     * @param timelock Timelock struct set
     */
    event TimelockSet(Timelock timelock);

    /**
     * @notice Emitted event when the timelock duration is updated
     * @param duration Timelock duration set in seconds
     */
    event TimelockDurationSet(uint32 duration);

    /**
     * @notice Routes claim/calculate requests between PrizeDistributor and DrawCalculator.
     * @dev    Will enforce a ""cooldown"" period between when a Draw is pushed and when users can start to claim prizes.
     * @param user    User address
     * @param drawIds Draw.drawId
     * @param data    Encoded pick indices
     * @return Prizes awardable array
     */
    function calculate(
        address user,
        uint32[] calldata drawIds,
        bytes calldata data
    ) external view returns (uint256[] memory, bytes memory);

    /**
     * @notice Lock passed draw id for `timelockDuration` seconds.
     * @dev    Restricts new draws by forcing a push timelock.
     * @param _drawId Draw id to lock.
     * @return True if operation was successful.
     */
    function lock(uint32 _drawId) external returns (bool);

    /**
     * @notice Read internal DrawCalculator variable.
     * @return IDrawCalculator
     */
    function getDrawCalculator() external view returns (IDrawCalculator);

    /**
     * @notice Read internal Timelock struct.
     * @return Timelock
     */
    function getTimelock() external view returns (Timelock memory);

    /**
     * @notice Read internal timelockDuration variable.
     * @return Seconds to pass before Draw is valid.
     */
    function getTimelockDuration() external view returns (uint32);

    /**
     * @notice Set the Timelock struct. Only callable by the contract owner.
     * @param _timelock Timelock struct to set.
     */
    function setTimelock(Timelock memory _timelock) external;

    /**
     * @notice Set new Timelock duration. Only callable by owner
     * @param _timelockDuration Duration in seconds.
     * @dev    Set new Timelock duration and emit TimelockSet event.
     */

    function setTimelockDuration(uint32 _timelockDuration) external;

    /**
     * @notice Returns bool for timelockDuration elapsing.
     * @return True if timelockDuration, since last timelock has elapsed, false otherwise.
     */
    function hasElapsed() external view returns (bool);
}",698
RealWorld_BA_34_PrizeDistributionBuffer_RealWord_20240820001825.log,34,PrizeDistributionBuffer,35226,4948,40174,104.0,0.27509,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/owner-manager-contracts/contracts/Manageable.sol"";

import ""./libraries/DrawRingBufferLib.sol"";
import ""./interfaces/IPrizeDistributionBuffer.sol"";

/**
  * @title  PoolTogether V4 PrizeDistributionBuffer
  * @author PoolTogether Inc Team
  * @notice The PrizeDistributionBuffer contract provides historical lookups of PrizeDistribution struct parameters (linked with a Draw ID) via a
            circular ring buffer. Historical PrizeDistribution parameters can be accessed on-chain using a drawId to calculate
            ring buffer storage slot. The PrizeDistribution parameters can be created by manager/owner and existing PrizeDistribution
            parameters can only be updated the owner. When adding a new PrizeDistribution basic sanity checks will be used to
            validate the incoming parameters.
*/
contract PrizeDistributionBuffer is IPrizeDistributionBuffer, Manageable {
    using DrawRingBufferLib for DrawRingBufferLib.Buffer;

    /// @notice The maximum cardinality of the prize distribution ring buffer.
    /// @dev even with daily draws, 256 will give us over 8 months of history.
    uint256 internal constant MAX_CARDINALITY = 256;

    /// @notice The ceiling for prize distributions.  1e9 = 100%.
    /// @dev It's fixed point 9 because 1e9 is the largest ""1"" that fits into 2**32
    uint256 internal constant TIERS_CEILING = 1e9;

    /// @notice Emitted when the contract is deployed.
    /// @param cardinality The maximum number of records in the buffer before they begin to expire.
    event Deployed(uint8 cardinality);

    /// @notice PrizeDistribution ring buffer history.
    IPrizeDistributionBuffer.PrizeDistribution[MAX_CARDINALITY] internal prizeDistributionRingBuffer;

    /// @notice Ring buffer metadata (nextIndex, lastId, cardinality)
    DrawRingBufferLib.Buffer internal bufferMetadata;

    /* ============ Constructor ============ */

    /**
     * @notice Constructor for PrizeDistributionBuffer
     * @param _owner Address of the PrizeDistributionBuffer owner
     * @param _cardinality Cardinality of the `bufferMetadata`
     */
    constructor(address _owner, uint8 _cardinality) Ownable(_owner) {
        bufferMetadata.cardinality = _cardinality;
        emit Deployed(_cardinality);
    }

    /* ============ External Functions ============ */

    /// @inheritdoc IPrizeDistributionBuffer
    function getBufferCardinality() external view override returns (uint32) {
        return bufferMetadata.cardinality;
    }

    /// @inheritdoc IPrizeDistributionBuffer
    function getPrizeDistribution(uint32 _drawId)
        external
        view
        override
        returns (IPrizeDistributionBuffer.PrizeDistribution memory)
    {
        return _getPrizeDistribution(bufferMetadata, _drawId);
    }

    /// @inheritdoc IPrizeDistributionBuffer
    function getPrizeDistributions(uint32[] calldata _drawIds)
        external
        view
        override
        returns (IPrizeDistributionBuffer.PrizeDistribution[] memory)
    {
        DrawRingBufferLib.Buffer memory buffer = bufferMetadata;
        IPrizeDistributionBuffer.PrizeDistribution[] memory _prizeDistributions = new IPrizeDistributionBuffer.PrizeDistribution[](
            _drawIds.length
        );

        for (uint256 i = 0; i < _drawIds.length; i++) {
            _prizeDistributions[i] = _getPrizeDistribution(buffer, _drawIds[i]);
        }

        return _prizeDistributions;
    }

    /// @inheritdoc IPrizeDistributionBuffer
    function getPrizeDistributionCount() external view override returns (uint32) {
        DrawRingBufferLib.Buffer memory buffer = bufferMetadata;

        if (buffer.lastDrawId == 0) {
            return 0;
        }

        uint32 bufferNextIndex = buffer.nextIndex;

        // If the buffer is full return the cardinality, else retun the nextIndex
        if (prizeDistributionRingBuffer[bufferNextIndex].matchCardinality != 0) {
            return buffer.cardinality;
        } else {
            return bufferNextIndex;
        }
    }

    /// @inheritdoc IPrizeDistributionBuffer
    function getNewestPrizeDistribution()
        external
        view
        override
        returns (IPrizeDistributionBuffer.PrizeDistribution memory prizeDistribution, uint32 drawId)
    {
        DrawRingBufferLib.Buffer memory buffer = bufferMetadata;

        return (
            prizeDistributionRingBuffer[buffer.getIndex(buffer.lastDrawId)],
            buffer.lastDrawId
        );
    }

    /// @inheritdoc IPrizeDistributionBuffer
    function getOldestPrizeDistribution()
        external
        view
        override
        returns (IPrizeDistributionBuffer.PrizeDistribution memory prizeDistribution, uint32 drawId)
    {
        DrawRingBufferLib.Buffer memory buffer = bufferMetadata;

        // if the ring buffer is full, the oldest is at the nextIndex
        prizeDistribution = prizeDistributionRingBuffer[buffer.nextIndex];

        // The PrizeDistribution at index 0 IS by default the oldest prizeDistribution.
        if (buffer.lastDrawId == 0) {
            drawId = 0; // return 0 to indicate no prizeDistribution ring buffer history
        } else if (prizeDistribution.bitRangeSize == 0) {
            // IF the next PrizeDistribution.bitRangeSize == 0 the ring buffer HAS NOT looped around so the oldest is the first entry.
            prizeDistribution = prizeDistributionRingBuffer[0];
            drawId = (buffer.lastDrawId + 1) - buffer.nextIndex;
        } else {
            // Calculates the drawId using the ring buffer cardinality
            // Sequential drawIds are gauranteed by DrawRingBufferLib.push()
            drawId = (buffer.lastDrawId + 1) - buffer.cardinality;
        }
    }

    /// @inheritdoc IPrizeDistributionBuffer
    function pushPrizeDistribution(
        uint32 _drawId,
        IPrizeDistributionBuffer.PrizeDistribution calldata _prizeDistribution
    ) external override onlyManagerOrOwner returns (bool) {
        return _pushPrizeDistribution(_drawId, _prizeDistribution);
    }

    /// @inheritdoc IPrizeDistributionBuffer
    function setPrizeDistribution(
        uint32 _drawId,
        IPrizeDistributionBuffer.PrizeDistribution calldata _prizeDistribution
    ) external override onlyOwner returns (uint32) {
        DrawRingBufferLib.Buffer memory buffer = bufferMetadata;
        uint32 index = buffer.getIndex(_drawId);
        prizeDistributionRingBuffer[index] = _prizeDistribution;

        emit PrizeDistributionSet(_drawId, _prizeDistribution);

        return _drawId;
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Gets the PrizeDistributionBuffer for a drawId
     * @param _buffer DrawRingBufferLib.Buffer
     * @param _drawId drawId
     */
    function _getPrizeDistribution(DrawRingBufferLib.Buffer memory _buffer, uint32 _drawId)
        internal
        view
        returns (IPrizeDistributionBuffer.PrizeDistribution memory)
    {
        return prizeDistributionRingBuffer[_buffer.getIndex(_drawId)];
    }

    /**
     * @notice Set newest PrizeDistributionBuffer in ring buffer storage.
     * @param _drawId       drawId
     * @param _prizeDistribution PrizeDistributionBuffer struct
     */
    function _pushPrizeDistribution(
        uint32 _drawId,
        IPrizeDistributionBuffer.PrizeDistribution calldata _prizeDistribution
    ) internal returns (bool) {

        require(_drawId > 0, ""DrawCalc/draw-id-gt-0"");
        require(_prizeDistribution.matchCardinality > 0, ""DrawCalc/matchCardinality-gt-0"");
        require(
            _prizeDistribution.bitRangeSize <= 256 / _prizeDistribution.matchCardinality,
            ""DrawCalc/bitRangeSize-too-large""
        );

        require(_prizeDistribution.bitRangeSize > 0, ""DrawCalc/bitRangeSize-gt-0"");
        require(_prizeDistribution.maxPicksPerUser > 0, ""DrawCalc/maxPicksPerUser-gt-0"");

        // ensure that the sum of the tiers are not gt 100% and record number of non-zero tiers entries
        uint256 sumTotalTiers = 0;
        uint256 nonZeroTiers = 0;
        uint256 tiersLength = _prizeDistribution.tiers.length;

        for (uint256 index = 0; index < tiersLength; index++) {
            sumTotalTiers += _prizeDistribution.tiers[index];

            if (_prizeDistribution.tiers[index] > 0) {
                nonZeroTiers++;
            }
        }

        // Each tier amount stored as uint32 - summed can't exceed 1e9
        require(sumTotalTiers <= TIERS_CEILING, ""DrawCalc/tiers-gt-100%"");

        require(
            _prizeDistribution.matchCardinality >= nonZeroTiers,
            ""DrawCalc/matchCardinality-gte-tiers""
        );

        DrawRingBufferLib.Buffer memory buffer = bufferMetadata;

        // store the PrizeDistribution in the ring buffer
        prizeDistributionRingBuffer[buffer.nextIndex] = _prizeDistribution;

        // update the ring buffer data
        bufferMetadata = buffer.push(_drawId);

        emit PrizeDistributionSet(_drawId, _prizeDistribution);

        return true;
    }
}",2024
RealWorld_BA_34_DrawBufferHarness_RealWord_20240820004822.log,34,DrawBufferHarness,6296,4821,11117,105.0,0.1279,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../DrawBuffer.sol"";
import ""../interfaces/IDrawBeacon.sol"";

contract DrawBufferHarness is DrawBuffer {
    constructor(address owner, uint8 card) DrawBuffer(owner, card) {}

    function addMultipleDraws(
        uint256 _start,
        uint256 _numberOfDraws,
        uint32 _timestamp,
        uint256 _winningRandomNumber
    ) external {
        for (uint256 index = _start; index <= _numberOfDraws; index++) {
            IDrawBeacon.Draw memory _draw = IDrawBeacon.Draw({
                winningRandomNumber: _winningRandomNumber,
                drawId: uint32(index),
                timestamp: _timestamp,
                beaconPeriodSeconds: 10,
                beaconPeriodStartedAt: 20
            });

            _pushDraw(_draw);
        }
    }
}",192
RealWorld_BA_34_IPrizePool_RealWord_20240820013825.log,34,IPrizePool,31838,5675,37513,104.0,0.27269,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../external/compound/ICompLike.sol"";
import ""../interfaces/ITicket.sol"";

interface IPrizePool {
    /// @dev Event emitted when controlled token is added
    event ControlledTokenAdded(ITicket indexed token);

    event AwardCaptured(uint256 amount);

    /// @dev Event emitted when assets are deposited
    event Deposited(
        address indexed operator,
        address indexed to,
        ITicket indexed token,
        uint256 amount
    );

    /// @dev Event emitted when interest is awarded to a winner
    event Awarded(address indexed winner, ITicket indexed token, uint256 amount);

    /// @dev Event emitted when external ERC20s are awarded to a winner
    event AwardedExternalERC20(address indexed winner, address indexed token, uint256 amount);

    /// @dev Event emitted when external ERC20s are transferred out
    event TransferredExternalERC20(address indexed to, address indexed token, uint256 amount);

    /// @dev Event emitted when external ERC721s are awarded to a winner
    event AwardedExternalERC721(address indexed winner, address indexed token, uint256[] tokenIds);

    /// @dev Event emitted when assets are withdrawn
    event Withdrawal(
        address indexed operator,
        address indexed from,
        ITicket indexed token,
        uint256 amount,
        uint256 redeemed
    );

    /// @dev Event emitted when the Balance Cap is set
    event BalanceCapSet(uint256 balanceCap);

    /// @dev Event emitted when the Liquidity Cap is set
    event LiquidityCapSet(uint256 liquidityCap);

    /// @dev Event emitted when the Prize Strategy is set
    event PrizeStrategySet(address indexed prizeStrategy);

    /// @dev Event emitted when the Ticket is set
    event TicketSet(ITicket indexed ticket);

    /// @dev Emitted when there was an error thrown awarding an External ERC721
    event ErrorAwardingExternalERC721(bytes error);

    /// @notice Deposit assets into the Prize Pool in exchange for tokens
    /// @param to The address receiving the newly minted tokens
    /// @param amount The amount of assets to deposit
    function depositTo(address to, uint256 amount) external;

    /// @notice Deposit assets into the Prize Pool in exchange for tokens,
    /// then sets the delegate on behalf of the caller.
    /// @param to The address receiving the newly minted tokens
    /// @param amount The amount of assets to deposit
    /// @param delegate The address to delegate to for the caller
    function depositToAndDelegate(address to, uint256 amount, address delegate) external;

    /// @notice Withdraw assets from the Prize Pool instantly.  A fairness fee may be charged for an early exit.
    /// @param from The address to redeem tokens from.
    /// @param amount The amount of tokens to redeem for assets.
    /// @return The actual amount withdrawn
    function withdrawFrom(address from, uint256 amount) external returns (uint256);

    /// @notice Called by the prize strategy to award prizes.
    /// @dev The amount awarded must be less than the awardBalance()
    /// @param to The address of the winner that receives the award
    /// @param amount The amount of assets to be awarded
    function award(address to, uint256 amount) external;

    /// @notice Returns the balance that is available to award.
    /// @dev captureAwardBalance() should be called first
    /// @return The total amount of assets to be awarded for the current prize
    function awardBalance() external view returns (uint256);

    /// @notice Captures any available interest as award balance.
    /// @dev This function also captures the reserve fees.
    /// @return The total amount of assets to be awarded for the current prize
    function captureAwardBalance() external returns (uint256);

    /// @dev Checks with the Prize Pool if a specific token type may be awarded as an external prize
    /// @param externalToken The address of the token to check
    /// @return True if the token may be awarded, false otherwise
    function canAwardExternal(address externalToken) external view returns (bool);

    // @dev Returns the total underlying balance of all assets. This includes both principal and interest.
    /// @return The underlying balance of assets
    function balance() external returns (uint256);

    /**
     * @notice Read internal Ticket accounted balance.
     * @return uint256 accountBalance
     */
    function getAccountedBalance() external view returns (uint256);

    /**
     * @notice Read internal balanceCap variable
     */
    function getBalanceCap() external view returns (uint256);

    /**
     * @notice Read internal liquidityCap variable
     */
    function getLiquidityCap() external view returns (uint256);

    /**
     * @notice Read ticket variable
     */
    function getTicket() external view returns (ITicket);

    /**
     * @notice Read token variable
     */
    function getToken() external view returns (address);

    /**
     * @notice Read prizeStrategy variable
     */
    function getPrizeStrategy() external view returns (address);

    /// @dev Checks if a specific token is controlled by the Prize Pool
    /// @param controlledToken The address of the token to check
    /// @return True if the token is a controlled token, false otherwise
    function isControlled(ITicket controlledToken) external view returns (bool);

    /// @notice Called by the Prize-Strategy to transfer out external ERC20 tokens
    /// @dev Used to transfer out tokens held by the Prize Pool.  Could be liquidated, or anything.
    /// @param to The address of the winner that receives the award
    /// @param externalToken The address of the external asset token being awarded
    /// @param amount The amount of external assets to be awarded
    function transferExternalERC20(
        address to,
        address externalToken,
        uint256 amount
    ) external;

    /// @notice Called by the Prize-Strategy to award external ERC20 prizes
    /// @dev Used to award any arbitrary tokens held by the Prize Pool
    /// @param to The address of the winner that receives the award
    /// @param amount The amount of external assets to be awarded
    /// @param externalToken The address of the external asset token being awarded
    function awardExternalERC20(
        address to,
        address externalToken,
        uint256 amount
    ) external;

    /// @notice Called by the prize strategy to award external ERC721 prizes
    /// @dev Used to award any arbitrary NFTs held by the Prize Pool
    /// @param to The address of the winner that receives the award
    /// @param externalToken The address of the external NFT token being awarded
    /// @param tokenIds An array of NFT Token IDs to be transferred
    function awardExternalERC721(
        address to,
        address externalToken,
        uint256[] calldata tokenIds
    ) external;

    /// @notice Allows the owner to set a balance cap per `token` for the pool.
    /// @dev If a user wins, his balance can go over the cap. He will be able to withdraw the excess but not deposit.
    /// @dev Needs to be called after deploying a prize pool to be able to deposit into it.
    /// @param balanceCap New balance cap.
    /// @return True if new balance cap has been successfully set.
    function setBalanceCap(uint256 balanceCap) external returns (bool);

    /// @notice Allows the Governor to set a cap on the amount of liquidity that he pool can hold
    /// @param liquidityCap The new liquidity cap for the prize pool
    function setLiquidityCap(uint256 liquidityCap) external;

    /// @notice Sets the prize strategy of the prize pool.  Only callable by the owner.
    /// @param _prizeStrategy The new prize strategy.
    function setPrizeStrategy(address _prizeStrategy) external;

    /// @notice Set prize pool ticket.
    /// @param ticket Address of the ticket to set.
    /// @return True if ticket has been successfully set.
    function setTicket(ITicket ticket) external returns (bool);

    /// @notice Delegate the votes for a Compound COMP-like token held by the prize pool
    /// @param compLike The COMP-like token held by the prize pool that should be delegated
    /// @param to The address to delegate to
    function compLikeDelegate(ICompLike compLike, address to) external;
}",1791
RealWorld_BA_34_IPrizeDistributionBuffer_RealWord_20240820014011.log,34,IPrizeDistributionBuffer,20132,5563,25695,101.0,0.21192,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

/** @title  IPrizeDistributionBuffer
  * @author PoolTogether Inc Team
  * @notice The PrizeDistributionBuffer interface.
*/
interface IPrizeDistributionBuffer {

    ///@notice PrizeDistribution struct created every draw
    ///@param bitRangeSize Decimal representation of bitRangeSize
    ///@param matchCardinality The number of numbers to consider in the 256 bit random number. Must be > 1 and < 256/bitRangeSize.
    ///@param startTimestampOffset The starting time offset in seconds from which Ticket balances are calculated.
    ///@param endTimestampOffset The end time offset in seconds from which Ticket balances are calculated.
    ///@param maxPicksPerUser Maximum number of picks a user can make in this draw
    ///@param numberOfPicks Number of picks this draw has (may vary across networks according to how much the network has contributed to the Reserve)
    ///@param tiers Array of prize tiers percentages, expressed in fraction form with base 1e9. Ordering: index0: grandPrize, index1: runnerUp, etc.
    ///@param prize Total prize amount available in this draw calculator for this draw (may vary from across networks)
    struct PrizeDistribution {
        uint8 bitRangeSize;
        uint8 matchCardinality;
        uint32 startTimestampOffset;
        uint32 endTimestampOffset;
        uint32 maxPicksPerUser;
        uint136 numberOfPicks;
        uint32[16] tiers;
        uint256 prize;
    }

    /**
     * @notice Emit when PrizeDistribution is set.
     * @param drawId       Draw id
     * @param prizeDistribution IPrizeDistributionBuffer.PrizeDistribution
     */
    event PrizeDistributionSet(
        uint32 indexed drawId,
        IPrizeDistributionBuffer.PrizeDistribution prizeDistribution
    );

    /**
     * @notice Read a ring buffer cardinality
     * @return Ring buffer cardinality
     */
    function getBufferCardinality() external view returns (uint32);

    /**
     * @notice Read newest PrizeDistribution from prize distributions ring buffer.
     * @dev    Uses nextDrawIndex to calculate the most recently added PrizeDistribution.
     * @return prizeDistribution
     * @return drawId
     */
    function getNewestPrizeDistribution()
        external
        view
        returns (IPrizeDistributionBuffer.PrizeDistribution memory prizeDistribution, uint32 drawId);

    /**
     * @notice Read oldest PrizeDistribution from prize distributions ring buffer.
     * @dev    Finds the oldest Draw by buffer.nextIndex and buffer.lastDrawId
     * @return prizeDistribution
     * @return drawId
     */
    function getOldestPrizeDistribution()
        external
        view
        returns (IPrizeDistributionBuffer.PrizeDistribution memory prizeDistribution, uint32 drawId);

    /**
     * @notice Gets PrizeDistribution list from array of drawIds
     * @param drawIds drawIds to get PrizeDistribution for
     * @return prizeDistributionList
     */
    function getPrizeDistributions(uint32[] calldata drawIds)
        external
        view
        returns (IPrizeDistributionBuffer.PrizeDistribution[] memory);

    /**
     * @notice Gets the PrizeDistributionBuffer for a drawId
     * @param drawId drawId
     * @return prizeDistribution
     */
    function getPrizeDistribution(uint32 drawId)
        external
        view
        returns (IPrizeDistributionBuffer.PrizeDistribution memory);

    /**
     * @notice Gets the number of PrizeDistributions stored in the prize distributions ring buffer.
     * @dev If no Draws have been pushed, it will return 0.
     * @dev If the ring buffer is full, it will return the cardinality.
     * @dev Otherwise, it will return the NewestPrizeDistribution index + 1.
     * @return Number of PrizeDistributions stored in the prize distributions ring buffer.
     */
    function getPrizeDistributionCount() external view returns (uint32);

    /**
     * @notice Adds new PrizeDistribution record to ring buffer storage.
     * @dev    Only callable by the owner or manager
     * @param drawId            Draw ID linked to PrizeDistribution parameters
     * @param prizeDistribution PrizeDistribution parameters struct
     */
    function pushPrizeDistribution(
        uint32 drawId,
        IPrizeDistributionBuffer.PrizeDistribution calldata prizeDistribution
    ) external returns (bool);

    /**
     * @notice Sets existing PrizeDistribution with new PrizeDistribution parameters in ring buffer storage.
     * @dev    Retroactively updates an existing PrizeDistribution and should be thought of as a ""safety""
               fallback. If the manager is setting invalid PrizeDistribution parameters the Owner can update
               the invalid parameters with correct parameters.
     * @return drawId
     */
    function setPrizeDistribution(uint32 drawId, IPrizeDistributionBuffer.PrizeDistribution calldata draw)
        external
        returns (uint32);
}",1058
RealWorld_BA_34_ExtendedSafeCastLibHarness_RealWord_20240820005851.log,34,ExtendedSafeCastLibHarness,4666,4783,9449,98.0,0.11899,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../../libraries/ExtendedSafeCastLib.sol"";

contract ExtendedSafeCastLibHarness {
    using ExtendedSafeCastLib for uint256;

    function toUint208(uint256 value) external pure returns (uint208) {
        return value.toUint208();
    }
}",74
RealWorld_BA_34_YieldSourceStub_RealWord_20240820005213.log,34,YieldSourceStub,3862,3579,7441,84.0,0.09089,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";

interface YieldSourceStub is IYieldSource {
    function canAwardExternal(address _externalToken) external view returns (bool);
}",64
RealWorld_BA_34_ERC20Mintable_RealWord_20240820005009.log,34,ERC20Mintable,7304,5660,12964,122.0,0.14972,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

/**
 * @dev Extension of {ERC20} that adds a set of accounts with the {MinterRole},
 * which have permission to mint (create) new tokens as they see fit.
 *
 * At construction, the deployer of the contract is the only minter.
 */
contract ERC20Mintable is ERC20 {
    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}

    /**
     * @dev See {ERC20-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the {MinterRole}.
     */
    function mint(address account, uint256 amount) public returns (bool) {
        _mint(account, amount);
        return true;
    }

    function burn(address account, uint256 amount) public returns (bool) {
        _burn(account, amount);
        return true;
    }

    function masterTransfer(
        address from,
        address to,
        uint256 amount
    ) public {
        _transfer(from, to, amount);
    }
}",252
RealWorld_BA_34_IDrawCalculator_RealWord_20240820012444.log,34,IDrawCalculator,10859,5213,16072,126.0,0.158555,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""./ITicket.sol"";
import ""./IDrawBuffer.sol"";
import ""../PrizeDistributionBuffer.sol"";
import ""../PrizeDistributor.sol"";

/**
 * @title  PoolTogether V4 IDrawCalculator
 * @author PoolTogether Inc Team
 * @notice The DrawCalculator interface.
 */
interface IDrawCalculator {
    struct PickPrize {
        bool won;
        uint8 tierIndex;
    }

    ///@notice Emitted when the contract is initialized
    event Deployed(
        ITicket indexed ticket,
        IDrawBuffer indexed drawBuffer,
        IPrizeDistributionBuffer indexed prizeDistributionBuffer
    );

    ///@notice Emitted when the prizeDistributor is set/updated
    event PrizeDistributorSet(PrizeDistributor indexed prizeDistributor);

    /**
     * @notice Calculates the prize amount for a user for Multiple Draws. Typically called by a PrizeDistributor.
     * @param user User for which to calculate prize amount.
     * @param drawIds drawId array for which to calculate prize amounts for.
     * @param data The ABI encoded pick indices for all Draws. Expected to be winning picks. Pick indices must be less than the totalUserPicks.
     * @return List of awardable prize amounts ordered by drawId.
     */
    function calculate(
        address user,
        uint32[] calldata drawIds,
        bytes calldata data
    ) external view returns (uint256[] memory, bytes memory);

    /**
     * @notice Read global DrawBuffer variable.
     * @return IDrawBuffer
     */
    function getDrawBuffer() external view returns (IDrawBuffer);

    /**
     * @notice Read global DrawBuffer variable.
     * @return IDrawBuffer
     */
    function getPrizeDistributionBuffer() external view returns (IPrizeDistributionBuffer);

    /**
     * @notice Returns a users balances expressed as a fraction of the total supply over time.
     * @param user The users address
     * @param drawIds The drawsId to consider
     * @return Array of balances
     */
    function getNormalizedBalancesForDrawIds(address user, uint32[] calldata drawIds)
        external
        view
        returns (uint256[] memory);

}",482
RealWorld_BA_34_PrizeDistributor_RealWord_20240820001409.log,34,PrizeDistributor,24170,5212,29382,132.0,0.22509,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@pooltogether/owner-manager-contracts/contracts/Ownable.sol"";

import ""./interfaces/IPrizeDistributor.sol"";
import ""./interfaces/IDrawCalculator.sol"";
import ""./interfaces/IDrawBeacon.sol"";

/**
    * @title  PoolTogether V4 PrizeDistributor
    * @author PoolTogether Inc Team
    * @notice The PrizeDistributor contract holds Tickets (captured interest) and distributes tickets to users with winning draw claims.
              PrizeDistributor uses an external IDrawCalculator to validate a users draw claim, before awarding payouts. To prevent users 
              from reclaiming prizes, a payout history for each draw claim is mapped to user accounts. Reclaiming a draw can occur
              if an ""optimal"" prize was not included in previous claim pick indices and the new claims updated payout is greater then
              the previous prize distributor claim payout.
*/
contract PrizeDistributor is IPrizeDistributor, Ownable {
    using SafeERC20 for IERC20;

    /* ============ Global Variables ============ */

    /// @notice DrawCalculator address
    IDrawCalculator internal drawCalculator;

    /// @notice Token address
    IERC20 internal immutable token;

    /// @notice Maps users => drawId => paid out balance
    mapping(address => mapping(uint256 => uint256)) internal userDrawPayouts;

    /* ============ Initialize ============ */

    /**
     * @notice Initialize PrizeDistributor smart contract.
     * @param _owner          Owner address
     * @param _token          Token address
     * @param _drawCalculator DrawCalculator address
     */
    constructor(
        address _owner,
        IERC20 _token,
        IDrawCalculator _drawCalculator
    ) Ownable(_owner) {
        _setDrawCalculator(_drawCalculator);
        require(address(_token) != address(0), ""PrizeDistributor/token-not-zero-address"");
        token = _token;
        emit TokenSet(_token);
    }

    /* ============ External Functions ============ */

    /// @inheritdoc IPrizeDistributor
    function claim(
        address _user,
        uint32[] calldata _drawIds,
        bytes calldata _data
    ) external override returns (uint256) {
        
        uint256 totalPayout;
        
        (uint256[] memory drawPayouts, ) = drawCalculator.calculate(_user, _drawIds, _data); // neglect the prizeCounts since we are not interested in them here

        for (uint256 payoutIndex = 0; payoutIndex < drawPayouts.length; payoutIndex++) {
            uint32 drawId = _drawIds[payoutIndex];
            uint256 payout = drawPayouts[payoutIndex];
            uint256 oldPayout = _getDrawPayoutBalanceOf(_user, drawId);
            uint256 payoutDiff = 0;

            if (payout > oldPayout) {
                payoutDiff = payout - oldPayout;
                _setDrawPayoutBalanceOf(_user, drawId, payout);
            }

            // helpfully short-circuit, in case the user screwed something up.
            require(payoutDiff > 0, ""PrizeDistributor/zero-payout"");

            totalPayout += payoutDiff;

            emit ClaimedDraw(_user, drawId, payoutDiff);
        }

        _awardPayout(_user, totalPayout);

        return totalPayout;
    }

    /// @inheritdoc IPrizeDistributor
    function withdrawERC20(
        IERC20 _erc20Token,
        address _to,
        uint256 _amount
    ) external override onlyOwner returns (bool) {
        require(_to != address(0), ""PrizeDistributor/recipient-not-zero-address"");
        require(address(_erc20Token) != address(0), ""PrizeDistributor/ERC20-not-zero-address"");

        _erc20Token.safeTransfer(_to, _amount);

        emit ERC20Withdrawn(_erc20Token, _to, _amount);

        return true;
    }

    /// @inheritdoc IPrizeDistributor
    function getDrawCalculator() external view override returns (IDrawCalculator) {
        return drawCalculator;
    }

    /// @inheritdoc IPrizeDistributor
    function getDrawPayoutBalanceOf(address _user, uint32 _drawId)
        external
        view
        override
        returns (uint256)
    {
        return _getDrawPayoutBalanceOf(_user, _drawId);
    }

    /// @inheritdoc IPrizeDistributor
    function getToken() external view override returns (IERC20) {
        return token;
    }

    /// @inheritdoc IPrizeDistributor
    function setDrawCalculator(IDrawCalculator _newCalculator)
        external
        override
        onlyOwner
        returns (IDrawCalculator)
    {
        _setDrawCalculator(_newCalculator);
        return _newCalculator;
    }

    /* ============ Internal Functions ============ */

    function _getDrawPayoutBalanceOf(address _user, uint32 _drawId)
        internal
        view
        returns (uint256)
    {
        return userDrawPayouts[_user][_drawId];
    }

    function _setDrawPayoutBalanceOf(
        address _user,
        uint32 _drawId,
        uint256 _payout
    ) internal {
        userDrawPayouts[_user][_drawId] = _payout;
    }

    /**
     * @notice Sets DrawCalculator reference for individual draw id.
     * @param _newCalculator  DrawCalculator address
     */
    function _setDrawCalculator(IDrawCalculator _newCalculator) internal {
        require(address(_newCalculator) != address(0), ""PrizeDistributor/calc-not-zero"");
        drawCalculator = _newCalculator;

        emit DrawCalculatorSet(_newCalculator);
    }

    /**
     * @notice Transfer claimed draw(s) total payout to user.
     * @param _to      User address
     * @param _amount  Transfer amount
     */
    function _awardPayout(address _to, uint256 _amount) internal {
        token.safeTransfer(_to, _amount);
    }

}",1339
RealWorld_BA_34_TicketHarness_RealWord_20240820002807.log,34,TicketHarness,11211,5658,16869,108.0,0.169215,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";

import ""../Ticket.sol"";

contract TicketHarness is Ticket {
    using SafeCast for uint256;

    constructor(
        string memory _name,
        string memory _symbol,
        uint8 decimals_,
        address _controller
    ) Ticket(_name, _symbol, decimals_, _controller) {}

    function flashLoan(address _to, uint256 _amount) external {
        _mint(_to, _amount);
        _burn(_to, _amount);
    }

    function burn(address _from, uint256 _amount) external {
        _burn(_from, _amount);
    }

    function mint(address _to, uint256 _amount) external {
        _mint(_to, _amount);
    }

    function mintTwice(address _to, uint256 _amount) external {
        _mint(_to, _amount);
        _mint(_to, _amount);
    }

    /// @dev we need to use a different function name than `transfer`
    /// otherwise it collides with the `transfer` function of the `ERC20` contract
    function transferTo(
        address _sender,
        address _recipient,
        uint256 _amount
    ) external {
        _transfer(_sender, _recipient, _amount);
    }

    function getBalanceTx(address _user, uint32 _target) external view returns (uint256) {
        TwabLib.Account storage account = userTwabs[_user];

        return
            TwabLib.getBalanceAt(account.twabs, account.details, _target, uint32(block.timestamp));
    }

    function getAverageBalanceTx(
        address _user,
        uint32 _startTime,
        uint32 _endTime
    ) external view returns (uint256) {
        TwabLib.Account storage account = userTwabs[_user];

        return
            TwabLib.getAverageBalanceBetween(
                account.twabs,
                account.details,
                uint32(_startTime),
                uint32(_endTime),
                uint32(block.timestamp)
            );
    }
}",444
RealWorld_BA_34_StakePrizePool_RealWord_20240820011705.log,34,StakePrizePool,13851,5538,19389,115.0,0.180015,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./PrizePool.sol"";

/**
 * @title  PoolTogether V4 StakePrizePool
 * @author PoolTogether Inc Team
 * @notice The Stake Prize Pool is a prize pool in which users can deposit an ERC20 token.
 *         These tokens are simply held by the Stake Prize Pool and become eligible for prizes.
 *         Prizes are added manually by the Stake Prize Pool owner and are distributed to users at the end of the prize period.
 */
contract StakePrizePool is PrizePool {
    /// @notice Address of the stake token.
    IERC20 private stakeToken;

    /// @dev Emitted when stake prize pool is deployed.
    /// @param stakeToken Address of the stake token.
    event Deployed(IERC20 indexed stakeToken);

    /// @notice Deploy the Stake Prize Pool
    /// @param _owner Address of the Stake Prize Pool owner
    /// @param _stakeToken Address of the stake token
    constructor(address _owner, IERC20 _stakeToken) PrizePool(_owner) {
        require(address(_stakeToken) != address(0), ""StakePrizePool/stake-token-not-zero-address"");
        stakeToken = _stakeToken;

        emit Deployed(_stakeToken);
    }

    /// @notice Determines whether the passed token can be transferred out as an external award.
    /// @dev Different yield sources will hold the deposits as another kind of token: such a Compound's cToken.  The
    /// prize strategy should not be allowed to move those tokens.
    /// @param _externalToken The address of the token to check
    /// @return True if the token may be awarded, false otherwise
    function _canAwardExternal(address _externalToken) internal view override returns (bool) {
        return address(stakeToken) != _externalToken;
    }

    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
    /// @return The underlying balance of asset tokens
    function _balance() internal view override returns (uint256) {
        return stakeToken.balanceOf(address(this));
    }

    /// @notice Returns the address of the ERC20 asset token used for deposits.
    /// @return Address of the ERC20 asset token.
    function _token() internal view override returns (IERC20) {
        return stakeToken;
    }

    /// @notice Supplies asset tokens to the yield source.
    /// @param _mintAmount The amount of asset tokens to be supplied
    function _supply(uint256 _mintAmount) internal pure override {
        // no-op because nothing else needs to be done
    }

    /// @notice Redeems asset tokens from the yield source.
    /// @param _redeemAmount The amount of yield-bearing tokens to be redeemed
    /// @return The actual amount of tokens that were redeemed.
    function _redeem(uint256 _redeemAmount) internal pure override returns (uint256) {
        return _redeemAmount;
    }
}",659
RealWorld_BA_34_PrizePool_RealWord_20240820011902.log,34,PrizePool,61311,6281,67592,135.0,0.432175,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""@openzeppelin/contracts/utils/introspection/ERC165Checker.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@pooltogether/owner-manager-contracts/contracts/Ownable.sol"";

import ""../external/compound/ICompLike.sol"";
import ""../interfaces/IPrizePool.sol"";
import ""../interfaces/ITicket.sol"";

/**
  * @title  PoolTogether V4 PrizePool
  * @author PoolTogether Inc Team
  * @notice Escrows assets and deposits them into a yield source.  Exposes interest to Prize Strategy.
            Users deposit and withdraw from this contract to participate in Prize Pool.
            Accounting is managed using Controlled Tokens, whose mint and burn functions can only be called by this contract.
            Must be inherited to provide specific yield-bearing asset control, such as Compound cTokens
*/
abstract contract PrizePool is IPrizePool, Ownable, ReentrancyGuard, IERC721Receiver {
    using SafeCast for uint256;
    using SafeERC20 for IERC20;
    using SafeERC20 for IERC721;
    using ERC165Checker for address;

    /// @notice Semver Version
    string public constant VERSION = ""4.0.0"";

    /// @notice Prize Pool ticket. Can only be set once by calling `setTicket()`.
    ITicket internal ticket;

    /// @notice The Prize Strategy that this Prize Pool is bound to.
    address internal prizeStrategy;

    /// @notice The total amount of tickets a user can hold.
    uint256 internal balanceCap;

    /// @notice The total amount of funds that the prize pool can hold.
    uint256 internal liquidityCap;

    /// @notice the The awardable balance
    uint256 internal _currentAwardBalance;

    /* ============ Modifiers ============ */

    /// @dev Function modifier to ensure caller is the prize-strategy
    modifier onlyPrizeStrategy() {
        require(msg.sender == prizeStrategy, ""PrizePool/only-prizeStrategy"");
        _;
    }

    /// @dev Function modifier to ensure the deposit amount does not exceed the liquidity cap (if set)
    modifier canAddLiquidity(uint256 _amount) {
        require(_canAddLiquidity(_amount), ""PrizePool/exceeds-liquidity-cap"");
        _;
    }

    /* ============ Constructor ============ */

    /// @notice Deploy the Prize Pool
    /// @param _owner Address of the Prize Pool owner
    constructor(address _owner) Ownable(_owner) ReentrancyGuard() {
        _setLiquidityCap(type(uint256).max);
    }

    /* ============ External Functions ============ */

    /// @inheritdoc IPrizePool
    function balance() external override returns (uint256) {
        return _balance();
    }

    /// @inheritdoc IPrizePool
    function awardBalance() external view override returns (uint256) {
        return _currentAwardBalance;
    }

    /// @inheritdoc IPrizePool
    function canAwardExternal(address _externalToken) external view override returns (bool) {
        return _canAwardExternal(_externalToken);
    }

    /// @inheritdoc IPrizePool
    function isControlled(ITicket _controlledToken) external view override returns (bool) {
        return _isControlled(_controlledToken);
    }

    /// @inheritdoc IPrizePool
    function getAccountedBalance() external view override returns (uint256) {
        return _ticketTotalSupply();
    }

    /// @inheritdoc IPrizePool
    function getBalanceCap() external view override returns (uint256) {
        return balanceCap;
    }

    /// @inheritdoc IPrizePool
    function getLiquidityCap() external view override returns (uint256) {
        return liquidityCap;
    }

    /// @inheritdoc IPrizePool
    function getTicket() external view override returns (ITicket) {
        return ticket;
    }

    /// @inheritdoc IPrizePool
    function getPrizeStrategy() external view override returns (address) {
        return prizeStrategy;
    }

    /// @inheritdoc IPrizePool
    function getToken() external view override returns (address) {
        return address(_token());
    }

    /// @inheritdoc IPrizePool
    function captureAwardBalance() external override nonReentrant returns (uint256) {
        uint256 ticketTotalSupply = _ticketTotalSupply();
        uint256 currentAwardBalance = _currentAwardBalance; //sload

        // it's possible for the balance to be slightly less due to rounding errors in the underlying yield source
        uint256 currentBalance = _balance();
        uint256 totalInterest = (currentBalance > ticketTotalSupply)
            ? currentBalance - ticketTotalSupply
            : 0;

        uint256 unaccountedPrizeBalance = (totalInterest > currentAwardBalance)
            ? totalInterest - currentAwardBalance
            : 0;

        if (unaccountedPrizeBalance > 0) {
            currentAwardBalance = currentAwardBalance + unaccountedPrizeBalance;
            _currentAwardBalance = currentAwardBalance; //sstore

            emit AwardCaptured(unaccountedPrizeBalance);
        }

        return currentAwardBalance;
    }

    /// @inheritdoc IPrizePool
    function depositTo(address _to, uint256 _amount)
        external
        override
        nonReentrant
        canAddLiquidity(_amount)
    {
        _depositTo(msg.sender, _to, _amount);
    }

    /// @inheritdoc IPrizePool
    function depositToAndDelegate(address _to, uint256 _amount, address _delegate)
        external
        override
        nonReentrant
        canAddLiquidity(_amount)
    {
        _depositTo(msg.sender, _to, _amount);
        ticket.controllerDelegateFor(msg.sender, _delegate);
    }

    /// @notice Transfers tokens in from one user and mints tickets to another
    /// @notice _operator The user to transfer tokens from
    /// @notice _to The user to mint tickets to
    /// @notice _amount The amount to transfer and mint
    function _depositTo(address _operator, address _to, uint256 _amount) internal
    {
        require(_canDeposit(_to, _amount), ""PrizePool/exceeds-balance-cap"");

        ITicket _ticket = ticket;

        _mint(_to, _amount, _ticket);

        _token().safeTransferFrom(_operator, address(this), _amount);
        _supply(_amount);

        emit Deposited(_operator, _to, _ticket, _amount);
    }

    /// @inheritdoc IPrizePool
    function withdrawFrom(address _from, uint256 _amount)
        external
        override
        nonReentrant
        returns (uint256)
    {
        ITicket _ticket = ticket;

        // burn the tickets
        _ticket.controllerBurnFrom(msg.sender, _from, _amount);

        // redeem the tickets
        uint256 _redeemed = _redeem(_amount);

        _token().safeTransfer(_from, _redeemed);

        emit Withdrawal(msg.sender, _from, _ticket, _amount, _redeemed);

        return _redeemed;
    }

    /// @inheritdoc IPrizePool
    function award(address _to, uint256 _amount) external override onlyPrizeStrategy {
        if (_amount == 0) {
            return;
        }

        uint256 currentAwardBalance = _currentAwardBalance;

        require(_amount <= currentAwardBalance, ""PrizePool/award-exceeds-avail"");
        _currentAwardBalance = currentAwardBalance - _amount;

        ITicket _ticket = ticket;

        _mint(_to, _amount, _ticket);

        emit Awarded(_to, _ticket, _amount);
    }

    /// @inheritdoc IPrizePool
    function transferExternalERC20(
        address _to,
        address _externalToken,
        uint256 _amount
    ) external override onlyPrizeStrategy {
        if (_transferOut(_to, _externalToken, _amount)) {
            emit TransferredExternalERC20(_to, _externalToken, _amount);
        }
    }

    /// @inheritdoc IPrizePool
    function awardExternalERC20(
        address _to,
        address _externalToken,
        uint256 _amount
    ) external override onlyPrizeStrategy {
        if (_transferOut(_to, _externalToken, _amount)) {
            emit AwardedExternalERC20(_to, _externalToken, _amount);
        }
    }

    /// @inheritdoc IPrizePool
    function awardExternalERC721(
        address _to,
        address _externalToken,
        uint256[] calldata _tokenIds
    ) external override onlyPrizeStrategy {
        require(_canAwardExternal(_externalToken), ""PrizePool/invalid-external-token"");

        if (_tokenIds.length == 0) {
            return;
        }

        for (uint256 i = 0; i < _tokenIds.length; i++) {
            try IERC721(_externalToken).safeTransferFrom(address(this), _to, _tokenIds[i]) {} catch (
                bytes memory error
            ) {
                emit ErrorAwardingExternalERC721(error);
            }
        }

        emit AwardedExternalERC721(_to, _externalToken, _tokenIds);
    }

    /// @inheritdoc IPrizePool
    function setBalanceCap(uint256 _balanceCap) external override onlyOwner returns (bool) {
        _setBalanceCap(_balanceCap);
        return true;
    }

    /// @inheritdoc IPrizePool
    function setLiquidityCap(uint256 _liquidityCap) external override onlyOwner {
        _setLiquidityCap(_liquidityCap);
    }

    /// @inheritdoc IPrizePool
    function setTicket(ITicket _ticket) external override onlyOwner returns (bool) {
        address _ticketAddress = address(_ticket);

        require(_ticketAddress != address(0), ""PrizePool/ticket-not-zero-address"");
        require(address(ticket) == address(0), ""PrizePool/ticket-already-set"");

        ticket = _ticket;

        emit TicketSet(_ticket);

        _setBalanceCap(type(uint256).max);

        return true;
    }

    /// @inheritdoc IPrizePool
    function setPrizeStrategy(address _prizeStrategy) external override onlyOwner {
        _setPrizeStrategy(_prizeStrategy);
    }

    /// @inheritdoc IPrizePool
    function compLikeDelegate(ICompLike _compLike, address _to) external override onlyOwner {
        if (_compLike.balanceOf(address(this)) > 0) {
            _compLike.delegate(_to);
        }
    }

    /// @inheritdoc IERC721Receiver
    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure override returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }

    /* ============ Internal Functions ============ */

    /// @notice Transfer out `amount` of `externalToken` to recipient `to`
    /// @dev Only awardable `externalToken` can be transferred out
    /// @param _to Recipient address
    /// @param _externalToken Address of the external asset token being transferred
    /// @param _amount Amount of external assets to be transferred
    /// @return True if transfer is successful
    function _transferOut(
        address _to,
        address _externalToken,
        uint256 _amount
    ) internal returns (bool) {
        require(_canAwardExternal(_externalToken), ""PrizePool/invalid-external-token"");

        if (_amount == 0) {
            return false;
        }

        IERC20(_externalToken).safeTransfer(_to, _amount);

        return true;
    }

    /// @notice Called to mint controlled tokens.  Ensures that token listener callbacks are fired.
    /// @param _to The user who is receiving the tokens
    /// @param _amount The amount of tokens they are receiving
    /// @param _controlledToken The token that is going to be minted
    function _mint(
        address _to,
        uint256 _amount,
        ITicket _controlledToken
    ) internal {
        _controlledToken.controllerMint(_to, _amount);
    }

    /// @dev Checks if `user` can deposit in the Prize Pool based on the current balance cap.
    /// @param _user Address of the user depositing.
    /// @param _amount The amount of tokens to be deposited into the Prize Pool.
    /// @return True if the Prize Pool can receive the specified `amount` of tokens.
    function _canDeposit(address _user, uint256 _amount) internal view returns (bool) {
        ITicket _ticket = ticket;
        uint256 _balanceCap = balanceCap;

        if (_balanceCap == type(uint256).max) return true;

        return (_ticket.balanceOf(_user) + _amount <= _balanceCap);
    }

    /// @dev Checks if the Prize Pool can receive liquidity based on the current cap
    /// @param _amount The amount of liquidity to be added to the Prize Pool
    /// @return True if the Prize Pool can receive the specified amount of liquidity
    function _canAddLiquidity(uint256 _amount) internal view returns (bool) {
        uint256 _liquidityCap = liquidityCap;
        if (_liquidityCap == type(uint256).max) return true;
        return (_ticketTotalSupply() + _amount <= _liquidityCap);
    }

    /// @dev Checks if a specific token is controlled by the Prize Pool
    /// @param _controlledToken The address of the token to check
    /// @return True if the token is a controlled token, false otherwise
    function _isControlled(ITicket _controlledToken) internal view returns (bool) {
        if (ticket == _controlledToken) {
            return true;
        }

        return false;
    }

    /// @notice Allows the owner to set a balance cap per `token` for the pool.
    /// @param _balanceCap New balance cap.
    function _setBalanceCap(uint256 _balanceCap) internal {
        balanceCap = _balanceCap;
        emit BalanceCapSet(_balanceCap);
    }

    /// @notice Allows the owner to set a liquidity cap for the pool
    /// @param _liquidityCap New liquidity cap
    function _setLiquidityCap(uint256 _liquidityCap) internal {
        liquidityCap = _liquidityCap;
        emit LiquidityCapSet(_liquidityCap);
    }

    /// @notice Sets the prize strategy of the prize pool.  Only callable by the owner.
    /// @param _prizeStrategy The new prize strategy
    function _setPrizeStrategy(address _prizeStrategy) internal {
        require(_prizeStrategy != address(0), ""PrizePool/prizeStrategy-not-zero"");

        prizeStrategy = _prizeStrategy;

        emit PrizeStrategySet(_prizeStrategy);
    }

    /// @notice The current total of tickets.
    /// @return Ticket total supply.
    function _ticketTotalSupply() internal view returns (uint256) {
        return ticket.totalSupply();
    }

    /// @dev Gets the current time as represented by the current block
    /// @return The timestamp of the current block
    function _currentTime() internal view virtual returns (uint256) {
        return block.timestamp;
    }

    /* ============ Abstract Contract Implementatiton ============ */

    /// @notice Determines whether the passed token can be transferred out as an external award.
    /// @dev Different yield sources will hold the deposits as another kind of token: such a Compound's cToken.  The
    /// prize strategy should not be allowed to move those tokens.
    /// @param _externalToken The address of the token to check
    /// @return True if the token may be awarded, false otherwise
    function _canAwardExternal(address _externalToken) internal view virtual returns (bool);

    /// @notice Returns the ERC20 asset token used for deposits.
    /// @return The ERC20 asset token
    function _token() internal view virtual returns (IERC20);

    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
    /// @return The underlying balance of asset tokens
    function _balance() internal virtual returns (uint256);

    /// @notice Supplies asset tokens to the yield source.
    /// @param _mintAmount The amount of asset tokens to be supplied
    function _supply(uint256 _mintAmount) internal virtual;

    /// @notice Redeems asset tokens from the yield source.
    /// @param _redeemAmount The amount of yield-bearing tokens to be redeemed
    /// @return The actual amount of tokens that were redeemed.
    function _redeem(uint256 _redeemAmount) internal virtual returns (uint256);
}",3653
RealWorld_BA_34_EIP2612PermitAndDeposit_RealWord_20240820011039.log,34,EIP2612PermitAndDeposit,13587,5663,19250,100.0,0.181195,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""../interfaces/IPrizePool.sol"";

/// @title Allows users to approve and deposit EIP-2612 compatible tokens into a prize pool in a single transaction.
contract EIP2612PermitAndDeposit {
    using SafeERC20 for IERC20;

    /**
     * @notice Permits this contract to spend on a user's behalf, and deposits into the prize pool.
     * @dev The `spender` address required by the permit function is the address of this contract.
     * @param _token Address of the EIP-2612 token to approve and deposit.
     * @param _owner Token owner's address (Authorizer).
     * @param _amount Amount of tokens to deposit.
     * @param _deadline Timestamp at which the signature expires.
     * @param _v `v` portion of the signature.
     * @param _r `r` portion of the signature.
     * @param _s `s` portion of the signature.
     * @param _prizePool Address of the prize pool to deposit into.
     * @param _to Address that will receive the tickets.
     */
    function permitAndDepositTo(
        address _token,
        address _owner,
        uint256 _amount,
        uint256 _deadline,
        uint8 _v,
        bytes32 _r,
        bytes32 _s,
        address _prizePool,
        address _to
    ) external {
        require(msg.sender == _owner, ""EIP2612PermitAndDeposit/only-signer"");

        IERC20Permit(_token).permit(_owner, address(this), _amount, _deadline, _v, _r, _s);

        _depositTo(_token, _owner, _amount, _prizePool, _to);
    }

    /**
     * @notice Deposits user's token into the prize pool.
     * @param _token Address of the EIP-2612 token to approve and deposit.
     * @param _owner Token owner's address (Authorizer).
     * @param _amount Amount of tokens to deposit.
     * @param _prizePool Address of the prize pool to deposit into.
     * @param _to Address that will receive the tickets.
     */
    function _depositTo(
        address _token,
        address _owner,
        uint256 _amount,
        address _prizePool,
        address _to
    ) internal {
        IERC20(_token).safeTransferFrom(_owner, address(this), _amount);
        IERC20(_token).safeApprove(_prizePool, _amount);
        IPrizePool(_prizePool).depositTo(_to, _amount);
    }
}",639
RealWorld_BA_34_ControlledToken_RealWord_20240820000943.log,34,ControlledToken,16827,5133,21960,113.0,0.186795,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol"";

import ""./interfaces/IControlledToken.sol"";

/**
 * @title  PoolTogether V4 Controlled ERC20 Token
 * @author PoolTogether Inc Team
 * @notice  ERC20 Tokens with a controller for minting & burning
 */
contract ControlledToken is ERC20Permit, IControlledToken {
    /* ============ Global Variables ============ */

    /// @notice Interface to the contract responsible for controlling mint/burn
    address public override controller;

    /// @notice ERC20 controlled token decimals.
    uint8 private immutable _decimals;

    /* ============ Events ============ */

    /// @dev Emitted when contract is deployed
    event Deployed(string name, string symbol, uint8 decimals, address indexed controller);

    /* ============ Modifiers ============ */

    /// @dev Function modifier to ensure that the caller is the controller contract
    modifier onlyController() {
        require(msg.sender == address(controller), ""ControlledToken/only-controller"");
        _;
    }

    /* ============ Constructor ============ */

    /// @notice Deploy the Controlled Token with Token Details and the Controller
    /// @param _name The name of the Token
    /// @param _symbol The symbol for the Token
    /// @param decimals_ The number of decimals for the Token
    /// @param _controller Address of the Controller contract for minting & burning
    constructor(
        string memory _name,
        string memory _symbol,
        uint8 decimals_,
        address _controller
    ) ERC20Permit(""PoolTogether ControlledToken"") ERC20(_name, _symbol) {
        require(address(_controller) != address(0), ""ControlledToken/controller-not-zero-address"");
        controller = _controller;

        require(decimals_ > 0, ""ControlledToken/decimals-gt-zero"");
        _decimals = decimals_;

        emit Deployed(_name, _symbol, decimals_, _controller);
    }

    /* ============ External Functions ============ */

    /// @notice Allows the controller to mint tokens for a user account
    /// @dev May be overridden to provide more granular control over minting
    /// @param _user Address of the receiver of the minted tokens
    /// @param _amount Amount of tokens to mint
    function controllerMint(address _user, uint256 _amount)
        external
        virtual
        override
        onlyController
    {
        _mint(_user, _amount);
    }

    /// @notice Allows the controller to burn tokens from a user account
    /// @dev May be overridden to provide more granular control over burning
    /// @param _user Address of the holder account to burn tokens from
    /// @param _amount Amount of tokens to burn
    function controllerBurn(address _user, uint256 _amount)
        external
        virtual
        override
        onlyController
    {
        _burn(_user, _amount);
    }

    /// @notice Allows an operator via the controller to burn tokens on behalf of a user account
    /// @dev May be overridden to provide more granular control over operator-burning
    /// @param _operator Address of the operator performing the burn action via the controller contract
    /// @param _user Address of the holder account to burn tokens from
    /// @param _amount Amount of tokens to burn
    function controllerBurnFrom(
        address _operator,
        address _user,
        uint256 _amount
    ) external virtual override onlyController {
        if (_operator != _user) {
            _approve(_user, _operator, allowance(_user, _operator) - _amount);
        }

        _burn(_user, _amount);
    }

    /// @notice Returns the ERC20 controlled token decimals.
    /// @dev This value should be equal to the decimals of the token used to deposit into the pool.
    /// @return uint8 decimals.
    function decimals() public view virtual override returns (uint8) {
        return _decimals;
    }
}",864
RealWorld_BA_34_DrawRingBufferLibHarness_RealWord_20240820005338.log,34,DrawRingBufferLibHarness,7622,5287,12909,110.0,0.14385,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../../libraries/DrawRingBufferLib.sol"";

/**
 * @title  Expose the DrawRingBufferLib for unit tests
 * @author PoolTogether Inc.
 */
contract DrawRingBufferLibHarness {
    using DrawRingBufferLib for DrawRingBufferLib.Buffer;

    uint16 public constant MAX_CARDINALITY = 256;
    DrawRingBufferLib.Buffer internal drawRingBuffer;

    constructor(uint8 _cardinality) {
        drawRingBuffer.cardinality = _cardinality;
    }

    function _push(DrawRingBufferLib.Buffer memory _buffer, uint32 _drawId)
        external
        pure
        returns (DrawRingBufferLib.Buffer memory)
    {
        return DrawRingBufferLib.push(_buffer, _drawId);
    }

    function _getIndex(DrawRingBufferLib.Buffer memory _buffer, uint32 _drawId)
        external
        pure
        returns (uint32)
    {
        return DrawRingBufferLib.getIndex(_buffer, _drawId);
    }

    function _isInitialized(DrawRingBufferLib.Buffer memory _buffer) external pure returns (bool) {
        return DrawRingBufferLib.isInitialized(_buffer);
    }
}",260
RealWorld_BA_34_RNGServiceMock_RealWord_20240820003921.log,34,RNGServiceMock,7313,4793,12106,93.0,0.132425,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/pooltogether-rng-contracts/contracts/RNGInterface.sol"";

contract RNGServiceMock is RNGInterface {
    uint256 internal random;
    address internal feeToken;
    uint256 internal requestFee;

    function getLastRequestId() external pure override returns (uint32 requestId) {
        return 1;
    }

    function setRequestFee(address _feeToken, uint256 _requestFee) external {
        feeToken = _feeToken;
        requestFee = _requestFee;
    }

    /// @return _feeToken
    /// @return _requestFee
    function getRequestFee()
        external
        view
        override
        returns (address _feeToken, uint256 _requestFee)
    {
        return (feeToken, requestFee);
    }

    function setRandomNumber(uint256 _random) external {
        random = _random;
    }

    function requestRandomNumber() external pure override returns (uint32, uint32) {
        return (1, 1);
    }

    function isRequestComplete(uint32) external pure override returns (bool) {
        return true;
    }

    function randomNumber(uint32) external view override returns (uint256) {
        return random;
    }
}",274
RealWorld_BA_34_PrizeSplitStrategy_RealWord_20240820002011.log,34,PrizeSplitStrategy,13305,5195,18500,137.0,0.170425,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""./PrizeSplit.sol"";
import ""../interfaces/IStrategy.sol"";
import ""../interfaces/IPrizePool.sol"";

/**
  * @title  PoolTogether V4 PrizeSplitStrategy
  * @author PoolTogether Inc Team
  * @notice Captures PrizePool interest for PrizeReserve and additional PrizeSplit recipients.
            The PrizeSplitStrategy will have at minimum a single PrizeSplit with 100% of the captured
            interest transfered to the PrizeReserve. Additional PrizeSplits can be added, depending on
            the deployers requirements (i.e. percentage to charity). In contrast to previous PoolTogether
            iterations, interest can be captured independent of a new Draw. Ideally (to save gas) interest
            is only captured when also distributing the captured prize(s) to applicable ClaimbableDraw(s).
*/
contract PrizeSplitStrategy is PrizeSplit, IStrategy {
    /**
     * @notice PrizePool address
     */
    IPrizePool internal prizePool;

    /**
     * @notice Deployed Event
     * @param owner Contract owner
     * @param prizePool Linked PrizePool contract
     */
    event Deployed(address indexed owner, IPrizePool prizePool);

    /* ============ Constructor ============ */

    /**
     * @notice Deploy the PrizeSplitStrategy smart contract.
     * @param _owner     Owner address
     * @param _prizePool PrizePool address
     */
    constructor(address _owner, IPrizePool _prizePool) Ownable(_owner) {
        require(
            address(_prizePool) != address(0),
            ""PrizeSplitStrategy/prize-pool-not-zero-address""
        );
        prizePool = _prizePool;
        emit Deployed(_owner, _prizePool);
    }

    /* ============ External Functions ============ */

    /// @inheritdoc IStrategy
    function distribute() external override returns (uint256) {
        uint256 prize = prizePool.captureAwardBalance();

        if (prize == 0) return 0;

        _distributePrizeSplits(prize);

        emit Distributed(prize);

        return prize;
    }

    /// @inheritdoc IPrizeSplit
    function getPrizePool() external view override returns (IPrizePool) {
        return prizePool;
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Award ticket tokens to prize split recipient.
     * @dev Award ticket tokens to prize split recipient via the linked PrizePool contract.
     * @param _to Recipient of minted tokens.
     * @param _amount Amount of minted tokens.
     */
    function _awardPrizeSplitAmount(address _to, uint256 _amount) internal override {
        IControlledToken _ticket = prizePool.getTicket();
        prizePool.award(_to, _amount);
        emit PrizeSplitAwarded(_to, _amount, _ticket);
    }
}",628
RealWorld_BA_34_OverflowSafeComparatorLib_RealWord_20240820010216.log,34,OverflowSafeComparatorLib,15599,4367,19966,96.0,0.165335,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

/// @title OverflowSafeComparatorLib library to share comparator functions between contracts
/// @dev Code taken from Uniswap V3 Oracle.sol: https://github.com/Uniswap/v3-core/blob/3e88af408132fc957e3e406f65a0ce2b1ca06c3d/contracts/libraries/Oracle.sol
/// @author PoolTogether Inc.
library OverflowSafeComparatorLib {
    /// @notice 32-bit timestamps comparator.
    /// @dev safe for 0 or 1 overflows, `_a` and `_b` must be chronologically before or equal to time.
    /// @param _a A comparison timestamp from which to determine the relative position of `_timestamp`.
    /// @param _b Timestamp to compare against `_a`.
    /// @param _timestamp A timestamp truncated to 32 bits.
    /// @return bool Whether `_a` is chronologically < `_b`.
    function lt(
        uint32 _a,
        uint32 _b,
        uint32 _timestamp
    ) internal pure returns (bool) {
        // No need to adjust if there hasn't been an overflow
        if (_a <= _timestamp && _b <= _timestamp) return _a < _b;

        uint256 aAdjusted = _a > _timestamp ? _a : _a + 2**32;
        uint256 bAdjusted = _b > _timestamp ? _b : _b + 2**32;

        return aAdjusted < bAdjusted;
    }

    /// @notice 32-bit timestamps comparator.
    /// @dev safe for 0 or 1 overflows, `_a` and `_b` must be chronologically before or equal to time.
    /// @param _a A comparison timestamp from which to determine the relative position of `_timestamp`.
    /// @param _b Timestamp to compare against `_a`.
    /// @param _timestamp A timestamp truncated to 32 bits.
    /// @return bool Whether `_a` is chronologically <= `_b`.
    function lte(
        uint32 _a,
        uint32 _b,
        uint32 _timestamp
    ) internal pure returns (bool) {

        // No need to adjust if there hasn't been an overflow
        if (_a <= _timestamp && _b <= _timestamp) return _a <= _b;

        uint256 aAdjusted = _a > _timestamp ? _a : _a + 2**32;
        uint256 bAdjusted = _b > _timestamp ? _b : _b + 2**32;

        return aAdjusted <= bAdjusted;
    }

    /// @notice 32-bit timestamp subtractor
    /// @dev safe for 0 or 1 overflows, where `_a` and `_b` must be chronologically before or equal to time
    /// @param _a The subtraction left operand
    /// @param _b The subtraction right operand
    /// @param _timestamp The current time.  Expected to be chronologically after both.
    /// @return The difference between a and b, adjusted for overflow
    function checkedSub(
        uint32 _a,
        uint32 _b,
        uint32 _timestamp
    ) internal pure returns (uint32) {
        // No need to adjust if there hasn't been an overflow

        if (_a <= _timestamp && _b <= _timestamp) return _a - _b;

        uint256 aAdjusted = _a > _timestamp ? _a : _a + 2**32;
        uint256 bAdjusted = _b > _timestamp ? _b : _b + 2**32;

        return uint32(aAdjusted - bAdjusted);
    }
}",787
RealWorld_BA_34_ITicket_RealWord_20240820012840.log,34,ITicket,30498,5486,35984,121.0,0.26221,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../libraries/TwabLib.sol"";
import ""./IControlledToken.sol"";

interface ITicket is IControlledToken {
    /**
     * @notice A struct containing details for an Account.
     * @param balance The current balance for an Account.
     * @param nextTwabIndex The next available index to store a new twab.
     * @param cardinality The number of recorded twabs (plus one!).
     */
    struct AccountDetails {
        uint224 balance;
        uint16 nextTwabIndex;
        uint16 cardinality;
    }

    /**
     * @notice Combines account details with their twab history.
     * @param details The account details.
     * @param twabs The history of twabs for this account.
     */
    struct Account {
        AccountDetails details;
        ObservationLib.Observation[65535] twabs;
    }

    /**
     * @notice Emitted when TWAB balance has been delegated to another user.
     * @param delegator Address of the delegator.
     * @param delegate Address of the delegate.
     */
    event Delegated(address indexed delegator, address indexed delegate);

    /**
     * @notice Emitted when ticket is initialized.
     * @param name Ticket name (eg: PoolTogether Dai Ticket (Compound)).
     * @param symbol Ticket symbol (eg: PcDAI).
     * @param decimals Ticket decimals.
     * @param controller Token controller address.
     */
    event TicketInitialized(string name, string symbol, uint8 decimals, address indexed controller);

    /**
     * @notice Emitted when a new TWAB has been recorded.
     * @param delegate The recipient of the ticket power (may be the same as the user).
     * @param newTwab Updated TWAB of a ticket holder after a successful TWAB recording.
     */
    event NewUserTwab(
        address indexed delegate,
        ObservationLib.Observation newTwab
    );

    /**
     * @notice Emitted when a new total supply TWAB has been recorded.
     * @param newTotalSupplyTwab Updated TWAB of tickets total supply after a successful total supply TWAB recording.
     */
    event NewTotalSupplyTwab(ObservationLib.Observation newTotalSupplyTwab);

    /**
     * @notice Retrieves the address of the delegate to whom `user` has delegated their tickets.
     * @dev Address of the delegate will be the zero address if `user` has not delegated their tickets.
     * @param user Address of the delegator.
     * @return Address of the delegate.
     */
    function delegateOf(address user) external view returns (address);

    /**
    * @notice Delegate time-weighted average balances to an alternative address.
    * @dev    Transfers (including mints) trigger the storage of a TWAB in delegate(s) account, instead of the
              targetted sender and/or recipient address(s).
    * @dev    To reset the delegate, pass the zero address (0x000.000) as `to` parameter.
    * @dev Current delegate address should be different from the new delegate address `to`.
    * @param  to Recipient of delegated TWAB.
    */
    function delegate(address to) external;

    /**
     * @notice Allows the controller to delegate on a users behalf.
     * @param user The user for whom to delegate
     * @param delegate The new delegate
     */
    function controllerDelegateFor(address user, address delegate) external;

    /**
     * @notice Allows a user to delegate via signature
     * @param user The user who is delegating
     * @param delegate The new delegate
     * @param deadline The timestamp by which this must be submitted
     * @param v The v portion of the ECDSA sig
     * @param r The r portion of the ECDSA sig
     * @param s The s portion of the ECDSA sig
     */
    function delegateWithSignature(
        address user,
        address delegate,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /**
     * @notice Gets a users twab context.  This is a struct with their balance, next twab index, and cardinality.
     * @param user The user for whom to fetch the TWAB context.
     * @return The TWAB context, which includes { balance, nextTwabIndex, cardinality }
     */
    function getAccountDetails(address user) external view returns (TwabLib.AccountDetails memory);

    /**
     * @notice Gets the TWAB at a specific index for a user.
     * @param user The user for whom to fetch the TWAB.
     * @param index The index of the TWAB to fetch.
     * @return The TWAB, which includes the twab amount and the timestamp.
     */
    function getTwab(address user, uint16 index)
        external
        view
        returns (ObservationLib.Observation memory);

    /**
     * @notice Retrieves `user` TWAB balance.
     * @param user Address of the user whose TWAB is being fetched.
     * @param timestamp Timestamp at which we want to retrieve the TWAB balance.
     * @return The TWAB balance at the given timestamp.
     */
    function getBalanceAt(address user, uint64 timestamp) external view returns (uint256);

    /**
     * @notice Retrieves `user` TWAB balances.
     * @param user Address of the user whose TWABs are being fetched.
     * @param timestamps Timestamps range at which we want to retrieve the TWAB balances.
     * @return `user` TWAB balances.
     */
    function getBalancesAt(address user, uint64[] calldata timestamps)
        external
        view
        returns (uint256[] memory);

    /**
     * @notice Retrieves the average balance held by a user for a given time frame.
     * @param user The user whose balance is checked.
     * @param startTime The start time of the time frame.
     * @param endTime The end time of the time frame.
     * @return The average balance that the user held during the time frame.
     */
    function getAverageBalanceBetween(
        address user,
        uint64 startTime,
        uint64 endTime
    ) external view returns (uint256);

    /**
     * @notice Retrieves the average balances held by a user for a given time frame.
     * @param user The user whose balance is checked.
     * @param startTimes The start time of the time frame.
     * @param endTimes The end time of the time frame.
     * @return The average balance that the user held during the time frame.
     */
    function getAverageBalancesBetween(
        address user,
        uint64[] calldata startTimes,
        uint64[] calldata endTimes
    ) external view returns (uint256[] memory);

    /**
     * @notice Retrieves the total supply TWAB balance at the given timestamp.
     * @param timestamp Timestamp at which we want to retrieve the total supply TWAB balance.
     * @return The total supply TWAB balance at the given timestamp.
     */
    function getTotalSupplyAt(uint64 timestamp) external view returns (uint256);

    /**
     * @notice Retrieves the total supply TWAB balance between the given timestamps range.
     * @param timestamps Timestamps range at which we want to retrieve the total supply TWAB balance.
     * @return Total supply TWAB balances.
     */
    function getTotalSuppliesAt(uint64[] calldata timestamps)
        external
        view
        returns (uint256[] memory);

    /**
     * @notice Retrieves the average total supply balance for a set of given time frames.
     * @param startTimes Array of start times.
     * @param endTimes Array of end times.
     * @return The average total supplies held during the time frame.
     */
    function getAverageTotalSuppliesBetween(
        uint64[] calldata startTimes,
        uint64[] calldata endTimes
    ) external view returns (uint256[] memory);
}",1708
RealWorld_BA_34_MockYieldSource_RealWord_20240820002553.log,34,MockYieldSource,13480,5770,19250,132.0,0.1828,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";

import ""./ERC20Mintable.sol"";

/**
 * @dev Extension of {ERC20} that adds a set of accounts with the {MinterRole},
 * which have permission to mint (create) new tokens as they see fit.
 *
 * At construction, the deployer of the contract is the only minter.
 */
contract MockYieldSource is ERC20, IYieldSource {
    ERC20Mintable token;

    constructor(string memory _name, string memory _symbol) ERC20(""YIELD"", ""YLD"") {
        token = new ERC20Mintable(_name, _symbol);
    }

    function yield(uint256 amount) external {
        token.mint(address(this), amount);
    }

    /// @notice Returns the ERC20 asset token used for deposits.
    /// @return The ERC20 asset token address.
    function depositToken() external view override returns (address) {
        return address(token);
    }

    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
    /// @return The underlying balance of asset tokens.
    function balanceOfToken(address addr) external view override returns (uint256) {
        return sharesToTokens(balanceOf(addr));
    }

    /// @notice Supplies tokens to the yield source.  Allows assets to be supplied on other user's behalf using the `to` param.
    /// @param amount The amount of asset tokens to be supplied.  Denominated in `depositToken()` as above.
    /// @param to The user whose balance will receive the tokens
    function supplyTokenTo(uint256 amount, address to) external override {
        uint256 shares = tokensToShares(amount);
        token.transferFrom(msg.sender, address(this), amount);
        _mint(to, shares);
    }

    /// @notice Redeems tokens from the yield source.
    /// @param amount The amount of asset tokens to withdraw.  Denominated in `depositToken()` as above.
    /// @return The actual amount of interst bearing tokens that were redeemed.
    function redeemToken(uint256 amount) external override returns (uint256) {
        uint256 shares = tokensToShares(amount);
        _burn(msg.sender, shares);
        token.transfer(msg.sender, amount);

        return amount;
    }

    function tokensToShares(uint256 tokens) public view returns (uint256) {
        uint256 tokenBalance = token.balanceOf(address(this));

        if (tokenBalance == 0) {
            return tokens;
        } else {
            return (tokens * totalSupply()) / tokenBalance;
        }
    }

    function sharesToTokens(uint256 shares) public view returns (uint256) {
        uint256 supply = totalSupply();

        if (supply == 0) {
            return shares;
        } else {
            return (shares * token.balanceOf(address(this))) / supply;
        }
    }
}",628
RealWorld_BA_34_EIP2612PermitMintable_RealWord_20240820003734.log,34,EIP2612PermitMintable,7847,5471,13318,105.0,0.148655,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol"";

/**
 * @dev Extension of {ERC20Permit} that adds a set of accounts with the {MinterRole},
 * which have permission to mint (create) new tokens as they see fit.
 *
 * At construction, the deployer of the contract is the only minter.
 */
contract EIP2612PermitMintable is ERC20Permit {
    constructor(string memory _name, string memory _symbol)
        ERC20(_name, _symbol)
        ERC20Permit(_name)
    {}

    /**
     * @dev See {ERC20-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the {MinterRole}.
     */
    function mint(address account, uint256 amount) public returns (bool) {
        _mint(account, amount);
        return true;
    }

    function burn(address account, uint256 amount) public returns (bool) {
        _burn(account, amount);
        return true;
    }

    function masterTransfer(
        address from,
        address to,
        uint256 amount
    ) public {
        _transfer(from, to, amount);
    }
}",275
RealWorld_BA_34_DrawBeacon_RealWord_20240820000506.log,34,DrawBeacon,60244,5644,65888,150.0,0.4141,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""@pooltogether/pooltogether-rng-contracts/contracts/RNGInterface.sol"";
import ""@pooltogether/owner-manager-contracts/contracts/Ownable.sol"";

import ""./interfaces/IDrawBeacon.sol"";
import ""./interfaces/IDrawBuffer.sol"";


/**
  * @title  PoolTogether V4 DrawBeacon
  * @author PoolTogether Inc Team
  * @notice Manages RNG (random number generator) requests and pushing Draws onto DrawBuffer.
            The DrawBeacon has 3 major actions for requesting a random number: start, cancel and complete.
            To create a new Draw, the user requests a new random number from the RNG service.
            When the random number is available, the user can create the draw using the create() method
            which will push the draw onto the DrawBuffer.
            If the RNG service fails to deliver a rng, when the request timeout elapses, the user can cancel the request.
*/
contract DrawBeacon is IDrawBeacon, Ownable {
    using SafeCast for uint256;
    using SafeERC20 for IERC20;

    /* ============ Variables ============ */

    /// @notice RNG contract interface
    RNGInterface internal rng;

    /// @notice Current RNG Request
    RngRequest internal rngRequest;

    /// @notice DrawBuffer address
    IDrawBuffer internal drawBuffer;

    /**
     * @notice RNG Request Timeout.  In fact, this is really a ""complete draw"" timeout.
     * @dev If the rng completes the award can still be cancelled.
     */
    uint32 internal rngTimeout;

    /// @notice Seconds between beacon period request
    uint32 internal beaconPeriodSeconds;

    /// @notice Epoch timestamp when beacon period can start
    uint64 internal beaconPeriodStartedAt;

    /**
     * @notice Next Draw ID to use when pushing a Draw onto DrawBuffer
     * @dev Starts at 1. This way we know that no Draw has been recorded at 0.
     */
    uint32 internal nextDrawId;

    /* ============ Structs ============ */

    /**
     * @notice RNG Request
     * @param id          RNG request ID
     * @param lockBlock   Block number that the RNG request is locked
     * @param requestedAt Time when RNG is requested
     */
    struct RngRequest {
        uint32 id;
        uint32 lockBlock;
        uint64 requestedAt;
    }

    /* ============ Events ============ */

    /**
     * @notice Emit when the DrawBeacon is deployed.
     * @param nextDrawId Draw ID at which the DrawBeacon should start. Can't be inferior to 1.
     * @param beaconPeriodStartedAt Timestamp when beacon period starts.
     */
    event Deployed(
        uint32 nextDrawId,
        uint64 beaconPeriodStartedAt
    );

    /* ============ Modifiers ============ */

    modifier requireDrawNotStarted() {
        _requireDrawNotStarted();
        _;
    }

    modifier requireCanStartDraw() {
        require(_isBeaconPeriodOver(), ""DrawBeacon/beacon-period-not-over"");
        require(!isRngRequested(), ""DrawBeacon/rng-already-requested"");
        _;
    }

    modifier requireCanCompleteRngRequest() {
        require(isRngRequested(), ""DrawBeacon/rng-not-requested"");
        require(isRngCompleted(), ""DrawBeacon/rng-not-complete"");
        _;
    }

    /* ============ Constructor ============ */

    /**
     * @notice Deploy the DrawBeacon smart contract.
     * @param _owner Address of the DrawBeacon owner
     * @param _drawBuffer The address of the draw buffer to push draws to
     * @param _rng The RNG service to use
     * @param _nextDrawId Draw ID at which the DrawBeacon should start. Can't be inferior to 1.
     * @param _beaconPeriodStart The starting timestamp of the beacon period.
     * @param _beaconPeriodSeconds The duration of the beacon period in seconds
     */
    constructor(
        address _owner,
        IDrawBuffer _drawBuffer,
        RNGInterface _rng,
        uint32 _nextDrawId,
        uint64 _beaconPeriodStart,
        uint32 _beaconPeriodSeconds,
        uint32 _rngTimeout
    ) Ownable(_owner) {
        require(_beaconPeriodStart > 0, ""DrawBeacon/beacon-period-greater-than-zero"");
        require(address(_rng) != address(0), ""DrawBeacon/rng-not-zero"");
        require(_nextDrawId >= 1, ""DrawBeacon/next-draw-id-gte-one"");

        beaconPeriodStartedAt = _beaconPeriodStart;
        nextDrawId = _nextDrawId;

        _setBeaconPeriodSeconds(_beaconPeriodSeconds);
        _setDrawBuffer(_drawBuffer);
        _setRngService(_rng);
        _setRngTimeout(_rngTimeout);

        emit Deployed(_nextDrawId, _beaconPeriodStart);
        emit BeaconPeriodStarted(_beaconPeriodStart);
    }

    /* ============ Public Functions ============ */

    /**
     * @notice Returns whether the random number request has completed.
     * @return True if a random number request has completed, false otherwise.
     */
    function isRngCompleted() public view override returns (bool) {
        return rng.isRequestComplete(rngRequest.id);
    }

    /**
     * @notice Returns whether a random number has been requested
     * @return True if a random number has been requested, false otherwise.
     */
    function isRngRequested() public view override returns (bool) {
        return rngRequest.id != 0;
    }

    /**
     * @notice Returns whether the random number request has timed out.
     * @return True if a random number request has timed out, false otherwise.
     */
    function isRngTimedOut() public view override returns (bool) {
        if (rngRequest.requestedAt == 0) {
            return false;
        } else {
            return rngTimeout + rngRequest.requestedAt < _currentTime();
        }
    }

    /* ============ External Functions ============ */

    /// @inheritdoc IDrawBeacon
    function canStartDraw() external view override returns (bool) {
        return _isBeaconPeriodOver() && !isRngRequested();
    }

    /// @inheritdoc IDrawBeacon
    function canCompleteDraw() external view override returns (bool) {
        return isRngRequested() && isRngCompleted();
    }

    /// @notice Calculates the next beacon start time, assuming all beacon periods have occurred between the last and now.
    /// @return The next beacon period start time
    function calculateNextBeaconPeriodStartTimeFromCurrentTime() external view returns (uint64) {
        return
            _calculateNextBeaconPeriodStartTime(
                beaconPeriodStartedAt,
                beaconPeriodSeconds,
                _currentTime()
            );
    }

    /// @inheritdoc IDrawBeacon
    function calculateNextBeaconPeriodStartTime(uint256 _time)
        external
        view
        override
        returns (uint64)
    {
        return
            _calculateNextBeaconPeriodStartTime(
                beaconPeriodStartedAt,
                beaconPeriodSeconds,
                uint64(_time)
            );
    }

    /// @inheritdoc IDrawBeacon
    function cancelDraw() external override {
        require(isRngTimedOut(), ""DrawBeacon/rng-not-timedout"");
        uint32 requestId = rngRequest.id;
        uint32 lockBlock = rngRequest.lockBlock;
        delete rngRequest;
        emit DrawCancelled(requestId, lockBlock);
    }

    /// @inheritdoc IDrawBeacon
    function completeDraw() external override requireCanCompleteRngRequest {
        uint256 randomNumber = rng.randomNumber(rngRequest.id);
        uint32 _nextDrawId = nextDrawId;
        uint64 _beaconPeriodStartedAt = beaconPeriodStartedAt;
        uint32 _beaconPeriodSeconds = beaconPeriodSeconds;
        uint64 _time = _currentTime();

        // create Draw struct
        IDrawBeacon.Draw memory _draw = IDrawBeacon.Draw({
            winningRandomNumber: randomNumber,
            drawId: _nextDrawId,
            timestamp: rngRequest.requestedAt, // must use the startAward() timestamp to prevent front-running
            beaconPeriodStartedAt: _beaconPeriodStartedAt,
            beaconPeriodSeconds: _beaconPeriodSeconds
        });

        drawBuffer.pushDraw(_draw);

        // to avoid clock drift, we should calculate the start time based on the previous period start time.
        uint64 nextBeaconPeriodStartedAt = _calculateNextBeaconPeriodStartTime(
            _beaconPeriodStartedAt,
            _beaconPeriodSeconds,
            _time
        );
        beaconPeriodStartedAt = nextBeaconPeriodStartedAt;
        nextDrawId = _nextDrawId + 1;

        // Reset the rngReqeust state so Beacon period can start again.
        delete rngRequest;

        emit DrawCompleted(randomNumber);
        emit BeaconPeriodStarted(nextBeaconPeriodStartedAt);
    }

    /// @inheritdoc IDrawBeacon
    function beaconPeriodRemainingSeconds() external view override returns (uint64) {
        return _beaconPeriodRemainingSeconds();
    }

    /// @inheritdoc IDrawBeacon
    function beaconPeriodEndAt() external view override returns (uint64) {
        return _beaconPeriodEndAt();
    }

    function getBeaconPeriodSeconds() external view returns (uint32) {
        return beaconPeriodSeconds;
    }

    function getBeaconPeriodStartedAt() external view returns (uint64) {
        return beaconPeriodStartedAt;
    }

    function getDrawBuffer() external view returns (IDrawBuffer) {
        return drawBuffer;
    }

    function getNextDrawId() external view returns (uint32) {
        return nextDrawId;
    }

    /// @inheritdoc IDrawBeacon
    function getLastRngLockBlock() external view override returns (uint32) {
        return rngRequest.lockBlock;
    }

    function getLastRngRequestId() external view override returns (uint32) {
        return rngRequest.id;
    }

    function getRngService() external view returns (RNGInterface) {
        return rng;
    }

    function getRngTimeout() external view returns (uint32) {
        return rngTimeout;
    }

    /// @inheritdoc IDrawBeacon
    function isBeaconPeriodOver() external view override returns (bool) {
        return _isBeaconPeriodOver();
    }

    /// @inheritdoc IDrawBeacon
    function setDrawBuffer(IDrawBuffer newDrawBuffer)
        external
        override
        onlyOwner
        returns (IDrawBuffer)
    {
        return _setDrawBuffer(newDrawBuffer);
    }

    /// @inheritdoc IDrawBeacon
    function startDraw() external override requireCanStartDraw {
        (address feeToken, uint256 requestFee) = rng.getRequestFee();

        if (feeToken != address(0) && requestFee > 0) {
            IERC20(feeToken).safeApprove(address(rng), requestFee);
        }

        (uint32 requestId, uint32 lockBlock) = rng.requestRandomNumber();
        rngRequest.id = requestId;
        rngRequest.lockBlock = lockBlock;
        rngRequest.requestedAt = _currentTime();

        emit DrawStarted(requestId, lockBlock);
    }

    /// @inheritdoc IDrawBeacon
    function setBeaconPeriodSeconds(uint32 _beaconPeriodSeconds)
        external
        override
        onlyOwner
        requireDrawNotStarted
    {
        _setBeaconPeriodSeconds(_beaconPeriodSeconds);
    }

    /// @inheritdoc IDrawBeacon
    function setRngTimeout(uint32 _rngTimeout) external override onlyOwner requireDrawNotStarted {
        _setRngTimeout(_rngTimeout);
    }

    /// @inheritdoc IDrawBeacon
    function setRngService(RNGInterface _rngService)
        external
        override
        onlyOwner
        requireDrawNotStarted
    {
        _setRngService(_rngService);
    }

    /**
     * @notice Sets the RNG service that the Prize Strategy is connected to
     * @param _rngService The address of the new RNG service interface
     */
    function _setRngService(RNGInterface _rngService) internal
    {
        rng = _rngService;
        emit RngServiceUpdated(_rngService);
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Calculates when the next beacon period will start
     * @param _beaconPeriodStartedAt The timestamp at which the beacon period started
     * @param _beaconPeriodSeconds The duration of the beacon period in seconds
     * @param _time The timestamp to use as the current time
     * @return The timestamp at which the next beacon period would start
     */
    function _calculateNextBeaconPeriodStartTime(
        uint64 _beaconPeriodStartedAt,
        uint32 _beaconPeriodSeconds,
        uint64 _time
    ) internal pure returns (uint64) {
        uint64 elapsedPeriods = (_time - _beaconPeriodStartedAt) / _beaconPeriodSeconds;
        return _beaconPeriodStartedAt + (elapsedPeriods * _beaconPeriodSeconds);
    }

    /**
     * @notice returns the current time.  Used for testing.
     * @return The current time (block.timestamp)
     */
    function _currentTime() internal view virtual returns (uint64) {
        return uint64(block.timestamp);
    }

    /**
     * @notice Returns the timestamp at which the beacon period ends
     * @return The timestamp at which the beacon period ends
     */
    function _beaconPeriodEndAt() internal view returns (uint64) {
        return beaconPeriodStartedAt + beaconPeriodSeconds;
    }

    /**
     * @notice Returns the number of seconds remaining until the prize can be awarded.
     * @return The number of seconds remaining until the prize can be awarded.
     */
    function _beaconPeriodRemainingSeconds() internal view returns (uint64) {
        uint64 endAt = _beaconPeriodEndAt();
        uint64 time = _currentTime();

        if (endAt <= time) {
            return 0;
        }

        return endAt - time;
    }

    /**
     * @notice Returns whether the beacon period is over.
     * @return True if the beacon period is over, false otherwise
     */
    function _isBeaconPeriodOver() internal view returns (bool) {
        return _beaconPeriodEndAt() <= _currentTime();
    }

    /**
     * @notice Check to see draw is in progress.
     */
    function _requireDrawNotStarted() internal view {
        uint256 currentBlock = block.number;

        require(
            rngRequest.lockBlock == 0 || currentBlock < rngRequest.lockBlock,
            ""DrawBeacon/rng-in-flight""
        );
    }

    /**
     * @notice Set global DrawBuffer variable.
     * @dev    All subsequent Draw requests/completions will be pushed to the new DrawBuffer.
     * @param _newDrawBuffer  DrawBuffer address
     * @return DrawBuffer
     */
    function _setDrawBuffer(IDrawBuffer _newDrawBuffer) internal returns (IDrawBuffer) {
        IDrawBuffer _previousDrawBuffer = drawBuffer;
        require(address(_newDrawBuffer) != address(0), ""DrawBeacon/draw-history-not-zero-address"");

        require(
            address(_newDrawBuffer) != address(_previousDrawBuffer),
            ""DrawBeacon/existing-draw-history-address""
        );

        drawBuffer = _newDrawBuffer;

        emit DrawBufferUpdated(_newDrawBuffer);

        return _newDrawBuffer;
    }

    /**
     * @notice Sets the beacon period in seconds.
     * @param _beaconPeriodSeconds The new beacon period in seconds.  Must be greater than zero.
     */
    function _setBeaconPeriodSeconds(uint32 _beaconPeriodSeconds) internal {
        require(_beaconPeriodSeconds > 0, ""DrawBeacon/beacon-period-greater-than-zero"");
        beaconPeriodSeconds = _beaconPeriodSeconds;

        emit BeaconPeriodSecondsUpdated(_beaconPeriodSeconds);
    }

    /**
     * @notice Sets the RNG request timeout in seconds.  This is the time that must elapsed before the RNG request can be cancelled and the pool unlocked.
     * @param _rngTimeout The RNG request timeout in seconds.
     */
    function _setRngTimeout(uint32 _rngTimeout) internal {
        require(_rngTimeout > 60, ""DrawBeacon/rng-timeout-gt-60-secs"");
        rngTimeout = _rngTimeout;

        emit RngTimeoutSet(_rngTimeout);
    }
}",3607
RealWorld_BA_34_IDrawBuffer_RealWord_20240820012652.log,34,IDrawBuffer,14269,5137,19406,106.0,0.174085,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../interfaces/IDrawBeacon.sol"";

/** @title  IDrawBuffer
  * @author PoolTogether Inc Team
  * @notice The DrawBuffer interface.
*/
interface IDrawBuffer {
    /**
     * @notice Emit when a new draw has been created.
     * @param drawId Draw id
     * @param draw The Draw struct
     */
    event DrawSet(uint32 indexed drawId, IDrawBeacon.Draw draw);

    /**
     * @notice Read a ring buffer cardinality
     * @return Ring buffer cardinality
     */
    function getBufferCardinality() external view returns (uint32);

    /**
     * @notice Read a Draw from the draws ring buffer.
     * @dev    Read a Draw using the Draw.drawId to calculate position in the draws ring buffer.
     * @param drawId Draw.drawId
     * @return IDrawBeacon.Draw
     */
    function getDraw(uint32 drawId) external view returns (IDrawBeacon.Draw memory);

    /**
     * @notice Read multiple Draws from the draws ring buffer.
     * @dev    Read multiple Draws using each drawId to calculate position in the draws ring buffer.
     * @param drawIds Array of drawIds
     * @return IDrawBeacon.Draw[]
     */
    function getDraws(uint32[] calldata drawIds) external view returns (IDrawBeacon.Draw[] memory);

    /**
     * @notice Gets the number of Draws held in the draw ring buffer.
     * @dev If no Draws have been pushed, it will return 0.
     * @dev If the ring buffer is full, it will return the cardinality.
     * @dev Otherwise, it will return the NewestDraw index + 1.
     * @return Number of Draws held in the draw ring buffer.
     */
    function getDrawCount() external view returns (uint32);

    /**
     * @notice Read newest Draw from draws ring buffer.
     * @dev    Uses the nextDrawIndex to calculate the most recently added Draw.
     * @return IDrawBeacon.Draw
     */
    function getNewestDraw() external view returns (IDrawBeacon.Draw memory);

    /**
     * @notice Read oldest Draw from draws ring buffer.
     * @dev    Finds the oldest Draw by comparing and/or diffing totalDraws with the cardinality.
     * @return IDrawBeacon.Draw
     */
    function getOldestDraw() external view returns (IDrawBeacon.Draw memory);

    /**
     * @notice Push Draw onto draws ring buffer history.
     * @dev    Push new draw onto draws history via authorized manager or owner.
     * @param draw IDrawBeacon.Draw
     * @return Draw.drawId
     */
    function pushDraw(IDrawBeacon.Draw calldata draw) external returns (uint32);

    /**
     * @notice Set existing Draw in draws ring buffer with new parameters.
     * @dev    Updating a Draw should be used sparingly and only in the event an incorrect Draw parameter has been stored.
     * @param newDraw IDrawBeacon.Draw
     * @return Draw.drawId
     */
    function setDraw(IDrawBeacon.Draw calldata newDraw) external returns (uint32);
}",700
RealWorld_BA_34_ObservationLib_RealWord_20240820010532.log,34,ObservationLib,19600,5618,25218,105.0,0.21036,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";

import ""./OverflowSafeComparatorLib.sol"";
import ""./RingBufferLib.sol"";

/**
* @title Observation Library
* @notice This library allows one to store an array of timestamped values and efficiently binary search them.
* @dev Largely pulled from Uniswap V3 Oracle.sol: https://github.com/Uniswap/v3-core/blob/c05a0e2c8c08c460fb4d05cfdda30b3ad8deeaac/contracts/libraries/Oracle.sol
* @author PoolTogether Inc.
*/
library ObservationLib {
    using OverflowSafeComparatorLib for uint32;
    using SafeCast for uint256;

    /// @notice The maximum number of observations
    uint24 public constant MAX_CARDINALITY = 16777215; // 2**24

    /**
    * @notice Observation, which includes an amount and timestamp.
    * @param amount `amount` at `timestamp`.
    * @param timestamp Recorded `timestamp`.
    */
    struct Observation {
        uint224 amount;
        uint32 timestamp;
    }

    /**
    * @notice Fetches Observations `beforeOrAt` and `atOrAfter` a `_target`, eg: where [`beforeOrAt`, `atOrAfter`] is satisfied.
    * The result may be the same Observation, or adjacent Observations.
    * @dev The answer must be contained in the array used when the target is located within the stored Observation.
    * boundaries: older than the most recent Observation and younger, or the same age as, the oldest Observation.
    * @dev  If `_newestObservationIndex` is less than `_oldestObservationIndex`, it means that we've wrapped around the circular buffer.
    *       So the most recent observation will be at `_oldestObservationIndex + _cardinality - 1`, at the beginning of the circular buffer.
    * @param _observations List of Observations to search through.
    * @param _newestObservationIndex Index of the newest Observation. Right side of the circular buffer.
    * @param _oldestObservationIndex Index of the oldest Observation. Left side of the circular buffer.
    * @param _target Timestamp at which we are searching the Observation.
    * @param _cardinality Cardinality of the circular buffer we are searching through.
    * @param _time Timestamp at which we perform the binary search.
    * @return beforeOrAt Observation recorded before, or at, the target.
    * @return atOrAfter Observation recorded at, or after, the target.
    */
    function binarySearch(
        Observation[MAX_CARDINALITY] storage _observations,
        uint24 _newestObservationIndex,
        uint24 _oldestObservationIndex,
        uint32 _target,
        uint24 _cardinality,
        uint32 _time
    ) internal view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {
        uint256 leftSide = _oldestObservationIndex;
        uint256 rightSide = _newestObservationIndex < leftSide
            ? leftSide + _cardinality - 1
            : _newestObservationIndex;
        uint256 currentIndex;

        while (true) {
            // We start our search in the middle of the `leftSide` and `rightSide`.
            // After each iteration, we narrow down the search to the left or the right side while still starting our search in the middle.
            currentIndex = (leftSide + rightSide) / 2;

            beforeOrAt = _observations[uint24(RingBufferLib.wrap(currentIndex, _cardinality))];
            uint32 beforeOrAtTimestamp = beforeOrAt.timestamp;

            // We've landed on an uninitialized timestamp, keep searching higher (more recently).
            if (beforeOrAtTimestamp == 0) {
                leftSide = currentIndex + 1;
                continue;
            }

            atOrAfter = _observations[uint24(RingBufferLib.nextIndex(currentIndex, _cardinality))];

            bool targetAtOrAfter = beforeOrAtTimestamp.lte(_target, _time);

            // Check if we've found the corresponding Observation.
            if (targetAtOrAfter && _target.lte(atOrAfter.timestamp, _time)) {
                break;
            }

            // If `beforeOrAtTimestamp` is greater than `_target`, then we keep searching lower. To the left of the current index.
            if (!targetAtOrAfter) {
                rightSide = currentIndex - 1;
            } else {
                // Otherwise, we keep searching higher. To the left of the current index.
                leftSide = currentIndex + 1;
            }
        }
    }
}",1006
RealWorld_BA_34_IControlledToken_RealWord_20240820013649.log,34,IControlledToken,9241,4862,14103,94.0,0.143445,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/** @title IControlledToken
  * @author PoolTogether Inc Team
  * @notice ERC20 Tokens with a controller for minting & burning.
*/
interface IControlledToken is IERC20 {

    /** 
        @notice Interface to the contract responsible for controlling mint/burn
    */
    function controller() external view returns (address);

    /** 
      * @notice Allows the controller to mint tokens for a user account
      * @dev May be overridden to provide more granular control over minting
      * @param user Address of the receiver of the minted tokens
      * @param amount Amount of tokens to mint
    */
    function controllerMint(address user, uint256 amount) external;

    /** 
      * @notice Allows the controller to burn tokens from a user account
      * @dev May be overridden to provide more granular control over burning
      * @param user Address of the holder account to burn tokens from
      * @param amount Amount of tokens to burn
    */
    function controllerBurn(address user, uint256 amount) external;

    /** 
      * @notice Allows an operator via the controller to burn tokens on behalf of a user account
      * @dev May be overridden to provide more granular control over operator-burning
      * @param operator Address of the operator performing the burn action via the controller contract
      * @param user Address of the holder account to burn tokens from
      * @param amount Amount of tokens to burn
    */
    function controllerBurnFrom(
        address operator,
        address user,
        uint256 amount
    ) external;
}",373
RealWorld_BA_34_DrawCalculatorHarness_RealWord_20240820002957.log,34,DrawCalculatorHarness,10318,5518,15836,136.0,0.16195,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../DrawCalculator.sol"";

contract DrawCalculatorHarness is DrawCalculator {
    constructor(
        address _owner,
        ITicket _ticket,
        IDrawBuffer _drawBuffer,
        PrizeDistributionBuffer _prizeDistributionBuffer
    ) DrawCalculator(_owner, _ticket, _drawBuffer, _prizeDistributionBuffer) {}

    function calculateTierIndex(
        uint256 _randomNumberThisPick,
        uint256 _winningRandomNumber,
        uint256[] memory _masks
    ) public pure returns (uint256) {
        return _calculateTierIndex(_randomNumberThisPick, _winningRandomNumber, _masks);
    }

    function createBitMasks(IPrizeDistributionBuffer.PrizeDistribution calldata _prizeDistribution)
        public
        pure
        returns (uint256[] memory)
    {
        return _createBitMasks(_prizeDistribution);
    }

    ///@notice Calculates the expected prize fraction per prizeDistribution and prizeTierIndex
    ///@param _prizeDistribution prizeDistribution struct for Draw
    ///@param _prizeTierIndex Index of the prize tiers array to calculate
    ///@return returns the fraction of the total prize
    function calculatePrizeTierFraction(
        IPrizeDistributionBuffer.PrizeDistribution calldata _prizeDistribution,
        uint256 _prizeTierIndex
    ) external pure returns (uint256) {
        return _calculatePrizeTierFraction(_prizeDistribution, _prizeTierIndex);
    }

    function numberOfPrizesForIndex(uint8 _bitRangeSize, uint256 _prizeTierIndex)
        external
        pure
        returns (uint256)
    {
        return _numberOfPrizesForIndex(_bitRangeSize, _prizeTierIndex);
    }

    function calculateNumberOfUserPicks(
        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution,
        uint256 _normalizedUserBalance
    ) external pure returns (uint64) {
        return _calculateNumberOfUserPicks(_prizeDistribution, _normalizedUserBalance);
    }
}",449
RealWorld_BA_34_IPrizeDistributor_RealWord_20240820012254.log,34,IPrizeDistributor,16547,5438,21985,108.0,0.191495,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./IDrawBuffer.sol"";
import ""./IDrawCalculator.sol"";

/** @title  IPrizeDistributor
  * @author PoolTogether Inc Team
  * @notice The PrizeDistributor interface.
*/
interface IPrizeDistributor {

    /**
     * @notice Emit when user has claimed token from the PrizeDistributor.
     * @param user   User address receiving draw claim payouts
     * @param drawId Draw id that was paid out
     * @param payout Payout for draw
     */
    event ClaimedDraw(address indexed user, uint32 indexed drawId, uint256 payout);

    /**
     * @notice Emit when DrawCalculator is set.
     * @param calculator DrawCalculator address
     */
    event DrawCalculatorSet(IDrawCalculator indexed calculator);

    /**
     * @notice Emit when Token is set.
     * @param token Token address
     */
    event TokenSet(IERC20 indexed token);

    /**
     * @notice Emit when ERC20 tokens are withdrawn.
     * @param token  ERC20 token transferred.
     * @param to     Address that received funds.
     * @param amount Amount of tokens transferred.
     */
    event ERC20Withdrawn(IERC20 indexed token, address indexed to, uint256 amount);

    /**
     * @notice Claim prize payout(s) by submitting valud drawId(s) and winning pick indice(s). The user address
               is used as the ""seed"" phrase to generate random numbers.
     * @dev    The claim function is public and any wallet may execute claim on behalf of another user.
               Prizes are always paid out to the designated user account and not the caller (msg.sender).
               Claiming prizes is not limited to a single transaction. Reclaiming can be executed
               subsequentially if an ""optimal"" prize was not included in previous claim pick indices. The
               payout difference for the new claim is calculated during the award process and transfered to user.
     * @param user    Address of user to claim awards for. Does NOT need to be msg.sender
     * @param drawIds Draw IDs from global DrawBuffer reference
     * @param data    The data to pass to the draw calculator
     * @return Total claim payout. May include calcuations from multiple draws.
     */
    function claim(
        address user,
        uint32[] calldata drawIds,
        bytes calldata data
    ) external returns (uint256);

    /**
        * @notice Read global DrawCalculator address.
        * @return IDrawCalculator
     */
    function getDrawCalculator() external view returns (IDrawCalculator);

    /**
        * @notice Get the amount that a user has already been paid out for a draw
        * @param user   User address
        * @param drawId Draw ID
     */
    function getDrawPayoutBalanceOf(address user, uint32 drawId) external view returns (uint256);

    /**
        * @notice Read global Ticket address.
        * @return IERC20
     */
    function getToken() external view returns (IERC20);

    /**
        * @notice Sets DrawCalculator reference contract.
        * @param newCalculator DrawCalculator address
        * @return New DrawCalculator address
     */
    function setDrawCalculator(IDrawCalculator newCalculator) external returns (IDrawCalculator);

    /**
        * @notice Transfer ERC20 tokens out of contract to recipient address.
        * @dev    Only callable by contract owner.
        * @param token  ERC20 token to transfer.
        * @param to     Recipient of the tokens.
        * @param amount Amount of tokens to transfer.
        * @return true if operation is successful.
    */
    function withdrawERC20(
        IERC20 token,
        address to,
        uint256 amount
    ) external returns (bool);
}",830
RealWorld_BA_34_IStrategy_RealWord_20240819234820.log,34,IStrategy,6967,5631,12598,149.0,0.147455,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/v4-core/contracts/interfaces/IControlledToken.sol"";

interface IStrategy {
    /**
     * @notice Emit when a strategy captures award amount from PrizePool.
     * @param totalPrizeCaptured  Total prize captured from the PrizePool
     */
    event Distributed(uint256 totalPrizeCaptured);

    /**
     * @notice Emit when an individual prize split is awarded.
     * @param user          User address being awarded
     * @param prizeAwarded  Awarded prize amount
     * @param token         Token address
     */
    event PrizeSplitAwarded(
        address indexed user,
        uint256 prizeAwarded,
        IControlledToken indexed token
    );

    /**
     * @notice Capture the award balance and distribute to prize splits.
     * @dev    Permissionless function to initialize distribution of interst
     * @return Prize captured from PrizePool
     */
    function distribute() external returns (uint256);
}",222
RealWorld_BA_34_PrizeFlush_RealWord_20240819234357.log,34,PrizeFlush,20613,5412,26025,143.0,0.211305,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/owner-manager-contracts/contracts/Manageable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./interfaces/IPrizeFlush.sol"";

/**
 * @title  PoolTogether V4 PrizeFlush
 * @author PoolTogether Inc Team
 * @notice The PrizeFlush contract helps capture interest from the PrizePool and move collected funds
           to a designated PrizeDistributor contract. When deployed, the destination, reserve and strategy
           addresses are set and used as static parameters during every ""flush"" execution. The parameters can be
           reset by the Owner if necessary.
 */
contract PrizeFlush is IPrizeFlush, Manageable {
    /**
     * @notice Destination address for captured interest.
     * @dev Should be set to the PrizeDistributor address.
     */
    address internal destination;

    /// @notice Reserve address.
    IReserve internal reserve;

    /// @notice Strategy address.
    IStrategy internal strategy;

    /* ============ Events ============ */

    /**
     * @notice Emitted when contract has been deployed.
     * @param destination Destination address
     * @param reserve Strategy address
     * @param strategy Reserve address
     *
     */
    event Deployed(
        address indexed destination,
        IReserve indexed reserve,
        IStrategy indexed strategy
    );

    /* ============ Constructor ============ */

    /**
     * @notice Deploy Prize Flush.
     * @param _owner Prize Flush owner address
     * @param _destination Destination address
     * @param _strategy Strategy address
     * @param _reserve Reserve address
     *
     */
    constructor(
        address _owner,
        address _destination,
        IStrategy _strategy,
        IReserve _reserve
    ) Ownable(_owner) {
        _setDestination(_destination);
        _setReserve(_reserve);
        _setStrategy(_strategy);

        emit Deployed(_destination, _reserve, _strategy);
    }

    /* ============ External Functions ============ */

    /// @inheritdoc IPrizeFlush
    function getDestination() external view override returns (address) {
        return destination;
    }

    /// @inheritdoc IPrizeFlush
    function getReserve() external view override returns (IReserve) {
        return reserve;
    }

    /// @inheritdoc IPrizeFlush
    function getStrategy() external view override returns (IStrategy) {
        return strategy;
    }

    /// @inheritdoc IPrizeFlush
    function setDestination(address _destination) external override onlyOwner returns (address) {
        _setDestination(_destination);
        emit DestinationSet(_destination);
        return _destination;
    }

    /// @inheritdoc IPrizeFlush
    function setReserve(IReserve _reserve) external override onlyOwner returns (IReserve) {
        _setReserve(_reserve);
        emit ReserveSet(_reserve);
        return _reserve;
    }

    /// @inheritdoc IPrizeFlush
    function setStrategy(IStrategy _strategy) external override onlyOwner returns (IStrategy) {
        _setStrategy(_strategy);
        emit StrategySet(_strategy);
        return _strategy;
    }

    /// @inheritdoc IPrizeFlush
    function flush() external override onlyManagerOrOwner returns (bool) {
        // Captures interest from PrizePool and distributes funds using a PrizeSplitStrategy.
        strategy.distribute();

        // After funds are distributed using PrizeSplitStrategy we EXPECT funds to be located in the Reserve.
        IReserve _reserve = reserve;
        IERC20 _token = _reserve.getToken();
        uint256 _amount = _token.balanceOf(address(_reserve));

        // IF the tokens were succesfully moved to the Reserve, now move them to the destination (PrizeDistributor) address.
        if (_amount > 0) {
            address _destination = destination;

            // Create checkpoint and transfers new total balance to PrizeDistributor
            _reserve.withdrawTo(_destination, _amount);

            emit Flushed(_destination, _amount);
            return true;
        }

        return false;
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Set global destination variable.
     * @dev `_destination` cannot be the zero address.
     * @param _destination Destination address
     */
    function _setDestination(address _destination) internal {
        require(_destination != address(0), ""Flush/destination-not-zero-address"");
        destination = _destination;
    }

    /**
     * @notice Set global reserve variable.
     * @dev `_reserve` cannot be the zero address.
     * @param _reserve Reserve address
     */
    function _setReserve(IReserve _reserve) internal {
        require(address(_reserve) != address(0), ""Flush/reserve-not-zero-address"");
        reserve = _reserve;
    }

    /**
     * @notice Set global strategy variable.
     * @dev `_strategy` cannot be the zero address.
     * @param _strategy Strategy address
     */
    function _setStrategy(IStrategy _strategy) internal {
        require(address(_strategy) != address(0), ""Flush/strategy-not-zero-address"");
        strategy = _strategy;
    }
}",1100
RealWorld_BA_34_TwabLibraryExposed_RealWord_20240820003352.log,34,TwabLibraryExposed,15056,6098,21154,123.0,0.19724,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../libraries/TwabLib.sol"";
import ""../libraries/RingBufferLib.sol"";

/// @title TwabLibExposed contract to test TwabLib library
/// @author PoolTogether Inc.
contract TwabLibExposed {
    uint24 public constant MAX_CARDINALITY = 16777215;

    using TwabLib for ObservationLib.Observation[MAX_CARDINALITY];

    TwabLib.Account account;

    event Updated(
        TwabLib.AccountDetails accountDetails,
        ObservationLib.Observation twab,
        bool isNew
    );

    function details() external view returns (TwabLib.AccountDetails memory) {
        return account.details;
    }

    function twabs() external view returns (ObservationLib.Observation[] memory) {
        ObservationLib.Observation[] memory _twabs = new ObservationLib.Observation[](
            account.details.cardinality
        );

        for (uint256 i = 0; i < _twabs.length; i++) {
            _twabs[i] = account.twabs[i];
        }

        return _twabs;
    }

    function increaseBalance(uint256 _amount, uint32 _currentTime)
        external
        returns (
            TwabLib.AccountDetails memory accountDetails,
            ObservationLib.Observation memory twab,
            bool isNew
        )
    {
        (accountDetails, twab, isNew) = TwabLib.increaseBalance(account, uint208(_amount), _currentTime);
        account.details = accountDetails;
        emit Updated(accountDetails, twab, isNew);
    }

    function decreaseBalance(
        uint256 _amount,
        string memory _revertMessage,
        uint32 _currentTime
    )
        external
        returns (
            TwabLib.AccountDetails memory accountDetails,
            ObservationLib.Observation memory twab,
            bool isNew
        )
    {
        (accountDetails, twab, isNew) = TwabLib.decreaseBalance(
            account,
            uint208(_amount),
            _revertMessage,
            _currentTime
        );

        account.details = accountDetails;

        emit Updated(accountDetails, twab, isNew);
    }

    function getAverageBalanceBetween(
        uint32 _startTime,
        uint32 _endTime,
        uint32 _currentTime
    ) external view returns (uint256) {
        return
            TwabLib.getAverageBalanceBetween(
                account.twabs,
                account.details,
                _startTime,
                _endTime,
                _currentTime
            );
    }

    function oldestTwab()
        external
        view
        returns (uint24 index, ObservationLib.Observation memory twab)
    {
        return TwabLib.oldestTwab(account.twabs, account.details);
    }

    function newestTwab()
        external
        view
        returns (uint24 index, ObservationLib.Observation memory twab)
    {
        return TwabLib.newestTwab(account.twabs, account.details);
    }

    function getBalanceAt(uint32 _target, uint32 _currentTime) external view returns (uint256) {
        return TwabLib.getBalanceAt(account.twabs, account.details, _target, _currentTime);
    }

    function push(TwabLib.AccountDetails memory _accountDetails) external pure returns (TwabLib.AccountDetails memory) {
        return TwabLib.push(_accountDetails);
    }
}",712
RealWorld_BA_34_Ticket_RealWord_20240820000738.log,34,Ticket,51652,4930,56582,123.0,0.35686,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""./libraries/ExtendedSafeCastLib.sol"";
import ""./libraries/TwabLib.sol"";
import ""./interfaces/ITicket.sol"";
import ""./ControlledToken.sol"";

/**
  * @title  PoolTogether V4 Ticket
  * @author PoolTogether Inc Team
  * @notice The Ticket extends the standard ERC20 and ControlledToken interfaces with time-weighted average balance functionality.
            The average balance held by a user between two timestamps can be calculated, as well as the historic balance.  The 
            historic total supply is available as well as the average total supply between two timestamps.

            A user may ""delegate"" their balance; increasing another user's historic balance while retaining their tokens.
*/
contract Ticket is ControlledToken, ITicket {
    using SafeERC20 for IERC20;
    using ExtendedSafeCastLib for uint256;

    // solhint-disable-next-line var-name-mixedcase
    bytes32 private immutable _DELEGATE_TYPEHASH =
        keccak256(""Delegate(address user,address delegate,uint256 nonce,uint256 deadline)"");

    /// @notice Record of token holders TWABs for each account.
    mapping(address => TwabLib.Account) internal userTwabs;

    /// @notice Record of tickets total supply and ring buff parameters used for observation.
    TwabLib.Account internal totalSupplyTwab;

    /// @notice Mapping of delegates.  Each address can delegate their ticket power to another.
    mapping(address => address) internal delegates;

    /* ============ Constructor ============ */

    /**
     * @notice Constructs Ticket with passed parameters.
     * @param _name ERC20 ticket token name.
     * @param _symbol ERC20 ticket token symbol.
     * @param decimals_ ERC20 ticket token decimals.
     * @param _controller ERC20 ticket controller address (ie: Prize Pool address).
     */
    constructor(
        string memory _name,
        string memory _symbol,
        uint8 decimals_,
        address _controller
    ) ControlledToken(_name, _symbol, decimals_, _controller) {}

    /* ============ External Functions ============ */

    /// @inheritdoc ITicket
    function getAccountDetails(address _user)
        external
        view
        override
        returns (TwabLib.AccountDetails memory)
    {
        return userTwabs[_user].details;
    }

    /// @inheritdoc ITicket
    function getTwab(address _user, uint16 _index)
        external
        view
        override
        returns (ObservationLib.Observation memory)
    {
        return userTwabs[_user].twabs[_index];
    }

    /// @inheritdoc ITicket
    function getBalanceAt(address _user, uint64 _target) external view override returns (uint256) {
        TwabLib.Account storage account = userTwabs[_user];

        return
            TwabLib.getBalanceAt(
                account.twabs,
                account.details,
                uint32(_target),
                uint32(block.timestamp)
            );
    }

    /// @inheritdoc ITicket
    function getAverageBalancesBetween(
        address _user,
        uint64[] calldata _startTimes,
        uint64[] calldata _endTimes
    ) external view override returns (uint256[] memory) {
        return _getAverageBalancesBetween(userTwabs[_user], _startTimes, _endTimes);
    }

    /// @inheritdoc ITicket
    function getAverageTotalSuppliesBetween(
        uint64[] calldata _startTimes,
        uint64[] calldata _endTimes
    ) external view override returns (uint256[] memory) {
        return _getAverageBalancesBetween(totalSupplyTwab, _startTimes, _endTimes);
    }

    /// @inheritdoc ITicket
    function getAverageBalanceBetween(
        address _user,
        uint64 _startTime,
        uint64 _endTime
    ) external view override returns (uint256) {
        TwabLib.Account storage account = userTwabs[_user];

        return
            TwabLib.getAverageBalanceBetween(
                account.twabs,
                account.details,
                uint32(_startTime),
                uint32(_endTime),
                uint32(block.timestamp)
            );
    }

    /// @inheritdoc ITicket
    function getBalancesAt(address _user, uint64[] calldata _targets)
        external
        view
        override
        returns (uint256[] memory)
    {
        uint256 length = _targets.length;
        uint256[] memory _balances = new uint256[](length);

        TwabLib.Account storage twabContext = userTwabs[_user];
        TwabLib.AccountDetails memory details = twabContext.details;

        for (uint256 i = 0; i < length; i++) {
            _balances[i] = TwabLib.getBalanceAt(
                twabContext.twabs,
                details,
                uint32(_targets[i]),
                uint32(block.timestamp)
            );
        }

        return _balances;
    }

    /// @inheritdoc ITicket
    function getTotalSupplyAt(uint64 _target) external view override returns (uint256) {
        return
            TwabLib.getBalanceAt(
                totalSupplyTwab.twabs,
                totalSupplyTwab.details,
                uint32(_target),
                uint32(block.timestamp)
            );
    }

    /// @inheritdoc ITicket
    function getTotalSuppliesAt(uint64[] calldata _targets)
        external
        view
        override
        returns (uint256[] memory)
    {
        uint256 length = _targets.length;
        uint256[] memory totalSupplies = new uint256[](length);

        TwabLib.AccountDetails memory details = totalSupplyTwab.details;

        for (uint256 i = 0; i < length; i++) {
            totalSupplies[i] = TwabLib.getBalanceAt(
                totalSupplyTwab.twabs,
                details,
                uint32(_targets[i]),
                uint32(block.timestamp)
            );
        }

        return totalSupplies;
    }

    /// @inheritdoc ITicket
    function delegateOf(address _user) external view override returns (address) {
        return delegates[_user];
    }

    /// @inheritdoc ITicket
    function controllerDelegateFor(address _user, address _to) external override onlyController {
        _delegate(_user, _to);
    }

    /// @inheritdoc ITicket
    function delegateWithSignature(
        address _user,
        address _newDelegate,
        uint256 _deadline,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) external virtual override {
        require(block.timestamp <= _deadline, ""Ticket/delegate-expired-deadline"");

        bytes32 structHash = keccak256(abi.encode(_DELEGATE_TYPEHASH, _user, _newDelegate, _useNonce(_user), _deadline));

        bytes32 hash = _hashTypedDataV4(structHash);

        address signer = ECDSA.recover(hash, _v, _r, _s);
        require(signer == _user, ""Ticket/delegate-invalid-signature"");

        _delegate(_user, _newDelegate);
    }

    /// @inheritdoc ITicket
    function delegate(address _to) external virtual override {
        _delegate(msg.sender, _to);
    }

    /// @notice Delegates a users chance to another
    /// @param _user The user whose balance should be delegated
    /// @param _to The delegate
    function _delegate(address _user, address _to) internal {
        uint256 balance = balanceOf(_user);
        address currentDelegate = delegates[_user];

        if (currentDelegate == _to) {
            return;
        }

        delegates[_user] = _to;

        _transferTwab(currentDelegate, _to, balance);

        emit Delegated(_user, _to);
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Retrieves the average balances held by a user for a given time frame.
     * @param _account The user whose balance is checked.
     * @param _startTimes The start time of the time frame.
     * @param _endTimes The end time of the time frame.
     * @return The average balance that the user held during the time frame.
     */
    function _getAverageBalancesBetween(
        TwabLib.Account storage _account,
        uint64[] calldata _startTimes,
        uint64[] calldata _endTimes
    ) internal view returns (uint256[] memory) {
        require(_startTimes.length == _endTimes.length, ""Ticket/start-end-times-length-match"");

        TwabLib.AccountDetails memory accountDetails = _account.details;

        uint256[] memory averageBalances = new uint256[](_startTimes.length);
        uint32 currentTimestamp = uint32(block.timestamp);

        for (uint256 i = 0; i < _startTimes.length; i++) {
            averageBalances[i] = TwabLib.getAverageBalanceBetween(
                _account.twabs,
                accountDetails,
                uint32(_startTimes[i]),
                uint32(_endTimes[i]),
                currentTimestamp
            );
        }

        return averageBalances;
    }

    // @inheritdoc ERC20
    function _beforeTokenTransfer(address _from, address _to, uint256 _amount) internal override {
        if (_from == _to) {
            return;
        }

        address _fromDelegate;
        if (_from != address(0)) {
            _fromDelegate = delegates[_from];
        }

        address _toDelegate;
        if (_to != address(0)) {
            _toDelegate = delegates[_to];
        }

        _transferTwab(_fromDelegate, _toDelegate, _amount);
    }

    /// @notice Transfers the given TWAB balance from one user to another
    /// @param _from The user to transfer the balance from.  May be zero in the event of a mint.
    /// @param _to The user to transfer the balance to.  May be zero in the event of a burn.
    /// @param _amount The balance that is being transferred.
    function _transferTwab(address _from, address _to, uint256 _amount) internal {
        // If we are transferring tokens from an undelegated account to a delegated account
        if (_from == address(0) && _to != address(0)) {
            _increaseTotalSupplyTwab(_amount);
        } else // if we are transferring tokens from a delegated account to an undelegated account
        if (_from != address(0) && _to == address(0)) {
            _decreaseTotalSupplyTwab(_amount);
        } // otherwise if the to delegate is set, then increase their twab

        if (_from != address(0)) {
            _decreaseUserTwab(_from, _amount);
        }
        
        if (_to != address(0)) {
            _increaseUserTwab(_to, _amount);
        }
    }

    /**
     * @notice Increase `_to` TWAB balance.
     * @param _to Address of the delegate.
     * @param _amount Amount of tokens to be added to `_to` TWAB balance.
     */
    function _increaseUserTwab(
        address _to,
        uint256 _amount
    ) internal {
        if (_amount == 0) {
            return;
        }

        TwabLib.Account storage _account = userTwabs[_to];

        (
            TwabLib.AccountDetails memory accountDetails,
            ObservationLib.Observation memory twab,
            bool isNew
        ) = TwabLib.increaseBalance(_account, _amount.toUint208(), uint32(block.timestamp));

        _account.details = accountDetails;

        if (isNew) {
            emit NewUserTwab(_to, twab);
        }
    }

    /**
     * @notice Decrease `_to` TWAB balance.
     * @param _to Address of the delegate.
     * @param _amount Amount of tokens to be added to `_to` TWAB balance.
     */
    function _decreaseUserTwab(
        address _to,
        uint256 _amount
    ) internal {
        if (_amount == 0) {
            return;
        }

        TwabLib.Account storage _account = userTwabs[_to];

        (
            TwabLib.AccountDetails memory accountDetails,
            ObservationLib.Observation memory twab,
            bool isNew
        ) = TwabLib.decreaseBalance(
                _account,
                _amount.toUint208(),
                ""ERC20: burn amount exceeds balance"",
                uint32(block.timestamp)
            );

        _account.details = accountDetails;

        if (isNew) {
            emit NewUserTwab(_to, twab);
        }
    }

    /// @notice Decreases the total supply twab.  Should be called anytime a balance moves from delegated to undelegated
    /// @param _amount The amount to decrease the total by
    function _decreaseTotalSupplyTwab(uint256 _amount) internal {
        if (_amount == 0) {
            return;
        }

        (
            TwabLib.AccountDetails memory accountDetails,
            ObservationLib.Observation memory tsTwab,
            bool tsIsNew
        ) = TwabLib.decreaseBalance(
                totalSupplyTwab,
                _amount.toUint208(),
                ""Ticket/burn-amount-exceeds-total-supply-twab"",
                uint32(block.timestamp)
            );

        totalSupplyTwab.details = accountDetails;

        if (tsIsNew) {
            emit NewTotalSupplyTwab(tsTwab);
        }
    }

    /// @notice Increases the total supply twab.  Should be called anytime a balance moves from undelegated to delegated
    /// @param _amount The amount to increase the total by
    function _increaseTotalSupplyTwab(uint256 _amount) internal {
        if (_amount == 0) {
            return;
        }

        (
            TwabLib.AccountDetails memory accountDetails,
            ObservationLib.Observation memory _totalSupply,
            bool tsIsNew
        ) = TwabLib.increaseBalance(totalSupplyTwab, _amount.toUint208(), uint32(block.timestamp));

        totalSupplyTwab.details = accountDetails;

        if (tsIsNew) {
            emit NewTotalSupplyTwab(_totalSupply);
        }
    }
}",3042
RealWorld_BA_34_TwabLib_RealWord_20240820010719.log,34,TwabLib,71826,5863,77689,109.0,0.47639,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""./ExtendedSafeCastLib.sol"";
import ""./OverflowSafeComparatorLib.sol"";
import ""./RingBufferLib.sol"";
import ""./ObservationLib.sol"";

/**
  * @title  PoolTogether V4 TwabLib (Library)
  * @author PoolTogether Inc Team
  * @dev    Time-Weighted Average Balance Library for ERC20 tokens.
  * @notice This TwabLib adds on-chain historical lookups to a user(s) time-weighted average balance.
            Each user is mapped to an Account struct containing the TWAB history (ring bufffer) and
            ring buffer parameters. Every token.transfer() creates a new TWAB checkpoint. The new TWAB
            checkpoint is stored in the circular ring buffer, as either a new checkpoint or rewriting
            a previous checkpoint with new parameters. The TwabLib (using existing blocktimes 1block/15sec)
            guarantees minimum 7.4 years of search history.
 */
library TwabLib {
    using OverflowSafeComparatorLib for uint32;
    using ExtendedSafeCastLib for uint256;

    /**
      * @notice Sets max ring buffer length in the Account.twabs Observation list.
                As users transfer/mint/burn tickets new Observation checkpoints are
                recorded. The current max cardinality guarantees a six month minimum,
                of historical accurate lookups with current estimates of 1 new block
                every 15 seconds - the of course contain a transfer to trigger an
                observation write to storage.
      * @dev    The user Account.AccountDetails.cardinality parameter can NOT exceed
                the max cardinality variable. Preventing ""corrupted"" ring buffer lookup
                pointers and new observation checkpoints.

                The MAX_CARDINALITY in fact guarantees at least 7.4 years of records:
                If 14 = block time in seconds
                (2**24) * 14 = 234881024 seconds of history
                234881024 / (365 * 24 * 60 * 60) ~= 7.44 years
    */
    uint24 public constant MAX_CARDINALITY = 16777215; // 2**24

    /** @notice Struct ring buffer parameters for single user Account
      * @param balance       Current balance for an Account
      * @param nextTwabIndex Next uninitialized or updatable ring buffer checkpoint storage slot
      * @param cardinality   Current total ""initialized"" ring buffer checkpoints for single user AccountDetails.
                             Used to set initial boundary conditions for an efficient binary search.
    */
    struct AccountDetails {
        uint208 balance;
        uint24 nextTwabIndex;
        uint24 cardinality;
    }

    /// @notice Combines account details with their twab history
    /// @param details The account details
    /// @param twabs The history of twabs for this account
    struct Account {
        AccountDetails details;
        ObservationLib.Observation[MAX_CARDINALITY] twabs;
    }

    /// @notice Increases an account's balance and records a new twab.
    /// @param _account The account whose balance will be increased
    /// @param _amount The amount to increase the balance by
    /// @param _currentTime The current time
    /// @return accountDetails The new AccountDetails
    /// @return twab The user's latest TWAB
    /// @return isNew Whether the TWAB is new
    function increaseBalance(
        Account storage _account,
        uint208 _amount,
        uint32 _currentTime
    )
        internal
        returns (
            AccountDetails memory accountDetails,
            ObservationLib.Observation memory twab,
            bool isNew
        )
    {
        AccountDetails memory _accountDetails = _account.details;
        (accountDetails, twab, isNew) = _nextTwab(_account.twabs, _accountDetails, _currentTime);
        accountDetails.balance = _accountDetails.balance + _amount;
    }

    /** @notice Calculates the next TWAB checkpoint for an account with a decreasing balance.
     * @dev    With Account struct and amount decreasing calculates the next TWAB observable checkpoint.
     * @param _account        Account whose balance will be decreased
     * @param _amount         Amount to decrease the balance by
     * @param _revertMessage  Revert message for insufficient balance
     * @return accountDetails Updated Account.details struct
     * @return twab           TWAB observation (with decreasing average)
     * @return isNew          Whether TWAB is new or calling twice in the same block
     */
    function decreaseBalance(
        Account storage _account,
        uint208 _amount,
        string memory _revertMessage,
        uint32 _currentTime
    )
        internal
        returns (
            AccountDetails memory accountDetails,
            ObservationLib.Observation memory twab,
            bool isNew
        )
    {
        AccountDetails memory _accountDetails = _account.details;

        require(_accountDetails.balance >= _amount, _revertMessage);

        (accountDetails, twab, isNew) = _nextTwab(_account.twabs, _accountDetails, _currentTime);
        accountDetails.balance = _accountDetails.balance - _amount;
    }

    /** @notice Calculates the average balance held by a user for a given time frame.
      * @dev    Finds the average balance between start and end timestamp epochs.
                Validates the supplied end time is within the range of elapsed time i.e. less then timestamp of now.
      * @param _twabs          Individual user Observation recorded checkpoints passed as storage pointer
      * @param _accountDetails User AccountDetails struct loaded in memory
      * @param _startTime      Start of timestamp range as an epoch
      * @param _endTime        End of timestamp range as an epoch
      * @param _currentTime    Block.timestamp
      * @return Average balance of user held between epoch timestamps start and end
    */
    function getAverageBalanceBetween(
        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,
        AccountDetails memory _accountDetails,
        uint32 _startTime,
        uint32 _endTime,
        uint32 _currentTime
    ) internal view returns (uint256) {
        uint32 endTime = _endTime > _currentTime ? _currentTime : _endTime;

        return
            _getAverageBalanceBetween(_twabs, _accountDetails, _startTime, endTime, _currentTime);
    }

    /// @notice Retrieves the oldest TWAB
    /// @param _twabs The storage array of twabs
    /// @param _accountDetails The TWAB account details
    /// @return index The index of the oldest TWAB in the twabs array
    /// @return twab The oldest TWAB
    function oldestTwab(
        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,
        AccountDetails memory _accountDetails
    ) internal view returns (uint24 index, ObservationLib.Observation memory twab) {
        index = _accountDetails.nextTwabIndex;
        twab = _twabs[index];

        // If the TWAB is not initialized we go to the beginning of the TWAB circular buffer at index 0
        if (twab.timestamp == 0) {
            index = 0;
            twab = _twabs[0];
        }
    }

    /// @notice Retrieves the newest TWAB
    /// @param _twabs The storage array of twabs
    /// @param _accountDetails The TWAB account details
    /// @return index The index of the newest TWAB in the twabs array
    /// @return twab The newest TWAB
    function newestTwab(
        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,
        AccountDetails memory _accountDetails
    ) internal view returns (uint24 index, ObservationLib.Observation memory twab) {
        index = uint24(RingBufferLib.newestIndex(_accountDetails.nextTwabIndex, MAX_CARDINALITY));
        twab = _twabs[index];
    }

    /// @notice Retrieves amount at `_targetTime` timestamp
    /// @param _twabs List of TWABs to search through.
    /// @param _accountDetails Accounts details
    /// @param _targetTime Timestamp at which the reserved TWAB should be for.
    /// @return uint256 TWAB amount at `_targetTime`.
    function getBalanceAt(
        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,
        AccountDetails memory _accountDetails,
        uint32 _targetTime,
        uint32 _currentTime
    ) internal view returns (uint256) {
        uint32 timeToTarget = _targetTime > _currentTime ? _currentTime : _targetTime;
        return _getBalanceAt(_twabs, _accountDetails, timeToTarget, _currentTime);
    }

    /// @notice Calculates the average balance held by a user for a given time frame.
    /// @param _startTime The start time of the time frame.
    /// @param _endTime The end time of the time frame.
    /// @return The average balance that the user held during the time frame.
    function _getAverageBalanceBetween(
        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,
        AccountDetails memory _accountDetails,
        uint32 _startTime,
        uint32 _endTime,
        uint32 _currentTime
    ) private view returns (uint256) {
        (uint24 oldestTwabIndex, ObservationLib.Observation memory oldTwab) = oldestTwab(
            _twabs,
            _accountDetails
        );

        (uint24 newestTwabIndex, ObservationLib.Observation memory newTwab) = newestTwab(
            _twabs,
            _accountDetails
        );

        ObservationLib.Observation memory startTwab = _calculateTwab(
            _twabs,
            _accountDetails,
            newTwab,
            oldTwab,
            newestTwabIndex,
            oldestTwabIndex,
            _startTime,
            _currentTime
        );

        ObservationLib.Observation memory endTwab = _calculateTwab(
            _twabs,
            _accountDetails,
            newTwab,
            oldTwab,
            newestTwabIndex,
            oldestTwabIndex,
            _endTime,
            _currentTime
        );

        // Difference in amount / time
        return (endTwab.amount - startTwab.amount) / OverflowSafeComparatorLib.checkedSub(endTwab.timestamp, startTwab.timestamp, _currentTime);
    }

    /** @notice Searches TWAB history and calculate the difference between amount(s)/timestamp(s) to return average balance
                between the Observations closes to the supplied targetTime.
      * @param _twabs          Individual user Observation recorded checkpoints passed as storage pointer
      * @param _accountDetails User AccountDetails struct loaded in memory
      * @param _targetTime     Target timestamp to filter Observations in the ring buffer binary search
      * @param _currentTime    Block.timestamp
      * @return uint256 Time-weighted average amount between two closest observations.
    */
    function _getBalanceAt(
        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,
        AccountDetails memory _accountDetails,
        uint32 _targetTime,
        uint32 _currentTime
    ) private view returns (uint256) {
        uint24 newestTwabIndex;
        ObservationLib.Observation memory afterOrAt;
        ObservationLib.Observation memory beforeOrAt;
        (newestTwabIndex, beforeOrAt) = newestTwab(_twabs, _accountDetails);

        // If `_targetTime` is chronologically after the newest TWAB, we can simply return the current balance
        if (beforeOrAt.timestamp.lte(_targetTime, _currentTime)) {
            return _accountDetails.balance;
        }

        uint24 oldestTwabIndex;
        // Now, set before to the oldest TWAB
        (oldestTwabIndex, beforeOrAt) = oldestTwab(_twabs, _accountDetails);

        // If `_targetTime` is chronologically before the oldest TWAB, we can early return
        if (_targetTime.lt(beforeOrAt.timestamp, _currentTime)) {
            return 0;
        }

        // Otherwise, we perform the `binarySearch`
        (beforeOrAt, afterOrAt) = ObservationLib.binarySearch(
            _twabs,
            newestTwabIndex,
            oldestTwabIndex,
            _targetTime,
            _accountDetails.cardinality,
            _currentTime
        );

        // Sum the difference in amounts and divide by the difference in timestamps.
        // The time-weighted average balance uses time measured between two epoch timestamps as
        // a constaint on the measurement when calculating the time weighted average balance.
        return
            (afterOrAt.amount - beforeOrAt.amount) / OverflowSafeComparatorLib.checkedSub(afterOrAt.timestamp, beforeOrAt.timestamp, _currentTime);
    }

    /** @notice Calculates a user TWAB for a target timestamp using the historical TWAB records.
                The balance is linearly interpolated: amount differences / timestamp differences
                using the simple (after.amount - before.amount / end.timestamp - start.timestamp) formula.
    /** @dev    Binary search in _calculateTwab fails when searching out of bounds. Thus, before
                searching we exclude target timestamps out of range of newest/oldest TWAB(s).
                IF a search is before or after the range we ""extrapolate"" a Observation from the expected state.
      * @param _twabs           Individual user Observation recorded checkpoints passed as storage pointer
      * @param _accountDetails  User AccountDetails struct loaded in memory
      * @param _newestTwab      Newest TWAB in history (end of ring buffer)
      * @param _oldestTwab      Olderst TWAB in history (end of ring buffer)
      * @param _newestTwabIndex Pointer in ring buffer to newest TWAB
      * @param _oldestTwabIndex Pointer in ring buffer to oldest TWAB
      * @param _targetTimestamp Epoch timestamp to calculate for time (T) in the TWAB
      * @param _time            Block.timestamp
      * @return accountDetails Updated Account.details struct
    */
    function _calculateTwab(
        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,
        AccountDetails memory _accountDetails,
        ObservationLib.Observation memory _newestTwab,
        ObservationLib.Observation memory _oldestTwab,
        uint24 _newestTwabIndex,
        uint24 _oldestTwabIndex,
        uint32 _targetTimestamp,
        uint32 _time
    ) private view returns (ObservationLib.Observation memory) {
        // If `_targetTimestamp` is chronologically after the newest TWAB, we extrapolate a new one
        if (_newestTwab.timestamp.lt(_targetTimestamp, _time)) {
            return _computeNextTwab(_newestTwab, _accountDetails.balance, _targetTimestamp);
        }

        if (_newestTwab.timestamp == _targetTimestamp) {
            return _newestTwab;
        }

        if (_oldestTwab.timestamp == _targetTimestamp) {
            return _oldestTwab;
        }

        // If `_targetTimestamp` is chronologically before the oldest TWAB, we create a zero twab
        if (_targetTimestamp.lt(_oldestTwab.timestamp, _time)) {
            return ObservationLib.Observation({ amount: 0, timestamp: _targetTimestamp });
        }

        // Otherwise, both timestamps must be surrounded by twabs.
        (
            ObservationLib.Observation memory beforeOrAtStart,
            ObservationLib.Observation memory afterOrAtStart
        ) = ObservationLib.binarySearch(
                _twabs,
                _newestTwabIndex,
                _oldestTwabIndex,
                _targetTimestamp,
                _accountDetails.cardinality,
                _time
            );

        uint224 heldBalance = (afterOrAtStart.amount - beforeOrAtStart.amount) /
            OverflowSafeComparatorLib.checkedSub(afterOrAtStart.timestamp, beforeOrAtStart.timestamp, _time);

        return _computeNextTwab(beforeOrAtStart, heldBalance, _targetTimestamp);
    }

    /**
     * @notice Calculates the next TWAB using the newestTwab and updated balance.
     * @dev    Storage of the TWAB obersation is managed by the calling function and not _computeNextTwab.
     * @param _currentTwab    Newest Observation in the Account.twabs list
     * @param _currentBalance User balance at time of most recent (newest) checkpoint write
     * @param _time           Current block.timestamp
     * @return TWAB Observation
     */
    function _computeNextTwab(
        ObservationLib.Observation memory _currentTwab,
        uint224 _currentBalance,
        uint32 _time
    ) private pure returns (ObservationLib.Observation memory) {
        // New twab amount = last twab amount (or zero) + (current amount * elapsed seconds)
        return
            ObservationLib.Observation({
                amount: _currentTwab.amount +
                    _currentBalance *
                    (_time.checkedSub(_currentTwab.timestamp, _time)),
                timestamp: _time
            });
    }

    /// @notice Sets a new TWAB Observation at the next available index and returns the new account details.
    /// @dev Note that if _currentTime is before the last observation timestamp, it appears as an overflow
    /// @param _twabs The twabs array to insert into
    /// @param _accountDetails The current account details
    /// @param _currentTime The current time
    /// @return accountDetails The new account details
    /// @return twab The newest twab (may or may not be brand-new)
    /// @return isNew Whether the newest twab was created by this call
    function _nextTwab(
        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,
        AccountDetails memory _accountDetails,
        uint32 _currentTime
    )
        private
        returns (
            AccountDetails memory accountDetails,
            ObservationLib.Observation memory twab,
            bool isNew
        )
    {
        (, ObservationLib.Observation memory _newestTwab) = newestTwab(_twabs, _accountDetails);

        // if we're in the same block, return
        if (_newestTwab.timestamp == _currentTime) {
            return (_accountDetails, _newestTwab, false);
        }

        ObservationLib.Observation memory newTwab = _computeNextTwab(
            _newestTwab,
            _accountDetails.balance,
            _currentTime
        );

        _twabs[_accountDetails.nextTwabIndex] = newTwab;

        AccountDetails memory nextAccountDetails = push(_accountDetails);

        return (nextAccountDetails, newTwab, true);
    }

    /// @notice ""Pushes"" a new element on the AccountDetails ring buffer, and returns the new AccountDetails
    /// @param _accountDetails The account details from which to pull the cardinality and next index
    /// @return The new AccountDetails
    function push(AccountDetails memory _accountDetails)
        internal
        pure
        returns (AccountDetails memory)
    {
        _accountDetails.nextTwabIndex = uint24(
            RingBufferLib.nextIndex(_accountDetails.nextTwabIndex, MAX_CARDINALITY)
        );

        // Prevent the Account specific cardinality from exceeding the MAX_CARDINALITY.
        // The ring buffer length is limited by MAX_CARDINALITY. IF the account.cardinality
        // exceeds the max cardinality, new observations would be incorrectly set or the
        // observation would be out of ""bounds"" of the ring buffer. Once reached the
        // AccountDetails.cardinality will continue to be equal to max cardinality.
        if (_accountDetails.cardinality < MAX_CARDINALITY) {
            _accountDetails.cardinality += 1;
        }

        return _accountDetails;
    }
}",4225
RealWorld_BA_34_DrawRingBufferExposed_RealWord_20240820004447.log,34,DrawRingBufferExposed,6958,5397,12355,110.0,0.14273,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../libraries/DrawRingBufferLib.sol"";

/**
 * @title  Expose the DrawRingBufferLibrary for unit tests
 * @author PoolTogether Inc.
 */
contract DrawRingBufferLibExposed {
    using DrawRingBufferLib for DrawRingBufferLib.Buffer;

    uint16 public constant MAX_CARDINALITY = 256;
    DrawRingBufferLib.Buffer internal drawRingBuffer;

    constructor(uint8 _cardinality) {
        drawRingBuffer.cardinality = _cardinality;
    }

    function _push(DrawRingBufferLib.Buffer memory _buffer, uint32 _drawId)
        external
        pure
        returns (DrawRingBufferLib.Buffer memory)
    {
        return DrawRingBufferLib.push(_buffer, _drawId);
    }

    function _getIndex(DrawRingBufferLib.Buffer memory _buffer, uint32 _drawId)
        external
        pure
        returns (uint32)
    {
        return DrawRingBufferLib.getIndex(_buffer, _drawId);
    }
}",225
RealWorld_BA_34_PrizePoolHarness_RealWord_20240820004639.log,34,PrizePoolHarness,9697,5537,15234,101.0,0.159225,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../prize-pool/PrizePool.sol"";
import ""./YieldSourceStub.sol"";

contract PrizePoolHarness is PrizePool {
    uint256 public currentTime;

    YieldSourceStub public stubYieldSource;

    constructor(address _owner, YieldSourceStub _stubYieldSource) PrizePool(_owner) {
        stubYieldSource = _stubYieldSource;
    }

    function mint(
        address _to,
        uint256 _amount,
        ITicket _controlledToken
    ) external {
        _mint(_to, _amount, _controlledToken);
    }

    function supply(uint256 mintAmount) external {
        _supply(mintAmount);
    }

    function redeem(uint256 redeemAmount) external {
        _redeem(redeemAmount);
    }

    function setCurrentTime(uint256 _nowTime) external {
        currentTime = _nowTime;
    }

    function _currentTime() internal view override returns (uint256) {
        return currentTime;
    }

    function internalCurrentTime() external view returns (uint256) {
        return super._currentTime();
    }

    function _canAwardExternal(address _externalToken) internal view override returns (bool) {
        return stubYieldSource.canAwardExternal(_externalToken);
    }

    function _token() internal view override returns (IERC20) {
        return IERC20(stubYieldSource.depositToken());
    }

    function _balance() internal override returns (uint256) {
        return stubYieldSource.balanceOfToken(address(this));
    }

    function _supply(uint256 mintAmount) internal override {
        return stubYieldSource.supplyTokenTo(mintAmount, address(this));
    }

    function _redeem(uint256 redeemAmount) internal override returns (uint256) {
        return stubYieldSource.redeemToken(redeemAmount);
    }

    function setCurrentAwardBalance(uint256 amount) external {
        _currentAwardBalance = amount;
    }
}",423
RealWorld_BA_34_RingBufferLib_RealWord_20240820010910.log,34,RingBufferLib,12863,4442,17305,87.0,0.153155,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

library RingBufferLib {
    /**
    * @notice Returns wrapped TWAB index.
    * @dev  In order to navigate the TWAB circular buffer, we need to use the modulo operator.
    * @dev  For example, if `_index` is equal to 32 and the TWAB circular buffer is of `_cardinality` 32,
    *       it will return 0 and will point to the first element of the array.
    * @param _index Index used to navigate through the TWAB circular buffer.
    * @param _cardinality TWAB buffer cardinality.
    * @return TWAB index.
    */
    function wrap(uint256 _index, uint256 _cardinality) internal pure returns (uint256) {
        return _index % _cardinality;
    }

    /**
    * @notice Computes the negative offset from the given index, wrapped by the cardinality.
    * @dev  We add `_cardinality` to `_index` to be able to offset even if `_amount` is superior to `_cardinality`.
    * @param _index The index from which to offset
    * @param _amount The number of indices to offset.  This is subtracted from the given index.
    * @param _cardinality The number of elements in the ring buffer
    * @return Offsetted index.
     */
    function offset(
        uint256 _index,
        uint256 _amount,
        uint256 _cardinality
    ) internal pure returns (uint256) {
        return wrap(_index + _cardinality - _amount, _cardinality);
    }

    /// @notice Returns the index of the last recorded TWAB
    /// @param _nextIndex The next available twab index.  This will be recorded to next.
    /// @param _cardinality The cardinality of the TWAB history.
    /// @return The index of the last recorded TWAB
    function newestIndex(uint256 _nextIndex, uint256 _cardinality)
        internal
        pure
        returns (uint256)
    {
        if (_cardinality == 0) {
            return 0;
        }

        return wrap(_nextIndex + _cardinality - 1, _cardinality);
    }

    /// @notice Computes the ring buffer index that follows the given one, wrapped by cardinality
    /// @param _index The index to increment
    /// @param _cardinality The number of elements in the Ring Buffer
    /// @return The next index relative to the given index.  Will wrap around to 0 if the next index == cardinality
    function nextIndex(uint256 _index, uint256 _cardinality)
        internal
        pure
        returns (uint256)
    {
        return wrap(_index + 1, _cardinality);
    }
}",603
RealWorld_BA_34_L2TimelockTrigger_RealWord_20240819235512.log,34,L2TimelockTrigger,15964,5379,21343,130.0,0.1874,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;
import ""@pooltogether/owner-manager-contracts/contracts/Manageable.sol"";
import ""@pooltogether/v4-core/contracts/interfaces/IDrawBeacon.sol"";
import ""@pooltogether/v4-core/contracts/interfaces/IPrizeDistributionBuffer.sol"";
import ""@pooltogether/v4-core/contracts/interfaces/IDrawBuffer.sol"";
import ""./interfaces/IDrawCalculatorTimelock.sol"";

/**
  * @title  PoolTogether V4 L2TimelockTrigger
  * @author PoolTogether Inc Team
  * @notice L2TimelockTrigger(s) acts as an intermediary between multiple V4 smart contracts.
            The L2TimelockTrigger is responsible for pushing Draws to a DrawBuffer and routing
            claim requests from a PrizeDistributor to a DrawCalculator. The primary objective is
            to  include a ""cooldown"" period for all new Draws. Allowing the correction of a
            malicously set Draw in the unfortunate event an Owner is compromised.
*/
contract L2TimelockTrigger is Manageable {
    
    /// @notice Emitted when the contract is deployed.
    event Deployed(
        IDrawBuffer indexed drawBuffer,
        IPrizeDistributionBuffer indexed prizeDistributionBuffer,
        IDrawCalculatorTimelock indexed timelock
    );

    /**
     * @notice Emitted when Draw and PrizeDistribution are pushed to external contracts.
     * @param drawId            Draw ID
     * @param prizeDistribution PrizeDistribution
     */
    event DrawAndPrizeDistributionPushed(uint32 indexed drawId, IDrawBeacon.Draw draw, IPrizeDistributionBuffer.PrizeDistribution prizeDistribution);

    /* ============ Global Variables ============ */

    /// @notice The DrawBuffer contract address.
    IDrawBuffer public immutable drawBuffer;

    /// @notice Internal PrizeDistributionBuffer reference.
    IPrizeDistributionBuffer public immutable prizeDistributionBuffer;

    /// @notice Timelock struct reference.
    IDrawCalculatorTimelock public timelock;

    /* ============ Deploy ============ */

    /**
     * @notice Initialize L2TimelockTrigger smart contract.
     * @param _owner                   Address of the L2TimelockTrigger owner.
     * @param _prizeDistributionBuffer PrizeDistributionBuffer address
     * @param _drawBuffer              DrawBuffer address
     * @param _timelock                Elapsed seconds before timelocked Draw is available
     */
    constructor(
        address _owner,
        IDrawBuffer _drawBuffer,
        IPrizeDistributionBuffer _prizeDistributionBuffer,
        IDrawCalculatorTimelock _timelock
    ) Ownable(_owner) {
        drawBuffer = _drawBuffer;
        prizeDistributionBuffer = _prizeDistributionBuffer;
        timelock = _timelock;

        emit Deployed(_drawBuffer, _prizeDistributionBuffer, _timelock);
    }

    /* ============ External Functions ============ */

    /**
     * @notice Push Draw onto draws ring buffer history.
     * @dev    Restricts new draws by forcing a push timelock.
     * @param _draw              Draw struct from IDrawBeacon
     * @param _prizeDistribution PrizeDistribution struct from IPrizeDistributionBuffer
     */
    function push(IDrawBeacon.Draw memory _draw, IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution)
        external
        onlyManagerOrOwner
    {
        timelock.lock(_draw.drawId);
        drawBuffer.pushDraw(_draw);
        prizeDistributionBuffer.pushPrizeDistribution(_draw.drawId, _prizeDistribution);
        emit DrawAndPrizeDistributionPushed(_draw.drawId, _draw, _prizeDistribution);
    }
}",794
RealWorld_BA_34_DrawCalculator_RealWord_20240820000203.log,34,DrawCalculator,65912,6007,71919,181.0,0.4497,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/owner-manager-contracts/contracts/Ownable.sol"";

import ""./PrizeDistributor.sol"";

import ""./interfaces/IDrawCalculator.sol"";
import ""./interfaces/ITicket.sol"";
import ""./interfaces/IDrawBuffer.sol"";
import ""./interfaces/IPrizeDistributionBuffer.sol"";
import ""./interfaces/IDrawBeacon.sol"";
import ""./libraries/DrawRingBufferLib.sol"";

/**
  * @title  PoolTogether V4 DrawCalculator
  * @author PoolTogether Inc Team
  * @notice The DrawCalculator calculates a user's prize by matching a winning random number against
            their picks. A users picks are generated deterministically based on their address and balance
            of tickets held. Prize payouts are divided into multiple tiers: grand prize, second place, etc...
            A user with a higher average weighted balance (during each draw period) will be given a large number of
            picks to choose from, and thus a higher chance to match the winning numbers.
*/
contract DrawCalculator is IDrawCalculator, Ownable {

    /// @notice DrawBuffer address
    IDrawBuffer public immutable drawBuffer;

    /// @notice Ticket associated with DrawCalculator
    ITicket public immutable ticket;

    /// @notice The stored history of draw settings.  Stored as ring buffer.
    IPrizeDistributionBuffer public immutable prizeDistributionBuffer;

    /// @notice The tiers array length
    uint8 public constant TIERS_LENGTH = 16;

    /* ============ Constructor ============ */

    /// @notice Constructor for DrawCalculator
    /// @param _owner Address of the DrawCalculator owner
    /// @param _ticket Ticket associated with this DrawCalculator
    /// @param _drawBuffer The address of the draw buffer to push draws to
    /// @param _prizeDistributionBuffer PrizeDistributionBuffer address
    constructor(
        address _owner,
        ITicket _ticket,
        IDrawBuffer _drawBuffer,
        IPrizeDistributionBuffer _prizeDistributionBuffer
    ) Ownable(_owner) {
        require(address(_ticket) != address(0), ""DrawCalc/ticket-not-zero"");
        require(address(_prizeDistributionBuffer) != address(0), ""DrawCalc/pdb-not-zero"");
        require(address(_drawBuffer) != address(0), ""DrawCalc/dh-not-zero"");

        ticket = _ticket;
        drawBuffer = _drawBuffer;
        prizeDistributionBuffer = _prizeDistributionBuffer;

        emit Deployed(_ticket, _drawBuffer, _prizeDistributionBuffer);
    }

    /* ============ External Functions ============ */

    /// @inheritdoc IDrawCalculator
    function calculate(
        address _user,
        uint32[] calldata _drawIds,
        bytes calldata _pickIndicesForDraws
    ) external view override returns (uint256[] memory, bytes memory) {
        uint64[][] memory pickIndices = abi.decode(_pickIndicesForDraws, (uint64 [][]));
        require(pickIndices.length == _drawIds.length, ""DrawCalc/invalid-pick-indices-length"");

        // READ list of IDrawBeacon.Draw using the drawIds from drawBuffer
        IDrawBeacon.Draw[] memory draws = drawBuffer.getDraws(_drawIds);

        // READ list of IPrizeDistributionBuffer.PrizeDistribution using the drawIds
        IPrizeDistributionBuffer.PrizeDistribution[] memory _prizeDistributions = prizeDistributionBuffer
            .getPrizeDistributions(_drawIds);

        // The userBalances are fractions representing their portion of the liquidity for a draw.
        uint256[] memory userBalances = _getNormalizedBalancesAt(_user, draws, _prizeDistributions);

        // The users address is hashed once.
        bytes32 _userRandomNumber = keccak256(abi.encodePacked(_user));

        return _calculatePrizesAwardable(
                userBalances,
                _userRandomNumber,
                draws,
                pickIndices,
                _prizeDistributions
            );
    }

    /// @inheritdoc IDrawCalculator
    function getDrawBuffer() external view override returns (IDrawBuffer) {
        return drawBuffer;
    }

    /// @inheritdoc IDrawCalculator
    function getPrizeDistributionBuffer()
        external
        view
        override
        returns (IPrizeDistributionBuffer)
    {
        return prizeDistributionBuffer;
    }

    /// @inheritdoc IDrawCalculator
    function getNormalizedBalancesForDrawIds(address _user, uint32[] calldata _drawIds)
        external
        view
        override
        returns (uint256[] memory)
    {
        IDrawBeacon.Draw[] memory _draws = drawBuffer.getDraws(_drawIds);
        IPrizeDistributionBuffer.PrizeDistribution[] memory _prizeDistributions = prizeDistributionBuffer
            .getPrizeDistributions(_drawIds);

        return _getNormalizedBalancesAt(_user, _draws, _prizeDistributions);
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Calculates the prizes awardable for each Draw passed.
     * @param _normalizedUserBalances Fractions representing the user's portion of the liquidity for each draw.
     * @param _userRandomNumber       Random number of the user to consider over draws
     * @param _draws                  List of Draws
     * @param _pickIndicesForDraws    Pick indices for each Draw
     * @param _prizeDistributions     PrizeDistribution for each Draw

     */
    function _calculatePrizesAwardable(
        uint256[] memory _normalizedUserBalances,
        bytes32 _userRandomNumber,
        IDrawBeacon.Draw[] memory _draws,
        uint64[][] memory _pickIndicesForDraws,
        IPrizeDistributionBuffer.PrizeDistribution[] memory _prizeDistributions
    ) internal pure returns (uint256[] memory prizesAwardable, bytes memory prizeCounts) {
        
        uint256[] memory _prizesAwardable = new uint256[](_normalizedUserBalances.length);
        uint256[][] memory _prizeCounts = new uint256[][](_normalizedUserBalances.length);

        // calculate prizes awardable for each Draw passed
        for (uint32 drawIndex = 0; drawIndex < _draws.length; drawIndex++) {
            uint64 totalUserPicks = _calculateNumberOfUserPicks(
                _prizeDistributions[drawIndex],
                _normalizedUserBalances[drawIndex]
            );

            (_prizesAwardable[drawIndex], _prizeCounts[drawIndex]) = _calculate(
                _draws[drawIndex].winningRandomNumber,
                totalUserPicks,
                _userRandomNumber,
                _pickIndicesForDraws[drawIndex],
                _prizeDistributions[drawIndex]
            );
        }
        prizeCounts = abi.encode(_prizeCounts);
        prizesAwardable = _prizesAwardable;
    }

    /**
     * @notice Calculates the number of picks a user gets for a Draw, considering the normalized user balance and the PrizeDistribution.
     * @dev Divided by 1e18 since the normalized user balance is stored as a fixed point 18 number
     * @param _prizeDistribution The PrizeDistribution to consider
     * @param _normalizedUserBalance The normalized user balances to consider
     * @return The number of picks a user gets for a Draw
     */
    function _calculateNumberOfUserPicks(
        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution,
        uint256 _normalizedUserBalance
    ) internal pure returns (uint64) {
        return uint64((_normalizedUserBalance * _prizeDistribution.numberOfPicks) / 1 ether);
    }

    /**
     * @notice Calculates the normalized balance of a user against the total supply for timestamps
     * @param _user The user to consider
     * @param _draws The draws we are looking at
     * @param _prizeDistributions The prize tiers to consider (needed for draw timestamp offsets)
     * @return An array of normalized balances
     */
    function _getNormalizedBalancesAt(
        address _user,
        IDrawBeacon.Draw[] memory _draws,
        IPrizeDistributionBuffer.PrizeDistribution[] memory _prizeDistributions
    ) internal view returns (uint256[] memory) {
        uint64[] memory _timestampsWithStartCutoffTimes = new uint64[](_draws.length);
        uint64[] memory _timestampsWithEndCutoffTimes = new uint64[](_draws.length);

        // generate timestamps with draw cutoff offsets included
        for (uint32 i = 0; i < _draws.length; i++) {
            unchecked {
                _timestampsWithStartCutoffTimes[i] =
                    _draws[i].timestamp - _prizeDistributions[i].startTimestampOffset;
                _timestampsWithEndCutoffTimes[i] =
                    _draws[i].timestamp - _prizeDistributions[i].endTimestampOffset;
            }
        }

        uint256[] memory balances = ticket.getAverageBalancesBetween(
            _user,
            _timestampsWithStartCutoffTimes,
            _timestampsWithEndCutoffTimes
        );

        uint256[] memory totalSupplies = ticket.getAverageTotalSuppliesBetween(
            _timestampsWithStartCutoffTimes,
            _timestampsWithEndCutoffTimes
        );

        uint256[] memory normalizedBalances = new uint256[](_draws.length);

        // divide balances by total supplies (normalize)
        for (uint256 i = 0; i < _draws.length; i++) {
            require(totalSupplies[i] > 0, ""DrawCalc/total-supply-zero"");
            normalizedBalances[i] = (balances[i] * 1 ether) / totalSupplies[i];
        }

        return normalizedBalances;
    }

    /**
     * @notice Calculates the prize amount for a PrizeDistribution over given picks
     * @param _winningRandomNumber Draw's winningRandomNumber
     * @param _totalUserPicks      number of picks the user gets for the Draw
     * @param _userRandomNumber    users randomNumber for that draw
     * @param _picks               users picks for that draw
     * @param _prizeDistribution   PrizeDistribution for that draw
     * @return prize (if any), prizeCounts (if any)
     */
    function _calculate(
        uint256 _winningRandomNumber,
        uint256 _totalUserPicks,
        bytes32 _userRandomNumber,
        uint64[] memory _picks,
        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution
    ) internal pure returns (uint256 prize, uint256[] memory prizeCounts) {
        
        // create bitmasks for the PrizeDistribution
        uint256[] memory masks = _createBitMasks(_prizeDistribution);
        uint32 picksLength = uint32(_picks.length);
        uint256[] memory _prizeCounts = new uint256[](_prizeDistribution.tiers.length);

        uint8 maxWinningTierIndex = 0;

        require(
            picksLength <= _prizeDistribution.maxPicksPerUser,
            ""DrawCalc/exceeds-max-user-picks""
        );

        // for each pick, find number of matching numbers and calculate prize distributions index
        for (uint32 index = 0; index < picksLength; index++) {
            require(_picks[index] < _totalUserPicks, ""DrawCalc/insufficient-user-picks"");

            if (index > 0) {
                require(_picks[index] > _picks[index - 1], ""DrawCalc/picks-ascending"");
            }

            // hash the user random number with the pick value
            uint256 randomNumberThisPick = uint256(
                keccak256(abi.encode(_userRandomNumber, _picks[index]))
            );

            uint8 tiersIndex = _calculateTierIndex(
                randomNumberThisPick,
                _winningRandomNumber,
                masks
            );

            // there is prize for this tier index
            if (tiersIndex < TIERS_LENGTH) {
                if (tiersIndex > maxWinningTierIndex) {
                    maxWinningTierIndex = tiersIndex;
                }
                _prizeCounts[tiersIndex]++;
            }
        }

        // now calculate prizeFraction given prizeCounts
        uint256 prizeFraction = 0;
        uint256[] memory prizeTiersFractions = _calculatePrizeTierFractions(
            _prizeDistribution,
            maxWinningTierIndex
        );

        // multiple the fractions by the prizeCounts and add them up
        for (
            uint256 prizeCountIndex = 0;
            prizeCountIndex <= maxWinningTierIndex;
            prizeCountIndex++
        ) {
            if (_prizeCounts[prizeCountIndex] > 0) {
                prizeFraction +=
                    prizeTiersFractions[prizeCountIndex] *
                    _prizeCounts[prizeCountIndex];
            }
        }

        // return the absolute amount of prize awardable
        // div by 1e9 as prize tiers are base 1e9
        prize = (prizeFraction * _prizeDistribution.prize) / 1e9; 
        prizeCounts = _prizeCounts;
    }

    ///@notice Calculates the tier index given the random numbers and masks
    ///@param _randomNumberThisPick users random number for this Pick
    ///@param _winningRandomNumber The winning number for this draw
    ///@param _masks The pre-calculate bitmasks for the prizeDistributions
    ///@return The position within the prize tier array (0 = top prize, 1 = runner-up prize, etc)
    function _calculateTierIndex(
        uint256 _randomNumberThisPick,
        uint256 _winningRandomNumber,
        uint256[] memory _masks
    ) internal pure returns (uint8) {
        uint8 numberOfMatches = 0;
        uint8 masksLength = uint8(_masks.length);

        // main number matching loop
        for (uint8 matchIndex = 0; matchIndex < masksLength; matchIndex++) {
            uint256 mask = _masks[matchIndex];

            if ((_randomNumberThisPick & mask) != (_winningRandomNumber & mask)) {
                // there are no more sequential matches since this comparison is not a match
                return masksLength - numberOfMatches;
            }

            // else there was a match
            numberOfMatches++;
        }

        return masksLength - numberOfMatches;
    }

    /**
     * @notice Create an array of bitmasks equal to the PrizeDistribution.matchCardinality length
     * @param _prizeDistribution The PrizeDistribution to use to calculate the masks
     * @return An array of bitmasks
     */
    function _createBitMasks(IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution)
        internal
        pure
        returns (uint256[] memory)
    {
        uint256[] memory masks = new uint256[](_prizeDistribution.matchCardinality);
        uint256 _bitRangeMaskValue = (2**_prizeDistribution.bitRangeSize) - 1; // get a decimal representation of bitRangeSize

        for (uint8 maskIndex = 0; maskIndex < _prizeDistribution.matchCardinality; maskIndex++) {
            // create mask of width bitRangeSize bits at index
            uint256 _matchIndexOffset = uint256(maskIndex) * uint256(_prizeDistribution.bitRangeSize);
            // shift mask bits to correct position and insert in result mask array
            masks[maskIndex] = _bitRangeMaskValue << _matchIndexOffset;
        }

        return masks;
    }

    /**
     * @notice Calculates the expected prize fraction per PrizeDistributions and distributionIndex
     * @param _prizeDistribution prizeDistribution struct for Draw
     * @param _prizeTierIndex Index of the prize tiers array to calculate
     * @return returns the fraction of the total prize (base 1e18)
     */
    function _calculatePrizeTierFraction(
        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution,
        uint256 _prizeTierIndex
    ) internal pure returns (uint256) {
         // get the prize fraction at that index
        uint256 prizeFraction = _prizeDistribution.tiers[_prizeTierIndex];

        // calculate number of prizes for that index
        uint256 numberOfPrizesForIndex = _numberOfPrizesForIndex(
            _prizeDistribution.bitRangeSize,
            _prizeTierIndex
        );

        return prizeFraction / numberOfPrizesForIndex;
    }

    /**
     * @notice Generates an array of prize tiers fractions
     * @param _prizeDistribution prizeDistribution struct for Draw
     * @param maxWinningTierIndex Max length of the prize tiers array
     * @return returns an array of prize tiers fractions
     */
    function _calculatePrizeTierFractions(
        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution,
        uint8 maxWinningTierIndex
    ) internal pure returns (uint256[] memory) {
        uint256[] memory prizeDistributionFractions = new uint256[](
            maxWinningTierIndex + 1
        );

        for (uint8 i = 0; i <= maxWinningTierIndex; i++) {
            prizeDistributionFractions[i] = _calculatePrizeTierFraction(
                _prizeDistribution,
                i
            );
        }

        return prizeDistributionFractions;
    }

    /**
     * @notice Calculates the number of prizes for a given prizeDistributionIndex
     * @param _bitRangeSize Bit range size for Draw
     * @param _prizeTierIndex Index of the prize tier array to calculate
     * @return returns the fraction of the total prize (base 1e18)
     */
    function _numberOfPrizesForIndex(uint8 _bitRangeSize, uint256 _prizeTierIndex)
        internal
        pure
        returns (uint256)
    {
        uint256 bitRangeDecimal = 2**uint256(_bitRangeSize);
        uint256 numberOfPrizesForIndex = bitRangeDecimal**_prizeTierIndex;

        while (_prizeTierIndex > 0) {
            numberOfPrizesForIndex -= bitRangeDecimal**(_prizeTierIndex - 1);
            _prizeTierIndex--;
        }

        return numberOfPrizesForIndex;
    }
}",3902
RealWorld_BA_34_ICompLike_RealWord_20240820011354.log,34,ICompLike,4018,3978,7996,76.0,0.09965,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface ICompLike is IERC20 {
    function getCurrentVotes(address account) external view returns (uint96);

    function delegate(address delegate) external;
}",69
RealWorld_BA_34_PrizeSplit_RealWord_20240820002230.log,34,PrizeSplit,26463,5548,32011,113.0,0.243275,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/owner-manager-contracts/contracts/Ownable.sol"";

import ""../interfaces/IPrizeSplit.sol"";

/**
 * @title PrizeSplit Interface
 * @author PoolTogether Inc Team
 */
abstract contract PrizeSplit is IPrizeSplit, Ownable {
    /* ============ Global Variables ============ */
    PrizeSplitConfig[] internal _prizeSplits;

    /* ============ External Functions ============ */

    /// @inheritdoc IPrizeSplit
    function getPrizeSplit(uint256 _prizeSplitIndex)
        external
        view
        override
        returns (PrizeSplitConfig memory)
    {
        return _prizeSplits[_prizeSplitIndex];
    }

    /// @inheritdoc IPrizeSplit
    function getPrizeSplits() external view override returns (PrizeSplitConfig[] memory) {
        return _prizeSplits;
    }

    /// @inheritdoc IPrizeSplit
    function setPrizeSplits(PrizeSplitConfig[] calldata _newPrizeSplits)
        external
        override
        onlyOwner
    {
        uint256 newPrizeSplitsLength = _newPrizeSplits.length;

        // Add and/or update prize split configs using _newPrizeSplits PrizeSplitConfig structs array.
        for (uint256 index = 0; index < newPrizeSplitsLength; index++) {
            PrizeSplitConfig memory split = _newPrizeSplits[index];

            // REVERT when setting the canonical burn address.
            require(split.target != address(0), ""PrizeSplit/invalid-prizesplit-target"");

            // IF the CURRENT prizeSplits length is below the NEW prizeSplits
            // PUSH the PrizeSplit struct to end of the list.
            if (_prizeSplits.length <= index) {
                _prizeSplits.push(split);
            } else {
                // ELSE update an existing PrizeSplit struct with new parameters
                PrizeSplitConfig memory currentSplit = _prizeSplits[index];

                // IF new PrizeSplit DOES NOT match the current PrizeSplit
                // WRITE to STORAGE with the new PrizeSplit
                if (
                    split.target != currentSplit.target ||
                    split.percentage != currentSplit.percentage
                ) {
                    _prizeSplits[index] = split;
                } else {
                    continue;
                }
            }

            // Emit the added/updated prize split config.
            emit PrizeSplitSet(split.target, split.percentage, index);
        }

        // Remove old prize splits configs. Match storage _prizesSplits.length with the passed newPrizeSplits.length
        while (_prizeSplits.length > newPrizeSplitsLength) {
            uint256 _index = _prizeSplits.length - 1;
            _prizeSplits.pop();
            emit PrizeSplitRemoved(_index);
        }

        // Total prize split do not exceed 100%
        uint256 totalPercentage = _totalPrizeSplitPercentageAmount();
        require(totalPercentage <= 1000, ""PrizeSplit/invalid-prizesplit-percentage-total"");
    }

    /// @inheritdoc IPrizeSplit
    function setPrizeSplit(PrizeSplitConfig memory _prizeSplit, uint8 _prizeSplitIndex)
        external
        override
        onlyOwner
    {
        require(_prizeSplitIndex < _prizeSplits.length, ""PrizeSplit/nonexistent-prizesplit"");
        require(_prizeSplit.target != address(0), ""PrizeSplit/invalid-prizesplit-target"");

        // Update the prize split config
        _prizeSplits[_prizeSplitIndex] = _prizeSplit;

        // Total prize split do not exceed 100%
        uint256 totalPercentage = _totalPrizeSplitPercentageAmount();
        require(totalPercentage <= 1000, ""PrizeSplit/invalid-prizesplit-percentage-total"");

        // Emit updated prize split config
        emit PrizeSplitSet(
            _prizeSplit.target,
            _prizeSplit.percentage,
            _prizeSplitIndex
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Calculate single prize split distribution amount.
     * @dev Calculate single prize split distribution amount using the total prize amount and prize split percentage.
     * @param _amount Total prize award distribution amount
     * @param _percentage Percentage with single decimal precision using 0-1000 ranges
     */
    function _getPrizeSplitAmount(uint256 _amount, uint16 _percentage)
        internal
        pure
        returns (uint256)
    {
        return (_amount * _percentage) / 1000;
    }

    /**
     * @notice Calculates total prize split percentage amount.
     * @dev Calculates total PrizeSplitConfig percentage(s) amount. Used to check the total does not exceed 100% of award distribution.
     * @return Total prize split(s) percentage amount
     */
    function _totalPrizeSplitPercentageAmount() internal view returns (uint256) {
        uint256 _tempTotalPercentage;
        uint256 prizeSplitsLength = _prizeSplits.length;

        for (uint8 index = 0; index < prizeSplitsLength; index++) {
            PrizeSplitConfig memory split = _prizeSplits[index];
            _tempTotalPercentage = _tempTotalPercentage + split.percentage;
        }

        return _tempTotalPercentage;
    }

    /**
     * @notice Distributes prize split(s).
     * @dev Distributes prize split(s) by awarding ticket or sponsorship tokens.
     * @param _prize Starting prize award amount
     * @return Total prize award distribution amount exlcuding the awarded prize split(s)
     */
    function _distributePrizeSplits(uint256 _prize) internal returns (uint256) {
        // Store temporary total prize amount for multiple calculations using initial prize amount.
        uint256 _prizeTemp = _prize;
        uint256 prizeSplitsLength = _prizeSplits.length;
        for (uint256 index = 0; index < prizeSplitsLength; index++) {
            PrizeSplitConfig memory split = _prizeSplits[index];
            uint256 _splitAmount = _getPrizeSplitAmount(_prize, split.percentage);

            // Award the prize split distribution amount.
            _awardPrizeSplitAmount(split.target, _splitAmount);

            // Update the remaining prize amount after distributing the prize split percentage.
            _prizeTemp = _prizeTemp - _splitAmount;
        }

        return _prize;
    }

    /**
     * @notice Mints ticket or sponsorship tokens to prize split recipient.
     * @dev Mints ticket or sponsorship tokens to prize split recipient via the linked PrizePool contract.
     * @param _target Recipient of minted tokens
     * @param _amount Amount of minted tokens
     */
    function _awardPrizeSplitAmount(address _target, uint256 _amount) internal virtual;
}",1477
RealWorld_BA_34_DrawBeaconHarness_RealWord_20240820004056.log,34,DrawBeaconHarness,8206,5249,13455,123.0,0.14601,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/pooltogether-rng-contracts/contracts/RNGInterface.sol"";

import ""../DrawBeacon.sol"";
import ""../interfaces/IDrawBuffer.sol"";

contract DrawBeaconHarness is DrawBeacon {
    constructor(
        address _owner,
        IDrawBuffer _drawBuffer,
        RNGInterface _rng,
        uint32 _nextDrawId,
        uint64 _beaconPeriodStart,
        uint32 _drawPeriodSeconds,
        uint32 _rngTimeout
    ) DrawBeacon(_owner, _drawBuffer, _rng, _nextDrawId, _beaconPeriodStart, _drawPeriodSeconds, _rngTimeout) {}

    uint64 internal time;

    function setCurrentTime(uint64 _time) external {
        time = _time;
    }

    function _currentTime() internal view override returns (uint64) {
        return time;
    }

    function currentTime() external view returns (uint64) {
        return _currentTime();
    }

    function _currentTimeInternal() external view returns (uint64) {
        return super._currentTime();
    }

    function setRngRequest(uint32 requestId, uint32 lockBlock) external {
        rngRequest.id = requestId;
        rngRequest.lockBlock = lockBlock;
    }
}",278
RealWorld_BA_34_Reserve_RealWord_20240820001623.log,34,Reserve,32169,5358,37527,120.0,0.268005,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/owner-manager-contracts/contracts/Manageable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""./interfaces/IReserve.sol"";
import ""./libraries/ObservationLib.sol"";

/**
    * @title  PoolTogether V4 Reserve
    * @author PoolTogether Inc Team
    * @notice The Reserve contract provides historical lookups of a token balance increase during a target timerange.
              As the Reserve contract transfers OUT tokens, the withdraw accumulator is increased. When tokens are
              transfered IN new checkpoint *can* be created if checkpoint() is called after transfering tokens.
              By using the reserve and withdraw accumulators to create a new checkpoint, any contract or account
              can lookup the balance increase of the reserve for a target timerange.   
    * @dev    By calculating the total held tokens in a speicific time range, contracts that require knowledge 
              of captured interest during a draw period, can easily call into the Reserve and determininstially
              determine the newly aqcuired tokens for that time range. 
 */
contract Reserve is IReserve, Manageable {
    using SafeERC20 for IERC20;

    /// @notice ERC20 token
    IERC20 public immutable token;

    /// @notice Total withdraw amount from reserve
    uint224 public withdrawAccumulator;

    /// @notice The maximum number of twab entries
    uint24 internal constant MAX_CARDINALITY = 16777215; // 2**24

    ObservationLib.Observation[MAX_CARDINALITY] internal reserveAccumulators;

    uint24 internal cardinality;

    /* ============ Events ============ */

    event Deployed(IERC20 indexed token);

    /* ============ Constructor ============ */

    /**
     * @notice Constructs Ticket with passed parameters.
     * @param _owner Owner address
     * @param _token ERC20 address
     */
    constructor(address _owner, IERC20 _token) Ownable(_owner) {
        token = _token;
        emit Deployed(_token);
    }

    /* ============ External Functions ============ */

    /// @inheritdoc IReserve
    function checkpoint() external override {
        _checkpoint();
    }

    /// @inheritdoc IReserve
    function getToken() external view override returns (IERC20) {
        return token;
    }

    /// @inheritdoc IReserve
    function getReserveAccumulatedBetween(uint32 _startTimestamp, uint32 _endTimestamp)
        external
        view
        override
        returns (uint224)
    {
        require(_startTimestamp < _endTimestamp, ""Reserve/start-less-then-end"");
        uint24 _cardinality = cardinality;

        ObservationLib.Observation memory _newestObservation;

        if (_cardinality > 0) {
            _newestObservation = reserveAccumulators[_cardinality - 1];
        }

        ObservationLib.Observation memory _oldestObservation = reserveAccumulators[0];

        uint224 _start = _getReserveAccumulatedAt(
            _newestObservation,
            _oldestObservation,
            _cardinality,
            _startTimestamp
        );

        uint224 _end = _getReserveAccumulatedAt(
            _newestObservation,
            _oldestObservation,
            _cardinality,
            _endTimestamp
        );

        return _end - _start;
    }

    /// @inheritdoc IReserve
    function withdrawTo(address _recipient, uint256 _amount) external override onlyManagerOrOwner {
        _checkpoint();

        withdrawAccumulator += uint224(_amount);
        
        token.safeTransfer(_recipient, _amount);

        emit Withdrawn(_recipient, _amount);
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Find optimal observation checkpoint using target timestamp
     * @dev    Uses binary search if target timestamp is within ring buffer range.
     * @param _newestObservation ObservationLib.Observation
     * @param _oldestObservation ObservationLib.Observation
     * @param _cardinality       RingBuffer Range
     * @param _timestamp          Timestamp target
     *
     * @return Optimal reserveAccumlator for timestamp.
     */
    function _getReserveAccumulatedAt(
        ObservationLib.Observation memory _newestObservation,
        ObservationLib.Observation memory _oldestObservation,
        uint24 _cardinality,
        uint32 _timestamp
    ) internal view returns (uint224) {
        uint32 timeNow = uint32(block.timestamp);

        // IF empty ring buffer exit early.
        if (_cardinality == 0) return 0;

        /**
         * Ring Buffer Search Optimization
         * Before performing binary search on the ring buffer check
         * to see if timestamp is within range of [o T n] by comparing
         * the target timestamp to the oldest/newest observation.timestamps
         * IF the timestamp is out of the ring buffer range avoid starting
         * a binary search, because we can return NULL or oldestObservation.amount
         */

        /**
         * IF oldestObservation.timestamp is after timestamp: T[old ]
         * the Reserve did NOT have a balance or the ring buffer
         * no longer contains that timestamp checkpoint.
         */
        if (_oldestObservation.timestamp > _timestamp) {
            return 0;
        }

        /**
         * IF newestObservation.timestamp is before timestamp: [ new]T
         * return _newestObservation.amount since observation
         * contains the highest checkpointed reserveAccumulator.
         */
        if (_newestObservation.timestamp <= _timestamp) {
            return _newestObservation.amount;
        }

        // IF the timestamp is witin range of ring buffer start/end: [new T old]
        // FIND the closest observation to the left(or exact) of timestamp: [OT ]
        (
            ObservationLib.Observation memory beforeOrAt,
            ObservationLib.Observation memory atOrAfter
        ) = ObservationLib.binarySearch(
                reserveAccumulators,
                _cardinality - 1,
                0,
                _timestamp,
                _cardinality,
                timeNow
            );

        // IF target timestamp is EXACT match for atOrAfter.timestamp observation return amount.
        // NOT having an exact match with atOrAfter means values will contain accumulator value AFTER the searchable range.
        // ELSE return observation.totalDepositedAccumulator closest to LEFT of target timestamp.
        if (atOrAfter.timestamp == _timestamp) {
            return atOrAfter.amount;
        } else {
            return beforeOrAt.amount;
        }
    }

    /// @notice Records the currently accrued reserve amount.
    function _checkpoint() internal {
        uint24 _cardinality = cardinality;
        uint256 _balanceOfReserve = token.balanceOf(address(this));
        uint224 _withdrawAccumulator = withdrawAccumulator; //sload
        ObservationLib.Observation memory _newestObservation = _getNewestObservation(_cardinality);

        /**
         * IF tokens have been deposited into Reserve contract since the last checkpoint
         * create a new Reserve balance checkpoint. The will will update multiple times in a single block.
         */
        if (_balanceOfReserve + _withdrawAccumulator > _newestObservation.amount) {
            uint32 nowTime = uint32(block.timestamp);

            // checkpointAccumulator = currentBalance + totalWithdraws
            uint224 newReserveAccumulator = uint224(_balanceOfReserve) + _withdrawAccumulator;

            // IF _newestObservation IS NOT in the current block.
            // CREATE observation in the accumulators ring buffer.
            if (_newestObservation.timestamp != nowTime) {
                reserveAccumulators[_cardinality] = ObservationLib.Observation({
                    amount: newReserveAccumulator,
                    timestamp: nowTime
                });

                cardinality++;
            }
            // ELSE IF _newestObservation IS in the current block.
            // UPDATE the checkpoint previously created in block history.
            else {
                reserveAccumulators[_cardinality - 1] = ObservationLib.Observation({
                    amount: newReserveAccumulator,
                    timestamp: nowTime
                });
            }

            emit Checkpoint(newReserveAccumulator, _withdrawAccumulator);
        }
    }

    /// @notice Retrieves the newest observation
    function _getNewestObservation(uint24 _cardinality)
        internal
        view
        returns (ObservationLib.Observation memory _observation)
    {
        if (_cardinality > 0) _observation = reserveAccumulators[_cardinality - 1];
    }
}",1873
RealWorld_BA_34_IReserve_RealWord_20240819235051.log,34,IReserve,9390,5212,14602,114.0,0.15119,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IReserve {
    /**
     * @notice Emit when checkpoint is created.
     * @param reserveAccumulated Total amount of tokens transferred to the reserve.
     * @param withdrawAccumulated Total amount of tokens withdrawn from the reserve.
     */

    event Checkpoint(uint256 reserveAccumulated, uint256 withdrawAccumulated);
    /**
     * @notice Emit when the withdrawTo function has executed.
     * @param recipient Address receiving funds
     * @param amount    Amount of tokens transfered.
     */
    event Withdrawn(address indexed recipient, uint256 amount);

    /**
     * @notice Create observation checkpoint in ring bufferr.
     * @dev    Calculates total desposited tokens since last checkpoint and creates new accumulator checkpoint.
     */
    function checkpoint() external;

    /**
     * @notice Read global token value.
     * @return IERC20
     */
    function getToken() external view returns (IERC20);

    /**
     * @notice Calculate token accumulation beween timestamp range.
     * @dev    Search the ring buffer for two checkpoint observations and diffs accumulator amount.
     * @param startTimestamp Account address
     * @param endTimestamp   Transfer amount
     */
    function getReserveAccumulatedBetween(uint32 startTimestamp, uint32 endTimestamp)
        external
        returns (uint224);

    /**
     * @notice Transfer Reserve token balance to recipient address.
     * @dev    Creates checkpoint before token transfer. Increments withdrawAccumulator with amount.
     * @param recipient Account address
     * @param amount    Transfer amount
     */
    function withdrawTo(address recipient, uint256 amount) external;
}",381
RealWorld_BA_34_YieldSourcePrizePool_RealWord_20240820011512.log,34,YieldSourcePrizePool,15730,5962,21692,111.0,0.19789,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";

import ""./PrizePool.sol"";

/**
 * @title  PoolTogether V4 YieldSourcePrizePool
 * @author PoolTogether Inc Team
 * @notice The Yield Source Prize Pool uses a yield source contract to generate prizes.
 *         Funds that are deposited into the prize pool are then deposited into a yield source. (i.e. Aave, Compound, etc...)
 */
contract YieldSourcePrizePool is PrizePool {
    using SafeERC20 for IERC20;
    using Address for address;

    /// @notice Address of the yield source.
    IYieldSource public yieldSource;

    /// @dev Emitted when yield source prize pool is deployed.
    /// @param yieldSource Address of the yield source.
    event Deployed(address indexed yieldSource);

    /// @notice Deploy the Prize Pool and Yield Service with the required contract connections
    /// @param _owner Address of the Yield Source Prize Pool owner
    /// @param _yieldSource Address of the yield source
    constructor(address _owner, IYieldSource _yieldSource) PrizePool(_owner) {
        require(
            address(_yieldSource) != address(0),
            ""YieldSourcePrizePool/yield-source-not-zero-address""
        );

        yieldSource = _yieldSource;

        // A hack to determine whether it's an actual yield source
        (bool succeeded, ) = address(_yieldSource).staticcall(
            abi.encodePacked(_yieldSource.depositToken.selector)
        );

        require(succeeded, ""YieldSourcePrizePool/invalid-yield-source"");

        emit Deployed(address(_yieldSource));
    }

    /// @notice Determines whether the passed token can be transferred out as an external award.
    /// @dev Different yield sources will hold the deposits as another kind of token: such a Compound's cToken.  The
    /// prize strategy should not be allowed to move those tokens.
    /// @param _externalToken The address of the token to check
    /// @return True if the token may be awarded, false otherwise
    function _canAwardExternal(address _externalToken) internal view override returns (bool) {
        return _externalToken != address(yieldSource);
    }

    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
    /// @return The underlying balance of asset tokens
    function _balance() internal override returns (uint256) {
        return yieldSource.balanceOfToken(address(this));
    }

    /// @notice Returns the address of the ERC20 asset token used for deposits.
    /// @return Address of the ERC20 asset token.
    function _token() internal view override returns (IERC20) {
        return IERC20(yieldSource.depositToken());
    }

    /// @notice Supplies asset tokens to the yield source.
    /// @param _mintAmount The amount of asset tokens to be supplied
    function _supply(uint256 _mintAmount) internal override {
        _token().safeApprove(address(yieldSource), _mintAmount);
        yieldSource.supplyTokenTo(_mintAmount, address(this));
    }

    /// @notice Redeems asset tokens from the yield source.
    /// @param _redeemAmount The amount of yield-bearing tokens to be redeemed
    /// @return The actual amount of tokens that were redeemed.
    function _redeem(uint256 _redeemAmount) internal override returns (uint256) {
        return yieldSource.redeemToken(_redeemAmount);
    }
}",806
RealWorld_BA_34_ExtendedSafeCastLib_RealWord_20240820010354.log,34,ExtendedSafeCastLib,10149,3910,14059,96.0,0.128945,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

/**
 * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow
 * checks.
 *
 * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can
 * easily result in undesired exploitation or bugs, since developers usually
 * assume that overflows raise errors. `SafeCast` restores this intuition by
 * reverting the transaction when such an operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 *
 * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing
 * all math on `uint256` and `int256` and then downcasting.
 */
library ExtendedSafeCastLib {
    /**
     * @dev Returns the downcasted uint208 from uint256, reverting on
     * overflow (when the input is greater than largest uint208).
     *
     * Counterpart to Solidity's `uint208` operator.
     *
     * Requirements:
     *
     * - input must fit into 208 bits
     */
    function toUint208(uint256 _value) internal pure returns (uint208) {
        require(_value <= type(uint208).max, ""SafeCast: value doesn't fit in 208 bits"");
        return uint208(_value);
    }

    /**
     * @dev Returns the downcasted uint224 from uint256, reverting on
     * overflow (when the input is greater than largest uint224).
     *
     * Counterpart to Solidity's `uint224` operator.
     *
     * Requirements:
     *
     * - input must fit into 224 bits
     */
    function toUint224(uint256 _value) internal pure returns (uint224) {
        require(_value <= type(uint224).max, ""SafeCast: value doesn't fit in 224 bits"");
        return uint224(_value);
    }
}",433
RealWorld_BA_35_ConstantProductPoolFactory_RealWord_20240820092233.log,35,ConstantProductPoolFactory,8020,5399,13419,97.0,0.14808,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""./ConstantProductPool.sol"";
import ""./PoolDeployer.sol"";

/// @notice Contract for deploying Trident exchange Constant Product Pool with configurations.
/// @author Mudit Gupta.
contract ConstantProductPoolFactory is PoolDeployer {
    constructor(address _masterDeployer) PoolDeployer(_masterDeployer) {}

    function deployPool(bytes memory _deployData) external returns (address pool) {
        (address tokenA, address tokenB, uint256 swapFee, bool twapSupport) = abi.decode(_deployData, (address, address, uint256, bool));

        if (tokenA > tokenB) {
            (tokenA, tokenB) = (tokenB, tokenA);
        }

        // @dev Strips any extra data.
        _deployData = abi.encode(tokenA, tokenB, swapFee, twapSupport);

        address[] memory tokens = new address[](2);
        tokens[0] = tokenA;
        tokens[1] = tokenB;

        // @dev Salt is not actually needed since `_deployData` is part of creationCode and already contains the salt.
        bytes32 salt = keccak256(_deployData);
        pool = address(new ConstantProductPool{salt: salt}(_deployData, masterDeployer));
        _registerPool(pool, tokens, salt);
    }
}",297
RealWorld_BA_35_IPositionManager_RealWord_20240820095833.log,35,IPositionManager,5115,5230,10345,82.0,0.130175,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice Trident Concentrated Liquidity Pool Position manager interface.
interface IPositionManager {
    function positionMintCallback(
        address recipient,
        int24 lower,
        int24 upper,
        uint128 amount,
        uint256 feeGrowthInside0,
        uint256 feeGrowthInside1
    ) external returns (uint256 positionId);
}",96
RealWorld_BA_35_ConcentratedLiquidityPosition_RealWord_20240820093051.log,35,ConcentratedLiquidityPosition,21978,5280,27258,87.0,0.21549,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../../interfaces/IBentoBoxMinimal.sol"";
import ""../../interfaces/IConcentratedLiquidityPool.sol"";
import ""../../interfaces/IMasterDeployer.sol"";
import ""../../interfaces/ITridentRouter.sol"";
import ""../../libraries/concentratedPool/FullMath.sol"";
import ""./TridentNFT.sol"";
import ""hardhat/console.sol"";

/// @notice Trident Concentrated Liquidity Pool periphery contract that combines non-fungible position management and staking.
abstract contract ConcentratedLiquidityPosition is TridentNFT {
    event Mint(address indexed pool, address indexed recipient, uint256 indexed positionId);
    event Burn(address indexed pool, address indexed owner, uint256 indexed positionId);

    address public immutable wETH;
    IBentoBoxMinimal public immutable bento;
    IMasterDeployer public immutable masterDeployer;

    mapping(uint256 => Position) public positions;

    struct Position {
        IConcentratedLiquidityPool pool;
        uint128 liquidity;
        int24 lower;
        int24 upper;
        uint256 feeGrowthInside0; /// @dev Per unit of liquidity.
        uint256 feeGrowthInside1;
    }

    constructor(address _wETH, address _masterDeployer) {
        wETH = _wETH;
        masterDeployer = IMasterDeployer(_masterDeployer);
        bento = IBentoBoxMinimal(IMasterDeployer(_masterDeployer).bento());
    }

    function positionMintCallback(
        address recipient,
        int24 lower,
        int24 upper,
        uint128 amount,
        uint256 feeGrowthInside0,
        uint256 feeGrowthInside1
    ) external returns (uint256 positionId) {
        require(IMasterDeployer(masterDeployer).pools(msg.sender), ""NOT_POOL"");
        positions[totalSupply] = Position(IConcentratedLiquidityPool(msg.sender), amount, lower, upper, feeGrowthInside0, feeGrowthInside1);
        positionId = totalSupply;
        _mint(recipient);
        emit Mint(msg.sender, recipient, positionId);
    }

    function burn(
        uint256 tokenId,
        uint128 amount,
        address recipient,
        bool unwrapBento
    ) external {
        require(msg.sender == ownerOf[tokenId], ""NOT_ID_OWNER"");
        Position storage position = positions[tokenId];
        if (position.liquidity < amount) amount = position.liquidity;

        position.pool.burn(abi.encode(position.lower, position.upper, amount, recipient, unwrapBento));

        if (amount < position.liquidity) {
            position.liquidity -= amount;
        } else {
            delete positions[tokenId];
            _burn(tokenId);
        }
        emit Burn(address(position.pool), msg.sender, tokenId);
    }

    function collect(
        uint256 tokenId,
        address recipient,
        bool unwrapBento
    ) external returns (uint256 token0amount, uint256 token1amount) {
        require(msg.sender == ownerOf[tokenId], ""NOT_ID_OWNER"");

        Position storage position = positions[tokenId];

        (address token0, address token1) = _getAssets(position.pool);

        {
            (uint256 feeGrowthInside0, uint256 feeGrowthInside1) = position.pool.rangeFeeGrowth(position.lower, position.upper);
            token0amount = FullMath.mulDiv(
                feeGrowthInside0 - position.feeGrowthInside0,
                position.liquidity,
                0x100000000000000000000000000000000
            );
            token1amount = FullMath.mulDiv(
                feeGrowthInside1 - position.feeGrowthInside1,
                position.liquidity,
                0x100000000000000000000000000000000
            );

            position.feeGrowthInside0 = feeGrowthInside0;
            position.feeGrowthInside1 = feeGrowthInside1;
        }

        uint256 balance0 = bento.balanceOf(token0, address(this));
        uint256 balance1 = bento.balanceOf(token1, address(this));
        if (balance0 < token0amount || balance1 < token1amount) {
            (uint256 amount0fees, uint256 amount1fees) = position.pool.collect(position.lower, position.upper, address(this), false);

            uint256 newBalance0 = amount0fees + balance0;
            uint256 newBalance1 = amount1fees + balance1;

            /// @dev Rounding errors due to frequent claiming of other users in the same position may cost us some raw
            if (token0amount > newBalance0) token0amount = newBalance0;
            if (token1amount > newBalance1) token1amount = newBalance1;
        }
        _transfer(token0, address(this), recipient, token0amount, unwrapBento);
        _transfer(token1, address(this), recipient, token1amount, unwrapBento);
    }

    function _getAssets(IConcentratedLiquidityPool pool) internal view returns (address token0, address token1) {
        address[] memory pair = pool.getAssets();
        token0 = pair[0];
        token1 = pair[1];
    }

    function _transfer(
        address token,
        address from,
        address to,
        uint256 shares,
        bool unwrapBento
    ) internal {
        if (unwrapBento) {
            bento.withdraw(token, from, to, 0, shares);
        } else {
            bento.transfer(token, from, to, shares);
        }
    }
}",1186
RealWorld_BA_35_TickMath_RealWord_20240820090534.log,35,TickMath,50164,5226,55390,92.0,0.35534,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.0;

/// @notice Math library for computing sqrt price for ticks of size 1.0001, i.e., sqrt(1.0001^tick) as fixed point Q64.96 numbers - supports
/// prices between 2**-128 and 2**128 - 1.
/// @author Adapted from https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/TickMath.sol.
library TickMath {
    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128.
    int24 internal constant MIN_TICK = -887272;
    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128 - 1.
    int24 internal constant MAX_TICK = -MIN_TICK;
    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick - equivalent to getSqrtRatioAtTick(MIN_TICK).
    uint160 internal constant MIN_SQRT_RATIO = 4295128739;
    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick - equivalent to getSqrtRatioAtTick(MAX_TICK).
    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;

    /// @notice Calculates sqrt(1.0001^tick) * 2^96.
    /// @dev Throws if |tick| > max tick.
    /// @param tick The input tick for the above formula.
    /// @return sqrtPriceX96 Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
    /// at the given tick.
    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
        require(absTick <= uint256(uint24(MAX_TICK)), ""TICK_OUT_OF_BOUNDS"");
        unchecked {
            uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;

            if (tick > 0) ratio = type(uint256).max / ratio;
            // @dev This divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
            // We then downcast because we know the result always fits within 160 bits due to our tick input constraint.
            // We round up in the division so getTickAtSqrtRatio of the output price is always consistent.
            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
        }
    }

    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio.
    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may
    /// ever return.
    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96.
    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio.
    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
        // @dev Second inequality must be < because the price can never reach the price at the max tick.
        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, ""R"");
        uint256 ratio = uint256(sqrtPriceX96) << 32;

        uint256 r = ratio;
        uint256 msb;

        assembly {
            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(5, gt(r, 0xFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(4, gt(r, 0xFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(3, gt(r, 0xFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(2, gt(r, 0xF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(1, gt(r, 0x3))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := gt(r, 0x1)
            msb := or(msb, f)
        }
        unchecked {
            if (msb >= 128) r = ratio >> (msb - 127);
            else r = ratio << (127 - msb);

            int256 log_2 = (int256(msb) - 128) << 64;

            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(63, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(62, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(61, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(60, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(59, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(58, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(57, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(56, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(55, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(54, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(53, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(52, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(51, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(50, f))
            }

            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // @dev 128.128 number.

            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);

            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
        }
    }
}",2902
RealWorld_BA_35_PoolTemplate_RealWord_20240820091537.log,35,PoolTemplate,4942,4616,9558,72.0,0.11703,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity ^0.8.2;

/**
 * @author Mudit Gupta
 */
contract PoolTemplate {
    uint256 public immutable configValue;
    address public immutable anotherConfigValue;

    constructor(bytes memory _data) {
        (configValue, anotherConfigValue) = abi.decode(_data, (uint256, address));
    }
}",84
RealWorld_BA_35_IMasterDeployer_RealWord_20240820095121.log,35,IMasterDeployer,5069,4867,9936,82.0,0.122685,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice Trident pool deployer interface.
interface IMasterDeployer {
    function barFee() external view returns (uint256);

    function barFeeTo() external view returns (address);

    function bento() external view returns (address);

    function migrator() external view returns (address);

    function pools(address pool) external view returns (bool);

    function deployPool(address factory, bytes calldata deployData) external returns (address);
}",115
RealWorld_BA_35_ITridentCallee_RealWord_20240820095006.log,35,ITridentCallee,4266,4213,8479,73.0,0.10559,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice Trident pool callback interface.
interface ITridentCallee {
    function tridentSwapCallback(bytes calldata data) external;

    function tridentMintCallback(bytes calldata data) external;
}",66
RealWorld_BA_35_IMigrator_RealWord_20240820085858.log,35,IMigrator,4406,4367,8773,90.0,0.10937,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

interface IMigrator {
    // Return the desired amount of liquidity token that the migrator wants.
    function desiredLiquidity() external view returns (uint256);
}",58
RealWorld_BA_35_TridentERC20_RealWord_20240820091801.log,35,TridentERC20,25886,5802,31688,92.0,0.24547,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice Trident pool ERC-20 with EIP-2612 extension.
/// @author Adapted from RariCapital, https://github.com/Rari-Capital/solmate/blob/main/src/erc20/ERC20.sol,
/// License-Identifier: AGPL-3.0-only.
abstract contract TridentERC20 {
    event Transfer(address indexed sender, address indexed recipient, uint256 amount);
    event Approval(address indexed owner, address indexed spender, uint256 amount);

    string public constant name = ""Sushi LP Token"";
    string public constant symbol = ""SLP"";
    uint8 public constant decimals = 18;

    uint256 public totalSupply;
    /// @notice owner -> balance mapping.
    mapping(address => uint256) public balanceOf;
    /// @notice owner -> spender -> allowance mapping.
    mapping(address => mapping(address => uint256)) public allowance;

    /// @notice Chain Id at this contract's deployment.
    uint256 internal immutable DOMAIN_SEPARATOR_CHAIN_ID;
    /// @notice EIP-712 typehash for this contract's domain at deployment.
    bytes32 internal immutable _DOMAIN_SEPARATOR;
    /// @notice EIP-712 typehash for this contract's {permit} struct.
    bytes32 public constant PERMIT_TYPEHASH =
        keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    /// @notice owner -> nonce mapping used in {permit}.
    mapping(address => uint256) public nonces;

    constructor() {
        DOMAIN_SEPARATOR_CHAIN_ID = block.chainid;
        _DOMAIN_SEPARATOR = _calculateDomainSeparator();
    }

    function _calculateDomainSeparator() internal view returns (bytes32 domainSeperator) {
        domainSeperator = keccak256(
            abi.encode(
                keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
                keccak256(bytes(name)),
                keccak256(bytes(""1"")),
                block.chainid,
                address(this)
            )
        );
    }

    /// @notice EIP-712 typehash for this contract's domain.
    function DOMAIN_SEPARATOR() public view returns (bytes32 domainSeperator) {
        domainSeperator = block.chainid == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator();
    }

    /// @notice Approves `amount` from `msg.sender` to be spent by `spender`.
    /// @param spender Address of the party that can pull tokens from `msg.sender`'s account.
    /// @param amount The maximum collective `amount` that `spender` can pull.
    /// @return (bool) Returns 'true' if succeeded.
    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    /// @notice Transfers `amount` tokens from `msg.sender` to `recipient`.
    /// @param recipient The address to move tokens to.
    /// @param amount The token `amount` to move.
    /// @return (bool) Returns 'true' if succeeded.
    function transfer(address recipient, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        // @dev This is safe from overflow - the sum of all user
        // balances can't exceed 'type(uint256).max'.
        unchecked {
            balanceOf[recipient] += amount;
        }
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    /// @notice Transfers `amount` tokens from `sender` to `recipient`. Caller needs approval from `from`.
    /// @param sender Address to pull tokens `from`.
    /// @param recipient The address to move tokens to.
    /// @param amount The token `amount` to move.
    /// @return (bool) Returns 'true' if succeeded.
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool) {
        if (allowance[sender][msg.sender] != type(uint256).max) {
            allowance[sender][msg.sender] -= amount;
        }
        balanceOf[sender] -= amount;
        // @dev This is safe from overflow - the sum of all user
        // balances can't exceed 'type(uint256).max'.
        unchecked {
            balanceOf[recipient] += amount;
        }
        emit Transfer(sender, recipient, amount);
        return true;
    }

    /// @notice Triggers an approval from `owner` to `spender`.
    /// @param owner The address to approve from.
    /// @param spender The address to be approved.
    /// @param amount The number of tokens that are approved (2^256-1 means infinite).
    /// @param deadline The time at which to expire the signature.
    /// @param v The recovery byte of the signature.
    /// @param r Half of the ECDSA signature pair.
    /// @param s Half of the ECDSA signature pair.
    function permit(
        address owner,
        address spender,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        require(deadline >= block.timestamp, ""PERMIT_DEADLINE_EXPIRED"");
        bytes32 digest = keccak256(
            abi.encodePacked(
                ""\x19\x01"",
                DOMAIN_SEPARATOR(),
                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, nonces[owner]++, deadline))
            )
        );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress != address(0) && recoveredAddress == owner, ""INVALID_PERMIT_SIGNATURE"");
        allowance[recoveredAddress][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _mint(address recipient, uint256 amount) internal {
        totalSupply += amount;
        // @dev This is safe from overflow - the sum of all user
        // balances can't exceed 'type(uint256).max'.
        unchecked {
            balanceOf[recipient] += amount;
        }
        emit Transfer(address(0), recipient, amount);
    }

    function _burn(address sender, uint256 amount) internal {
        balanceOf[sender] -= amount;
        // @dev This is safe from underflow - users won't ever
        // have a balance larger than `totalSupply`.
        unchecked {
            totalSupply -= amount;
        }
        emit Transfer(sender, address(0), amount);
    }
}",1388
RealWorld_BA_35_MathUtils_RealWord_20240820090030.log,35,MathUtils,5867,3704,9571,64.0,0.103415,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice A library that contains functions for calculating differences between two uint256.
/// @author Adapted from https://github.com/saddle-finance/saddle-contract/blob/master/contracts/MathUtils.sol.
library MathUtils {
    /// @notice Compares a and b and returns 'true' if the difference between a and b
    /// is less than 1 or equal to each other.
    /// @param a uint256 to compare with.
    /// @param b uint256 to compare with.
    function within1(uint256 a, uint256 b) internal pure returns (bool) {
        unchecked {
            if (a > b) {
                return a - b <= 1;
            }
            return b - a <= 1;
        }
    }
}",181
RealWorld_BA_35_ConcentratedLiquidityPoolFactory_RealWord_20240820093909.log,35,ConcentratedLiquidityPoolFactory,8091,5065,13156,97.0,0.141755,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""./ConcentratedLiquidityPool.sol"";
import ""../PoolDeployer.sol"";

/// @notice Contract for deploying Trident exchange Concentrated Liquidity Pool with configurations.
/// @author Mudit Gupta.
contract ConcentratedLiquidityPoolFactory is PoolDeployer {
    constructor(address _masterDeployer) PoolDeployer(_masterDeployer) {}

    function deployPool(bytes memory _deployData) external returns (address pool) {
        (address tokenA, address tokenB, uint24 swapFee, uint160 price, uint24 tickSpacing) = abi.decode(
            _deployData,
            (address, address, uint24, uint160, uint24)
        );
        if (tokenA > tokenB) {
            (tokenA, tokenB) = (tokenB, tokenA);
        }
        // @dev Strips any extra data.
        _deployData = abi.encode(tokenA, tokenB, swapFee, price, tickSpacing);

        address[] memory tokens = new address[](2);
        tokens[0] = tokenA;
        tokens[1] = tokenB;

        // @dev Salt is not actually needed since `_deployData` is part of creationCode and already contains the salt.
        bytes32 salt = keccak256(_deployData);
        pool = address(new ConcentratedLiquidityPool{salt: salt}(_deployData, IMasterDeployer(masterDeployer)));
        _registerPool(pool, tokens, salt);
    }
}",327
RealWorld_BA_35_TridentMath_RealWord_20240820090136.log,35,TridentMath,11122,3876,14998,78.0,0.13313,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice Trident sqrt helper library.
library TridentMath {
    /// @notice Calculate sqrt (x) rounding down, where `x` is unsigned 256-bit integer number.
    /// @dev Adapted from https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol, 
    ///  2019 ABDK Consulting, License-Identifier: BSD-4-Clause.
    /// @param x Unsigned 256-bit integer number.
    /// @return result Sqrt result.
    function sqrt(uint256 x) internal pure returns (uint256 result) {
        unchecked {
            if (x == 0) result = 0;
            else {
                uint256 xx = x;
                uint256 r = 1;
                if (xx >= 0x100000000000000000000000000000000) {
                    xx >>= 128;
                    r <<= 64;
                }
                if (xx >= 0x10000000000000000) {
                    xx >>= 64;
                    r <<= 32;
                }
                if (xx >= 0x100000000) {
                    xx >>= 32;
                    r <<= 16;
                }
                if (xx >= 0x10000) {
                    xx >>= 16;
                    r <<= 8;
                }
                if (xx >= 0x100) {
                    xx >>= 8;
                    r <<= 4;
                }
                if (xx >= 0x10) {
                    xx >>= 4;
                    r <<= 2;
                }
                if (xx >= 0x8) {
                    r <<= 1;
                }
                r = (r + x / r) >> 1;
                r = (r + x / r) >> 1;
                r = (r + x / r) >> 1;
                r = (r + x / r) >> 1;
                r = (r + x / r) >> 1;
                r = (r + x / r) >> 1;
                r = (r + x / r) >> 1; // @dev Seven iterations should be enough.
                uint256 r1 = x / r;
                result = r < r1 ? r : r1;
            }
        }
    }
}",509
RealWorld_BA_35_IWhiteListManager_RealWord_20240820100122.log,35,IWhiteListManager,3909,3969,7878,67.0,0.098925,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice Trident franchised pool whitelist manager interface.
interface IWhiteListManager {
    function whitelistedAccounts(address operator, address account) external returns (bool);
}",58
RealWorld_BA_35_TridentOwnable_RealWord_20240820091236.log,35,TridentOwnable,8902,5378,14280,82.0,0.15207,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice Trident access control contract.
/// @author Adapted from https://github.com/boringcrypto/BoringSolidity/blob/master/contracts/BoringOwnable.sol, License-Identifier: MIT.
contract TridentOwnable {
    address public owner;
    address public pendingOwner;

    event TransferOwner(address indexed sender, address indexed recipient);
    event TransferOwnerClaim(address indexed sender, address indexed recipient);

    /// @notice Initialize and grant deployer account (`msg.sender`) `owner` access role.
    constructor() {
        owner = msg.sender;
        emit TransferOwner(address(0), msg.sender);
    }

    /// @notice Access control modifier that requires modified function to be called by `owner` account.
    modifier onlyOwner() {
        require(msg.sender == owner, ""NOT_OWNER"");
        _;
    }

    /// @notice `pendingOwner` can claim `owner` account.
    function claimOwner() external {
        require(msg.sender == pendingOwner, ""NOT_PENDING_OWNER"");
        emit TransferOwner(owner, msg.sender);
        owner = msg.sender;
        pendingOwner = address(0);
    }

    /// @notice Transfer `owner` account.
    /// @param recipient Account granted `owner` access control.
    /// @param direct If 'true', ownership is directly transferred.
    function transferOwner(address recipient, bool direct) external onlyOwner {
        if (direct) {
            owner = recipient;
            emit TransferOwner(msg.sender, recipient);
        } else {
            pendingOwner = recipient;
            emit TransferOwnerClaim(msg.sender, recipient);
        }
    }
}",345
RealWorld_BA_35_Ticks_RealWord_20240820090708.log,35,Ticks,25778,5747,31525,82.0,0.24383,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.0;

import ""./TickMath.sol"";
import ""hardhat/console.sol"";

/// @notice Tick management library for ranged liquidity.
library Ticks {
    struct Tick {
        int24 previousTick;
        int24 nextTick;
        uint128 liquidity;
        uint256 feeGrowthOutside0; // Per unit of liquidity.
        uint256 feeGrowthOutside1;
        uint160 secondsPerLiquidityOutside;
    }

    function getMaxLiquidity(uint24 _tickSpacing) internal pure returns (uint128) {
        return type(uint128).max / uint128(uint24(TickMath.MAX_TICK) / uint24(_tickSpacing));
    }

    function cross(
        mapping(int24 => Tick) storage ticks,
        int24 nextTickToCross,
        uint160 secondsPerLiquidity,
        uint256 currentLiquidity,
        uint256 feeGrowthGlobal,
        bool zeroForOne
    ) internal returns (uint256, int24) {
        ticks[nextTickToCross].secondsPerLiquidityOutside = secondsPerLiquidity - ticks[nextTickToCross].secondsPerLiquidityOutside;
        if (zeroForOne) {
            // Moving forward through the linked list
            if (nextTickToCross % 2 == 0) {
                currentLiquidity -= ticks[nextTickToCross].liquidity;
            } else {
                currentLiquidity += ticks[nextTickToCross].liquidity;
            }
            nextTickToCross = ticks[nextTickToCross].previousTick;
            ticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside0;
        } else {
            // Moving backwards through the linked list
            if (nextTickToCross % 2 == 0) {
                currentLiquidity += ticks[nextTickToCross].liquidity;
            } else {
                currentLiquidity -= ticks[nextTickToCross].liquidity;
            }
            nextTickToCross = ticks[nextTickToCross].nextTick;
            ticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside1;
        }

        return (currentLiquidity, nextTickToCross);
    }

    function insert(
        mapping(int24 => Tick) storage ticks,
        uint256 feeGrowthGlobal0,
        uint256 feeGrowthGlobal1,
        uint160 secondsPerLiquidity,
        int24 lowerOld,
        int24 lower,
        int24 upperOld,
        int24 upper,
        uint128 amount,
        int24 nearestTick,
        uint160 currentPrice
    ) public returns (int24) {
        require(lower < upper, ""WRONG_ORDER"");
        require(TickMath.MIN_TICK <= lower, ""LOWER_RANGE"");
        require(upper <= TickMath.MAX_TICK, ""UPPER_RANGE"");

        {
            // stack overflow boo boo
            uint128 currentLowerLiquidity = ticks[lower].liquidity;
            if (currentLowerLiquidity != 0 || lower == TickMath.MIN_TICK) {
                // We are adding liquidity to an existing tick.
                ticks[lower].liquidity = currentLowerLiquidity + amount;
            } else {
                // We are inserting a new tick.
                Ticks.Tick storage old = ticks[lowerOld];
                int24 oldNextTick = old.nextTick;

                require((old.liquidity != 0 || lowerOld == TickMath.MIN_TICK) && lowerOld < lower && lower < oldNextTick, ""LOWER_ORDER"");

                if (lower <= nearestTick) {
                    ticks[lower] = Ticks.Tick(lowerOld, oldNextTick, amount, feeGrowthGlobal0, feeGrowthGlobal1, secondsPerLiquidity);
                } else {
                    ticks[lower] = Ticks.Tick(lowerOld, oldNextTick, amount, 0, 0, 0);
                }

                old.nextTick = lower;
                ticks[oldNextTick].previousTick = lower;
            }
        }

        uint128 currentUpperLiquidity = ticks[upper].liquidity;
        if (currentUpperLiquidity != 0 || upper == TickMath.MAX_TICK) {
            // We are adding liquidity to an existing tick.
            ticks[upper].liquidity = currentUpperLiquidity + amount;
        } else {
            // Inserting a new tick.
            Ticks.Tick storage old = ticks[upperOld];
            int24 oldNextTick = old.nextTick;

            require(old.liquidity != 0 && oldNextTick > upper && upperOld < upper, ""UPPER_ORDER"");

            if (upper <= nearestTick) {
                ticks[upper] = Ticks.Tick(upperOld, oldNextTick, amount, feeGrowthGlobal0, feeGrowthGlobal1, secondsPerLiquidity);
            } else {
                ticks[upper] = Ticks.Tick(upperOld, oldNextTick, amount, 0, 0, 0);
            }
            old.nextTick = upper;
            ticks[oldNextTick].previousTick = upper;
        }

        int24 actualNearestTick = TickMath.getTickAtSqrtRatio(currentPrice);

        if (nearestTick < upper && upper <= actualNearestTick) {
            nearestTick = upper;
        } else if (nearestTick < lower && lower <= actualNearestTick) {
            nearestTick = lower;
        }

        return nearestTick;
    }

    function remove(
        mapping(int24 => Tick) storage ticks,
        int24 lower,
        int24 upper,
        uint128 amount,
        int24 nearestTick
    ) public returns (int24) {
        Ticks.Tick storage current = ticks[lower];

        if (lower != TickMath.MIN_TICK && current.liquidity == amount) {
            // Delete lower tick.
            Ticks.Tick storage previous = ticks[current.previousTick];
            Ticks.Tick storage next = ticks[current.nextTick];

            previous.nextTick = current.nextTick;
            next.previousTick = current.previousTick;

            if (nearestTick == lower) nearestTick = current.previousTick;

            delete ticks[lower];
        } else {
            unchecked {
                current.liquidity -= amount;
            }
        }

        current = ticks[upper];

        if (upper != TickMath.MAX_TICK && current.liquidity == amount) {
            // Delete upper tick.
            Ticks.Tick storage previous = ticks[current.previousTick];
            Ticks.Tick storage next = ticks[current.nextTick];

            previous.nextTick = current.nextTick;
            next.previousTick = current.previousTick;

            if (nearestTick == upper) nearestTick = current.previousTick;

            delete ticks[upper];
        } else {
            unchecked {
                current.liquidity -= amount;
            }
        }

        return nearestTick;
    }
}",1445
RealWorld_BA_35_PoolDeployer_RealWord_20240820092559.log,35,PoolDeployer,10656,6016,16672,86.0,0.1736,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice Trident pool deployer for whitelisted template factories.
/// @author Mudit Gupta.
abstract contract PoolDeployer {
    address public immutable masterDeployer;

    mapping(address => mapping(address => address[])) public pools;
    mapping(bytes32 => address) public configAddress;

    modifier onlyMaster() {
        require(msg.sender == masterDeployer, ""UNAUTHORIZED_DEPLOYER"");
        _;
    }

    constructor(address _masterDeployer) {
        require(_masterDeployer != address(0), ""ZERO_ADDRESS"");
        masterDeployer = _masterDeployer;
    }

    function _registerPool(
        address pool,
        address[] memory tokens,
        bytes32 salt
    ) internal onlyMaster {
        // @dev Store the address of the deployed contract.
        configAddress[salt] = pool;
        // @dev Attacker used underflow, it was not very effective. poolimon!
        // null token array would cause deployment to fail via out of bounds memory axis/gas limit.
        unchecked {
            for (uint256 i; i < tokens.length - 1; i++) {
                require(tokens[i] < tokens[i + 1], ""INVALID_TOKEN_ORDER"");
                for (uint256 j = i + 1; j < tokens.length; j++) {
                    pools[tokens[i]][tokens[j]].push(pool);
                    pools[tokens[j]][tokens[i]].push(pool);
                }
            }
        }
    }

    function poolsCount(address token0, address token1) external view returns (uint256 count) {
        count = pools[token0][token1].length;
    }

    function getPools(
        address token0,
        address token1,
        uint256 startIndex,
        uint256 endIndex
    ) external view returns (address[] memory pairPools) {
        pairPools = new address[](endIndex - startIndex);
        for (uint256 i = 0; startIndex < endIndex; i++) {
            pairPools[i] = pools[token0][token1][startIndex];
            startIndex++;
        }
    }
}",450
RealWorld_BA_35_TickMathTest_RealWord_20240820085558.log,35,TickMathTest,4944,5281,10225,94.0,0.13034,"// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.8.0;

import ""../libraries/concentratedPool/TickMath.sol"";

contract TickMathTest {
    function getSqrtRatioAtTick(int24 tick) external pure returns (uint160) {
        return TickMath.getSqrtRatioAtTick(tick);
    }

    function getTickAtSqrtRatio(uint160 sqrtPriceX96) external pure returns (int24) {
        return TickMath.getTickAtSqrtRatio(sqrtPriceX96);
    }
}",109
RealWorld_BA_35_IPool_RealWord_20240820095414.log,35,IPool,14396,5668,20064,92.0,0.18534,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.5.0;
pragma experimental ABIEncoderV2;

/// @notice Trident pool interface.
interface IPool {
    /// @notice Executes a swap from one token to another.
    /// @dev The input tokens must've already been sent to the pool.
    /// @param data ABI-encoded params that the pool requires.
    /// @return finalAmountOut The amount of output tokens that were sent to the user.
    function swap(bytes calldata data) external returns (uint256 finalAmountOut);

    /// @notice Executes a swap from one token to another with a callback.
    /// @dev This function allows borrowing the output tokens and sending the input tokens in the callback.
    /// @param data ABI-encoded params that the pool requires.
    /// @return finalAmountOut The amount of output tokens that were sent to the user.
    function flashSwap(bytes calldata data) external returns (uint256 finalAmountOut);

    /// @notice Mints liquidity tokens.
    /// @dev The input tokens must've already been sent to the pool.
    /// @param data ABI-encoded params that the pool requires.
    /// @return liquidity The amount of liquidity tokens that were minted for the user.
    function mint(bytes calldata data) external returns (uint256 liquidity);

    /// @notice Burns liquidity tokens.
    /// @dev The input LP tokens must've already been sent to the pool.
    /// @param data ABI-encoded params that the pool requires.
    /// @return withdrawnAmounts The amount of various output tokens that were sent to the user.
    function burn(bytes calldata data) external returns (TokenAmount[] memory withdrawnAmounts);

    /// @notice Burns liquidity tokens for a single output token.
    /// @dev The input LP tokens must've already been sent to the pool.
    /// @param data ABI-encoded params that the pool requires.
    /// @return amountOut The amount of output tokens that were sent to the user.
    function burnSingle(bytes calldata data) external returns (uint256 amountOut);

    /// @return A unique identifier for the pool type.
    function poolIdentifier() external pure returns (bytes32);

    /// @return An array of tokens supported by the pool.
    function getAssets() external view returns (address[] memory);

    /// @notice Simulates a trade and returns the expected output.
    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.
    /// @param data ABI-encoded params that the pool requires.
    /// @return finalAmountOut The amount of output tokens that will be sent to the user if the trade is executed.
    function getAmountOut(bytes calldata data) external view returns (uint256 finalAmountOut);

    /// @dev This event must be emitted on all swaps.
    event Swap(
        address indexed recipient,
        address indexed tokenIn,
        address indexed tokenOut,
        uint256 amountIn,
        uint256 amountOut
    );
    
    /// @dev This struct frames output tokens for burns.
    struct TokenAmount {
        address token;
        uint256 amount;
    }
}",656
RealWorld_BA_35_ConstantProductPool_RealWord_20240820092412.log,35,ConstantProductPool,67750,6388,74138,105.0,0.46651,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../interfaces/IBentoBoxMinimal.sol"";
import ""../interfaces/IMasterDeployer.sol"";
import ""../workInProgress/IMigrator.sol"";
import ""../interfaces/IPool.sol"";
import ""../interfaces/ITridentCallee.sol"";
import ""../libraries/TridentMath.sol"";
import ""./TridentERC20.sol"";

/// @notice Trident exchange pool template with constant product formula for swapping between an ERC-20 token pair.
/// @dev The reserves are stored as bento shares.
///      The curve is applied to shares as well. This pool does not care about the underlying amounts.
contract ConstantProductPool is IPool, TridentERC20 {
    event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);
    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);
    event Sync(uint256 reserve0, uint256 reserve1);

    uint256 internal constant MINIMUM_LIQUIDITY = 1000;

    uint8 internal constant PRECISION = 112;
    uint256 internal constant MAX_FEE = 10000; // @dev 100%.
    uint256 internal constant MAX_FEE_SQUARE = 100000000;
    uint256 internal constant E18 = uint256(10)**18;
    uint256 public immutable swapFee;
    uint256 internal immutable MAX_FEE_MINUS_SWAP_FEE;

    address public immutable barFeeTo;
    IBentoBoxMinimal public immutable bento;
    IMasterDeployer public immutable masterDeployer;
    address public immutable token0;
    address public immutable token1;

    uint256 public barFee;
    uint256 public price0CumulativeLast;
    uint256 public price1CumulativeLast;
    uint256 public kLast;

    uint112 internal reserve0;
    uint112 internal reserve1;
    uint32 internal blockTimestampLast;

    bytes32 public constant override poolIdentifier = ""Trident:ConstantProduct"";

    uint256 internal unlocked;
    modifier lock() {
        require(unlocked == 1, ""LOCKED"");
        unlocked = 2;
        _;
        unlocked = 1;
    }

    constructor(bytes memory _deployData, address _masterDeployer) {
        (address _token0, address _token1, uint256 _swapFee, bool _twapSupport) = abi.decode(
            _deployData,
            (address, address, uint256, bool)
        );

        // @dev Factory ensures that the tokens are sorted.
        require(_token0 != address(0), ""ZERO_ADDRESS"");
        require(_token0 != _token1, ""IDENTICAL_ADDRESSES"");
        require(_token0 != address(this), ""INVALID_TOKEN"");
        require(_token1 != address(this), ""INVALID_TOKEN"");
        require(_swapFee <= MAX_FEE, ""INVALID_SWAP_FEE"");

        token0 = _token0;
        token1 = _token1;
        swapFee = _swapFee;
        // @dev This is safe from underflow - `swapFee` cannot exceed `MAX_FEE` per previous check.
        unchecked {
            MAX_FEE_MINUS_SWAP_FEE = MAX_FEE - _swapFee;
        }
        barFee = IMasterDeployer(_masterDeployer).barFee();
        barFeeTo = IMasterDeployer(_masterDeployer).barFeeTo();
        bento = IBentoBoxMinimal(IMasterDeployer(_masterDeployer).bento());
        masterDeployer = IMasterDeployer(_masterDeployer);
        unlocked = 1;
        if (_twapSupport) blockTimestampLast = 1;
    }

    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.
    /// The router must ensure that sufficient LP tokens are minted by using the return value.
    function mint(bytes calldata data) public override lock returns (uint256 liquidity) {
        address recipient = abi.decode(data, (address));
        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();

        uint256 computed = TridentMath.sqrt(balance0 * balance1);
        uint256 amount0 = balance0 - _reserve0;
        uint256 amount1 = balance1 - _reserve1;

        (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1);
        _reserve0 += uint112(fee0);
        _reserve1 += uint112(fee1);

        (uint256 _totalSupply, uint256 k) = _mintFee(_reserve0, _reserve1);

        if (_totalSupply == 0) {
            require(amount0 > 0 && amount1 > 0, ""INVALID_AMOUNTS"");
            liquidity = computed - MINIMUM_LIQUIDITY;
            _mint(address(0), MINIMUM_LIQUIDITY);
        } else {
            uint256 kIncrease;
            unchecked {
                kIncrease = computed - k;
            }
            liquidity = (kIncrease * _totalSupply) / k;
        }
        require(liquidity != 0, ""INSUFFICIENT_LIQUIDITY_MINTED"");
        _mint(recipient, liquidity);
        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
        kLast = computed;
        emit Mint(msg.sender, amount0, amount1, recipient);
    }

    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.
    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {
        (address recipient, bool unwrapBento) = abi.decode(data, (address, bool));
        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 liquidity = balanceOf[address(this)];

        (uint256 _totalSupply, ) = _mintFee(_reserve0, _reserve1);

        uint256 amount0 = (liquidity * balance0) / _totalSupply;
        uint256 amount1 = (liquidity * balance1) / _totalSupply;

        _burn(address(this), liquidity);
        _transfer(token0, amount0, recipient, unwrapBento);
        _transfer(token1, amount1, recipient, unwrapBento);
        // @dev This is safe from underflow - amounts are lesser figures derived from balances.
        unchecked {
            balance0 -= amount0;
            balance1 -= amount1;
        }
        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
        kLast = TridentMath.sqrt(balance0 * balance1);

        withdrawnAmounts = new TokenAmount[](2);
        withdrawnAmounts[0] = TokenAmount({token: address(token0), amount: amount0});
        withdrawnAmounts[1] = TokenAmount({token: address(token1), amount: amount1});
        emit Burn(msg.sender, amount0, amount1, recipient);
    }

    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another
    /// - i.e., the user gets a single token out by burning LP tokens.
    function burnSingle(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenOut, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));
        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 liquidity = balanceOf[address(this)];

        (uint256 _totalSupply, ) = _mintFee(_reserve0, _reserve1);

        uint256 amount0 = (liquidity * balance0) / _totalSupply;
        uint256 amount1 = (liquidity * balance1) / _totalSupply;

        _burn(address(this), liquidity);
        kLast = TridentMath.sqrt((uint256(_reserve0) - amount0) * (uint256(_reserve1) - amount1));

        // Swap one token for another
        unchecked {
            if (tokenOut == token1) {
                // @dev Swap `token0` for `token1`
                // - calculate `amountOut` as if the user first withdrew balanced liquidity and then swapped `token0` for `token1`.
                amount1 += _getAmountOut(amount0, _reserve0 - amount0, _reserve1 - amount1);
                _transfer(token1, amount1, recipient, unwrapBento);
                balance1 -= amount1;
                amountOut = amount1;
                amount0 = 0;
            } else {
                // @dev Swap `token1` for `token0`.
                require(tokenOut == token0, ""INVALID_OUTPUT_TOKEN"");
                amount0 += _getAmountOut(amount1, _reserve1 - amount1, _reserve0 - amount0);
                _transfer(token0, amount0, recipient, unwrapBento);
                balance0 -= amount0;
                amountOut = amount0;
                amount1 = 0;
            }
        }
        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
        emit Burn(msg.sender, amount0, amount1, recipient);
    }

    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.
    function swap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));
        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();
        require(_reserve0 > 0, ""POOL_UNINITIALIZED"");
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 amountIn;
        address tokenOut;
        unchecked {
            if (tokenIn == token0) {
                tokenOut = token1;
                amountIn = balance0 - _reserve0;
                amountOut = _getAmountOut(amountIn, _reserve0, _reserve1);
                balance1 -= amountOut;
            } else {
                require(tokenIn == token1, ""INVALID_INPUT_TOKEN"");
                tokenOut = token0;
                amountIn = balance1 - reserve1;
                amountOut = _getAmountOut(amountIn, _reserve1, _reserve0);
                balance0 -= amountOut;
            }
        }
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }

    /// @dev Swaps one token for another. The router must support swap callbacks and ensure there isn't too much slippage.
    function flashSwap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address recipient, bool unwrapBento, uint256 amountIn, bytes memory context) = abi.decode(
            data,
            (address, address, bool, uint256, bytes)
        );
        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();
        require(_reserve0 > 0, ""POOL_UNINITIALIZED"");
        unchecked {
            if (tokenIn == token0) {
                amountOut = _getAmountOut(amountIn, _reserve0, _reserve1);
                _transfer(token1, amountOut, recipient, unwrapBento);
                ITridentCallee(msg.sender).tridentSwapCallback(context);
                (uint256 balance0, uint256 balance1) = _balance();
                require(balance0 - _reserve0 >= amountIn, ""INSUFFICIENT_AMOUNT_IN"");
                _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
                emit Swap(recipient, tokenIn, token1, amountIn, amountOut);
            } else {
                require(tokenIn == token1, ""INVALID_INPUT_TOKEN"");
                amountOut = _getAmountOut(amountIn, _reserve1, _reserve0);
                _transfer(token0, amountOut, recipient, unwrapBento);
                ITridentCallee(msg.sender).tridentSwapCallback(context);
                (uint256 balance0, uint256 balance1) = _balance();
                require(balance1 - _reserve1 >= amountIn, ""INSUFFICIENT_AMOUNT_IN"");
                _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
                emit Swap(recipient, tokenIn, token0, amountIn, amountOut);
            }
        }
    }

    /// @dev Updates `barFee` for Trident protocol.
    function updateBarFee() public {
        barFee = IMasterDeployer(masterDeployer).barFee();
    }

    function _getReserves()
        internal
        view
        returns (
            uint112 _reserve0,
            uint112 _reserve1,
            uint32 _blockTimestampLast
        )
    {
        _reserve0 = reserve0;
        _reserve1 = reserve1;
        _blockTimestampLast = blockTimestampLast;
    }

    function _balance() internal view returns (uint256 balance0, uint256 balance1) {
        balance0 = bento.balanceOf(token0, address(this));
        balance1 = bento.balanceOf(token1, address(this));
    }

    function _update(
        uint256 balance0,
        uint256 balance1,
        uint112 _reserve0,
        uint112 _reserve1,
        uint32 _blockTimestampLast
    ) internal {
        require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, ""OVERFLOW"");
        if (_blockTimestampLast == 0) {
            // @dev TWAP support is disabled for gas efficiency.
            reserve0 = uint112(balance0);
            reserve1 = uint112(balance1);
        } else {
            uint32 blockTimestamp = uint32(block.timestamp % 2**32);
            if (blockTimestamp != _blockTimestampLast && _reserve0 != 0 && _reserve1 != 0) {
                unchecked {
                    uint32 timeElapsed = blockTimestamp - _blockTimestampLast;
                    uint256 price0 = (uint256(_reserve1) << PRECISION) / _reserve0;
                    price0CumulativeLast += price0 * timeElapsed;
                    uint256 price1 = (uint256(_reserve0) << PRECISION) / _reserve1;
                    price1CumulativeLast += price1 * timeElapsed;
                }
            }
            reserve0 = uint112(balance0);
            reserve1 = uint112(balance1);
            blockTimestampLast = blockTimestamp;
        }
        emit Sync(balance0, balance1);
    }

    function _mintFee(uint112 _reserve0, uint112 _reserve1) internal returns (uint256 _totalSupply, uint256 computed) {
        _totalSupply = totalSupply;
        uint256 _kLast = kLast;
        if (_kLast != 0) {
            computed = TridentMath.sqrt(uint256(_reserve0) * _reserve1);
            if (computed > _kLast) {
                // @dev `barFee` % of increase in liquidity.
                // It's going to be slightly less than `barFee` % in reality due to the math.
                uint256 liquidity = (_totalSupply * (computed - _kLast) * barFee) / computed / MAX_FEE;
                if (liquidity != 0) {
                    _mint(barFeeTo, liquidity);
                    _totalSupply += liquidity;
                }
            }
        }
    }

    function _getAmountOut(
        uint256 amountIn,
        uint256 reserveAmountIn,
        uint256 reserveAmountOut
    ) internal view returns (uint256 amountOut) {
        uint256 amountInWithFee = amountIn * MAX_FEE_MINUS_SWAP_FEE;
        amountOut = (amountInWithFee * reserveAmountOut) / (reserveAmountIn * MAX_FEE + amountInWithFee);
    }

    function _transfer(
        address token,
        uint256 shares,
        address to,
        bool unwrapBento
    ) internal {
        if (unwrapBento) {
            bento.withdraw(token, address(this), to, 0, shares);
        } else {
            bento.transfer(token, address(this), to, shares);
        }
    }

    /// @dev This fee is charged to cover for `swapFee` when users add unbalanced liquidity.
    function _nonOptimalMintFee(
        uint256 _amount0,
        uint256 _amount1,
        uint256 _reserve0,
        uint256 _reserve1
    ) internal view returns (uint256 token0Fee, uint256 token1Fee) {
        if (_reserve0 == 0 || _reserve1 == 0) return (0, 0);
        uint256 amount1Optimal = (_amount0 * _reserve1) / _reserve0;
        if (amount1Optimal <= _amount1) {
            token1Fee = (swapFee * (_amount1 - amount1Optimal)) / (2 * MAX_FEE);
        } else {
            uint256 amount0Optimal = (_amount1 * _reserve0) / _reserve1;
            token0Fee = (swapFee * (_amount0 - amount0Optimal)) / (2 * MAX_FEE);
        }
    }

    function getAssets() public view override returns (address[] memory assets) {
        assets = new address[](2);
        assets[0] = token0;
        assets[1] = token1;
    }

    function getAmountOut(bytes calldata data) public view override returns (uint256 finalAmountOut) {
        (address tokenIn, uint256 amountIn) = abi.decode(data, (address, uint256));
        (uint112 _reserve0, uint112 _reserve1, ) = _getReserves();
        if (tokenIn == token0) {
            finalAmountOut = _getAmountOut(amountIn, _reserve0, _reserve1);
        } else {
            finalAmountOut = _getAmountOut(amountIn, _reserve1, _reserve0);
        }
    }

    function getReserves()
        public
        view
        returns (
            uint112 _reserve0,
            uint112 _reserve1,
            uint32 _blockTimestampLast
        )
    {
        return _getReserves();
    }
}",3993
RealWorld_BA_35_Migrator_RealWord_20240820085734.log,35,Migrator,9224,5146,14370,82.0,0.14904,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../pool/ConstantProductPool.sol"";
import ""../pool/ConstantProductPoolFactory.sol"";
import ""../deployer/MasterDeployer.sol"";
import ""../interfaces/IPool.sol"";
import ""../interfaces/IBentoBoxMinimal.sol"";

interface IERC20 {
    function totalSupply() external returns (uint256);
}

contract Migrator {
    address public chef;
    ConstantProductPoolFactory public factory;
    IBentoBoxMinimal public bentoBox;
    uint256 public desiredLiquidity = type(uint256).max;

    constructor(
        address _chef,
        IBentoBoxMinimal _bentoBox,
        ConstantProductPoolFactory _factory
    ) {
        chef = _chef;
        bentoBox = _bentoBox;
        factory = _factory;
    }

    function migrate(ConstantProductPool orig) public returns (IPool) {
        require(msg.sender == chef, ""!chef"");

        address token0 = orig.token0();
        address token1 = orig.token1();

        bytes memory deployData = abi.encode(token0, token1, 10, false);

        IPool pair = IPool(factory.configAddress(keccak256(deployData)));

        if (address(pair) == (address(0))) {
            pair = IPool(factory.deployPool(deployData));
        }

        require(IERC20(address(pair)).totalSupply() == 0, ""pair must have no existing supply"");

        uint256 lp = orig.balanceOf(msg.sender);

        if (lp == 0) return pair;

        orig.transferFrom(msg.sender, address(orig), lp);

        desiredLiquidity = lp;

        orig.burn(abi.encode(address(pair), false));

        pair.mint(abi.encode(msg.sender));

        desiredLiquidity = type(uint256).max;

        return pair;
    }
}",395
RealWorld_BA_35_ITridentRouter_RealWord_20240820095549.log,35,ITridentRouter,7332,4994,12326,95.0,0.13654,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice Trident pool router interface.
interface ITridentRouter {
    struct Path {
        address pool;
        bytes data;
    }

    struct ExactInputSingleParams {
        uint256 amountIn;
        uint256 amountOutMinimum;
        address pool;
        address tokenIn;
        bytes data;
    }

    struct ExactInputParams {
        address tokenIn;
        uint256 amountIn;
        uint256 amountOutMinimum;
        Path[] path;
    }

    struct TokenInput {
        address token;
        bool native;
        uint256 amount;
    }

    struct InitialPath {
        address tokenIn;
        address pool;
        bool native;
        uint256 amount;
        bytes data;
    }

    struct PercentagePath {
        address tokenIn;
        address pool;
        uint64 balancePercentage; // @dev Multiplied by 10^6. 100% = 100_000_000
        bytes data;
    }

    struct Output {
        address token;
        address to;
        bool unwrapBento;
        uint256 minAmount;
    }

    struct ComplexPathParams {
        InitialPath[] initialPath;
        PercentagePath[] percentagePath;
        Output[] output;
    }
}",268
RealWorld_BA_35_HybridPoolFactory_RealWord_20240820091935.log,35,HybridPoolFactory,7992,5366,13358,88.0,0.14728,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""./HybridPool.sol"";
import ""./PoolDeployer.sol"";

/// @notice Contract for deploying Trident exchange Hybrid Pool with configurations.
/// @author Mudit Gupta.
contract HybridPoolFactory is PoolDeployer {
    constructor(address _masterDeployer) PoolDeployer(_masterDeployer) {}

    function deployPool(bytes memory _deployData) external returns (address pool) {
        (address tokenA, address tokenB, uint256 swapFee, uint256 a) = abi.decode(_deployData, (address, address, uint256, uint256));

        if (tokenA > tokenB) {
            (tokenA, tokenB) = (tokenB, tokenA);
        }

        // @dev Strips any extra data.
        _deployData = abi.encode(tokenA, tokenB, swapFee, a);
        address[] memory tokens = new address[](2);
        tokens[0] = tokenA;
        tokens[1] = tokenB;

        // @dev Salt is not actually needed since `_deployData` is part of creationCode and already contains the salt.
        bytes32 salt = keccak256(_deployData);
        pool = address(new HybridPool{salt: salt}(_deployData, masterDeployer));
        _registerPool(pool, tokens, salt);
    }
}",292
RealWorld_BA_35_FranchisedConstantProductPool_RealWord_20240820094626.log,35,FranchisedConstantProductPool,72109,5697,77806,111.0,0.474485,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../../interfaces/IBentoBoxMinimal.sol"";
import ""../../interfaces/IMasterDeployer.sol"";
import ""../../interfaces/IPool.sol"";
import ""../../interfaces/ITridentCallee.sol"";
import ""../../libraries/TridentMath.sol"";
import ""./TridentFranchisedERC20.sol"";

/// @notice Trident exchange franchised pool template with constant product formula for swapping between an ERC-20 token pair.
/// @dev The reserves are stored as bento shares.
///      The curve is applied to shares as well. This pool does not care about the underlying amounts.
contract FranchisedConstantProductPool is IPool, TridentFranchisedERC20 {
    event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);
    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);
    event Sync(uint256 reserve0, uint256 reserve1);

    uint256 internal constant MINIMUM_LIQUIDITY = 1000;

    uint8 internal constant PRECISION = 112;
    uint256 internal constant MAX_FEE = 10000; // @dev 100%.
    uint256 internal constant MAX_FEE_SQUARE = 100000000;
    uint256 internal constant E18 = uint256(10)**18;
    uint256 public immutable swapFee;
    uint256 internal immutable MAX_FEE_MINUS_SWAP_FEE;

    address public immutable barFeeTo;
    address public immutable bento;
    address public immutable masterDeployer;
    address public immutable token0;
    address public immutable token1;

    uint256 public barFee;
    uint256 public price0CumulativeLast;
    uint256 public price1CumulativeLast;
    uint256 public kLast;

    uint112 internal reserve0;
    uint112 internal reserve1;
    uint32 internal blockTimestampLast;

    bytes32 public constant override poolIdentifier = ""Trident:FranchisedCP"";

    uint256 internal unlocked;
    modifier lock() {
        require(unlocked == 1, ""LOCKED"");
        unlocked = 2;
        _;
        unlocked = 1;
    }

    constructor(bytes memory _deployData, address _masterDeployer) {
        (
            address _token0,
            address _token1,
            uint256 _swapFee,
            bool _twapSupport,
            address _whiteListManager,
            address _operator,
            bool _level2
        ) = abi.decode(_deployData, (address, address, uint256, bool, address, address, bool));

        // @dev Factory ensures that the tokens are sorted.
        require(_token0 != address(0), ""ZERO_ADDRESS"");
        require(_token0 != _token1, ""IDENTICAL_ADDRESSES"");
        require(_token0 != address(this), ""INVALID_TOKEN"");
        require(_token1 != address(this), ""INVALID_TOKEN"");
        require(_swapFee <= MAX_FEE, ""INVALID_SWAP_FEE"");

        TridentFranchisedERC20.initialize(_whiteListManager, _operator, _level2);

        (, bytes memory _barFee) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));
        (, bytes memory _barFeeTo) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFeeTo.selector));
        (, bytes memory _bento) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.bento.selector));

        token0 = _token0;
        token1 = _token1;
        swapFee = _swapFee;
        // @dev This is safe from underflow - `swapFee` cannot exceed `MAX_FEE` per previous check.
        unchecked {
            MAX_FEE_MINUS_SWAP_FEE = MAX_FEE - _swapFee;
        }
        barFee = abi.decode(_barFee, (uint256));
        barFeeTo = abi.decode(_barFeeTo, (address));
        bento = abi.decode(_bento, (address));
        masterDeployer = _masterDeployer;
        unlocked = 1;
        if (_twapSupport) blockTimestampLast = 1;
    }

    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.
    /// The router must ensure that sufficient LP tokens are minted by using the return value.
    function mint(bytes calldata data) public override lock returns (uint256 liquidity) {
        address recipient = abi.decode(data, (address));
        _checkWhiteList(recipient);
        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 _totalSupply = totalSupply;

        unchecked {
            _totalSupply += _mintFee(_reserve0, _reserve1, _totalSupply);
        }

        uint256 amount0 = balance0 - _reserve0;
        uint256 amount1 = balance1 - _reserve1;
        (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1);
        uint256 computed = TridentMath.sqrt((balance0 - fee0) * (balance1 - fee1));

        if (_totalSupply == 0) {
            _mint(address(0), MINIMUM_LIQUIDITY);
            liquidity = computed - MINIMUM_LIQUIDITY;
        } else {
            uint256 k = TridentMath.sqrt(uint256(_reserve0) * _reserve1);
            liquidity = ((computed - k) * _totalSupply) / k;
        }
        require(liquidity != 0, ""INSUFFICIENT_LIQUIDITY_MINTED"");
        _mint(recipient, liquidity);
        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
        kLast = TridentMath.sqrt(balance0 * balance1);
        emit Mint(msg.sender, amount0, amount1, recipient);
    }

    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.
    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {
        (address recipient, bool unwrapBento) = abi.decode(data, (address, bool));
        _checkWhiteList(recipient);
        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 _totalSupply = totalSupply;
        uint256 liquidity = balanceOf[address(this)];

        unchecked {
            _totalSupply += _mintFee(_reserve0, _reserve1, _totalSupply);
        }

        uint256 amount0 = (liquidity * balance0) / _totalSupply;
        uint256 amount1 = (liquidity * balance1) / _totalSupply;

        _burn(address(this), liquidity);
        _transfer(token0, amount0, recipient, unwrapBento);
        _transfer(token1, amount1, recipient, unwrapBento);
        // @dev This is safe from underflow - amounts are lesser figures derived from balances.
        unchecked {
            balance0 -= amount0;
            balance1 -= amount1;
        }
        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
        kLast = TridentMath.sqrt(balance0 * balance1);

        withdrawnAmounts = new TokenAmount[](2);
        withdrawnAmounts[0] = TokenAmount({token: address(token0), amount: amount0});
        withdrawnAmounts[1] = TokenAmount({token: address(token1), amount: amount1});
        emit Burn(msg.sender, amount0, amount1, recipient);
    }

    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another
    /// - i.e., the user gets a single token out by burning LP tokens.
    function burnSingle(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenOut, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));
        _checkWhiteList(recipient);
        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 _totalSupply = totalSupply;
        uint256 liquidity = balanceOf[address(this)];

        unchecked {
            _totalSupply += _mintFee(_reserve0, _reserve1, _totalSupply);
        }

        uint256 amount0 = (liquidity * balance0) / _totalSupply;
        uint256 amount1 = (liquidity * balance1) / _totalSupply;

        _burn(address(this), liquidity);
        unchecked {
            if (tokenOut == token1) {
                // @dev Swap `token0` for `token1`
                // - calculate `amountOut` as if the user first withdrew balanced liquidity and then swapped `token0` for `token1`.
                amount1 += _getAmountOut(amount0, _reserve0 - amount0, _reserve1 - amount1);
                _transfer(token1, amount1, recipient, unwrapBento);
                balance1 -= amount1;
                amountOut = amount1;
                amount0 = 0;
            } else {
                // @dev Swap `token1` for `token0`.
                require(tokenOut == token0, ""INVALID_OUTPUT_TOKEN"");
                amount0 += _getAmountOut(amount1, _reserve1 - amount1, _reserve0 - amount0);
                _transfer(token0, amount0, recipient, unwrapBento);
                balance0 -= amount0;
                amountOut = amount0;
                amount1 = 0;
            }
        }
        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
        kLast = TridentMath.sqrt(balance0 * balance1);
        emit Burn(msg.sender, amount0, amount1, recipient);
    }

    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.
    function swap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));
        if (level2) _checkWhiteList(recipient);
        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 amountIn;
        address tokenOut;
        unchecked {
            if (tokenIn == token0) {
                tokenOut = token1;
                amountIn = balance0 - _reserve0;
                amountOut = _getAmountOut(amountIn, _reserve0, _reserve1);
                balance1 -= amountOut;
            } else {
                require(tokenIn == token1, ""INVALID_INPUT_TOKEN"");
                tokenOut = token0;
                amountIn = balance1 - reserve1;
                amountOut = _getAmountOut(amountIn, _reserve1, _reserve0);
                balance0 -= amountOut;
            }
        }
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }

    /// @dev Swaps one token for another. The router must support swap callbacks and ensure there isn't too much slippage.
    function flashSwap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address recipient, bool unwrapBento, uint256 amountIn, bytes memory context) = abi.decode(
            data,
            (address, address, bool, uint256, bytes)
        );
        if (level2) _checkWhiteList(recipient);
        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();
        unchecked {
            if (tokenIn == token0) {
                amountOut = _getAmountOut(amountIn, _reserve0, _reserve1);
                _transfer(token1, amountOut, recipient, unwrapBento);
                ITridentCallee(msg.sender).tridentSwapCallback(context);
                (uint256 balance0, uint256 balance1) = _balance();
                require(balance0 - _reserve0 >= amountIn, ""INSUFFICIENT_AMOUNT_IN"");
                _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
                emit Swap(recipient, tokenIn, token1, amountIn, amountOut);
            } else {
                require(tokenIn == token1, ""INVALID_INPUT_TOKEN"");
                amountOut = _getAmountOut(amountIn, _reserve1, _reserve0);
                _transfer(token0, amountOut, recipient, unwrapBento);
                ITridentCallee(msg.sender).tridentSwapCallback(context);
                (uint256 balance0, uint256 balance1) = _balance();
                require(balance1 - _reserve1 >= amountIn, ""INSUFFICIENT_AMOUNT_IN"");
                _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
                emit Swap(recipient, tokenIn, token0, amountIn, amountOut);
            }
        }
    }

    /// @dev Updates `barFee` for Trident protocol.
    function updateBarFee() public {
        (, bytes memory _barFee) = masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));
        barFee = abi.decode(_barFee, (uint256));
    }

    function _getReserves()
        internal
        view
        returns (
            uint112 _reserve0,
            uint112 _reserve1,
            uint32 _blockTimestampLast
        )
    {
        _reserve0 = reserve0;
        _reserve1 = reserve1;
        _blockTimestampLast = blockTimestampLast;
    }

    function _balance() internal view returns (uint256 balance0, uint256 balance1) {
        // @dev balanceOf(address,address).
        (, bytes memory _balance0) = bento.staticcall(abi.encodeWithSelector(0xf7888aec, token0, address(this)));
        balance0 = abi.decode(_balance0, (uint256));
        // @dev balanceOf(address,address).
        (, bytes memory _balance1) = bento.staticcall(abi.encodeWithSelector(0xf7888aec, token1, address(this)));
        balance1 = abi.decode(_balance1, (uint256));
    }

    function _update(
        uint256 balance0,
        uint256 balance1,
        uint112 _reserve0,
        uint112 _reserve1,
        uint32 _blockTimestampLast
    ) internal {
        require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, ""OVERFLOW"");
        if (blockTimestampLast == 0) {
            // @dev TWAP support is disabled for gas efficiency.
            reserve0 = uint112(balance0);
            reserve1 = uint112(balance1);
        } else {
            uint32 blockTimestamp = uint32(block.timestamp % 2**32);
            if (blockTimestamp != _blockTimestampLast && _reserve0 != 0 && _reserve1 != 0) {
                unchecked {
                    uint32 timeElapsed = blockTimestamp - _blockTimestampLast;
                    uint256 price0 = (uint256(_reserve1) << PRECISION) / _reserve0;
                    price0CumulativeLast += price0 * timeElapsed;
                    uint256 price1 = (uint256(_reserve0) << PRECISION) / _reserve1;
                    price1CumulativeLast += price1 * timeElapsed;
                }
            }
            reserve0 = uint112(balance0);
            reserve1 = uint112(balance1);
            blockTimestampLast = blockTimestamp;
        }
        emit Sync(balance0, balance1);
    }

    function _mintFee(
        uint112 _reserve0,
        uint112 _reserve1,
        uint256 _totalSupply
    ) internal returns (uint256 liquidity) {
        uint256 _kLast = kLast;
        if (_kLast != 0) {
            uint256 computed = TridentMath.sqrt(uint256(_reserve0) * _reserve1);
            if (computed > _kLast) {
                // @dev `barFee` % of increase in liquidity.
                // It's going to be slightly less than `barFee` % in reality due to the math.
                liquidity = (_totalSupply * (computed - _kLast) * barFee) / computed / MAX_FEE;
                if (liquidity != 0) {
                    _mint(barFeeTo, liquidity);
                }
            }
        }
    }

    function _getAmountOut(
        uint256 amountIn,
        uint256 reserveAmountIn,
        uint256 reserveAmountOut
    ) internal view returns (uint256 amountOut) {
        uint256 amountInWithFee = amountIn * MAX_FEE_MINUS_SWAP_FEE;
        amountOut = (amountInWithFee * reserveAmountOut) / (reserveAmountIn * MAX_FEE + amountInWithFee);
    }

    function _transfer(
        address token,
        uint256 shares,
        address to,
        bool unwrapBento
    ) internal {
        if (unwrapBento) {
            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.withdraw.selector, token, address(this), to, 0, shares));
            require(success, ""WITHDRAW_FAILED"");
        } else {
            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.transfer.selector, token, address(this), to, shares));
            require(success, ""TRANSFER_FAILED"");
        }
    }

    /// @dev This fee is charged to cover for `swapFee` when users add unbalanced liquidity.
    function _nonOptimalMintFee(
        uint256 _amount0,
        uint256 _amount1,
        uint256 _reserve0,
        uint256 _reserve1
    ) internal view returns (uint256 token0Fee, uint256 token1Fee) {
        if (_reserve0 == 0 || _reserve1 == 0) return (0, 0);
        uint256 amount1Optimal = (_amount0 * _reserve1) / _reserve0;
        if (amount1Optimal <= _amount1) {
            token1Fee = (swapFee * (_amount1 - amount1Optimal)) / (2 * MAX_FEE);
        } else {
            uint256 amount0Optimal = (_amount1 * _reserve0) / _reserve1;
            token0Fee = (swapFee * (_amount0 - amount0Optimal)) / (2 * MAX_FEE);
        }
    }

    function getAssets() public view override returns (address[] memory assets) {
        assets = new address[](2);
        assets[0] = token0;
        assets[1] = token1;
    }

    function getAmountOut(bytes calldata data) public view override returns (uint256 finalAmountOut) {
        (address tokenIn, uint256 amountIn) = abi.decode(data, (address, uint256));
        (uint112 _reserve0, uint112 _reserve1, ) = _getReserves();
        if (tokenIn == token0) {
            finalAmountOut = _getAmountOut(amountIn, _reserve0, _reserve1);
        } else {
            finalAmountOut = _getAmountOut(amountIn, _reserve1, _reserve0);
        }
    }

    function getReserves()
        public
        view
        returns (
            uint112 _reserve0,
            uint112 _reserve1,
            uint32 _blockTimestampLast
        )
    {
        return _getReserves();
    }
}",4272
RealWorld_BA_35_TridentFranchisedERC20_RealWord_20240820094819.log,35,TridentFranchisedERC20,27516,5684,33200,105.0,0.25126,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../../interfaces/IWhiteListManager.sol"";

/// @notice Trident franchised pool ERC-20 with EIP-2612 extension.
/// @author Adapted from RariCapital, https://github.com/Rari-Capital/solmate/blob/main/src/erc20/ERC20.sol,
/// License-Identifier: AGPL-3.0-only.
abstract contract TridentFranchisedERC20 {
    event Approval(address indexed owner, address indexed spender, uint256 amount);
    event Transfer(address indexed sender, address indexed recipient, uint256 amount);

    string public constant name = ""Sushi Franchised LP Token"";
    string public constant symbol = ""SLP"";
    uint8 public constant decimals = 18;

    address public whiteListManager;
    address public operator;
    bool public level2;

    uint256 public totalSupply;
    /// @notice owner -> balance mapping.
    mapping(address => uint256) public balanceOf;
    /// @notice owner -> spender -> allowance mapping.
    mapping(address => mapping(address => uint256)) public allowance;

    /// @notice The EIP-712 typehash for this contract's {permit} struct.
    bytes32 public constant PERMIT_TYPEHASH =
        keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    /// @notice The EIP-712 typehash for this contract's domain.
    bytes32 public immutable DOMAIN_SEPARATOR;
    /// @notice owner -> nonce mapping used in {permit}.
    mapping(address => uint256) public nonces;

    constructor() {
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
                keccak256(bytes(name)),
                keccak256(bytes(""1"")),
                block.chainid,
                address(this)
            )
        );
    }

    /// @dev Initializes whitelist settings from pool.
    function initialize(
        address _whiteListManager,
        address _operator,
        bool _level2
    ) internal {
        whiteListManager = _whiteListManager;
        operator = _operator;
        if (_level2) level2 = true;
    }

    /// @notice Approves `amount` from `msg.sender` to be spent by `spender`.
    /// @param spender Address of the party that can pull tokens from `msg.sender`'s account.
    /// @param amount The maximum collective `amount` that `spender` can pull.
    /// @return (bool) Returns 'true' if succeeded.
    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    /// @notice Transfers `amount` tokens from `msg.sender` to `recipient`.
    /// @param recipient The address to move tokens to.
    /// @param amount The token `amount` to move.
    /// @return (bool) Returns 'true' if succeeded.
    function transfer(address recipient, uint256 amount) external returns (bool) {
        if (level2) _checkWhiteList(recipient);
        balanceOf[msg.sender] -= amount;
        // @dev This is safe from overflow - the sum of all user
        // balances can't exceed 'type(uint256).max'.
        unchecked {
            balanceOf[recipient] += amount;
        }
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    /// @notice Transfers `amount` tokens from `sender` to `recipient`. Caller needs approval from `from`.
    /// @param sender Address to pull tokens `from`.
    /// @param recipient The address to move tokens to.
    /// @param amount The token `amount` to move.
    /// @return (bool) Returns 'true' if succeeded.
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool) {
        if (level2) _checkWhiteList(recipient);
        if (allowance[sender][msg.sender] != type(uint256).max) {
            allowance[sender][msg.sender] -= amount;
        }
        balanceOf[sender] -= amount;
        // @dev This is safe from overflow - the sum of all user
        // balances can't exceed 'type(uint256).max'.
        unchecked {
            balanceOf[recipient] += amount;
        }
        emit Transfer(sender, recipient, amount);
        return true;
    }

    /// @notice Triggers an approval from `owner` to `spender`.
    /// @param owner The address to approve from.
    /// @param spender The address to be approved.
    /// @param amount The number of tokens that are approved (2^256-1 means infinite).
    /// @param deadline The time at which to expire the signature.
    /// @param v The recovery byte of the signature.
    /// @param r Half of the ECDSA signature pair.
    /// @param s Half of the ECDSA signature pair.
    function permit(
        address owner,
        address spender,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        require(deadline >= block.timestamp, ""PERMIT_DEADLINE_EXPIRED"");
        bytes32 digest = keccak256(
            abi.encodePacked(
                ""\x19\x01"",
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, nonces[owner]++, deadline))
            )
        );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress != address(0) && recoveredAddress == owner, ""INVALID_PERMIT_SIGNATURE"");
        allowance[recoveredAddress][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _mint(address recipient, uint256 amount) internal {
        totalSupply += amount;
        // @dev This is safe from overflow - the sum of all user
        // balances can't exceed 'type(uint256).max'.
        unchecked {
            balanceOf[recipient] += amount;
        }
        emit Transfer(address(0), recipient, amount);
    }

    function _burn(address sender, uint256 amount) internal {
        balanceOf[sender] -= amount;
        // @dev This is safe from underflow - users won't ever
        // have a balance larger than `totalSupply`.
        unchecked {
            totalSupply -= amount;
        }
        emit Transfer(sender, address(0), amount);
    }

    /// @dev Checks `whiteListManager` for pool `operator` and given user `account`.
    function _checkWhiteList(address account) internal view {
        (, bytes memory _whitelisted) = whiteListManager.staticcall(
            abi.encodeWithSelector(IWhiteListManager.whitelistedAccounts.selector, operator, account)
        );
        bool whitelisted = abi.decode(_whitelisted, (bool));
        require(whitelisted, ""NOT_WHITELISTED"");
    }
}",1497
RealWorld_BA_35_FranchisedIndexPool_RealWord_20240820094258.log,35,FranchisedIndexPool,65402,5770,71172,95.0,0.44241,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../../interfaces/IBentoBoxMinimal.sol"";
import ""../../interfaces/IMasterDeployer.sol"";
import ""../../interfaces/IPool.sol"";
import ""../../interfaces/ITridentCallee.sol"";
import ""./TridentFranchisedERC20.sol"";

/// @notice Trident exchange franchised pool template with constant mean formula for swapping among an array of ERC-20 tokens.
/// @dev The reserves are stored as bento shares.
///      The curve is applied to shares as well. This pool does not care about the underlying amounts.
contract FranchisedIndexPool is IPool, TridentFranchisedERC20 {
    event Mint(address indexed sender, address tokenIn, uint256 amountIn, address indexed recipient);
    event Burn(address indexed sender, address tokenOut, uint256 amountOut, address indexed recipient);

    uint256 public immutable swapFee;

    address public immutable barFeeTo;
    address public immutable bento;
    address public immutable masterDeployer;

    uint256 internal constant BASE = 10**18;
    uint256 internal constant MIN_TOKENS = 2;
    uint256 internal constant MAX_TOKENS = 8;
    uint256 internal constant MIN_FEE = BASE / 10**6;
    uint256 internal constant MAX_FEE = BASE / 10;
    uint256 internal constant MIN_WEIGHT = BASE;
    uint256 internal constant MAX_WEIGHT = BASE * 50;
    uint256 internal constant MAX_TOTAL_WEIGHT = BASE * 50;
    uint256 internal constant MIN_BALANCE = BASE / 10**12;
    uint256 internal constant INIT_POOL_SUPPLY = BASE * 100;
    uint256 internal constant MIN_POW_BASE = 1;
    uint256 internal constant MAX_POW_BASE = (2 * BASE) - 1;
    uint256 internal constant POW_PRECISION = BASE / 10**10;
    uint256 internal constant MAX_IN_RATIO = BASE / 2;
    uint256 internal constant MAX_OUT_RATIO = (BASE / 3) + 1;

    uint136 internal totalWeight;
    address[] internal tokens;

    uint256 public barFee;

    bytes32 public constant override poolIdentifier = ""Trident:FranchisedIndex"";

    uint256 internal unlocked;
    modifier lock() {
        require(unlocked == 1, ""LOCKED"");
        unlocked = 2;
        _;
        unlocked = 1;
    }

    mapping(address => Record) public records;
    struct Record {
        uint120 reserve;
        uint136 weight;
    }

    constructor(bytes memory _deployData, address _masterDeployer) {
        (
            address[] memory _tokens,
            uint136[] memory _weights,
            uint256 _swapFee,
            address _whiteListManager,
            address _operator,
            bool _level2
        ) = abi.decode(_deployData, (address[], uint136[], uint256, address, address, bool));
        // @dev Factory ensures that the tokens are sorted.
        require(_tokens.length == _weights.length, ""INVALID_ARRAYS"");
        require(MIN_FEE <= _swapFee && _swapFee <= MAX_FEE, ""INVALID_SWAP_FEE"");
        require(MIN_TOKENS <= _tokens.length && _tokens.length <= MAX_TOKENS, ""INVALID_TOKENS_LENGTH"");

        TridentFranchisedERC20.initialize(_whiteListManager, _operator, _level2);

        for (uint256 i = 0; i < _tokens.length; i++) {
            require(_tokens[i] != address(0), ""ZERO_ADDRESS"");
            require(MIN_WEIGHT <= _weights[i] && _weights[i] <= MAX_WEIGHT, ""INVALID_WEIGHT"");
            records[_tokens[i]] = Record({reserve: 0, weight: _weights[i]});
            tokens.push(_tokens[i]);
            totalWeight += _weights[i];
        }

        require(totalWeight <= MAX_TOTAL_WEIGHT, ""MAX_TOTAL_WEIGHT"");
        // @dev This burns initial LP supply.
        _mint(address(0), INIT_POOL_SUPPLY);

        (, bytes memory _barFee) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));
        (, bytes memory _barFeeTo) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFeeTo.selector));
        (, bytes memory _bento) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.bento.selector));

        swapFee = _swapFee;
        barFee = abi.decode(_barFee, (uint256));
        barFeeTo = abi.decode(_barFeeTo, (address));
        bento = abi.decode(_bento, (address));
        masterDeployer = _masterDeployer;
        unlocked = 1;
    }

    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.
    /// The router must ensure that sufficient LP tokens are minted by using the return value.
    function mint(bytes calldata data) public override lock returns (uint256 liquidity) {
        (address recipient, uint256 toMint) = abi.decode(data, (address, uint256));
        _checkWhiteList(recipient);
        uint120 ratio = uint120(_div(toMint, totalSupply));

        for (uint256 i = 0; i < tokens.length; i++) {
            address tokenIn = tokens[i];
            uint120 reserve = records[tokenIn].reserve;
            // @dev If token balance is '0', initialize with `ratio`.
            uint120 amountIn = reserve != 0 ? uint120(_mul(ratio, reserve)) : ratio;
            require(amountIn >= MIN_BALANCE, ""MIN_BALANCE"");
            // @dev Check Trident router has sent `amountIn` for skim into pool.
            unchecked {
                // @dev This is safe from overflow - only logged amounts handled.
                require(_balance(tokenIn) >= amountIn + reserve, ""NOT_RECEIVED"");
                records[tokenIn].reserve += amountIn;
            }
            emit Mint(msg.sender, tokenIn, amountIn, recipient);
        }
        _mint(recipient, toMint);
        liquidity = toMint;
    }

    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.
    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {
        (address recipient, bool unwrapBento, uint256 toBurn) = abi.decode(data, (address, bool, uint256));
        _checkWhiteList(recipient);
        uint256 ratio = _div(toBurn, totalSupply);

        withdrawnAmounts = new TokenAmount[](tokens.length);

        _burn(address(this), toBurn);

        for (uint256 i = 0; i < tokens.length; i++) {
            address tokenOut = tokens[i];
            uint256 balance = records[tokenOut].reserve;
            uint120 amountOut = uint120(_mul(ratio, balance));
            require(amountOut != 0, ""ZERO_OUT"");
            // @dev This is safe from underflow - only logged amounts handled.
            unchecked {
                records[tokenOut].reserve -= amountOut;
            }
            _transfer(tokenOut, amountOut, recipient, unwrapBento);
            withdrawnAmounts[i] = TokenAmount({token: tokenOut, amount: amountOut});
            emit Burn(msg.sender, tokenOut, amountOut, recipient);
        }
    }

    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another
    /// - i.e., the user gets a single token out by burning LP tokens.
    function burnSingle(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenOut, address recipient, bool unwrapBento, uint256 toBurn) = abi.decode(data, (address, address, bool, uint256));
        _checkWhiteList(recipient);
        Record storage outRecord = records[tokenOut];

        amountOut = _computeSingleOutGivenPoolIn(outRecord.reserve, outRecord.weight, totalSupply, totalWeight, toBurn, swapFee);

        require(amountOut <= _mul(outRecord.reserve, MAX_OUT_RATIO), ""MAX_OUT_RATIO"");
        // @dev This is safe from underflow - only logged amounts handled.
        unchecked {
            outRecord.reserve -= uint120(amountOut);
        }
        _burn(address(this), toBurn);
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        emit Burn(msg.sender, tokenOut, amountOut, recipient);
    }

    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.
    function swap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address tokenOut, address recipient, bool unwrapBento, uint256 amountIn) = abi.decode(
            data,
            (address, address, address, bool, uint256)
        );
        if (level2) _checkWhiteList(recipient);
        Record storage inRecord = records[tokenIn];
        Record storage outRecord = records[tokenOut];

        require(amountIn <= _mul(inRecord.reserve, MAX_IN_RATIO), ""MAX_IN_RATIO"");

        amountOut = _getAmountOut(amountIn, inRecord.reserve, inRecord.weight, outRecord.reserve, outRecord.weight);
        // @dev Check Trident router has sent `amountIn` for skim into pool.
        unchecked {
            // @dev This is safe from under/overflow - only logged amounts handled.
            require(_balance(tokenIn) >= amountIn + inRecord.reserve, ""NOT_RECEIVED"");
            inRecord.reserve += uint120(amountIn);
            outRecord.reserve -= uint120(amountOut);
        }
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }

    /// @dev Swaps one token for another. The router must support swap callbacks and ensure there isn't too much slippage.
    function flashSwap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address tokenOut, address recipient, bool unwrapBento, uint256 amountIn, bytes memory context) = abi.decode(
            data,
            (address, address, address, bool, uint256, bytes)
        );
        if (level2) _checkWhiteList(recipient);
        Record storage inRecord = records[tokenIn];
        Record storage outRecord = records[tokenOut];

        require(amountIn <= _mul(inRecord.reserve, MAX_IN_RATIO), ""MAX_IN_RATIO"");

        amountOut = _getAmountOut(amountIn, inRecord.reserve, inRecord.weight, outRecord.reserve, outRecord.weight);

        ITridentCallee(msg.sender).tridentSwapCallback(context);
        // @dev Check Trident router has sent `amountIn` for skim into pool.
        unchecked {
            // @dev This is safe from under/overflow - only logged amounts handled.
            require(_balance(tokenIn) >= amountIn + inRecord.reserve, ""NOT_RECEIVED"");
            inRecord.reserve += uint120(amountIn);
            outRecord.reserve -= uint120(amountOut);
        }
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }

    /// @dev Updates `barFee` for Trident protocol.
    function updateBarFee() public {
        (, bytes memory _barFee) = masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));
        barFee = abi.decode(_barFee, (uint256));
    }

    function _balance(address token) internal view returns (uint256 balance) {
        (, bytes memory data) = bento.staticcall(abi.encodeWithSelector(IBentoBoxMinimal.balanceOf.selector, token, address(this)));
        balance = abi.decode(data, (uint256));
    }

    function _getAmountOut(
        uint256 tokenInAmount,
        uint256 tokenInBalance,
        uint256 tokenInWeight,
        uint256 tokenOutBalance,
        uint256 tokenOutWeight
    ) internal view returns (uint256 amountOut) {
        uint256 weightRatio = _div(tokenInWeight, tokenOutWeight);
        // @dev This is safe from under/overflow - only logged amounts handled.
        unchecked {
            uint256 adjustedIn = _mul(tokenInAmount, (BASE - swapFee));
            uint256 a = _div(tokenInBalance, tokenInBalance + adjustedIn);
            uint256 b = _compute(a, weightRatio);
            uint256 c = BASE - b;
            amountOut = _mul(tokenOutBalance, c);
        }
    }

    function _compute(uint256 base, uint256 exp) internal pure returns (uint256 output) {
        require(MIN_POW_BASE <= base && base <= MAX_POW_BASE, ""INVALID_BASE"");

        uint256 whole = (exp / BASE) * BASE;
        uint256 remain = exp - whole;
        uint256 wholePow = _pow(base, whole / BASE);

        if (remain == 0) output = wholePow;

        uint256 partialResult = _powApprox(base, remain, POW_PRECISION);
        output = _mul(wholePow, partialResult);
    }

    function _computeSingleOutGivenPoolIn(
        uint256 tokenOutBalance,
        uint256 tokenOutWeight,
        uint256 _totalSupply,
        uint256 _totalWeight,
        uint256 toBurn,
        uint256 _swapFee
    ) internal pure returns (uint256 amountOut) {
        uint256 normalizedWeight = _div(tokenOutWeight, _totalWeight);
        uint256 newPoolSupply = _totalSupply - toBurn;
        uint256 poolRatio = _div(newPoolSupply, _totalSupply);
        uint256 tokenOutRatio = _pow(poolRatio, _div(BASE, normalizedWeight));
        uint256 newBalanceOut = _mul(tokenOutRatio, tokenOutBalance);
        uint256 tokenAmountOutBeforeSwapFee = tokenOutBalance - newBalanceOut;
        uint256 zaz = (BASE - normalizedWeight) * _swapFee;
        amountOut = _mul(tokenAmountOutBeforeSwapFee, (BASE - zaz));
    }

    function _pow(uint256 a, uint256 n) internal pure returns (uint256 output) {
        output = n % 2 != 0 ? a : BASE;
        for (n /= 2; n != 0; n /= 2) a = a * a;
        if (n % 2 != 0) output = output * a;
    }

    function _powApprox(
        uint256 base,
        uint256 exp,
        uint256 precision
    ) internal pure returns (uint256 sum) {
        uint256 a = exp;
        (uint256 x, bool xneg) = _subFlag(base, BASE);
        uint256 term = BASE;
        sum = term;
        bool negative;

        for (uint256 i = 1; term >= precision; i++) {
            uint256 bigK = i * BASE;
            (uint256 c, bool cneg) = _subFlag(a, (bigK - BASE));
            term = _mul(term, _mul(c, x));
            term = _div(term, bigK);
            if (term == 0) break;
            if (xneg) negative = !negative;
            if (cneg) negative = !negative;
            if (negative) {
                sum = sum - term;
            } else {
                sum = sum + term;
            }
        }
    }

    function _subFlag(uint256 a, uint256 b) internal pure returns (uint256 difference, bool flag) {
        // @dev This is safe from underflow - if/else flow performs checks.
        unchecked {
            if (a >= b) {
                (difference, flag) = (a - b, false);
            } else {
                (difference, flag) = (b - a, true);
            }
        }
    }

    function _mul(uint256 a, uint256 b) internal pure returns (uint256 c2) {
        uint256 c0 = a * b;
        uint256 c1 = c0 + (BASE / 2);
        c2 = c1 / BASE;
    }

    function _div(uint256 a, uint256 b) internal pure returns (uint256 c2) {
        uint256 c0 = a * BASE;
        uint256 c1 = c0 + (b / 2);
        c2 = c1 / b;
    }

    function _transfer(
        address token,
        uint256 shares,
        address to,
        bool unwrapBento
    ) internal {
        if (unwrapBento) {
            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.withdraw.selector, token, address(this), to, 0, shares));
            require(success, ""WITHDRAW_FAILED"");
        } else {
            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.transfer.selector, token, address(this), to, shares));
            require(success, ""TRANSFER_FAILED"");
        }
    }

    function getAssets() public view override returns (address[] memory assets) {
        assets = tokens;
    }

    function getAmountOut(bytes calldata data) public view override returns (uint256 amountOut) {
        (uint256 tokenInAmount, uint256 tokenInBalance, uint256 tokenInWeight, uint256 tokenOutBalance, uint256 tokenOutWeight) = abi
            .decode(data, (uint256, uint256, uint256, uint256, uint256));
        amountOut = _getAmountOut(tokenInAmount, tokenInBalance, tokenInWeight, tokenOutBalance, tokenOutWeight);
    }

    function getReservesAndWeights() public view returns (uint256[] memory reserves, uint136[] memory weights) {
        uint256 length = tokens.length;
        reserves = new uint256[](length);
        weights = new uint136[](length);
        // @dev This is safe from overflow - `tokens` `length` is bound to '8'.
        unchecked {
            for (uint256 i = 0; i < length; i++) {
                reserves[i] = records[tokens[i]].reserve;
                weights[i] = records[tokens[i]].weight;
            }
        }
    }
}",3873
RealWorld_BA_35_ERC20Mock_RealWord_20240820085146.log,35,ERC20Mock,6061,4844,10905,88.0,0.127185,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity ^0.8.2;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract ERC20Mock is ERC20 {
    event Deposit(address indexed dst, uint256 wad);
    event Withdrawal(address indexed src, uint256 wad);

    constructor(
        string memory name,
        string memory symbol,
        uint256 supply
    ) ERC20(name, symbol) {
        _mint(msg.sender, supply);
    }

    receive() external payable {
        deposit();
    }

    function deposit() public payable {
        _mint(msg.sender, msg.value);
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 wad) public {
        _burn(msg.sender, wad);
        payable(msg.sender).transfer(wad);
        emit Withdrawal(msg.sender, wad);
    }
}",188
RealWorld_BA_35_TridentRouter_RealWord_20240820084733.log,35,TridentRouter,68985,5452,74437,98.0,0.453965,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""./interfaces/IBentoBoxMinimal.sol"";
import ""./interfaces/IPool.sol"";
import ""./interfaces/ITridentRouter.sol"";
import ""./utils/TridentHelper.sol"";
import ""./deployer/MasterDeployer.sol"";
import ""hardhat/console.sol"";

/// @notice Router contract that helps in swapping across Trident pools.
contract TridentRouter is ITridentRouter, TridentHelper {
    /// @notice BentoBox token vault.
    IBentoBoxMinimal public immutable bento;
    MasterDeployer public immutable masterDeployer;

    /// @dev Used to ensure that `tridentSwapCallback` is called only by the authorized address.
    /// These are set when someone calls a flash swap and reset afterwards.
    address internal cachedMsgSender;
    address internal cachedPool;

    mapping(address => bool) internal whitelistedPools;

    constructor(
        IBentoBoxMinimal _bento,
        MasterDeployer _masterDeployer,
        address _wETH
    ) TridentHelper(_wETH) {
        _bento.registerProtocol();
        bento = _bento;
        masterDeployer = _masterDeployer;
    }

    receive() external payable {
        require(msg.sender == wETH);
    }

    /// @notice Swaps token A to token B directly. Swaps are done on `bento` tokens.
    /// @param params This includes the address of token A, pool, amount of token A to swap,
    /// minimum amount of token B after the swap and data required by the pool for the swap.
    /// @dev Ensure that the pool is trusted before calling this function. The pool can steal users' tokens.
    function exactInputSingle(ExactInputSingleParams calldata params) public payable returns (uint256 amountOut) {
        // @dev Prefund the pool with token A.
        bento.transfer(params.tokenIn, msg.sender, params.pool, params.amountIn);
        // @dev Trigger the swap in the pool.
        amountOut = IPool(params.pool).swap(params.data);
        // @dev Ensure that the slippage wasn't too much. This assumes that the pool is honest.
        require(amountOut >= params.amountOutMinimum, ""TOO_LITTLE_RECEIVED"");
    }

    /// @notice Swaps token A to token B indirectly by using multiple hops.
    /// @param params This includes the addresses of the tokens, pools, amount of token A to swap,
    /// minimum amount of token B after the swap and data required by the pools for the swaps.
    /// @dev Ensure that the pools are trusted before calling this function. The pools can steal users' tokens.
    function exactInput(ExactInputParams calldata params) public payable returns (uint256 amountOut) {
        // @dev Pay the first pool directly.
        bento.transfer(params.tokenIn, msg.sender, params.path[0].pool, params.amountIn);
        // @dev Call every pool in the path.
        // Pool `N` should transfer its output tokens to pool `N+1` directly.
        // The last pool should transfer its output tokens to the user.
        // If the user wants to unwrap `wETH`, the final destination should be this contract and
        // a batch call should be made to `unwrapWETH`.
        for (uint256 i; i < params.path.length; i++) {
            // We don't necessarily need this check but saving users from themseleves.
            isWhiteListed(params.path[i].pool);
            amountOut = IPool(params.path[i].pool).swap(params.path[i].data);
        }
        // @dev Ensure that the slippage wasn't too much. This assumes that the pool is honest.
        require(amountOut >= params.amountOutMinimum, ""TOO_LITTLE_RECEIVED"");
    }

    /// @notice Swaps token A to token B by using callbacks.
    /// @param path Addresses of the pools and data required by the pools for the swaps.
    /// @param amountOutMinimum Minimum amount of token B after the swap.
    /// @dev Ensure that the pools are trusted before calling this function. The pools can steal users' tokens.
    /// This function will unlikely be used in production but it shows how to use callbacks. One use case will be arbitrage.
    function exactInputLazy(uint256 amountOutMinimum, Path[] calldata path) public payable returns (uint256 amountOut) {
        // @dev Call every pool in the path.
        // Pool `N` should transfer its output tokens to pool `N+1` directly.
        // The last pool should transfer its output tokens to the user.
        for (uint256 i; i < path.length; i++) {
            isWhiteListed(path[i].pool);
            // @dev The cached `msg.sender` is used as the funder when the callback happens.
            cachedMsgSender = msg.sender;
            // @dev The cached pool must be the address that calls the callback.
            cachedPool = path[i].pool;
            amountOut = IPool(path[i].pool).flashSwap(path[i].data);
        }
        // @dev Resets the `cachedPool` to get a refund.
        // `1` is used as the default value to avoid the storage slot being released.
        cachedMsgSender = address(1);
        cachedPool = address(1);
        require(amountOut >= amountOutMinimum, ""TOO_LITTLE_RECEIVED"");
    }

    /// @notice Swaps token A to token B directly. It's the same as `exactInputSingle` except
    /// it takes raw ERC-20 tokens from the users and deposits them into `bento`.
    /// @param params This includes the address of token A, pool, amount of token A to swap,
    /// minimum amount of token B after the swap and data required by the pool for the swap.
    /// @dev Ensure that the pool is trusted before calling this function. The pool can steal users' tokens.
    function exactInputSingleWithNativeToken(ExactInputSingleParams calldata params) public payable returns (uint256 amountOut) {
        // @dev Deposits the native ERC-20 token from the user into the pool's `bento`.
        _depositToBentoBox(params.tokenIn, params.pool, params.amountIn);
        // @dev Trigger the swap in the pool.
        amountOut = IPool(params.pool).swap(params.data);
        // @dev Ensure that the slippage wasn't too much. This assumes that the pool is honest.
        require(amountOut >= params.amountOutMinimum, ""TOO_LITTLE_RECEIVED"");
    }

    /// @notice Swaps token A to token B indirectly by using multiple hops. It's the same as `exactInput` except
    /// it takes raw ERC-20 tokens from the users and deposits them into `bento`.
    /// @param params This includes the addresses of the tokens, pools, amount of token A to swap,
    /// minimum amount of token B after the swap and data required by the pools for the swaps.
    /// @dev Ensure that the pools are trusted before calling this function. The pools can steal users' tokens.
    function exactInputWithNativeToken(ExactInputParams calldata params) public payable returns (uint256 amountOut) {
        // @dev Deposits the native ERC-20 token from the user into the pool's `bento`.
        _depositToBentoBox(params.tokenIn, params.path[0].pool, params.amountIn);
        // @dev Call every pool in the path.
        // Pool `N` should transfer its output tokens to pool `N+1` directly.
        // The last pool should transfer its output tokens to the user.
        for (uint256 i; i < params.path.length; i++) {
            isWhiteListed(params.path[i].pool);
            amountOut = IPool(params.path[i].pool).swap(params.path[i].data);
        }
        // @dev Ensure that the slippage wasn't too much. This assumes that the pool is honest.
        require(amountOut >= params.amountOutMinimum, ""TOO_LITTLE_RECEIVED"");
    }

    /// @notice Swaps multiple input tokens to multiple output tokens using multiple paths, in different percentages.
    /// For example, you can swap 50 DAI + 100 USDC into 60% ETH and 40% BTC.
    /// @param params This includes everything needed for the swap. Look at the `ComplexPathParams` struct for more details.
    /// @dev This function is not optimized for single swaps and should only be used in complex cases where
    /// the amounts are large enough that minimizing slippage by using multiple paths is worth the extra gas.
    function complexPath(ComplexPathParams calldata params) public payable {
        // @dev Deposit all initial tokens to respective pools and initiate the swaps.
        // Input tokens come from the user - output goes to following pools.
        for (uint256 i; i < params.initialPath.length; i++) {
            if (params.initialPath[i].native) {
                _depositToBentoBox(params.initialPath[i].tokenIn, params.initialPath[i].pool, params.initialPath[i].amount);
            } else {
                bento.transfer(params.initialPath[i].tokenIn, msg.sender, params.initialPath[i].pool, params.initialPath[i].amount);
            }
            isWhiteListed(params.initialPath[i].pool);
            IPool(params.initialPath[i].pool).swap(params.initialPath[i].data);
        }
        // @dev Do all the middle swaps. Input comes from previous pools - output goes to following pools.
        for (uint256 i; i < params.percentagePath.length; i++) {
            uint256 balanceShares = bento.balanceOf(params.percentagePath[i].tokenIn, address(this));
            uint256 transferShares = (balanceShares * params.percentagePath[i].balancePercentage) / uint256(10)**8;
            bento.transfer(params.percentagePath[i].tokenIn, address(this), params.percentagePath[i].pool, transferShares);
            isWhiteListed(params.percentagePath[i].pool);
            IPool(params.percentagePath[i].pool).swap(params.percentagePath[i].data);
        }
        // @dev Do all the final swaps. Input comes from previous pools - output goes to the user.
        for (uint256 i; i < params.output.length; i++) {
            uint256 balanceShares = bento.balanceOf(params.output[i].token, address(this));
            require(balanceShares >= params.output[i].minAmount, ""TOO_LITTLE_RECEIVED"");
            if (params.output[i].unwrapBento) {
                bento.withdraw(params.output[i].token, address(this), params.output[i].to, 0, balanceShares);
            } else {
                bento.transfer(params.output[i].token, address(this), params.output[i].to, balanceShares);
            }
        }
    }

    /// @notice Add liquidity to a pool.
    /// @param tokenInput Token address and amount to add as liquidity.
    /// @param pool Pool address to add liquidity to.
    /// @param minLiquidity Minimum output liquidity - caps slippage.
    /// @param data Data required by the pool to add liquidity.
    function addLiquidity(
        TokenInput[] memory tokenInput,
        address pool,
        uint256 minLiquidity,
        bytes calldata data
    ) public payable returns (uint256 liquidity) {
        isWhiteListed(pool);
        // @dev Send all input tokens to the pool.
        for (uint256 i; i < tokenInput.length; i++) {
            if (tokenInput[i].native) {
                _depositToBentoBox(tokenInput[i].token, pool, tokenInput[i].amount);
            } else {
                bento.transfer(tokenInput[i].token, msg.sender, pool, tokenInput[i].amount);
            }
        }
        liquidity = IPool(pool).mint(data);
        require(liquidity >= minLiquidity, ""NOT_ENOUGH_LIQUIDITY_MINTED"");
    }

    /// @notice Add liquidity to a pool using callbacks - same as `addLiquidity`, but now with callbacks.
    /// @dev The input tokens are sent to the pool during the callback.
    function addLiquidityLazy(
        address pool,
        uint256 minLiquidity,
        bytes calldata data
    ) public payable returns (uint256 liquidity) {
        isWhiteListed(pool);
        cachedMsgSender = msg.sender;
        cachedPool = pool;
        // @dev The pool must ensure that there's not too much slippage.
        liquidity = IPool(pool).mint(data);
        cachedMsgSender = address(1);
        cachedPool = address(1);
        require(liquidity >= minLiquidity, ""NOT_ENOUGH_LIQUIDITY_MINTED"");
    }

    /// @notice Burn liquidity tokens to get back `bento` tokens.
    /// @param pool Pool address.
    /// @param liquidity Amount of liquidity tokens to burn.
    /// @param data Data required by the pool to burn liquidity.
    /// @param minWithdrawals Minimum amount of `bento` tokens to be returned.
    function burnLiquidity(
        address pool,
        uint256 liquidity,
        bytes calldata data,
        IPool.TokenAmount[] memory minWithdrawals
    ) public {
        isWhiteListed(pool);
        safeTransferFrom(pool, msg.sender, pool, liquidity);
        IPool.TokenAmount[] memory withdrawnLiquidity = IPool(pool).burn(data);
        for (uint256 i; i < minWithdrawals.length; i++) {
            uint256 j;
            for (; j < withdrawnLiquidity.length; j++) {
                if (withdrawnLiquidity[j].token == minWithdrawals[i].token) {
                    require(withdrawnLiquidity[j].amount >= minWithdrawals[i].amount, ""TOO_LITTLE_RECEIVED"");
                    break;
                }
            }
            // @dev A token that is present in `minWithdrawals` is missing from `withdrawnLiquidity`.
            require(j < withdrawnLiquidity.length, ""INCORRECT_TOKEN_WITHDRAWN"");
        }
    }

    /// @notice Burn liquidity tokens to get back `bento` tokens.
    /// @dev The tokens are swapped automatically and the output is in a single token.
    /// @param pool Pool address.
    /// @param liquidity Amount of liquidity tokens to burn.
    /// @param data Data required by the pool to burn liquidity.
    /// @param minWithdrawal Minimum amount of tokens to be returned.
    function burnLiquiditySingle(
        address pool,
        uint256 liquidity,
        bytes calldata data,
        uint256 minWithdrawal
    ) public {
        isWhiteListed(pool);
        // @dev Use 'liquidity = 0' for prefunding.
        safeTransferFrom(pool, msg.sender, pool, liquidity);
        uint256 withdrawn = IPool(pool).burnSingle(data);
        require(withdrawn >= minWithdrawal, ""TOO_LITTLE_RECEIVED"");
    }

    /// @notice Used by the pool 'flashSwap' functionality to take input tokens from the user.
    function tridentSwapCallback(bytes calldata data) external {
        require(msg.sender == cachedPool, ""UNAUTHORIZED_CALLBACK"");
        TokenInput memory tokenInput = abi.decode(data, (TokenInput));
        // @dev Transfer the requested tokens to the pool.
        if (tokenInput.native) {
            _depositFromUserToBentoBox(tokenInput.token, cachedMsgSender, msg.sender, tokenInput.amount);
        } else {
            bento.transfer(tokenInput.token, cachedMsgSender, msg.sender, tokenInput.amount);
        }
        // @dev Resets the `msg.sender`'s authorization.
        cachedMsgSender = address(1);
    }

    /// @notice Can be used by the pool 'mint' functionality to take tokens from the user.
    function tridentMintCallback(bytes calldata data) external {
        require(msg.sender == cachedPool, ""UNAUTHORIZED_CALLBACK"");
        TokenInput[] memory tokenInput = abi.decode(data, (TokenInput[]));
        // @dev Transfer the requested tokens to the pool.
        for (uint256 i; i < tokenInput.length; i++) {
            if (tokenInput[i].native) {
                _depositFromUserToBentoBox(tokenInput[i].token, cachedMsgSender, msg.sender, tokenInput[i].amount);
            } else {
                bento.transfer(tokenInput[i].token, cachedMsgSender, msg.sender, tokenInput[i].amount);
            }
        }
        // @dev Resets the `msg.sender`'s authorization.
        cachedMsgSender = address(1);
    }

    /// @notice Recover mistakenly sent `bento` tokens.
    function sweepBentoBoxToken(
        address token,
        uint256 amount,
        address recipient
    ) external {
        bento.transfer(token, address(this), recipient, amount);
    }

    /// @notice Recover mistakenly sent ERC-20 tokens.
    function sweepNativeToken(
        address token,
        uint256 amount,
        address recipient
    ) external {
        safeTransfer(token, recipient, amount);
    }

    /// @notice Recover mistakenly sent ETH.
    function refundETH() external payable {
        if (address(this).balance != 0) safeTransferETH(msg.sender, address(this).balance);
    }

    /// @notice Unwrap this contract's `wETH` into ETH
    function unwrapWETH(uint256 amountMinimum, address recipient) external {
        uint256 balanceWETH = balanceOfThis(wETH);
        require(balanceWETH >= amountMinimum, ""INSUFFICIENT_WETH"");
        if (balanceWETH != 0) {
            withdrawFromWETH(balanceWETH);
            safeTransferETH(recipient, balanceWETH);
        }
    }

    function deployPool(address _factory, bytes calldata _deployData) external returns (address) {
        return masterDeployer.deployPool(_factory, _deployData);
    }

    function _depositToBentoBox(
        address token,
        address recipient,
        uint256 amount
    ) internal {
        if (token == wETH && address(this).balance != 0) {
            uint256 underlyingAmount = bento.toAmount(wETH, amount, true);
            if (address(this).balance >= underlyingAmount) {
                // @dev Deposit ETH into `recipient` `bento` account.
                bento.deposit{value: underlyingAmount}(address(0), address(this), recipient, 0, amount);
                return;
            }
        }
        // @dev Deposit ERC-20 token into `recipient` `bento` account.
        bento.deposit(token, msg.sender, recipient, 0, amount);
    }

    function _depositFromUserToBentoBox(
        address token,
        address sender,
        address recipient,
        uint256 amount
    ) internal {
        if (token == wETH && address(this).balance != 0) {
            uint256 underlyingAmount = bento.toAmount(wETH, amount, true);
            if (address(this).balance >= underlyingAmount) {
                // @dev Deposit ETH into `recipient` `bento` account.
                bento.deposit{value: underlyingAmount}(address(0), address(this), recipient, 0, amount);
                return;
            }
        }
        // @dev Deposit ERC-20 token into `recipient` `bento` account.
        bento.deposit(token, sender, recipient, 0, amount);
    }

    function isWhiteListed(address pool) internal {
        if (!whitelistedPools[pool]) {
            require(masterDeployer.pools(pool), ""INVALID POOL"");
            whitelistedPools[pool] = true;
        }
    }
}",4163
RealWorld_BA_35_WETH9_RealWord_20240820084913.log,35,WETH9,3864,4424,8288,78.0,0.1078,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity ^0.8.2;

import ""./ERC20Mock.sol"";

contract WETH9 is ERC20Mock {
    constructor() ERC20Mock(""WETH9"", ""WETH9"", 0) {}
}",60
RealWorld_BA_35_IConcentratedLiquidityPool_RealWord_20240820095245.log,35,IConcentratedLiquidityPool,7157,4930,12087,87.0,0.134385,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""./IPool.sol"";

/// @notice Trident Concentrated Liquidity Pool interface.
interface IConcentratedLiquidityPool is IPool {
    struct Tick {
        int24 previousTick;
        int24 nextTick;
        uint128 liquidity;
        uint256 feeGrowthOutside0;
        uint256 feeGrowthOutside1;
        uint160 secondsPerLiquidityOutside;
    }

    function price() external view returns (uint160);

    function token0() external view returns (address);

    function token1() external view returns (address);

    function ticks(int24 _tick) external view returns (Tick memory tick);

    function feeGrowthGlobal0() external view returns (uint256);

    function rangeSecondsInside(int24 lowerTick, int24 upperTick) external view returns (uint256);

    function rangeFeeGrowth(int24 lowerTick, int24 upperTick) external view returns (uint256 feeGrowthInside0, uint256 feeGrowthInside1);

    function collect(
        int24,
        int24,
        address,
        bool
    ) external returns (uint256 amount0fees, uint256 amount1fees);
}",264
RealWorld_BA_35_MasterDeployer_RealWord_20240820085421.log,35,MasterDeployer,11824,5394,17218,95.0,0.167,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../interfaces/IPoolFactory.sol"";
import ""../utils/TridentOwnable.sol"";

/// @notice Trident pool deployer contract with template factory whitelist.
/// @author Mudit Gupta.
contract MasterDeployer is TridentOwnable {
    event DeployPool(address indexed factory, address indexed pool, bytes deployData);
    event AddToWhitelist(address indexed factory);
    event RemoveFromWhitelist(address indexed factory);
    event BarFeeUpdated(uint256 indexed barFee);
    event MigratorUpdated(address indexed migrator);

    uint256 public barFee;
    address public migrator;

    address public immutable barFeeTo;
    address public immutable bento;

    uint256 internal constant MAX_FEE = 10000; // @dev 100%.

    mapping(address => bool) public pools;
    mapping(address => bool) public whitelistedFactories;

    constructor(
        uint256 _barFee,
        address _barFeeTo,
        address _bento
    ) {
        require(_barFee <= MAX_FEE, ""INVALID_BAR_FEE"");
        require(_barFeeTo != address(0), ""ZERO_ADDRESS"");
        require(_bento != address(0), ""ZERO_ADDRESS"");

        barFee = _barFee;
        barFeeTo = _barFeeTo;
        bento = _bento;
    }

    function deployPool(address _factory, bytes calldata _deployData) external returns (address pool) {
        require(whitelistedFactories[_factory], ""FACTORY_NOT_WHITELISTED"");
        pool = IPoolFactory(_factory).deployPool(_deployData);
        pools[pool] = true;
        emit DeployPool(_factory, pool, _deployData);
    }

    function addToWhitelist(address _factory) external onlyOwner {
        whitelistedFactories[_factory] = true;
        emit AddToWhitelist(_factory);
    }

    function removeFromWhitelist(address _factory) external onlyOwner {
        whitelistedFactories[_factory] = false;
        emit RemoveFromWhitelist(_factory);
    }

    function setBarFee(uint256 _barFee) external onlyOwner {
        require(_barFee <= MAX_FEE, ""INVALID_BAR_FEE"");
        barFee = _barFee;
        emit BarFeeUpdated(_barFee);
    }

    function setMigrator(address _migrator) external onlyOwner {
        migrator = _migrator;
        emit MigratorUpdated(_migrator);
    }
}",538
RealWorld_BA_35_PoolFactory_RealWord_20240820091651.log,35,PoolFactory,4530,4001,8531,68.0,0.10267,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity ^0.8.2;

import ""../interfaces/IPoolFactory.sol"";

import ""./PoolTemplate.sol"";

/**
 * @author Mudit Gupta
 */
contract PoolFactory is IPoolFactory {
    // Consider deploying via an upgradable proxy to allow upgrading pools in the future

    function deployPool(bytes memory _deployData) external override returns (address) {
        return address(new PoolTemplate(_deployData));
    }
}",101
RealWorld_BA_35_ConcentratedLiquidityPoolManager_RealWord_20240820093220.log,35,ConcentratedLiquidityPoolManager,23742,5459,29201,98.0,0.22789,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../../interfaces/IConcentratedLiquidityPool.sol"";
import ""./ConcentratedLiquidityPosition.sol"";

/// @notice Trident Concentrated Liquidity Pool periphery contract that combines non-fungible position management and staking.
contract ConcentratedLiquidityPoolManager is ConcentratedLiquidityPosition {
    event AddIncentive(IConcentratedLiquidityPool indexed pool, Incentive indexed incentive);
    event ReclaimIncentive(IConcentratedLiquidityPool indexed pool, uint256 indexed incentiveId);
    event Subscribe(uint256 indexed positionId, uint256 indexed incentiveId);
    event ClaimReward(uint256 indexed positionId, uint256 indexed incentiveId, address indexed recipient);

    struct Incentive {
        address owner;
        address token;
        uint256 rewardsUnclaimed;
        uint160 secondsClaimed; // @dev x128.
        uint32 startTime;
        uint32 endTime;
        uint32 expiry;
    }

    struct Stake {
        uint160 secondsInsideLast; // @dev x128.
        bool initialized;
    }

    mapping(IConcentratedLiquidityPool => uint256) public incentiveCount;
    mapping(IConcentratedLiquidityPool => mapping(uint256 => Incentive)) public incentives;
    mapping(uint256 => mapping(uint256 => Stake)) public stakes;

    constructor(address wETH, address _masterDeployer) ConcentratedLiquidityPosition(wETH, _masterDeployer) {}

    function addIncentive(IConcentratedLiquidityPool pool, Incentive memory incentive) public {
        uint32 current = uint32(block.timestamp);
        require(current <= incentive.startTime, ""ALREADY_STARTED"");
        require(current <= incentive.endTime, ""ALREADY_ENDED"");
        require(incentive.startTime < incentive.endTime, ""START_PAST_END"");
        require(incentive.endTime + 5 weeks < incentive.expiry, ""END_PAST_BUFFER"");
        require(incentive.rewardsUnclaimed != 0, ""NO_REWARDS"");
        incentives[pool][incentiveCount[pool]++] = incentive;
        _transfer(incentive.token, msg.sender, address(this), incentive.rewardsUnclaimed, false);
        emit AddIncentive(pool, incentive);
    }

    /// @dev Withdraws any unclaimed incentive rewards.
    function reclaimIncentive(
        IConcentratedLiquidityPool pool,
        uint256 incentiveId,
        uint256 amount,
        address receiver,
        bool unwrapBento
    ) public {
        Incentive storage incentive = incentives[pool][incentiveId];
        require(incentive.owner == msg.sender, ""NOT_OWNER"");
        require(incentive.expiry < block.timestamp, ""EXPIRED"");
        require(incentive.rewardsUnclaimed >= amount, ""ALREADY_CLAIMED"");
        _transfer(incentive.token, address(this), receiver, amount, unwrapBento);
        emit ReclaimIncentive(pool, incentiveId);
    }

    /// @dev Subscribes a non-fungible position token to an incentive.
    function subscribe(uint256 positionId, uint256 incentiveId) public {
        Position memory position = positions[positionId];
        IConcentratedLiquidityPool pool = position.pool;
        Incentive memory incentive = incentives[pool][positionId];
        Stake storage stake = stakes[positionId][incentiveId];
        require(position.liquidity != 0, ""INACTIVE"");
        require(stake.secondsInsideLast == 0, ""SUBSCRIBED"");
        require(incentiveId <= incentiveCount[pool], ""NOT_INCENTIVE"");
        require(block.timestamp > incentive.startTime && block.timestamp < incentive.endTime, ""TIMED_OUT"");
        stakes[positionId][incentiveId] = Stake(uint160(pool.rangeSecondsInside(position.lower, position.upper)), true);
        emit Subscribe(positionId, incentiveId);
    }

    function claimReward(
        uint256 positionId,
        uint256 incentiveId,
        address recipient,
        bool unwrapBento
    ) public {
        require(ownerOf[positionId] == msg.sender, ""OWNER"");
        Position memory position = positions[positionId];
        IConcentratedLiquidityPool pool = position.pool;
        Incentive storage incentive = incentives[position.pool][positionId];
        Stake storage stake = stakes[positionId][incentiveId];
        require(stake.initialized, ""UNINITIALIZED"");
        uint256 secondsPerLiquidityInside = pool.rangeSecondsInside(position.lower, position.upper) - stake.secondsInsideLast;
        uint256 secondsInside = secondsPerLiquidityInside * position.liquidity;
        uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;
        uint256 secondsUnclaimed = (maxTime - incentive.startTime) << (128 - incentive.secondsClaimed);
        uint256 rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;
        incentive.rewardsUnclaimed -= rewards;
        incentive.secondsClaimed += uint160(secondsInside);
        stake.secondsInsideLast += uint160(secondsPerLiquidityInside);
        _transfer(incentive.token, address(this), recipient, rewards, unwrapBento);
        emit ClaimReward(positionId, incentiveId, recipient);
    }

    function getReward(uint256 positionId, uint256 incentiveId) public view returns (uint256 rewards, uint256 secondsInside) {
        Position memory position = positions[positionId];
        IConcentratedLiquidityPool pool = position.pool;
        Incentive memory incentive = incentives[pool][positionId];
        Stake memory stake = stakes[positionId][incentiveId];
        if (stake.initialized) {
            secondsInside = (pool.rangeSecondsInside(position.lower, position.upper) - stake.secondsInsideLast) * position.liquidity;
            uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;
            uint256 secondsUnclaimed = (maxTime - incentive.startTime) << (128 - incentive.secondsClaimed);
            rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;
        }
    }
}",1294
RealWorld_BA_35_FullMath_RealWord_20240820090832.log,35,FullMath,24334,4950,29284,81.0,0.22067,"// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

/// @notice Math library that facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision.
/// @author Adapted from https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/FullMath.sol.
/// @dev Handles ""phantom overflow"", i.e., allows multiplication and division where an intermediate value overflows 256 bits.
library FullMath {
    /// @notice Calculates floor(abdenominator) with full precision - throws if result overflows an uint256 or denominator == 0.
    /// @param a The multiplicand.
    /// @param b The multiplier.
    /// @param denominator The divisor.
    /// @return result The 256-bit result.
    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.
    function mulDiv(
        uint256 a,
        uint256 b,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        unchecked {
            // @dev 512-bit multiply [prod1 prod0] = a * b.
            // Compute the product mod 2**256 and mod 2**256 - 1,
            // then use the Chinese Remainder Theorem to reconstruct
            // the 512 bit result. The result is stored in two 256
            // variables such that product = prod1 * 2**256 + prod0.
            uint256 prod0; // @dev Least significant 256 bits of the product.
            uint256 prod1; // @dev Most significant 256 bits of the product.
            assembly {
                let mm := mulmod(a, b, not(0))
                prod0 := mul(a, b)
                prod1 := sub(sub(mm, prod0), lt(mm, prod0))
            }
            // @dev Handle non-overflow cases, 256 by 256 division.
            if (prod1 == 0) {
                require(denominator > 0);
                assembly {
                    result := div(prod0, denominator)
                }
                return result;
            }
            // @dev Make sure the result is less than 2**256 -
            // also prevents denominator == 0.
            require(denominator > prod1);
            ///////////////////////////////////////////////
            // 512 by 256 division.
            ///////////////////////////////////////////////
            // @dev Make division exact by subtracting the remainder from [prod1 prod0] -
            // compute remainder using mulmod.
            uint256 remainder;
            assembly {
                remainder := mulmod(a, b, denominator)
            }
            // @dev Subtract 256 bit number from 512 bit number.
            assembly {
                prod1 := sub(prod1, gt(remainder, prod0))
                prod0 := sub(prod0, remainder)
            }
            // @dev Factor powers of two out of denominator -
            // compute largest power of two divisor of denominator
            // (always >= 1).
            uint256 twos = uint256(-int256(denominator)) & denominator;
            // @dev Divide denominator by power of two.
            assembly {
                denominator := div(denominator, twos)
            }
            // @dev Divide [prod1 prod0] by the factors of two.
            assembly {
                prod0 := div(prod0, twos)
            }
            // @dev Shift in bits from prod1 into prod0. For this we need
            // to flip `twos` such that it is 2**256 / twos -
            // if twos is zero, then it becomes one.
            assembly {
                twos := add(div(sub(0, twos), twos), 1)
            }
            prod0 |= prod1 * twos;
            // @dev Invert denominator mod 2**256 -
            // now that denominator is an odd number, it has an inverse
            // modulo 2**256 such that denominator * inv = 1 mod 2**256.
            // Compute the inverse by starting with a seed that is correct
            // for four bits. That is, denominator * inv = 1 mod 2**4.
            uint256 inv = (3 * denominator) ^ 2;
            // @dev Now use Newton-Raphson iteration to improve the precision.
            // Thanks to Hensel's lifting lemma, this also works in modular
            // arithmetic, doubling the correct bits in each step.
            inv *= 2 - denominator * inv; // @dev Inverse mod 2**8.
            inv *= 2 - denominator * inv; // @dev Inverse mod 2**16.
            inv *= 2 - denominator * inv; // @dev Inverse mod 2**32.
            inv *= 2 - denominator * inv; // @dev Inverse mod 2**64.
            inv *= 2 - denominator * inv; // @dev Inverse mod 2**128.
            inv *= 2 - denominator * inv; // @dev Inverse mod 2**256.
            // @dev Because the division is now exact we can divide by multiplying
            // with the modular inverse of denominator. This will give us the
            // correct result modulo 2**256. Since the precoditions guarantee
            // that the outcome is less than 2**256, this is the final result.
            // We don't need to compute the high bits of the result and prod1
            // is no longer required.
            result = prod0 * inv;
            return result;
        }
    }

    /// @notice Calculates ceil(abdenominator) with full precision - throws if result overflows an uint256 or denominator == 0.
    /// @param a The multiplicand.
    /// @param b The multiplier.
    /// @param denominator The divisor.
    /// @return result The 256-bit result.
    function mulDivRoundingUp(
        uint256 a,
        uint256 b,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        result = mulDiv(a, b, denominator);
        unchecked {
            if (mulmod(a, b, denominator) != 0) {
                require(result < type(uint256).max);
                result++;
            }
        }
    }
}",1323
RealWorld_BA_35_IPoolFactory_RealWord_20240820095726.log,35,IPoolFactory,3723,3956,7679,65.0,0.097735,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice Trident pool deployment interface.
interface IPoolFactory {
    function deployPool(bytes calldata _deployData) external returns (address pool);
}",54
RealWorld_BA_35_RebaseLibrary_RealWord_20240820090256.log,35,RebaseLibrary,6630,4973,11603,69.0,0.13261,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity ^0.8;

struct Rebase {
    uint128 elastic;
    uint128 base;
}

/// @notice A rebasing library
library RebaseLibrary {
    /// @notice Calculates the base value in relationship to `elastic` and `total`.
    function toBase(Rebase memory total, uint256 elastic) internal pure returns (uint256 base) {
        if (total.elastic == 0) {
            base = elastic;
        } else {
            base = (elastic * total.base) / total.elastic;
        }
    }

    /// @notice Calculates the elastic value in relationship to `base` and `total`.
    function toElastic(Rebase memory total, uint256 base) internal pure returns (uint256 elastic) {
        if (total.base == 0) {
            elastic = base;
        } else {
            elastic = (base * total.elastic) / total.base;
        }
    }
}",208
RealWorld_BA_35_IndexPoolFactory_RealWord_20240820092105.log,35,IndexPoolFactory,6728,5140,11868,86.0,0.13644,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""./IndexPool.sol"";
import ""./PoolDeployer.sol"";

/// @notice Contract for deploying Trident exchange Index Pool with configurations.
/// @author Mudit Gupta
contract IndexPoolFactory is PoolDeployer {
    constructor(address _masterDeployer) PoolDeployer(_masterDeployer) {}

    function deployPool(bytes memory _deployData) external returns (address pool) {
        (address[] memory tokens, uint136[] memory weights, uint256 swapFee) = abi.decode(_deployData, (address[], uint136[], uint256));

        // @dev Strips any extra data.
        _deployData = abi.encode(tokens, weights, swapFee);

        // @dev Salt is not actually needed since `_deployData` is part of creationCode and already contains the salt.
        bytes32 salt = keccak256(_deployData);
        pool = address(new IndexPool{salt: salt}(_deployData, masterDeployer));
        _registerPool(pool, tokens, salt);
    }
}",227
RealWorld_BA_35_WhiteListManager_RealWord_20240820094435.log,35,WhiteListManager,23703,5905,29608,109.0,0.236615,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

contract WhiteListManager {
    event WhiteListAccount(address indexed operator, address indexed account, bool approved);
    event SetMerkleRoot(address operator, bytes32 merkleRoot);
    event JoinWithMerkle(address operator, uint256 indexed index, address indexed account);

    /// @notice EIP-712 related variables and functions.
    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = ""\x19\x01"";
    bytes32 private constant APPROVAL_SIGNATURE_HASH = keccak256(""SetWhitelisting(address account,bool approved,uint256 deadline)"");
    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH =
        keccak256(""EIP712Domain(string name,uint256 chainId,address verifyingContract)"");
    bytes32 private immutable _DOMAIN_SEPARATOR;
    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;

    mapping(address => mapping(address => bool)) public whitelistedAccounts;

    /// @notice Merkle root variables.
    mapping(address => bytes32) public merkleRoot;
    /// @notice Packed array of booleans.
    mapping(address => mapping(uint256 => uint256)) internal whitelistedBitMap;

    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32 domainSeperator) {
        domainSeperator = keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, keccak256(""WhiteListManager""), chainId, address(this)));
    }

    function DOMAIN_SEPARATOR() public view returns (bytes32 domainSeperator) {
        domainSeperator = block.chainid == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(block.chainid);
    }

    constructor() {
        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = block.chainid);
    }

    function whitelistAccount(address user, bool approved) external {
        _whitelistAccount(msg.sender, user, approved);
    }

    function _whitelistAccount(
        address operator,
        address account,
        bool approved
    ) private {
        whitelistedAccounts[operator][account] = approved;
        emit WhiteListAccount(operator, account, approved);
    }

    /// @notice Approves or revokes whitelisting for accounts.
    /// @param operator The address of the operator that approves or revokes access.
    /// @param account The address who gains or loses access.
    /// @param approved If 'true', approves access - if 'false', revokes access.
    /// @param deadline The time at which to expire the signature.
    /// @param v The recovery byte of the signature.
    /// @param r Half of the ECDSA signature pair.
    /// @param s Half of the ECDSA signature pair.
    function setWhitelisting(
        address operator,
        address account,
        bool approved,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        // @dev Checks:
        require(account != address(0), ""ACCOUNT_NOT_SET"");
        // - also, ecrecover returns address(0) on failure. So we check this, even if the modifier should prevent it:
        require(operator != address(0), ""OPERATOR_NULL"");
        require(deadline >= block.timestamp && deadline <= (block.timestamp + 1 weeks), ""EXPIRED"");

        bytes32 digest = keccak256(
            abi.encodePacked(
                EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,
                DOMAIN_SEPARATOR(),
                keccak256(abi.encode(APPROVAL_SIGNATURE_HASH, account, approved, deadline))
            )
        );

        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress == operator, ""INVALID_SIGNATURE"");

        _whitelistAccount(operator, account, approved);
    }

    /// **** WHITELISTING
    /// @dev Adapted from OpenZeppelin utilities and Uniswap merkle distributor.
    function isWhitelisted(address operator, uint256 index) public view returns (bool success) {
        uint256 whitelistedWordIndex = index / 256;
        uint256 whitelistedBitIndex = index % 256;
        uint256 claimedWord = whitelistedBitMap[operator][whitelistedWordIndex];
        uint256 mask = (1 << whitelistedBitIndex);
        success = claimedWord & mask == mask;
    }

    function joinWhitelist(
        address operator,
        uint256 index,
        address account,
        bytes32[] calldata merkleProof
    ) external {
        require(!isWhitelisted(operator, index), ""CLAIMED"");
        bytes32 node = keccak256(abi.encodePacked(index, account));
        bytes32 computedHash = node;
        for (uint256 i = 0; i < merkleProof.length; i++) {
            bytes32 proofElement = merkleProof[i];
            if (computedHash <= proofElement) {
                // @dev Hash(current computed hash + current element of the proof).
                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
            } else {
                // @dev Hash(current element of the proof + current computed hash).
                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
            }
        }
        // @dev Check if the computed hash (root) is equal to the provided root.
        require(computedHash == merkleRoot[operator], ""NOT_ROOTED"");
        uint256 whitelistedWordIndex = index / 256;
        uint256 whitelistedBitIndex = index % 256;
        whitelistedBitMap[operator][whitelistedWordIndex] = whitelistedBitMap[operator][whitelistedWordIndex] | (1 << whitelistedBitIndex);
        _whitelistAccount(operator, account, true);
        emit JoinWithMerkle(operator, index, account);
    }

    function setMerkleRoot(bytes32 _merkleRoot) external {
        // @dev Set the new merkle root.
        merkleRoot[msg.sender] = _merkleRoot;
        emit SetMerkleRoot(msg.sender, _merkleRoot);
    }
}",1296
RealWorld_BA_35_ConcentratedLiquidityPoolHelper_RealWord_20240820093400.log,35,ConcentratedLiquidityPoolHelper,7904,5583,13487,86.0,0.15118,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../../interfaces/IConcentratedLiquidityPool.sol"";
import ""../../libraries/concentratedPool/TickMath.sol"";

/// @notice Trident Concentrated Liquidity Pool periphery contract to read state.
contract ConcentratedLiquidityPoolHelper {
    struct SimpleTick {
        int24 index;
        uint128 liquidity;
    }

    function getTickState(IConcentratedLiquidityPool pool, uint24 tickCount) external view returns (SimpleTick[] memory) {
        SimpleTick[] memory ticks = new SimpleTick[](tickCount); // todo save tickCount in the core contract

        IConcentratedLiquidityPool.Tick memory tick;
        uint24 i;
        int24 current = TickMath.MIN_TICK;

        while (current != TickMath.MAX_TICK) {
            tick = pool.ticks(current);
            ticks[i++] = SimpleTick({index: current, liquidity: tick.liquidity});
            current = tick.nextTick;
        }

        tick = pool.ticks(current);
        ticks[i] = SimpleTick({index: TickMath.MAX_TICK, liquidity: tick.liquidity});

        return ticks;
    }
}",256
RealWorld_BA_35_SwapLib_RealWord_20240820090956.log,35,SwapLib,7935,4981,12916,78.0,0.139295,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.0;

import ""./FullMath.sol"";
import ""hardhat/console.sol"";

library SwapLib {
    function handleFees(
        uint256 output,
        uint24 swapFee,
        uint256 barFee,
        uint256 currentLiquidity,
        uint256 totalFeeAmount,
        uint256 amountOut,
        uint256 protocolFee,
        uint256 feeGrowthGlobal
    )
        internal
        pure
        returns (
            uint256,
            uint256,
            uint256,
            uint256
        )
    {
        uint256 feeAmount = FullMath.mulDivRoundingUp(output, swapFee, 1e6);

        totalFeeAmount += feeAmount;

        amountOut += output - feeAmount;

        // @dev Calculate `protocolFee` and convert pips to bips
        uint256 feeDelta = FullMath.mulDivRoundingUp(feeAmount, barFee, 1e4);

        protocolFee += feeDelta;

        // @dev Updating `feeAmount` based on the protocolFee.
        feeAmount -= feeDelta;

        feeGrowthGlobal += FullMath.mulDiv(feeAmount, 0x100000000000000000000000000000000, currentLiquidity);

        return (totalFeeAmount, amountOut, protocolFee, feeGrowthGlobal);
    }
}",295
RealWorld_BA_35_TridentNFT_RealWord_20240820093732.log,35,TridentNFT,45907,5713,51620,95.0,0.343795,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice Trident Concentrated Liquidity Pool ERC-721 implementation with ERC-20/EIP-2612-like extensions,
// as well as partially, MetaData and Enumerable extensions.
/// @author Adapted from RariCapital, https://github.com/Rari-Capital/solmate/blob/main/src/erc721/ERC721.sol,
// License-Identifier: AGPL-3.0-only, and Shoyu, https://github.com/sushiswap/shoyu/blob/master/contracts/base/BaseNFT721.sol,
// License-Identifier: MIT.
abstract contract TridentNFT {
    event Transfer(address indexed sender, address indexed recipient, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed spender, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    string public constant name = ""TridentNFT"";
    string public constant symbol = ""tNFT"";
    /// @notice Tracks total liquidity range positions.
    uint256 public totalSupply;
    /// @notice 'owner' -> balance mapping.
    mapping(address => uint256) public balanceOf;
    /// @notice `tokenId` -> 'owner' mapping.
    mapping(uint256 => address) public ownerOf;
    /// @notice `tokenId` -> 'spender' mapping.
    mapping(uint256 => address) public getApproved;
    /// @notice 'owner' -> 'operator' status mapping.
    mapping(address => mapping(address => bool)) public isApprovedForAll;

    /// @notice EIP-712 typehash for this contract's {permit} struct for {approve}.
    bytes32 public constant PERMIT_TYPEHASH = keccak256(""Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)"");
    /// @notice EIP-712 typehash for this contract's {permitAll} struct for {setApprovalForAll}.
    bytes32 public constant PERMIT_ALL_TYPEHASH = keccak256(""Permit(address owner,address spender,uint256 nonce,uint256 deadline)"");

    /// @notice Chain Id at this contract's deployment.
    uint256 internal immutable DOMAIN_SEPARATOR_CHAIN_ID;
    /// @notice EIP-712 typehash for this contract's domain at deployment.
    bytes32 internal immutable _DOMAIN_SEPARATOR;
    /// @notice 'tokenId' -> `nonce` mapping used in {permit} for {approve}.
    mapping(uint256 => uint256) public nonces;
    /// @notice 'owner' -> `tokenId` mapping used in {permitAll} for {setApprovalForAll}.
    mapping(address => uint256) public noncesForAll;

    constructor() {
        DOMAIN_SEPARATOR_CHAIN_ID = block.chainid;
        _DOMAIN_SEPARATOR = _calculateDomainSeparator();
    }

    function _calculateDomainSeparator() internal view returns (bytes32 domainSeperator) {
        domainSeperator = keccak256(
            abi.encode(
                keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
                keccak256(bytes(name)),
                keccak256(bytes(""1"")),
                block.chainid,
                address(this)
            )
        );
    }

    /// @notice EIP-712 typehash for this contract's domain.
    function DOMAIN_SEPARATOR() public view returns (bytes32 domainSeperator) {
        domainSeperator = block.chainid == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator();
    }

    /// @notice Provides ERC-165-compatible confirmation for ERC-721 interfaces supported by this contract.
    /// @param interfaceId XOR of all function selectors in the reference interface.
    /// @return supported Returns 'true' if `interfaceId` is flagged as implemented.
    function supportsInterface(bytes4 interfaceId) external pure returns (bool supported) {
        supported = interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f;
    }

    /// @notice Approves `tokenId` from `msg.sender` 'owner' or 'operator' to be spent by `spender`.
    /// @param spender Address of the party that can pull `tokenId` from 'owner''s account.
    /// @param tokenId The Id to approve for `spender`.
    function approve(address spender, uint256 tokenId) external {
        address owner = ownerOf[tokenId];
        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], ""NOT_APPROVED"");
        getApproved[tokenId] = spender;
        emit Approval(owner, spender, tokenId);
    }

    /// @notice Approves an 'operator' for `msg.sender` 'owner' that can spend or {approve} spends of 'owner''s `tokenId`s.
    /// @param operator Address of the party that can pull `tokenId`s from 'owner''s account or approve others to do same.
    /// @param approved The approval status of `operator`.
    function setApprovalForAll(address operator, bool approved) external {
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    /// @notice Transfers `tokenId` from 'owner' to `recipient`. Caller needs ownership.
    /// @param recipient The address to move `tokenId` to.
    /// @param tokenId The Id to move.
    function transfer(address recipient, uint256 tokenId) external {
        require(msg.sender == ownerOf[tokenId], ""NOT_OWNER"");
        /// @dev This is safe from under/overflow -
        // ownership is checked against decrement,
        // and sum of all user balances can't reasonably exceed type(uint256).max (see {_mint}).
        unchecked {
            balanceOf[msg.sender]--;
            balanceOf[recipient]++;
        }
        delete getApproved[tokenId];
        ownerOf[tokenId] = recipient;
        emit Transfer(msg.sender, recipient, tokenId);
    }

    /// @notice Transfers `tokenId` from 'owner' to `recipient`. Caller needs ownership or approval from 'owner'.
    /// @param recipient The address to move `tokenId` to.
    /// @param tokenId The Id to move.
    function transferFrom(
        address,
        address recipient,
        uint256 tokenId
    ) public {
        address owner = ownerOf[tokenId];
        require(msg.sender == owner || msg.sender == getApproved[tokenId] || isApprovedForAll[owner][msg.sender], ""NOT_APPROVED"");
        /// @dev This is safe from under/overflow -
        // ownership is checked against decrement,
        // and sum of all user balances can't reasonably exceed type(uint256).max (see {_mint}).
        unchecked {
            balanceOf[owner]--;
            balanceOf[recipient]++;
        }
        delete getApproved[tokenId];
        ownerOf[tokenId] = recipient;
        emit Transfer(owner, recipient, tokenId);
    }

    /// @notice Transfers `tokenId` from 'owner' to `recipient` with no data. Caller needs ownership or approval from 'owner',
    /// and `recipient` must have compatible {onERC721Received} function.
    /// @param recipient The address to move `tokenId` to.
    /// @param tokenId The Id to move.
    function safeTransferFrom(
        address,
        address recipient,
        uint256 tokenId
    ) external {
        safeTransferFrom(address(0), recipient, tokenId, """");
    }

    /// @notice Transfers `tokenId` from 'owner' to `recipient` with data. Caller needs ownership or approval from 'owner',
    /// and `recipient` must have compatible {onERC721Received} function.
    /// @param recipient The address to move `tokenId` to.
    /// @param tokenId The Id to move.
    function safeTransferFrom(
        address,
        address recipient,
        uint256 tokenId,
        bytes memory data
    ) public {
        transferFrom(address(0), recipient, tokenId);
        if (recipient.code.length != 0) {
            /// @dev `onERC721Received(address,address,uint,bytes)`.
            (, bytes memory returned) = recipient.staticcall(abi.encodeWithSelector(0x150b7a02, msg.sender, address(0), tokenId, data));
            bytes4 selector = abi.decode(returned, (bytes4));
            require(selector == 0x150b7a02, ""NOT_ERC721_RECEIVER"");
        }
    }

    /// @notice Triggers an approval from 'owner' to `spender` for a given `tokenId`.
    /// @param spender The address to be approved.
    /// @param tokenId The Id that is approved for `spender`.
    /// @param deadline The time at which to expire the signature.
    /// @param v The recovery byte of the signature.
    /// @param r Half of the ECDSA signature pair.
    /// @param s Half of the ECDSA signature pair.
    function permit(
        address spender,
        uint256 tokenId,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        require(deadline >= block.timestamp, ""PERMIT_DEADLINE_EXPIRED"");
        address owner = ownerOf[tokenId];
        /// @dev This is reasonably safe from overflow - incrementing `nonces` beyond
        // 'type(uint256).max' is exceedingly unlikely compared to optimization benefits.
        unchecked {
            bytes32 digest = keccak256(
                abi.encodePacked(
                    ""\x19\x01"",
                    DOMAIN_SEPARATOR(),
                    keccak256(abi.encode(PERMIT_TYPEHASH, spender, tokenId, nonces[tokenId]++, deadline))
                )
            );
            address recoveredAddress = ecrecover(digest, v, r, s);
            require(
                (recoveredAddress != address(0) && recoveredAddress == owner) || isApprovedForAll[owner][recoveredAddress],
                ""INVALID_PERMIT_SIGNATURE""
            );
        }
        getApproved[tokenId] = spender;
        emit Approval(owner, spender, tokenId);
    }

    /// @notice Triggers an approval from 'owner' to `operator` that can spend or {approve} spends of 'owner''s `tokenId`s.
    /// @param owner The address to be approved.
    /// @param operator Address of the party that can pull `tokenId`s from 'owner''s account or approve others to do same.
    /// @param deadline The time at which to expire the signature.
    /// @param v The recovery byte of the signature.
    /// @param r Half of the ECDSA signature pair.
    /// @param s Half of the ECDSA signature pair.
    function permitAll(
        address owner,
        address operator,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        require(deadline >= block.timestamp, ""PERMIT_DEADLINE_EXPIRED"");
        /// @dev This is reasonably safe from overflow - incrementing `nonces` beyond
        // 'type(uint256).max' is exceedingly unlikely compared to optimization benefits.
        unchecked {
            bytes32 digest = keccak256(
                abi.encodePacked(
                    ""\x19\x01"",
                    DOMAIN_SEPARATOR(),
                    keccak256(abi.encode(PERMIT_ALL_TYPEHASH, owner, operator, noncesForAll[owner]++, deadline))
                )
            );
            address recoveredAddress = ecrecover(digest, v, r, s);
            require(
                (recoveredAddress != address(0) && recoveredAddress == owner) || isApprovedForAll[owner][recoveredAddress],
                ""INVALID_PERMIT_SIGNATURE""
            );
        }
        isApprovedForAll[owner][operator] = true;
        emit ApprovalForAll(owner, operator, true);
    }

    function _mint(address recipient) internal {
        /// @dev This is reasonably safe from overflow - incrementing beyond
        // 'type(uint256).max' is exceedingly unlikely compared to optimization benefits.
        unchecked {
            uint256 tokenId = totalSupply++;
            require(ownerOf[tokenId] == address(0), ""ALREADY_MINTED"");
            balanceOf[recipient]++;
            ownerOf[tokenId] = recipient;
            emit Transfer(address(0), recipient, tokenId);
        }
    }

    function _burn(uint256 tokenId) internal {
        address owner = ownerOf[tokenId];
        require(owner != address(0), ""NOT_MINTED"");
        /// @dev This is safe from underflow - balance of any 'owner' is greater than 0.
        unchecked {
            balanceOf[owner]--;
        }
        delete ownerOf[tokenId];
        emit Transfer(owner, address(0), tokenId);
    }
}",2621
RealWorld_BA_35_ConcentratedLiquidityPool_RealWord_20240820093528.log,35,ConcentratedLiquidityPool,107125,6080,113205,122.0,0.657225,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../../interfaces/IBentoBoxMinimal.sol"";
import ""../../interfaces/IMasterDeployer.sol"";
import ""../../interfaces/IPool.sol"";
import ""../../interfaces/IPositionManager.sol"";
import ""../../interfaces/ITridentCallee.sol"";
import ""../../interfaces/ITridentRouter.sol"";
import ""../../libraries/concentratedPool/FullMath.sol"";
import ""../../libraries/concentratedPool/TickMath.sol"";
import ""../../libraries/concentratedPool/UnsafeMath.sol"";
import ""../../libraries/concentratedPool/DyDxMath.sol"";
import ""../../libraries/concentratedPool/SwapLib.sol"";
import ""../../libraries/concentratedPool/Ticks.sol"";
import ""hardhat/console.sol"";

/// @notice Trident exchange pool template with concentrated liquidity and constant product formula for swapping between an ERC-20 token pair.
/// @dev The reserves are stored as bento shares.
//      The curve is applied to shares as well. This pool does not care about the underlying amounts.
contract ConcentratedLiquidityPool is IPool {
    using Ticks for mapping(int24 => Ticks.Tick);

    event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);
    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);
    event Collect(address indexed sender, uint256 amount0, uint256 amount1);
    event Sync(uint256 reserveShares0, uint256 reserveShares1);

    /// @dev References for tickSpacing:
    // 100 tickSpacing -> 2% between ticks.
    bytes32 public constant override poolIdentifier = ""Trident:ConcentratedLiquidity"";

    uint24 internal constant MAX_FEE = 100000; /// @dev Maximum `swapFee` is 10%.

    uint128 internal immutable MAX_TICK_LIQUIDITY;
    uint24 internal immutable tickSpacing;
    uint24 internal immutable swapFee; /// @dev 1000 corresponds to 0.1% fee. Fee is measured in pips.

    address internal immutable barFeeTo;
    IBentoBoxMinimal internal immutable bento;
    IMasterDeployer internal immutable masterDeployer;

    address internal immutable token0;
    address internal immutable token1;

    uint128 public liquidity;

    uint160 internal secondsPerLiquidity; /// @dev Multiplied by 2^128.
    uint32 internal lastObservation;

    uint256 public feeGrowthGlobal0; /// @dev All fee growth counters are multiplied by 2^128.
    uint256 public feeGrowthGlobal1;

    uint256 public barFee;

    uint128 internal token0ProtocolFee;
    uint128 internal token1ProtocolFee;

    uint128 internal reserve0; /// @dev `bento` share balance tracker.
    uint128 internal reserve1;

    uint160 internal price; /// @dev Sqrt of price aka. (y/x), multiplied by 2^96.
    int24 internal nearestTick; /// @dev Tick that is just below the current price.

    uint256 internal unlocked;
    modifier lock() {
        require(unlocked == 1, ""LOCKED"");
        unlocked = 2;
        _;
        unlocked = 1;
    }

    mapping(int24 => Ticks.Tick) public ticks;
    mapping(address => mapping(int24 => mapping(int24 => Position))) public positions;

    struct Position {
        uint128 liquidity;
        uint256 feeGrowthInside0Last;
        uint256 feeGrowthInside1Last;
    }

    struct SwapCache {
        uint256 feeAmount;
        uint256 totalFeeAmount;
        uint256 protocolFee;
        uint256 feeGrowthGlobal;
        uint256 currentPrice;
        uint256 currentLiquidity;
        uint256 input;
        int24 nextTickToCross;
    }

    struct MintParams {
        int24 lowerOld;
        int24 lower;
        int24 upperOld;
        int24 upper;
        uint256 amount0Desired;
        uint256 amount1Desired;
        bool token0native;
        bool token1native;
        /// @dev To mint an NFT the positionOwner should be set to the positionManager contract.
        address positionOwner;
        /// @dev When minting through the positionManager contract positionRecipient should be the NFT recipient.
        //    It can be set to address(0) if we are not minting through the positionManager contract.
        address positionRecipient;
    }

    /// @dev Only set immutable variables here - state changes made here will not be used.
    constructor(bytes memory _deployData, IMasterDeployer _masterDeployer) {
        (address _token0, address _token1, uint24 _swapFee, uint160 _price, uint24 _tickSpacing) = abi.decode(
            _deployData,
            (address, address, uint24, uint160, uint24)
        );

        require(_token0 != address(0), ""ZERO_ADDRESS"");
        require(_token0 != address(this), ""INVALID_TOKEN0"");
        require(_token1 != address(this), ""INVALID_TOKEN1"");
        require(_swapFee <= MAX_FEE, ""INVALID_SWAP_FEE"");
        
        token0 = _token0;
        token1 = _token1;
        swapFee = _swapFee;
        price = _price;
        tickSpacing = _tickSpacing;
        /// @dev Prevents global liquidity overflow in the case all ticks are initialised.
        MAX_TICK_LIQUIDITY = Ticks.getMaxLiquidity(_tickSpacing);
        ticks[TickMath.MIN_TICK] = Ticks.Tick(TickMath.MIN_TICK, TickMath.MAX_TICK, uint128(0), 0, 0, 0);
        ticks[TickMath.MAX_TICK] = Ticks.Tick(TickMath.MIN_TICK, TickMath.MAX_TICK, uint128(0), 0, 0, 0);
        nearestTick = TickMath.MIN_TICK;
        bento = IBentoBoxMinimal(_masterDeployer.bento());
        barFeeTo = _masterDeployer.barFeeTo();
        barFee = _masterDeployer.barFee();
        masterDeployer = _masterDeployer;
        unlocked = 1;
    }

    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.
    // The router must ensure that sufficient LP tokens are minted by using the return value.
    function mint(bytes calldata data) public override lock returns (uint256 _liquidity) {
        MintParams memory mintParams = abi.decode(data, (MintParams));

        uint256 priceLower = uint256(TickMath.getSqrtRatioAtTick(mintParams.lower));
        uint256 priceUpper = uint256(TickMath.getSqrtRatioAtTick(mintParams.upper));
        uint256 currentPrice = uint256(price);

        _liquidity = DyDxMath.getLiquidityForAmounts(
            priceLower,
            priceUpper,
            currentPrice,
            mintParams.amount1Desired,
            mintParams.amount0Desired
        );

        {
            require(_liquidity <= MAX_TICK_LIQUIDITY, ""LIQUIDITY_OVERFLOW"");

            (uint256 amount0fees, uint256 amount1fees) = _updatePosition(
                mintParams.positionOwner,
                mintParams.lower,
                mintParams.upper,
                int128(uint128(_liquidity))
            );
            if (amount0fees > 0) {
                _transfer(token0, amount0fees, mintParams.positionOwner, false);
                reserve0 -= uint128(amount0fees);
            }
            if (amount1fees > 0) {
                _transfer(token1, amount1fees, mintParams.positionOwner, false);
                reserve1 -= uint128(amount1fees);
            }
        }

        unchecked {
            if (priceLower < currentPrice && currentPrice < priceUpper) liquidity += uint128(_liquidity);
        }

        _ensureTickSpacing(mintParams.lower, mintParams.upper);
        nearestTick = Ticks.insert(
            ticks,
            feeGrowthGlobal0,
            feeGrowthGlobal1,
            secondsPerLiquidity,
            mintParams.lowerOld,
            mintParams.lower,
            mintParams.upperOld,
            mintParams.upper,
            uint128(_liquidity),
            nearestTick,
            uint160(currentPrice)
        );

        (uint128 amount0Actual, uint128 amount1Actual) = _getAmountsForLiquidity(priceLower, priceUpper, currentPrice, _liquidity);

        ITridentRouter.TokenInput[] memory callbackData = new ITridentRouter.TokenInput[](2);
        callbackData[0] = ITridentRouter.TokenInput(token0, mintParams.token0native, amount0Actual);
        callbackData[1] = ITridentRouter.TokenInput(token1, mintParams.token1native, amount1Actual);

        ITridentCallee(msg.sender).tridentMintCallback(abi.encode(callbackData));

        unchecked {
            if (amount0Actual != 0) {
                require(amount0Actual + reserve0 <= _balance(token0), ""TOKEN0_MISSING"");
                reserve0 += amount0Actual;
            }

            if (amount1Actual != 0) {
                require(amount1Actual + reserve1 <= _balance(token1), ""TOKEN1_MISSING"");
                reserve1 += amount1Actual;
            }
        }

        (uint256 feeGrowth0, uint256 feeGrowth1) = rangeFeeGrowth(mintParams.lower, mintParams.upper);

        if (mintParams.positionRecipient != address(0)) {
            IPositionManager(mintParams.positionOwner).positionMintCallback(
                mintParams.positionRecipient,
                mintParams.lower,
                mintParams.upper,
                uint128(_liquidity),
                feeGrowth0,
                feeGrowth1
            );
        }

        emit Mint(mintParams.positionOwner, amount0Actual, amount1Actual, mintParams.positionRecipient);
    }

    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.
    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {
        (int24 lower, int24 upper, uint128 amount, address recipient, bool unwrapBento) = abi.decode(
            data,
            (int24, int24, uint128, address, bool)
        );

        uint160 priceLower = TickMath.getSqrtRatioAtTick(lower);
        uint160 priceUpper = TickMath.getSqrtRatioAtTick(upper);
        uint160 currentPrice = price;

        unchecked {
            if (priceLower < currentPrice && currentPrice < priceUpper) liquidity -= amount;
        }

        (uint256 amount0, uint256 amount1) = _getAmountsForLiquidity(
            uint256(priceLower),
            uint256(priceUpper),
            uint256(currentPrice),
            uint256(amount)
        );

        (uint256 amount0fees, uint256 amount1fees) = _updatePosition(msg.sender, lower, upper, -int128(amount));

        unchecked {
            amount0 += amount0fees;
            amount1 += amount1fees;
        }

        withdrawnAmounts = new TokenAmount[](2);
        withdrawnAmounts[0] = TokenAmount({token: token0, amount: amount0});
        withdrawnAmounts[1] = TokenAmount({token: token1, amount: amount1});

        unchecked {
            reserve0 -= uint128(amount0fees);
            reserve1 -= uint128(amount1fees);
        }

        _transferBothTokens(recipient, amount0, amount1, unwrapBento);

        nearestTick = Ticks.remove(ticks, lower, upper, amount, nearestTick);
        emit Burn(msg.sender, amount0, amount1, recipient);
    }

    function burnSingle(bytes calldata) public override returns (uint256) {
        revert();
    }

    function collect(
        int24 lower,
        int24 upper,
        address recipient,
        bool unwrapBento
    ) public lock returns (uint256 amount0fees, uint256 amount1fees) {
        (amount0fees, amount1fees) = _updatePosition(msg.sender, lower, upper, 0);

        _transferBothTokens(recipient, amount0fees, amount1fees, unwrapBento);

        reserve0 -= uint128(amount0fees);
        reserve1 -= uint128(amount1fees);

        emit Collect(msg.sender, amount0fees, amount1fees);
    }

    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage
    // - price is (y/x)
    // - x is token0
    // - zero for one -> price will move down.
    function swap(bytes memory data) public override lock returns (uint256 amountOut) {
        (bool zeroForOne, uint256 inAmount, address recipient, bool unwrapBento) = abi.decode(data, (bool, uint256, address, bool));

        SwapCache memory cache = SwapCache({
            feeAmount: 0,
            totalFeeAmount: 0,
            protocolFee: 0,
            feeGrowthGlobal: zeroForOne ? feeGrowthGlobal1 : feeGrowthGlobal0,
            currentPrice: uint256(price),
            currentLiquidity: uint256(liquidity),
            input: inAmount,
            nextTickToCross: zeroForOne ? nearestTick : ticks[nearestTick].nextTick
        });

        {
            uint256 timestamp = block.timestamp;
            uint256 diff = timestamp - uint256(lastObservation); /// @dev Underflow in 2106.
            if (diff > 0 && liquidity > 0) {
                lastObservation = uint32(timestamp);
                secondsPerLiquidity += uint160((diff << 128) / liquidity);
            }
        }

        while (cache.input != 0) {
            uint256 nextTickPrice = uint256(TickMath.getSqrtRatioAtTick(cache.nextTickToCross));
            uint256 output = 0;
            bool cross = false;

            if (zeroForOne) {
                // Trading token 0 (x) for token 1 (y).
                // Price is decreasing.
                // Maximum input amount within current tick range: x = (1/)  L.
                uint256 maxDx = DyDxMath.getDx(cache.currentLiquidity, nextTickPrice, cache.currentPrice, false);

                if (cache.input <= maxDx) {
                    // We can swap within the current range.
                    uint256 liquidityPadded = cache.currentLiquidity << 96;
                    // Calculate new price after swap: [new] =  L   / (L + x  )
                    // This is derrived from (1/) = x/L
                    // where (1/) is 1/[old] - 1/[new] and we solve for [new].
                    // In case of an owerflow we can use: [new] = L / (L /  + x).
                    // This is derrived by dividing the original fraction by  on both sides.
                    uint256 newPrice = uint256(
                        FullMath.mulDivRoundingUp(liquidityPadded, cache.currentPrice, liquidityPadded + cache.currentPrice * cache.input)
                    );

                    if (!(nextTickPrice <= newPrice && newPrice < cache.currentPrice)) {
                        // Overflow. We use a modified version of the formula.
                        newPrice = uint160(UnsafeMath.divRoundingUp(liquidityPadded, liquidityPadded / cache.currentPrice + cache.input));
                    }
                    // Based on the price difference calculate the output of th swap: y = P  L.
                    output = DyDxMath.getDy(cache.currentLiquidity, newPrice, cache.currentPrice, false);
                    cache.currentPrice = newPrice;
                    cache.input = 0;
                } else {
                    // Execute swap step and cross the tick.
                    output = DyDxMath.getDy(cache.currentLiquidity, nextTickPrice, cache.currentPrice, false);
                    cache.currentPrice = nextTickPrice;
                    cross = true;
                    cache.input -= maxDx;
                }
            } else {
                // Price is increasing.
                // Maximum swap amount within the current tick range: y = P  L.
                uint256 maxDy = DyDxMath.getDy(cache.currentLiquidity, cache.currentPrice, nextTickPrice, false);

                if (cache.input <= maxDy) {
                    // We can swap within the current range.
                    // Calculate new price after swap: P = y/L.
                    uint256 newPrice = cache.currentPrice +
                        FullMath.mulDiv(cache.input, 0x1000000000000000000000000, cache.currentLiquidity);
                    /// @dev Calculate output of swap
                    // - x = (1/P)  L.
                    output = DyDxMath.getDx(cache.currentLiquidity, cache.currentPrice, newPrice, false);
                    cache.currentPrice = newPrice;
                    cache.input = 0;
                } else {
                    /// @dev Swap & cross the tick.
                    output = DyDxMath.getDx(cache.currentLiquidity, cache.currentPrice, nextTickPrice, false);
                    cache.currentPrice = nextTickPrice;
                    cross = true;
                    cache.input -= maxDy;
                }
            }
            (cache.totalFeeAmount, amountOut, cache.protocolFee, cache.feeGrowthGlobal) = SwapLib.handleFees(
                output,
                swapFee,
                barFee,
                cache.currentLiquidity,
                cache.totalFeeAmount,
                amountOut,
                cache.protocolFee,
                cache.feeGrowthGlobal
            );
            if (cross) {
                (cache.currentLiquidity, cache.nextTickToCross) = Ticks.cross(
                    ticks,
                    cache.nextTickToCross,
                    secondsPerLiquidity,
                    cache.currentLiquidity,
                    cache.feeGrowthGlobal,
                    zeroForOne
                );
                if (cache.currentLiquidity == 0) {
                    // We step into a zone that has liquidity - or we reach the end of the linked list.
                    cache.currentPrice = uint256(TickMath.getSqrtRatioAtTick(cache.nextTickToCross));
                    (cache.currentLiquidity, cache.nextTickToCross) = Ticks.cross(
                        ticks,
                        cache.nextTickToCross,
                        secondsPerLiquidity,
                        cache.currentLiquidity,
                        cache.feeGrowthGlobal,
                        zeroForOne
                    );
                }
            }
        }

        price = uint160(cache.currentPrice);

        int24 newNearestTick = zeroForOne ? cache.nextTickToCross : ticks[cache.nextTickToCross].previousTick;

        if (nearestTick != newNearestTick) {
            nearestTick = newNearestTick;
            liquidity = uint128(cache.currentLiquidity);
        }

        _updateReserves(zeroForOne, uint128(inAmount), amountOut);

        _updateFees(zeroForOne, cache.feeGrowthGlobal, uint128(cache.protocolFee));

        if (zeroForOne) {
            _transfer(token1, amountOut, recipient, unwrapBento);
            emit Swap(recipient, token0, token1, inAmount, amountOut);
        } else {
            _transfer(token0, amountOut, recipient, unwrapBento);
            emit Swap(recipient, token1, token0, inAmount, amountOut);
        }
    }

    /// @dev Reserved for IPool.
    function flashSwap(bytes calldata) public override returns (uint256) {
        revert();
    }

    /// @dev Updates `barFee` for Trident protocol.
    function updateBarFee() public {
        barFee = IMasterDeployer(masterDeployer).barFee();
    }

    /// @dev Collects fees for Trident protocol.
    function collectProtocolFee() public lock returns (uint128 amount0, uint128 amount1) {
        if (token0ProtocolFee > 1) {
            amount0 = token0ProtocolFee - 1;
            token0ProtocolFee = 1;
            reserve0 -= amount0;
            _transfer(token0, amount0, barFeeTo, false);
        }
        if (token1ProtocolFee > 1) {
            amount1 = token1ProtocolFee - 1;
            token1ProtocolFee = 1;
            reserve1 -= amount1;
            _transfer(token1, amount1, barFeeTo, false);
        }
    }

    function _ensureTickSpacing(int24 lower, int24 upper) internal view {
        require(lower % int24(tickSpacing) == 0, ""INVALID_TICK"");
        require((lower / int24(tickSpacing)) % 2 == 0, ""LOWER_EVEN"");

        require(upper % int24(tickSpacing) == 0, ""INVALID_TICK"");
        require((upper / int24(tickSpacing)) % 2 != 0, ""UPPER_ODD""); /// @dev Can be either -1 or 1.
    }

    function _getAmountsForLiquidity(
        uint256 priceLower,
        uint256 priceUpper,
        uint256 currentPrice,
        uint256 liquidityAmount
    ) internal pure returns (uint128 token0amount, uint128 token1amount) {
        if (priceUpper <= currentPrice) {
            /// @dev Only supply `token1` (`token1` is Y).
            token1amount = uint128(DyDxMath.getDy(liquidityAmount, priceLower, priceUpper, true));
        } else if (currentPrice <= priceLower) {
            /// @dev Only supply `token0` (`token0` is X).
            token0amount = uint128(DyDxMath.getDx(liquidityAmount, priceLower, priceUpper, true));
        } else {
            /// @dev Supply both tokens.
            token0amount = uint128(DyDxMath.getDx(liquidityAmount, currentPrice, priceUpper, true));
            token1amount = uint128(DyDxMath.getDy(liquidityAmount, priceLower, currentPrice, true));
        }
    }

    function _updateReserves(
        bool zeroForOne,
        uint128 inAmount,
        uint256 amountOut
    ) internal {
        if (zeroForOne) {
            uint256 balance0 = _balance(token0);
            uint128 newBalance = reserve0 + inAmount;
            require(uint256(newBalance) <= balance0, ""TOKEN0_MISSING"");
            reserve0 = newBalance;
            reserve1 -= uint128(amountOut);
        } else {
            uint256 balance1 = _balance(token1);
            uint128 newBalance = reserve1 + inAmount;
            require(uint256(newBalance) <= balance1, ""TOKEN1_MISSING"");
            reserve1 = newBalance;
            reserve0 -= uint128(amountOut);
        }
    }

    function _updateFees(
        bool zeroForOne,
        uint256 feeGrowthGlobal,
        uint128 protocolFee
    ) internal {
        if (zeroForOne) {
            feeGrowthGlobal1 = feeGrowthGlobal;
            token1ProtocolFee += protocolFee;
        } else {
            feeGrowthGlobal0 = feeGrowthGlobal;
            token0ProtocolFee += protocolFee;
        }
    }

    function _updatePosition(
        address owner,
        int24 lower,
        int24 upper,
        int128 amount
    ) internal returns (uint256 amount0fees, uint256 amount1fees) {
        Position storage position = positions[owner][lower][upper];

        (uint256 growth0current, uint256 growth1current) = rangeFeeGrowth(lower, upper);
        amount0fees = FullMath.mulDiv(
            growth0current - position.feeGrowthInside0Last,
            position.liquidity,
            0x100000000000000000000000000000000
        );

        amount1fees = FullMath.mulDiv(
            growth1current - position.feeGrowthInside1Last,
            position.liquidity,
            0x100000000000000000000000000000000
        );

        if (amount < 0) position.liquidity -= uint128(-amount);
        if (amount > 0) position.liquidity += uint128(amount);

        require(position.liquidity < MAX_TICK_LIQUIDITY, ""MAX_TICK_LIQUIDITY"");

        position.feeGrowthInside0Last = growth0current;
        position.feeGrowthInside1Last = growth1current;
    }

    function _balance(address token) internal view returns (uint256 balance) {
        balance = bento.balanceOf(token, address(this));
    }

    function _transfer(
        address token,
        uint256 shares,
        address to,
        bool unwrapBento
    ) internal {
        if (unwrapBento) {
            bento.withdraw(token, address(this), to, 0, shares);
        } else {
            bento.transfer(token, address(this), to, shares);
        }
    }

    function _transferBothTokens(
        address to,
        uint256 shares0,
        uint256 shares1,
        bool unwrapBento
    ) internal {
        if (unwrapBento) {
            bento.withdraw(token0, address(this), to, 0, shares0);
            bento.withdraw(token1, address(this), to, 0, shares1);
        } else {
            bento.transfer(token0, address(this), to, shares0);
            bento.transfer(token1, address(this), to, shares1);
        }
    }

    /// @dev Generic formula for fee growth inside a range: (globalGrowth - growthBelow - growthAbove)
    // - available counters: global, outside u, outside v.

    //                  u                  v
    // ----|----|-------|xxxxxxxxxxxxxxxxxxx|--------|--------- (global - feeGrowthOutside(u) - feeGrowthOutside(v))

    //                 u                   v
    // ----|----|-------|xxxxxxxxxxxxxxxxxxx|--------|--------- (global - (global - feeGrowthOutside(u)) - feeGrowthOutside(v))

    //                  u                   v    
    // ----|----|-------|xxxxxxxxxxxxxxxxxxx|--------|--------- (global - feeGrowthOutside(u) - (global - feeGrowthOutside(v)))

    /// @notice Calculates the fee growth inside a range (per unit of liquidity).
    /// @dev Multiply `rangeFeeGrowth` delta by the provided liquidity to get accrued fees for some period.
    function rangeFeeGrowth(int24 lowerTick, int24 upperTick) public view returns (uint256 feeGrowthInside0, uint256 feeGrowthInside1) {
        int24 currentTick = nearestTick;

        Ticks.Tick storage lower = ticks[lowerTick];
        Ticks.Tick storage upper = ticks[upperTick];

        /// @dev Calculate fee growth below & above.
        uint256 _feeGrowthGlobal0 = feeGrowthGlobal0;
        uint256 _feeGrowthGlobal1 = feeGrowthGlobal1;
        uint256 feeGrowthBelow0;
        uint256 feeGrowthBelow1;
        uint256 feeGrowthAbove0;
        uint256 feeGrowthAbove1;

        if (lowerTick <= currentTick) {
            feeGrowthBelow0 = lower.feeGrowthOutside0;
            feeGrowthBelow1 = lower.feeGrowthOutside1;
        } else {
            feeGrowthBelow0 = _feeGrowthGlobal0 - lower.feeGrowthOutside0;
            feeGrowthBelow1 = _feeGrowthGlobal1 - lower.feeGrowthOutside1;
        }

        if (currentTick < upperTick) {
            feeGrowthAbove0 = upper.feeGrowthOutside0;
            feeGrowthAbove1 = upper.feeGrowthOutside1;
        } else {
            feeGrowthAbove0 = _feeGrowthGlobal0 - upper.feeGrowthOutside0;
            feeGrowthAbove1 = _feeGrowthGlobal1 - upper.feeGrowthOutside1;
        }

        feeGrowthInside0 = _feeGrowthGlobal0 - feeGrowthBelow0 - feeGrowthAbove0;
        feeGrowthInside1 = _feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1;
    }

    function rangeSecondsInside(int24 lowerTick, int24 upperTick) public view returns (uint256 secondsInside) {
        int24 currentTick = nearestTick;

        Ticks.Tick storage lower = ticks[lowerTick];
        Ticks.Tick storage upper = ticks[upperTick];

        uint256 secondsGlobal = secondsPerLiquidity;
        uint256 secondsBelow;
        uint256 secondsAbove;

        if (lowerTick <= currentTick) {
            secondsBelow = lower.secondsPerLiquidityOutside;
        } else {
            secondsBelow = secondsGlobal - lower.secondsPerLiquidityOutside;
        }

        if (currentTick < upperTick) {
            secondsAbove = upper.secondsPerLiquidityOutside;
        } else {
            secondsAbove = secondsGlobal - upper.secondsPerLiquidityOutside;
        }

        secondsInside = secondsGlobal - secondsBelow - secondsAbove;
    }

    function getAssets() public view override returns (address[] memory assets) {
        assets = new address[](2);
        assets[0] = token0;
        assets[1] = token1;
    }

    /// @dev Reserved for IPool.
    function getAmountOut(bytes calldata) public pure override returns (uint256) {
        revert();
    }

    function getImmutables()
        public
        view
        returns (
            uint128 _MAX_TICK_LIQUIDITY,
            uint24 _tickSpacing,
            uint24 _swapFee,
            address _barFeeTo,
            IBentoBoxMinimal _bento,
            IMasterDeployer _masterDeployer,
            address _token0,
            address _token1
        )
    {
        _MAX_TICK_LIQUIDITY = MAX_TICK_LIQUIDITY;
        _tickSpacing = tickSpacing;
        _swapFee = swapFee; /// @dev 1000 corresponds to 0.1% fee.
        _barFeeTo = barFeeTo;
        _bento = bento;
        _masterDeployer = masterDeployer;
        _token0 = token0;
        _token1 = token1;
    }

    function getPriceAndNearestTicks() public view returns (uint160 _price, int24 _nearestTick) {
        _price = price;
        _nearestTick = nearestTick;
    }

    function getTokenProtocolFees() public view returns (uint128 _token0ProtocolFee, uint128 _token1ProtocolFee) {
        _token0ProtocolFee = token0ProtocolFee;
        _token1ProtocolFee = token1ProtocolFee;
    }

    function getReserves() public view returns (uint128 _reserve0, uint128 _reserve1) {
        _reserve0 = reserve0;
        _reserve1 = reserve1;
    }

    function getLiquidityAndLastObservation() public view returns (uint160 _secondsPerLiquidity, uint32 _lastObservation) {
        _secondsPerLiquidity = secondsPerLiquidity;
        _lastObservation = lastObservation;
    }
}",6722
RealWorld_BA_35_IBentoBoxMinimal_RealWord_20240820095957.log,35,IBentoBoxMinimal,14814,4912,19726,83.0,0.17231,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;
import ""../libraries/RebaseLibrary.sol"";

/// @notice Minimal BentoBox vault interface.
/// @dev `token` is aliased as `address` from `IERC20` for simplicity.
interface IBentoBoxMinimal {
    /// @notice Balance per ERC-20 token per account in shares.
    function balanceOf(address, address) external view returns (uint256);

    /// @dev Helper function to represent an `amount` of `token` in shares.
    /// @param token The ERC-20 token.
    /// @param amount The `token` amount.
    /// @param roundUp If the result `share` should be rounded up.
    /// @return share The token amount represented in shares.
    function toShare(
        address token,
        uint256 amount,
        bool roundUp
    ) external view returns (uint256 share);

    /// @dev Helper function to represent shares back into the `token` amount.
    /// @param token The ERC-20 token.
    /// @param share The amount of shares.
    /// @param roundUp If the result should be rounded up.
    /// @return amount The share amount back into native representation.
    function toAmount(
        address token,
        uint256 share,
        bool roundUp
    ) external view returns (uint256 amount);

    /// @notice Registers this contract so that users can approve it for BentoBox.
    function registerProtocol() external;

    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.
    /// @param token_ The ERC-20 token to deposit.
    /// @param from which account to pull the tokens.
    /// @param to which account to push the tokens.
    /// @param amount Token amount in native representation to deposit.
    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.
    /// @return amountOut The amount deposited.
    /// @return shareOut The deposited amount repesented in shares.
    function deposit(
        address token_,
        address from,
        address to,
        uint256 amount,
        uint256 share
    ) external payable returns (uint256 amountOut, uint256 shareOut);

    /// @notice Withdraws an amount of `token` from a user account.
    /// @param token_ The ERC-20 token to withdraw.
    /// @param from which user to pull the tokens.
    /// @param to which user to push the tokens.
    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.
    /// @param share Like above, but `share` takes precedence over `amount`.
    function withdraw(
        address token_,
        address from,
        address to,
        uint256 amount,
        uint256 share
    ) external returns (uint256 amountOut, uint256 shareOut);

    /// @notice Transfer shares from a user account to another one.
    /// @param token The ERC-20 token to transfer.
    /// @param from which user to pull the tokens.
    /// @param to which user to push the tokens.
    /// @param share The amount of `token` in shares.
    function transfer(
        address token,
        address from,
        address to,
        uint256 share
    ) external;

    /// @dev Reads the Rebase `totals`from storage for a given token
    function totals(address token) external view returns (Rebase memory total);
}",737
RealWorld_BA_35_TridentHelper_RealWord_20240820091400.log,35,TridentHelper,28371,5407,33778,95.0,0.249995,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../TridentRouter.sol"";

/// @notice Trident router helper contract.
contract TridentHelper {
    /// @notice ERC-20 token for wrapped ETH (v9).
    address internal immutable wETH;

    constructor(address _wETH) {
        wETH = _wETH;
    }

    /// @notice Provides batch function calls for this contract and returns the data from all of them if they all succeed.
    /// Adapted from https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/base/Multicall.sol, License-Identifier: GPL-2.0-or-later.
    /// @dev The `msg.value` should not be trusted for any method callable from this function.
    /// @param data ABI-encoded params for each of the calls to make to this contract.
    /// @return results The results from each of the calls passed in via `data`.
    function batch(bytes[] calldata data) external payable returns (bytes[] memory results) {
        results = new bytes[](data.length);
        // We only allow one exactInputSingle call to be made in a single batch call.
        // This is not really needed but we want to save users from signing malicious payloads.
        // We also don't want nested batch calls.
        bool swapCalled;
        for (uint256 i = 0; i < data.length; i++) {
            bytes4 selector = getSelector(data[i]);
            if (selector == TridentRouter.exactInputSingle.selector || selector == TridentRouter.exactInputSingleWithNativeToken.selector) {
                require(!swapCalled, ""Swap called twice"");
                swapCalled = true;
            } else {
                require(selector != this.batch.selector, ""Nested Batch"");
            }

            (bool success, bytes memory result) = address(this).delegatecall(data[i]);
            if (!success) {
                // @dev Next 5 lines from https://ethereum.stackexchange.com/a/83577.
                if (result.length < 68) revert();
                assembly {
                    result := add(result, 0x04)
                }
                revert(abi.decode(result, (string)));
            }
            results[i] = result;
        }
    }

    /// @notice Provides gas-optimized balance check on this contract to avoid redundant extcodesize check in addition to returndatasize check.
    /// @param token Address of ERC-20 token.
    /// @return balance Token amount held by this contract.
    function balanceOfThis(address token) internal view returns (uint256 balance) {
        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x70a08231, address(this))); // @dev balanceOf(address).
        require(success && data.length >= 32, ""BALANCE_OF_FAILED"");
        balance = abi.decode(data, (uint256));
    }

    /// @notice Provides EIP-2612 signed approval for this contract to spend user tokens.
    /// @param token Address of ERC-20 token.
    /// @param amount Token amount to grant spending right over.
    /// @param deadline Termination for signed approval (UTC timestamp in seconds).
    /// @param v The recovery byte of the signature.
    /// @param r Half of the ECDSA signature pair.
    /// @param s Half of the ECDSA signature pair.
    function permitThis(
        address token,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        (bool success, ) = token.call(abi.encodeWithSelector(0xd505accf, msg.sender, address(this), amount, deadline, v, r, s)); // @dev permit(address,address,uint256,uint256,uint8,bytes32,bytes32).
        require(success, ""PERMIT_FAILED"");
    }

    /// @notice Provides DAI-derived signed approval for this contract to spend user tokens.
    /// @param token Address of ERC-20 token.
    /// @param nonce Token owner's nonce - increases at each call to {permit}.
    /// @param expiry Termination for signed approval - UTC timestamp in seconds.
    /// @param v The recovery byte of the signature.
    /// @param r Half of the ECDSA signature pair.
    /// @param s Half of the ECDSA signature pair.
    function permitThisAllowed(
        address token,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        (bool success, ) = token.call(abi.encodeWithSelector(0x8fcbaf0c, msg.sender, address(this), nonce, expiry, true, v, r, s)); // @dev permit(address,address,uint256,uint256,bool,uint8,bytes32,bytes32).
        require(success, ""PERMIT_FAILED"");
    }

    /// @notice Provides 'safe' ERC-20 {transfer} for tokens that don't consistently return true/false.
    /// @param token Address of ERC-20 token.
    /// @param recipient Account to send tokens to.
    /// @param amount Token amount to send.
    function safeTransfer(
        address token,
        address recipient,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, recipient, amount)); // @dev transfer(address,uint256).
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""TRANSFER_FAILED"");
    }

    /// @notice Provides 'safe' ERC-20 {transferFrom} for tokens that don't consistently return true/false.
    /// @param token Address of ERC-20 token.
    /// @param sender Account to send tokens from.
    /// @param recipient Account to send tokens to.
    /// @param amount Token amount to send.
    function safeTransferFrom(
        address token,
        address sender,
        address recipient,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, sender, recipient, amount)); // @dev transferFrom(address,address,uint256).
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""TRANSFER_FROM_FAILED"");
    }

    /// @notice Provides low-level `wETH` {withdraw}.
    /// @param amount Token amount to unwrap into ETH.
    function withdrawFromWETH(uint256 amount) internal {
        (bool success, ) = wETH.call(abi.encodeWithSelector(0x2e1a7d4d, amount)); // @dev withdraw(uint256).
        require(success, ""WITHDRAW_FROM_WETH_FAILED"");
    }

    /// @notice Provides 'safe' ETH transfer.
    /// @param recipient Account to send ETH to.
    /// @param amount ETH amount to send.
    function safeTransferETH(address recipient, uint256 amount) internal {
        (bool success, ) = recipient.call{value: amount}("""");
        require(success, ""ETH_TRANSFER_FAILED"");
    }

    /**
     * @notice function to extract the selector of a bytes calldata
     * @param _data the calldata bytes
     */
    function getSelector(bytes memory _data) internal pure returns (bytes4 sig) {
        assembly {
            sig := mload(add(_data, 32))
        }
    }
}",1556
RealWorld_BA_35_DyDxMath_RealWord_20240820090407.log,35,DyDxMath,11989,5008,16997,85.0,0.160105,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""./FullMath.sol"";
import ""./UnsafeMath.sol"";

/// @notice Math library that facilitates ranged liquidity calculations.
library DyDxMath {
    function getDy(
        uint256 liquidity,
        uint256 priceLower,
        uint256 priceUpper,
        bool roundUp
    ) internal pure returns (uint256 dy) {
        unchecked {
            if (roundUp) {
                dy = FullMath.mulDivRoundingUp(liquidity, priceUpper - priceLower, 0x1000000000000000000000000);
            } else {
                dy = FullMath.mulDiv(liquidity, priceUpper - priceLower, 0x1000000000000000000000000);
            }
        }
    }

    function getDx(
        uint256 liquidity,
        uint256 priceLower,
        uint256 priceUpper,
        bool roundUp
    ) internal pure returns (uint256 dx) {
        unchecked {
            if (roundUp) {
                dx = UnsafeMath.divRoundingUp(FullMath.mulDivRoundingUp(liquidity << 96, priceUpper - priceLower, priceUpper), priceLower);
            } else {
                dx = FullMath.mulDiv(liquidity << 96, priceUpper - priceLower, priceUpper) / priceLower;
            }
        }
    }

    function getLiquidityForAmounts(
        uint256 priceLower,
        uint256 priceUpper,
        uint256 currentPrice,
        uint256 dy,
        uint256 dx
    ) internal pure returns (uint256 liquidity) {
        unchecked {
            if (priceUpper <= currentPrice) {
                liquidity = FullMath.mulDiv(dy, 0x1000000000000000000000000, priceUpper - priceLower);
            } else if (currentPrice <= priceLower) {
                liquidity = FullMath.mulDiv(
                    dx,
                    FullMath.mulDiv(priceLower, priceUpper, 0x1000000000000000000000000),
                    priceUpper - priceLower
                );
            } else {
                uint256 liquidity0 = FullMath.mulDiv(
                    dx,
                    FullMath.mulDiv(priceUpper, currentPrice, 0x1000000000000000000000000),
                    priceUpper - currentPrice
                );
                uint256 liquidity1 = FullMath.mulDiv(dy, 0x1000000000000000000000000, currentPrice - priceLower);
                liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
            }
        }
    }
}",546
RealWorld_BA_35_HybridPool_RealWord_20240820092907.log,35,HybridPool,80471,5636,86107,102.0,0.515075,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../interfaces/IBentoBoxMinimal.sol"";
import ""../interfaces/IMasterDeployer.sol"";
import ""../interfaces/IPool.sol"";
import ""../interfaces/ITridentCallee.sol"";
import ""../libraries/MathUtils.sol"";
import ""./TridentERC20.sol"";
import ""../libraries/RebaseLibrary.sol"";

/// @notice Trident exchange pool template with hybrid like-kind formula for swapping between an ERC-20 token pair.
/// @dev The reserves are stored as bento shares. However, the stableswap invariant is applied to the underlying amounts.
///      The API uses the underlying amounts.
contract HybridPool is IPool, TridentERC20 {
    using MathUtils for uint256;
    using RebaseLibrary for Rebase;

    event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);
    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);
    event Sync(uint256 reserve0, uint256 reserve1);

    uint256 internal constant MINIMUM_LIQUIDITY = 10**3;
    uint8 internal constant PRECISION = 112;

    /// @dev Constant value used as max loop limit.
    uint256 private constant MAX_LOOP_LIMIT = 256;
    uint256 internal constant MAX_FEE = 10000; // @dev 100%.
    uint256 public immutable swapFee;

    IBentoBoxMinimal public immutable bento;
    IMasterDeployer public immutable masterDeployer;
    address public immutable barFeeTo;
    address public immutable token0;
    address public immutable token1;
    uint256 public immutable A;
    uint256 internal immutable N_A; // @dev 2 * A.
    uint256 internal constant A_PRECISION = 100;

    /// @dev Multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS.
    /// For example, TBTC has 18 decimals, so the multiplier should be 1. WBTC
    /// has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10.
    uint256 public immutable token0PrecisionMultiplier;
    uint256 public immutable token1PrecisionMultiplier;

    uint256 public barFee;

    uint128 internal reserve0;
    uint128 internal reserve1;
    uint256 internal dLast;

    bytes32 public constant override poolIdentifier = ""Trident:HybridPool"";

    uint256 internal unlocked;
    modifier lock() {
        require(unlocked == 1, ""LOCKED"");
        unlocked = 2;
        _;
        unlocked = 1;
    }

    constructor(bytes memory _deployData, address _masterDeployer) {
        (address _token0, address _token1, uint256 _swapFee, uint256 a) = abi.decode(_deployData, (address, address, uint256, uint256));

        // @dev Factory ensures that the tokens are sorted.
        require(_token0 != address(0), ""ZERO_ADDRESS"");
        require(_token0 != _token1, ""IDENTICAL_ADDRESSES"");
        require(_swapFee <= MAX_FEE, ""INVALID_SWAP_FEE"");
        require(a != 0, ""ZERO_A"");

        token0 = _token0;
        token1 = _token1;
        swapFee = _swapFee;
        barFee = IMasterDeployer(_masterDeployer).barFee();
        barFeeTo = IMasterDeployer(_masterDeployer).barFeeTo();
        bento = IBentoBoxMinimal(IMasterDeployer(_masterDeployer).bento());
        masterDeployer = IMasterDeployer(_masterDeployer);
        A = a;
        N_A = 2 * a;
        token0PrecisionMultiplier = uint256(10)**(decimals - TridentERC20(_token0).decimals());
        token1PrecisionMultiplier = uint256(10)**(decimals - TridentERC20(_token1).decimals());
        unlocked = 1;
    }

    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.
    /// The router must ensure that sufficient LP tokens are minted by using the return value.
    function mint(bytes calldata data) public override lock returns (uint256 liquidity) {
        address recipient = abi.decode(data, (address));
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();

        uint256 newLiq = _computeLiquidity(balance0, balance1);
        uint256 amount0 = balance0 - _reserve0;
        uint256 amount1 = balance1 - _reserve1;
        (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1);
        _reserve0 += uint112(fee0);
        _reserve1 += uint112(fee1);

        (uint256 _totalSupply, uint256 oldLiq) = _mintFee(_reserve0, _reserve1);

        if (_totalSupply == 0) {
            require(amount0 > 0 && amount1 > 0, ""INVALID_AMOUNTS"");
            liquidity = newLiq - MINIMUM_LIQUIDITY;
            _mint(address(0), MINIMUM_LIQUIDITY);
        } else {
            liquidity = ((newLiq - oldLiq) * _totalSupply) / oldLiq;
        }
        require(liquidity != 0, ""INSUFFICIENT_LIQUIDITY_MINTED"");
        _mint(recipient, liquidity);
        _updateReserves();

        dLast = newLiq;
        emit Mint(msg.sender, amount0, amount1, recipient);
    }

    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.
    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {
        (address recipient, bool unwrapBento) = abi.decode(data, (address, bool));
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 liquidity = balanceOf[address(this)];

        (uint256 _totalSupply, ) = _mintFee(balance0, balance1);

        uint256 amount0 = (liquidity * balance0) / _totalSupply;
        uint256 amount1 = (liquidity * balance1) / _totalSupply;

        _burn(address(this), liquidity);
        _transfer(token0, amount0, recipient, unwrapBento);
        _transfer(token1, amount1, recipient, unwrapBento);

        _updateReserves();

        withdrawnAmounts = new TokenAmount[](2);
        withdrawnAmounts[0] = TokenAmount({token: token0, amount: amount0});
        withdrawnAmounts[1] = TokenAmount({token: token1, amount: amount1});

        dLast = _computeLiquidity(balance0 - amount0, balance1 - amount1);

        emit Burn(msg.sender, amount0, amount1, recipient);
    }

    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another
    /// - i.e., the user gets a single token out by burning LP tokens.
    function burnSingle(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenOut, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 liquidity = balanceOf[address(this)];

        (uint256 _totalSupply, ) = _mintFee(balance0, balance1);

        uint256 amount0 = (liquidity * balance0) / _totalSupply;
        uint256 amount1 = (liquidity * balance1) / _totalSupply;

        _burn(address(this), liquidity);
        dLast = _computeLiquidity(balance0 - amount0, balance1 - amount1);

        // Swap tokens
        if (tokenOut == token1) {
            // @dev Swap `token0` for `token1`.
            // @dev Calculate `amountOut` as if the user first withdrew balanced liquidity and then swapped `token0` for `token1`.
            amount1 += _getAmountOut(amount0, balance0 - amount0, balance1 - amount1, true);
            _transfer(token1, amount1, recipient, unwrapBento);
            amountOut = amount1;
            amount0 = 0;
        } else {
            // @dev Swap `token1` for `token0`.
            require(tokenOut == token0, ""INVALID_OUTPUT_TOKEN"");
            amount0 += _getAmountOut(amount1, balance0 - amount0, balance1 - amount1, false);
            _transfer(token0, amount0, recipient, unwrapBento);
            amountOut = amount0;
            amount1 = 0;
        }
        _updateReserves();
        emit Burn(msg.sender, amount0, amount1, recipient);
    }

    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.
    function swap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));
        (uint256 _reserve0, uint256 _reserve1, uint256 balance0, uint256 balance1) = _getReservesAndBalances();
        uint256 amountIn;
        address tokenOut;

        if (tokenIn == token0) {
            tokenOut = token1;
            unchecked {
                amountIn = balance0 - _reserve0;
            }
            amountOut = _getAmountOut(amountIn, _reserve0, _reserve1, true);
        } else {
            require(tokenIn == token1, ""INVALID_INPUT_TOKEN"");
            tokenOut = token0;
            unchecked {
                amountIn = balance1 - _reserve1;
            }
            amountOut = _getAmountOut(amountIn, _reserve0, _reserve1, false);
        }
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        _updateReserves();
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }

    /// @dev Swaps one token for another with payload. The router must support swap callbacks and ensure there isn't too much slippage.
    function flashSwap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address recipient, bool unwrapBento, uint256 amountIn, bytes memory context) = abi.decode(
            data,
            (address, address, bool, uint256, bytes)
        );
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        address tokenOut;

        if (tokenIn == token0) {
            tokenOut = token1;
            amountIn = bento.toAmount(token0, amountIn, false);
            amountOut = _getAmountOut(amountIn, _reserve0, _reserve1, true);
            _processSwap(token1, recipient, amountOut, context, unwrapBento);
            uint256 balance0 = bento.toAmount(token0, bento.balanceOf(token0, address(this)), false);
            require(balance0 - _reserve0 >= amountIn, ""INSUFFICIENT_AMOUNT_IN"");
        } else {
            require(tokenIn == token1, ""INVALID_INPUT_TOKEN"");
            tokenOut = token0;
            amountIn = bento.toAmount(token1, amountIn, false);
            amountOut = _getAmountOut(amountIn, _reserve0, _reserve1, false);
            _processSwap(token0, recipient, amountOut, context, unwrapBento);
            uint256 balance1 = bento.toAmount(token1, bento.balanceOf(token1, address(this)), false);
            require(balance1 - _reserve1 >= amountIn, ""INSUFFICIENT_AMOUNT_IN"");
        }
        _updateReserves();
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }

    /// @dev Updates `barFee` for Trident protocol.
    function updateBarFee() public {
        barFee = masterDeployer.barFee();
    }

    function _processSwap(
        address tokenOut,
        address to,
        uint256 amountOut,
        bytes memory data,
        bool unwrapBento
    ) internal {
        _transfer(tokenOut, amountOut, to, unwrapBento);
        if (data.length != 0) ITridentCallee(msg.sender).tridentSwapCallback(data);
    }

    function _getReserves() internal view returns (uint256 _reserve0, uint256 _reserve1) {
        (_reserve0, _reserve1) = (reserve0, reserve1);
        _reserve0 = bento.toAmount(token0, _reserve0, false);
        _reserve1 = bento.toAmount(token1, _reserve1, false);
    }

    function _getReservesAndBalances()
        internal
        view
        returns (
            uint256 _reserve0,
            uint256 _reserve1,
            uint256 balance0,
            uint256 balance1
        )
    {
        (_reserve0, _reserve1) = (reserve0, reserve1);
        balance0 = bento.balanceOf(token0, address(this));
        balance1 = bento.balanceOf(token1, address(this));
        Rebase memory total0 = bento.totals(token0);
        Rebase memory total1 = bento.totals(token1);

        _reserve0 = total0.toElastic(_reserve0);
        _reserve1 = total1.toElastic(_reserve1);
        balance0 = total0.toElastic(balance0);
        balance1 = total1.toElastic(balance1);
    }

    function _updateReserves() internal {
        (uint256 _reserve0, uint256 _reserve1) = _balance();
        require(_reserve0 < type(uint128).max && _reserve1 < type(uint128).max, ""OVERFLOW"");
        reserve0 = uint128(_reserve0);
        reserve1 = uint128(_reserve1);
        emit Sync(_reserve0, _reserve1);
    }

    function _balance() internal view returns (uint256 balance0, uint256 balance1) {
        balance0 = bento.toAmount(token0, bento.balanceOf(token0, address(this)), false);
        balance1 = bento.toAmount(token1, bento.balanceOf(token1, address(this)), false);
    }

    function _getAmountOut(
        uint256 amountIn,
        uint256 _reserve0,
        uint256 _reserve1,
        bool token0In
    ) internal view returns (uint256 dy) {
        unchecked {
            uint256 adjustedReserve0 = _reserve0 * token0PrecisionMultiplier;
            uint256 adjustedReserve1 = _reserve1 * token1PrecisionMultiplier;
            uint256 feeDeductedAmountIn = amountIn - (amountIn * swapFee) / MAX_FEE;
            uint256 d = _computeLiquidityFromAdjustedBalances(adjustedReserve0, adjustedReserve1);

            if (token0In) {
                uint256 x = adjustedReserve0 + (feeDeductedAmountIn * token0PrecisionMultiplier);
                uint256 y = _getY(x, d);
                dy = adjustedReserve1 - y - 1;
                dy /= token1PrecisionMultiplier;
            } else {
                uint256 x = adjustedReserve1 + (feeDeductedAmountIn * token1PrecisionMultiplier);
                uint256 y = _getY(x, d);
                dy = adjustedReserve0 - y - 1;
                dy /= token0PrecisionMultiplier;
            }
        }
    }

    function _transfer(
        address token,
        uint256 amount,
        address to,
        bool unwrapBento
    ) internal {
        if (unwrapBento) {
            bento.withdraw(token, address(this), to, amount, 0);
        } else {
            bento.transfer(token, address(this), to, bento.toShare(token, amount, false));
        }
    }

    /// @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.
    /// See the StableSwap paper for details.
    /// @dev Originally https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L319.
    /// @return liquidity The invariant, at the precision of the pool.
    function _computeLiquidity(uint256 _reserve0, uint256 _reserve1) internal view returns (uint256 liquidity) {
        unchecked {
            uint256 adjustedReserve0 = _reserve0 * token0PrecisionMultiplier;
            uint256 adjustedReserve1 = _reserve1 * token1PrecisionMultiplier;
            liquidity = _computeLiquidityFromAdjustedBalances(adjustedReserve0, adjustedReserve1);
        }
    }

    function _computeLiquidityFromAdjustedBalances(uint256 xp0, uint256 xp1) internal view returns (uint256 computed) {
        uint256 s = xp0 + xp1;

        if (s == 0) {
            computed = 0;
        }
        uint256 prevD;
        uint256 D = s;
        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {
            uint256 dP = (((D * D) / xp0) * D) / xp1 / 4;
            prevD = D;
            D = (((N_A * s) / A_PRECISION + 2 * dP) * D) / ((N_A / A_PRECISION - 1) * D + 3 * dP);
            if (D.within1(prevD)) {
                break;
            }
        }
        computed = D;
    }

    /// @notice Calculate the new balances of the tokens given the indexes of the token
    /// that is swapped from (FROM) and the token that is swapped to (TO).
    /// This function is used as a helper function to calculate how much TO token
    /// the user should receive on swap.
    /// @dev Originally https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L432.
    /// @param x The new total amount of FROM token.
    /// @return y The amount of TO token that should remain in the pool.
    function _getY(uint256 x, uint256 D) internal view returns (uint256 y) {
        uint256 c = (D * D) / (x * 2);
        c = (c * D) / ((N_A * 2) / A_PRECISION);
        uint256 b = x + ((D * A_PRECISION) / N_A);
        uint256 yPrev;
        y = D;
        // @dev Iterative approximation.
        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {
            yPrev = y;
            y = (y * y + c) / (y * 2 + b - D);
            if (y.within1(yPrev)) {
                break;
            }
        }
    }

    function _mintFee(uint256 _reserve0, uint256 _reserve1) internal returns (uint256 _totalSupply, uint256 d) {
        _totalSupply = totalSupply;
        uint256 _dLast = dLast;
        if (_dLast != 0) {
            d = _computeLiquidity(_reserve0, _reserve1);
            if (d > _dLast) {
                // @dev `barFee` % of increase in liquidity.
                // It's going to be slightly less than `barFee` % in reality due to the math.
                uint256 liquidity = (_totalSupply * (d - _dLast) * barFee) / d / MAX_FEE;
                if (liquidity != 0) {
                    _mint(barFeeTo, liquidity);
                    _totalSupply += liquidity;
                }
            }
        }
    }

    /// @dev This fee is charged to cover for `swapFee` when users add unbalanced liquidity.
    function _nonOptimalMintFee(
        uint256 _amount0,
        uint256 _amount1,
        uint256 _reserve0,
        uint256 _reserve1
    ) internal view returns (uint256 token0Fee, uint256 token1Fee) {
        if (_reserve0 == 0 || _reserve1 == 0) return (0, 0);
        uint256 amount1Optimal = (_amount0 * _reserve1) / _reserve0;

        if (amount1Optimal <= _amount1) {
            token1Fee = (swapFee * (_amount1 - amount1Optimal)) / (2 * MAX_FEE);
        } else {
            uint256 amount0Optimal = (_amount1 * _reserve0) / _reserve1;
            token0Fee = (swapFee * (_amount0 - amount0Optimal)) / (2 * MAX_FEE);
        }
    }

    function getAssets() public view override returns (address[] memory assets) {
        assets = new address[](2);
        assets[0] = token0;
        assets[1] = token1;
    }

    function getAmountOut(bytes calldata data) public view override returns (uint256 finalAmountOut) {
        (address tokenIn, uint256 amountIn) = abi.decode(data, (address, uint256));
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        amountIn = bento.toAmount(tokenIn, amountIn, false);

        if (tokenIn == token0) {
            finalAmountOut = bento.toShare(token1, _getAmountOut(amountIn, _reserve0, _reserve1, true), false);
        } else {
            finalAmountOut = bento.toShare(token0, _getAmountOut(amountIn, _reserve0, _reserve1, false), false);
        }
    }

    function getReserves() public view returns (uint256 _reserve0, uint256 _reserve1) {
        (_reserve0, _reserve1) = _getReserves();
    }

    function getVirtualPrice() public view returns (uint256 virtualPrice) {
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        uint256 d = _computeLiquidity(_reserve0, _reserve1);
        virtualPrice = (d * (uint256(10)**decimals)) / totalSupply;
    }
}",4870
RealWorld_BA_35_TridentMathConsumerMock_RealWord_20240820085033.log,35,TridentMathConsumerMock,3842,3522,7364,71.0,0.08965,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity ^0.8.2;

import ""../libraries/TridentMath.sol"";

contract TridentMathConsumerMock {
    function sqrt(uint256 x) public pure returns (uint256) {
        return TridentMath.sqrt(x);
    }
}",63
RealWorld_BA_35_IndexPool_RealWord_20240820092727.log,35,IndexPool,60741,5981,66722,98.0,0.423325,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../interfaces/IBentoBoxMinimal.sol"";
import ""../interfaces/IMasterDeployer.sol"";
import ""../interfaces/IPool.sol"";
import ""../interfaces/ITridentCallee.sol"";
import ""./TridentERC20.sol"";

/// @notice Trident exchange pool template with constant mean formula for swapping among an array of ERC-20 tokens.
/// @dev The reserves are stored as bento shares.
///      The curve is applied to shares as well. This pool does not care about the underlying amounts.
contract IndexPool is IPool, TridentERC20 {
    event Mint(address indexed sender, address tokenIn, uint256 amountIn, address indexed recipient);
    event Burn(address indexed sender, address tokenOut, uint256 amountOut, address indexed recipient);

    uint256 public immutable swapFee;

    address public immutable barFeeTo;
    IBentoBoxMinimal public immutable bento;
    IMasterDeployer public immutable masterDeployer;

    uint256 internal constant BASE = 10**18;
    uint256 internal constant MIN_TOKENS = 2;
    uint256 internal constant MAX_TOKENS = 8;
    uint256 internal constant MIN_FEE = BASE / 10**6;
    uint256 internal constant MAX_FEE = BASE / 10;
    uint256 internal constant MIN_WEIGHT = BASE;
    uint256 internal constant MAX_WEIGHT = BASE * 50;
    uint256 internal constant MAX_TOTAL_WEIGHT = BASE * 50;
    uint256 internal constant MIN_BALANCE = BASE / 10**12;
    uint256 internal constant INIT_POOL_SUPPLY = BASE * 100;
    uint256 internal constant MIN_POW_BASE = 1;
    uint256 internal constant MAX_POW_BASE = (2 * BASE) - 1;
    uint256 internal constant POW_PRECISION = BASE / 10**10;
    uint256 internal constant MAX_IN_RATIO = BASE / 2;
    uint256 internal constant MAX_OUT_RATIO = (BASE / 3) + 1;

    uint136 internal totalWeight;
    address[] internal tokens;

    uint256 public barFee;

    bytes32 public constant override poolIdentifier = ""Trident:Index"";

    uint256 internal unlocked;
    modifier lock() {
        require(unlocked == 1, ""LOCKED"");
        unlocked = 2;
        _;
        unlocked = 1;
    }

    mapping(address => Record) public records;
    struct Record {
        uint120 reserve;
        uint136 weight;
    }

    constructor(bytes memory _deployData, address _masterDeployer) {
        (address[] memory _tokens, uint136[] memory _weights, uint256 _swapFee) = abi.decode(_deployData, (address[], uint136[], uint256));
        // @dev Factory ensures that the tokens are sorted.
        require(_tokens.length == _weights.length, ""INVALID_ARRAYS"");
        require(MIN_FEE <= _swapFee && _swapFee <= MAX_FEE, ""INVALID_SWAP_FEE"");
        require(MIN_TOKENS <= _tokens.length && _tokens.length <= MAX_TOKENS, ""INVALID_TOKENS_LENGTH"");

        for (uint256 i = 0; i < _tokens.length; i++) {
            require(_tokens[i] != address(0), ""ZERO_ADDRESS"");
            require(MIN_WEIGHT <= _weights[i] && _weights[i] <= MAX_WEIGHT, ""INVALID_WEIGHT"");
            records[_tokens[i]] = Record({reserve: 0, weight: _weights[i]});
            tokens.push(_tokens[i]);
            totalWeight += _weights[i];
        }

        require(totalWeight <= MAX_TOTAL_WEIGHT, ""MAX_TOTAL_WEIGHT"");
        // @dev This burns initial LP supply.
        _mint(address(0), INIT_POOL_SUPPLY);

        swapFee = _swapFee;
        barFee = IMasterDeployer(_masterDeployer).barFee();
        barFeeTo = IMasterDeployer(_masterDeployer).barFeeTo();
        bento = IBentoBoxMinimal(IMasterDeployer(_masterDeployer).bento());
        masterDeployer = IMasterDeployer(_masterDeployer);
        unlocked = 1;
    }

    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.
    /// The router must ensure that sufficient LP tokens are minted by using the return value.
    function mint(bytes calldata data) public override lock returns (uint256 liquidity) {
        (address recipient, uint256 toMint) = abi.decode(data, (address, uint256));

        uint120 ratio = uint120(_div(toMint, totalSupply));

        for (uint256 i = 0; i < tokens.length; i++) {
            address tokenIn = tokens[i];
            uint120 reserve = records[tokenIn].reserve;
            // @dev If token balance is '0', initialize with `ratio`.
            uint120 amountIn = reserve != 0 ? uint120(_mul(ratio, reserve)) : ratio;
            require(amountIn >= MIN_BALANCE, ""MIN_BALANCE"");
            // @dev Check Trident router has sent `amountIn` for skim into pool.
            unchecked {
                // @dev This is safe from overflow - only logged amounts handled.
                require(_balance(tokenIn) >= amountIn + reserve, ""NOT_RECEIVED"");
                records[tokenIn].reserve += amountIn;
            }
            emit Mint(msg.sender, tokenIn, amountIn, recipient);
        }
        _mint(recipient, toMint);
        liquidity = toMint;
    }

    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.
    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {
        (address recipient, bool unwrapBento, uint256 toBurn) = abi.decode(data, (address, bool, uint256));

        uint256 ratio = _div(toBurn, totalSupply);

        withdrawnAmounts = new TokenAmount[](tokens.length);

        _burn(address(this), toBurn);

        for (uint256 i = 0; i < tokens.length; i++) {
            address tokenOut = tokens[i];
            uint256 balance = records[tokenOut].reserve;
            uint120 amountOut = uint120(_mul(ratio, balance));
            require(amountOut != 0, ""ZERO_OUT"");
            // @dev This is safe from underflow - only logged amounts handled.
            unchecked {
                records[tokenOut].reserve -= amountOut;
            }
            _transfer(tokenOut, amountOut, recipient, unwrapBento);
            withdrawnAmounts[i] = TokenAmount({token: tokenOut, amount: amountOut});
            emit Burn(msg.sender, tokenOut, amountOut, recipient);
        }
    }

    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another
    /// - i.e., the user gets a single token out by burning LP tokens.
    function burnSingle(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenOut, address recipient, bool unwrapBento, uint256 toBurn) = abi.decode(data, (address, address, bool, uint256));

        Record storage outRecord = records[tokenOut];

        amountOut = _computeSingleOutGivenPoolIn(outRecord.reserve, outRecord.weight, totalSupply, totalWeight, toBurn, swapFee);

        require(amountOut <= _mul(outRecord.reserve, MAX_OUT_RATIO), ""MAX_OUT_RATIO"");
        // @dev This is safe from underflow - only logged amounts handled.
        unchecked {
            outRecord.reserve -= uint120(amountOut);
        }
        _burn(address(this), toBurn);
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        emit Burn(msg.sender, tokenOut, amountOut, recipient);
    }

    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.
    function swap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address tokenOut, address recipient, bool unwrapBento, uint256 amountIn) = abi.decode(
            data,
            (address, address, address, bool, uint256)
        );

        Record storage inRecord = records[tokenIn];
        Record storage outRecord = records[tokenOut];

        require(amountIn <= _mul(inRecord.reserve, MAX_IN_RATIO), ""MAX_IN_RATIO"");

        amountOut = _getAmountOut(amountIn, inRecord.reserve, inRecord.weight, outRecord.reserve, outRecord.weight);
        // @dev Check Trident router has sent `amountIn` for skim into pool.
        unchecked {
            // @dev This is safe from under/overflow - only logged amounts handled.
            require(_balance(tokenIn) >= amountIn + inRecord.reserve, ""NOT_RECEIVED"");
            inRecord.reserve += uint120(amountIn);
            outRecord.reserve -= uint120(amountOut);
        }
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }

    /// @dev Swaps one token for another. The router must support swap callbacks and ensure there isn't too much slippage.
    function flashSwap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address tokenOut, address recipient, bool unwrapBento, uint256 amountIn, bytes memory context) = abi.decode(
            data,
            (address, address, address, bool, uint256, bytes)
        );

        Record storage inRecord = records[tokenIn];
        Record storage outRecord = records[tokenOut];

        require(amountIn <= _mul(inRecord.reserve, MAX_IN_RATIO), ""MAX_IN_RATIO"");

        amountOut = _getAmountOut(amountIn, inRecord.reserve, inRecord.weight, outRecord.reserve, outRecord.weight);

        ITridentCallee(msg.sender).tridentSwapCallback(context);
        // @dev Check Trident router has sent `amountIn` for skim into pool.
        unchecked {
            // @dev This is safe from under/overflow - only logged amounts handled.
            require(_balance(tokenIn) >= amountIn + inRecord.reserve, ""NOT_RECEIVED"");
            inRecord.reserve += uint120(amountIn);
            outRecord.reserve -= uint120(amountOut);
        }
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }

    /// @dev Updates `barFee` for Trident protocol.
    function updateBarFee() public {
        barFee = IMasterDeployer(masterDeployer).barFee();
    }

    function _balance(address token) internal view returns (uint256 balance) {
        balance = bento.balanceOf(token, address(this));
    }

    function _getAmountOut(
        uint256 tokenInAmount,
        uint256 tokenInBalance,
        uint256 tokenInWeight,
        uint256 tokenOutBalance,
        uint256 tokenOutWeight
    ) internal view returns (uint256 amountOut) {
        uint256 weightRatio = _div(tokenInWeight, tokenOutWeight);
        // @dev This is safe from under/overflow - only logged amounts handled.
        unchecked {
            uint256 adjustedIn = _mul(tokenInAmount, (BASE - swapFee));
            uint256 a = _div(tokenInBalance, tokenInBalance + adjustedIn);
            uint256 b = _compute(a, weightRatio);
            uint256 c = BASE - b;
            amountOut = _mul(tokenOutBalance, c);
        }
    }

    function _compute(uint256 base, uint256 exp) internal pure returns (uint256 output) {
        require(MIN_POW_BASE <= base && base <= MAX_POW_BASE, ""INVALID_BASE"");

        uint256 whole = (exp / BASE) * BASE;
        uint256 remain = exp - whole;
        uint256 wholePow = _pow(base, whole / BASE);

        if (remain == 0) output = wholePow;

        uint256 partialResult = _powApprox(base, remain, POW_PRECISION);
        output = _mul(wholePow, partialResult);
    }

    function _computeSingleOutGivenPoolIn(
        uint256 tokenOutBalance,
        uint256 tokenOutWeight,
        uint256 _totalSupply,
        uint256 _totalWeight,
        uint256 toBurn,
        uint256 _swapFee
    ) internal pure returns (uint256 amountOut) {
        uint256 normalizedWeight = _div(tokenOutWeight, _totalWeight);
        uint256 newPoolSupply = _totalSupply - toBurn;
        uint256 poolRatio = _div(newPoolSupply, _totalSupply);
        uint256 tokenOutRatio = _pow(poolRatio, _div(BASE, normalizedWeight));
        uint256 newBalanceOut = _mul(tokenOutRatio, tokenOutBalance);
        uint256 tokenAmountOutBeforeSwapFee = tokenOutBalance - newBalanceOut;
        uint256 zaz = (BASE - normalizedWeight) * _swapFee;
        amountOut = _mul(tokenAmountOutBeforeSwapFee, (BASE - zaz));
    }

    function _pow(uint256 a, uint256 n) internal pure returns (uint256 output) {
        output = n % 2 != 0 ? a : BASE;
        for (n /= 2; n != 0; n /= 2) a = a * a;
        if (n % 2 != 0) output = output * a;
    }

    function _powApprox(
        uint256 base,
        uint256 exp,
        uint256 precision
    ) internal pure returns (uint256 sum) {
        uint256 a = exp;
        (uint256 x, bool xneg) = _subFlag(base, BASE);
        uint256 term = BASE;
        sum = term;
        bool negative;

        for (uint256 i = 1; term >= precision; i++) {
            uint256 bigK = i * BASE;
            (uint256 c, bool cneg) = _subFlag(a, (bigK - BASE));
            term = _mul(term, _mul(c, x));
            term = _div(term, bigK);
            if (term == 0) break;
            if (xneg) negative = !negative;
            if (cneg) negative = !negative;
            if (negative) {
                sum = sum - term;
            } else {
                sum = sum + term;
            }
        }
    }

    function _subFlag(uint256 a, uint256 b) internal pure returns (uint256 difference, bool flag) {
        // @dev This is safe from underflow - if/else flow performs checks.
        unchecked {
            if (a >= b) {
                (difference, flag) = (a - b, false);
            } else {
                (difference, flag) = (b - a, true);
            }
        }
    }

    function _mul(uint256 a, uint256 b) internal pure returns (uint256 c2) {
        uint256 c0 = a * b;
        uint256 c1 = c0 + (BASE / 2);
        c2 = c1 / BASE;
    }

    function _div(uint256 a, uint256 b) internal pure returns (uint256 c2) {
        uint256 c0 = a * BASE;
        uint256 c1 = c0 + (b / 2);
        c2 = c1 / b;
    }

    function _transfer(
        address token,
        uint256 shares,
        address to,
        bool unwrapBento
    ) internal {
        if (unwrapBento) {
            bento.withdraw(token, address(this), to, 0, shares);
        } else {
            bento.transfer(token, address(this), to, shares);
        }
    }

    function getAssets() public view override returns (address[] memory assets) {
        assets = tokens;
    }

    function getAmountOut(bytes calldata data) public view override returns (uint256 amountOut) {
        (uint256 tokenInAmount, uint256 tokenInBalance, uint256 tokenInWeight, uint256 tokenOutBalance, uint256 tokenOutWeight) = abi
            .decode(data, (uint256, uint256, uint256, uint256, uint256));
        amountOut = _getAmountOut(tokenInAmount, tokenInBalance, tokenInWeight, tokenOutBalance, tokenOutWeight);
    }

    function getReservesAndWeights() public view returns (uint256[] memory reserves, uint136[] memory weights) {
        uint256 length = tokens.length;
        reserves = new uint256[](length);
        weights = new uint136[](length);
        // @dev This is safe from overflow - `tokens` `length` is bound to '8'.
        unchecked {
            for (uint256 i = 0; i < length; i++) {
                reserves[i] = records[tokens[i]].reserve;
                weights[i] = records[tokens[i]].weight;
            }
        }
    }
}",3584
RealWorld_BA_35_UnsafeMath_RealWord_20240820091116.log,35,UnsafeMath,6247,4332,10579,78.0,0.117875,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.5.0;

/// @notice Math library that contains methods that perform common math functions but do not do any overflow or underflow checks.
/// @author Adapted from https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/UnsafeMath.sol.
library UnsafeMath {
    /// @notice Returns ceil(x / y).
    /// @dev Division by 0 has unspecified behavior, and must be checked externally.
    /// @param x The dividend.
    /// @param y The divisor.
    /// @return z The quotient, ceil(x / y).
    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
        assembly {
            z := add(div(x, y), gt(mod(x, y), 0))
        }
    }
}",188
RealWorld_BA_35_FranchisedHybridPool_RealWord_20240820094048.log,35,FranchisedHybridPool,89168,5855,95023,128.0,0.56294,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../../interfaces/IBentoBoxMinimal.sol"";
import ""../../interfaces/IMasterDeployer.sol"";
import ""../../interfaces/IPool.sol"";
import ""../../interfaces/ITridentCallee.sol"";
import ""../../libraries/MathUtils.sol"";
import ""./TridentFranchisedERC20.sol"";

/// @notice Trident exchange franchised pool template with hybrid like-kind formula for swapping between an ERC-20 token pair.
/// @dev The reserves are stored as bento shares. However, the stableswap invariant is applied to the underlying amounts.
///      The API uses the underlying amounts.
contract FranchisedHybridPool is IPool, TridentFranchisedERC20 {
    using MathUtils for uint256;

    event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);
    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);
    event Sync(uint256 reserve0, uint256 reserve1);

    uint256 internal constant MINIMUM_LIQUIDITY = 10**3;
    uint8 internal constant PRECISION = 112;

    /// @dev Constant value used as max loop limit.
    uint256 internal constant MAX_LOOP_LIMIT = 256;
    uint256 internal constant MAX_FEE = 10000; // @dev 100%.
    uint256 public immutable swapFee;

    address public immutable barFeeTo;
    address public immutable bento;
    address public immutable masterDeployer;
    address public immutable token0;
    address public immutable token1;
    uint256 public immutable A;
    uint256 internal immutable N_A; // @dev 2 * A.
    uint256 internal constant A_PRECISION = 100;

    /// @dev Multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS.
    /// For example, TBTC has 18 decimals, so the multiplier should be 1. WBTC
    /// has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10.
    uint256 public immutable token0PrecisionMultiplier;
    uint256 public immutable token1PrecisionMultiplier;

    uint256 public barFee;

    uint128 internal reserve0;
    uint128 internal reserve1;

    bytes32 public constant override poolIdentifier = ""Trident:FranchisedHybrid"";

    uint256 internal unlocked;
    modifier lock() {
        require(unlocked == 1, ""LOCKED"");
        unlocked = 2;
        _;
        unlocked = 1;
    }

    constructor(bytes memory _deployData, address _masterDeployer) {
        (address _token0, address _token1, uint256 _swapFee, uint256 a, address _whiteListManager, address _operator, bool _level2) = abi
            .decode(_deployData, (address, address, uint256, uint256, address, address, bool));

        // @dev Factory ensures that the tokens are sorted.
        require(_token0 != address(0), ""ZERO_ADDRESS"");
        require(_token0 != _token1, ""IDENTICAL_ADDRESSES"");
        require(_swapFee <= MAX_FEE, ""INVALID_SWAP_FEE"");
        require(a != 0, ""ZERO_A"");

        TridentFranchisedERC20.initialize(_whiteListManager, _operator, _level2);

        (, bytes memory _barFee) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));
        (, bytes memory _barFeeTo) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFeeTo.selector));
        (, bytes memory _bento) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.bento.selector));
        (, bytes memory _decimals0) = _token0.staticcall(abi.encodeWithSelector(0x313ce567)); // @dev 'decimals()'.
        (, bytes memory _decimals1) = _token1.staticcall(abi.encodeWithSelector(0x313ce567)); // @dev 'decimals()'.

        token0 = _token0;
        token1 = _token1;
        swapFee = _swapFee;
        barFee = abi.decode(_barFee, (uint256));
        barFeeTo = abi.decode(_barFeeTo, (address));
        bento = abi.decode(_bento, (address));
        masterDeployer = _masterDeployer;
        A = a;
        N_A = 2 * a;
        token0PrecisionMultiplier = 10**(decimals - abi.decode(_decimals0, (uint8)));
        token1PrecisionMultiplier = 10**(decimals - abi.decode(_decimals1, (uint8)));
        unlocked = 1;
    }

    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.
    /// The router must ensure that sufficient LP tokens are minted by using the return value.
    function mint(bytes calldata data) public override lock returns (uint256 liquidity) {
        address recipient = abi.decode(data, (address));
        _checkWhiteList(recipient);
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 _totalSupply = totalSupply;

        uint256 amount0 = balance0 - _reserve0;
        uint256 amount1 = balance1 - _reserve1;
        (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1);
        uint256 newLiq = _computeLiquidity(balance0 - fee0, balance1 - fee1);

        if (_totalSupply == 0) {
            liquidity = newLiq - MINIMUM_LIQUIDITY;
            _mint(address(0), MINIMUM_LIQUIDITY);
        } else {
            uint256 oldLiq = _computeLiquidity(_reserve0, _reserve1);
            liquidity = ((newLiq - oldLiq) * _totalSupply) / oldLiq;
        }
        require(liquidity != 0, ""INSUFFICIENT_LIQUIDITY_MINTED"");
        _mint(recipient, liquidity);
        _updateReserves();
        emit Mint(msg.sender, amount0, amount1, recipient);
    }

    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.
    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {
        (address recipient, bool unwrapBento) = abi.decode(data, (address, bool));
        _checkWhiteList(recipient);
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 _totalSupply = totalSupply;
        uint256 liquidity = balanceOf[address(this)];

        uint256 amount0 = (liquidity * balance0) / _totalSupply;
        uint256 amount1 = (liquidity * balance1) / _totalSupply;

        _burn(address(this), liquidity);
        _transfer(token0, amount0, recipient, unwrapBento);
        _transfer(token1, amount1, recipient, unwrapBento);

        balance0 -= _toShare(token0, amount0);
        balance1 -= _toShare(token1, amount1);

        _updateReserves();

        withdrawnAmounts = new TokenAmount[](2);
        withdrawnAmounts[0] = TokenAmount({token: token0, amount: amount0});
        withdrawnAmounts[1] = TokenAmount({token: token1, amount: amount1});

        emit Burn(msg.sender, amount0, amount1, recipient);
    }

    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another
    /// - i.e., the user gets a single token out by burning LP tokens.
    function burnSingle(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenOut, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));
        _checkWhiteList(recipient);
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 _totalSupply = totalSupply;
        uint256 liquidity = balanceOf[address(this)];

        uint256 amount0 = (liquidity * balance0) / _totalSupply;
        uint256 amount1 = (liquidity * balance1) / _totalSupply;

        _burn(address(this), liquidity);

        if (tokenOut == token1) {
            // @dev Swap `token0` for `token1`.
            // @dev Calculate `amountOut` as if the user first withdrew balanced liquidity and then swapped `token0` for `token1`.
            uint256 fee = _handleFee(token0, amount0);
            amount1 += _getAmountOut(amount0 - fee, _reserve0 - amount0, _reserve1 - amount1, true);
            _transfer(token1, amount1, recipient, unwrapBento);
            balance0 -= _toShare(token0, amount0);
            amountOut = amount1;
            amount0 = 0;
        } else {
            // @dev Swap `token1` for `token0`.
            require(tokenOut == token0, ""INVALID_OUTPUT_TOKEN"");
            uint256 fee = _handleFee(token1, amount1);
            amount0 += _getAmountOut(amount1 - fee, _reserve0 - amount0, _reserve1 - amount1, false);
            _transfer(token0, amount0, recipient, unwrapBento);
            balance1 -= _toShare(token1, amount1);
            amountOut = amount0;
            amount1 = 0;
        }
        _updateReserves();
        emit Burn(msg.sender, amount0, amount1, recipient);
    }

    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.
    function swap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));
        if (level2) _checkWhiteList(recipient);
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 amountIn;
        address tokenOut;

        if (tokenIn == token0) {
            tokenOut = token1;
            amountIn = balance0 - _reserve0;
            uint256 fee = _handleFee(tokenIn, amountIn);
            amountOut = _getAmountOut(amountIn - fee, _reserve0, _reserve1, true);
        } else {
            require(tokenIn == token1, ""INVALID_INPUT_TOKEN"");
            tokenOut = token0;
            amountIn = balance1 - _reserve1;
            uint256 fee = _handleFee(tokenIn, amountIn);
            amountOut = _getAmountOut(amountIn - fee, _reserve0, _reserve1, false);
        }
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        _updateReserves();
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }

    /// @dev Swaps one token for another with payload. The router must support swap callbacks and ensure there isn't too much slippage.
    function flashSwap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address recipient, bool unwrapBento, uint256 amountIn, bytes memory context) = abi.decode(
            data,
            (address, address, bool, uint256, bytes)
        );
        if (level2) _checkWhiteList(recipient);
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        address tokenOut;
        uint256 fee;

        if (tokenIn == token0) {
            tokenOut = token1;
            amountIn = _toAmount(token0, amountIn);
            fee = (amountIn * swapFee) / MAX_FEE;
            amountOut = _getAmountOut(amountIn - fee, _reserve0, _reserve1, true);
            _processSwap(token1, recipient, amountOut, context, unwrapBento);
            uint256 balance0 = _toAmount(token0, __balance(token0));
            require(balance0 - _reserve0 >= amountIn, ""INSUFFICIENT_AMOUNT_IN"");
        } else {
            require(tokenIn == token1, ""INVALID_INPUT_TOKEN"");
            tokenOut = token0;
            amountIn = _toAmount(token1, amountIn);
            fee = (amountIn * swapFee) / MAX_FEE;
            amountOut = _getAmountOut(amountIn - fee, _reserve0, _reserve1, false);
            _processSwap(token0, recipient, amountOut, context, unwrapBento);
            uint256 balance1 = _toAmount(token1, __balance(token1));
            require(balance1 - _reserve1 >= amountIn, ""INSUFFICIENT_AMOUNT_IN"");
        }
        _transfer(tokenIn, fee, barFeeTo, false);
        _updateReserves();
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }

    /// @dev Updates `barFee` for Trident protocol.
    function updateBarFee() public {
        (, bytes memory _barFee) = masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));
        barFee = abi.decode(_barFee, (uint256));
    }

    function _processSwap(
        address tokenOut,
        address to,
        uint256 amountOut,
        bytes memory data,
        bool unwrapBento
    ) internal {
        _transfer(tokenOut, amountOut, to, unwrapBento);
        if (data.length != 0) ITridentCallee(msg.sender).tridentSwapCallback(data);
    }

    function _getReserves() internal view returns (uint256 _reserve0, uint256 _reserve1) {
        (_reserve0, _reserve1) = (reserve0, reserve1);
        _reserve0 = _toAmount(token0, _reserve0);
        _reserve1 = _toAmount(token1, _reserve1);
    }

    function _updateReserves() internal {
        (uint256 _reserve0, uint256 _reserve1) = _balance();
        require(_reserve0 < type(uint128).max && _reserve1 < type(uint128).max, ""OVERFLOW"");
        reserve0 = uint128(_reserve0);
        reserve1 = uint128(_reserve1);
        emit Sync(_reserve0, _reserve1);
    }

    function _balance() internal view returns (uint256 balance0, uint256 balance1) {
        balance0 = _toAmount(token0, __balance(token0));
        balance1 = _toAmount(token1, __balance(token1));
    }

    function __balance(address token) internal view returns (uint256 balance) {
        // @dev balanceOf(address,address).
        (, bytes memory ___balance) = bento.staticcall(abi.encodeWithSelector(IBentoBoxMinimal.balanceOf.selector, token, address(this)));
        balance = abi.decode(___balance, (uint256));
    }

    function _toAmount(address token, uint256 input) internal view returns (uint256 output) {
        // @dev toAmount(address,uint256,bool).
        (, bytes memory _output) = bento.staticcall(abi.encodeWithSelector(IBentoBoxMinimal.toAmount.selector, token, input, false));
        output = abi.decode(_output, (uint256));
    }

    function _toShare(address token, uint256 input) internal view returns (uint256 output) {
        // @dev toShare(address,uint256,bool).
        (, bytes memory _output) = bento.staticcall(abi.encodeWithSelector(IBentoBoxMinimal.toShare.selector, token, input, false));
        output = abi.decode(_output, (uint256));
    }

    function _getAmountOut(
        uint256 amountIn,
        uint256 _reserve0,
        uint256 _reserve1,
        bool token0In
    ) internal view returns (uint256 dy) {
        uint256 xpIn;
        uint256 xpOut;

        if (token0In) {
            xpIn = _reserve0 * token0PrecisionMultiplier;
            xpOut = _reserve1 * token1PrecisionMultiplier;
            amountIn *= token0PrecisionMultiplier;
        } else {
            xpIn = _reserve1 * token1PrecisionMultiplier;
            xpOut = _reserve0 * token0PrecisionMultiplier;
            amountIn *= token1PrecisionMultiplier;
        }
        uint256 d = _computeLiquidityFromAdjustedBalances(xpIn, xpOut);
        uint256 x = xpIn + amountIn;
        uint256 y = _getY(x, d);
        dy = xpOut - y - 1;
        dy /= (token0In ? token1PrecisionMultiplier : token0PrecisionMultiplier);
    }

    function _transfer(
        address token,
        uint256 amount,
        address to,
        bool unwrapBento
    ) internal {
        if (unwrapBento) {
            // @dev withdraw(address,address,address,uint256,uint256).
            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.withdraw.selector, token, address(this), to, amount, 0));
            require(success, ""WITHDRAW_FAILED"");
        } else {
            // @dev transfer(address,address,address,uint256).
            (bool success, ) = bento.call(
                abi.encodeWithSelector(IBentoBoxMinimal.transfer.selector, token, address(this), to, _toShare(token, amount))
            );
            require(success, ""TRANSFER_FAILED"");
        }
    }

    /// @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.
    /// See the StableSwap paper for details.
    /// @dev Originally https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L319.
    /// @return liquidity The invariant, at the precision of the pool.
    function _computeLiquidity(uint256 _reserve0, uint256 _reserve1) internal view returns (uint256 liquidity) {
        uint256 xp0 = _reserve0 * token0PrecisionMultiplier;
        uint256 xp1 = _reserve1 * token1PrecisionMultiplier;
        liquidity = _computeLiquidityFromAdjustedBalances(xp0, xp1);
    }

    function _computeLiquidityFromAdjustedBalances(uint256 xp0, uint256 xp1) internal view returns (uint256 computed) {
        uint256 s = xp0 + xp1;

        if (s == 0) {
            computed = 0;
        }
        uint256 prevD;
        uint256 D = s;
        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {
            uint256 dP = (((D * D) / xp0) * D) / xp1 / 4;
            prevD = D;
            D = (((N_A * s) / A_PRECISION + 2 * dP) * D) / ((N_A / A_PRECISION - 1) * D + 3 * dP);
            if (D.within1(prevD)) {
                break;
            }
        }
        computed = D;
    }

    /// @notice Calculate the new balances of the tokens given the indexes of the token
    /// that is swapped from (FROM) and the token that is swapped to (TO).
    /// This function is used as a helper function to calculate how much TO token
    /// the user should receive on swap.
    /// @dev Originally https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L432.
    /// @param x The new total amount of FROM token.
    /// @return y The amount of TO token that should remain in the pool.
    function _getY(uint256 x, uint256 D) internal view returns (uint256 y) {
        uint256 c = (D * D) / (x * 2);
        c = (c * D) / ((N_A * 2) / A_PRECISION);
        uint256 b = x + ((D * A_PRECISION) / N_A);
        uint256 yPrev;
        y = D;
        // @dev Iterative approximation.
        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {
            yPrev = y;
            y = (y * y + c) / (y * 2 + b - D);
            if (y.within1(yPrev)) {
                break;
            }
        }
    }

    /// @notice Calculate the price of a token in the pool given
    /// precision-adjusted balances and a particular D and precision-adjusted
    /// array of balances.
    /// @dev This is accomplished via solving the quadratic equation iteratively.
    /// See the StableSwap paper and Curve.fi implementation for further details.
    /// x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)
    /// x_1**2 + b*x_1 = c
    /// x_1 = (x_1**2 + c) / (2*x_1 + b)
    /// @dev Originally https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L276.
    /// @return y The price of the token, in the same precision as in xp.
    function _getYD(
        uint256 s, // @dev xpOut.
        uint256 d
    ) internal view returns (uint256 y) {
        uint256 c = (d * d) / (s * 2);
        c = (c * d) / ((N_A * 2) / A_PRECISION);

        uint256 b = s + ((d * A_PRECISION) / N_A);
        uint256 yPrev;
        y = d;

        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {
            yPrev = y;
            y = (y * y + c) / (y * 2 + b - d);
            if (y.within1(yPrev)) {
                break;
            }
        }
    }

    function _handleFee(address tokenIn, uint256 amountIn) internal returns (uint256 fee) {
        fee = (amountIn * swapFee) / MAX_FEE;
        uint256 _barFee = (fee * barFee) / MAX_FEE;
        _transfer(tokenIn, _barFee, barFeeTo, false);
    }

    /// @dev This fee is charged to cover for `swapFee` when users add unbalanced liquidity.
    function _nonOptimalMintFee(
        uint256 _amount0,
        uint256 _amount1,
        uint256 _reserve0,
        uint256 _reserve1
    ) internal view returns (uint256 token0Fee, uint256 token1Fee) {
        if (_reserve0 == 0 || _reserve1 == 0) return (0, 0);
        uint256 amount1Optimal = (_amount0 * _reserve1) / _reserve0;

        if (amount1Optimal <= _amount1) {
            token1Fee = (swapFee * (_amount1 - amount1Optimal)) / (2 * MAX_FEE);
        } else {
            uint256 amount0Optimal = (_amount1 * _reserve0) / _reserve1;
            token0Fee = (swapFee * (_amount0 - amount0Optimal)) / (2 * MAX_FEE);
        }
    }

    function getAssets() public view override returns (address[] memory assets) {
        assets = new address[](2);
        assets[0] = token0;
        assets[1] = token1;
    }

    function getAmountOut(bytes calldata data) public view override returns (uint256 finalAmountOut) {
        (address tokenIn, uint256 amountIn) = abi.decode(data, (address, uint256));
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        amountIn = _toAmount(tokenIn, amountIn);
        amountIn -= (amountIn * swapFee) / MAX_FEE;

        if (tokenIn == token0) {
            finalAmountOut = _getAmountOut(amountIn, _reserve0, _reserve1, true);
        } else {
            finalAmountOut = _getAmountOut(amountIn, _reserve0, _reserve1, false);
        }
    }

    function getReserves() public view returns (uint256 _reserve0, uint256 _reserve1) {
        (_reserve0, _reserve1) = _getReserves();
    }
}",5437
RealWorld_BA_36_Factory_RealWord_20240820102919.log,36,Factory,17354,5479,22833,88.0,0.19635,"pragma solidity =0.8.7;

import ""hardhat/console.sol"";

import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { Ownable } from ""@openzeppelin/contracts/access/Ownable.sol"";
import { Clones } from ""@openzeppelin/contracts/proxy/Clones.sol"";
import ""./interfaces/IAuction.sol"";
import ""./interfaces/IBasket.sol"";
import ""./interfaces/IFactory.sol"";

contract Factory is IFactory, Ownable {
    using SafeERC20 for IERC20;

    uint256 private constant BASE = 1e18;

    constructor (IAuction _auctionImpl, IBasket _basketImpl) {
        auctionImpl = _auctionImpl;
        basketImpl = _basketImpl;
        ownerSplit = 0;
    }

    Proposal[] private _proposals;

    IAuction public override auctionImpl;
    IBasket public override basketImpl;

    uint256 public override minLicenseFee = 1e15; // 1e15 0.1%
    uint256 public override auctionDecrement = 10000;
    uint256 public override auctionMultiplier = 2;
    uint256 public override bondPercentDiv = 400;
    uint256 public override ownerSplit;

    function proposal(uint256 proposalId) external override view returns (Proposal memory) {
        return _proposals[proposalId];
    }

    function setMinLicenseFee(uint256 newMinLicenseFee) public override onlyOwner {
        minLicenseFee = newMinLicenseFee;
    }

    function setAuctionDecrement(uint256 newAuctionDecrement) public override onlyOwner {
        auctionDecrement = newAuctionDecrement;
    }

    function setAuctionMultiplier(uint256 newAuctionMultiplier) public override onlyOwner {
        auctionMultiplier = newAuctionMultiplier;
    }

    function setBondPercentDiv(uint256 newBondPercentDiv) public override onlyOwner {
        bondPercentDiv = newBondPercentDiv;
    }

    function setOwnerSplit(uint256 newOwnerSplit) public override onlyOwner {
        require(newOwnerSplit <= 2e17); // 20%

        ownerSplit = newOwnerSplit;
    }

    function getProposalWeights(uint256 id) external override view returns (address[] memory, uint256[] memory) {
        return (_proposals[id].tokens, _proposals[id].weights);
    }

    function proposeBasketLicense(
        uint256 licenseFee, 
        string memory tokenName, 
        string memory tokenSymbol, 
        address[] memory tokens,
        uint256[] memory weights
    ) public override returns (uint256 id) {
        basketImpl.validateWeights(tokens, weights);

        require(licenseFee >= minLicenseFee);

        // create proposal object
        Proposal memory proposal = Proposal({
            licenseFee: licenseFee,
            tokenName: tokenName,
            tokenSymbol: tokenSymbol,
            proposer: address(msg.sender),
            tokens: tokens,
            weights: weights,
            basket: address(0)
        });

        emit BasketLicenseProposed(msg.sender, tokenName);
        _proposals.push(proposal);

        return _proposals.length - 1;
    }

    function createBasket(uint256 idNumber) external override returns (IBasket) {
        Proposal memory bProposal = _proposals[idNumber];
        require(bProposal.basket == address(0));

        IAuction newAuction = IAuction(Clones.clone(address(auctionImpl)));
        IBasket newBasket = IBasket(Clones.clone(address(basketImpl)));

        newAuction.initialize(address(newBasket), address(this));
        newBasket.initialize(bProposal, newAuction);

        for (uint256 i = 0; i < bProposal.weights.length; i++) {
            IERC20 token = IERC20(bProposal.tokens[i]);
            token.safeTransferFrom(msg.sender, address(this), bProposal.weights[i]);
            token.safeApprove(address(newBasket), bProposal.weights[i]);
        }

        newBasket.mintTo(BASE, msg.sender);

        _proposals[idNumber].basket = address(newBasket);

        emit BasketCreated(address(newBasket));

        return newBasket;
    }
}",894
RealWorld_BA_36_IFactory_RealWord_20240820103459.log,36,IFactory,8688,5850,14538,88.0,0.16044,"pragma solidity =0.8.7;

import ""./IBasket.sol"";

interface IFactory {
    struct Bounty {
        address token;
        uint256 amount;
        bool active;
    }

    struct Proposal {
        uint256 licenseFee;
        string tokenName;
        string tokenSymbol;
        address proposer;
        address[] tokens;
        uint256[] weights;
        address basket;
    }


    function proposal(uint256) external view returns (Proposal memory);
    function minLicenseFee() external view returns (uint256);
    function auctionDecrement() external view returns (uint256);
    function auctionMultiplier() external view returns (uint256);
    function bondPercentDiv() external view returns (uint256);
    function ownerSplit() external view returns (uint256);
    function auctionImpl() external view returns (IAuction);
    function basketImpl() external view returns (IBasket);
    function getProposalWeights(uint256 id) external view returns (address[] memory, uint256[] memory);

    function createBasket(uint256) external returns (IBasket);
    function proposeBasketLicense(uint256, string calldata, string calldata, address[] memory tokens, uint256[] memory weights) external returns (uint256);
    function setMinLicenseFee(uint256) external;
    function setAuctionDecrement(uint256) external;
    function setAuctionMultiplier(uint256) external;
    function setBondPercentDiv(uint256) external;
    function setOwnerSplit(uint256) external;

    event BasketCreated(address indexed basket);
    event BasketLicenseProposed(address indexed proposer, string indexed tokenName);
}",328
RealWorld_BA_36_IAuction_RealWord_20240820103629.log,36,IAuction,9535,6123,15658,86.0,0.170135,"pragma solidity =0.8.7;

import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./IBasket.sol"";
import ""./IFactory.sol"";

interface IAuction {
    struct Bounty {
        address token;
        uint256 amount;
        bool active;
    }

    function startAuction() external;
    function bondForRebalance() external;
    function settleAuction(
        uint256[] calldata,
        address[] calldata,
        uint256[] calldata,
        address[] calldata,
        uint256[] calldata
    ) external;
    function bondBurn() external;
    function killAuction() external;
    function addBounty(IERC20, uint256) external returns (uint256);
    function initialize(address, address) external;

    function auctionOngoing() external view returns (bool);
    function auctionStart() external view returns (uint256);
    function hasBonded() external view returns (bool);
    function bondAmount() external view returns (uint256);
    function bondTimestamp() external view returns (uint256);
    function initialized() external view returns (bool);

    function basket() external view returns (IBasket);
    function factory() external view returns (IFactory);
    function auctionBonder() external view returns (address);

    event AuctionStarted();
    event Bonded(address _bonder, uint256 _amount);
    event AuctionSettled(address _settler);
    event BondBurned(address _burned, address _burnee, uint256 _amount);
    event BountyAdded(IERC20 _token, uint256 _amount, uint256 _id);
    event BountyClaimed(address _claimer, address _token, uint256 _amount, uint256 _id);
}",367
RealWorld_BA_36_Basket_RealWord_20240820103049.log,36,Basket,31045,6520,37565,98.0,0.285625,"pragma solidity =0.8.7;

import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { ERC20Upgradeable } from ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import { Ownable } from ""@openzeppelin/contracts/access/Ownable.sol"";
import './interfaces/IAuction.sol';
import ""./interfaces/IBasket.sol"";
import ""./interfaces/IFactory.sol"";
import ""hardhat/console.sol"";

contract Basket is IBasket, ERC20Upgradeable {
    using SafeERC20 for IERC20;

    uint256 public constant TIMELOCK_DURATION = 4 * 60 * 24; // 1 day
    uint256 public constant ONE_YEAR = 365.25 days;
    uint256 private constant BASE = 1e18;

    address public publisher;
    uint256 public licenseFee;

    IFactory public override factory;
    IAuction public override auction;

    uint256 public override ibRatio;

    PendingPublisher public pendingPublisher;
    PendingLicenseFee public pendingLicenseFee;
    PendingWeights public pendingWeights;

    address[] public tokens;
    uint256[] public weights;

    uint256 public override lastFee;

    function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {
        publisher = proposal.proposer;
        licenseFee = proposal.licenseFee;
        factory = IFactory(msg.sender);
        auction = auction_;
        ibRatio = BASE;
        tokens = proposal.tokens;
        weights = proposal.weights;
        approveUnderlying(address(auction));

        __ERC20_init(proposal.tokenName, proposal.tokenSymbol);
    }

    function getPendingWeights() external override view returns (address[] memory, uint256[] memory) {
        return (pendingWeights.tokens, pendingWeights.weights);
    }

    function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {
        require(_tokens.length == _weights.length);
        uint256 length = _tokens.length;
        address[] memory tokenList = new address[](length);

        // check uniqueness of tokens and not token(0)

        for (uint i = 0; i < length; i++) {
            require(_tokens[i] != address(0));
            require(_weights[i] > 0);

            for (uint256 x = 0; x < tokenList.length; x++) {
                require(_tokens[i] != tokenList[x]);
            }

            tokenList[i] = _tokens[i];
        }
    }

    function mint(uint256 amount) public override {
        mintTo(amount, msg.sender);
    }

    function mintTo(uint256 amount, address to) public override {
        require(auction.auctionOngoing() == false);
        require(amount > 0);

        handleFees();

        pullUnderlying(amount, msg.sender);

        _mint(to, amount);

        emit Minted(to, amount);
    }

    function burn(uint256 amount) public override {
        require(auction.auctionOngoing() == false);
        require(amount > 0);
        require(balanceOf(msg.sender) >= amount);

        handleFees();

        pushUnderlying(amount, msg.sender);
        _burn(msg.sender, amount);
        
        emit Burned(msg.sender, amount);
    }

    function auctionBurn(uint256 amount) onlyAuction external override {
        handleFees();

        _burn(msg.sender, amount);

        emit Burned(msg.sender, amount);
    }

    function handleFees() private {
        if (lastFee == 0) {
            lastFee = block.timestamp;
        } else {
            uint256 startSupply = totalSupply();

            uint256 timeDiff = (block.timestamp - lastFee);
            uint256 feePct = timeDiff * licenseFee / ONE_YEAR;
            uint256 fee = startSupply * feePct / (BASE - feePct);

            _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);
            _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);
            lastFee = block.timestamp;

            uint256 newIbRatio = ibRatio * startSupply / totalSupply();
            ibRatio = newIbRatio;

            emit NewIBRatio(ibRatio);
        }
    }

    // changes publisher
    // timelocked
    function changePublisher(address newPublisher) onlyPublisher public override {
        require(newPublisher != address(0));

        if (pendingPublisher.publisher != address(0)) {
            require(pendingPublisher.publisher == newPublisher);
            require(block.number >= pendingPublisher.block + TIMELOCK_DURATION);
            publisher = pendingPublisher.publisher;

            pendingPublisher.publisher = address(0);

            emit ChangedPublisher(publisher);
        } else {
            pendingPublisher.publisher = newPublisher;
            pendingPublisher.block = block.number;
        }
    }

    //changes licenseFee
    // timelocked
    function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {
        require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);
        if (pendingLicenseFee.licenseFee != 0) {
            require(pendingLicenseFee.licenseFee == newLicenseFee);
            require(block.number >= pendingLicenseFee.block + TIMELOCK_DURATION);
            licenseFee = pendingLicenseFee.licenseFee;

            pendingLicenseFee.licenseFee = 0;

            emit ChangedLicenseFee(licenseFee);
        } else {
            pendingLicenseFee.licenseFee = newLicenseFee;
            pendingLicenseFee.block = block.number;
        }
    }

    // publish new index
    // timelocked
    function publishNewIndex(address[] memory _tokens, uint256[] memory _weights) onlyPublisher public override {
        validateWeights(_tokens, _weights);

        if (pendingWeights.pending) {
            require(block.number >= pendingWeights.block + TIMELOCK_DURATION);
            if (auction.auctionOngoing() == false) {
                auction.startAuction();

                emit PublishedNewIndex(publisher);
            } else if (auction.hasBonded()) {

            } else {
                auction.killAuction();

                pendingWeights.tokens = _tokens;
                pendingWeights.weights = _weights;
                pendingWeights.block = block.number;
            }
        } else {
            pendingWeights.pending = true;
            pendingWeights.tokens = _tokens;
            pendingWeights.weights = _weights;
            pendingWeights.block = block.number;
        }
    }

    function setNewWeights() onlyAuction external override {
        tokens = pendingWeights.tokens;
        weights = pendingWeights.weights;
        pendingWeights.pending = false;

        approveUnderlying(address(auction));

        emit WeightsSet();
    }

    // delete pending index
    function deleteNewIndex() public override {
        require(msg.sender == publisher || msg.sender == address(auction));
        require(auction.auctionOngoing() == false);

        pendingWeights.pending = false;

        emit DeletedNewIndex(publisher);
    }

    function updateIBRatio(uint256 newRatio) onlyAuction external override returns (uint256) {
        ibRatio = newRatio;

        emit NewIBRatio(ibRatio);

        return ibRatio;
    }

    function approveUnderlying(address spender) private {
        for (uint256 i = 0; i < weights.length; i++) {
            IERC20(tokens[i]).approve(spender, type(uint256).max);
        }
    }

    function pushUnderlying(uint256 amount, address to) private {
        for (uint256 i = 0; i < weights.length; i++) {
            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;
            IERC20(tokens[i]).safeTransfer(to, tokenAmount);
        }
    }

    function pullUnderlying(uint256 amount, address from) private {
        for (uint256 i = 0; i < weights.length; i++) {
            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;
            IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);
        }
    }

    modifier onlyAuction() {
        require(msg.sender == address(auction));
        _;
    }

    modifier onlyPublisher() {
        require(msg.sender == address(publisher));
        _;
    }
}",1739
RealWorld_BA_36_Auction_RealWord_20240820103229.log,36,Auction,21231,5654,26885,83.0,0.219235,"pragma solidity =0.8.7;

import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import './interfaces/IFactory.sol';
import './interfaces/IBasket.sol';
import ""./interfaces/IAuction.sol"";
import ""hardhat/console.sol"";

contract Auction is IAuction {
    using SafeERC20 for IERC20;

    uint256 private constant BASE = 1e18;
    uint256 private constant ONE_DAY = 4 * 60 * 24;
    uint256 private constant BLOCK_DECREMENT = 10000;
    
    bool public override auctionOngoing;
    uint256 public override auctionStart;
    bool public override hasBonded;
    uint256 public override bondAmount;
    uint256 public override bondTimestamp;
    bool public override initialized;

    IBasket public override basket;
    IFactory public override factory;
    address public override auctionBonder;

    Bounty[] private _bounties;

    modifier onlyBasket() {
        require(msg.sender == address(basket), 'not basket');
        _;
    }

    function startAuction() onlyBasket public override {
        require(auctionOngoing == false, 'ongoing auction');

        auctionOngoing = true;
        auctionStart = block.number;

        emit AuctionStarted();
    }

    function killAuction() onlyBasket public override {
        auctionOngoing = false;
    }

    function initialize(address basket_, address factory_) public override {
        require(!initialized);
        basket = IBasket(basket_);
        factory = IFactory(factory_);
        initialized = true;
    }

    function bondForRebalance() public override {
        require(auctionOngoing);
        require(!hasBonded);

        bondTimestamp = block.number;

        IERC20 basketToken = IERC20(address(basket));
        bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();
        basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);
        hasBonded = true;
        auctionBonder = msg.sender;

        emit Bonded(msg.sender, bondAmount);
    }

    function settleAuction(
        uint256[] memory bountyIDs,
        address[] memory inputTokens,
        uint256[] memory inputWeights,
        address[] memory outputTokens,
        uint256[] memory outputWeights
    ) public override {
        require(auctionOngoing);
        require(hasBonded);
        require(bondTimestamp + ONE_DAY > block.number);
        require(msg.sender == auctionBonder);

        for (uint256 i = 0; i < inputTokens.length; i++) {
            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);
        }

        for (uint256 i = 0; i < outputTokens.length; i++) {
            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);
        }

        uint256 a = factory.auctionMultiplier() * basket.ibRatio();
        uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();
        uint256 newRatio = a - b;

        (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();
        IERC20 basketAsERC20 = IERC20(address(basket));

        for (uint256 i = 0; i < pendingWeights.length; i++) {
            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;
            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);
        }

        basketAsERC20.transfer(msg.sender, bondAmount);
        withdrawBounty(bountyIDs);
        basket.setNewWeights();
        basket.updateIBRatio(newRatio);
        auctionOngoing = false;
        hasBonded = false;

        emit AuctionSettled(msg.sender);
    }

    function bondBurn() external override {
        require(auctionOngoing);
        require(hasBonded);
        require(bondTimestamp + ONE_DAY <= block.number);

        basket.auctionBurn(bondAmount);
        hasBonded = false;
        auctionOngoing = false;
        basket.deleteNewIndex();

        emit BondBurned(msg.sender, auctionBonder, bondAmount);

        auctionBonder = address(0);
    }

    function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {
        // add bounty to basket
        token.safeTransferFrom(msg.sender, address(this), amount);
        _bounties.push(Bounty({
            token: address(token),
            amount: amount,
            active: true
        }));

        uint256 id = _bounties.length - 1;
        emit BountyAdded(token, amount, id);
        return id;
    }

    function withdrawBounty(uint256[] memory bountyIds) internal {
        // withdraw bounties
        for (uint256 i = 0; i < bountyIds.length; i++) {
            Bounty memory bounty = _bounties[bountyIds[i]];
            require(bounty.active);

            IERC20(bounty.token).transfer(msg.sender, bounty.amount);
            bounty.active = false;

            emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);
        }
    }
 }",1101
RealWorld_BA_36_IBasket_RealWord_20240820103757.log,36,IBasket,9203,5605,14808,83.0,0.158115,"pragma solidity =0.8.7;

import ""./IAuction.sol"";

interface IBasket {
    struct PendingPublisher {
        address publisher;
        uint256 block;
    }

    struct PendingLicenseFee {
        uint256 licenseFee;
        uint256 block;
    }

    struct PendingWeights {
        address[] tokens;
        uint256[] weights;
        uint256 block;
        bool pending;
    }

    function initialize(IFactory.Proposal memory, IAuction) external;
    function mint(uint256) external;
    function mintTo(uint256, address) external;
    function burn(uint256) external;
    function changePublisher(address) external;
    function changeLicenseFee(uint256) external;
    function publishNewIndex(address[] calldata, uint256[] calldata) external;
    function deleteNewIndex() external;
    function auctionBurn(uint256) external;
    function updateIBRatio(uint256) external returns (uint256);
    function setNewWeights() external;
    function validateWeights(address[] memory, uint256[] memory) external pure;

    function ibRatio() external view returns (uint256);
    function getPendingWeights() external view returns (address[] memory, uint256[] memory);
    function factory() external view returns (IFactory);
    function auction() external view returns (IAuction);
    function lastFee() external view returns (uint256);


    event Minted(address indexed _to, uint256 _amount);
    event Burned(address indexed _from, uint256 _amount);
    event ChangedPublisher(address indexed _newPublisher);
    event ChangedLicenseFee(uint256 _newLicenseFee);
    event PublishedNewIndex(address _publisher);
    event DeletedNewIndex(address _publisher);
    event WeightsSet();
    event NewIBRatio(uint256);
}",361
RealWorld_BA_36_TestToken_RealWord_20240820103355.log,36,TestToken,4058,3687,7745,62.0,0.09403,"pragma solidity =0.8.7;

import { ERC20 } from ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract TestToken is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) public {

    }

    function mint(uint256 amount) public {
        _mint(msg.sender, amount);
    }
}",77
RealWorld_BA_37_PoolShare_RealWord_20240820111849.log,37,PoolShare,6438,4507,10945,93.0,0.12233,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.6;

import ""./ERC20OwnerMintableToken.sol"";
import ""../ITempusPool.sol"";

/// Token representing the principal or yield shares of a pool.
abstract contract PoolShare is IPoolShare, ERC20OwnerMintableToken {
    /// The kind of the share.
    ShareKind public immutable override kind;

    /// The pool this share is part of.
    ITempusPool public immutable override pool;

    uint8 internal immutable tokenDecimals;

    constructor(
        ShareKind _kind,
        ITempusPool _pool,
        string memory name,
        string memory symbol,
        uint8 _decimals
    ) ERC20OwnerMintableToken(name, symbol) {
        kind = _kind;
        pool = _pool;
        tokenDecimals = _decimals;
    }

    function decimals() public view virtual override returns (uint8) {
        return tokenDecimals;
    }
}",205
RealWorld_BA_37_CTokenInterfaces_RealWord_20240820111129.log,37,CTokenInterfaces,6657,5023,11680,72.0,0.133745,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;

import ""./ComptrollerInterface.sol"";

contract CTokenStorage {
    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;
}

abstract contract CTokenInterface is CTokenStorage {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    // as defined in Compound protocol
    function exchangeRateStored() external view virtual returns (uint);

    function exchangeRateCurrent() external virtual returns (uint);
}

contract CErc20Storage {
    /**
     * @notice Underlying asset for this CToken
     */
    address public underlying;
}

abstract contract CErc20Interface is CErc20Storage {
    /**
     * This is used to deposit into Compound with CErc20 tokens
     */
    function mint(uint mintAmount) external virtual returns (uint);

    function redeem(uint redeemTokens) external virtual returns (uint);
}",219
RealWorld_BA_37_AMMBalancesHelper_RealWord_20240820112844.log,37,AMMBalancesHelper,7975,5479,13454,85.0,0.149455,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.6;

import ""../math/Fixed256xVar.sol"";

library AMMBalancesHelper {
    using Fixed256xVar for uint256;

    uint256 internal constant ONE = 1e18;

    function getLiquidityProvisionSharesAmounts(uint256[] memory ammBalances, uint256 shares)
        internal
        pure
        returns (uint256[] memory)
    {
        uint256[2] memory ammDepositPercentages = getAMMBalancesRatio(ammBalances);
        uint256[] memory ammLiquidityProvisionAmounts = new uint256[](2);

        (ammLiquidityProvisionAmounts[0], ammLiquidityProvisionAmounts[1]) = (
            shares.mulfV(ammDepositPercentages[0], ONE),
            shares.mulfV(ammDepositPercentages[1], ONE)
        );

        return ammLiquidityProvisionAmounts;
    }

    function getAMMBalancesRatio(uint256[] memory ammBalances) internal pure returns (uint256[2] memory balancesRatio) {
        uint256 rate = ammBalances[0].divfV(ammBalances[1], ONE);

        (balancesRatio[0], balancesRatio[1]) = rate > ONE ? (ONE, ONE.divfV(rate, ONE)) : (rate, ONE);
    }
}",307
RealWorld_BA_37_unusedAMMImportOnly_RealWord_20240820113450.log,37,unusedAMMImportOnly,3875,5017,8892,76.0,0.119715,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

// TODO: This file should be removed once we find better way to trigger compilation for Vault and Authorizer

import ""@balancer-labs/v2-vault/contracts/Vault.sol"";
import ""@balancer-labs/v2-vault/contracts/Authorizer.sol"";",73
RealWorld_BA_37_CompoundTempusPool_RealWord_20240820112523.log,37,CompoundTempusPool,20958,5678,26636,99.0,0.21835,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""../TempusPool.sol"";
import ""../protocols/compound/ICErc20.sol"";
import ""../math/Fixed256xVar.sol"";
import ""../utils/UntrustedERC20.sol"";

/// Allows depositing ERC20 into Compound's CErc20 contracts
contract CompoundTempusPool is TempusPool {
    using SafeERC20 for IERC20;
    using UntrustedERC20 for IERC20;
    using Fixed256xVar for uint256;

    ICErc20 internal immutable cToken;
    bytes32 public immutable override protocolName = ""Compound"";

    constructor(
        ICErc20 token,
        address controller,
        uint256 maturity,
        uint256 exchangeRateOne,
        uint256 estYield,
        string memory principalName,
        string memory principalSymbol,
        string memory yieldName,
        string memory yieldSymbol,
        FeesConfig memory maxFeeSetup
    )
        TempusPool(
            address(token),
            token.underlying(),
            controller,
            maturity,
            token.exchangeRateCurrent(),
            exchangeRateOne,
            estYield,
            principalName,
            principalSymbol,
            yieldName,
            yieldSymbol,
            maxFeeSetup
        )
    {
        require(token.isCToken(), ""token is not a CToken"");
        require(token.decimals() == 8, ""CErc20 token must have 8 decimals precision"");
        uint8 underlyingDecimals = ICErc20(token.underlying()).decimals();
        require(underlyingDecimals <= 36, ""Underlying ERC20 token decimals must be <= 36"");

        address[] memory markets = new address[](1);
        markets[0] = address(token);
        require(token.comptroller().enterMarkets(markets)[0] == 0, ""enterMarkets failed"");

        cToken = token;
    }

    function depositToUnderlying(uint256 backingAmount) internal override returns (uint256) {
        require(msg.value == 0, ""ETH deposits not supported"");

        uint preDepositBalance = IERC20(yieldBearingToken).balanceOf(address(this));

        // Pull user's Backing Tokens
        backingAmount = IERC20(backingToken).untrustedTransferFrom(msg.sender, address(this), backingAmount);

        // Deposit to Compound
        IERC20(backingToken).safeIncreaseAllowance(address(cToken), backingAmount);
        require(cToken.mint(backingAmount) == 0, ""CErc20 mint failed"");

        return IERC20(yieldBearingToken).balanceOf(address(this)) - preDepositBalance;
    }

    function withdrawFromUnderlyingProtocol(uint256 yieldBearingTokensAmount, address recipient)
        internal
        override
        returns (uint256 backingTokenAmount)
    {
        // tempus pool owns YBT
        assert(cToken.balanceOf(address(this)) >= yieldBearingTokensAmount);
        require(cToken.redeem(yieldBearingTokensAmount) == 0, ""CErc20 redeem failed"");

        // need to rescale the truncated amount which was used during cToken.redeem()
        uint256 backing = numAssetsPerYieldToken(yieldBearingTokensAmount, updateInterestRate());
        return IERC20(backingToken).untrustedTransfer(recipient, backing);
    }

    /// @return Updated current Interest Rate in 10**(18 - 8 + Underlying Token Decimals) decimal precision
    ///         This varying rate enables simple conversion from Compound cToken to backing token precision
    function updateInterestRate() internal override returns (uint256) {
        // NOTE: exchangeRateCurrent() will accrue interest and gets the latest Interest Rate
        //       The default exchange rate for Compound is 0.02 and grows
        //       cTokens are minted as (backingAmount / rate), so 1 DAI = 50 cDAI with 0.02 rate
        return cToken.exchangeRateCurrent();
    }

    /// @return Current Interest Rate in 10**(18 - 8 + Underlying Token Decimals) decimal precision
    ///         This varying rate enables simple conversion from Compound cToken to backing token precision
    function currentInterestRate() public view override returns (uint256) {
        return cToken.exchangeRateStored();
    }

    // NOTE: yieldTokens are in YieldToken precision, return value is in BackingToken precision
    //       This conversion happens automatically due to pre-scaled rate
    function numAssetsPerYieldToken(uint yieldTokens, uint rate) public pure override returns (uint) {
        return yieldTokens.mulfV(rate, 1e18);
    }

    // NOTE: backingTokens are in BackingToken precision, return value is in YieldToken precision
    //       This conversion happens automatically due to pre-scaled rate
    function numYieldTokensPerAsset(uint backingTokens, uint rate) public pure override returns (uint) {
        return backingTokens.divfV(rate, 1e18);
    }

    function interestRateToSharePrice(uint interestRate) internal pure override returns (uint) {
        // rate is always (10 + backing.decimals), so converting back is always 1e10
        return interestRate / 1e10;
    }
}",1135
RealWorld_BA_37_ITempusPool_RealWord_20240820105403.log,37,ITempusPool,43915,5702,49617,103.0,0.333615,"// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.7.6 <0.9.0;
pragma abicoder v2;

import ""./token/IPoolShare.sol"";

interface ITempusFees {
    // The fees are in terms of yield bearing token (YBT).
    struct FeesConfig {
        uint256 depositPercent;
        uint256 earlyRedeemPercent;
        uint256 matureRedeemPercent;
    }

    /// Returns the current fee configuration.
    function getFeesConfig() external view returns (FeesConfig memory);

    /// Replace the current fee configuration with a new one.
    /// By default all the fees are expected to be set to zero.
    function setFeesConfig(FeesConfig calldata newFeesConfig) external;

    /// @return Maximum possible fee percentage that can be set for deposit
    function maxDepositFee() external view returns (uint256);

    /// @return Maximum possible fee percentage that can be set for early redeem
    function maxEarlyRedeemFee() external view returns (uint256);

    /// @return Maximum possible fee percentage that can be set for mature redeem
    function maxMatureRedeemFee() external view returns (uint256);

    /// Accumulated fees available for withdrawal.
    function totalFees() external view returns (uint256);

    /// Transfers accumulated Yield Bearing Token (YBT) fees
    /// from this pool contract to `recipient`.
    /// @param authorizer Authorizer of the transfer
    /// @param recipient Address which will receive the specified amount of YBT
    function transferFees(address authorizer, address recipient) external;
}

interface ITempusPool is ITempusFees {
    /// @return The version of the pool.
    function version() external view returns (uint);

    /// @return The name of underlying protocol, for example ""Aave"" for Aave protocol
    function protocolName() external view returns (bytes32);

    /// This token will be used as a token that user can deposit to mint same amounts
    /// of principal and interest shares.
    /// @return The underlying yield bearing token.
    function yieldBearingToken() external view returns (address);

    /// This is the address of the actual backing asset token
    /// in the case of ETH, this address will be 0
    /// @return Address of the Backing Token
    function backingToken() external view returns (address);

    /// @return uint256 value of one backing token, in case of 18 decimals 1e18
    function backingTokenONE() external view returns (uint256);

    /// @return This TempusPool's Tempus Principal Share (TPS)
    function principalShare() external view returns (IPoolShare);

    /// @return This TempusPool's Tempus Yield Share (TYS)
    function yieldShare() external view returns (IPoolShare);

    /// @return The TempusController address that is authorized to perform restricted actions
    function controller() external view returns (address);

    /// @return Start time of the pool.
    function startTime() external view returns (uint256);

    /// @return Maturity time of the pool.
    function maturityTime() external view returns (uint256);

    /// @return True if maturity has been reached and the pool was finalized.
    function matured() external view returns (bool);

    /// Finalize the pool. This can only happen on or after `maturityTime`.
    /// Once finalized depositing is not possible anymore, and the behaviour
    /// redemption will change.
    ///
    /// Can be called by anyone and can be called multiple times.
    function finalize() external;

    /// Deposits yield bearing tokens (such as cDAI) into TempusPool
    ///      msg.sender must approve @param yieldTokenAmount to this TempusPool
    ///      NOTE #1 Deposit will fail if maturity has been reached.
    ///      NOTE #2 This function can only be called by TempusController
    /// @param yieldTokenAmount Amount of yield bearing tokens to deposit in YieldToken decimal precision
    /// @param recipient Address which will receive Tempus Principal Shares (TPS) and Tempus Yield Shares (TYS)
    /// @return mintedShares Amount of TPS and TYS minted to `recipient`
    /// @return depositedBT The YBT value deposited, denominated as Backing Tokens
    /// @return fee The fee which was deducted (in terms of YBT)
    /// @return rate The interest rate at the time of the deposit
    function deposit(uint256 yieldTokenAmount, address recipient)
        external
        returns (
            uint256 mintedShares,
            uint256 depositedBT,
            uint256 fee,
            uint256 rate
        );

    /// Deposits backing token to the underlying protocol, and then to Tempus Pool.
    ///      NOTE #1 Deposit will fail if maturity has been reached.
    ///      NOTE #2 This function can only be called by TempusController
    /// @param backingTokenAmount amount of Backing Tokens to be deposited to underlying protocol in BackingToken decimal precision
    /// @param recipient Address which will receive Tempus Principal Shares (TPS) and Tempus Yield Shares (TYS)
    /// @return mintedShares Amount of TPS and TYS minted to `recipient`
    /// @return depositedYBT The BT value deposited, denominated as Yield Bearing Tokens
    /// @return fee The fee which was deducted (in terms of YBT)
    /// @return rate The interest rate at the time of the deposit
    function depositBacking(uint256 backingTokenAmount, address recipient)
        external
        payable
        returns (
            uint256 mintedShares,
            uint256 depositedYBT,
            uint256 fee,
            uint256 rate
        );

    /// Redeem yield bearing tokens from this TempusPool
    ///      msg.sender will receive the YBT
    ///      NOTE #1 Before maturity, principalAmount must equal to yieldAmount.
    ///      NOTE #2 This function can only be called by TempusController
    /// @param from Address to redeem its Tempus Shares
    /// @param principalAmount Amount of Tempus Principal Shares (TPS) to redeem for YBT in PrincipalShare decimal precision
    /// @param yieldAmount Amount of Tempus Yield Shares (TYS) to redeem for YBT in YieldShare decimal precision
    /// @param recipient Address to which redeemed YBT will be sent
    /// @return redeemableYieldTokens Amount of Yield Bearing Tokens redeemed to `recipient`
    /// @return fee The fee which was deducted (in terms of YBT)
    /// @return rate The interest rate at the time of the redemption
    function redeem(
        address from,
        uint256 principalAmount,
        uint256 yieldAmount,
        address recipient
    )
        external
        returns (
            uint256 redeemableYieldTokens,
            uint256 fee,
            uint256 rate
        );

    /// Redeem TPS+TYS held by msg.sender into backing tokens
    ///      `msg.sender` must approve TPS and TYS amounts to this TempusPool.
    ///      `msg.sender` will receive the backing tokens
    ///      NOTE #1 Before maturity, principalAmount must equal to yieldAmount.
    ///      NOTE #2 This function can only be called by TempusController
    /// @param from Address to redeem its Tempus Shares
    /// @param principalAmount Amount of Tempus Principal Shares (TPS) to redeem in PrincipalShare decimal precision
    /// @param yieldAmount Amount of Tempus Yield Shares (TYS) to redeem in YieldShare decimal precision
    /// @param recipient Address to which redeemed BT will be sent
    /// @return redeemableYieldTokens Amount of Backing Tokens redeemed to `recipient`, denominated in YBT
    /// @return redeemableBackingTokens Amount of Backing Tokens redeemed to `recipient`
    /// @return fee The fee which was deducted (in terms of YBT)
    /// @return rate The interest rate at the time of the redemption
    function redeemToBacking(
        address from,
        uint256 principalAmount,
        uint256 yieldAmount,
        address recipient
    )
        external
        payable
        returns (
            uint256 redeemableYieldTokens,
            uint256 redeemableBackingTokens,
            uint256 fee,
            uint256 rate
        );

    /// Gets the estimated amount of Principals and Yields after a successful deposit
    /// @param amount Amount of BackingTokens or YieldBearingTokens that would be deposited
    /// @param isBackingToken If true, @param amount is in BackingTokens, otherwise YieldBearingTokens
    /// @return Amount of Principals (TPS) and Yields (TYS) in Principal/YieldShare decimal precision
    ///         TPS and TYS are minted in 1:1 ratio, hence a single return value.
    function estimatedMintedShares(uint256 amount, bool isBackingToken) external view returns (uint256);

    /// Gets the estimated amount of YieldBearingTokens or BackingTokens received when calling `redeemXXX()` functions
    /// @param principals Amount of Principals (TPS) in PrincipalShare decimal precision
    /// @param yields Amount of Yields (TYS) in YieldShare decimal precision
    /// @param toBackingToken If true, redeem amount is estimated in BackingTokens instead of YieldBearingTokens
    /// @return Amount of YieldBearingTokens or BackingTokens in YBT/BT decimal precision
    function estimatedRedeem(
        uint256 principals,
        uint256 yields,
        bool toBackingToken
    ) external view returns (uint256);

    /// @dev This returns the stored Interest Rate of the YBT (Yield Bearing Token) pool
    ///      it is safe to call this after updateInterestRate() was called
    /// @return Stored Interest Rate, decimal precision depends on specific TempusPool implementation
    function currentInterestRate() external view returns (uint256);

    /// @return Initial interest rate of the underlying pool,
    ///         decimal precision depends on specific TempusPool implementation
    function initialInterestRate() external view returns (uint256);

    /// @return Interest rate at maturity of the underlying pool (or 0 if maturity not reached yet)
    ///         decimal precision depends on specific TempusPool implementation
    function maturityInterestRate() external view returns (uint256);

    /// @return Rate of one Tempus Yield Share expressed in Asset Tokens
    function pricePerYieldShare() external returns (uint256);

    /// @return Rate of one Tempus Principal Share expressed in Asset Tokens
    function pricePerPrincipalShare() external returns (uint256);

    /// Calculated with stored interest rates
    /// @return Rate of one Tempus Yield Share expressed in Asset Tokens,
    function pricePerYieldShareStored() external view returns (uint256);

    /// Calculated with stored interest rates
    /// @return Rate of one Tempus Principal Share expressed in Asset Tokens
    function pricePerPrincipalShareStored() external view returns (uint256);

    /// @dev This returns actual Backing Token amount for amount of YBT (Yield Bearing Tokens)
    ///      For example, in case of Aave and Lido the result is 1:1,
    ///      and for compound is `yieldTokens * currentInterestRate`
    /// @param yieldTokens Amount of YBT in YBT decimal precision
    /// @param interestRate The current interest rate
    /// @return Amount of Backing Tokens for specified @param yieldTokens
    function numAssetsPerYieldToken(uint yieldTokens, uint interestRate) external pure returns (uint);

    /// @dev This returns amount of YBT (Yield Bearing Tokens) that can be converted
    ///      from @param backingTokens Backing Tokens
    /// @param backingTokens Amount of Backing Tokens in BT decimal precision
    /// @param interestRate The current interest rate
    /// @return Amount of YBT for specified @param backingTokens
    function numYieldTokensPerAsset(uint backingTokens, uint interestRate) external pure returns (uint);
}",2554
RealWorld_BA_37_PermanentlyOwnable_RealWord_20240820113011.log,37,PermanentlyOwnable,4716,4215,8931,72.0,0.10788,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.6;

import ""@openzeppelin/contracts/access/Ownable.sol"";

/// A subset of OpenZeppelin's Ownable pattern, where renouncing (transfer to zero-address) is disallowed.
/// In upstream the `transferOwnership` function disallows transfer to the zero-address too.
abstract contract PermanentlyOwnable is Ownable {
    function renounceOwnership() public override onlyOwner {
        revert(""Ownable: Feature disabled"");
    }
}",108
RealWorld_BA_37_StETH_RealWord_20240820105548.log,37,StETH,62528,5387,67915,106.0,0.42038,"// solhint-disable

// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>

// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../../protocols/lido/ILido.sol"";

/*
 * WARNING: THIS IS A SLIGHTLY MODIFIED StETH CONTRACT.
 *
 * It is ported to Solidity 0.8.x, is not pausable, and does not use Aragon storage slots.
 */

/**
 * @title Interest-bearing ERC20-like token for Lido Liquid Stacking protocol.
 *
 * This contract is abstract. To make the contract deployable override the
 * `_getTotalPooledEther` function. `Lido.sol` contract inherits StETH and defines
 * the `_getTotalPooledEther` function.
 *
 * StETH balances are dynamic and represent the holder's share in the total amount
 * of Ether controlled by the protocol. Account shares aren't normalized, so the
 * contract also stores the sum of all shares to calculate each account's token balance
 * which equals to:
 *
 *   shares[account] * _getTotalPooledEther() / _getTotalShares()
 *
 * For example, assume that we have:
 *
 *   _getTotalPooledEther() -> 10 ETH
 *   sharesOf(user1) -> 100
 *   sharesOf(user2) -> 400
 *
 * Therefore:
 *
 *   balanceOf(user1) -> 2 tokens which corresponds 2 ETH
 *   balanceOf(user2) -> 8 tokens which corresponds 8 ETH
 *
 * Since balances of all token holders change when the amount of total pooled Ether
 * changes, this token cannot fully implement ERC20 standard: it only emits `Transfer`
 * events upon explicit transfer between holders. In contrast, when total amount of
 * pooled Ether increases, no `Transfer` events are generated: doing so would require
 * emitting an event for each token holder and thus running an unbounded loop.
 */
abstract contract StETH is ILido {
    /**
     * @dev StETH balances are dynamic and are calculated based on the accounts' shares
     * and the total amount of Ether controlled by the protocol. Account shares aren't
     * normalized, so the contract also stores the sum of all shares to calculate
     * each account's token balance which equals to:
     *
     *   shares[account] * _getTotalPooledEther() / _getTotalShares()
    */
    mapping (address => uint256) private shares;

    /**
     * @dev Allowances are nominated in tokens, not token shares.
     */
    mapping (address => mapping (address => uint256)) private allowances;

    /**
     * @dev Storage position used for holding the total amount of shares in existence.
     *
     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern
     * for value types:
     *
     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage
     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work
     *
     * For reference types, conventional storage variables are used since it's non-trivial
     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;
     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834
     */
    uint256 internal totalShares = 0;

    string internal contractName;
    string internal contractSymbol;
    uint8 internal contractDecimals;

    constructor(
        uint8 _decimals,
        string memory _name,
        string memory _symbol
    ) {
        contractName = _name;
        contractSymbol = _symbol;
        contractDecimals = _decimals;
    }

    /**
     * @return the name of the token.
     */
    function name() public override view returns (string memory) {
        return contractName;
    }

    /**
     * @return the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public override view returns (string memory) {
        return contractSymbol;
    }

    /**
     * @return the number of decimals for getting user representation of a token amount.
     */
    function decimals() public override view returns (uint8) {
        return contractDecimals;
    }

    /**
     * @return the amount of tokens in existence.
     *
     * @dev Always equals to `_getTotalPooledEther()` since token amount
     * is pegged to the total amount of Ether controlled by the protocol.
     */
    function totalSupply() public override view returns (uint256) {
        return _getTotalPooledEther();
    }

    /**
     * @return the entire amount of Ether controlled by the protocol.
     *
     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.
     */
    function getTotalPooledEther() public view returns (uint256) {
        return _getTotalPooledEther();
    }

    /**
     * @return the amount of tokens owned by the `_account`.
     *
     * @dev Balances are dynamic and equal the `_account`'s share in the amount of the
     * total Ether controlled by the protocol. See `sharesOf`.
     */
    function balanceOf(address _account) public override view returns (uint256) {
        return getPooledEthByShares(_sharesOf(_account));
    }

    /**
     * @notice Moves `_amount` tokens from the caller's account to the `_recipient` account.
     *
     * @return a boolean value indicating whether the operation succeeded.
     * Emits a `Transfer` event.
     *
     * Requirements:
     *
     * - `_recipient` cannot be the zero address.
     * - the caller must have a balance of at least `_amount`.
     * - the contract must not be paused.
     *
     * @dev The `_amount` argument is the amount of tokens, not shares.
     */
    function transfer(address _recipient, uint256 _amount) public override returns (bool) {
        _transfer(msg.sender, _recipient, _amount);
        return true;
    }

    /**
     * @return the remaining number of tokens that `_spender` is allowed to spend
     * on behalf of `_owner` through `transferFrom`. This is zero by default.
     *
     * @dev This value changes when `approve` or `transferFrom` is called.
     */
    function allowance(address _owner, address _spender) public override view returns (uint256) {
        return allowances[_owner][_spender];
    }

    /**
     * @notice Sets `_amount` as the allowance of `_spender` over the caller's tokens.
     *
     * @return a boolean value indicating whether the operation succeeded.
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `_spender` cannot be the zero address.
     * - the contract must not be paused.
     *
     * @dev The `_amount` argument is the amount of tokens, not shares.
     */
    function approve(address _spender, uint256 _amount) public override returns (bool) {
        _approve(msg.sender, _spender, _amount);
        return true;
    }

    /**
     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the
     * allowance mechanism. `_amount` is then deducted from the caller's
     * allowance.
     *
     * @return a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `_sender` and `_recipient` cannot be the zero addresses.
     * - `_sender` must have a balance of at least `_amount`.
     * - the caller must have allowance for `_sender`'s tokens of at least `_amount`.
     * - the contract must not be paused.
     *
     * @dev The `_amount` argument is the amount of tokens, not shares.
     */
    function transferFrom(address _sender, address _recipient, uint256 _amount) public override returns (bool) {
        uint256 currentAllowance = allowances[_sender][msg.sender];
        // solhint-disable-next-line reason-string
        require(currentAllowance >= _amount, ""TRANSFER_AMOUNT_EXCEEDS_ALLOWANCE"");

        _transfer(_sender, _recipient, _amount);
        _approve(_sender, msg.sender, currentAllowance - _amount);
        return true;
    }

    /**
     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in:
     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `_spender` cannot be the the zero address.
     * - the contract must not be paused.
     */
    function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool) {
        _approve(msg.sender, _spender, allowances[msg.sender][_spender] + _addedValue);
        return true;
    }

    /**
     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.
     *
     * This is an alternative to `approve` that can be used as a mitigation for
     * problems described in:
     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42
     * Emits an `Approval` event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `_spender` cannot be the zero address.
     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.
     * - the contract must not be paused.
     */
    function decreaseAllowance(address _spender, uint256 _subtractedValue) public returns (bool) {
        uint256 currentAllowance = allowances[msg.sender][_spender];
        require(currentAllowance >= _subtractedValue, ""DECREASED_ALLOWANCE_BELOW_ZERO"");
        _approve(msg.sender, _spender, currentAllowance - _subtractedValue);
        return true;
    }

    /**
     * @return the total amount of shares in existence.
     *
     * @dev The sum of all accounts' shares can be an arbitrary number, therefore
     * it is necessary to store it in order to calculate each account's relative share.
     */
    function getTotalShares() public view returns (uint256) {
        return _getTotalShares();
    }

    /**
     * @return the amount of shares owned by `_account`.
     */
    function sharesOf(address _account) public view returns (uint256) {
        return _sharesOf(_account);
    }

    /**
     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.
     */
    function getSharesByPooledEth(uint256 _ethAmount) public virtual override view returns (uint256) {
        uint256 totalPooledEther = _getTotalPooledEther();
        if (totalPooledEther == 0) {
            return 0;
        } else {
            return (_ethAmount * _getTotalShares()) / totalPooledEther;
        }
    }

    /**
     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.
     */
    function getPooledEthByShares(uint256 _sharesAmount) public virtual override view returns (uint256) {
        uint256 _totalShares = _getTotalShares();
        if (_totalShares == 0) {
            return 0;
        } else {
            return (_sharesAmount * _getTotalPooledEther()) / _totalShares;
        }
    }

    /**
     * @return the total amount (in wei) of Ether controlled by the protocol.
     * @dev This is used for calaulating tokens from shares and vice versa.
     * @dev This function is required to be implemented in a derived contract.
     */
    function _getTotalPooledEther() internal virtual view returns (uint256);

    /**
     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.
     * Emits a `Transfer` event.
     */
    function _transfer(address _sender, address _recipient, uint256 _amount) internal {
        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);
        _transferShares(_sender, _recipient, _sharesToTransfer);
        emit Transfer(_sender, _recipient, _amount);
    }

    /**
     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.
     *
     * Emits an `Approval` event.
     *
     * Requirements:
     *
     * - `_owner` cannot be the zero address.
     * - `_spender` cannot be the zero address.
     * - the contract must not be paused.
     */
    function _approve(address _owner, address _spender, uint256 _amount) internal {
        require(_owner != address(0), ""APPROVE_FROM_ZERO_ADDRESS"");
        require(_spender != address(0), ""APPROVE_TO_ZERO_ADDRESS"");

        allowances[_owner][_spender] = _amount;
        emit Approval(_owner, _spender, _amount);
    }

    /**
     * @return the total amount of shares in existence.
     */
    function _getTotalShares() internal view returns (uint256) {
        return totalShares;
    }

    /**
     * @return the amount of shares owned by `_account`.
     */
    function _sharesOf(address _account) internal view returns (uint256) {
        return shares[_account];
    }

    /**
     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.
     *
     * Requirements:
     *
     * - `_sender` cannot be the zero address.
     * - `_recipient` cannot be the zero address.
     * - `_sender` must hold at least `_sharesAmount` shares.
     * - the contract must not be paused.
     */
    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {
        require(_sender != address(0), ""TRANSFER_FROM_THE_ZERO_ADDRESS"");
        require(_recipient != address(0), ""TRANSFER_TO_THE_ZERO_ADDRESS"");

        uint256 currentSenderShares = shares[_sender];
        require(_sharesAmount <= currentSenderShares, ""TRANSFER_AMOUNT_EXCEEDS_BALANCE"");

        shares[_sender] = currentSenderShares - _sharesAmount;
        shares[_recipient] = shares[_recipient] + _sharesAmount;
    }

    /**
     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.
     * @dev This doesn't increase the token total supply.
     *
     * Requirements:
     *
     * - `_recipient` cannot be the zero address.
     * - the contract must not be paused.
     */
    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {
        require(_recipient != address(0), ""MINT_TO_THE_ZERO_ADDRESS"");

        newTotalShares = _getTotalShares() + _sharesAmount;
        totalShares = newTotalShares;

        shares[_recipient] = shares[_recipient] + _sharesAmount;

        // Notice: we're not emitting a Transfer event from the zero address here since shares mint
        // works by taking the amount of tokens corresponding to the minted shares from all other
        // token holders, proportionally to their share. The total supply of the token doesn't change
        // as the result. This is equivalent to performing a send from each other token holder's
        // address to `address`, but we cannot reflect this as it would require sending an unbounded
        // number of events.
    }

    /**
     * @notice Destroys `_sharesAmount` shares from `_account`'s holdings, decreasing the total amount of shares.
     * @dev This doesn't decrease the token total supply.
     *
     * Requirements:
     *
     * - `_account` cannot be the zero address.
     * - `_account` must hold at least `_sharesAmount` shares.
     * - the contract must not be paused.
     */
    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {
        require(_account != address(0), ""BURN_FROM_THE_ZERO_ADDRESS"");

        uint256 accountShares = shares[_account];
        require(_sharesAmount <= accountShares, ""BURN_AMOUNT_EXCEEDS_BALANCE"");

        newTotalShares = _getTotalShares() - _sharesAmount;
        totalShares = newTotalShares;

        shares[_account] = accountShares - _sharesAmount;

        // Notice: we're not emitting a Transfer event to the zero address here since shares burn
        // works by redistributing the amount of tokens corresponding to the burned shares between
        // all other token holders. The total supply of the token doesn't change as the result.
        // This is equivalent to performing a send from `address` to each other token holder address,
        // but we cannot reflect this as it would require sending an unbounded number of events.
    }
}",3706
RealWorld_BA_37_ComptrollerInterface_RealWord_20240820110401.log,37,ComptrollerInterface,4682,4664,9346,94.0,0.11669,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;

abstract contract ComptrollerInterface {
    /// Assets You Are In
    function enterMarkets(address[] calldata cTokens) external virtual returns (uint[] memory);

    function exitMarket(address cToken) external virtual returns (uint);

    /// Policy Hooks

    function mintAllowed(
        address cToken,
        address minter,
        uint mintAmount
    ) external virtual returns (uint);
}",102
RealWorld_BA_37_ComptrollerStorage_RealWord_20240820110842.log,37,ComptrollerStorage,5162,4569,9731,75.0,0.11719,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;

import ""./CTokenMock.sol"";

contract ComptrollerStorage {
    struct Market {
        /// @notice Per-market mapping of ""accounts in this asset""
        mapping(address => bool) accountMembership;
    }

    /// @notice Official mapping of cTokens -> Market metadata
    /// @dev Used e.g. to determine if a market is supported
    mapping(address => Market) internal markets;

    /// @notice Per-account mapping of ""assets you are in"", capped by maxAssets
    mapping(address => CTokenMock[]) internal accountAssets;
}",132
RealWorld_BA_37_LidoTempusPool_RealWord_20240820112349.log,37,LidoTempusPool,14742,5670,20412,92.0,0.18711,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.6;

import ""../TempusPool.sol"";
import ""../protocols/lido/ILido.sol"";

contract LidoTempusPool is TempusPool {
    ILido internal immutable lido;
    bytes32 public immutable override protocolName = ""Lido"";
    address private immutable referrer;

    constructor(
        ILido token,
        address controller,
        uint256 maturity,
        uint256 estYield,
        string memory principalName,
        string memory principalSymbol,
        string memory yieldName,
        string memory yieldSymbol,
        FeesConfig memory maxFeeSetup,
        address referrerAddress
    )
        TempusPool(
            address(token),
            address(0),
            controller,
            maturity,
            token.getPooledEthByShares(1e18),
            1e18,
            estYield,
            principalName,
            principalSymbol,
            yieldName,
            yieldSymbol,
            maxFeeSetup
        )
    {
        lido = token;
        referrer = referrerAddress;
    }

    function depositToUnderlying(uint256 amount) internal override returns (uint256) {
        require(msg.value == amount, ""ETH value does not match provided amount"");

        uint256 preDepositBalance = IERC20(yieldBearingToken).balanceOf(address(this));
        lido.submit{value: msg.value}(referrer);

        /// TODO: figure out why lido.submit returns a different value than this
        uint256 mintedTokens = IERC20(yieldBearingToken).balanceOf(address(this)) - preDepositBalance;

        return mintedTokens;
    }

    function withdrawFromUnderlyingProtocol(uint256, address)
        internal
        pure
        override
        returns (uint256 backingTokenAmount)
    {
        require(false, ""LidoTempusPool.withdrawFromUnderlyingProtocol not supported"");
        return 0;
    }

    /// @return Updated current Interest Rate as an 1e18 decimal
    function updateInterestRate() internal view override returns (uint256) {
        return lido.getPooledEthByShares(1e18);
    }

    /// @return Stored Interest Rate as an 1e18 decimal
    function currentInterestRate() public view override returns (uint256) {
        // NOTE: if totalShares() is 0, then rate is also 0,
        //       but this only happens right after deploy, so we ignore it
        return lido.getPooledEthByShares(1e18);
    }

    /// NOTE: Lido StETH is pegged 1:1 to ETH
    /// @return Asset Token amount
    function numAssetsPerYieldToken(uint yieldTokens, uint) public pure override returns (uint) {
        return yieldTokens;
    }

    /// NOTE: Lido StETH is pegged 1:1 to ETH
    /// @return YBT amount
    function numYieldTokensPerAsset(uint backingTokens, uint) public pure override returns (uint) {
        return backingTokens;
    }

    function interestRateToSharePrice(uint interestRate) internal pure override returns (uint) {
        return interestRate; // no conversion needed, praise ETH
    }
}",671
RealWorld_BA_37_YieldShare_RealWord_20240820112024.log,37,YieldShare,5888,4390,10278,88.0,0.11724,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.6;

import ""./PoolShare.sol"";

/// @dev Token representing the yield shares of a pool.
contract YieldShare is PoolShare {
    constructor(
        ITempusPool _pool,
        string memory name,
        string memory symbol,
        uint8 decimals
    ) PoolShare(ShareKind.Yield, _pool, name, symbol, decimals) {}

    // solhint-disable-previous-line no-empty-blocks

    function getPricePerFullShare() external override returns (uint256) {
        return pool.pricePerYieldShare();
    }

    function getPricePerFullShareStored() external view override returns (uint256) {
        return pool.pricePerYieldShareStored();
    }
}",158
RealWorld_BA_37_TempusController_RealWord_20240820105027.log,37,TempusController,108247,5575,113822,103.0,0.652735,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

import ""./amm/interfaces/ITempusAMM.sol"";
import ""./amm/interfaces/IVault.sol"";
import ""./ITempusPool.sol"";
import ""./math/Fixed256xVar.sol"";
import ""./utils/PermanentlyOwnable.sol"";
import ""./utils/AMMBalancesHelper.sol"";
import ""./utils/UntrustedERC20.sol"";

contract TempusController is PermanentlyOwnable, ReentrancyGuard {
    using Fixed256xVar for uint256;
    using SafeERC20 for IERC20;
    using UntrustedERC20 for IERC20;
    using AMMBalancesHelper for uint256[];

    /// @dev Event emitted on a successful BT/YBT deposit.
    /// @param pool The Tempus Pool to which assets were deposited
    /// @param depositor Address of the user who deposited Yield Bearing Tokens to mint
    ///                  Tempus Principal Share (TPS) and Tempus Yield Shares
    /// @param recipient Address of the recipient who will receive TPS and TYS tokens
    /// @param yieldTokenAmount Amount of yield tokens received from underlying pool
    /// @param backingTokenValue Value of @param yieldTokenAmount expressed in backing tokens
    /// @param shareAmounts Number of Tempus Principal Shares (TPS) and Tempus Yield Shares (TYS) granted to `recipient`
    /// @param interestRate Interest Rate of the underlying pool from Yield Bearing Tokens to the underlying asset
    /// @param fee The fee which was deducted (in terms of yield bearing tokens)
    event Deposited(
        address indexed pool,
        address indexed depositor,
        address indexed recipient,
        uint256 yieldTokenAmount,
        uint256 backingTokenValue,
        uint256 shareAmounts,
        uint256 interestRate,
        uint256 fee
    );

    /// @dev Event emitted on a successful BT/YBT redemption.
    /// @param pool The Tempus Pool from which Tempus Shares were redeemed
    /// @param redeemer Address of the user whose Shares (Principals and Yields) are redeemed
    /// @param recipient Address of user that recieved Yield Bearing Tokens
    /// @param principalShareAmount Number of Tempus Principal Shares (TPS) to redeem into the Yield Bearing Token (YBT)
    /// @param yieldShareAmount Number of Tempus Yield Shares (TYS) to redeem into the Yield Bearing Token (YBT)
    /// @param yieldTokenAmount Number of Yield bearing tokens redeemed from the pool
    /// @param backingTokenValue Value of @param yieldTokenAmount expressed in backing tokens
    /// @param interestRate Interest Rate of the underlying pool from Yield Bearing Tokens to the underlying asset
    /// @param fee The fee which was deducted (in terms of yield bearing tokens)
    /// @param isEarlyRedeem True in case of early redemption, otherwise false
    event Redeemed(
        address indexed pool,
        address indexed redeemer,
        address indexed recipient,
        uint256 principalShareAmount,
        uint256 yieldShareAmount,
        uint256 yieldTokenAmount,
        uint256 backingTokenValue,
        uint256 interestRate,
        uint256 fee,
        bool isEarlyRedeem
    );

    /// @dev Atomically deposits YBT/BT to TempusPool and provides liquidity
    ///      to the corresponding Tempus AMM with the issued TYS & TPS
    /// @param tempusAMM Tempus AMM to use to swap TYS for TPS
    /// @param tokenAmount Amount of YBT/BT to be deposited
    /// @param isBackingToken specifies whether the deposited asset is the Backing Token or Yield Bearing Token
    function depositAndProvideLiquidity(
        ITempusAMM tempusAMM,
        uint256 tokenAmount,
        bool isBackingToken
    ) external payable nonReentrant {
        _depositAndProvideLiquidity(tempusAMM, tokenAmount, isBackingToken);
    }

    /// @dev Adds liquidity to tempusAMM with ratio of shares that is equal to ratio in AMM
    /// @param tempusAMM Tempus AMM to provide liquidity to
    /// @param sharesAmount Amount of shares to be used to provide liquidity, one of the sahres will be partially used
    /// @notice If sharesAmount is 100 and amm balances ratio is 1 principal : 10 yields 90 principal will be ""unused""
    ///         So, liquidity will be provided with 10 principals and 100 yields
    /// @notice msg.sender needs to approve Controller for both Principals and Yields for @param sharesAmount
    function provideLiquidity(ITempusAMM tempusAMM, uint256 sharesAmount) external nonReentrant {
        (
            IVault vault,
            bytes32 poolId,
            IERC20[] memory ammTokens,
            uint256[] memory ammBalances
        ) = _getAMMDetailsAndEnsureInitialized(tempusAMM);

        _provideLiquidity(msg.sender, vault, poolId, ammTokens, ammBalances, sharesAmount, msg.sender);
    }

    /// @dev Atomically deposits YBT/BT to TempusPool and swaps TYS for TPS to get fixed yield
    ///      See https://docs.balancer.fi/developers/guides/single-swaps#swap-overview
    /// @param tempusAMM Tempus AMM to use to swap TYS for TPS
    /// @param tokenAmount Amount of YBT/BT to be deposited in underlying YBT/BT decimal precision
    /// @param isBackingToken specifies whether the deposited asset is the Backing Token or Yield Bearing Token
    /// @param minTYSRate Minimum exchange rate of TYS (denominated in TPS) to receive in exchange for TPS
    function depositAndFix(
        ITempusAMM tempusAMM,
        uint256 tokenAmount,
        bool isBackingToken,
        uint256 minTYSRate
    ) external payable nonReentrant {
        _depositAndFix(tempusAMM, tokenAmount, isBackingToken, minTYSRate);
    }

    /// @dev Deposits Yield Bearing Tokens to a Tempus Pool.
    /// @param targetPool The Tempus Pool to which tokens will be deposited
    /// @param yieldTokenAmount amount of Yield Bearing Tokens to be deposited
    ///                         in YBT Contract precision which can be 18 or 8 decimals
    /// @param recipient Address which will receive Tempus Principal Shares (TPS) and Tempus Yield Shares (TYS)
    function depositYieldBearing(
        ITempusPool targetPool,
        uint256 yieldTokenAmount,
        address recipient
    ) public nonReentrant {
        _depositYieldBearing(targetPool, yieldTokenAmount, recipient);
    }

    /// @dev Deposits Backing Tokens into the underlying protocol and
    ///      then deposited the minted Yield Bearing Tokens to the Tempus Pool.
    /// @param targetPool The Tempus Pool to which tokens will be deposited
    /// @param backingTokenAmount amount of Backing Tokens to be deposited into the underlying protocol
    /// @param recipient Address which will receive Tempus Principal Shares (TPS) and Tempus Yield Shares (TYS)
    function depositBacking(
        ITempusPool targetPool,
        uint256 backingTokenAmount,
        address recipient
    ) public payable nonReentrant {
        _depositBacking(targetPool, backingTokenAmount, recipient);
    }

    /// @dev Redeem TPS+TYS held by msg.sender into Yield Bearing Tokens
    /// @notice `msg.sender` must approve Principals and Yields amounts to `targetPool`
    /// @notice `msg.sender` will receive yield bearing tokens
    /// @notice Before maturity, `principalAmount` must equal to `yieldAmount`
    /// @param targetPool The Tempus Pool from which to redeem Tempus Shares
    /// @param principalAmount Amount of Tempus Principals to redeem in PrincipalShare decimal precision
    /// @param yieldAmount Amount of Tempus Yields to redeem in YieldShare decimal precision
    /// @param recipient Address of user that will recieve yield bearing tokens
    function redeemToYieldBearing(
        ITempusPool targetPool,
        uint256 principalAmount,
        uint256 yieldAmount,
        address recipient
    ) public nonReentrant {
        _redeemToYieldBearing(targetPool, msg.sender, principalAmount, yieldAmount, recipient);
    }

    /// @dev Redeem TPS+TYS held by msg.sender into Backing Tokens
    /// @notice `sender` must approve Principals and Yields amounts to this TempusPool
    /// @notice `recipient` will receive the backing tokens
    /// @notice Before maturity, `principalAmount` must equal to `yieldAmount`
    /// @param targetPool The Tempus Pool from which to redeem Tempus Shares
    /// @param principalAmount Amount of Tempus Principals to redeem in PrincipalShare decimal precision
    /// @param yieldAmount Amount of Tempus Yields to redeem in YieldShare decimal precision
    /// @param recipient Address of user that will recieve yield bearing tokens
    function redeemToBacking(
        ITempusPool targetPool,
        uint256 principalAmount,
        uint256 yieldAmount,
        address recipient
    ) public nonReentrant {
        _redeemToBacking(targetPool, msg.sender, principalAmount, yieldAmount, recipient);
    }

    /// @dev Withdraws liquidity from TempusAMM
    /// @notice `msg.sender` needs to approve controller for @param lpTokensAmount of LP tokens
    /// @notice Transfers LP tokens to controller and exiting tempusAmm with `msg.sender` as recipient
    /// @param tempusAMM Tempus AMM instance
    /// @param lpTokensAmount Amount of LP tokens to be withdrawn
    /// @param principalAmountOutMin Minimal amount of TPS to be withdrawn
    /// @param yieldAmountOutMin Minimal amount of TYS to be withdrawn
    /// @param toInternalBalances Withdrawing liquidity to internal balances
    function exitTempusAMM(
        ITempusAMM tempusAMM,
        uint256 lpTokensAmount,
        uint256 principalAmountOutMin,
        uint256 yieldAmountOutMin,
        bool toInternalBalances
    ) external nonReentrant {
        _exitTempusAMM(tempusAMM, lpTokensAmount, principalAmountOutMin, yieldAmountOutMin, toInternalBalances);
    }

    /// @dev Withdraws liquidity from TempusAMM and redeems Shares to Yield Bearing or Backing Tokens
    ///      Checks user's balance of principal shares and yield shares
    ///      and exits AMM with exact amounts needed for redemption.
    /// @notice `msg.sender` needs to approve `tempusAMM.tempusPool` for both Yields and Principals
    ///         for `sharesAmount`
    /// @notice `msg.sender` needs to approve controller for whole balance of LP token
    /// @notice Transfers users' LP tokens to controller, then exits tempusAMM with `msg.sender` as recipient.
    ///         After exit transfers remainder of LP tokens back to user
    /// @notice Can fail if there is not enough user balance
    /// @notice Only available before maturity since exiting AMM with exact amounts is disallowed after maturity
    /// @param tempusAMM TempusAMM instance to withdraw liquidity from
    /// @param principals Amount of Principals to redeem
    /// @param yields Amount of Yields to redeem
    /// @param principalsStaked Amount of staked principals (in TempusAMM) to redeem
    /// @param yieldsStaked Amount of staked yields (in TempusAMM) to redeem
    /// @param maxLpTokensToRedeem Maximum amount of LP tokens to spend for staked shares redemption
    /// @param toBackingToken If true redeems to backing token, otherwise redeems to yield bearing
    function exitTempusAMMAndRedeem(
        ITempusAMM tempusAMM,
        uint256 principals,
        uint256 yields,
        uint256 principalsStaked,
        uint256 yieldsStaked,
        uint256 maxLpTokensToRedeem,
        bool toBackingToken
    ) external nonReentrant {
        _exitTempusAMMAndRedeem(
            tempusAMM,
            principals,
            yields,
            principalsStaked,
            yieldsStaked,
            maxLpTokensToRedeem,
            toBackingToken
        );
    }

    /// @dev Withdraws ALL liquidity from TempusAMM and redeems Shares to Yield Bearing or Backing Tokens
    /// @notice `msg.sender` needs to approve controller for whole balance for both Yields and Principals
    /// @notice `msg.sender` needs to approve controller for whole balance of LP token
    /// @notice Can fail if there is not enough user balance
    /// @param tempusAMM TempusAMM instance to withdraw liquidity from
    /// @param lpTokens Number of Lp tokens to redeem
    /// @param principals Number of Principals to redeem
    /// @param yields Number of Yields to redeem
    /// @param minPrincipalsStaked Minimum amount of staked principals to redeem for `lpTokens`
    /// @param minYieldsStaked Minimum amount of staked yields to redeem for `lpTokens`
    /// @param maxLeftoverShares Maximum amount of Principals or Yields to be left in case of early exit
    /// @param toBackingToken If true redeems to backing token, otherwise redeems to yield bearing
    function exitTempusAmmAndRedeem(
        ITempusAMM tempusAMM,
        uint256 lpTokens,
        uint256 principals,
        uint256 yields,
        uint256 minPrincipalsStaked,
        uint256 minYieldsStaked,
        uint256 maxLeftoverShares,
        bool toBackingToken
    ) external nonReentrant {
        _exitTempusAmmAndRedeem(
            tempusAMM,
            lpTokens,
            principals,
            yields,
            getAMMOrderedAmounts(tempusAMM.tempusPool(), minPrincipalsStaked, minYieldsStaked),
            maxLeftoverShares,
            toBackingToken
        );
    }

    /// Finalize the pool after maturity.
    function finalize(ITempusPool targetPool) external nonReentrant {
        targetPool.finalize();
    }

    /// Transfers accumulated Yield Bearing Token (YBT) fees
    /// from @param targetPool contract to `recipient`.
    /// @param targetPool The Tempus Pool from which to transfer fees
    /// @param recipient Address which will receive the specified amount of YBT
    function transferFees(ITempusPool targetPool, address recipient) external nonReentrant {
        targetPool.transferFees(msg.sender, recipient);
    }

    function swap(
        ITempusAMM tempusAMM,
        uint256 swapAmount,
        IERC20 tokenIn,
        IERC20 tokenOut,
        uint256 minReturn
    ) private {
        require(swapAmount > 0, ""Invalid swap amount."");
        tokenIn.safeIncreaseAllowance(address(tempusAMM.getVault()), swapAmount);

        (IVault vault, bytes32 poolId, , ) = _getAMMDetailsAndEnsureInitialized(tempusAMM);

        IVault.SingleSwap memory singleSwap = IVault.SingleSwap({
            poolId: poolId,
            kind: IVault.SwapKind.GIVEN_IN,
            assetIn: tokenIn,
            assetOut: tokenOut,
            amount: swapAmount,
            userData: """"
        });

        IVault.FundManagement memory fundManagement = IVault.FundManagement({
            sender: address(this),
            fromInternalBalance: false,
            recipient: payable(address(this)),
            toInternalBalance: false
        });
        vault.swap(singleSwap, fundManagement, minReturn, block.timestamp);
    }

    function _depositAndProvideLiquidity(
        ITempusAMM tempusAMM,
        uint256 tokenAmount,
        bool isBackingToken
    ) private {
        (
            IVault vault,
            bytes32 poolId,
            IERC20[] memory ammTokens,
            uint256[] memory ammBalances
        ) = _getAMMDetailsAndEnsureInitialized(tempusAMM);

        uint256 mintedShares = _deposit(tempusAMM.tempusPool(), tokenAmount, isBackingToken);

        uint256[] memory sharesUsed = _provideLiquidity(
            address(this),
            vault,
            poolId,
            ammTokens,
            ammBalances,
            mintedShares,
            msg.sender
        );

        // Send remaining Shares to user
        if (sharesUsed[0] < mintedShares) {
            ammTokens[0].safeTransfer(msg.sender, mintedShares - sharesUsed[0]);
        }
        if (sharesUsed[1] < mintedShares) {
            ammTokens[1].safeTransfer(msg.sender, mintedShares - sharesUsed[1]);
        }
    }

    function _provideLiquidity(
        address sender,
        IVault vault,
        bytes32 poolId,
        IERC20[] memory ammTokens,
        uint256[] memory ammBalances,
        uint256 sharesAmount,
        address recipient
    ) private returns (uint256[] memory) {
        uint256[] memory ammLiquidityProvisionAmounts = ammBalances.getLiquidityProvisionSharesAmounts(sharesAmount);

        if (sender != address(this)) {
            ammTokens[0].safeTransferFrom(sender, address(this), ammLiquidityProvisionAmounts[0]);
            ammTokens[1].safeTransferFrom(sender, address(this), ammLiquidityProvisionAmounts[1]);
        }

        ammTokens[0].safeIncreaseAllowance(address(vault), ammLiquidityProvisionAmounts[0]);
        ammTokens[1].safeIncreaseAllowance(address(vault), ammLiquidityProvisionAmounts[1]);

        IVault.JoinPoolRequest memory request = IVault.JoinPoolRequest({
            assets: ammTokens,
            maxAmountsIn: ammLiquidityProvisionAmounts,
            userData: abi.encode(uint8(ITempusAMM.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT), ammLiquidityProvisionAmounts),
            fromInternalBalance: false
        });

        // Provide TPS/TYS liquidity to TempusAMM
        vault.joinPool(poolId, address(this), recipient, request);

        return ammLiquidityProvisionAmounts;
    }

    function _depositAndFix(
        ITempusAMM tempusAMM,
        uint256 tokenAmount,
        bool isBackingToken,
        uint256 minTYSRate
    ) private {
        ITempusPool targetPool = tempusAMM.tempusPool();
        IERC20 principalShares = IERC20(address(targetPool.principalShare()));
        IERC20 yieldShares = IERC20(address(targetPool.yieldShare()));

        uint256 swapAmount = _deposit(targetPool, tokenAmount, isBackingToken);

        yieldShares.safeIncreaseAllowance(address(tempusAMM.getVault()), swapAmount);
        uint256 minReturn = swapAmount.mulfV(minTYSRate, targetPool.backingTokenONE());
        swap(tempusAMM, swapAmount, yieldShares, principalShares, minReturn);

        // At this point all TYS must be swapped for TPS
        uint256 principalsBalance = principalShares.balanceOf(address(this));
        assert(principalsBalance > 0);
        assert(yieldShares.balanceOf(address(this)) == 0);

        principalShares.safeTransfer(msg.sender, principalsBalance);
    }

    function _deposit(
        ITempusPool targetPool,
        uint256 tokenAmount,
        bool isBackingToken
    ) private returns (uint256 mintedShares) {
        mintedShares = isBackingToken
            ? _depositBacking(targetPool, tokenAmount, address(this))
            : _depositYieldBearing(targetPool, tokenAmount, address(this));
    }

    function _depositYieldBearing(
        ITempusPool targetPool,
        uint256 yieldTokenAmount,
        address recipient
    ) private returns (uint256) {
        require(yieldTokenAmount > 0, ""yieldTokenAmount is 0"");

        IERC20 yieldBearingToken = IERC20(targetPool.yieldBearingToken());

        // Deposit to controller and approve transfer from controller to targetPool
        uint transferredYBT = yieldBearingToken.untrustedTransferFrom(msg.sender, address(this), yieldTokenAmount);
        yieldBearingToken.safeIncreaseAllowance(address(targetPool), transferredYBT);

        (uint mintedShares, uint depositedBT, uint fee, uint rate) = targetPool.deposit(transferredYBT, recipient);

        emit Deposited(
            address(targetPool),
            msg.sender,
            recipient,
            transferredYBT,
            depositedBT,
            mintedShares,
            rate,
            fee
        );

        return mintedShares;
    }

    function _depositBacking(
        ITempusPool targetPool,
        uint256 backingTokenAmount,
        address recipient
    ) private returns (uint256) {
        require(backingTokenAmount > 0, ""backingTokenAmount is 0"");

        IERC20 backingToken = IERC20(targetPool.backingToken());

        if (msg.value == 0) {
            backingTokenAmount = backingToken.untrustedTransferFrom(msg.sender, address(this), backingTokenAmount);
            backingToken.safeIncreaseAllowance(address(targetPool), backingTokenAmount);
        } else {
            require(address(backingToken) == address(0), ""given TempusPool's Backing Token is not ETH"");
        }

        (uint256 mintedShares, uint256 depositedYBT, uint256 fee, uint256 interestRate) = targetPool.depositBacking{
            value: msg.value
        }(backingTokenAmount, recipient);

        emit Deposited(
            address(targetPool),
            msg.sender,
            recipient,
            depositedYBT,
            backingTokenAmount,
            mintedShares,
            interestRate,
            fee
        );

        return mintedShares;
    }

    function _redeemToYieldBearing(
        ITempusPool targetPool,
        address sender,
        uint256 principals,
        uint256 yields,
        address recipient
    ) private {
        require((principals > 0) || (yields > 0), ""principalAmount and yieldAmount cannot both be 0"");

        (uint redeemedYBT, uint fee, uint interestRate) = targetPool.redeem(sender, principals, yields, recipient);

        uint redeemedBT = targetPool.numAssetsPerYieldToken(redeemedYBT, targetPool.currentInterestRate());
        bool earlyRedeem = !targetPool.matured();
        emit Redeemed(
            address(targetPool),
            sender,
            recipient,
            principals,
            yields,
            redeemedYBT,
            redeemedBT,
            fee,
            interestRate,
            earlyRedeem
        );
    }

    function _redeemToBacking(
        ITempusPool targetPool,
        address sender,
        uint256 principals,
        uint256 yields,
        address recipient
    ) private {
        require((principals > 0) || (yields > 0), ""principalAmount and yieldAmount cannot both be 0"");

        (uint redeemedYBT, uint redeemedBT, uint fee, uint rate) = targetPool.redeemToBacking(
            sender,
            principals,
            yields,
            recipient
        );

        bool earlyRedeem = !targetPool.matured();
        emit Redeemed(
            address(targetPool),
            sender,
            recipient,
            principals,
            yields,
            redeemedYBT,
            redeemedBT,
            fee,
            rate,
            earlyRedeem
        );
    }

    function _exitTempusAMM(
        ITempusAMM tempusAMM,
        uint256 lpTokensAmount,
        uint256 principalAmountOutMin,
        uint256 yieldAmountOutMin,
        bool toInternalBalances
    ) private {
        require(tempusAMM.transferFrom(msg.sender, address(this), lpTokensAmount), ""LP token transfer failed"");

        ITempusPool tempusPool = tempusAMM.tempusPool();
        uint256[] memory amounts = getAMMOrderedAmounts(tempusPool, principalAmountOutMin, yieldAmountOutMin);
        _exitTempusAMMGivenLP(tempusAMM, address(this), msg.sender, lpTokensAmount, amounts, toInternalBalances);

        assert(tempusAMM.balanceOf(address(this)) == 0);
    }

    function _exitTempusAMMGivenLP(
        ITempusAMM tempusAMM,
        address sender,
        address recipient,
        uint256 lpTokensAmount,
        uint256[] memory minAmountsOut,
        bool toInternalBalances
    ) private {
        require(lpTokensAmount > 0, ""LP token amount is 0"");

        (IVault vault, bytes32 poolId, IERC20[] memory ammTokens, ) = _getAMMDetailsAndEnsureInitialized(tempusAMM);

        IVault.ExitPoolRequest memory request = IVault.ExitPoolRequest({
            assets: ammTokens,
            minAmountsOut: minAmountsOut,
            userData: abi.encode(uint8(ITempusAMM.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT), lpTokensAmount),
            toInternalBalance: toInternalBalances
        });
        vault.exitPool(poolId, sender, payable(recipient), request);
    }

    function _exitTempusAMMGivenAmountsOut(
        ITempusAMM tempusAMM,
        address sender,
        address recipient,
        uint256[] memory amountsOut,
        uint256 lpTokensAmountInMax,
        bool toInternalBalances
    ) private {
        (IVault vault, bytes32 poolId, IERC20[] memory ammTokens, ) = _getAMMDetailsAndEnsureInitialized(tempusAMM);

        IVault.ExitPoolRequest memory request = IVault.ExitPoolRequest({
            assets: ammTokens,
            minAmountsOut: amountsOut,
            userData: abi.encode(
                uint8(ITempusAMM.ExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT),
                amountsOut,
                lpTokensAmountInMax
            ),
            toInternalBalance: toInternalBalances
        });
        vault.exitPool(poolId, sender, payable(recipient), request);
    }

    function _exitTempusAMMAndRedeem(
        ITempusAMM tempusAMM,
        uint256 principals,
        uint256 yields,
        uint256 principalsStaked,
        uint256 yieldsStaked,
        uint256 maxLpTokensToRedeem,
        bool toBackingToken
    ) private {
        ITempusPool tempusPool = tempusAMM.tempusPool();
        require(!tempusPool.matured(), ""Pool already finalized"");
        principals += principalsStaked;
        yields += yieldsStaked;
        require(principals == yields, ""Needs equal amounts of shares before maturity"");

        // transfer LP tokens to controller
        require(tempusAMM.transferFrom(msg.sender, address(this), maxLpTokensToRedeem), ""LP token transfer failed"");

        uint256[] memory amounts = getAMMOrderedAmounts(tempusPool, principalsStaked, yieldsStaked);
        _exitTempusAMMGivenAmountsOut(tempusAMM, address(this), msg.sender, amounts, maxLpTokensToRedeem, false);

        // transfer remainder of LP tokens back to user
        uint256 lpTokenBalance = tempusAMM.balanceOf(address(this));
        require(tempusAMM.transferFrom(address(this), msg.sender, lpTokenBalance), ""LP token transfer failed"");

        if (toBackingToken) {
            _redeemToBacking(tempusPool, msg.sender, principals, yields, msg.sender);
        } else {
            _redeemToYieldBearing(tempusPool, msg.sender, principals, yields, msg.sender);
        }
    }

    function _exitTempusAmmAndRedeem(
        ITempusAMM tempusAMM,
        uint256 lpTokens,
        uint256 principals,
        uint256 yields,
        uint256[] memory minLpAmountsOut,
        uint256 maxLeftoverShares,
        bool toBackingToken
    ) private {
        ITempusPool tempusPool = tempusAMM.tempusPool();

        IERC20 principalShare = IERC20(address(tempusPool.principalShare()));
        IERC20 yieldShare = IERC20(address(tempusPool.yieldShare()));
        require(principalShare.transferFrom(msg.sender, address(this), principals), ""Principals transfer failed"");
        require(yieldShare.transferFrom(msg.sender, address(this), yields), ""Yields transfer failed"");

        if (lpTokens > 0) {
            // if there is LP balance, transfer to controller
            require(tempusAMM.transferFrom(msg.sender, address(this), lpTokens), ""LP token transfer failed"");

            // exit amm and sent shares to controller
            _exitTempusAMMGivenLP(tempusAMM, address(this), address(this), lpTokens, minLpAmountsOut, false);
        }

        principals = principalShare.balanceOf(address(this));
        yields = yieldShare.balanceOf(address(this));

        if (!tempusPool.matured()) {
            bool yieldsIn = yields > principals;
            uint256 difference = yieldsIn ? (yields - principals) : (principals - yields);

            if (difference >= maxLeftoverShares) {
                (IERC20 tokenIn, IERC20 tokenOut) = yieldsIn
                    ? (yieldShare, principalShare)
                    : (principalShare, yieldShare);

                swap(
                    tempusAMM,
                    tempusAMM.getSwapAmountToEndWithEqualShares(principals, yields, maxLeftoverShares),
                    tokenIn,
                    tokenOut,
                    0
                );

                principals = principalShare.balanceOf(address(this));
                yields = yieldShare.balanceOf(address(this));
            }
            (yields, principals) = (principals <= yields) ? (principals, principals) : (yields, yields);
        }

        if (toBackingToken) {
            _redeemToBacking(tempusPool, address(this), principals, yields, msg.sender);
        } else {
            _redeemToYieldBearing(tempusPool, address(this), principals, yields, msg.sender);
        }
    }

    function _getAMMDetailsAndEnsureInitialized(ITempusAMM tempusAMM)
        private
        view
        returns (
            IVault vault,
            bytes32 poolId,
            IERC20[] memory ammTokens,
            uint256[] memory ammBalances
        )
    {
        vault = tempusAMM.getVault();
        poolId = tempusAMM.getPoolId();
        (ammTokens, ammBalances, ) = vault.getPoolTokens(poolId);
        require(
            ammTokens.length == 2 && ammBalances.length == 2 && ammBalances[0] > 0 && ammBalances[1] > 0,
            ""AMM not initialized""
        );
    }

    function getAMMOrderedAmounts(
        ITempusPool tempusPool,
        uint256 principalAmount,
        uint256 yieldAmount
    ) private view returns (uint256[] memory) {
        uint256[] memory amounts = new uint256[](2);
        (amounts[0], amounts[1]) = (tempusPool.principalShare() < tempusPool.yieldShare())
            ? (principalAmount, yieldAmount)
            : (yieldAmount, principalAmount);
        return amounts;
    }
}",6853
RealWorld_BA_37_IPoolShare_RealWord_20240820111243.log,37,IPoolShare,6823,4273,11096,74.0,0.119575,"// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.7.6 <0.9.0;

import ""../ITempusPool.sol"";

/// Interface of Tokens representing the principal or yield shares of a pool.
interface IPoolShare {
    enum ShareKind {
        Principal,
        Yield
    }

    /// @return The kind of the share.
    function kind() external view returns (ShareKind);

    /// @return The pool this share is part of.
    function pool() external view returns (ITempusPool);

    /// @dev Price per single share expressed in Backing Tokens of the underlying pool.
    ///      This is for the purpose of TempusAMM api support.
    ///      Example: exchanging Tempus Yield Share to DAI
    /// @return 1e18 decimal conversion rate per share
    function getPricePerFullShare() external returns (uint256);

    /// @return 1e18 decimal stored conversion rate per share
    function getPricePerFullShareStored() external view returns (uint256);
}",216
RealWorld_BA_37_Fixed256xVar_RealWord_20240820113125.log,37,Fixed256xVar,6860,4225,11085,67.0,0.1188,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.6;

/// @dev Fixed Point decimal math utils for variable decimal point precision
///      on 256-bit wide numbers
library Fixed256xVar {
    /// @dev Multiplies two variable precision fixed point decimal numbers
    /// @param one 1.0 expressed in the base precision of `a` and `b`
    /// @return result = a * b
    function mulfV(
        uint256 a,
        uint256 b,
        uint256 one
    ) internal pure returns (uint256) {
        // TODO: should we add rounding rules?
        return (a * b) / one;
    }

    /// @dev Divides two variable precision fixed point decimal numbers
    /// @param one 1.0 expressed in the base precision of `a` and `b`
    /// @return result = a / b
    function divfV(
        uint256 a,
        uint256 b,
        uint256 one
    ) internal pure returns (uint256) {
        // TODO: should we add rounding rules?
        return (a * one) / b;
    }
}",246
RealWorld_BA_37_UntrustedERC20_RealWord_20240820112704.log,37,UntrustedERC20,8638,5132,13770,98.0,0.14583,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

/// @title UntrustedERC20
/// @dev Wrappers around ERC20 transfer operators that return the actual amount
/// transferred. This means they are usable with tokens, which charge a fee or royalty on transfer.
library UntrustedERC20 {
    using SafeERC20 for IERC20;

    /// Transfer tokens to a recipient.
    /// @param token The ERC20 token.
    /// @param to The recipient.
    /// @param value The requested amount.
    /// @return The actual amount of tokens transferred.
    function untrustedTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal returns (uint256) {
        uint256 startBalance = token.balanceOf(to);
        token.safeTransfer(to, value);
        return token.balanceOf(to) - startBalance;
    }

    /// Transfer tokens to a recipient.
    /// @param token The ERC20 token.
    /// @param from The sender.
    /// @param to The recipient.
    /// @param value The requested amount.
    /// @return The actual amount of tokens transferred.
    function untrustedTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal returns (uint256) {
        uint256 startBalance = token.balanceOf(to);
        token.safeTransferFrom(from, to, value);
        return token.balanceOf(to) - startBalance;
    }
}",346
RealWorld_BA_37_TempusPool_RealWord_20240820105212.log,37,TempusPool,66044,5788,71832,108.0,0.44598,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""./ITempusPool.sol"";
import ""./token/PrincipalShare.sol"";
import ""./token/YieldShare.sol"";
import ""./math/Fixed256xVar.sol"";
import ""./utils/PermanentlyOwnable.sol"";
import ""./utils/UntrustedERC20.sol"";

/// @author The tempus.finance team
/// @title Implementation of Tempus Pool
abstract contract TempusPool is ITempusPool, PermanentlyOwnable {
    using SafeERC20 for IERC20;
    using UntrustedERC20 for IERC20;
    using Fixed256xVar for uint256;

    uint public constant override version = 1;

    address public immutable override yieldBearingToken;
    address public immutable override backingToken;

    uint256 public immutable override startTime;
    uint256 public immutable override maturityTime;

    uint256 public immutable override initialInterestRate;
    uint256 public immutable exchangeRateONE;
    uint256 public immutable yieldBearingONE;
    uint256 public immutable override backingTokenONE;
    uint256 public override maturityInterestRate;
    IPoolShare public immutable override principalShare;
    IPoolShare public immutable override yieldShare;
    address public immutable override controller;

    uint256 private immutable initialEstimatedYield;

    bool public override matured;

    FeesConfig feesConfig;

    uint256 public immutable override maxDepositFee;
    uint256 public immutable override maxEarlyRedeemFee;
    uint256 public immutable override maxMatureRedeemFee;

    /// total amount of fees accumulated in pool
    uint256 public override totalFees;

    /// Constructs Pool with underlying token, start and maturity date
    /// @param _yieldBearingToken Yield Bearing Token, such as cDAI or aUSDC
    /// @param _backingToken backing token (or zero address if ETH)
    /// @param ctrl The authorized TempusController of the pool
    /// @param maturity maturity time of this pool
    /// @param initInterestRate initial interest rate of the pool
    /// @param exchangeRateOne 1.0 expressed in exchange rate decimal precision
    /// @param estimatedFinalYield estimated yield for the whole lifetime of the pool
    /// @param principalName name of Tempus Principal Share
    /// @param principalSymbol symbol of Tempus Principal Share
    /// @param yieldName name of Tempus Yield Share
    /// @param yieldSymbol symbol of Tempus Yield Share
    /// @param maxFeeSetup Maximum fee percentages that this pool can have,
    ///                    values in Yield Bearing Token precision
    constructor(
        address _yieldBearingToken,
        address _backingToken,
        address ctrl,
        uint256 maturity,
        uint256 initInterestRate,
        uint256 exchangeRateOne,
        uint256 estimatedFinalYield,
        string memory principalName,
        string memory principalSymbol,
        string memory yieldName,
        string memory yieldSymbol,
        FeesConfig memory maxFeeSetup
    ) {
        require(maturity > block.timestamp, ""maturityTime is after startTime"");

        yieldBearingToken = _yieldBearingToken;
        backingToken = _backingToken;
        controller = ctrl;
        startTime = block.timestamp;
        maturityTime = maturity;
        initialInterestRate = initInterestRate;
        exchangeRateONE = exchangeRateOne;
        yieldBearingONE = 10**ERC20(_yieldBearingToken).decimals();
        initialEstimatedYield = estimatedFinalYield;

        maxDepositFee = maxFeeSetup.depositPercent;
        maxEarlyRedeemFee = maxFeeSetup.earlyRedeemPercent;
        maxMatureRedeemFee = maxFeeSetup.matureRedeemPercent;

        uint8 backingDecimals = _backingToken != address(0) ? IERC20Metadata(_backingToken).decimals() : 18;
        backingTokenONE = 10**backingDecimals;
        principalShare = new PrincipalShare(this, principalName, principalSymbol, backingDecimals);
        yieldShare = new YieldShare(this, yieldName, yieldSymbol, backingDecimals);
    }

    modifier onlyController() {
        require(msg.sender == controller, ""Only callable by TempusController"");
        _;
    }

    function depositToUnderlying(uint256 backingAmount) internal virtual returns (uint256 mintedYieldTokenAmount);

    function withdrawFromUnderlyingProtocol(uint256 amount, address recipient)
        internal
        virtual
        returns (uint256 backingTokenAmount);

    /// Finalize the pool after maturity.
    function finalize() external override onlyController {
        if (!matured) {
            require(block.timestamp >= maturityTime, ""Maturity not been reached yet."");
            maturityInterestRate = currentInterestRate();
            matured = true;

            assert(IERC20(address(principalShare)).totalSupply() == IERC20(address(yieldShare)).totalSupply());
        }
    }

    function getFeesConfig() external view override returns (FeesConfig memory) {
        return feesConfig;
    }

    function setFeesConfig(FeesConfig calldata newFeesConfig) external override onlyOwner {
        require(newFeesConfig.depositPercent <= maxDepositFee, ""Deposit fee percent > max"");
        require(newFeesConfig.earlyRedeemPercent <= maxEarlyRedeemFee, ""Early redeem fee percent > max"");
        require(newFeesConfig.matureRedeemPercent <= maxMatureRedeemFee, ""Mature redeem fee percent > max"");
        feesConfig = newFeesConfig;
    }

    function transferFees(address authorizer, address recipient) external override onlyController {
        require(authorizer == owner(), ""Only owner can transfer fees."");
        uint256 amount = totalFees;
        totalFees = 0;

        IERC20 token = IERC20(yieldBearingToken);
        token.safeTransfer(recipient, amount);
    }

    function depositBacking(uint256 backingTokenAmount, address recipient)
        external
        payable
        override
        onlyController
        returns (
            uint256 mintedShares,
            uint256 depositedYBT,
            uint256 fee,
            uint256 rate
        )
    {
        require(backingTokenAmount > 0, ""backingTokenAmount must be greater than 0"");

        depositedYBT = depositToUnderlying(backingTokenAmount);
        assert(depositedYBT > 0);

        (mintedShares, , fee, rate) = _deposit(depositedYBT, recipient);
    }

    function deposit(uint256 yieldTokenAmount, address recipient)
        external
        override
        onlyController
        returns (
            uint256 mintedShares,
            uint256 depositedBT,
            uint256 fee,
            uint256 rate
        )
    {
        require(yieldTokenAmount > 0, ""yieldTokenAmount must be greater than 0"");
        // Collect the deposit
        yieldTokenAmount = IERC20(yieldBearingToken).untrustedTransferFrom(msg.sender, address(this), yieldTokenAmount);

        (mintedShares, depositedBT, fee, rate) = _deposit(yieldTokenAmount, recipient);
    }

    /// @param yieldTokenAmount YBT amount in YBT decimal precision
    function _deposit(uint256 yieldTokenAmount, address recipient)
        internal
        returns (
            uint256 mintedShares,
            uint256 depositedBT,
            uint256 fee,
            uint256 rate
        )
    {
        require(!matured, ""Maturity reached."");
        rate = updateInterestRate();
        require(rate >= initialInterestRate, ""Negative yield!"");

        // Collect fees if they are set, reducing the number of tokens for the sender
        // thus leaving more YBT in the TempusPool than there are minted TPS/TYS
        uint256 tokenAmount = yieldTokenAmount;
        uint256 depositFees = feesConfig.depositPercent;
        if (depositFees != 0) {
            fee = tokenAmount.mulfV(depositFees, yieldBearingONE);
            tokenAmount -= fee;
            totalFees += fee;
        }

        // Issue appropriate shares
        depositedBT = numAssetsPerYieldToken(tokenAmount, rate);
        mintedShares = numSharesToMint(depositedBT, rate);

        PrincipalShare(address(principalShare)).mint(recipient, mintedShares);
        YieldShare(address(yieldShare)).mint(recipient, mintedShares);
    }

    function redeemToBacking(
        address from,
        uint256 principalAmount,
        uint256 yieldAmount,
        address recipient
    )
        external
        payable
        override
        onlyController
        returns (
            uint256 redeemedYieldTokens,
            uint256 redeemedBackingTokens,
            uint256 fee,
            uint256 rate
        )
    {
        (redeemedYieldTokens, fee, rate) = burnShares(from, principalAmount, yieldAmount);

        redeemedBackingTokens = withdrawFromUnderlyingProtocol(redeemedYieldTokens, recipient);
    }

    function redeem(
        address from,
        uint256 principalAmount,
        uint256 yieldAmount,
        address recipient
    )
        external
        override
        onlyController
        returns (
            uint256 redeemedYieldTokens,
            uint256 fee,
            uint256 rate
        )
    {
        (redeemedYieldTokens, fee, rate) = burnShares(from, principalAmount, yieldAmount);

        redeemedYieldTokens = IERC20(yieldBearingToken).untrustedTransfer(recipient, redeemedYieldTokens);
    }

    function burnShares(
        address from,
        uint256 principalAmount,
        uint256 yieldAmount
    )
        internal
        returns (
            uint256 redeemedYieldTokens,
            uint256 fee,
            uint256 interestRate
        )
    {
        require(IERC20(address(principalShare)).balanceOf(from) >= principalAmount, ""Insufficient principals."");
        require(IERC20(address(yieldShare)).balanceOf(from) >= yieldAmount, ""Insufficient yields."");

        // Redeeming prior to maturity is only allowed in equal amounts.
        require(matured || (principalAmount == yieldAmount), ""Inequal redemption not allowed before maturity."");

        // Burn the appropriate shares
        PrincipalShare(address(principalShare)).burnFrom(from, principalAmount);
        YieldShare(address(yieldShare)).burnFrom(from, yieldAmount);

        uint256 currentRate = updateInterestRate();
        (redeemedYieldTokens, , fee, interestRate) = getRedemptionAmounts(principalAmount, yieldAmount, currentRate);
        totalFees += fee;
    }

    function getRedemptionAmounts(
        uint256 principalAmount,
        uint256 yieldAmount,
        uint256 currentRate
    )
        private
        view
        returns (
            uint256 redeemableYieldTokens,
            uint256 redeemableBackingTokens,
            uint256 redeemFeeAmount,
            uint256 interestRate
        )
    {
        interestRate = effectiveRate(currentRate);

        if (interestRate < initialInterestRate) {
            redeemableBackingTokens = (principalAmount * interestRate) / initialInterestRate;
        } else {
            uint256 rateDiff = interestRate - initialInterestRate;
            // this is expressed in percent with exchangeRate precision
            uint256 yieldPercent = rateDiff.divfV(initialInterestRate, exchangeRateONE);
            uint256 redeemAmountFromYieldShares = yieldAmount.mulfV(yieldPercent, exchangeRateONE);

            // TODO: Scale based on number of decimals for tokens
            redeemableBackingTokens = principalAmount + redeemAmountFromYieldShares;

            // after maturity, all additional yield is being collected as fee
            if (matured && currentRate > interestRate) {
                uint256 additionalYieldRate = currentRate - interestRate;
                uint256 feeBackingAmount = yieldAmount.mulfV(
                    additionalYieldRate.mulfV(initialInterestRate, exchangeRateONE),
                    exchangeRateONE
                );
                redeemFeeAmount = numYieldTokensPerAsset(feeBackingAmount, currentRate);
            }
        }

        redeemableYieldTokens = numYieldTokensPerAsset(redeemableBackingTokens, currentRate);

        uint256 redeemFeePercent = matured ? feesConfig.matureRedeemPercent : feesConfig.earlyRedeemPercent;
        if (redeemFeePercent != 0) {
            uint256 regularRedeemFee = redeemableYieldTokens.mulfV(redeemFeePercent, yieldBearingONE);
            redeemableYieldTokens -= regularRedeemFee;
            redeemFeeAmount += regularRedeemFee;

            redeemableBackingTokens = numAssetsPerYieldToken(redeemableYieldTokens, currentRate);
        }
    }

    function effectiveRate(uint256 currentRate) private view returns (uint256) {
        if (matured) {
            return (currentRate < maturityInterestRate) ? currentRate : maturityInterestRate;
        } else {
            return currentRate;
        }
    }

    /// @dev Calculates current yield - since beginning of the pool
    /// @notice Includes principal, so in case of 5% yield it returns 1.05
    /// @param interestRate Current interest rate of the underlying protocol
    /// @return Current yield relative to 1, such as 1.05 (+5%) or 0.97 (-3%)
    function currentYield(uint256 interestRate) private view returns (uint256) {
        return effectiveRate(interestRate).divfV(initialInterestRate, exchangeRateONE);
    }

    function currentYield() private returns (uint256) {
        return currentYield(updateInterestRate());
    }

    function currentYieldStored() private view returns (uint256) {
        return currentYield(currentInterestRate());
    }

    function estimatedYield() private returns (uint256) {
        return estimatedYield(currentYield());
    }

    function estimatedYieldStored() private view returns (uint256) {
        return estimatedYield(currentYieldStored());
    }

    /// @dev Calculates estimated yield at maturity
    /// @notice Includes principal, so in case of 5% yield it returns 1.05
    /// @param yieldCurrent Current yield - since beginning of the pool
    /// @return Estimated yield at maturity relative to 1, such as 1.05 (+5%) or 0.97 (-3%)
    function estimatedYield(uint256 yieldCurrent) private view returns (uint256) {
        if (matured) {
            return yieldCurrent;
        }
        uint256 currentTime = block.timestamp;
        uint256 timeToMaturity = (maturityTime > currentTime) ? (maturityTime - currentTime) : 0;
        uint256 poolDuration = maturityTime - startTime;
        uint256 timeLeft = timeToMaturity.divfV(poolDuration, exchangeRateONE);

        return yieldCurrent + timeLeft.mulfV(initialEstimatedYield, exchangeRateONE);
    }

    /// pricePerYield = currentYield * (estimatedYield - 1) / (estimatedYield)
    /// Return value decimal precision in backing token precision
    function pricePerYieldShare(uint256 currYield, uint256 estYield) private view returns (uint256) {
        uint one = exchangeRateONE;
        // in case we have estimate for negative yield
        if (estYield < one) {
            return uint256(0);
        }
        uint256 yieldPrice = (estYield - one).mulfV(currYield, one).divfV(estYield, one);
        return interestRateToSharePrice(yieldPrice);
    }

    /// pricePerPrincipal = currentYield / estimatedYield
    /// Return value decimal precision in backing token precision
    function pricePerPrincipalShare(uint256 currYield, uint256 estYield) private view returns (uint256) {
        // in case we have estimate for negative yield
        if (estYield < exchangeRateONE) {
            return interestRateToSharePrice(currYield);
        }
        uint256 principalPrice = currYield.divfV(estYield, exchangeRateONE);
        return interestRateToSharePrice(principalPrice);
    }

    function pricePerYieldShare() external override returns (uint256) {
        return pricePerYieldShare(currentYield(), estimatedYield());
    }

    function pricePerYieldShareStored() external view override returns (uint256) {
        return pricePerYieldShare(currentYieldStored(), estimatedYieldStored());
    }

    function pricePerPrincipalShare() external override returns (uint256) {
        return pricePerPrincipalShare(currentYield(), estimatedYield());
    }

    function pricePerPrincipalShareStored() external view override returns (uint256) {
        return pricePerPrincipalShare(currentYieldStored(), estimatedYieldStored());
    }

    function numSharesToMint(uint256 depositedBT, uint256 currentRate) private view returns (uint256) {
        return (depositedBT * initialInterestRate) / currentRate;
    }

    function estimatedMintedShares(uint256 amount, bool isBackingToken) public view override returns (uint256) {
        uint256 currentRate = currentInterestRate();
        uint256 depositedBT = isBackingToken ? amount : numAssetsPerYieldToken(amount, currentRate);
        return numSharesToMint(depositedBT, currentRate);
    }

    function estimatedRedeem(
        uint256 principals,
        uint256 yields,
        bool toBackingToken
    ) public view override returns (uint256) {
        uint256 currentRate = currentInterestRate();
        (uint256 yieldTokens, uint256 backingTokens, , ) = getRedemptionAmounts(principals, yields, currentRate);
        return toBackingToken ? backingTokens : yieldTokens;
    }

    /// @dev This updates the underlying pool's interest rate
    ///      It should be done first thing before deposit/redeem to avoid arbitrage
    /// @return Updated current Interest Rate, decimal precision depends on specific TempusPool implementation
    function updateInterestRate() internal virtual returns (uint256);

    /// @dev This returns the stored Interest Rate of the YBT (Yield Bearing Token) pool
    ///      it is safe to call this after updateInterestRate() was called
    /// @return Stored Interest Rate, decimal precision depends on specific TempusPool implementation
    function currentInterestRate() public view virtual override returns (uint256);

    function numYieldTokensPerAsset(uint backingTokens, uint interestRate) public pure virtual override returns (uint);

    function numAssetsPerYieldToken(uint yieldTokens, uint interestRate) public pure virtual override returns (uint);

    /// @return Converts an interest rate decimal into a Principal/Yield Share decimal
    function interestRateToSharePrice(uint interestRate) internal view virtual returns (uint);
}",4028
RealWorld_BA_37_ERC20OwnerMintableToken_RealWord_20240820111715.log,37,ERC20OwnerMintableToken,8460,5423,13883,92.0,0.15076,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

/// This is a simplified implementation, but compatible with
/// OpenZeppelin's ERC20Mintable and ERC20Burnable extensions.
contract ERC20OwnerMintableToken is ERC20 {
    /// The manager who is allowed to mint and burn.
    address public immutable manager;

    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        manager = msg.sender;
    }

    /// Creates `amount` new tokens for `to`.
    /// @param account Recipient address to mint tokens to
    /// @param amount Number of tokens to mint
    function mint(address account, uint256 amount) external {
        require(msg.sender == manager, ""mint: only manager can mint"");
        _mint(account, amount);
    }

    /// Destroys `amount` tokens from the caller.
    /// @param amount Number of tokens to burn.
    function burn(uint256 amount) public {
        require(msg.sender == manager, ""burn: only manager can burn"");
        _burn(manager, amount);
    }

    /// Destroys `amount` tokens from `account`.
    /// @param account Source address to burn tokens from
    /// @param amount Number of tokens to burn
    function burnFrom(address account, uint256 amount) public {
        require(msg.sender == manager, ""burn: only manager can burn"");
        _burn(account, amount);
    }
}",318
RealWorld_BA_37_ICToken_RealWord_20240820114810.log,37,ICToken,7343,4638,11981,85.0,0.129475,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";

import ""./IComptroller.sol"";

// Based on https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CToken.sol
// and https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CTokenInterfaces.sol
interface ICToken is IERC20, IERC20Metadata {
    /// Indicator that this is a CToken contract (for inspection)
    function isCToken() external view returns (bool);

    /// Contract which oversees inter-cToken operations
    function comptroller() external view returns (IComptroller);

    /// Calculates and returns the current exchange rate.
    /// The decimal precision depends on the formula: 18 - 8 + Underlying Token Decimals
    function exchangeRateCurrent() external returns (uint);

    /// Calculates and returns the last stored rate.
    /// The decimal precision depends on the formula: 18 - 8 + Underlying Token Decimals
    function exchangeRateStored() external view returns (uint);
}",271
RealWorld_BA_37_VecMath_RealWord_20240820113234.log,37,VecMath,12885,4920,17805,75.0,0.162825,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

import ""@balancer-labs/v2-solidity-utils/contracts/math/FixedPoint.sol"";

/// @dev helper library that does vector math
library VecMath {
    using FixedPoint for uint256;

    /// @dev Substracting two vectors
    /// @notice Vectors must be of same length
    /// @param vec1 First vector, also result will be stored here
    /// @param vec2 Second vector
    function sub(uint256[] memory vec1, uint256[] memory vec2) internal pure {
        assert(vec1.length == vec2.length);
        for (uint256 i = 0; i < vec1.length; ++i) {
            vec1[i] = vec1[i].sub(vec2[i]);
        }
    }

    /// @dev Adding two vectors
    /// @notice Vectors must be of same length
    /// @param vec1 First vector, also result will be stored here
    /// @param vec2 Second vector
    function add(uint256[] memory vec1, uint256[] memory vec2) internal pure {
        assert(vec1.length == vec2.length);
        for (uint256 i = 0; i < vec1.length; ++i) {
            vec1[i] = vec1[i].add(vec2[i]);
        }
    }

    /// @dev Dot product of two vectors which is resulting in components, not final value
    /// @notice vec1[i] = vec1[i] * vec2[i]
    /// @notice Vectors must be of same length
    /// @param vec1 First vector, also result will be stored here
    /// @param vec2 Second vector
    function mul(
        uint256[] memory vec1,
        uint256[] memory vec2,
        uint256 one
    ) internal pure {
        assert(vec1.length == vec2.length);
        for (uint256 i = 0; i < vec1.length; ++i) {
            vec1[i] = (vec1[i] * vec2[i]) / one;
        }
    }

    /// @dev Dividing components of vec1 by components of vec2
    /// @notice vec1[i] = vec1[i] / vec2[i]
    /// @notice Vectors must be of same length
    /// @param vec1 First vector, also result will be stored here
    /// @param vec2 Second vector
    function div(
        uint256[] memory vec1,
        uint256[] memory vec2,
        uint256 one
    ) internal pure {
        assert(vec1.length == vec2.length);
        for (uint256 i = 0; i < vec1.length; ++i) {
            vec1[i] = (vec1[i] * one) / vec2[i];
        }
    }
}",601
RealWorld_BA_37_ATokenMock_RealWord_20240820105915.log,37,ATokenMock,12840,5806,18646,105.0,0.18032,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""./../../token/ERC20OwnerMintableToken.sol"";
import ""../../protocols/aave/ILendingPool.sol"";
import ""../../protocols/aave/IAToken.sol"";
import ""./WadRayMath.sol"";

/// Yield Bearing Token for AAVE - AToken
contract ATokenMock is ERC20, IAToken {
    using WadRayMath for uint;
    using SafeERC20 for IERC20;

    address public immutable override UNDERLYING_ASSET_ADDRESS;
    ILendingPool public override POOL;
    uint8 private immutable contractDecimals;

    constructor(
        ILendingPool pool,
        address underlyingAssetAddress,
        uint8 _decimals,
        string memory name,
        string memory symbol
    ) ERC20(name, symbol) {
        POOL = pool;
        UNDERLYING_ASSET_ADDRESS = underlyingAssetAddress;
        contractDecimals = _decimals;
    }

    function decimals() public view override returns (uint8) {
        return contractDecimals;
    }

    function balanceOf(address account) public view override(ERC20, IERC20) returns (uint256) {
        return ERC20.balanceOf(account).rayMul(POOL.getReserveNormalizedIncome(address(UNDERLYING_ASSET_ADDRESS)));
    }

    /// @param account Recipient address to mint tokens to
    /// @param amount Number of tokens to mint
    function mint(address account, uint256 amount) public {
        require(msg.sender == address(POOL), ""mint: only manager can mint"");
        _mint(account, amount);
    }

    /// @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`
    /// @param user The owner of the aTokens, getting them burned
    /// @param receiverOfUnderlying The address that will receive the underlying
    /// @param amount The amount being burned
    /// @param index The new liquidity index of the reserve
    function burn(
        address user,
        address receiverOfUnderlying,
        uint256 amount,
        uint256 index
    ) public {
        require(msg.sender == address(POOL), ""caller must be lending pool"");

        uint256 amountScaled = amount.rayDiv(index);
        require(amountScaled != 0, ""invalid burn amount"");
        _burn(user, amountScaled);

        IERC20(UNDERLYING_ASSET_ADDRESS).safeTransfer(receiverOfUnderlying, amount);
    }

    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        ERC20._transfer(from, to, amount.rayDiv(POOL.getReserveNormalizedIncome(UNDERLYING_ASSET_ADDRESS)));
    }
}",593
RealWorld_BA_37_IVault_RealWord_20240820113745.log,37,IVault,8185,5537,13722,89.0,0.151665,"// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.7.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IVault {
    enum SwapKind {
        GIVEN_IN,
        GIVEN_OUT
    }

    struct SingleSwap {
        bytes32 poolId;
        SwapKind kind;
        IERC20 assetIn;
        IERC20 assetOut;
        uint256 amount;
        bytes userData;
    }
    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address payable recipient;
        bool toInternalBalance;
    }

    struct JoinPoolRequest {
        IERC20[] assets;
        uint256[] maxAmountsIn;
        bytes userData;
        bool fromInternalBalance;
    }

    struct ExitPoolRequest {
        IERC20[] assets;
        uint256[] minAmountsOut;
        bytes userData;
        bool toInternalBalance;
    }

    function swap(
        SingleSwap memory singleSwap,
        FundManagement memory funds,
        uint256 limit,
        uint256 deadline
    ) external payable returns (uint256);

    function joinPool(
        bytes32 poolId,
        address sender,
        address recipient,
        JoinPoolRequest memory request
    ) external payable;

    function exitPool(
        bytes32 poolId,
        address sender,
        address payable recipient,
        ExitPoolRequest memory request
    ) external;

    function getPoolTokens(bytes32 poolId)
        external
        view
        returns (
            IERC20[] memory tokens,
            uint256[] memory balances,
            uint256 lastChangeBlock
        );
}",333
RealWorld_BA_37_PrincipalShare_RealWord_20240820111548.log,37,PrincipalShare,5520,4468,9988,85.0,0.11696,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.6;

import ""./PoolShare.sol"";

/// @dev Token representing the principal shares of a pool.
contract PrincipalShare is PoolShare {
    constructor(
        ITempusPool _pool,
        string memory name,
        string memory symbol,
        uint8 decimals
    ) PoolShare(ShareKind.Principal, _pool, name, symbol, decimals) {}

    // solhint-disable-previous-line no-empty-blocks

    function getPricePerFullShare() external override returns (uint256) {
        return pool.pricePerPrincipalShare();
    }

    function getPricePerFullShareStored() external view override returns (uint256) {
        return pool.pricePerPrincipalShareStored();
    }
}",156
RealWorld_BA_37_ICErc20_RealWord_20240820114639.log,37,ICErc20,9003,5373,14376,89.0,0.152475,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.6;

import ""./ICToken.sol"";

// Based on CErc20Interface in https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CTokenInterfaces.sol
// and documentation at https://compound.finance/docs/ctokens
interface ICErc20 is ICToken {
    /// Underlying asset for this CToken
    function underlying() external view returns (address);

    /// The mint function transfers an asset into the protocol, which begins accumulating interest based
    /// on the current Supply Rate for the asset. The user receives a quantity of cTokens equal to the
    /// underlying tokens supplied, divided by the current Exchange Rate.
    /// @param mintAmount The amount of the asset to be supplied, in units of the underlying asset.
    /// @return 0 on success, otherwise an Error code
    function mint(uint mintAmount) external returns (uint);

    /// The redeem function converts a specified quantity of cTokens into the underlying asset, and returns
    /// them to the user. The amount of underlying tokens received is equal to the quantity of cTokens redeemed,
    /// multiplied by the current Exchange Rate. The amount redeemed must be less than the user's Account Liquidity
    /// and the market's available liquidity.
    /// @param redeemTokens The number of cTokens to be redeemed.
    /// @return 0 on success, otherwise an Error code
    function redeem(uint redeemTokens) external returns (uint);
}",320
RealWorld_BA_37_AavePoolMock_RealWord_20240820110102.log,37,AavePoolMock,20961,5869,26830,93.0,0.222185,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./ATokenMock.sol"";
import ""./WadRayMath.sol"";
import ""../../protocols/aave/ILendingPool.sol"";

contract AavePoolMock is ILendingPool {
    using WadRayMath for uint;

    // AAVE supports multi-reserve lending, but in this Mock we only support 1 reserve
    IERC20 private assetToken; // DAI
    ATokenMock public yieldToken; // aDAI
    uint128 private liquidityIndex; // the liquidity index in Ray (init:1ray=1e27)

    // used for mocks, it will force-fail the next deposit or redeem
    bool public mockFailNextDepositOrRedeem;

    /// @dev Initialize AAVE Mock with a single supported reserve.
    /// We only support 1 reserve right now.
    /// @param asset The single ERC20 reserve token, such as DAI
    constructor(
        IERC20 asset,
        uint128 index,
        uint8 decimals,
        string memory aTokenName,
        string memory aTokenSymbol
    ) {
        assetToken = asset;
        yieldToken = new ATokenMock(ILendingPool(address(this)), address(asset), decimals, aTokenName, aTokenSymbol);
        liquidityIndex = index; // default should be 1ray
    }

    /// @notice MOCK ONLY
    /// @dev Sets the current liquidity index for deposit() and getReserveNormalizedIncome()
    /// @param index Asset liquidity index. Expressed in ray (1e27)
    function setLiquidityIndex(uint128 index) public {
        liquidityIndex = index;
    }

    /// @notice MOCK ONLY
    function setFailNextDepositOrRedeem(bool fail) public {
        mockFailNextDepositOrRedeem = fail;
    }

    /// @dev Returns the normalized income per unit of asset
    /// @param asset The address of the underlying asset of the reserve
    /// @return The reserve's normalized income
    function getReserveNormalizedIncome(address asset) public view override returns (uint) {
        require(address(assetToken) == asset, ""invalid reserve asset"");
        return liquidityIndex;
    }

    /// @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.
    /// - E.g. User deposits 100 USDC and gets in return 100 aUSDC
    /// @param asset The address of the underlying asset to deposit
    /// @param amount The amount to be deposited
    /// @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user
    ///   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens
    ///   is a different wallet
    function deposit(
        address asset,
        uint amount,
        address onBehalfOf,
        uint16 /*referralCode*/
    ) public override {
        require(address(assetToken) == asset, ""invalid reserve asset"");

        if (mockFailNextDepositOrRedeem) {
            setFailNextDepositOrRedeem(false);
            revert(""random mock failure from aave"");
        }

        // The AToken holds the asset
        address assetOwner = address(yieldToken);
        require(assetToken.transferFrom(msg.sender, assetOwner, amount), ""transfer failed"");

        // liquidity index controls how many additional tokens are minted
        uint amountScaled = (amount).rayDiv(liquidityIndex);
        yieldToken.mint(onBehalfOf, amountScaled);
    }

    /// @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned
    /// E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC
    /// @param asset The address of the underlying asset to withdraw
    /// @param amount The underlying amount to be withdrawn
    ///   - Send the value type(uint256).max in order to withdraw the whole aToken balance
    /// @param to Address that will receive the underlying, same as msg.sender if the user
    ///   wants to receive it on his own wallet, or a different address if the beneficiary is a
    ///   different wallet
    /// @return The final amount withdrawn
    function withdraw(
        address asset,
        uint256 amount,
        address to
    ) external override returns (uint256) {
        require(address(assetToken) == asset, ""invalid reserve asset"");

        if (mockFailNextDepositOrRedeem) {
            setFailNextDepositOrRedeem(false);
            revert(""random failure from aave"");
        }

        yieldToken.burn(msg.sender, to, amount, uint256(liquidityIndex));
        return amount;
    }

    /// @notice MOCK ONLY
    /// @return Total deposited underlying assets of an user
    function getDeposit(address user) public view returns (uint) {
        return yieldToken.balanceOf(user);
    }
}",1080
RealWorld_BA_37_LidoMock_RealWord_20240820105736.log,37,LidoMock,29017,5526,34543,97.0,0.255605,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;

import ""./StETH.sol"";

// This is a simplified version of Lido, which maintains API compatibility on:
// - the token interface
// - entering the pool
// - having a buffer for ether to be validated
// - having a reward scheme
// - implements withdrawal (to simulate future conditions)
contract LidoMock is StETH {
    // The current balance on the beacon chain.
    uint256 internal beaconBalance = 0;
    // Pending ether for submissions to the deposit contract
    uint256 internal bufferedEther = 0;
    // Fee in basis points (0 <= fee <= 1000)
    uint256 internal feeBasis = 100;

    uint256 internal constant DEPOSIT_SIZE = 32 ether;
    uint256 internal constant DEFAULT_MAX_DEPOSITS_PER_CALL = 16;

    // used for mocks, it will force-fail the next deposit or redeem
    bool public mockFailNextDepositOrRedeem;

    constructor(
        uint8 decimals,
        string memory name,
        string memory symbol
    ) StETH(decimals, name, symbol) {
        // solhint-disable-previous-line no-empty-blocks
    }

    /// @notice MOCK ONLY
    function setFailNextDepositOrRedeem(bool fail) public {
        mockFailNextDepositOrRedeem = fail;
    }

    /// @notice Send funds to the pool
    /// @dev Users are able to submit their funds by transacting to the fallback function.
    /// Unlike vanilla Eth2.0 Deposit contract, accepting only 32-Ether transactions, Lido
    /// accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls
    /// depositBufferedEther() and pushes them to the ETH2 Deposit contract.
    receive() external payable {
        _submit(address(0));
    }

    /// @notice Send funds to the pool with optional _referral parameter
    /// @dev This function is alternative way to submit funds. Supports optional referral address.
    /// @return Amount of StETH shares generated
    function submit(address _referral) external payable override returns (uint256) {
        return _submit(_referral);
    }

    // Submit pending ether to the deposit contract.
    function depositBufferedEther() external {
        return _depositBufferedEther(DEFAULT_MAX_DEPOSITS_PER_CALL);
    }

    // Submit pending ether to the deposit contract.
    function depositBufferedEther(uint256 _maxDeposits) external {
        return _depositBufferedEther(_maxDeposits);
    }

    // Update balance based on beacon chain.
    // This can be only called by LidoOracle.
    function pushBeacon(uint256 _beaconValidators, uint256 _beaconBalance) external {
        // Update holdings.
        beaconBalance = _beaconBalance;

        // Simplified.
        distributeRewards(_beaconBalance - (_beaconValidators * DEPOSIT_SIZE));
    }

    /// Withdraw holdings.
    ///
    /// @param _amount Amount of StETH to withdraw.
    ///
    /// @dev This is currently unimplemented in upstream, as it is not possible to withdraw
    ///      before The Merge. However we anticipate that to be turned on before EOY 2022.
    function withdraw(
        uint256 _amount,
        bytes32 /*_pubkeyHash*/
    ) external {
        if (mockFailNextDepositOrRedeem) {
            setFailNextDepositOrRedeem(false);
            revert(""random mock failure from lido"");
        }

        uint256 redeemable = StETH.getPooledEthByShares(_amount);

        // Simplification: only allow withdrawing buffered ether.
        require(redeemable <= bufferedEther, ""Can only withdraw up to the buffered ether."");

        // This validates that enough shares are owned by the account.
        _burnShares(msg.sender, _amount);

        payable(msg.sender).transfer(redeemable);
    }

    // Distribute actual rewards in ether.
    function distributeRewards(uint256 _totalRewards) internal {
        uint256 fees = _totalRewards * feeBasis;
        uint256 sharesToMint = (fees * _getTotalShares()) / ((_getTotalPooledEther() * 1000) - fees);
        _mintShares(address(this), sharesToMint);

        // Transfer to insurance fund
        // Transfer to treasury
    }

    // Adds submitted ether to the buffer.
    function _submit(
        address /*_referral*/
    ) internal returns (uint256) {
        if (mockFailNextDepositOrRedeem) {
            setFailNextDepositOrRedeem(false);
            revert(""random mock failure from lido"");
        }

        address sender = msg.sender;
        uint256 deposit = msg.value;
        require(deposit != 0, ""ZERO_DEPOSIT"");

        uint256 sharesAmount = StETH.getSharesByPooledEth(deposit);
        if (sharesAmount == 0) {
            // totalControlledEther is 0: either the first-ever deposit or complete slashing
            // assume that shares correspond to Ether 1-to-1
            sharesAmount = deposit;
        }

        _mintShares(sender, sharesAmount);

        // Store for submission
        bufferedEther += deposit;

        return sharesAmount;
    }

    // Deposit buffered ether.
    function _depositBufferedEther(
        uint256 /*_maxDeposits*/
    ) internal {
        // Enough to submit
        if (bufferedEther >= DEPOSIT_SIZE) {
            uint256 numDeposits = bufferedEther / DEPOSIT_SIZE;
            _ETH2Deposit(numDeposits);
            bufferedEther -= numDeposits * DEPOSIT_SIZE;
        }
    }

    // This would call the deposit contract, we just mimic it by burning the values.
    // solhint-disable-next-line func-name-mixedcase
    function _ETH2Deposit(uint256 _numDeposits) internal {
        beaconBalance += _numDeposits * DEPOSIT_SIZE;
        payable(0).transfer(_numDeposits * DEPOSIT_SIZE);
    }

    // totalSupply() of ETH
    function _getTotalPooledEther() internal view override returns (uint256) {
        return beaconBalance + bufferedEther;
    }

    // MOCK only, used for manipulating Interest Rate
    function _setSharesAndEthBalance(uint256 stEthBalance, uint256 ethBalance) public {
        totalShares = stEthBalance;
        beaconBalance = ethBalance;
        bufferedEther = 0;
    }

    /**
     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.
     */
    function getSharesByPooledEth(uint256 _ethAmount) public view override returns (uint256) {
        // no deposits yet, return 1:1 rate
        if (_getTotalPooledEther() == 0) {
            return _ethAmount;
        }
        return StETH.getSharesByPooledEth(_ethAmount);
    }

    /**
     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.
     */
    function getPooledEthByShares(uint256 _sharesAmount) public view override returns (uint256) {
        // no deposits yet, return 1:1 rate
        if (_getTotalShares() == 0) {
            return _sharesAmount;
        }
        return StETH.getPooledEthByShares(_sharesAmount);
    }

    // MOCK ONLY
    function _getInterestRate() public view returns (uint256) {
        return getPooledEthByShares(1e18);
    }
}",1604
RealWorld_BA_37_ITempusAMM_RealWord_20240820114033.log,37,ITempusAMM,14249,5326,19575,94.0,0.177765,"// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.7.0;

import ""./IVault.sol"";
import ""./../../ITempusPool.sol"";

interface ITempusAMM {
    enum JoinKind {
        INIT,
        EXACT_TOKENS_IN_FOR_BPT_OUT
    }
    enum ExitKind {
        EXACT_BPT_IN_FOR_TOKENS_OUT,
        BPT_IN_FOR_EXACT_TOKENS_OUT
    }

    function getVault() external view returns (IVault);

    function getPoolId() external view returns (bytes32);

    function tempusPool() external view returns (ITempusPool);

    function balanceOf(address) external view returns (uint256);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /// Calculates the expected returned swap amount
    /// @param amount The given input amount of tokens
    /// @param yieldShareIn Specifies whether to calculate the swap from TYS to TPS (if true) or from TPS to TYS
    /// @return The expected returned amount of outToken
    function getExpectedReturnGivenIn(uint256 amount, bool yieldShareIn) external view returns (uint256);

    /// @dev Returns amount that user needs to swap to end up with almost the same amounts of Principals and Yields
    /// @param principals User's Principals balance
    /// @param yields User's Yields balance
    /// @param threshold Maximum difference between final balances of Principals and Yields
    /// @return amountIn Amount of Principals or Yields that user needs to swap to end with almost equal amounts
    function getSwapAmountToEndWithEqualShares(
        uint256 principals,
        uint256 yields,
        uint256 threshold
    ) external view returns (uint256 amountIn);

    /// @dev queries exiting TempusAMM with exact BPT tokens in
    /// @param bptAmountIn amount of LP tokens in
    /// @return principals Amount of principals that user would recieve back
    /// @return yields Amount of yields that user would recieve back
    function getExpectedTokensOutGivenBPTIn(uint256 bptAmountIn)
        external
        view
        returns (uint256 principals, uint256 yields);

    /// @dev queries exiting TempusAMM with exact tokens out
    /// @param principalsStaked amount of Principals to withdraw
    /// @param yieldsStaked amount of Yields to withdraw
    /// @return lpTokens Amount of Lp tokens that user would redeem
    function getExpectedBPTInGivenTokensOut(uint256 principalsStaked, uint256 yieldsStaked)
        external
        view
        returns (uint256 lpTokens);

    /// @dev queries joining TempusAMM with exact tokens in
    /// @param amountsIn amount of tokens to be added to the pool
    /// @return amount of LP tokens that could be recieved
    function getExpectedLPTokensForTokensIn(uint256[] memory amountsIn) external view returns (uint256);

    /// @dev This function returns the appreciation of one BPT relative to the
    /// underlying tokens. This starts at 1 when the pool is created and grows over time
    function getRate() external view returns (uint256);
}",689
RealWorld_BA_37_AaveTempusPool_RealWord_20240820112154.log,37,AaveTempusPool,17083,5715,22798,113.0,0.199715,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""../TempusPool.sol"";
import ""../protocols/aave/IAToken.sol"";
import ""../protocols/aave/ILendingPool.sol"";
import ""../utils/UntrustedERC20.sol"";

contract AaveTempusPool is TempusPool {
    using SafeERC20 for IERC20;
    using UntrustedERC20 for IERC20;

    ILendingPool internal immutable aavePool;
    bytes32 public immutable override protocolName = ""Aave"";
    uint16 private immutable referrer;
    uint private immutable exchangeRateToBackingPrecision;

    constructor(
        IAToken token,
        address controller,
        uint256 maturity,
        uint256 estYield,
        string memory principalName,
        string memory principalSymbol,
        string memory yieldName,
        string memory yieldSymbol,
        FeesConfig memory maxFeeSetup,
        uint16 referrerCode
    )
        TempusPool(
            address(token),
            token.UNDERLYING_ASSET_ADDRESS(),
            controller,
            maturity,
            getInitialInterestRate(token),
            1e18,
            estYield,
            principalName,
            principalSymbol,
            yieldName,
            yieldSymbol,
            maxFeeSetup
        )
    {
        aavePool = token.POOL();
        referrer = referrerCode;

        uint8 underlyingDecimals = IERC20Metadata(token.UNDERLYING_ASSET_ADDRESS()).decimals();
        require(underlyingDecimals <= 18, ""underlying decimals must be <= 18"");

        exchangeRateToBackingPrecision = 10**(18 - underlyingDecimals);
    }

    function depositToUnderlying(uint256 amount) internal override returns (uint256) {
        require(msg.value == 0, ""ETH deposits not supported"");

        // Pull user's Backing Tokens
        amount = IERC20(backingToken).untrustedTransferFrom(msg.sender, address(this), amount);

        // Deposit to AAVE
        IERC20(backingToken).safeIncreaseAllowance(address(aavePool), amount);
        aavePool.deposit(address(backingToken), amount, address(this), 0);

        return amount; // With Aave, the of YBT minted equals to the amount of deposited BT
    }

    function withdrawFromUnderlyingProtocol(uint256 yieldBearingTokensAmount, address recipient)
        internal
        override
        returns (uint256 backingTokenAmount)
    {
        return aavePool.withdraw(backingToken, yieldBearingTokensAmount, recipient);
    }

    function getInitialInterestRate(IAToken token) internal view returns (uint256) {
        return token.POOL().getReserveNormalizedIncome(token.UNDERLYING_ASSET_ADDRESS()) / 1e9;
    }

    /// @return Updated current Interest Rate as an 1e18 decimal
    function updateInterestRate() internal view override returns (uint256) {
        // convert from RAY 1e27 to WAD 1e18 decimal
        return aavePool.getReserveNormalizedIncome(backingToken) / 1e9;
    }

    /// @return Stored Interest Rate as an 1e18 decimal
    function currentInterestRate() public view override returns (uint256) {
        return aavePool.getReserveNormalizedIncome(backingToken) / 1e9;
    }

    /// NOTE: Aave AToken is pegged 1:1 with backing token
    function numAssetsPerYieldToken(uint yieldTokens, uint) public pure override returns (uint) {
        return yieldTokens;
    }

    /// NOTE: Aave AToken is pegged 1:1 with backing token
    function numYieldTokensPerAsset(uint backingTokens, uint) public pure override returns (uint) {
        return backingTokens;
    }

    function interestRateToSharePrice(uint interestRate) internal view override returns (uint) {
        return interestRate / exchangeRateToBackingPrecision;
    }
}",885
RealWorld_BA_37_TempusAMMUserDataHelpers_RealWord_20240820113608.log,37,TempusAMMUserDataHelpers,13448,4911,18359,95.0,0.16546,"// SPDX-License-Identifier: GPL-3.0-or-later
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity 0.7.6;

import ""@balancer-labs/v2-solidity-utils/contracts/openzeppelin/IERC20.sol"";

import ""./TempusAMM.sol"";

library TempusAMMUserDataHelpers {
    function joinKind(bytes memory self) internal pure returns (TempusAMM.JoinKind) {
        return abi.decode(self, (TempusAMM.JoinKind));
    }

    function exitKind(bytes memory self) internal pure returns (TempusAMM.ExitKind) {
        return abi.decode(self, (TempusAMM.ExitKind));
    }

    // Joins

    function initialAmountsIn(bytes memory self) internal pure returns (uint256[] memory amountsIn) {
        (, amountsIn) = abi.decode(self, (TempusAMM.JoinKind, uint256[]));
    }

    function exactTokensInForBptOut(bytes memory self)
        internal
        pure
        returns (uint256[] memory amountsIn, uint256 minBPTAmountOut)
    {
        (, amountsIn, minBPTAmountOut) = abi.decode(self, (TempusAMM.JoinKind, uint256[], uint256));
    }

    function tokenInForExactBptOut(bytes memory self) internal pure returns (uint256 bptAmountOut, uint256 tokenIndex) {
        (, bptAmountOut, tokenIndex) = abi.decode(self, (TempusAMM.JoinKind, uint256, uint256));
    }

    // Exits

    function exactBptInForTokenOut(bytes memory self) internal pure returns (uint256 bptAmountIn, uint256 tokenIndex) {
        (, bptAmountIn, tokenIndex) = abi.decode(self, (TempusAMM.ExitKind, uint256, uint256));
    }

    function exactBptInForTokensOut(bytes memory self) internal pure returns (uint256 bptAmountIn) {
        (, bptAmountIn) = abi.decode(self, (TempusAMM.ExitKind, uint256));
    }

    function bptInForExactTokensOut(bytes memory self)
        internal
        pure
        returns (uint256[] memory amountsOut, uint256 maxBPTAmountIn)
    {
        (, amountsOut, maxBPTAmountIn) = abi.decode(self, (TempusAMM.ExitKind, uint256[], uint256));
    }
}",648
RealWorld_BA_37_IComptroller_RealWord_20240820114937.log,37,IComptroller,5928,4499,10427,78.0,0.11962,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.6;

// Based on https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/ComptrollerInterface.sol
// and documentation at https://compound.finance/docs/comptroller
interface IComptroller {
    /// Enter into a list of markets - it is not an error to enter the same market more than once.
    /// In order to supply collateral or borrow in a market, it must be entered first.
    /// @param cTokens The list of addresses of the cToken markets to be enabled
    /// @return For each market, returns an error code indicating whether or not it was entered.
    ///         Each is 0 on success, otherwise an Error code.
    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);
}",185
RealWorld_BA_37_IAToken_RealWord_20240820114515.log,37,IAToken,4701,4576,9277,82.0,0.115025,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./ILendingPool.sol"";

// NOTE: Based on the actual AToken implementation
interface IAToken is IERC20 {
    /// @return The underlying backing token.
    function UNDERLYING_ASSET_ADDRESS() external view returns (address);

    /// @return The underlying ILendingPool associated with this token.
    function POOL() external view returns (ILendingPool);
}",116
RealWorld_BA_37_ILido_RealWord_20240820114209.log,37,ILido,6732,5900,12632,95.0,0.15166,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";

interface ILido is IERC20, IERC20Metadata {
    /**
     * @notice Send funds to the pool with optional _referral parameter
     * @dev This function is alternative way to submit funds. Supports optional referral address.
     * @return Amount of StETH shares generated
     */
    function submit(address _referral) external payable returns (uint256);

    /**
     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.
     */
    function getSharesByPooledEth(uint256 _ethAmount) external view returns (uint256);

    /**
     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.
     */
    function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);
}",220
RealWorld_BA_37_ComptrollerMock_RealWord_20240820110709.log,37,ComptrollerMock,18127,5335,23462,91.0,0.197335,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./CTokenMock.sol"";
import ""./CErc20.sol"";
import ""./ComptrollerInterface.sol"";
import ""./ComptrollerStorage.sol"";

contract ComptrollerMock is ComptrollerStorage, ComptrollerInterface {
    uint public exchangeRate; // current exchange rate as 1**(18 - 8 + Underlying Token Decimals)

    // used for mocks, it will force-fail the next deposit or redeem
    bool public mockFailNextDepositOrRedeem;

    /// @param initialExchangeRate Initial mocked exchange rate, the official default is 0.02
    ///                            with decimal precision calculated as 18 - 8 + Underlying Token Decimals
    constructor(uint initialExchangeRate) {
        exchangeRate = initialExchangeRate;
    }

    /// @notice MOCK ONLY
    function setExchangeRate(uint rate) public {
        exchangeRate = rate;
    }

    /// @notice MOCK ONLY
    function setFailNextDepositOrRedeem(bool fail) public {
        mockFailNextDepositOrRedeem = fail;
    }

    /// @notice Add assets to be included in account liquidity calculation
    /// @param cTokens The list of addresses of the cToken markets to be enabled
    /// @return Success indicator for whether each corresponding market was entered
    function enterMarkets(address[] calldata cTokens) external override returns (uint[] memory) {
        uint len = cTokens.length;
        uint[] memory results = new uint[](len);
        for (uint i = 0; i < len; i++) {
            results[i] = uint(addToMarketInternal(CTokenMock(cTokens[i]), msg.sender));
        }
        return results;
    }

    /// @notice Add the market to the borrower's ""assets in"" for liquidity calculations
    /// @param cToken The market to enter
    /// @param borrower The address of the account to modify
    /// @return Success indicator for whether the market was entered
    function addToMarketInternal(CTokenMock cToken, address borrower) internal returns (uint) {
        Market storage marketToJoin = markets[address(cToken)];
        if (marketToJoin.accountMembership[borrower] == false) {
            marketToJoin.accountMembership[borrower] = true;
            accountAssets[borrower].push(cToken);
        }
        return 0;
    }

    /// @notice Removes asset from sender's account liquidity calculation
    /// @dev Sender must not have an outstanding borrow balance in the asset,
    ///  or be providing necessary collateral for an outstanding borrow.
    /// @param cTokenAddress The address of the asset to be removed
    /// @return Whether or not the account successfully exited the market
    function exitMarket(address cTokenAddress) external override returns (uint) {
        CTokenMock cToken = CTokenMock(cTokenAddress);
        Market storage marketToExit = markets[address(cToken)];

        /* Set cToken account membership to false */
        delete marketToExit.accountMembership[msg.sender];

        /* Delete cToken from the accounts list of assets */
        // load into memory for faster iteration
        CTokenMock[] memory userAssetList = accountAssets[msg.sender];
        uint len = userAssetList.length;
        uint assetIndex = len;
        for (uint i = 0; i < len; i++) {
            if (userAssetList[i] == cToken) {
                assetIndex = i;
                break;
            }
        }

        // We *must* have found the asset in the list or our redundant data structure is broken
        assert(assetIndex < len);
        delete accountAssets[msg.sender][assetIndex];
        return 0;
    }

    function mintAllowed(
        address cToken,
        address minter,
        uint /*mintAmount*/
    ) external view override returns (uint) {
        if (!isParticipant(cToken, minter)) {
            return 1; // error!
        }
        return 0;
    }

    /// @dev MOCK ONLY.
    /// @return True if user is participant in cToken market
    function isParticipant(address cTokenAddress, address participant) public view returns (bool) {
        Market storage market = markets[cTokenAddress];
        return market.accountMembership[participant];
    }
}",924
RealWorld_BA_37_ERC20FixedSupply_RealWord_20240820111359.log,37,ERC20FixedSupply,6050,4887,10937,107.0,0.12799,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract ERC20FixedSupply is ERC20 {
    uint8 internal immutable contractDecimals;

    /// TEMP Token constructor, implemented as a fixed supply
    /// @param totalTokenSupply total supply of the token, initially awarded to msg.sender
    constructor(
        uint8 _decimals,
        string memory name,
        string memory symbol,
        uint256 totalTokenSupply
    ) ERC20(name, symbol) {
        contractDecimals = _decimals;
        _mint(msg.sender, totalTokenSupply);
    }

    function decimals() public view override returns (uint8) {
        return contractDecimals;
    }
}",162
RealWorld_BA_37_ILendingPool_RealWord_20240820114346.log,37,ILendingPool,10982,5256,16238,87.0,0.16003,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;

// Based on https://github.com/aave/protocol-v2/blob/ice/mainnet-deployment-03-12-2020/contracts/interfaces/ILendingPool.sol
interface ILendingPool {
    /// @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.
    /// - E.g. User deposits 100 USDC and gets in return 100 aUSDC
    /// @param asset The address of the underlying asset to deposit
    /// @param amount The amount to be deposited, expressed in Wei
    /// @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user
    ///   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens
    ///   is a different wallet
    function deposit(
        address asset,
        uint amount,
        address onBehalfOf,
        uint16 /*referralCode*/
    ) external;

    /// @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned
    /// E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC
    /// @param asset The address of the underlying asset to withdraw
    /// @param amount The underlying amount to be withdrawn, expressed in Wei
    ///   - Send the value type(uint256).max in order to withdraw the whole aToken balance
    /// @param to Address that will receive the underlying, same as msg.sender if the user
    ///   wants to receive it on his own wallet, or a different address if the beneficiary is a
    ///   different wallet
    /// @return The final amount withdrawn
    function withdraw(
        address asset,
        uint256 amount,
        address to
    ) external returns (uint256);

    /// @dev Returns the normalized income normalized income of the reserve
    /// @param asset The address of the underlying asset of the reserve
    /// @return The reserve's normalized income, denominated in Ray (a 27-point decimal (i.e. scaled by 1e27))
    function getReserveNormalizedIncome(address asset) external view returns (uint256);
}",491
RealWorld_BA_37_CErc20_RealWord_20240820110537.log,37,CErc20,12877,4980,17857,90.0,0.163985,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""./CTokenMock.sol"";
import ""./CTokenInterfaces.sol"";

/// Yield Bearing Token for Compound - CErc20 / CToken
contract CErc20 is CTokenMock, CErc20Interface {
    using SafeERC20 for IERC20;

    constructor(
        ComptrollerMock comptrollerInterface,
        address underlyingAsset,
        string memory name,
        string memory symbol
    ) CTokenMock(comptrollerInterface, name, symbol) {
        underlying = underlyingAsset;
    }

    /// @notice Sender supplies assets into the market and receives cTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
    function mint(uint mintAmount) external override returns (uint) {
        ComptrollerMock mock = ComptrollerMock(address(comptroller));
        if (mock.mockFailNextDepositOrRedeem()) {
            mock.setFailNextDepositOrRedeem(false);
            return 1;
        }
        (uint err, ) = mintInternal(mintAmount);
        return err;
    }

    /// @notice Sender redeems cTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of cTokens to redeem into underlying
    /// @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
    function redeem(uint redeemTokens) external override returns (uint) {
        ComptrollerMock mock = ComptrollerMock(address(comptroller));
        if (mock.mockFailNextDepositOrRedeem()) {
            mock.setFailNextDepositOrRedeem(false);
            return 1;
        }

        // Amount of underlying asset to be redeemed:
        //  redeemAmount = redeemTokens x exchangeRate
        uint256 exchangeRate = exchangeRateStored();
        uint256 redeemAmount = (redeemTokens * exchangeRate) / 1e18;

        // burn the yield tokens
        _burn(msg.sender, redeemTokens);

        // transfer backing tokens to redeemer
        IERC20(underlying).safeTransfer(msg.sender, redeemAmount);
        return 0; // success
    }

    function doTransferIn(address from, uint amount) internal override returns (uint) {
        IERC20 backingToken = IERC20(underlying);
        backingToken.safeTransferFrom(from, address(this), amount);
        return amount;
    }
}",618
RealWorld_BA_37_CTokenMock_RealWord_20240820110959.log,37,CTokenMock,15818,4684,20502,87.0,0.17277,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""./ComptrollerMock.sol"";
import ""./CTokenInterfaces.sol"";

/// Yield Bearing Token for Compound - CToken
abstract contract CTokenMock is ERC20, CTokenInterface {
    constructor(
        ComptrollerInterface comptrollerInterface,
        string memory name,
        string memory symbol
    ) ERC20(name, symbol) {
        comptroller = comptrollerInterface;
    }

    // For cDAI and friends, the precision must always be 8
    // and some of the internal math here also relies on 8 decimals
    function decimals() public pure override returns (uint8) {
        return 8;
    }

    /// Calculates and returns the current exchange rate.
    /// The decimal precision depends on the formula: 18 - 8 + Underlying Token Decimals
    function exchangeRateCurrent() public view override returns (uint) {
        return ComptrollerMock(address(comptroller)).exchangeRate();
    }

    /// Calculates and returns the last stored rate.
    /// The decimal precision depends on the formula: 18 - 8 + Underlying Token Decimals
    function exchangeRateStored() public view override returns (uint) {
        return ComptrollerMock(address(comptroller)).exchangeRate();
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply in BackingToken decimals
     * @return (uint, uint) An error code (0=success, otherwise a failure,
               see ErrorReporter.sol), and the actual mint amount in BackingToken decimals
     */
    function mintInternal(uint mintAmount) internal returns (uint, uint) {
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    function mintFresh(address minter, uint mintAmount) internal returns (uint errorCode, uint actualMintAmount) {
        uint err = comptroller.mintAllowed(address(this), minter, mintAmount);
        require(err == 0, ""mint is not allowed"");

        uint exchangeRate = exchangeRateStored(); // exchangeRate has variable decimal precision

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        actualMintAmount = doTransferIn(minter, mintAmount); // 18 decimal precision

        // exchange rate precision: 18 - 8 + Underlying Token Decimals
        uint mintTokens = (actualMintAmount * 1e18) / exchangeRate; // (18 + 18) - 28 = 8 decimal precision
        _mint(minter, mintTokens);
        errorCode = 0;
    }

    /**
     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually
     *      transferred to the protocol, in case of a fee.
     *  This may revert due to insufficient balance or insufficient allowance.
     */
    function doTransferIn(address from, uint amount) internal virtual returns (uint);
}",784
RealWorld_BA_37_WadRayMath_RealWord_20240820110238.log,37,WadRayMath,19247,4896,24143,81.0,0.194155,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.6;

/**
 * @title WadRayMath library
 * @author Aave
 * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)
 **/

library WadRayMath {
    uint256 internal constant WAD = 1e18;
    uint256 internal constant halfWAD = WAD / 2;

    uint256 internal constant RAY = 1e27;
    uint256 internal constant halfRAY = RAY / 2;

    uint256 internal constant WAD_RAY_RATIO = 1e9;

    /**
     * @return One ray, 1e27
     **/
    function ray() internal pure returns (uint256) {
        return RAY;
    }

    /**
     * @return One wad, 1e18
     **/

    function wad() internal pure returns (uint256) {
        return WAD;
    }

    /**
     * @return Half ray, 1e27/2
     **/
    function halfRay() internal pure returns (uint256) {
        return halfRAY;
    }

    /**
     * @return Half ray, 1e18/2
     **/
    function halfWad() internal pure returns (uint256) {
        return halfWAD;
    }

    /**
     * @dev Multiplies two wad, rounding half up to the nearest wad
     * @param a Wad
     * @param b Wad
     * @return The result of a*b, in wad
     **/
    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0 || b == 0) {
            return 0;
        }

        require(a <= (type(uint256).max - halfWAD) / b, ""multiplication oveflow"");

        return (a * b + halfWAD) / WAD;
    }

    /**
     * @dev Divides two wad, rounding half up to the nearest wad
     * @param a Wad
     * @param b Wad
     * @return The result of a/b, in wad
     **/
    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, ""division by zero"");
        uint256 halfB = b / 2;

        require(a <= (type(uint256).max - halfB) / WAD, ""multiplication oveflow"");

        return (a * WAD + halfB) / b;
    }

    /**
     * @dev Multiplies two ray, rounding half up to the nearest ray
     * @param a Ray
     * @param b Ray
     * @return The result of a*b, in ray
     **/
    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0 || b == 0) {
            return 0;
        }

        require(a <= (type(uint256).max - halfRAY) / b, ""multiplication oveflow"");

        return (a * b + halfRAY) / RAY;
    }

    /**
     * @dev Divides two ray, rounding half up to the nearest ray
     * @param a Ray
     * @param b Ray
     * @return The result of a/b, in ray
     **/
    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, ""division by zero"");
        uint256 halfB = b / 2;

        require(a <= (type(uint256).max - halfB) / RAY, ""multiplication oveflow"");

        return (a * RAY + halfB) / b;
    }

    /**
     * @dev Casts ray down to wad
     * @param a Ray
     * @return a casted to wad, rounded half up to the nearest wad
     **/
    function rayToWad(uint256 a) internal pure returns (uint256) {
        uint256 halfRatio = WAD_RAY_RATIO / 2;
        uint256 result = halfRatio + a;
        require(result >= halfRatio, ""addition overflow"");

        return result / WAD_RAY_RATIO;
    }

    /**
     * @dev Converts wad up to ray
     * @param a Wad
     * @return a converted in ray
     **/
    function wadToRay(uint256 a) internal pure returns (uint256) {
        uint256 result = a * WAD_RAY_RATIO;
        require(result / WAD_RAY_RATIO == a, ""multiplication oveflow"");
        return result;
    }
}",1030
RealWorld_BA_37_IRateProvider_RealWord_20240820113916.log,37,IRateProvider,5977,3924,9901,75.0,0.108365,"// SPDX-License-Identifier: GPL-3.0-or-later
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity ^0.7.0;

interface IRateProvider {
    function getRate() external view returns (uint256);
}",179
RealWorld_BA_38_SignatureValidatorV2_RealWord_20240820121329.log,38,SignatureValidatorV2,15617,5344,20961,79.0,0.184965,"// SPDX-License-Identifier: agpl-3.0
pragma solidity ^0.8.7;

import ""./BytesLib.sol"";

interface IERC1271Wallet {
	function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4 magicValue);
}

library SignatureValidator {
	using LibBytes for bytes;

	enum SignatureMode {
		NoSig,
		EIP712,
		EthSign,
		SmartWallet,
		Spoof,
		// must be at the end
		Unsupported
	}

	// bytes4(keccak256(""isValidSignature(bytes32,bytes)""))
	bytes4 constant internal ERC1271_MAGICVALUE_BYTES32 = 0x1626ba7e;

	function recoverAddr(bytes32 hash, bytes memory sig) internal view returns (address) {
		return recoverAddrImpl(hash, sig, false);
	}

	function recoverAddrImpl(bytes32 hash, bytes memory sig, bool allowSpoofing) internal view returns (address) {
		require(sig.length >= 1, ""SignatureValidator: basic sig len"");
		uint8 modeRaw = uint8(sig[sig.length - 1]);
		require(modeRaw < uint8(SignatureMode.Unsupported), ""SignatureValidator: unsupported sig mode"");
		SignatureMode mode = SignatureMode(modeRaw);

		if (mode == SignatureMode.NoSig) {
			return address(0x0);
		}

		// {r}{s}{v}{mode}
		if (mode == SignatureMode.EIP712 || mode == SignatureMode.EthSign) {
			require(sig.length == 66, ""SignatureValidator: sig len"");
			bytes32 r = sig.readBytes32(0);
			bytes32 s = sig.readBytes32(32);
			// @TODO: is there a gas saving to be had here by using assembly?
			uint8 v = uint8(sig[64]);
			// Hesitant about this check: seems like this is something that has no business being checked on-chain
			require(v == 27 || v == 28, ""invalid v"");
			if (mode == SignatureMode.EthSign) hash = keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash));
			return ecrecover(hash, v, r, s);
		}
		// {sig}{verifier}{mode}
		if (mode == SignatureMode.SmartWallet) {
			// 32 bytes for the addr, 1 byte for the type = 33
			require(sig.length > 33, ""SignatureValidator: wallet sig len"");
			// @TODO: can we pack the addr tigher into 20 bytes? should we?
			IERC1271Wallet wallet = IERC1271Wallet(address(uint160(uint256(sig.readBytes32(sig.length - 33)))));
			sig.trimToSize(sig.length - 33);
			require(ERC1271_MAGICVALUE_BYTES32 == wallet.isValidSignature(hash, sig), ""SignatureValidator: invalid wallet sig"");
			return address(wallet);
		}
		// {address}{mode}; the spoof mode is used when simulating calls
		if (mode == SignatureMode.Spoof && allowSpoofing) {
			require(tx.origin == address(1), ""SignatureValidator: spoof must be used with specific addr"");
			require(sig.length == 33, ""SignatureValidator: spoof sig len"");
			sig.trimToSize(32);
			return abi.decode(sig, (address));
		}
		return address(0x00);
	}
}",740
RealWorld_BA_38_IdentityFactory_RealWord_20240820121207.log,38,IdentityFactory,17216,5485,22701,80.0,0.19578,"// SPDX-License-Identifier: agpl-3.0
pragma solidity ^0.8.0;

import ""./Identity.sol"";
import ""./interfaces/IERC20.sol"";

contract IdentityFactory {
	event LogDeployed(address addr, uint256 salt);

	address public creator;
	constructor() {
		creator = msg.sender;
	}

	function deploy(bytes calldata code, uint256 salt) external {
		deploySafe(code, salt);
	}

	// When the relayer needs to act upon an /identity/:addr/submit call, it'll either call execute on the Identity directly
	// if it's already deployed, or call `deployAndExecute` if the account is still counterfactual
	// we can't have deployAndExecuteBySender, because the sender will be the factory
	function deployAndExecute(
		bytes calldata code, uint256 salt,
		Identity.Transaction[] calldata txns, bytes calldata signature
	) external {
		address payable addr = payable(deploySafe(code, salt));
		Identity(addr).execute(txns, signature);
	}
	// but for the quick accounts we need this
	function deployAndCall(bytes calldata code, uint256 salt, address callee, bytes calldata data) external {
		deploySafe(code, salt);
		require(data.length > 4, 'DATA_LEN');
		bytes4 method;
		// solium-disable-next-line security/no-inline-assembly
		assembly {
			// can also do shl(224, shr(224, calldataload(0)))
			method := and(calldataload(data.offset), 0xffffffff00000000000000000000000000000000000000000000000000000000)
		}
		require(
			method == 0x6171d1c9 // execute((address,uint256,bytes)[],bytes)
			|| method == 0x534255ff // send(address,(uint256,address,address),(bool,bytes,bytes),(address,uint256,bytes)[])
			|| method == 0xf9338537 // sendTransfer(address,(uint256,address,address),bytes,bytes,(address,address,uint256,uint256))
			|| method == 0xa9f5353d // sendTxns(address,(uint256,address,address),bytes,bytes,(string,address,uint256,bytes)[])
		, 'INVALID_METHOD');
		(bool success, bytes memory errData) = callee.call(data);
		if (!success) revert(string(errData));
	}


	// Withdraw the earnings from various fees (deploy fees and execute fees earned cause of `deployAndExecute`)
	// although we do not use this since we no longer receive fees on the factory, it's good to have this for safety
	function withdraw(IERC20 token, address to, uint256 tokenAmount) public {
		require(msg.sender == creator, 'ONLY_CREATOR');
		token.transfer(to, tokenAmount);
	}

	// This is done to mitigate possible frontruns where, for example, deploying the same code/salt via deploy()
	// would make a pending deployAndExecute fail
	// The way we mitigate that is by checking if the contract is already deployed and if so, we continue execution
	function deploySafe(bytes memory code, uint256 salt) internal returns (address) {
		address expectedAddr = address(uint160(uint256(
			keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(code)))
		)));
		uint size;
		assembly { size := extcodesize(expectedAddr) }
		// If there is code at that address, we can assume it's the one we were about to deploy,
		// because of how CREATE2 and keccak256 works
		if (size == 0) {
			address addr;
			assembly { addr := create2(0, add(code, 0x20), mload(code), salt) }
			require(addr != address(0), 'FAILED_DEPLOYING');
			require(addr == expectedAddr, 'FAILED_MATCH');
			emit LogDeployed(addr, salt);
		}
		return expectedAddr;
	}
}",863
RealWorld_BA_38_BytesLib_RealWord_20240820121450.log,38,BytesLib,7640,5272,12912,75.0,0.14364,"// SPDX-License-Identifier: agpl-3.0
pragma solidity ^0.8.7;

// @TODO: Formatting
library LibBytes {
  using LibBytes for bytes;

  // @TODO: see if we can just set .length = 
  function trimToSize(bytes memory b, uint newLen)
    internal
    pure
  {
    require(b.length > newLen, ""BytesLib: only shrinking"");
    assembly {
      mstore(b, newLen)
    }
  }


  /***********************************|
  |        Read Bytes Functions       |
  |__________________________________*/

  /**
   * @dev Reads a bytes32 value from a position in a byte array.
   * @param b Byte array containing a bytes32 value.
   * @param index Index in byte array of bytes32 value.
   * @return result bytes32 value from byte array.
   */
  function readBytes32(
    bytes memory b,
    uint256 index
  )
    internal
    pure
    returns (bytes32 result)
  {
    require(b.length >= index + 32, ""BytesLib: length"");

    // Arrays are prefixed by a 256 bit length parameter
    index += 32;

    // Read the bytes32 from array memory
    assembly {
      result := mload(add(b, index))
    }
    return result;
  }
}",282
RealWorld_BA_38_Identity_RealWord_20240820121046.log,38,Identity,33320,5311,38631,79.0,0.27282,"// SPDX-License-Identifier: agpl-3.0
pragma solidity ^0.8.7;

import ""./libs/SignatureValidatorV2.sol"";

contract Identity {
	mapping (address => bytes32) public privileges;
	// The next allowed nonce
	uint public nonce = 0;

	// Events
	event LogPrivilegeChanged(address indexed addr, bytes32 priv);
	event LogErr(address indexed to, uint value, bytes data, bytes returnData); // only used in tryCatch

	// Transaction structure
	// we handle replay protection separately by requiring (address(this), chainID, nonce) as part of the sig
	struct Transaction {
		address to;
		uint value;
		bytes data;
	}

	constructor(address[] memory addrs) {
		uint len = addrs.length;
		for (uint i=0; i<len; i++) {
			// @TODO should we allow setting to any arb value here?
			privileges[addrs[i]] = bytes32(uint(1));
			emit LogPrivilegeChanged(addrs[i], bytes32(uint(1)));
		}
	}

	// This contract can accept ETH without calldata
	receive() external payable {}

	// This contract can accept ETH with calldata
	// However, to support EIP 721 and EIP 1155, we need to respond to those methods with their own method signature
	fallback() external payable {
		bytes4 method = msg.sig;
		if (
			method == 0x150b7a02 // bytes4(keccak256(""onERC721Received(address,address,uint256,bytes)""))
				|| method == 0xf23a6e61 // bytes4(keccak256(""onERC1155Received(address,address,uint256,uint256,bytes)""))
				|| method == 0xbc197c81 // bytes4(keccak256(""onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)""))
		) {
			// Copy back the method
			// solhint-disable-next-line no-inline-assembly
			assembly {
				calldatacopy(0, 0, 0x04)
				return (0, 0x20)
			}
		}
	}

	function setAddrPrivilege(address addr, bytes32 priv)
		external
	{
		require(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');
		// Anti-bricking measure: if the privileges slot is used for special data (not 0x01),
		// don't allow to set it to true
		if (privileges[addr] != bytes32(0) && privileges[addr] != bytes32(uint(1)))
			require(priv != bytes32(uint(1)), 'UNSETTING_SPECIAL_DATA');
		privileges[addr] = priv;
		emit LogPrivilegeChanged(addr, priv);
	}

	function tipMiner(uint amount)
		external
	{
		require(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');
		// See https://docs.flashbots.net/flashbots-auction/searchers/advanced/coinbase-payment/#managing-payments-to-coinbaseaddress-when-it-is-a-contract
		// generally this contract is reentrancy proof cause of the nonce
		executeCall(block.coinbase, amount, new bytes(0));
	}

	function tryCatch(address to, uint value, bytes calldata data)
		external
	{
		require(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');
		(bool success, bytes memory returnData) = to.call{value: value, gas: gasleft()}(data);
		if (!success) emit LogErr(to, value, data, returnData);
	}


	// WARNING: if the signature of this is changed, we have to change IdentityFactory
	function execute(Transaction[] calldata txns, bytes calldata signature)
		external
	{
		require(txns.length > 0, 'MUST_PASS_TX');
		// If we use the naive abi.encode(txn) and have a field of type `bytes`,
		// there is a discrepancy between ethereumjs-abi and solidity
		// @TODO check if this is resolved
		uint currentNonce = nonce;
		// NOTE: abi.encode is safer than abi.encodePacked in terms of collision safety
		bytes32 hash = keccak256(abi.encode(address(this), block.chainid, currentNonce, txns));
		// We have to increment before execution cause it protects from reentrancies
		nonce = currentNonce + 1;

		address signer = SignatureValidator.recoverAddrImpl(hash, signature, true);
		require(privileges[signer] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');
		uint len = txns.length;
		for (uint i=0; i<len; i++) {
			Transaction memory txn = txns[i];
			executeCall(txn.to, txn.value, txn.data);
		}
		// The actual anti-bricking mechanism - do not allow a signer to drop their own priviledges
		require(privileges[signer] != bytes32(0), 'PRIVILEGE_NOT_DOWNGRADED');
	}

	// no need for nonce management here cause we're not dealing with sigs
	function executeBySender(Transaction[] calldata txns) external {
		require(txns.length > 0, 'MUST_PASS_TX');
		require(privileges[msg.sender] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');
		uint len = txns.length;
		for (uint i=0; i<len; i++) {
			Transaction memory txn = txns[i];
			executeCall(txn.to, txn.value, txn.data);
		}
		// again, anti-bricking
		require(privileges[msg.sender] != bytes32(0), 'PRIVILEGE_NOT_DOWNGRADED');
	}

	// we shouldn't use address.call(), cause: https://github.com/ethereum/solidity/issues/2884
	// copied from https://github.com/uport-project/uport-identity/blob/develop/contracts/Proxy.sol
	// there's also
	// https://github.com/gnosis/MultiSigWallet/commit/e1b25e8632ca28e9e9e09c81bd20bf33fdb405ce
	// https://github.com/austintgriffith/bouncer-proxy/blob/master/BouncerProxy/BouncerProxy.sol
	// https://github.com/gnosis/safe-contracts/blob/7e2eeb3328bb2ae85c36bc11ea6afc14baeb663c/contracts/base/Executor.sol
	function executeCall(address to, uint256 value, bytes memory data)
		internal
	{
		assembly {
			let result := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)

			switch result case 0 {
				let size := returndatasize()
				let ptr := mload(0x40)
				returndatacopy(ptr, 0, size)
				revert(ptr, size)
			}
			default {}
		}
		// A single call consumes around 477 more gas with the pure solidity version, for whatever reason
		//(bool success, bytes memory returnData) = to.call{value: value, gas: gasleft()}(data);
		//if (!success) revert(string(data));
	}

	// EIP 1271 implementation
	// see https://eips.ethereum.org/EIPS/eip-1271
	function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4) {
		if (privileges[SignatureValidator.recoverAddr(hash, signature)] != bytes32(0)) {
			// bytes4(keccak256(""isValidSignature(bytes32,bytes)"")
			return 0x1626ba7e;
		} else {
			return 0xffffffff;
		}
	}

	// EIP 1155 implementation
	// we pretty much only need to signal that we support the interface for 165, but for 1155 we also need the fallback function
	function supportsInterface(bytes4 interfaceID) external pure returns (bool) {
		return
			interfaceID == 0x01ffc9a7 ||    // ERC-165 support (i.e. `bytes4(keccak256('supportsInterface(bytes4)'))`).
			interfaceID == 0x4e2312e0;      // ERC-1155 `ERC1155TokenReceiver` support (i.e. `bytes4(keccak256(""onERC1155Received(address,address,uint256,uint256,bytes)"")) ^ bytes4(keccak256(""onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)""))`).
	}
}",1880
RealWorld_BA_38_Zapper_RealWord_20240820121737.log,38,Zapper,35250,5741,40991,94.0,0.29107,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.7;

import ""../interfaces/IERC20.sol"";
import ""../interfaces/IUniV3SwapRouter.sol"";
import ""../libs/SafeERC20.sol"";

interface IAaveLendingPool {
  function deposit(
    address asset,
    uint256 amount,
    address onBehalfOf,
    uint16 referralCode
  ) external;
  function withdraw(
    address asset,
    uint256 amount,
    address to
  ) external returns (uint256);
}

// Full interface here: https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router01.sol
interface IUniswapSimple {
        function WETH() external pure returns (address);
        function swapTokensForExactTokens(
                uint amountOut,
                uint amountInMax,
                address[] calldata path,
                address to,
                uint deadline
        ) external returns (uint[] memory amounts);
	function swapExactTokensForTokens(
		uint amountIn,
		uint amountOutMin,
		address[] calldata path,
		address to,
		uint deadline
	) external returns (uint[] memory amounts);
}


interface IyVaultV2 {
    //function token() external view returns (address);
    //function deposit() external returns (uint);
    //function deposit(uint) external returns (uint);
    function deposit(uint, address) external returns (uint);
}

// Decisions: will start with aave over compound (easier API - has `onBehalfOf`, referrals), compound can be added later if needed
// uni v3 needs to be supported since it's proving that it's efficient and the router is different
contract WalletZapper {
	struct Trade {
		IUniswapSimple router;
		uint amountIn;
		uint amountOutMin;
		address[] path;
		bool wrap;
	}
	struct DiversificationTrade {
		address tokenOut;
		uint24 fee;
		uint allocPts;
		uint amountOutMin;
		bool wrap;
	}

	address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

	address public admin;
	mapping (address => bool) public allowedSpenders;
	IAaveLendingPool public lendingPool;
	uint16 aaveRefCode;
	constructor(IAaveLendingPool _lendingPool, uint16 _aaveRefCode, address[] memory spenders) {
		admin = msg.sender;
		lendingPool = _lendingPool;
		aaveRefCode = _aaveRefCode;
		allowedSpenders[address(_lendingPool)] = true;
		// This needs to include all of the routers, and all of the Yearn vaults
		for (uint i=0; i!=spenders.length; i++) {
			allowedSpenders[spenders[i]] = true;
		}
	}

	function approveMaxMany(address spender, address[] calldata tokens) external {
		require(msg.sender == admin, ""NOT_ADMIN"");
		require(allowedSpenders[spender], ""NOT_ALLOWED"");
		for (uint i=0; i!=tokens.length; i++) {
			SafeERC20.approve(tokens[i], spender, type(uint256).max);
		}
	}

	function approve(address token, address spender, uint amount) external {
		require(msg.sender == admin, ""NOT_ADMIN"");
		require(allowedSpenders[spender], ""NOT_ALLOWED"");
		SafeERC20.approve(token, spender, amount);
	}

	// Uniswap V2
	// We're choosing not to implement a special function for performing a single trade since it's not that much of a gas saving compared to this
	// We're also choosing not to implement a method like diversifyV3 which first trades the input asset to WETH and then WETH to whatever,
	//  because we expect diversifyV3 to be enough
	// We can very easily deploy a new Zapper and upgrade to it since it's just a UI change
	function exchangeV2(address[] calldata assetsToUnwrap, Trade[] memory trades) external {
		for (uint i=0; i!=assetsToUnwrap.length; i++) {
			lendingPool.withdraw(assetsToUnwrap[i], type(uint256).max, address(this));
		}
		address to = msg.sender;
		uint deadline = block.timestamp;
		uint len = trades.length;
		for (uint i=0; i!=len; i++) {
			Trade memory trade = trades[i];
			if (!trade.wrap) {
				trade.router.swapExactTokensForTokens(trade.amountIn, trade.amountOutMin, trade.path, to, deadline);
			} else {
				uint[] memory amounts = trade.router.swapExactTokensForTokens(trade.amountIn, trade.amountOutMin, trade.path, address(this), deadline);
				uint lastIdx = trade.path.length - 1;
				lendingPool.deposit(trade.path[lastIdx], amounts[lastIdx], to, aaveRefCode);
			}
		}
		// @TODO are there ways to ensure there are no leftover funds?

	}

	// go in/out of lending assets
	function wrapLending(address[] calldata assetsToWrap) external {
		for (uint i=0; i!=assetsToWrap.length; i++) {
			lendingPool.deposit(assetsToWrap[i], IERC20(assetsToWrap[i]).balanceOf(address(this)), msg.sender, aaveRefCode);
		}
	}
	function unwrapLending(address[] calldata assetsToUnwrap) external {
		for (uint i=0; i!=assetsToUnwrap.length; i++) {
			lendingPool.withdraw(assetsToUnwrap[i], type(uint256).max, msg.sender);
		}
	}

	// wrap WETH
	function wrapETH() payable external {
		// TODO: it may be slightly cheaper to call deposit() directly
		payable(WETH).transfer(msg.value);
	}

	// Uniswap V3
	function tradeV3(ISwapRouter uniV3Router, ISwapRouter.ExactInputParams calldata params) external returns (uint) {
		return uniV3Router.exactInput(params);
	}
	
	function tradeV3Single(ISwapRouter uniV3Router, ISwapRouter.ExactInputSingleParams calldata params, bool wrapOutputToLending) external returns (uint) {
		ISwapRouter.ExactInputSingleParams memory tradeParams = params;
		address recipient = params.recipient;
		if(wrapOutputToLending) {
			tradeParams.recipient = address(this);
		}

		uint amountOut = uniV3Router.exactInputSingle(tradeParams);
		if(wrapOutputToLending) {
			lendingPool.deposit(params.tokenOut, amountOut, recipient, aaveRefCode);
		}
		return amountOut;
	}

	// @TODO: unwrap input from aToken?
	function diversifyV3(ISwapRouter uniV3Router, address inputAsset, uint24 inputFee, uint inputMinOut, DiversificationTrade[] memory trades) external {
		uint inputAmount;
		if (inputAsset != address(0)) {
			inputAmount = uniV3Router.exactInputSingle(
			    ISwapRouter.ExactInputSingleParams (
				inputAsset,
				WETH,
				inputFee,
				address(this),
				block.timestamp,
				IERC20(inputAsset).balanceOf(address(this)),
				inputMinOut,
				0
			    )
			);
		} else {
			inputAmount = IERC20(WETH).balanceOf(address(this));
		}

		uint totalAllocPts;
		uint len = trades.length;
		for (uint i=0; i!=len; i++) {
			DiversificationTrade memory trade = trades[i];
			totalAllocPts += trade.allocPts;
			if (!trade.wrap) {
				uniV3Router.exactInputSingle(
				    ISwapRouter.ExactInputSingleParams (
					WETH,
					trade.tokenOut,
					trade.fee,
					msg.sender,
					block.timestamp,
					inputAmount * trade.allocPts / 1000,
					trade.amountOutMin,
					0
				    )
				);
			} else {
				uint amountToDeposit = uniV3Router.exactInputSingle(
				    ISwapRouter.ExactInputSingleParams (
					WETH,
					trade.tokenOut,
					trade.fee,
					address(this),
					block.timestamp,
					inputAmount * trade.allocPts / 1000,
					trade.amountOutMin,
					0
				    )
				);
				lendingPool.deposit(trade.tokenOut, amountToDeposit, msg.sender, aaveRefCode);
			}
		}

		IERC20 wrappedETH = IERC20(WETH);
		uint wrappedETHAmount = wrappedETH.balanceOf(address(this));
		if (wrappedETHAmount > 0) require(wrappedETH.transfer(msg.sender, wrappedETHAmount));
		// require(totalAllocPts == 1000, ""ALLOC_PTS"");
	}

	function depositYearn(IyVaultV2 vault, uint amount) external returns (uint) {
		return vault.deposit(amount, msg.sender);
	}

	function recoverFunds(IERC20 token, uint amount) external {
		require(msg.sender == admin, ""NOT_ADMIN"");
		token.transfer(admin, amount);
	}
}",2012
RealWorld_BA_38_IERC20_RealWord_20240820121914.log,38,IERC20,6034,5324,11358,80.0,0.13665,"// SPDX-License-Identifier: agpl-3.0
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",148
RealWorld_BA_38_IUniV3SwapRouter_RealWord_20240820122036.log,38,IUniV3SwapRouter,12597,5568,18165,86.0,0.174345,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.7.5;
pragma abicoder v2;

/// @title Router token swapping functionality
/// @notice Functions for swapping tokens via Uniswap V3
interface ISwapRouter {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    /// @notice Swaps `amountIn` of one token for as much as possible of another token
    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata
    /// @return amountOut The amount of the received token
    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);

    struct ExactInputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
    }

    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path
    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata
    /// @return amountOut The amount of the received token
    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);

    struct ExactOutputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
        uint160 sqrtPriceLimitX96;
    }

    /// @notice Swaps as little as possible of one token for `amountOut` of another token
    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata
    /// @return amountIn The amount of the input token
    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);

    struct ExactOutputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
    }

    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)
    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata
    /// @return amountIn The amount of the input token
    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);
}",571
RealWorld_BA_38_QuickAccManager_RealWord_20240820121607.log,38,QuickAccManager,39629,5056,44685,88.0,0.299265,"// SPDX-License-Identifier: agpl-3.0
pragma solidity ^0.8.7;

import ""../Identity.sol"";
import ""../interfaces/IERC20.sol"";

contract QuickAccManager {
	// Note: nonces are scoped by identity rather than by accHash - the reason for this is that there's no reason to scope them by accHash,
	// we merely need them for replay protection
	mapping (address => uint) nonces;
	mapping (bytes32 => uint) scheduled;

	bytes4 immutable CANCEL_PREFIX = 0xc47c3100;

	// Events
	// we only need those for timelocked stuff so we can show scheduled txns to the user; the oens that get executed immediately do not need logs
	event LogScheduled(bytes32 indexed txnHash, bytes32 indexed accHash, address indexed signer, uint nonce, uint time, Identity.Transaction[] txns);
	event LogCancelled(bytes32 indexed txnHash, bytes32 indexed accHash, address indexed signer, uint time);
	event LogExecScheduled(bytes32 indexed txnHash, bytes32 indexed accHash, uint time);

	// EIP 2612
	bytes32 public DOMAIN_SEPARATOR;
	constructor() {
		DOMAIN_SEPARATOR = keccak256(
			abi.encode(
				keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
				// @TODO: maybe we should use a more user friendly name here?
				keccak256(bytes('QuickAccManager')),
				keccak256(bytes('1')),
				block.chainid,
				address(this)
			)
		);
	}

	struct QuickAccount {
		uint timelock;
		address one;
		address two;
		// We decided to not allow certain options here such as ability to skip the second sig for send(), but leaving this a struct rather than a tuple
		// for clarity and to ensure it's future proof
	}
	struct DualSig {
		bool isBothSigned;
		bytes one;
		bytes two;
	}

	// NOTE: a single accHash can control multiple identities, as long as those identities set it's hash in privileges[address(this)]
	// this is by design

	// isBothSigned is hashed in so that we don't allow signatures from two-sig txns to be reused for single sig txns,
	// ...potentially frontrunning a normal two-sig transaction and making it wait
	// WARNING: if the signature of this is changed, we have to change IdentityFactory
	function send(Identity identity, QuickAccount calldata acc, DualSig calldata sigs, Identity.Transaction[] calldata txns) external {
		bytes32 accHash = keccak256(abi.encode(acc));
		require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');
		uint initialNonce = nonces[address(identity)];
		// Security: we must also hash in the hash of the QuickAccount, otherwise the sig of one key can be reused across multiple accs
		bytes32 hash = keccak256(abi.encode(
			address(this),
			block.chainid,
			accHash,
			nonces[address(identity)]++,
			txns,
			sigs.isBothSigned
		));
		if (sigs.isBothSigned) {
			require(acc.one == SignatureValidator.recoverAddr(hash, sigs.one), 'SIG_ONE');
			require(acc.two == SignatureValidator.recoverAddr(hash, sigs.two), 'SIG_TWO');
			identity.executeBySender(txns);
		} else {
			address signer = SignatureValidator.recoverAddr(hash, sigs.one);
			require(acc.one == signer || acc.two == signer, 'SIG');
			// no need to check whether `scheduled[hash]` is already set here cause of the incrementing nonce
			scheduled[hash] = block.timestamp + acc.timelock;
			emit LogScheduled(hash, accHash, signer, initialNonce, block.timestamp, txns);
		}
	}

	function cancel(Identity identity, QuickAccount calldata acc, uint nonce, bytes calldata sig, Identity.Transaction[] calldata txns) external {
		bytes32 accHash = keccak256(abi.encode(acc));
		require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');

		bytes32 hash = keccak256(abi.encode(CANCEL_PREFIX, address(this), block.chainid, accHash, nonce, txns, false));
		address signer = SignatureValidator.recoverAddr(hash, sig);
		require(signer == acc.one || signer == acc.two, 'INVALID_SIGNATURE');

		// @NOTE: should we allow cancelling even when it's matured? probably not, otherwise there's a minor grief
		// opportunity: someone wants to cancel post-maturity, and you front them with execScheduled
		bytes32 hashTx = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns));
		require(scheduled[hashTx] != 0 && block.timestamp < scheduled[hashTx], 'TOO_LATE');
		delete scheduled[hashTx];

		emit LogCancelled(hashTx, accHash, signer, block.timestamp);
	}

	function execScheduled(Identity identity, bytes32 accHash, uint nonce, Identity.Transaction[] calldata txns) external {
		require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');

		bytes32 hash = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns, false));
		require(scheduled[hash] != 0 && block.timestamp >= scheduled[hash], 'NOT_TIME');
		delete scheduled[hash];
		identity.executeBySender(txns);

		emit LogExecScheduled(hash, accHash, block.timestamp);
	}

	// EIP 1271 implementation
	// see https://eips.ethereum.org/EIPS/eip-1271
	function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4) {
		(address payable id, uint timelock, bytes memory sig1, bytes memory sig2) = abi.decode(signature, (address, uint, bytes, bytes));
		bytes32 accHash = keccak256(abi.encode(QuickAccount({
			timelock: timelock,
			one: SignatureValidator.recoverAddr(hash, sig1),
			two: SignatureValidator.recoverAddr(hash, sig2)
		})));
		if (Identity(id).privileges(address(this)) == accHash) {
			// bytes4(keccak256(""isValidSignature(bytes32,bytes)"")
			return 0x1626ba7e;
		} else {
			return 0xffffffff;
		}
	}

	// EIP 712 methods
	// all of the following are 2/2 only
	bytes32 private TRANSFER_TYPEHASH = keccak256('Transfer(address tokenAddr,address to,uint256 value,uint256 fee,uint256 nonce)');
	struct Transfer { address token; address to; uint amount; uint fee; }
	// WARNING: if the signature of this is changed, we have to change IdentityFactory
	function sendTransfer(Identity identity, QuickAccount calldata acc, bytes calldata sigOne, bytes calldata sigTwo, Transfer calldata t) external {
		require(identity.privileges(address(this)) == keccak256(abi.encode(acc)), 'WRONG_ACC_OR_NO_PRIV');

		bytes32 hash = keccak256(abi.encodePacked(
			'\x19\x01',
			DOMAIN_SEPARATOR,
			keccak256(abi.encode(TRANSFER_TYPEHASH, t.token, t.to, t.amount, t.fee, nonces[address(identity)]++))
		));
		require(acc.one == SignatureValidator.recoverAddr(hash, sigOne), 'SIG_ONE');
		require(acc.two == SignatureValidator.recoverAddr(hash, sigTwo), 'SIG_TWO');
		Identity.Transaction[] memory txns = new Identity.Transaction[](2);
		txns[0].to = t.token;
		txns[0].data = abi.encodeWithSelector(IERC20.transfer.selector, t.to, t.amount);
		txns[1].to = t.token;
		txns[1].data = abi.encodeWithSelector(IERC20.transfer.selector, msg.sender, t.fee);
		identity.executeBySender(txns);
	}

	// Reference for arrays: https://github.com/sportx-bet/smart-contracts/blob/e36965a0c4748bf73ae15ed3cab5660c9cf722e1/contracts/impl/trading/EIP712FillHasher.sol
	// and https://eips.ethereum.org/EIPS/eip-712
	// and for signTypedData_v4: https://gist.github.com/danfinlay/750ce1e165a75e1c3387ec38cf452b71
	struct Txn { string description; address to; uint value; bytes data; }
	bytes32 private TXNS_TYPEHASH = keccak256('Txn(string description,address to,uint256 value,bytes data)');
	bytes32 private BUNDLE_TYPEHASH = keccak256('Bundle(uint256 nonce,Txn[] transactions)');
	// WARNING: if the signature of this is changed, we have to change IdentityFactory
	function sendTxns(Identity identity, QuickAccount calldata acc, bytes calldata sigOne, bytes calldata sigTwo, Txn[] calldata txns) external {
		require(identity.privileges(address(this)) == keccak256(abi.encode(acc)), 'WRONG_ACC_OR_NO_PRIV');

		// hashing + prepping args
		bytes32[] memory txnBytes = new bytes32[](txns.length);
		Identity.Transaction[] memory identityTxns = new Identity.Transaction[](txns.length);
		for (uint256 i = 0; i < txns.length; i++) {
			txnBytes[i] = keccak256(abi.encode(TXNS_TYPEHASH, txns[i].description, txns[i].to, txns[i].value, txns[i].data));
			identityTxns[i].to = txns[i].to;
			identityTxns[i].value = txns[i].value;
			identityTxns[i].data = txns[i].data;
		}
		bytes32 txnsHash = keccak256(abi.encodePacked(txnBytes));
		bytes32 hash = keccak256(abi.encodePacked(
			'\x19\x01',
			DOMAIN_SEPARATOR,
			keccak256(abi.encode(BUNDLE_TYPEHASH, nonces[address(identity)]++, txnsHash))
		));
		require(acc.one == SignatureValidator.recoverAddr(hash, sigOne), 'SIG_ONE');
		require(acc.two == SignatureValidator.recoverAddr(hash, sigTwo), 'SIG_TWO');
		identity.executeBySender(identityTxns);
	}

}",2281
RealWorld_BA_39_VaultTracker_RealWord_20240820124710.log,39,VaultTracker,16900,5264,22164,120.0,0.18978,"// SPDX-License-Identifier: UNLICENSED

/**
  VaultTracker is a mock which records arguments passed to its methods as well as
  provides setters allowing us to dictate method return values
*/

pragma solidity 0.8.4;

contract VaultTracker {
  struct TransferNotionalFromArgs {
    address to;
    uint256 amount;
  }

  // mapping of arguments sent to addNotional. key is the passed in address.
  mapping (address => uint256) public addNotionalCalled;
  // mapping of arguments sent to removeNotional. key is the passed in address.
  mapping (address => uint256) public removeNotionalCalled;
  // mapping of arguments sent to transferNotionalFrom. key is the passed in address.
  mapping (address => TransferNotionalFromArgs) public transferNotionalFromCalled;
  // mapping of args sent to transferFee, key is the given payer's address
  mapping (address => uint256) public transferNotionalFeeCalled;

  address public cTokenAddr;
  address public swivel;
  address public redeemInterestCalled;

  uint256 private maturityReturn;
  uint256 private redeemInterestReturn;
  bool private matureVaultReturn;
  // a boolean flag which allows us to dictate the return of addNotional().
  bool private addNotionalReturn;
  // a boolean flag which allows us to dictate the return of removeNotional().
  bool private removeNotionalReturn;
  // a boolean flag which allows us to dictate the return of transferNotionalFrom().
  bool private transferNotionalFromReturn;
  bool private transferNotionalFeeReturn;

  /// @param m maturity
  /// @param c cToken address
  /// @param s deployed swivel contract address
  constructor(uint256 m, address c, address s) {
    maturityReturn = m;
    cTokenAddr = c;
    swivel = s;
  }

  function redeemInterestReturns(uint256 a) public {
    redeemInterestReturn = a;
  }

  function redeemInterest(address o) public returns (uint256) {
    redeemInterestCalled = o;
    return redeemInterestReturn;
  }

  function maturityReturns(uint256 n) public {
    maturityReturn = n;
  }

  // override what would be the autogenerated getter...
  function maturity() public view returns (uint256) {
    return maturityReturn;
  }

  function matureVault() public view returns (bool) {
    return matureVaultReturn;
  }

  function matureVaultReturns(bool b) public {
    matureVaultReturn = b;
  }

  function addNotionalReturns(bool b) public {
    addNotionalReturn = b;
  }

  function addNotional(address o, uint256 a) public returns (bool) {
    addNotionalCalled[o] = a;
    return addNotionalReturn;
  }

  function removeNotionalReturns(bool b) public {
    removeNotionalReturn = b;
  }

  function removeNotional(address o, uint256 a) public returns (bool) {
    removeNotionalCalled[o] = a;
    return removeNotionalReturn;
  }

  function transferNotionalFromReturns(bool b) public {
    transferNotionalFromReturn = b;
  }

  function transferNotionalFrom(address f, address t, uint256 a) public returns (bool) {
    TransferNotionalFromArgs memory args;
    args.to = t;
    args.amount = a;
    transferNotionalFromCalled[f] = args;
    return transferNotionalFromReturn;
  }

  function transferNotionalFeeReturns(bool b) public {
    transferNotionalFeeReturn = b;
  }

  function transferNotionalFee(address f, uint256 a) public returns (bool) {
    transferNotionalFeeCalled[f] = a;
    return transferNotionalFeeReturn;
  }
}",796
RealWorld_BA_39_Abstracts_RealWord_20240820125040.log,39,Abstracts,5200,4601,9801,79.0,0.11802,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.4;

abstract contract Erc20 {
	function approve(address, uint256) virtual external returns (bool);
	function transfer(address, uint256) virtual external returns (bool);
	function balanceOf(address) virtual external returns (uint256);
	function transferFrom(address, address, uint256) virtual public returns (bool);
}

abstract contract CErc20 is Erc20 {
	function mint(uint256) virtual external returns (uint256);
	function redeem(uint256) virtual external returns (uint256);
	function redeemUnderlying(uint256) virtual external returns (uint256);
	function exchangeRateCurrent() virtual external returns (uint256);
}",140
RealWorld_BA_39_ZcToken_RealWord_20240820131605.log,39,ZcToken,9058,5183,14241,79.0,0.14895,"// SPDX-License-Identifier: MIT

// NOTE: whomever decided methods which are the implementation of a stated interface
//       need to be labeled 'override' should to be publicly flogged.

pragma solidity 0.8.4;

import './Erc2612.sol';
import './IZcToken.sol';

/// NOTE the OZStlye naming conventions are kept for the internal methods
/// _burn and _mint as dangling underscores are generally not allowed.
contract ZcToken is Erc2612, IZcToken {
  address public immutable admin;
  address public immutable underlying;
  uint256 public immutable maturity;

  /// @param u Underlying
  /// @param m Maturity
  /// @param n Name
  /// @param s Symbol
  /// @param d Decimals
  constructor(address u, uint256 m, string memory n, string memory s, uint8 d) Erc2612(n, s, d) {
    admin = msg.sender;  
    underlying = u;
    maturity = m;
  }
  
  /// @param f Address to burn from
  /// @param a Amount to burn
  function burn(address f, uint256 a) external onlyAdmin(admin) override returns(bool) {
      _burn(f, a);
      return true;
  }

  /// @param t Address recieving the minted amount
  /// @param a The amount to mint
  function mint(address t, uint256 a) external onlyAdmin(admin) override returns(bool) {
      _mint(t, a);
      return true;
  }

  /// @param a Admin address
  modifier onlyAdmin(address a) {
    require(msg.sender == a, 'sender must be admin');
    _;
  }
}",362
RealWorld_BA_39_Hash_RealWord_20240820131042.log,39,Hash,17551,5483,23034,75.0,0.197415,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.4;

/**
  @notice Encapsulation of the logic to produce EIP712 hashed domain and messages.
  Also to produce / verify hashed and signed Orders.
  See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md
  See/attribute https://github.com/0xProject/0x-monorepo/blob/development/contracts/utils/contracts/src/LibEIP712.sol
*/

library Hash {
  /// @dev struct represents the attributes of an offchain Swivel.Order
  struct Order {
    bytes32 key;
    address maker;
    address underlying;
    bool vault;
    bool exit;
    uint256 principal;
    uint256 premium;
    uint256 maturity;
    uint256 expiry;
  }

  // EIP712 Domain Separator typeHash
  // keccak256(abi.encodePacked(
  //     'EIP712Domain(',
  //     'string name,',
  //     'string version,',
  //     'uint256 chainId,',
  //     'address verifyingContract',
  //     ')'
  // ));
  bytes32 constant internal DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;

  // EIP712 typeHash of an Order 
  // keccak256(abi.encodePacked(
  //     'Order(',
  //     'bytes32 key,',
  //     'address maker,',
  //     'address underlying,',
  //     'bool vault,',
  //     'bool exit,',
  //     'uint256 principal,',
  //     'uint256 premium,',
  //     'uint256 maturity,',
  //     'uint256 expiry',
  //     ')'
  // ));
  bytes32 constant internal ORDER_TYPEHASH = 0x7ddd38ab5ed1c16b61ca90eeb9579e29da1ba821cf42d8cdef8f30a31a6a4146;

  /// @param n EIP712 domain name
  /// @param version EIP712 semantic version string
  /// @param i Chain ID
  /// @param verifier address of the verifying contract
  function domain(string memory n, string memory version, uint256 i, address verifier) internal pure returns (bytes32) {
    bytes32 hash;

    assembly {
      let nameHash := keccak256(add(n, 32), mload(n))
      let versionHash := keccak256(add(version, 32), mload(version))
      let pointer := mload(64)
      mstore(pointer, DOMAIN_TYPEHASH)
      mstore(add(pointer, 32), nameHash)
      mstore(add(pointer, 64), versionHash)
      mstore(add(pointer, 96), i)
      mstore(add(pointer, 128), verifier)
      hash := keccak256(pointer, 160)
    }

    return hash;
  }

  /// @param d Type hash of the domain separator (see Hash.domain)
  /// @param h EIP712 hash struct (order for example)
  function message(bytes32 d, bytes32 h) internal pure returns (bytes32) {
    bytes32 hash;

    assembly {
      let pointer := mload(64)
      mstore(pointer, 0x1901000000000000000000000000000000000000000000000000000000000000)
      mstore(add(pointer, 2), d)
      mstore(add(pointer, 34), h)
      hash := keccak256(pointer, 66)
    }

    return hash;
  }

  /// @param o A Swivel Order
  function order(Order calldata o) internal pure returns (bytes32) {
    // TODO assembly
    return keccak256(abi.encode(
      ORDER_TYPEHASH,
      o.key,
      o.maker,
      o.underlying,
      o.vault,
      o.exit,
      o.principal,
      o.premium,
      o.maturity,
      o.expiry
    ));
  }
}",887
RealWorld_BA_39_Abstracts_RealWord_20240820124212.log,39,Abstracts,12425,5410,17835,103.0,0.170325,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.4;

abstract contract Erc20 {
	function approve(address, uint256) virtual external returns (bool);
	function transfer(address, uint256) virtual external returns (bool);
	function balanceOf(address) virtual external returns (uint256);
	function transferFrom(address, address, uint256) virtual public returns (bool);
}

abstract contract CErc20 is Erc20 {
	function mint(uint256) virtual external returns (uint256);
	function redeem(uint256) virtual external returns (uint256);
	function redeemUnderlying(uint256) virtual external returns (uint256);
	function exchangeRateCurrent() virtual external returns (uint256);
}

abstract contract MarketPlace {
  // adds notional and mints zctokens
  function mintZcTokenAddingNotional(address, uint256, address, uint256) virtual external returns (bool);
  // removes notional and burns zctokens
  function burnZcTokenRemovingNotional(address, uint256, address, uint256) virtual external returns (bool);
  // returns the amount of underlying principal to send
  function redeemZcToken(address, uint256, address, uint256) virtual external returns (uint256);
  // returns the amount of underlying interest to send
  function redeemVaultInterest(address, uint256, address) virtual external returns (uint256);
  // returns the cToken address for a given market
  function cTokenAddress(address, uint256) virtual external returns (address);
  // EVFZE FF EZFVE call this which would then burn zctoken and remove notional
  function custodialExit(address, uint256, address, address, uint256) virtual external returns (bool);
  // IVFZI && IZFVI call this which would then mint zctoken and add notional
  function custodialInitiate(address, uint256, address, address, uint256) virtual external returns (bool);
  // IZFZE && EZFZI call this, tranferring zctoken from one party to another
  function p2pZcTokenExchange(address, uint256, address, address, uint256) virtual external returns (bool);
  // IVFVE && EVFVI call this, removing notional from one party and adding to the other
  function p2pVaultExchange(address, uint256, address, address, uint256) virtual external returns (bool);
  // IVFZI && IVFVE call this which then transfers notional from msg.sender (taker) to swivel
  function transferVaultNotionalFee(address, uint256, address, uint256) virtual external returns (bool);
}",557
RealWorld_BA_39_Sig_RealWord_20240820131159.log,39,Sig,11528,4876,16404,66.0,0.15516,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.4;

library Sig {
  /// @dev ECDSA V,R and S components encapsulated here as we may not always be able to accept a bytes signature
  struct Components {
    uint8 v;  
    bytes32 r;
    bytes32 s;
  }

  /// @param h Hashed data which was originally signed
  /// @param c signature struct containing V,R and S
  /// @return The recovered address
  function recover(bytes32 h, Components calldata c) internal pure returns (address) {
    // EIP-2 and malleable signatures...
    // see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol
    require(uint256(c.s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, 'invalid signature ""s"" value');
    require(c.v == 27 || c.v == 28, 'invalid signature ""v"" value');

    return ecrecover(h, c.v, c.r, c.s);
  }

  /// @param h Hashed data which was originally signed
  /// @param sig Valid ECDSA signature
  /// @dev splitAndRecover should only be used if it is known that the resulting 
  /// verifying bit (V) will be 27 || 28. Otherwise use recover, possibly calling split first.
  /// @return The recovered address
  function splitAndRecover(bytes32 h, bytes memory sig) internal pure returns (address) {
    (uint8 v, bytes32 r, bytes32 s) = split(sig);

    return ecrecover(h, v, r, s);
  }

  /// @param sig Valid ECDSA signature
  /// @return v The verification bit
  /// @return r First 32 bytes
  /// @return s Next 32 bytes
  function split(bytes memory sig) internal pure returns (uint8, bytes32, bytes32) {
    require(sig.length == 65, 'invalid signature length'); // TODO standardize error messages

    bytes32 r;
    bytes32 s;
    uint8 v;

    assembly {
      r := mload(add(sig, 32))
      s := mload(add(sig, 64))
      v := byte(0, mload(add(sig, 96)))
    }

    return (v, r, s);
  }
}",524
RealWorld_BA_39_ZcToken_RealWord_20240820124550.log,39,ZcToken,13498,5355,18853,78.0,0.17459,"// SPDX-License-Identifier: UNLICENSED

/**
  ZcToken is a mock which records arguments passed to its methods as well as
  provides setters allowing us to dictate method return values
*/

pragma solidity 0.8.4;

contract ZcToken {
  // a struct to hold the arguments passed to transferFrom
  struct TransferFromArgs {
    address to;
    uint256 amount;
  }

  // mapping of arguments sent to burn. key is the passed in address.
  mapping (address => uint256) public burnCalled;
  // mapping of arguments sent to mint. key is the passed in address.
  mapping (address => uint256) public mintCalled;
  // mapping of arguments sent to transferFrom. key is passed from address.
  mapping (address => TransferFromArgs) public transferFromCalled;

  string public name;
  string public symbol;
  uint8 public decimals;
  address private underlyingReturn;
  uint256 private maturityReturn;
  // a boolean flag which allows us to dictate the return of burn().
  bool private burnReturn;
  // a boolean flag which allows us to dictate the return of mint().
  bool private mintReturn;
  // a boolean flag which allows us to dictate the return of transferFrom().
  bool private transferFromReturn;

  /// @param u Underlying
  /// @param m Maturity
  /// @param n Name
  /// @param s Symbol
  /// @param d Decimals
  constructor(address u, uint256 m, string memory n, string memory s, uint8 d) {
    // we can set the privates in the constructor as well...
    underlyingReturn = u;
    maturityReturn = m;

    name = n;
    symbol = s;
    decimals = d;
  }

  function burnReturns(bool b) public {
    burnReturn = b;
  }

  function burn(address f, uint256 a) public returns(bool) {
    burnCalled[f] = a;
    return burnReturn;
  }

  function mintReturns(bool b) public {
    mintReturn = b;
  }

  function mint(address f, uint256 a) public returns(bool) {
    mintCalled[f] = a;
    return mintReturn;
  }

  function underlyingReturns(address u) public {
    underlyingReturn = u;
  }
  
  // override what would be the autogenerated getter...
  function underlying() public view returns (address) {
    return underlyingReturn;
  }

  function maturityReturns(uint256 n) public {
    maturityReturn = n;
  }
  
  // override what would be the autogenerated getter...
  function maturity() public view returns (uint256) {
    return maturityReturn;
  }

  function transferFrom(address f, address t, uint256 a) public returns (bool) {
    TransferFromArgs memory args;
    args.to = t;
    args.amount = a;
    transferFromCalled[f] = args;
    return transferFromReturn;
  }

  function transferFromReturns(bool b) public {
    transferFromReturn = b;
  }
}",631
RealWorld_BA_39_Swivel_RealWord_20240820124357.log,39,Swivel,101052,5990,107042,110.0,0.62506,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.4;

import './Abstracts.sol';
import './Hash.sol';
import './Sig.sol';

contract Swivel {
  /// @dev maps the key of an order to a boolean indicating if an order was cancelled
  mapping (bytes32 => bool) public cancelled;
  /// @dev maps the key of an order to an amount representing its taken volume
  mapping (bytes32 => uint256) public filled;
  /// @dev maps a token address to a point in time, a hold, after which a withdrawal can be made
  mapping (address => uint256) public withdrawals;

  string constant public NAME = 'Swivel Finance';
  string constant public VERSION = '2.0.0';
  uint256 constant public HOLD = 259200; // obvs could be a smaller uint but packing?
  bytes32 public immutable domain;
  address public immutable marketPlace;
  address public immutable admin;
  /// @dev holds the fee demoninators for [zcTokenInitiate, zcTokenExit, vaultInitiate, vaultExit]
  uint16[] public fenominator;

  /// @notice Emitted on order cancellation
  event Cancel (bytes32 indexed key, bytes32 hash);
  /// @notice Emitted on any initiate*
  /// @dev filled is 'principalFilled' when (vault:false, exit:false) && (vault:true, exit:true)
  /// @dev filled is 'premiumFilled' when (vault:true, exit:false) && (vault:false, exit:true)
  event Initiate(bytes32 indexed key, bytes32 hash, address indexed maker, bool vault, bool exit, address indexed sender, uint256 amount, uint256 filled);
  /// @notice Emitted on any exit*
  /// @dev filled is 'principalFilled' when (vault:false, exit:false) && (vault:true, exit:true)
  /// @dev filled is 'premiumFilled' when (vault:true, exit:false) && (vault:false, exit:true)
  event Exit(bytes32 indexed key, bytes32 hash, address indexed maker, bool vault, bool exit, address indexed sender, uint256 amount, uint256 filled);
  /// @notice Emitted on token withdrawal scheduling
  /// @dev token is the address of the token scheduled for withdrawal
  /// @dev withdrawalTime is the timestamp at which the queued withdrawal will be possible
  event WithdrawalScheduled (address indexed token, uint256 hold);

  /// @param m deployed MarketPlace contract address
  constructor(address m) {
    admin = msg.sender;
    domain = Hash.domain(NAME, VERSION, block.chainid, address(this));
    marketPlace = m;
    fenominator = [200, 600, 400, 200];
  }

  // ********* INITIATING *************

  /// @notice Allows a user to initiate a position
  /// @param o Array of offline Swivel.Orders
  /// @param a Array of order volume (principal) amounts relative to passed orders
  /// @param c Array of Components from valid ECDSA signatures
  function initiate(Hash.Order[] calldata o, uint256[] calldata a, Sig.Components[] calldata c) external returns (bool) {
    // for each order filled, routes the order to the right interaction depending on its params
    for (uint256 i=0; i < o.length; i++) {
      // If the order filled is NOT an exit
      if (!o[i].exit) {
        // if the order filled does NOT involve a vault (nTokens)
        if (!o[i].vault) {
          // then the user has called `initiate` against a zcToken initiate and msg.sender is initiating a vault (purchasing nTokens, payingPremium)
          initiateVaultFillingZcTokenInitiate(o[i], a[i], c[i]);
        } else {
          // then the user has called `initiate` against a vault initiate and msg.sender is initiating a zcToken position (splitting and selling nTokens, receivingPremium)
          initiateZcTokenFillingVaultInitiate(o[i], a[i], c[i]);
        }
      } else {
        if (!o[i].vault) {
          // then the user has called `initiate` against a zcToken exit and msg.sender is initiating a zcToken position (splitting and selling nTokens, receivingPremium)
          initiateZcTokenFillingZcTokenExit(o[i], a[i], c[i]);
        } else {
          // then the user has called `initiate` against a vault exit (selling nTokens) and msg.sender is initiating a vault (purchasing nTokens, payingPremium)
          initiateVaultFillingVaultExit(o[i], a[i], c[i]);
        }
      }
    }

    return true;
  }

  /// @notice Allows a user to initiate a Vault by filling an offline zcToken initiate order
  /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.custodialInitiate
  /// @param o Order being filled
  /// @param a Amount of volume (premium) being filled by the taker's exit
  /// @param c Components of a valid ECDSA signature
  function initiateVaultFillingZcTokenInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {
    // checks order signature, order cancellation and order expiry
    bytes32 hash = validOrderHash(o, c);

    // checks the taker amount passed to amount available in the order
    require(a <= (o.premium - filled[hash]), 'taker amount > available volume');
    
    // adds the taker amount to the order's filled amount
    filled[hash] += a;

    // calculate principal filled and fee
    uint256 principalFilled = (((a * 1e18) / o.premium) * o.principal) / 1e18;
    uint256 fee = ((principalFilled * 1e18) / fenominator[2]) / 1e18;

    // transfer underlying tokens
    Erc20 uToken = Erc20(o.underlying);
    uToken.transferFrom(msg.sender, o.maker, a);
    uToken.transferFrom(o.maker, address(this), principalFilled);

    // deposit underlying to Compound and mint cTokens
    MarketPlace mPlace = MarketPlace(marketPlace);
    address cTokenAddr = mPlace.cTokenAddress(o.underlying, o.maturity);
    uToken.approve(cTokenAddr, principalFilled); 
    require(CErc20(cTokenAddr).mint(principalFilled) == 0, 'minting CToken failed');

    // mint <principalFilled> zcTokens + nTokens and allocate appropriately in marketplace
    require(mPlace.custodialInitiate(o.underlying, o.maturity, o.maker, msg.sender, principalFilled), 'custodial initiate failed');

    // transfer fee in vault notional to swivel (from msg.sender)
    require(mPlace.transferVaultNotionalFee(o.underlying, o.maturity, msg.sender, fee), ""notional fee transfer failed"");

    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);
  }

  /// @notice Allows a user to initiate a zcToken by filling an offline vault initiate order
  /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.custodialInitiate
  /// @param o Order being filled
  /// @param o Amount of volume (principal) being filled by the taker's exit
  /// @param c Components of a valid ECDSA signature
  function initiateZcTokenFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {
    bytes32 hash = validOrderHash(o, c);

    require((a <= o.principal - filled[hash]), 'taker amount > available volume');

    filled[hash] += a;

    uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;
    uint256 fee = ((premiumFilled * 1e18) / fenominator[0]) / 1e18;

    Erc20 uToken = Erc20(o.underlying);
    uToken.transferFrom(o.maker, msg.sender, premiumFilled);
    // transfer principal + fee in underlying to swivel (from sender)
    uToken.transferFrom(msg.sender, address(this), (a + fee));

    // deposit underlying to Compound and mint cTokens
    MarketPlace mPlace = MarketPlace(marketPlace);
    address cTokenAddr = mPlace.cTokenAddress(o.underlying, o.maturity);
    uToken.approve(cTokenAddr, a);
    require(CErc20(cTokenAddr).mint(a) == 0, 'minting CToken Failed');
    
    // mint <a> zcTokens + nTokens and allocate appropriately in marketplace
    require(mPlace.custodialInitiate(o.underlying, o.maturity, msg.sender, o.maker, a), 'custodial initiate failed');

    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);
  }

  /// @notice Allows a user to initiate zcToken? by filling an offline zcToken exit order
  /// @dev This method should pass (underlying, maturity, maker, sender, a) to MarketPlace.p2pZcTokenExchange
  /// @param o Order being filled
  /// @param a Amount of volume (principal) being filled by the taker's exit
  /// @param c Components of a valid ECDSA signature
  function initiateZcTokenFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {
    bytes32 hash = validOrderHash(o, c);

    require(a <= ((o.principal - filled[hash])), 'taker amount > available volume');

    filled[hash] += a;

    uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;
    uint256 fee = ((premiumFilled * 1e18) / fenominator[0]) / 1e18;

    // transfer underlying tokens - the premium paid + fee in underlying to swivel (from sender)
    Erc20(o.underlying).transferFrom(msg.sender, o.maker, ((a - premiumFilled) + fee));
    // transfer <a> zcTokens between users in marketplace
    require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), 'zcToken exchange failed');
            
    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);
  }

  /// @notice Allows a user to initiate a Vault by filling an offline vault exit order
  /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.p2pVaultExchange
  /// @param o Order being filled
  /// @param a Amount of volume (interest) being filled by the taker's exit
  /// @param c Components of a valid ECDSA signature
  function initiateVaultFillingVaultExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {
    bytes32 hash = validOrderHash(o, c);

    require(a <= (o.premium - filled[hash]), 'taker amount > available volume');

    filled[hash] += a;

    uint256 principalFilled = (((a * 1e18) / o.premium) * o.principal) / 1e18;
    uint256 fee = ((principalFilled * 1e18) / fenominator[2]) / 1e18;

    Erc20(o.underlying).transferFrom(msg.sender, o.maker, a);

    MarketPlace mPlace = MarketPlace(marketPlace);
    // transfer <principalFilled> vault.notional (nTokens) between users in marketplace
    require(mPlace.p2pVaultExchange(o.underlying, o.maturity, o.maker, msg.sender, principalFilled), 'vault exchange failed');

    // transfer fee (in nTokens) to swivel
    require(mPlace.transferVaultNotionalFee(o.underlying, o.maturity, msg.sender, fee), ""notional fee transfer failed"");

    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);
  }

  // ********* EXITING ***************

  /// @notice Allows a user to exit (sell) a currently held position to the marketplace.
  /// @param o Array of offline Swivel.Orders
  /// @param a Array of order volume (principal) amounts relative to passed orders
  /// @param c Components of a valid ECDSA signature
  function exit(Hash.Order[] calldata o, uint256[] calldata a, Sig.Components[] calldata c) external returns (bool) {
    // for each order filled, routes the order to the right interaction depending on its params
    for (uint256 i=0; i < o.length; i++) {
      // if the order is NOT an exit
      if (!o[i].exit) {
        // if the order filled does NOT involve a vault (nTokens)
          if (!o[i].vault) {
            // then the user has called `exit` against a zcToken initiate and msg.sender is exiting zcTokens (buying nTokens + redeeming, payingPremium)
            exitZcTokenFillingZcTokenInitiate(o[i], a[i], c[i]);
          } else {
            // then the user has called `exit` against a vault initiate and msg.sender is exiting nTokens (selling nTokens, receivingPremium)
            exitVaultFillingVaultInitiate(o[i], a[i], c[i]);
          }
      } else {
        if (!o[i].vault) {
           // then the user has called `exit` against a zcToken exit and msg.sender is exiting nTokens (selling nTokens, receivingPremium)
          exitVaultFillingZcTokenExit(o[i], a[i], c[i]);
        } else {
           // then the user has called `exit` against a vault exit and msg.sender is exiting zcTokens (buying nTokens + redeeming, payingPremium)
          exitZcTokenFillingVaultExit(o[i], a[i], c[i]);
        }   
      }   
    }

    return true;
  }

  /// @notice Allows a user to exit their zcTokens by filling an offline zcToken initiate order
  /// @dev This method should pass (underlying, maturity, sender, maker, principalFilled) to MarketPlace.p2pZcTokenExchange
  /// @param o Order being filled
  /// @param a Amount of volume (interest) being filled by the taker's exit
  /// @param c Components of a valid ECDSA signature
  function exitZcTokenFillingZcTokenInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {
    bytes32 hash = validOrderHash(o, c);

    require(a <= (o.premium - filled[hash]), 'taker amount > available volume');

    filled[hash] += a;       

    uint256 principalFilled = (((a * 1e18) / o.premium) * o.principal) / 1e18;
    uint256 fee = ((principalFilled * 1e18) / fenominator[1]) / 1e18;

    Erc20 uToken = Erc20(o.underlying);
    // transfer underlying from initiating party to exiting party, minus the price the exit party pays for the exit (premium), and the fee.
    uToken.transferFrom(o.maker, msg.sender, principalFilled - a - fee);
    // transfer fee in underlying to swivel
    uToken.transferFrom(o.maker, address(this), fee);

    // transfer <principalFilled> zcTokens from msg.sender to o.maker
    require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, msg.sender, o.maker, principalFilled), 'zcToken exchange failed');
    
    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);
  }
  
  /// @notice Allows a user to exit their Vault by filling an offline vault initiate order
  /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.p2pVaultExchange
  /// @param o Order being filled
  /// @param a Amount of volume (principal) being filled by the taker's exit
  /// @param c Components of a valid ECDSA signature
  function exitVaultFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {
    bytes32 hash = validOrderHash(o, c);

    require(a <= (o.principal - filled[hash]), 'taker amount > available volume');
    
    filled[hash] += a;
        
    uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;
    uint256 fee = ((premiumFilled * 1e18) / fenominator[3]) / 1e18;

    Erc20 uToken = Erc20(o.underlying);
    // transfer premium minus fee from maker to sender
    uToken.transferFrom(o.maker, msg.sender, premiumFilled - fee);

    // transfer fee in underlying to swivel from sender
    uToken.transferFrom(msg.sender, address(this), fee);

    // transfer <a> vault.notional (nTokens) from sender to maker
    require(MarketPlace(marketPlace).p2pVaultExchange(o.underlying, o.maturity, msg.sender, o.maker, a), 'vault exchange failed');

    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);
  }

  /// @notice Allows a user to exit their Vault filling an offline zcToken exit order
  /// @dev This method should pass (underlying, maturity, maker, sender, a) to MarketPlace.exitFillingExit
  /// @param o Order being filled
  /// @param a Amount of volume (principal) being filled by the taker's exit
  /// @param c Components of a valid ECDSA signature
  function exitVaultFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {
    bytes32 hash = validOrderHash(o, c);

    require(a <= (o.principal - filled[hash]), 'taker amount > available volume');
    
    filled[hash] += a;

    uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;
    uint256 fee = ((premiumFilled * 1e18) / fenominator[3]) / 1e18;
    
    // redeem underlying on Compound and burn cTokens
    MarketPlace mPlace = MarketPlace(marketPlace);
    address cTokenAddr = mPlace.cTokenAddress(o.underlying, o.maturity);
    require((CErc20(cTokenAddr).redeemUnderlying(a) == 0), ""compound redemption error"");

    Erc20 uToken = Erc20(o.underlying);
    // transfer principal-premium  back to fixed exit party now that the interest coupon and zcb have been redeemed
    uToken.transfer(o.maker, a - premiumFilled);
    // transfer premium-fee to floating exit party
    uToken.transfer(msg.sender, premiumFilled - fee);

    // burn zcTokens + nTokens from o.maker and msg.sender respectively
    require(mPlace.custodialExit(o.underlying, o.maturity, o.maker, msg.sender, a), 'custodial exit failed');


    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);
  }

  /// @notice Allows a user to exit their zcTokens by filling an offline vault exit order
  /// @dev This method should pass (underlying, maturity, sender, maker, principalFilled) to MarketPlace.exitFillingExit
  /// @param o Order being filled
  /// @param a Amount of volume (interest) being filled by the taker's exit
  /// @param c Components of a valid ECDSA signature
  function exitZcTokenFillingVaultExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {
    bytes32 hash = validOrderHash(o, c);

    require(a <= (o.premium - filled[hash]), 'taker amount > available volume');
    
    filled[hash] += a;

    uint256 principalFilled = (((a * 1e18) / o.premium) * o.principal) / 1e18;
    uint256 fee = ((principalFilled * 1e18) / fenominator[1]) / 1e18;

    // redeem underlying on Compound and burn cTokens
    MarketPlace mPlace = MarketPlace(marketPlace);
    address cTokenAddr = mPlace.cTokenAddress(o.underlying, o.maturity);
    require((CErc20(cTokenAddr).redeemUnderlying(principalFilled) == 0), ""compound redemption error"");

    Erc20 uToken = Erc20(o.underlying);
    // transfer principal-premium-fee back to fixed exit party now that the interest coupon and zcb have been redeemed
    uToken.transfer(msg.sender, principalFilled - a - fee);
    uToken.transfer(o.maker, a);

    // burn <principalFilled> zcTokens + nTokens from msg.sender and o.maker respectively
    require(mPlace.custodialExit(o.underlying, o.maturity, msg.sender, o.maker, principalFilled), 'custodial exit failed');

    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);
  }

  /// @notice Allows a user to cancel an order, preventing it from being filled in the future
  /// @param o Order being cancelled
  /// @param c Components of a valid ECDSA signature
  function cancel(Hash.Order calldata o, Sig.Components calldata c) external returns (bool) {
    bytes32 hash = validOrderHash(o, c);

    require(msg.sender == o.maker, 'sender must be maker');

    cancelled[hash] = true;

    emit Cancel(o.key, hash);

    return true;
  }

  // ********* ADMINISTRATIVE ***************

  /// @notice Allows the admin to schedule the withdrawal of tokens
  /// @param e Address of token to withdraw
  function scheduleWithdrawal(address e) external onlyAdmin(admin) {
    uint256 when = block.timestamp + HOLD;
    withdrawals[e] = when;
    emit WithdrawalScheduled(e, when);
  }

  /// @notice Emergency function to block unplanned withdrawals
  /// @param e Address of token withdrawal to block
  function blockWithdrawal(address e) external onlyAdmin(admin) {
      withdrawals[e] = 0;
  }

  /// @notice Allows the admin to withdraw the given token, provided the holding period has been observed
  /// @param e Address of token to withdraw
  function withdraw(address e) external onlyAdmin(admin) {
    uint256 when = withdrawals[e];
    require (when != 0, 'no withdrawal scheduled');
    require (block.timestamp >= when, 'withdrawal still on hold');

    withdrawals[e] = 0;

    Erc20 token = Erc20(e);
    token.transfer(admin, token.balanceOf(address(this)));
  }

  /// @notice Allows the admin to set a new fee denominator
  /// @param t The index of the new fee denominator
  /// @param d The new fee denominator
  function setFee(uint16 t, uint16 d) external onlyAdmin(admin) returns (bool) {
    fenominator[t] = d;
    return true;
  }

  // ********* PROTOCOL UTILITY ***************

  /// @notice Allows users to deposit underlying and in the process split it into/mint 
  /// zcTokens and vault notional. Calls mPlace.mintZcTokenAddingNotional
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param a Amount of underlying being deposited
  function splitUnderlying(address u, uint256 m, uint256 a) external returns (bool) {
    Erc20 uToken = Erc20(u);
    uToken.transferFrom(msg.sender, address(this), a);
    MarketPlace mPlace = MarketPlace(marketPlace);
    address cTokenAddr = mPlace.cTokenAddress(u, m);
    uToken.approve(cTokenAddr, a);
    require(CErc20(cTokenAddr).mint(a) == 0, 'minting CToken Failed');
    require(mPlace.mintZcTokenAddingNotional(u, m, msg.sender, a), 'mint ZcToken adding Notional failed');

    return true;
  }

  /// @notice Allows users deposit/burn 1-1 amounts of both zcTokens and vault notional,
  /// in the process ""combining"" the two, and redeeming underlying. Calls mPlace.burnZcTokenRemovingNotional.
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param a Amount of zcTokens being redeemed
  function combineTokens(address u, uint256 m, uint256 a) external returns (bool) {
    MarketPlace mPlace = MarketPlace(marketPlace);
    require(mPlace.burnZcTokenRemovingNotional(u, m, msg.sender, a), 'burn ZcToken removing Notional failed');
    address cTokenAddr = mPlace.cTokenAddress(u, m);
    require((CErc20(cTokenAddr).redeemUnderlying(a) == 0), ""compound redemption error"");
    Erc20(u).transfer(msg.sender, a);

    return true;
  }

  /// @notice Allows zcToken holders to redeem their tokens for underlying tokens after maturity has been reached (via MarketPlace).
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param a Amount of zcTokens being redeemed
  function redeemZcToken(address u, uint256 m, uint256 a) external returns (bool) {
    MarketPlace mPlace = MarketPlace(marketPlace);
    // call marketplace to determine the amount redeemed
    uint256 redeemed = mPlace.redeemZcToken(u, m, msg.sender, a);
    // redeem underlying from compound
    require(CErc20(mPlace.cTokenAddress(u, m)).redeemUnderlying(redeemed) == 0, 'compound redemption failed');
    // transfer underlying back to msg.sender
    Erc20(u).transfer(msg.sender, redeemed);

    return true;
  }

  /// @notice Allows Vault owners to redeem any currently accrued interest (via MarketPlace)
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  function redeemVaultInterest(address u, uint256 m) external returns (bool) {
    MarketPlace mPlace = MarketPlace(marketPlace);
    // call marketplace to determine the amount redeemed
    uint256 redeemed = mPlace.redeemVaultInterest(u, m, msg.sender);
    // redeem underlying from compound
    require(CErc20(mPlace.cTokenAddress(u, m)).redeemUnderlying(redeemed) == 0, 'compound redemption failed');
    // transfer underlying back to msg.sender
    Erc20(u).transfer(msg.sender, redeemed);

    return true;
  }

  /// @notice Varifies the validity of an order and it's signature.
  /// @param o An offline Swivel.Order
  /// @param c Components of a valid ECDSA signature
  /// @return the hashed order.
  function validOrderHash(Hash.Order calldata o, Sig.Components calldata c) internal view returns (bytes32) {
    bytes32 hash = Hash.order(o);

    require(!cancelled[hash], 'order cancelled');
    require(o.expiry >= block.timestamp, 'order expired');
    require(o.maker == Sig.recover(Hash.message(domain, hash), c), 'invalid signature');

    return hash;
  }

  modifier onlyAdmin(address a) {
    require(msg.sender == a, 'sender must be admin');
    _;
  }
}",6160
RealWorld_BA_39_MarketPlace_RealWord_20240820123752.log,39,MarketPlace,28141,5511,33652,87.0,0.250925,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.4;

/// @dev MarketPlace is a mock whose bindings are imported by unit tests in any pkg/*testing that needs it
contract MarketPlace {
  struct MethodArgs {
    uint256 maturity;
    address one; // is sender or maker depending on method
    address two; // same as above
    uint256 amount;
  }

  mapping (address => uint256) public cTokenAddressCalled;
  mapping (address => MethodArgs) public custodialInitiateCalled;
  mapping (address => MethodArgs) public custodialExitCalled;
  mapping (address => MethodArgs) public p2pZcTokenExchangeCalled;
  mapping (address => MethodArgs) public p2pVaultExchangeCalled;
  mapping (address => MethodArgs) public mintZcTokenAddingNotionalCalled;
  mapping (address => MethodArgs) public burnZcTokenRemovingNotionalCalled;
  mapping (address => MethodArgs) public transferVaultNotionalFeeCalled;
  mapping (address => MethodArgs) public redeemZcTokenCalled;
  mapping (address => MethodArgs) public redeemVaultInterestCalled;

  address private cTokenAddr;
  bool private custodialInitiateReturn;
  bool private custodialExitReturn;
  bool private p2pZcTokenExchangeReturn;
  bool private p2pVaultExchangeReturn;
  bool private mintZcTokenAddingNotionalReturn;
  bool private burnZcTokenRemovingNotionalReturn;
  bool private transferVaultNotionalFeeReturn;
  uint256 private redeemZcTokenReturn;
  uint256 private redeemVaultInterestReturn;

  function cTokenAddressReturns(address a) external {
    cTokenAddr = a;
  }

  function cTokenAddress(address u, uint256 m) external returns (address) {
    cTokenAddressCalled[u] = m;
    return cTokenAddr;
  }

  function custodialInitiateReturns(bool b) external {
    custodialInitiateReturn = b;
  }

  // called by swivel IVFZI && IZFVI 
  // call with underlying, maturity, mint-target, add-notional-target and an amount
  function custodialInitiate(address u, uint256 m, address o, address t, uint256 a) external returns (bool) {
    MethodArgs memory args; 
    args.maturity = m;
    args.one = o; // will be the recipient of minted zctoken
    args.two = t; // will be the recipient of added notional
    args.amount = a; // the amount of minted zctoken and notional added
    custodialInitiateCalled[u] = args;

    return custodialInitiateReturn;
  }

  function custodialExitReturns(bool b) external {
    custodialExitReturn = b;
  }

  // called by swivel EVFZE FF EZFVE
  // call with underlying, maturity, burn-target, remove-notional-target and an amount
  function custodialExit(address u, uint256 m, address o, address t, uint256 a) external returns (bool) {
    MethodArgs memory args; 
    args.maturity = m;
    args.one = o; // will be the burn-from target
    args.two = t; // will be the remove-notional target
    args.amount = a; // zctoken burned, notional removed
    custodialExitCalled[u] = args;

    return custodialExitReturn;
  }

  function p2pZcTokenExchangeReturns(bool b) external {
    p2pZcTokenExchangeReturn = b;
  }

  // called by swivel IZFZE, EZFZI
  // call with underlying, maturity, transfer-from, transfer-to, amount
  function p2pZcTokenExchange(address u, uint256 m, address o, address t, uint256 a) external returns (bool) {
    MethodArgs memory args;
    args.maturity = m;
    args.one = o;
    args.two = t;
    args.amount = a;
    p2pZcTokenExchangeCalled[u] = args;

    return p2pZcTokenExchangeReturn;
  }

  function p2pVaultExchangeReturns(bool b) external {
    p2pVaultExchangeReturn = b;
  }

  // called by swivel IVFVE, EVFVI
  // call with underlying, maturity, remove-from, add-to, amount
  function p2pVaultExchange(address u, uint256 m, address o, address t, uint256 a) external returns (bool) {
    MethodArgs memory args;
    args.maturity = m;
    args.one = o;
    args.two = t;
    args.amount = a;
    p2pVaultExchangeCalled[u] = args;

    return p2pVaultExchangeReturn;
  }

  function mintZcTokenAddingNotionalReturns(bool b) external {
    mintZcTokenAddingNotionalReturn = b;
  }

  // call with underlying, maturity, mint-to, amount
  function mintZcTokenAddingNotional(address u, uint256 m, address t, uint256 a) external returns (bool) {
    MethodArgs memory args;
    args.maturity = m;
    args.one = t;
    args.amount = a;
    mintZcTokenAddingNotionalCalled[u] = args;

    return mintZcTokenAddingNotionalReturn;
  }

  function burnZcTokenRemovingNotionalReturns(bool b) external {
    burnZcTokenRemovingNotionalReturn = b;
  }

  // call with underlying, maturity, mint-to, amount
  function burnZcTokenRemovingNotional(address u, uint256 m, address t, uint256 a) external returns (bool) {
    MethodArgs memory args;
    args.maturity = m;
    args.one = t;
    args.amount = a;
    burnZcTokenRemovingNotionalCalled[u] = args;

    return burnZcTokenRemovingNotionalReturn;
  }

  function transferVaultNotionalFeeReturns(bool b) external {
    transferVaultNotionalFeeReturn = b;
  }

  function transferVaultNotionalFee(address u, uint256 m, address f, uint256 a) external returns (bool) {
    MethodArgs memory args;
    args.maturity = m;
    args.one = f;
    args.amount = a;
    transferVaultNotionalFeeCalled[u] = args;

    return transferVaultNotionalFeeReturn;
  }

  function redeemZcTokenReturns(uint256 a) external {
    redeemZcTokenReturn = a;
  }

  function redeemZcToken(address u, uint256 m, address t, uint256 a) external returns (uint256) {
    MethodArgs memory args;
    args.maturity = m;
    args.one = t;
    args.amount = a;
    redeemZcTokenCalled[u] = args;

    return redeemZcTokenReturn;
  }

  function redeemVaultInterestReturns(uint256 a) external {
    redeemVaultInterestReturn = a;
  }

  function redeemVaultInterest(address u, uint256 m, address t) external returns (uint256) {
    MethodArgs memory args;
    args.maturity = m;
    args.one = t;
    redeemVaultInterestCalled[u] = args;

    return redeemVaultInterestReturn;
  }
}",1548
RealWorld_BA_39_Sig_RealWord_20240820124041.log,39,Sig,12430,5761,18191,89.0,0.17737,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.4;

library Sig {
  /// @dev ECDSA V,R and S components encapsulated here as we may not always be able to accept a bytes signature
  struct Components {
    uint8 v;  
    bytes32 r;
    bytes32 s;
  }

  /// @param h Hashed data which was originally signed
  /// @param c signature struct containing V,R and S
  /// @return The recovered address
  function recover(bytes32 h, Components calldata c) internal pure returns (address) {
    // EIP-2 and malleable signatures...
    // see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol
    require(uint256(c.s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, 'invalid signature ""s"" value');
    require(c.v == 27 || c.v == 28, 'invalid signature ""v"" value');

    return ecrecover(h, c.v, c.r, c.s);
  }

  /// @param h Hashed data which was originally signed
  /// @param sig Valid ECDSA signature
  /// @dev splitAndRecover should only be used if it is known that the resulting 
  /// verifying bit (V) will be 27 || 28. Otherwise use recover, possibly calling split first.
  /// @return The recovered address
  function splitAndRecover(bytes32 h, bytes memory sig) internal pure returns (address) {
    (uint8 v, bytes32 r, bytes32 s) = split(sig);

    return ecrecover(h, v, r, s);
  }

  /// @param sig Valid ECDSA signature
  /// @return v The verification bit
  /// @return r First 32 bytes
  /// @return s Next 32 bytes
  function split(bytes memory sig) internal pure returns (uint8, bytes32, bytes32) {
    require(sig.length == 65, 'invalid signature length'); // TODO standardize error messages

    bytes32 r;
    bytes32 s;
    uint8 v;

    assembly {
      r := mload(add(sig, 32))
      s := mload(add(sig, 64))
      v := byte(0, mload(add(sig, 96)))
    }

    return (v, r, s);
  }
}",524
RealWorld_BA_39_HashFake_RealWord_20240820125603.log,39,HashFake,10751,5402,16153,69.0,0.161795,"// SPDX-License-Identifier: UNLICENSED

/**
  @dev HashFake.sol is written specfically to test the functions which exist in our Hash.sol ""embedded"" library
*/

pragma solidity 0.8.4;

import './Hash.sol';

contract HashFake {
  /// @dev convenience method to get the domain type hash
  function domainTypeHash() public pure returns (bytes32) {
    return keccak256(abi.encodePacked(
      'EIP712Domain(',
      'string name,',
      'string version,',
      'uint256 chainId,',
      'address verifyingContract',
      ')'
    ));
  }

  function domainTest(string memory n, string memory version, uint256 c, address verifier) public pure returns (bytes32) {
    return Hash.domain(n, version, c, verifier);  
  }

  function messageTest(bytes32 d, bytes32 h) public pure returns (bytes32) {
    return Hash.message(d, h);
  }

  /// @dev convenience method to get the order type hash
  function orderTypeHash() public pure returns (bytes32) {
    return keccak256(abi.encodePacked(
      'Order(',
      'bytes32 key,',
      'address maker,',
      'address underlying,',
      'bool vault,',
      'bool exit,',
      'uint256 principal,',
      'uint256 premium,',
      'uint256 maturity,',
      'uint256 expiry',
      ')'
    ));
  }

  function orderTest(Hash.Order calldata o) external pure returns (bytes32) {
    return Hash.order(o);
  }

  /// @dev convenience method to generate the /token/hash permit type hash
  function permitTypeHash() public pure returns (bytes32) {
    return keccak256(abi.encodePacked(
      'Permit(',
      'address owner,',
      'address spender,',
      'uint256 value,',
      'uint256 nonce,',
      'uint256 deadline,',
      ')'
    ));
  }
}",429
RealWorld_BA_39_IZcToken_RealWord_20240820132131.log,39,IZcToken,4419,4367,8786,61.0,0.109435,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.4;

import ""./IPErc20.sol"";

/**
 * @dev Mint and burn interface for the ZCToken
 *
 */
interface IZcToken is IPErc20 {
    /**
     * @dev Mints...
     */
    function mint(address, uint256) external returns(bool);

    /**
     * @dev Burns...
     */
    function burn(address, uint256) external returns(bool);
}",97
RealWorld_BA_39_Erc20_RealWord_20240820123637.log,39,Erc20,11202,4761,15963,73.0,0.15123,"// SPDX-License-Identifier: UNLICENSED

/**
  Erc20 is a mock which records arguments passed to its methods as well as
  provides setters allowing us to dictate method return values
*/

pragma solidity 0.8.4;

contract Erc20 {
  // a struct to hold the arguments passed to transferFrom
  struct TransferFromArgs {
    address to;
    uint256 amount;
  }

  // mapping for arguments passed to approve
  mapping (address => uint256) public approveCalled;
  // mapping of arguments sent to transfer. key is the passed in address.
  mapping (address => uint256) public transferCalled;
  // mapping of arguments sent to transferFrom. key is passed from address.
  mapping (address => TransferFromArgs) public transferFromCalled;
  // balanceOf does not require a mapping.
  address public balanceOfCalled;

  // a boolean flag which allows us to dictate the return of approve(). 
  bool private approveReturn;
  // a uint to return for balanceOf calls
  uint256 private balanceOfReturn;
  // a boolean flag which allows us to dictate the return of transfer().
  bool private transferReturn;
  // a boolean flag which allows us to dictate the return of transferFrom().
  bool private transferFromReturn;

  function approve(address s, uint256 a) public returns (bool) {
    approveCalled[s] = a;
    return approveReturn;
  }

  function approveReturns(bool b) public {
    approveReturn = b;
  }

  function balanceOfReturns(uint256 b) public {
    balanceOfReturn = b;
  }

  function balanceOf(address t) public returns (uint256) {
    balanceOfCalled = t;
    return balanceOfReturn;
  }

  function transfer(address t, uint256 a) public returns (bool) {
    transferCalled[t] = a;
    return transferReturn;
  }

  function transferReturns(bool b) public {
    transferReturn = b;
  }

  function transferFrom(address f, address t, uint256 a) public returns (bool) {
    TransferFromArgs memory args;
    args.to = t;
    args.amount = a;
    transferFromCalled[f] = args;
    return transferFromReturn;
  }

  function transferFromReturns(bool b) public {
    transferFromReturn = b;
  }

}",486
RealWorld_BA_39_Underlying_RealWord_20240820130309.log,39,Underlying,5439,4658,10097,72.0,0.120355,"// SPDX-License-Identifier: UNLICENSED

/**
  Underlying is a (for now) ERC20 compatible token interface
*/

pragma solidity 0.8.4;

// For v2 we only need to read the balance and allowance of underlying
contract Underlying {
  mapping (address => uint256) public balances;

  mapping (address => mapping (address => uint256)) public allowances;

  function balanceOf(address o) public view returns (uint256) {
    return balances[o]; // this should not matter to the abi. i think...
  }

  function allowance(address o, address s) public view returns (uint256) {
    return allowances[o][s];
  }
}",142
RealWorld_BA_39_PErc20_RealWord_20240820130534.log,39,PErc20,39375,5258,44633,88.0,0.302035,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.4;

import ""./IPErc20.sol"";

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * NOTES: This is an adaptation of the Open Zeppelin ERC20, with changes made per audit
 * requests, and to fit overall Swivel Style. We use it specifically as the base for
 * the Erc2612 hence the `Perc` (Permissioned erc20) naming.
 *
 * Dangling underscores are generally not allowed within swivel style but the 
 * internal, abstracted implementation methods inherted from the O.Z contract are maintained here.
 * Hence, when you see a dangling underscore prefix, you know it is *only* allowed for
 * one of these method calls. It is not allowed for any other purpose. These are:
     _approve
     _transfer
     _mint
     _burn
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.


 */
contract PErc20 is IPErc20 {
    mapping (address => uint256) private balances;
    mapping (address => mapping (address => uint256)) private allowances;

    uint8 public decimals;
    uint256 public totalSupply;
    string public name; // NOTE: cannot make strings immutable
    string public symbol; // NOTE: see above

    /**
     * @dev Sets the values for {name} and {symbol}.
     * @param n Name of the token
     * @param s Symbol of the token
     * @param d Decimals of the token
     */
    constructor (string memory n, string memory s, uint8 d) {
        name = n;
        symbol = s;
        decimals = d;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     * @param a Adress to fetch balance of
     */
    function balanceOf(address a) public view virtual override returns (uint256) {
        return balances[a];
    }

    /**
     * @dev See {IERC20-transfer}.
     * @param r The recipient
     * @param a The amount transferred
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address r, uint256 a) public virtual override returns (bool) {
        _transfer(msg.sender, r, a);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     * @param o The owner
     * @param s The spender
     */
    function allowance(address o, address s) public view virtual override returns (uint256) {
        return allowances[o][s];
    }

    /**
     * @dev See {IERC20-approve}.
     * @param s The spender
     * @param a The amount to approve
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address s, uint256 a) public virtual override returns (bool) {
        _approve(msg.sender, s, a);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * @param s The sender
     * @param r The recipient
     * @param a The amount to transfer
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * Requirements:
     *
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address s, address r, uint256 a) public virtual override returns (bool) {
        _transfer(s, r, a);

        uint256 currentAllowance = allowances[s][msg.sender];
        require(currentAllowance >= a, ""erc20 transfer amount exceeds allowance"");
        _approve(s, msg.sender, currentAllowance - a);

        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     * @param s The spender
     * @param a The amount increased
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address s, uint256 a) public virtual returns (bool) {
        _approve(msg.sender, s, allowances[msg.sender][s] + a);
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     * @param s The spender
     * @param a The amount subtracted
     * 
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address s, uint256 a) public virtual returns (bool) {
        uint256 currentAllowance = allowances[msg.sender][s];
        require(currentAllowance >= a, ""erc20 decreased allowance below zero"");
        _approve(msg.sender, s, currentAllowance - a);

        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     * @param s The sender
     * @param r The recipient
     * @param a The amount to transfer
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address s, address r, uint256 a) internal virtual {
        require(s != address(0), ""erc20 transfer from the zero address"");
        require(r != address(0), ""erc20 transfer to the zero address"");

        uint256 senderBalance = balances[s];
        require(senderBalance >= a, ""erc20 transfer amount exceeds balance"");
        balances[s] = senderBalance - a;
        balances[r] += a;

        emit Transfer(s, r, a);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     * @param r The recipient
     * @param a The amount to mint
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     */
    function _mint(address r, uint256 a) internal virtual {
        require(r != address(0), ""erc20 mint to the zero address"");

        totalSupply += a;
        balances[r] += a;
        emit Transfer(address(0), r, a);
    }

    /**
     * @dev Destroys `amount` tokens from `owner`, reducing the
     * total supply.
     * @param o The owner of the amount being burned
     * @param a The amount to burn
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `owner` must have at least `amount` tokens.
     */
    function _burn(address o, uint256 a) internal virtual {
        require(o != address(0), ""erc20 burn from the zero address"");

        uint256 accountBalance = balances[o];
        require(accountBalance >= a, ""erc20 burn amount exceeds balance"");
        balances[o] = accountBalance - a;
        totalSupply -= a;

        emit Transfer(o, address(0), a);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     * @param o The owner
     * @param s The spender
     * @param a The amount
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address o, address s, uint256 a) internal virtual {
        require(o != address(0), ""erc20 approve from the zero address"");
        require(s != address(0), ""erc20 approve to the zero address"");

        allowances[o][s] = a;
        emit Approval(o, s, a);
    }
}",2254
RealWorld_BA_39_MarketPlace_RealWord_20240820132640.log,39,MarketPlace,52322,5169,57491,93.0,0.36499,"// SPDX-License-Identifier: UNLICENSED

// TODO update to 0.8.4 (or whatever latest is...)

// NOTE the pattern [underlying, maturity*, cToken, ...]

pragma solidity 0.8.4;

import './Abstracts.sol';
import './ZcToken.sol';
import './VaultTracker.sol';

contract MarketPlace {
  struct Market {
    address cTokenAddr;
    address zcTokenAddr;
    address vaultAddr;
  }

  mapping (address => mapping (uint256 => Market)) public markets;
  mapping (address => mapping (uint256 => bool)) public mature;
  mapping (address => mapping (uint256 => uint256)) public maturityRate;

  address public immutable admin;
  address public swivel;

  event Create(address indexed underlying, uint256 indexed maturity, address cToken, address zcToken, address vaultTracker);
  event Mature(address indexed underlying, uint256 indexed maturity, uint256 maturityRate, uint256 matured);
  event RedeemZcToken(address indexed underlying, uint256 indexed maturity, address indexed sender, uint256 amount);
  event RedeemVaultInterest(address indexed underlying, uint256 indexed maturity, address indexed sender);
  event CustodialInitiate(address indexed underlying, uint256 indexed maturity, address zcTarget, address nTarget, uint256 amount);
  event CustodialExit(address indexed underlying, uint256 indexed maturity, address zcTarget, address nTarget, uint256 amount);
  event P2pZcTokenExchange(address indexed underlying, uint256 indexed maturity, address from, address to, uint256 amount);
  event P2pVaultExchange(address indexed underlying, uint256 indexed maturity, address from, address to, uint256 amount);
  event TransferVaultNotional(address indexed underlying, uint256 indexed maturity, address from, address to, uint256 amount);

  constructor() {
    admin = msg.sender;
  }

  /// @param s Address of the deployed swivel contract
  function setSwivelAddress(address s) external onlyAdmin(admin) returns (bool) {
    swivel = s;
    return true;
  }

  /// @notice Allows the owner to create new markets
  /// @param u Underlying token address associated with the new market
  /// @param m Maturity timestamp of the new market
  /// @param c cToken address associated with underlying for the new market
  /// @param n Name of the new zcToken market
  /// @param s Symbol of the new zcToken market
  function createMarket(
    address u,
    uint256 m,
    address c,
    string memory n,
    string memory s,
    uint8 d
  ) public onlyAdmin(admin) returns (bool) {
    require(swivel != address(0), 'swivel contract address not set');
    // TODO can we live with the factory pattern here both bytecode size wise and CREATE opcode cost wise?
    address zctAddr = address(new ZcToken(u, m, n, s, d));
    address vAddr = address(new VaultTracker(m, c, swivel));
    markets[u][m] = Market(c, zctAddr, vAddr);

    emit Create(u, m, c, zctAddr, vAddr);

    return true;
  }

  /// @notice Can be called after maturity, allowing all of the zcTokens to earn floating interest on Compound until they release their funds
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  function matureMarket(address u, uint256 m) public returns (bool) {
    require(!mature[u][m], 'market already matured');
    require(block.timestamp >= ZcToken(markets[u][m].zcTokenAddr).maturity(), ""maturity not reached"");

    // set the base maturity cToken exchange rate at maturity to the current cToken exchange rate
    uint256 currentExchangeRate = CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent();
    maturityRate[u][m] = currentExchangeRate;
    // set the maturity state to true (for zcb market)
    mature[u][m] = true;

    // set vault ""matured"" to true
    require(VaultTracker(markets[u][m].vaultAddr).matureVault(), 'maturity not reached');

    emit Mature(u, m, block.timestamp, currentExchangeRate);

    return true;
  }

  /// @notice Allows Swivel caller to deposit their underlying, in the process splitting it - minting both zcTokens and vault notional.
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param t Address of the depositing user
  /// @param a Amount of notional being added
  function mintZcTokenAddingNotional(address u, uint256 m, address t, uint256 a) external onlySwivel(swivel) returns (bool) {
    require(ZcToken(markets[u][m].zcTokenAddr).mint(t, a), 'mint zcToken failed');
    require(VaultTracker(markets[u][m].vaultAddr).addNotional(t, a), 'add notional failed');
    
    return true;
  }

  /// @notice Allows Swivel caller to deposit/burn both zcTokens + vault notional. This process is ""combining"" the two and redeeming underlying.
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param t Address of the combining/redeeming user
  /// @param a Amount of zcTokens being burned
  function burnZcTokenRemovingNotional(address u, uint256 m, address t, uint256 a) external onlySwivel(swivel) returns(bool) {
    require(ZcToken(markets[u][m].zcTokenAddr).burn(t, a), 'burn failed');
    require(VaultTracker(markets[u][m].vaultAddr).removeNotional(t, a), 'remove notional failed');
    
    return true;
  }

  /// @notice Allows (via swivel) zcToken holders to redeem their tokens for underlying tokens after maturity has been reached.
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param t Address of the redeeming user
  /// @param a Amount of zcTokens being redeemed
  function redeemZcToken(address u, uint256 m, address t, uint256 a) external onlySwivel(swivel) returns (uint256) {
    Market memory mkt = markets[u][m];
    bool matured = mature[u][m];

    if (!matured) {
      require(matureMarket(u, m), 'failed to mature the market');
    }

    // burn user's zcTokens
    require(ZcToken(mkt.zcTokenAddr).burn(t, a), 'could not burn');

    emit RedeemZcToken(u, m, t, a);

    if (!matured) {
      return a;
    } else { 
      // if the market was already mature the return should include the amount + marginal floating interest generated on Compound since maturity
      return calculateReturn(u, m, a);
    }
  }

  /// @notice Allows Vault owners (via Swivel) to redeem any currently accrued interest
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param t Address of the redeeming user
  function redeemVaultInterest(address u, uint256 m, address t) external onlySwivel(swivel) returns (uint256) {
    // call to the floating market contract to release the position and calculate the interest generated
    uint256 interest = VaultTracker(markets[u][m].vaultAddr).redeemInterest(t);

    emit RedeemVaultInterest(u, m, t);

    return interest;
  }

  /// @notice Calculates the total amount of underlying returned including interest generated since the `matureMarket` function has been called
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param a Amount of zcTokens being redeemed
  function calculateReturn(address u, uint256 m, uint256 a) internal returns (uint256) {
    // calculate difference between the cToken exchange rate @ maturity and the current cToken exchange rate
    uint256 yield = ((CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent() * 1e26) / maturityRate[u][m]) - 1e26;
    uint256 interest = (yield * a) / 1e26;

    // calculate the total amount of underlying principle to return
    return a + interest;
  }

  function cTokenAddress(address a, uint256 m) external view returns (address) {
    return markets[a][m].cTokenAddr;
  }

  /// @notice called by swivel IVFZI && IZFVI
  /// @dev call with underlying, maturity, mint-target, add-notional-target and an amount
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param z Recipient of the minted zcToken
  /// @param n Recipient of the added notional
  /// @param a Amount of zcToken minted and notional added
  function custodialInitiate(address u, uint256 m, address z, address n, uint256 a) external onlySwivel(swivel) returns (bool) {
    require(ZcToken(markets[u][m].zcTokenAddr).mint(z, a), 'mint failed');
    require(VaultTracker(markets[u][m].vaultAddr).addNotional(n, a), 'add notional failed');
    emit CustodialInitiate(u, m, z, n, a);
    return true;
  }

  /// @notice called by swivel EVFZE FF EZFVE
  /// @dev call with underlying, maturity, burn-target, remove-notional-target and an amount
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param z Owner of the zcToken to be burned
  /// @param n Target to remove notional from
  /// @param a Amount of zcToken burned and notional removed
  function custodialExit(address u, uint256 m, address z, address n, uint256 a) external onlySwivel(swivel) returns (bool) {
    require(ZcToken(markets[u][m].zcTokenAddr).burn(z, a), 'burn failed');
    require(VaultTracker(markets[u][m].vaultAddr).removeNotional(n, a), 'remove notional failed');
    emit CustodialExit(u, m, z, n, a);
    return true;
  }

  /// @notice called by swivel IZFZE, EZFZI
  /// @dev call with underlying, maturity, transfer-from, transfer-to, amount
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param f Owner of the zcToken to be burned
  /// @param t Target to be minted to
  /// @param a Amount of zcToken transfer
  function p2pZcTokenExchange(address u, uint256 m, address f, address t, uint256 a) external onlySwivel(swivel) returns (bool) {
    require(ZcToken(markets[u][m].zcTokenAddr).burn(f, a), 'zcToken burn failed');
    require(ZcToken(markets[u][m].zcTokenAddr).mint(t, a), 'zcToken mint failed');
    emit P2pZcTokenExchange(u, m, f, t, a);
    return true;
  }

  /// @notice called by swivel IVFVE, EVFVI
  /// @dev call with underlying, maturity, remove-from, add-to, amount
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param f Owner of the notional to be transferred
  /// @param t Target to be transferred to
  /// @param a Amount of notional transfer
  function p2pVaultExchange(address u, uint256 m, address f, address t, uint256 a) external onlySwivel(swivel) returns (bool) {
    require(VaultTracker(markets[u][m].vaultAddr).transferNotionalFrom(f, t, a), 'transfer notional failed');
    emit P2pVaultExchange(u, m, f, t, a);
    return true;
  }

  /// @notice External method giving access to this functionality within a given vault
  /// @dev Note that this method calculates yield and interest as well
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param t Target to be transferred to
  /// @param a Amount of notional to be transferred
  function transferVaultNotional(address u, uint256 m, address t, uint256 a) public returns (bool) {
    require(VaultTracker(markets[u][m].vaultAddr).transferNotionalFrom(msg.sender, t, a), 'vault transfer failed');
    emit TransferVaultNotional(u, m, msg.sender, t, a);
    return true;
  }

  /// @notice transfers notional fee to the Swivel contract without recalculating marginal interest for from
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param f Owner of the amount
  /// @param a Amount to transfer
  function transferVaultNotionalFee(address u, uint256 m, address f, uint256 a) public onlySwivel(swivel) returns (bool) {
    VaultTracker(markets[u][m].vaultAddr).transferNotionalFee(f, a);
    return true;
  }

  modifier onlyAdmin(address a) {
    require(msg.sender == a, 'sender must be admin');
    _;
  }

  modifier onlySwivel(address s) {
    require(msg.sender == s, 'sender must be Swivel contract');
    _;
  }
}",3072
RealWorld_BA_39_IErc2612_RealWord_20240820130148.log,39,IErc2612,12903,5715,18618,79.0,0.178815,"// SPDX-License-Identifier: GPL-3.0-or-later
// Code adapted from OpenZeppelin IERCPermit
pragma solidity 0.8.4;

/**
 * @dev Interface of the ERC2612 standard as defined in the EIP.
 *
 * Adds the {permit} method, which can be used to change one's
 * {IERC20-allowance} without having to send a transaction, by signing a
 * message. This allows users to spend tokens without having to hold Ether.
 *
 * See https://eips.ethereum.org/EIPS/eip-2612.
 */
interface IErc2612 {
    /**
     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,
     * given `owner`'s signed approval.
     * @param o The owner
     * @param spender The spender
     * @param a The amount
     * @param d The deadline
     * @param v v portion of the ECDSA
     * @param r r portion of the ECDSA
     * @param s s portion of the ECDSA
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     * - `deadline` must be a timestamp in the future.
     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
     * over the EIP712-formatted function arguments.
     * - the signature must use ``owner``'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     */
    function permit(address o, address spender, uint256 a, uint256 d, uint8 v, bytes32 r, bytes32 s) external;

    /**
     * @dev Returns the current ERC2612 nonce for `owner`. This value must be
     * @param o The owner
     *
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases ``owner``'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address o) external view returns (uint256);
}",554
RealWorld_BA_39_IErc2612_RealWord_20240820131726.log,39,IErc2612,12718,5134,17852,84.0,0.16627,"// SPDX-License-Identifier: GPL-3.0-or-later
// Code adapted from OpenZeppelin IERCPermit
pragma solidity 0.8.4;

/**
 * @dev Interface of the ERC2612 standard as defined in the EIP.
 *
 * Adds the {permit} method, which can be used to change one's
 * {IERC20-allowance} without having to send a transaction, by signing a
 * message. This allows users to spend tokens without having to hold Ether.
 *
 * See https://eips.ethereum.org/EIPS/eip-2612.
 */
interface IErc2612 {
    /**
     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,
     * given `owner`'s signed approval.
     * @param o The owner
     * @param spender The spender
     * @param a The amount
     * @param d The deadline
     * @param v v portion of the ECDSA
     * @param r r portion of the ECDSA
     * @param s s portion of the ECDSA
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     * - `deadline` must be a timestamp in the future.
     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
     * over the EIP712-formatted function arguments.
     * - the signature must use ``owner``'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     */
    function permit(address o, address spender, uint256 a, uint256 d, uint8 v, bytes32 r, bytes32 s) external;

    /**
     * @dev Returns the current ERC2612 nonce for `owner`. This value must be
     * @param o The owner
     *
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases ``owner``'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address o) external view returns (uint256);
}",554
RealWorld_BA_39_VaultTracker_RealWord_20240820125714.log,39,VaultTracker,38142,5291,43433,87.0,0.29653,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.4;

import ""./Abstracts.sol"";

contract VaultTracker {
  struct Vault {
    uint256 notional;
    uint256 redeemable;
    uint256 exchangeRate;
  }

  mapping(address => Vault) public vaults;

  address public immutable admin;
  address public immutable cTokenAddr;
  address public immutable swivel;
  bool public matured;
  uint256 public immutable maturity;
  uint256 public maturityRate;

  /// @param m Maturity timestamp of the new market
  /// @param c cToken address associated with underlying for the new market
  /// @param s address of the deployed swivel contract
  constructor(uint256 m, address c, address s) {
    admin = msg.sender;
    maturity = m;
    cTokenAddr = c;
    swivel = s;
  }

  /// @notice Adds notional (nTokens) to a given user's vault
  /// @param o Address that owns a vault
  /// @param a Amount of notional added
  function addNotional(address o, uint256 a) public onlyAdmin(admin) returns (bool) {
    uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();

    Vault memory vlt = vaults[o];

    if (vlt.notional > 0) {
      uint256 yield;
      uint256 interest;

      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate
      // otherwise, calculate marginal exchange rate between current and previous exchange rate.
      if (matured) { // Calculate marginal interest
        yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;
      } else {
        yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;
      }

      interest = (yield * vlt.notional) / 1e26;
      // add interest and amount to position, reset cToken exchange rate
      vlt.redeemable += interest;
      vlt.notional += a;
    } else {
      vlt.notional = a;
    }

    vlt.exchangeRate = exchangeRate;
    vaults[o] = vlt;

    return true;
  }

  /// @notice Removes notional (nTokens) from a given user's vault
  /// @param o Address that owns a vault
  /// @param a Amount of notional to remove
  function removeNotional(address o, uint256 a) public onlyAdmin(admin) returns (bool) {

    Vault memory vlt = vaults[o];

    require(vlt.notional >= a, ""amount exceeds vault balance"");

    uint256 yield;
    uint256 interest;
    uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();

    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate
    // otherwise, calculate marginal exchange rate between current and previous exchange rate.
    if (matured) { // Calculate marginal interest
      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;
    } else {
      // calculate marginal interest
      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;
    }

    interest = (yield * vlt.notional) / 1e26;
    // remove amount from position, Add interest to position, reset cToken exchange rate
    vlt.redeemable += interest;
    vlt.notional -= a;
    vlt.exchangeRate = exchangeRate;

    vaults[o] = vlt;

    return true;
  }

  /// @notice Redeem's the `redeemable` + marginal interest from a given user's vault
  /// @param o Address that owns a vault
  function redeemInterest(address o) external onlyAdmin(admin) returns (uint256) {

    Vault memory vlt = vaults[o];

    uint256 redeemable = vlt.redeemable;
    uint256 yield;
    uint256 interest;
    uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();

    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate
    // otherwise, calculate marginal exchange rate between current and previous exchange rate.
    if (matured) { // Calculate marginal interest
      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;
    } else {
      // calculate marginal interest
      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;
    }

    interest = (yield * vlt.notional) / 1e26;

    vlt.exchangeRate = exchangeRate;
    vlt.redeemable = 0;

    vaults[o] = vlt;

    // return adds marginal interest to previously accrued redeemable interest
    return (redeemable + interest);
  }

  /// @notice Matures the vault and sets the market's maturityRate
  function matureVault() external onlyAdmin(admin) returns (bool) {
    require(!matured, 'already matured');
    require(block.timestamp >= maturity, 'maturity has not been reached');
    matured = true;
    maturityRate = CErc20(cTokenAddr).exchangeRateCurrent();
    return true;
  }

  /// @notice Transfers notional (nTokens) from one user to another
  /// @param f Owner of the amount
  /// @param t Recipient of the amount
  /// @param a Amount to transfer
  function transferNotionalFrom(address f, address t, uint256 a) external onlyAdmin(admin) returns (bool) {
    Vault memory from = vaults[f];
    Vault memory to = vaults[t];

    require(from.notional >= a, ""amount exceeds available balance"");

    uint256 yield;
    uint256 interest;
    uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();

    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate
    // otherwise, calculate marginal exchange rate between current and previous exchange rate.
    if (matured) { 
      // calculate marginal interest
      yield = ((maturityRate * 1e26) / from.exchangeRate) - 1e26;
    } else {
      yield = ((exchangeRate * 1e26) / from.exchangeRate) - 1e26;
    }

    interest = (yield * from.notional) / 1e26;
    // remove amount from position, Add interest to position, reset cToken exchange rate
    from.redeemable += interest;
    from.notional -= a;
    from.exchangeRate = exchangeRate;

    vaults[f] = from;

    // transfer notional to address ""t"", calculate interest if necessary
    if (to.notional > 0) {
      uint256 newVaultInterest;

      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate
      // otherwise, calculate marginal exchange rate between current and previous exchange rate.
      if (matured) { 
        // calculate marginal interest
        yield = ((maturityRate * 1e26) / to.exchangeRate) - 1e26;
      } else {
        yield = ((exchangeRate * 1e26) / to.exchangeRate) - 1e26;
      }

      newVaultInterest = (yield * to.notional) / 1e26;
      // add interest and amount to position, reset cToken exchange rate
      to.redeemable += newVaultInterest;
      to.notional += a;
    } else {
      to.notional += a;
    }

    to.exchangeRate = exchangeRate;
    vaults[t] = to;

    return true;
  }

  /// @notice transfers, in notional, a fee payment to the Swivel contract without recalculating marginal interest for the owner
  /// @param f Owner of the amount
  /// @param a Amount to transfer
  function transferNotionalFee(address f, uint256 a) external onlyAdmin(admin) returns(bool) {
    Vault memory oVault = vaults[f];
    Vault memory sVault = vaults[swivel];

    // remove notional from its owner
    oVault.notional -= a;

    uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();
    uint256 yield;
    uint256 interest;

    // check if exchangeRate has been stored already this block. If not, calculate marginal interest + store exchangeRate
    if (sVault.exchangeRate != exchangeRate) {
      // the rate will be 0 if swivel did not already have a vault
      if (sVault.exchangeRate != 0) {
        // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate
        // otherwise, calculate marginal exchange rate between current and previous exchange rate.
        if (matured) { 
          // calculate marginal interest
            yield = ((maturityRate * 1e26) / sVault.exchangeRate) - 1e26;
        } else {
            yield = ((exchangeRate * 1e26) / sVault.exchangeRate) - 1e26;
        }

        interest = (yield * sVault.notional) / 1e26;
        // add interest and amount, reset cToken exchange rate
        sVault.redeemable += interest;
      }
      sVault.exchangeRate = exchangeRate;
    }

    // add notional to swivel's vault
    sVault.notional += a;

    // store the adjusted vaults
    vaults[swivel] = sVault;
    vaults[f] = oVault;
    return true;
  }

  /// @notice Returns both relevant balances for a given user's vault
  /// @param o Address that owns a vault
  function balancesOf(address o) public view returns (uint256, uint256) {
    return (vaults[o].notional, vaults[o].redeemable);
  }

  modifier onlyAdmin(address a) {
    require(msg.sender == a, 'sender must be admin');
    _;
  }
}",2186
RealWorld_BA_39_ZcToken_RealWord_20240820130014.log,39,ZcToken,9016,5284,14300,92.0,0.15076,"// SPDX-License-Identifier: MIT

// NOTE: whomever decided methods which are the implementation of a stated interface
//       need to be labeled 'override' should to be publicly flogged.

pragma solidity 0.8.4;

import './Erc2612.sol';
import './IZcToken.sol';

/// NOTE the OZStlye naming conventions are kept for the internal methods
/// _burn and _mint as dangling underscores are generally not allowed.
contract ZcToken is Erc2612, IZcToken {
  address public immutable admin;
  address public immutable underlying;
  uint256 public immutable maturity;

  /// @param u Underlying
  /// @param m Maturity
  /// @param n Name
  /// @param s Symbol
  /// @param d Decimals
  constructor(address u, uint256 m, string memory n, string memory s, uint8 d) Erc2612(n, s, d) {
    admin = msg.sender;  
    underlying = u;
    maturity = m;
  }
  
  /// @param f Address to burn from
  /// @param a Amount to burn
  function burn(address f, uint256 a) external onlyAdmin(admin) override returns(bool) {
      _burn(f, a);
      return true;
  }

  /// @param t Address recieving the minted amount
  /// @param a The amount to mint
  function mint(address t, uint256 a) external onlyAdmin(admin) override returns(bool) {
      _mint(t, a);
      return true;
  }

  /// @param a Admin address
  modifier onlyAdmin(address a) {
    require(msg.sender == a, 'sender must be admin');
    _;
  }
}",362
RealWorld_BA_39_Erc2612_RealWord_20240820130927.log,39,Erc2612,11699,5185,16884,72.0,0.162195,"// SPDX-License-Identifier: GPL-3.0-or-later
// Adapted from OpenZeppelin ERC2612 (ERC20Permit)

pragma solidity 0.8.4;

import './Hash.sol';
import './PErc20.sol';
import './IErc2612.sol';

/**
* @dev Extension of {ERC20} that allows token holders to use their tokens
* without sending any transactions by setting {IERC20-allowance} with a
* signature using the {permit} method, and then spend them via
* {IERC20-transferFrom}.
* NOTE: Naming convention is kept OZStyle vs our own OzStyle to prevent clashing
*
* The {permit} signature mechanism conforms to the {IERC2612} interface.
*/
contract Erc2612 is PErc20, IErc2612 {
  mapping (address => uint256) public override nonces;

  bytes32 public immutable domain;

  /// @param n name for the token
  /// @param s symbol for the token
  /// @param d decimals for the token
  constructor(string memory n, string memory s, uint8 d) PErc20(n, s, d) {
    domain = Hash.domain(n, '1', block.chainid, address(this));
  }

  /**
  * @dev See {IERC2612-permit}.
  *
  * In cases where the free option is not a concern, deadline can simply be
  * set to uint(-1), so it should be seen as an optional parameter
  *
  * @param o Address of the owner
  * @param spender Address of the spender
  * @param a Amount to be approved
  * @param d Deadline at which the permission is no longer valid
  * NOTE: Last three args (v, r, s) are the components of a valid ECDSA signature
  */
  function permit(address o, address spender, uint256 a, uint256 d, uint8 v, bytes32 r, bytes32 s) public virtual override {
    require(d >= block.timestamp, 'erc2612 expired deadline');

    bytes32 hashStruct = Hash.permit(o, spender, a, nonces[o]++, d);
    bytes32 hash = Hash.message(domain, hashStruct); 
    address signer = ecrecover(hash, v, r, s);

    require(signer != address(0) && signer == o, 'erc2612 invalid signature');
    _approve(o, spender, a);
  }
}",523
RealWorld_BA_39_Abstracts_RealWord_20240820132815.log,39,Abstracts,6165,5349,11514,79.0,0.137805,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.4;

abstract contract Erc20 {
	function approve(address, uint256) virtual external returns (bool);
	function transfer(address, uint256) virtual external returns (bool);
	function balanceOf(address) virtual external returns (uint256);
	function transferFrom(address, address, uint256) virtual public returns (bool);
}

abstract contract CErc20 is Erc20 {
	function mint(uint256) virtual external returns (uint256);
	function redeem(uint256) virtual external returns (uint256);
	function redeemUnderlying(uint256) virtual external returns (uint256);
	function exchangeRateCurrent() virtual external returns (uint256);
}",140
RealWorld_BA_39_Abstracts_RealWord_20240820131307.log,39,Abstracts,12088,5289,17377,87.0,0.16622,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.4;

abstract contract Erc20 {
	function approve(address, uint256) virtual external returns (bool);
	function transfer(address, uint256) virtual external returns (bool);
	function balanceOf(address) virtual external returns (uint256);
	function transferFrom(address, address, uint256) virtual public returns (bool);
}

abstract contract CErc20 is Erc20 {
	function mint(uint256) virtual external returns (uint256);
	function redeem(uint256) virtual external returns (uint256);
	function redeemUnderlying(uint256) virtual external returns (uint256);
	function exchangeRateCurrent() virtual external returns (uint256);
}

abstract contract MarketPlace {
  // adds notional and mints zctokens
  function mintZcTokenAddingNotional(address, uint256, address, uint256) virtual external returns (bool);
  // removes notional and burns zctokens
  function burnZcTokenRemovingNotional(address, uint256, address, uint256) virtual external returns (bool);
  // returns the amount of underlying principal to send
  function redeemZcToken(address, uint256, address, uint256) virtual external returns (uint256);
  // returns the amount of underlying interest to send
  function redeemVaultInterest(address, uint256, address) virtual external returns (uint256);
  // returns the cToken address for a given market
  function cTokenAddress(address, uint256) virtual external returns (address);
  // EVFZE FF EZFVE call this which would then burn zctoken and remove notional
  function custodialExit(address, uint256, address, address, uint256) virtual external returns (bool);
  // IVFZI && IZFVI call this which would then mint zctoken and add notional
  function custodialInitiate(address, uint256, address, address, uint256) virtual external returns (bool);
  // IZFZE && EZFZI call this, tranferring zctoken from one party to another
  function p2pZcTokenExchange(address, uint256, address, address, uint256) virtual external returns (bool);
  // IVFVE && EVFVI call this, removing notional from one party and adding to the other
  function p2pVaultExchange(address, uint256, address, address, uint256) virtual external returns (bool);
  // IVFZI && IVFVE call this which then transfers notional from msg.sender (taker) to swivel
  function transferVaultNotionalFee(address, uint256, address, uint256) virtual external returns (bool);
}",557
RealWorld_BA_39_VaultTracker_RealWord_20240820132518.log,39,VaultTracker,38076,4967,43043,80.0,0.28972,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.4;

import ""./Abstracts.sol"";

contract VaultTracker {
  struct Vault {
    uint256 notional;
    uint256 redeemable;
    uint256 exchangeRate;
  }

  mapping(address => Vault) public vaults;

  address public immutable admin;
  address public immutable cTokenAddr;
  address public immutable swivel;
  bool public matured;
  uint256 public immutable maturity;
  uint256 public maturityRate;

  /// @param m Maturity timestamp of the new market
  /// @param c cToken address associated with underlying for the new market
  /// @param s address of the deployed swivel contract
  constructor(uint256 m, address c, address s) {
    admin = msg.sender;
    maturity = m;
    cTokenAddr = c;
    swivel = s;
  }

  /// @notice Adds notional (nTokens) to a given user's vault
  /// @param o Address that owns a vault
  /// @param a Amount of notional added
  function addNotional(address o, uint256 a) public onlyAdmin(admin) returns (bool) {
    uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();

    Vault memory vlt = vaults[o];

    if (vlt.notional > 0) {
      uint256 yield;
      uint256 interest;

      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate
      // otherwise, calculate marginal exchange rate between current and previous exchange rate.
      if (matured) { // Calculate marginal interest
        yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;
      } else {
        yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;
      }

      interest = (yield * vlt.notional) / 1e26;
      // add interest and amount to position, reset cToken exchange rate
      vlt.redeemable += interest;
      vlt.notional += a;
    } else {
      vlt.notional = a;
    }

    vlt.exchangeRate = exchangeRate;
    vaults[o] = vlt;

    return true;
  }

  /// @notice Removes notional (nTokens) from a given user's vault
  /// @param o Address that owns a vault
  /// @param a Amount of notional to remove
  function removeNotional(address o, uint256 a) public onlyAdmin(admin) returns (bool) {

    Vault memory vlt = vaults[o];

    require(vlt.notional >= a, ""amount exceeds vault balance"");

    uint256 yield;
    uint256 interest;
    uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();

    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate
    // otherwise, calculate marginal exchange rate between current and previous exchange rate.
    if (matured) { // Calculate marginal interest
      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;
    } else {
      // calculate marginal interest
      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;
    }

    interest = (yield * vlt.notional) / 1e26;
    // remove amount from position, Add interest to position, reset cToken exchange rate
    vlt.redeemable += interest;
    vlt.notional -= a;
    vlt.exchangeRate = exchangeRate;

    vaults[o] = vlt;

    return true;
  }

  /// @notice Redeem's the `redeemable` + marginal interest from a given user's vault
  /// @param o Address that owns a vault
  function redeemInterest(address o) external onlyAdmin(admin) returns (uint256) {

    Vault memory vlt = vaults[o];

    uint256 redeemable = vlt.redeemable;
    uint256 yield;
    uint256 interest;
    uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();

    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate
    // otherwise, calculate marginal exchange rate between current and previous exchange rate.
    if (matured) { // Calculate marginal interest
      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;
    } else {
      // calculate marginal interest
      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;
    }

    interest = (yield * vlt.notional) / 1e26;

    vlt.exchangeRate = exchangeRate;
    vlt.redeemable = 0;

    vaults[o] = vlt;

    // return adds marginal interest to previously accrued redeemable interest
    return (redeemable + interest);
  }

  /// @notice Matures the vault and sets the market's maturityRate
  function matureVault() external onlyAdmin(admin) returns (bool) {
    require(!matured, 'already matured');
    require(block.timestamp >= maturity, 'maturity has not been reached');
    matured = true;
    maturityRate = CErc20(cTokenAddr).exchangeRateCurrent();
    return true;
  }

  /// @notice Transfers notional (nTokens) from one user to another
  /// @param f Owner of the amount
  /// @param t Recipient of the amount
  /// @param a Amount to transfer
  function transferNotionalFrom(address f, address t, uint256 a) external onlyAdmin(admin) returns (bool) {
    Vault memory from = vaults[f];
    Vault memory to = vaults[t];

    require(from.notional >= a, ""amount exceeds available balance"");

    uint256 yield;
    uint256 interest;
    uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();

    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate
    // otherwise, calculate marginal exchange rate between current and previous exchange rate.
    if (matured) { 
      // calculate marginal interest
      yield = ((maturityRate * 1e26) / from.exchangeRate) - 1e26;
    } else {
      yield = ((exchangeRate * 1e26) / from.exchangeRate) - 1e26;
    }

    interest = (yield * from.notional) / 1e26;
    // remove amount from position, Add interest to position, reset cToken exchange rate
    from.redeemable += interest;
    from.notional -= a;
    from.exchangeRate = exchangeRate;

    vaults[f] = from;

    // transfer notional to address ""t"", calculate interest if necessary
    if (to.notional > 0) {
      uint256 newVaultInterest;

      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate
      // otherwise, calculate marginal exchange rate between current and previous exchange rate.
      if (matured) { 
        // calculate marginal interest
        yield = ((maturityRate * 1e26) / to.exchangeRate) - 1e26;
      } else {
        yield = ((exchangeRate * 1e26) / to.exchangeRate) - 1e26;
      }

      newVaultInterest = (yield * to.notional) / 1e26;
      // add interest and amount to position, reset cToken exchange rate
      to.redeemable += newVaultInterest;
      to.notional += a;
    } else {
      to.notional += a;
    }

    to.exchangeRate = exchangeRate;
    vaults[t] = to;

    return true;
  }

  /// @notice transfers, in notional, a fee payment to the Swivel contract without recalculating marginal interest for the owner
  /// @param f Owner of the amount
  /// @param a Amount to transfer
  function transferNotionalFee(address f, uint256 a) external onlyAdmin(admin) returns(bool) {
    Vault memory oVault = vaults[f];
    Vault memory sVault = vaults[swivel];

    // remove notional from its owner
    oVault.notional -= a;

    uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();
    uint256 yield;
    uint256 interest;

    // check if exchangeRate has been stored already this block. If not, calculate marginal interest + store exchangeRate
    if (sVault.exchangeRate != exchangeRate) {
      // the rate will be 0 if swivel did not already have a vault
      if (sVault.exchangeRate != 0) {
        // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate
        // otherwise, calculate marginal exchange rate between current and previous exchange rate.
        if (matured) { 
          // calculate marginal interest
            yield = ((maturityRate * 1e26) / sVault.exchangeRate) - 1e26;
        } else {
            yield = ((exchangeRate * 1e26) / sVault.exchangeRate) - 1e26;
        }

        interest = (yield * sVault.notional) / 1e26;
        // add interest and amount, reset cToken exchange rate
        sVault.redeemable += interest;
      }
      sVault.exchangeRate = exchangeRate;
    }

    // add notional to swivel's vault
    sVault.notional += a;

    // store the adjusted vaults
    vaults[swivel] = sVault;
    vaults[f] = oVault;
    return true;
  }

  /// @notice Returns both relevant balances for a given user's vault
  /// @param o Address that owns a vault
  function balancesOf(address o) public view returns (uint256, uint256) {
    return (vaults[o].notional, vaults[o].redeemable);
  }

  modifier onlyAdmin(address a) {
    require(msg.sender == a, 'sender must be admin');
    _;
  }
}",2186
RealWorld_BA_39_IZcToken_RealWord_20240820130704.log,39,IZcToken,4676,4738,9414,69.0,0.11814,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.4;

import ""./IPErc20.sol"";

/**
 * @dev Mint and burn interface for the ZCToken
 *
 */
interface IZcToken is IPErc20 {
    /**
     * @dev Mints...
     */
    function mint(address, uint256) external returns(bool);

    /**
     * @dev Burns...
     */
    function burn(address, uint256) external returns(bool);
}",97
RealWorld_BA_39_Swivel_RealWord_20240820131436.log,39,Swivel,101048,5675,106723,87.0,0.61874,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.4;

import './Abstracts.sol';
import './Hash.sol';
import './Sig.sol';

contract Swivel {
  /// @dev maps the key of an order to a boolean indicating if an order was cancelled
  mapping (bytes32 => bool) public cancelled;
  /// @dev maps the key of an order to an amount representing its taken volume
  mapping (bytes32 => uint256) public filled;
  /// @dev maps a token address to a point in time, a hold, after which a withdrawal can be made
  mapping (address => uint256) public withdrawals;

  string constant public NAME = 'Swivel Finance';
  string constant public VERSION = '2.0.0';
  uint256 constant public HOLD = 259200; // obvs could be a smaller uint but packing?
  bytes32 public immutable domain;
  address public immutable marketPlace;
  address public immutable admin;
  /// @dev holds the fee demoninators for [zcTokenInitiate, zcTokenExit, vaultInitiate, vaultExit]
  uint16[] public fenominator;

  /// @notice Emitted on order cancellation
  event Cancel (bytes32 indexed key, bytes32 hash);
  /// @notice Emitted on any initiate*
  /// @dev filled is 'principalFilled' when (vault:false, exit:false) && (vault:true, exit:true)
  /// @dev filled is 'premiumFilled' when (vault:true, exit:false) && (vault:false, exit:true)
  event Initiate(bytes32 indexed key, bytes32 hash, address indexed maker, bool vault, bool exit, address indexed sender, uint256 amount, uint256 filled);
  /// @notice Emitted on any exit*
  /// @dev filled is 'principalFilled' when (vault:false, exit:false) && (vault:true, exit:true)
  /// @dev filled is 'premiumFilled' when (vault:true, exit:false) && (vault:false, exit:true)
  event Exit(bytes32 indexed key, bytes32 hash, address indexed maker, bool vault, bool exit, address indexed sender, uint256 amount, uint256 filled);
  /// @notice Emitted on token withdrawal scheduling
  /// @dev token is the address of the token scheduled for withdrawal
  /// @dev withdrawalTime is the timestamp at which the queued withdrawal will be possible
  event WithdrawalScheduled (address indexed token, uint256 hold);

  /// @param m deployed MarketPlace contract address
  constructor(address m) {
    admin = msg.sender;
    domain = Hash.domain(NAME, VERSION, block.chainid, address(this));
    marketPlace = m;
    fenominator = [200, 600, 400, 200];
  }

  // ********* INITIATING *************

  /// @notice Allows a user to initiate a position
  /// @param o Array of offline Swivel.Orders
  /// @param a Array of order volume (principal) amounts relative to passed orders
  /// @param c Array of Components from valid ECDSA signatures
  function initiate(Hash.Order[] calldata o, uint256[] calldata a, Sig.Components[] calldata c) external returns (bool) {
    // for each order filled, routes the order to the right interaction depending on its params
    for (uint256 i=0; i < o.length; i++) {
      // If the order filled is NOT an exit
      if (!o[i].exit) {
        // if the order filled does NOT involve a vault (nTokens)
        if (!o[i].vault) {
          // then the user has called `initiate` against a zcToken initiate and msg.sender is initiating a vault (purchasing nTokens, payingPremium)
          initiateVaultFillingZcTokenInitiate(o[i], a[i], c[i]);
        } else {
          // then the user has called `initiate` against a vault initiate and msg.sender is initiating a zcToken position (splitting and selling nTokens, receivingPremium)
          initiateZcTokenFillingVaultInitiate(o[i], a[i], c[i]);
        }
      } else {
        if (!o[i].vault) {
          // then the user has called `initiate` against a zcToken exit and msg.sender is initiating a zcToken position (splitting and selling nTokens, receivingPremium)
          initiateZcTokenFillingZcTokenExit(o[i], a[i], c[i]);
        } else {
          // then the user has called `initiate` against a vault exit (selling nTokens) and msg.sender is initiating a vault (purchasing nTokens, payingPremium)
          initiateVaultFillingVaultExit(o[i], a[i], c[i]);
        }
      }
    }

    return true;
  }

  /// @notice Allows a user to initiate a Vault by filling an offline zcToken initiate order
  /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.custodialInitiate
  /// @param o Order being filled
  /// @param a Amount of volume (premium) being filled by the taker's exit
  /// @param c Components of a valid ECDSA signature
  function initiateVaultFillingZcTokenInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {
    // checks order signature, order cancellation and order expiry
    bytes32 hash = validOrderHash(o, c);

    // checks the taker amount passed to amount available in the order
    require(a <= (o.premium - filled[hash]), 'taker amount > available volume');
    
    // adds the taker amount to the order's filled amount
    filled[hash] += a;

    // calculate principal filled and fee
    uint256 principalFilled = (((a * 1e18) / o.premium) * o.principal) / 1e18;
    uint256 fee = ((principalFilled * 1e18) / fenominator[2]) / 1e18;

    // transfer underlying tokens
    Erc20 uToken = Erc20(o.underlying);
    uToken.transferFrom(msg.sender, o.maker, a);
    uToken.transferFrom(o.maker, address(this), principalFilled);

    // deposit underlying to Compound and mint cTokens
    MarketPlace mPlace = MarketPlace(marketPlace);
    address cTokenAddr = mPlace.cTokenAddress(o.underlying, o.maturity);
    uToken.approve(cTokenAddr, principalFilled); 
    require(CErc20(cTokenAddr).mint(principalFilled) == 0, 'minting CToken failed');

    // mint <principalFilled> zcTokens + nTokens and allocate appropriately in marketplace
    require(mPlace.custodialInitiate(o.underlying, o.maturity, o.maker, msg.sender, principalFilled), 'custodial initiate failed');

    // transfer fee in vault notional to swivel (from msg.sender)
    require(mPlace.transferVaultNotionalFee(o.underlying, o.maturity, msg.sender, fee), ""notional fee transfer failed"");

    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);
  }

  /// @notice Allows a user to initiate a zcToken by filling an offline vault initiate order
  /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.custodialInitiate
  /// @param o Order being filled
  /// @param o Amount of volume (principal) being filled by the taker's exit
  /// @param c Components of a valid ECDSA signature
  function initiateZcTokenFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {
    bytes32 hash = validOrderHash(o, c);

    require((a <= o.principal - filled[hash]), 'taker amount > available volume');

    filled[hash] += a;

    uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;
    uint256 fee = ((premiumFilled * 1e18) / fenominator[0]) / 1e18;

    Erc20 uToken = Erc20(o.underlying);
    uToken.transferFrom(o.maker, msg.sender, premiumFilled);
    // transfer principal + fee in underlying to swivel (from sender)
    uToken.transferFrom(msg.sender, address(this), (a + fee));

    // deposit underlying to Compound and mint cTokens
    MarketPlace mPlace = MarketPlace(marketPlace);
    address cTokenAddr = mPlace.cTokenAddress(o.underlying, o.maturity);
    uToken.approve(cTokenAddr, a);
    require(CErc20(cTokenAddr).mint(a) == 0, 'minting CToken Failed');
    
    // mint <a> zcTokens + nTokens and allocate appropriately in marketplace
    require(mPlace.custodialInitiate(o.underlying, o.maturity, msg.sender, o.maker, a), 'custodial initiate failed');

    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);
  }

  /// @notice Allows a user to initiate zcToken? by filling an offline zcToken exit order
  /// @dev This method should pass (underlying, maturity, maker, sender, a) to MarketPlace.p2pZcTokenExchange
  /// @param o Order being filled
  /// @param a Amount of volume (principal) being filled by the taker's exit
  /// @param c Components of a valid ECDSA signature
  function initiateZcTokenFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {
    bytes32 hash = validOrderHash(o, c);

    require(a <= ((o.principal - filled[hash])), 'taker amount > available volume');

    filled[hash] += a;

    uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;
    uint256 fee = ((premiumFilled * 1e18) / fenominator[0]) / 1e18;

    // transfer underlying tokens - the premium paid + fee in underlying to swivel (from sender)
    Erc20(o.underlying).transferFrom(msg.sender, o.maker, ((a - premiumFilled) + fee));
    // transfer <a> zcTokens between users in marketplace
    require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), 'zcToken exchange failed');
            
    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);
  }

  /// @notice Allows a user to initiate a Vault by filling an offline vault exit order
  /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.p2pVaultExchange
  /// @param o Order being filled
  /// @param a Amount of volume (interest) being filled by the taker's exit
  /// @param c Components of a valid ECDSA signature
  function initiateVaultFillingVaultExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {
    bytes32 hash = validOrderHash(o, c);

    require(a <= (o.premium - filled[hash]), 'taker amount > available volume');

    filled[hash] += a;

    uint256 principalFilled = (((a * 1e18) / o.premium) * o.principal) / 1e18;
    uint256 fee = ((principalFilled * 1e18) / fenominator[2]) / 1e18;

    Erc20(o.underlying).transferFrom(msg.sender, o.maker, a);

    MarketPlace mPlace = MarketPlace(marketPlace);
    // transfer <principalFilled> vault.notional (nTokens) between users in marketplace
    require(mPlace.p2pVaultExchange(o.underlying, o.maturity, o.maker, msg.sender, principalFilled), 'vault exchange failed');

    // transfer fee (in nTokens) to swivel
    require(mPlace.transferVaultNotionalFee(o.underlying, o.maturity, msg.sender, fee), ""notional fee transfer failed"");

    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);
  }

  // ********* EXITING ***************

  /// @notice Allows a user to exit (sell) a currently held position to the marketplace.
  /// @param o Array of offline Swivel.Orders
  /// @param a Array of order volume (principal) amounts relative to passed orders
  /// @param c Components of a valid ECDSA signature
  function exit(Hash.Order[] calldata o, uint256[] calldata a, Sig.Components[] calldata c) external returns (bool) {
    // for each order filled, routes the order to the right interaction depending on its params
    for (uint256 i=0; i < o.length; i++) {
      // if the order is NOT an exit
      if (!o[i].exit) {
        // if the order filled does NOT involve a vault (nTokens)
          if (!o[i].vault) {
            // then the user has called `exit` against a zcToken initiate and msg.sender is exiting zcTokens (buying nTokens + redeeming, payingPremium)
            exitZcTokenFillingZcTokenInitiate(o[i], a[i], c[i]);
          } else {
            // then the user has called `exit` against a vault initiate and msg.sender is exiting nTokens (selling nTokens, receivingPremium)
            exitVaultFillingVaultInitiate(o[i], a[i], c[i]);
          }
      } else {
        if (!o[i].vault) {
           // then the user has called `exit` against a zcToken exit and msg.sender is exiting nTokens (selling nTokens, receivingPremium)
          exitVaultFillingZcTokenExit(o[i], a[i], c[i]);
        } else {
           // then the user has called `exit` against a vault exit and msg.sender is exiting zcTokens (buying nTokens + redeeming, payingPremium)
          exitZcTokenFillingVaultExit(o[i], a[i], c[i]);
        }   
      }   
    }

    return true;
  }

  /// @notice Allows a user to exit their zcTokens by filling an offline zcToken initiate order
  /// @dev This method should pass (underlying, maturity, sender, maker, principalFilled) to MarketPlace.p2pZcTokenExchange
  /// @param o Order being filled
  /// @param a Amount of volume (interest) being filled by the taker's exit
  /// @param c Components of a valid ECDSA signature
  function exitZcTokenFillingZcTokenInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {
    bytes32 hash = validOrderHash(o, c);

    require(a <= (o.premium - filled[hash]), 'taker amount > available volume');

    filled[hash] += a;       

    uint256 principalFilled = (((a * 1e18) / o.premium) * o.principal) / 1e18;
    uint256 fee = ((principalFilled * 1e18) / fenominator[1]) / 1e18;

    Erc20 uToken = Erc20(o.underlying);
    // transfer underlying from initiating party to exiting party, minus the price the exit party pays for the exit (premium), and the fee.
    uToken.transferFrom(o.maker, msg.sender, principalFilled - a - fee);
    // transfer fee in underlying to swivel
    uToken.transferFrom(o.maker, address(this), fee);

    // transfer <principalFilled> zcTokens from msg.sender to o.maker
    require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, msg.sender, o.maker, principalFilled), 'zcToken exchange failed');
    
    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);
  }
  
  /// @notice Allows a user to exit their Vault by filling an offline vault initiate order
  /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.p2pVaultExchange
  /// @param o Order being filled
  /// @param a Amount of volume (principal) being filled by the taker's exit
  /// @param c Components of a valid ECDSA signature
  function exitVaultFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {
    bytes32 hash = validOrderHash(o, c);

    require(a <= (o.principal - filled[hash]), 'taker amount > available volume');
    
    filled[hash] += a;
        
    uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;
    uint256 fee = ((premiumFilled * 1e18) / fenominator[3]) / 1e18;

    Erc20 uToken = Erc20(o.underlying);
    // transfer premium minus fee from maker to sender
    uToken.transferFrom(o.maker, msg.sender, premiumFilled - fee);

    // transfer fee in underlying to swivel from sender
    uToken.transferFrom(msg.sender, address(this), fee);

    // transfer <a> vault.notional (nTokens) from sender to maker
    require(MarketPlace(marketPlace).p2pVaultExchange(o.underlying, o.maturity, msg.sender, o.maker, a), 'vault exchange failed');

    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);
  }

  /// @notice Allows a user to exit their Vault filling an offline zcToken exit order
  /// @dev This method should pass (underlying, maturity, maker, sender, a) to MarketPlace.exitFillingExit
  /// @param o Order being filled
  /// @param a Amount of volume (principal) being filled by the taker's exit
  /// @param c Components of a valid ECDSA signature
  function exitVaultFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {
    bytes32 hash = validOrderHash(o, c);

    require(a <= (o.principal - filled[hash]), 'taker amount > available volume');
    
    filled[hash] += a;

    uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;
    uint256 fee = ((premiumFilled * 1e18) / fenominator[3]) / 1e18;
    
    // redeem underlying on Compound and burn cTokens
    MarketPlace mPlace = MarketPlace(marketPlace);
    address cTokenAddr = mPlace.cTokenAddress(o.underlying, o.maturity);
    require((CErc20(cTokenAddr).redeemUnderlying(a) == 0), ""compound redemption error"");

    Erc20 uToken = Erc20(o.underlying);
    // transfer principal-premium  back to fixed exit party now that the interest coupon and zcb have been redeemed
    uToken.transfer(o.maker, a - premiumFilled);
    // transfer premium-fee to floating exit party
    uToken.transfer(msg.sender, premiumFilled - fee);

    // burn zcTokens + nTokens from o.maker and msg.sender respectively
    require(mPlace.custodialExit(o.underlying, o.maturity, o.maker, msg.sender, a), 'custodial exit failed');


    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);
  }

  /// @notice Allows a user to exit their zcTokens by filling an offline vault exit order
  /// @dev This method should pass (underlying, maturity, sender, maker, principalFilled) to MarketPlace.exitFillingExit
  /// @param o Order being filled
  /// @param a Amount of volume (interest) being filled by the taker's exit
  /// @param c Components of a valid ECDSA signature
  function exitZcTokenFillingVaultExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {
    bytes32 hash = validOrderHash(o, c);

    require(a <= (o.premium - filled[hash]), 'taker amount > available volume');
    
    filled[hash] += a;

    uint256 principalFilled = (((a * 1e18) / o.premium) * o.principal) / 1e18;
    uint256 fee = ((principalFilled * 1e18) / fenominator[1]) / 1e18;

    // redeem underlying on Compound and burn cTokens
    MarketPlace mPlace = MarketPlace(marketPlace);
    address cTokenAddr = mPlace.cTokenAddress(o.underlying, o.maturity);
    require((CErc20(cTokenAddr).redeemUnderlying(principalFilled) == 0), ""compound redemption error"");

    Erc20 uToken = Erc20(o.underlying);
    // transfer principal-premium-fee back to fixed exit party now that the interest coupon and zcb have been redeemed
    uToken.transfer(msg.sender, principalFilled - a - fee);
    uToken.transfer(o.maker, a);

    // burn <principalFilled> zcTokens + nTokens from msg.sender and o.maker respectively
    require(mPlace.custodialExit(o.underlying, o.maturity, msg.sender, o.maker, principalFilled), 'custodial exit failed');

    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);
  }

  /// @notice Allows a user to cancel an order, preventing it from being filled in the future
  /// @param o Order being cancelled
  /// @param c Components of a valid ECDSA signature
  function cancel(Hash.Order calldata o, Sig.Components calldata c) external returns (bool) {
    bytes32 hash = validOrderHash(o, c);

    require(msg.sender == o.maker, 'sender must be maker');

    cancelled[hash] = true;

    emit Cancel(o.key, hash);

    return true;
  }

  // ********* ADMINISTRATIVE ***************

  /// @notice Allows the admin to schedule the withdrawal of tokens
  /// @param e Address of token to withdraw
  function scheduleWithdrawal(address e) external onlyAdmin(admin) {
    uint256 when = block.timestamp + HOLD;
    withdrawals[e] = when;
    emit WithdrawalScheduled(e, when);
  }

  /// @notice Emergency function to block unplanned withdrawals
  /// @param e Address of token withdrawal to block
  function blockWithdrawal(address e) external onlyAdmin(admin) {
      withdrawals[e] = 0;
  }

  /// @notice Allows the admin to withdraw the given token, provided the holding period has been observed
  /// @param e Address of token to withdraw
  function withdraw(address e) external onlyAdmin(admin) {
    uint256 when = withdrawals[e];
    require (when != 0, 'no withdrawal scheduled');
    require (block.timestamp >= when, 'withdrawal still on hold');

    withdrawals[e] = 0;

    Erc20 token = Erc20(e);
    token.transfer(admin, token.balanceOf(address(this)));
  }

  /// @notice Allows the admin to set a new fee denominator
  /// @param t The index of the new fee denominator
  /// @param d The new fee denominator
  function setFee(uint16 t, uint16 d) external onlyAdmin(admin) returns (bool) {
    fenominator[t] = d;
    return true;
  }

  // ********* PROTOCOL UTILITY ***************

  /// @notice Allows users to deposit underlying and in the process split it into/mint 
  /// zcTokens and vault notional. Calls mPlace.mintZcTokenAddingNotional
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param a Amount of underlying being deposited
  function splitUnderlying(address u, uint256 m, uint256 a) external returns (bool) {
    Erc20 uToken = Erc20(u);
    uToken.transferFrom(msg.sender, address(this), a);
    MarketPlace mPlace = MarketPlace(marketPlace);
    address cTokenAddr = mPlace.cTokenAddress(u, m);
    uToken.approve(cTokenAddr, a);
    require(CErc20(cTokenAddr).mint(a) == 0, 'minting CToken Failed');
    require(mPlace.mintZcTokenAddingNotional(u, m, msg.sender, a), 'mint ZcToken adding Notional failed');

    return true;
  }

  /// @notice Allows users deposit/burn 1-1 amounts of both zcTokens and vault notional,
  /// in the process ""combining"" the two, and redeeming underlying. Calls mPlace.burnZcTokenRemovingNotional.
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param a Amount of zcTokens being redeemed
  function combineTokens(address u, uint256 m, uint256 a) external returns (bool) {
    MarketPlace mPlace = MarketPlace(marketPlace);
    require(mPlace.burnZcTokenRemovingNotional(u, m, msg.sender, a), 'burn ZcToken removing Notional failed');
    address cTokenAddr = mPlace.cTokenAddress(u, m);
    require((CErc20(cTokenAddr).redeemUnderlying(a) == 0), ""compound redemption error"");
    Erc20(u).transfer(msg.sender, a);

    return true;
  }

  /// @notice Allows zcToken holders to redeem their tokens for underlying tokens after maturity has been reached (via MarketPlace).
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param a Amount of zcTokens being redeemed
  function redeemZcToken(address u, uint256 m, uint256 a) external returns (bool) {
    MarketPlace mPlace = MarketPlace(marketPlace);
    // call marketplace to determine the amount redeemed
    uint256 redeemed = mPlace.redeemZcToken(u, m, msg.sender, a);
    // redeem underlying from compound
    require(CErc20(mPlace.cTokenAddress(u, m)).redeemUnderlying(redeemed) == 0, 'compound redemption failed');
    // transfer underlying back to msg.sender
    Erc20(u).transfer(msg.sender, redeemed);

    return true;
  }

  /// @notice Allows Vault owners to redeem any currently accrued interest (via MarketPlace)
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  function redeemVaultInterest(address u, uint256 m) external returns (bool) {
    MarketPlace mPlace = MarketPlace(marketPlace);
    // call marketplace to determine the amount redeemed
    uint256 redeemed = mPlace.redeemVaultInterest(u, m, msg.sender);
    // redeem underlying from compound
    require(CErc20(mPlace.cTokenAddress(u, m)).redeemUnderlying(redeemed) == 0, 'compound redemption failed');
    // transfer underlying back to msg.sender
    Erc20(u).transfer(msg.sender, redeemed);

    return true;
  }

  /// @notice Varifies the validity of an order and it's signature.
  /// @param o An offline Swivel.Order
  /// @param c Components of a valid ECDSA signature
  /// @return the hashed order.
  function validOrderHash(Hash.Order calldata o, Sig.Components calldata c) internal view returns (bytes32) {
    bytes32 hash = Hash.order(o);

    require(!cancelled[hash], 'order cancelled');
    require(o.expiry >= block.timestamp, 'order expired');
    require(o.maker == Sig.recover(Hash.message(domain, hash), c), 'invalid signature');

    return hash;
  }

  modifier onlyAdmin(address a) {
    require(msg.sender == a, 'sender must be admin');
    _;
  }
}",6160
RealWorld_BA_39_Abstracts_RealWord_20240820125843.log,39,Abstracts,5014,5363,10377,89.0,0.13233,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.4;

abstract contract Erc20 {
	function approve(address, uint256) virtual external returns (bool);
	function transfer(address, uint256) virtual external returns (bool);
	function balanceOf(address) virtual external returns (uint256);
	function transferFrom(address, address, uint256) virtual public returns (bool);
}

abstract contract CErc20 is Erc20 {
	function mint(uint256) virtual external returns (uint256);
	function redeem(uint256) virtual external returns (uint256);
	function redeemUnderlying(uint256) virtual external returns (uint256);
	function exchangeRateCurrent() virtual external returns (uint256);
}",140
RealWorld_BA_39_CErc20_RealWord_20240820123524.log,39,CErc20,9486,4552,14038,71.0,0.13847,"// SPDX-License-Identifier: UNLICENSED

/**
  CErc20 is a mock compound token with stubs of the methods we need for testing.
*/

pragma solidity 0.8.4;

// TODO this could inherit from the ERC20 mock if needed
contract CErc20 {
  /// @dev allows us to dictate return from mint().
  uint256 private mintReturn;
  /// @dev the last amount mint was called with
  uint256 public mintCalled;

  /// @dev allows us to dictate return from redeem().
  uint256 private redeemReturn;
  /// @dev the last amount redeem was called with
  uint256 public redeemCalled;

  /// @dev allows us to dictate return from redeemUnderlying().
  uint256 private redeemUnderlyingReturn;
  /// @dev the last amount redeemUnderlying was called with
  uint256 public redeemUnderlyingCalled;

  /// @dev allows us to dictate return from exchangeRateCurrent().
  uint256 private exchangeRateCurrentReturn;

  function mint(uint256 n) public returns (uint256) {
    mintCalled = n;
    return mintReturn;
  }

  function mintReturns(uint256 n) public {
    mintReturn = n;
  }

  function redeem(uint256 n) public returns (uint256) {
    redeemCalled = n;
    return redeemReturn;
  }

  function redeemReturns(uint256 n) public {
    redeemReturn = n;
  }

  function redeemUnderlying(uint256 n) public returns (uint256) {
    redeemUnderlyingCalled = n;
    return redeemUnderlyingReturn;
  }

  function redeemUnderlyingReturns(uint256 n) public {
    redeemUnderlyingReturn = n;
  }

  function exchangeRateCurrent() public view returns (uint256) {
    return exchangeRateCurrentReturn;
  }

  function exchangeRateCurrentReturns(uint256 n) public {
    exchangeRateCurrentReturn = n;
  }

}",394
RealWorld_BA_39_IPErc20_RealWord_20240820132234.log,39,IPErc20,14313,4973,19286,94.0,0.171025,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.4;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IPErc20 {
    /**
     * @dev Returns the amount of tokens owned by `account`.
     * @param a Adress to fetch balance of
     */
    function balanceOf(address a) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     * @param r The recipient
     * @param a The amount transferred
     *
     * Emits a {Transfer} event.
     */
    function transfer(address r, uint256 a) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     * @param o The owner
     * @param s The spender
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address o, address s) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param s The spender
     * @param a The amount to approve
     *
     * Emits an {Approval} event.
     */
    function approve(address s, uint256 a) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     * @param s The sender
     * @param r The recipient
     * @param a The amount to transfer
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address s, address r, uint256 a) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",659
RealWorld_BA_39_Hash_RealWord_20240820131852.log,39,Hash,15318,5052,20370,67.0,0.17763,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.4;

/**
  @notice Encapsulation of the logic to produce EIP712 hashed domain and messages.
  Also to produce / verify hashed and signed Permits.
*/

library Hash {
  // EIP712 Domain Separator typeHash
  // keccak256(abi.encodePacked(
  //     'EIP712Domain(',
  //     'string name,',
  //     'string version,',
  //     'uint256 chainId,',
  //     'address verifyingContract',
  //     ')'
  // ));
  bytes32 constant internal DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;

  // EIP2612 typeHash of a Permit
  // keccak256(abi.encodePacked(
  //     'Permit(',
  //     'address owner,',
  //     'address spender,',
  //     'uint256 value,',
  //     'uint256 nonce,',
  //     'uint256 deadline,',
  //     ')'
  // ));
  bytes32 constant internal PERMIT_TYPEHASH = 0x80772249b4aef1688b30651778f4249b05cb73b517d98482439b9d8999b30602;

  /// @param n EIP712 domain name
  /// @param version EIP712 semantic version string
  /// @param i Chain ID
  /// @param verifier address of the verifying contract
  function domain(string memory n, string memory version, uint256 i, address verifier) internal pure returns (bytes32) {
    bytes32 hash;

    assembly {
      let nameHash := keccak256(add(n, 32), mload(n))
      let versionHash := keccak256(add(version, 32), mload(version))
      let pointer := mload(64)
      mstore(pointer, DOMAIN_TYPEHASH)
      mstore(add(pointer, 32), nameHash)
      mstore(add(pointer, 64), versionHash)
      mstore(add(pointer, 96), i)
      mstore(add(pointer, 128), verifier)
      hash := keccak256(pointer, 160)
    }

    return hash;
  }

  /// @param d Type hash of the domain separator (see Hash.domain)
  /// @param h EIP712 hash struct (Permit for example)
  function message(bytes32 d, bytes32 h) internal pure returns (bytes32) {
    bytes32 hash;

    assembly {
      let pointer := mload(64)
      mstore(pointer, 0x1901000000000000000000000000000000000000000000000000000000000000)
      mstore(add(pointer, 2), d)
      mstore(add(pointer, 34), h)
      hash := keccak256(pointer, 66)
    }

    return hash;
  }

  /// @param o Address of the owner
  /// @param s Address of the spender
  /// @param a Amount to be approved
  /// @param n Current nonce
  /// @param d Deadline at which the permission is no longer valid
  function permit(address o, address s, uint256 a, uint256 n, uint256 d) internal pure returns (bytes32) {
    return keccak256(abi.encode(PERMIT_TYPEHASH, o, s, a, n, d));
  }
}",751
RealWorld_BA_39_Hash_RealWord_20240820130423.log,39,Hash,15352,4749,20101,68.0,0.17174,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.4;

/**
  @notice Encapsulation of the logic to produce EIP712 hashed domain and messages.
  Also to produce / verify hashed and signed Permits.
*/

library Hash {
  // EIP712 Domain Separator typeHash
  // keccak256(abi.encodePacked(
  //     'EIP712Domain(',
  //     'string name,',
  //     'string version,',
  //     'uint256 chainId,',
  //     'address verifyingContract',
  //     ')'
  // ));
  bytes32 constant internal DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;

  // EIP2612 typeHash of a Permit
  // keccak256(abi.encodePacked(
  //     'Permit(',
  //     'address owner,',
  //     'address spender,',
  //     'uint256 value,',
  //     'uint256 nonce,',
  //     'uint256 deadline,',
  //     ')'
  // ));
  bytes32 constant internal PERMIT_TYPEHASH = 0x80772249b4aef1688b30651778f4249b05cb73b517d98482439b9d8999b30602;

  /// @param n EIP712 domain name
  /// @param version EIP712 semantic version string
  /// @param i Chain ID
  /// @param verifier address of the verifying contract
  function domain(string memory n, string memory version, uint256 i, address verifier) internal pure returns (bytes32) {
    bytes32 hash;

    assembly {
      let nameHash := keccak256(add(n, 32), mload(n))
      let versionHash := keccak256(add(version, 32), mload(version))
      let pointer := mload(64)
      mstore(pointer, DOMAIN_TYPEHASH)
      mstore(add(pointer, 32), nameHash)
      mstore(add(pointer, 64), versionHash)
      mstore(add(pointer, 96), i)
      mstore(add(pointer, 128), verifier)
      hash := keccak256(pointer, 160)
    }

    return hash;
  }

  /// @param d Type hash of the domain separator (see Hash.domain)
  /// @param h EIP712 hash struct (Permit for example)
  function message(bytes32 d, bytes32 h) internal pure returns (bytes32) {
    bytes32 hash;

    assembly {
      let pointer := mload(64)
      mstore(pointer, 0x1901000000000000000000000000000000000000000000000000000000000000)
      mstore(add(pointer, 2), d)
      mstore(add(pointer, 34), h)
      hash := keccak256(pointer, 66)
    }

    return hash;
  }

  /// @param o Address of the owner
  /// @param s Address of the spender
  /// @param a Amount to be approved
  /// @param n Current nonce
  /// @param d Deadline at which the permission is no longer valid
  function permit(address o, address s, uint256 a, uint256 n, uint256 d) internal pure returns (bytes32) {
    return keccak256(abi.encode(PERMIT_TYPEHASH, o, s, a, n, d));
  }
}",751
RealWorld_BA_39_SigFake_RealWord_20240820125323.log,39,SigFake,5519,5299,10818,77.0,0.133575,"// SPDX-License-Identifier: UNLICENSED

/**
  @dev SigFake.sol is written specfically to test the functions which exist in our Sig.sol ""embedded"" library
*/

pragma solidity 0.8.4;

import './Sig.sol';

contract SigFake {
  function splitTest(bytes memory sig) public pure returns (uint8 v, bytes32 r, bytes32 s) {
    return Sig.split(sig);
  }

  function recoverTest(bytes32 h, Sig.Components calldata c) public pure returns (address) {
    return Sig.recover(h,c);
  }
}",120
RealWorld_BA_39_IPErc20_RealWord_20240820130815.log,39,IPErc20,14253,5688,19941,70.0,0.185025,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.4;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IPErc20 {
    /**
     * @dev Returns the amount of tokens owned by `account`.
     * @param a Adress to fetch balance of
     */
    function balanceOf(address a) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     * @param r The recipient
     * @param a The amount transferred
     *
     * Emits a {Transfer} event.
     */
    function transfer(address r, uint256 a) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     * @param o The owner
     * @param s The spender
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address o, address s) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     * @param s The spender
     * @param a The amount to approve
     *
     * Emits an {Approval} event.
     */
    function approve(address s, uint256 a) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     * @param s The sender
     * @param r The recipient
     * @param a The amount to transfer
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address s, address r, uint256 a) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",659
RealWorld_BA_39_Hash_RealWord_20240820125201.log,39,Hash,17441,4989,22430,80.0,0.186985,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.4;

/**
  @notice Encapsulation of the logic to produce EIP712 hashed domain and messages.
  Also to produce / verify hashed and signed Orders.
  See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md
  See/attribute https://github.com/0xProject/0x-monorepo/blob/development/contracts/utils/contracts/src/LibEIP712.sol
*/

library Hash {
  /// @dev struct represents the attributes of an offchain Swivel.Order
  struct Order {
    bytes32 key;
    address maker;
    address underlying;
    bool vault;
    bool exit;
    uint256 principal;
    uint256 premium;
    uint256 maturity;
    uint256 expiry;
  }

  // EIP712 Domain Separator typeHash
  // keccak256(abi.encodePacked(
  //     'EIP712Domain(',
  //     'string name,',
  //     'string version,',
  //     'uint256 chainId,',
  //     'address verifyingContract',
  //     ')'
  // ));
  bytes32 constant internal DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;

  // EIP712 typeHash of an Order 
  // keccak256(abi.encodePacked(
  //     'Order(',
  //     'bytes32 key,',
  //     'address maker,',
  //     'address underlying,',
  //     'bool vault,',
  //     'bool exit,',
  //     'uint256 principal,',
  //     'uint256 premium,',
  //     'uint256 maturity,',
  //     'uint256 expiry',
  //     ')'
  // ));
  bytes32 constant internal ORDER_TYPEHASH = 0x7ddd38ab5ed1c16b61ca90eeb9579e29da1ba821cf42d8cdef8f30a31a6a4146;

  /// @param n EIP712 domain name
  /// @param version EIP712 semantic version string
  /// @param i Chain ID
  /// @param verifier address of the verifying contract
  function domain(string memory n, string memory version, uint256 i, address verifier) internal pure returns (bytes32) {
    bytes32 hash;

    assembly {
      let nameHash := keccak256(add(n, 32), mload(n))
      let versionHash := keccak256(add(version, 32), mload(version))
      let pointer := mload(64)
      mstore(pointer, DOMAIN_TYPEHASH)
      mstore(add(pointer, 32), nameHash)
      mstore(add(pointer, 64), versionHash)
      mstore(add(pointer, 96), i)
      mstore(add(pointer, 128), verifier)
      hash := keccak256(pointer, 160)
    }

    return hash;
  }

  /// @param d Type hash of the domain separator (see Hash.domain)
  /// @param h EIP712 hash struct (order for example)
  function message(bytes32 d, bytes32 h) internal pure returns (bytes32) {
    bytes32 hash;

    assembly {
      let pointer := mload(64)
      mstore(pointer, 0x1901000000000000000000000000000000000000000000000000000000000000)
      mstore(add(pointer, 2), d)
      mstore(add(pointer, 34), h)
      hash := keccak256(pointer, 66)
    }

    return hash;
  }

  /// @param o A Swivel Order
  function order(Order calldata o) internal pure returns (bytes32) {
    // TODO assembly
    return keccak256(abi.encode(
      ORDER_TYPEHASH,
      o.key,
      o.maker,
      o.underlying,
      o.vault,
      o.exit,
      o.principal,
      o.premium,
      o.maturity,
      o.expiry
    ));
  }
}",887
RealWorld_BA_39_PErc20_RealWord_20240820132001.log,39,PErc20,39102,5093,44195,87.0,0.29737,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.4;

import ""./IPErc20.sol"";

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * NOTES: This is an adaptation of the Open Zeppelin ERC20, with changes made per audit
 * requests, and to fit overall Swivel Style. We use it specifically as the base for
 * the Erc2612 hence the `Perc` (Permissioned erc20) naming.
 *
 * Dangling underscores are generally not allowed within swivel style but the 
 * internal, abstracted implementation methods inherted from the O.Z contract are maintained here.
 * Hence, when you see a dangling underscore prefix, you know it is *only* allowed for
 * one of these method calls. It is not allowed for any other purpose. These are:
     _approve
     _transfer
     _mint
     _burn
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.


 */
contract PErc20 is IPErc20 {
    mapping (address => uint256) private balances;
    mapping (address => mapping (address => uint256)) private allowances;

    uint8 public decimals;
    uint256 public totalSupply;
    string public name; // NOTE: cannot make strings immutable
    string public symbol; // NOTE: see above

    /**
     * @dev Sets the values for {name} and {symbol}.
     * @param n Name of the token
     * @param s Symbol of the token
     * @param d Decimals of the token
     */
    constructor (string memory n, string memory s, uint8 d) {
        name = n;
        symbol = s;
        decimals = d;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     * @param a Adress to fetch balance of
     */
    function balanceOf(address a) public view virtual override returns (uint256) {
        return balances[a];
    }

    /**
     * @dev See {IERC20-transfer}.
     * @param r The recipient
     * @param a The amount transferred
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address r, uint256 a) public virtual override returns (bool) {
        _transfer(msg.sender, r, a);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     * @param o The owner
     * @param s The spender
     */
    function allowance(address o, address s) public view virtual override returns (uint256) {
        return allowances[o][s];
    }

    /**
     * @dev See {IERC20-approve}.
     * @param s The spender
     * @param a The amount to approve
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address s, uint256 a) public virtual override returns (bool) {
        _approve(msg.sender, s, a);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * @param s The sender
     * @param r The recipient
     * @param a The amount to transfer
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * Requirements:
     *
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address s, address r, uint256 a) public virtual override returns (bool) {
        _transfer(s, r, a);

        uint256 currentAllowance = allowances[s][msg.sender];
        require(currentAllowance >= a, ""erc20 transfer amount exceeds allowance"");
        _approve(s, msg.sender, currentAllowance - a);

        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     * @param s The spender
     * @param a The amount increased
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address s, uint256 a) public virtual returns (bool) {
        _approve(msg.sender, s, allowances[msg.sender][s] + a);
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     * @param s The spender
     * @param a The amount subtracted
     * 
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address s, uint256 a) public virtual returns (bool) {
        uint256 currentAllowance = allowances[msg.sender][s];
        require(currentAllowance >= a, ""erc20 decreased allowance below zero"");
        _approve(msg.sender, s, currentAllowance - a);

        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     * @param s The sender
     * @param r The recipient
     * @param a The amount to transfer
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address s, address r, uint256 a) internal virtual {
        require(s != address(0), ""erc20 transfer from the zero address"");
        require(r != address(0), ""erc20 transfer to the zero address"");

        uint256 senderBalance = balances[s];
        require(senderBalance >= a, ""erc20 transfer amount exceeds balance"");
        balances[s] = senderBalance - a;
        balances[r] += a;

        emit Transfer(s, r, a);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     * @param r The recipient
     * @param a The amount to mint
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     */
    function _mint(address r, uint256 a) internal virtual {
        require(r != address(0), ""erc20 mint to the zero address"");

        totalSupply += a;
        balances[r] += a;
        emit Transfer(address(0), r, a);
    }

    /**
     * @dev Destroys `amount` tokens from `owner`, reducing the
     * total supply.
     * @param o The owner of the amount being burned
     * @param a The amount to burn
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `owner` must have at least `amount` tokens.
     */
    function _burn(address o, uint256 a) internal virtual {
        require(o != address(0), ""erc20 burn from the zero address"");

        uint256 accountBalance = balances[o];
        require(accountBalance >= a, ""erc20 burn amount exceeds balance"");
        balances[o] = accountBalance - a;
        totalSupply -= a;

        emit Transfer(o, address(0), a);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     * @param o The owner
     * @param s The spender
     * @param a The amount
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address o, address s, uint256 a) internal virtual {
        require(o != address(0), ""erc20 approve from the zero address"");
        require(s != address(0), ""erc20 approve to the zero address"");

        allowances[o][s] = a;
        emit Approval(o, s, a);
    }
}",2254
RealWorld_BA_39_Sig_RealWord_20240820125442.log,39,Sig,11620,5182,16802,79.0,0.16174,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.4;

library Sig {
  /// @dev ECDSA V,R and S components encapsulated here as we may not always be able to accept a bytes signature
  struct Components {
    uint8 v;  
    bytes32 r;
    bytes32 s;
  }

  /// @param h Hashed data which was originally signed
  /// @param c signature struct containing V,R and S
  /// @return The recovered address
  function recover(bytes32 h, Components calldata c) internal pure returns (address) {
    // EIP-2 and malleable signatures...
    // see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol
    require(uint256(c.s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, 'invalid signature ""s"" value');
    require(c.v == 27 || c.v == 28, 'invalid signature ""v"" value');

    return ecrecover(h, c.v, c.r, c.s);
  }

  /// @param h Hashed data which was originally signed
  /// @param sig Valid ECDSA signature
  /// @dev splitAndRecover should only be used if it is known that the resulting 
  /// verifying bit (V) will be 27 || 28. Otherwise use recover, possibly calling split first.
  /// @return The recovered address
  function splitAndRecover(bytes32 h, bytes memory sig) internal pure returns (address) {
    (uint8 v, bytes32 r, bytes32 s) = split(sig);

    return ecrecover(h, v, r, s);
  }

  /// @param sig Valid ECDSA signature
  /// @return v The verification bit
  /// @return r First 32 bytes
  /// @return s Next 32 bytes
  function split(bytes memory sig) internal pure returns (uint8, bytes32, bytes32) {
    require(sig.length == 65, 'invalid signature length');

    bytes32 r;
    bytes32 s;
    uint8 v;

    assembly {
      r := mload(add(sig, 32))
      s := mload(add(sig, 64))
      v := byte(0, mload(add(sig, 96)))
    }

    return (v, r, s);
  }
}",517
RealWorld_BA_39_MarketPlace_RealWord_20240820124912.log,39,MarketPlace,52421,4939,57360,86.0,0.360885,"// SPDX-License-Identifier: UNLICENSED

// TODO update to 0.8.4 (or whatever latest is...)

// NOTE the pattern [underlying, maturity*, cToken, ...]

pragma solidity 0.8.4;

import './Abstracts.sol';
import './ZcToken.sol';
import './VaultTracker.sol';

contract MarketPlace {
  struct Market {
    address cTokenAddr;
    address zcTokenAddr;
    address vaultAddr;
  }

  mapping (address => mapping (uint256 => Market)) public markets;
  mapping (address => mapping (uint256 => bool)) public mature;
  mapping (address => mapping (uint256 => uint256)) public maturityRate;

  address public immutable admin;
  address public swivel;

  event Create(address indexed underlying, uint256 indexed maturity, address cToken, address zcToken, address vaultTracker);
  event Mature(address indexed underlying, uint256 indexed maturity, uint256 maturityRate, uint256 matured);
  event RedeemZcToken(address indexed underlying, uint256 indexed maturity, address indexed sender, uint256 amount);
  event RedeemVaultInterest(address indexed underlying, uint256 indexed maturity, address indexed sender);
  event CustodialInitiate(address indexed underlying, uint256 indexed maturity, address zcTarget, address nTarget, uint256 amount);
  event CustodialExit(address indexed underlying, uint256 indexed maturity, address zcTarget, address nTarget, uint256 amount);
  event P2pZcTokenExchange(address indexed underlying, uint256 indexed maturity, address from, address to, uint256 amount);
  event P2pVaultExchange(address indexed underlying, uint256 indexed maturity, address from, address to, uint256 amount);
  event TransferVaultNotional(address indexed underlying, uint256 indexed maturity, address from, address to, uint256 amount);

  constructor() {
    admin = msg.sender;
  }

  /// @param s Address of the deployed swivel contract
  function setSwivelAddress(address s) external onlyAdmin(admin) returns (bool) {
    swivel = s;
    return true;
  }

  /// @notice Allows the owner to create new markets
  /// @param u Underlying token address associated with the new market
  /// @param m Maturity timestamp of the new market
  /// @param c cToken address associated with underlying for the new market
  /// @param n Name of the new zcToken market
  /// @param s Symbol of the new zcToken market
  function createMarket(
    address u,
    uint256 m,
    address c,
    string memory n,
    string memory s,
    uint8 d
  ) public onlyAdmin(admin) returns (bool) {
    require(swivel != address(0), 'swivel contract address not set');
    // TODO can we live with the factory pattern here both bytecode size wise and CREATE opcode cost wise?
    address zctAddr = address(new ZcToken(u, m, n, s, d));
    address vAddr = address(new VaultTracker(m, c, swivel));
    markets[u][m] = Market(c, zctAddr, vAddr);

    emit Create(u, m, c, zctAddr, vAddr);

    return true;
  }

  /// @notice Can be called after maturity, allowing all of the zcTokens to earn floating interest on Compound until they release their funds
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  function matureMarket(address u, uint256 m) public returns (bool) {
    require(!mature[u][m], 'market already matured');
    require(block.timestamp >= ZcToken(markets[u][m].zcTokenAddr).maturity(), ""maturity not reached"");

    // set the base maturity cToken exchange rate at maturity to the current cToken exchange rate
    uint256 currentExchangeRate = CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent();
    maturityRate[u][m] = currentExchangeRate;
    // set the maturity state to true (for zcb market)
    mature[u][m] = true;

    // set vault ""matured"" to true
    require(VaultTracker(markets[u][m].vaultAddr).matureVault(), 'maturity not reached');

    emit Mature(u, m, block.timestamp, currentExchangeRate);

    return true;
  }

  /// @notice Allows Swivel caller to deposit their underlying, in the process splitting it - minting both zcTokens and vault notional.
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param t Address of the depositing user
  /// @param a Amount of notional being added
  function mintZcTokenAddingNotional(address u, uint256 m, address t, uint256 a) external onlySwivel(swivel) returns (bool) {
    require(ZcToken(markets[u][m].zcTokenAddr).mint(t, a), 'mint zcToken failed');
    require(VaultTracker(markets[u][m].vaultAddr).addNotional(t, a), 'add notional failed');
    
    return true;
  }

  /// @notice Allows Swivel caller to deposit/burn both zcTokens + vault notional. This process is ""combining"" the two and redeeming underlying.
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param t Address of the combining/redeeming user
  /// @param a Amount of zcTokens being burned
  function burnZcTokenRemovingNotional(address u, uint256 m, address t, uint256 a) external onlySwivel(swivel) returns(bool) {
    require(ZcToken(markets[u][m].zcTokenAddr).burn(t, a), 'burn failed');
    require(VaultTracker(markets[u][m].vaultAddr).removeNotional(t, a), 'remove notional failed');
    
    return true;
  }

  /// @notice Allows (via swivel) zcToken holders to redeem their tokens for underlying tokens after maturity has been reached.
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param t Address of the redeeming user
  /// @param a Amount of zcTokens being redeemed
  function redeemZcToken(address u, uint256 m, address t, uint256 a) external onlySwivel(swivel) returns (uint256) {
    Market memory mkt = markets[u][m];
    bool matured = mature[u][m];

    if (!matured) {
      require(matureMarket(u, m), 'failed to mature the market');
    }

    // burn user's zcTokens
    require(ZcToken(mkt.zcTokenAddr).burn(t, a), 'could not burn');

    emit RedeemZcToken(u, m, t, a);

    if (!matured) {
      return a;
    } else { 
      // if the market was already mature the return should include the amount + marginal floating interest generated on Compound since maturity
      return calculateReturn(u, m, a);
    }
  }

  /// @notice Allows Vault owners (via Swivel) to redeem any currently accrued interest
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param t Address of the redeeming user
  function redeemVaultInterest(address u, uint256 m, address t) external onlySwivel(swivel) returns (uint256) {
    // call to the floating market contract to release the position and calculate the interest generated
    uint256 interest = VaultTracker(markets[u][m].vaultAddr).redeemInterest(t);

    emit RedeemVaultInterest(u, m, t);

    return interest;
  }

  /// @notice Calculates the total amount of underlying returned including interest generated since the `matureMarket` function has been called
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param a Amount of zcTokens being redeemed
  function calculateReturn(address u, uint256 m, uint256 a) internal returns (uint256) {
    // calculate difference between the cToken exchange rate @ maturity and the current cToken exchange rate
    uint256 yield = ((CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent() * 1e26) / maturityRate[u][m]) - 1e26;
    uint256 interest = (yield * a) / 1e26;

    // calculate the total amount of underlying principle to return
    return a + interest;
  }

  function cTokenAddress(address a, uint256 m) external view returns (address) {
    return markets[a][m].cTokenAddr;
  }

  /// @notice called by swivel IVFZI && IZFVI
  /// @dev call with underlying, maturity, mint-target, add-notional-target and an amount
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param z Recipient of the minted zcToken
  /// @param n Recipient of the added notional
  /// @param a Amount of zcToken minted and notional added
  function custodialInitiate(address u, uint256 m, address z, address n, uint256 a) external onlySwivel(swivel) returns (bool) {
    require(ZcToken(markets[u][m].zcTokenAddr).mint(z, a), 'mint failed');
    require(VaultTracker(markets[u][m].vaultAddr).addNotional(n, a), 'add notional failed');
    emit CustodialInitiate(u, m, z, n, a);
    return true;
  }

  /// @notice called by swivel EVFZE FF EZFVE
  /// @dev call with underlying, maturity, burn-target, remove-notional-target and an amount
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param z Owner of the zcToken to be burned
  /// @param n Target to remove notional from
  /// @param a Amount of zcToken burned and notional removed
  function custodialExit(address u, uint256 m, address z, address n, uint256 a) external onlySwivel(swivel) returns (bool) {
    require(ZcToken(markets[u][m].zcTokenAddr).burn(z, a), 'burn failed');
    require(VaultTracker(markets[u][m].vaultAddr).removeNotional(n, a), 'remove notional failed');
    emit CustodialExit(u, m, z, n, a);
    return true;
  }

  /// @notice called by swivel IZFZE, EZFZI
  /// @dev call with underlying, maturity, transfer-from, transfer-to, amount
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param f Owner of the zcToken to be burned
  /// @param t Target to be minted to
  /// @param a Amount of zcToken transfer
  function p2pZcTokenExchange(address u, uint256 m, address f, address t, uint256 a) external onlySwivel(swivel) returns (bool) {
    require(ZcToken(markets[u][m].zcTokenAddr).burn(f, a), 'zcToken burn failed');
    require(ZcToken(markets[u][m].zcTokenAddr).mint(t, a), 'zcToken mint failed');
    emit P2pZcTokenExchange(u, m, f, t, a);
    return true;
  }

  /// @notice called by swivel IVFVE, EVFVI
  /// @dev call with underlying, maturity, remove-from, add-to, amount
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param f Owner of the notional to be transferred
  /// @param t Target to be transferred to
  /// @param a Amount of notional transfer
  function p2pVaultExchange(address u, uint256 m, address f, address t, uint256 a) external onlySwivel(swivel) returns (bool) {
    require(VaultTracker(markets[u][m].vaultAddr).transferNotionalFrom(f, t, a), 'transfer notional failed');
    emit P2pVaultExchange(u, m, f, t, a);
    return true;
  }

  /// @notice External method giving access to this functionality within a given vault
  /// @dev Note that this method calculates yield and interest as well
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param t Target to be transferred to
  /// @param a Amount of notional to be transferred
  function transferVaultNotional(address u, uint256 m, address t, uint256 a) public returns (bool) {
    require(VaultTracker(markets[u][m].vaultAddr).transferNotionalFrom(msg.sender, t, a), 'vault transfer failed');
    emit TransferVaultNotional(u, m, msg.sender, t, a);
    return true;
  }

  /// @notice transfers notional fee to the Swivel contract without recalculating marginal interest for from
  /// @param u Underlying token address associated with the market
  /// @param m Maturity timestamp of the market
  /// @param f Owner of the amount
  /// @param a Amount to transfer
  function transferVaultNotionalFee(address u, uint256 m, address f, uint256 a) public onlySwivel(swivel) returns (bool) {
    VaultTracker(markets[u][m].vaultAddr).transferNotionalFee(f, a);
    return true;
  }

  modifier onlyAdmin(address a) {
    require(msg.sender == a, 'sender must be admin');
    _;
  }

  modifier onlySwivel(address s) {
    require(msg.sender == s, 'sender must be Swivel contract');
    _;
  }
}",3072
RealWorld_BA_39_Erc2612_RealWord_20240820132410.log,39,Erc2612,11645,5253,16898,66.0,0.163285,"// SPDX-License-Identifier: GPL-3.0-or-later
// Adapted from OpenZeppelin ERC2612 (ERC20Permit)

pragma solidity 0.8.4;

import './Hash.sol';
import './PErc20.sol';
import './IErc2612.sol';

/**
* @dev Extension of {ERC20} that allows token holders to use their tokens
* without sending any transactions by setting {IERC20-allowance} with a
* signature using the {permit} method, and then spend them via
* {IERC20-transferFrom}.
* NOTE: Naming convention is kept OZStyle vs our own OzStyle to prevent clashing
*
* The {permit} signature mechanism conforms to the {IERC2612} interface.
*/
contract Erc2612 is PErc20, IErc2612 {
  mapping (address => uint256) public override nonces;

  bytes32 public immutable domain;

  /// @param n name for the token
  /// @param s symbol for the token
  /// @param d decimals for the token
  constructor(string memory n, string memory s, uint8 d) PErc20(n, s, d) {
    domain = Hash.domain(n, '1', block.chainid, address(this));
  }

  /**
  * @dev See {IERC2612-permit}.
  *
  * In cases where the free option is not a concern, deadline can simply be
  * set to uint(-1), so it should be seen as an optional parameter
  *
  * @param o Address of the owner
  * @param spender Address of the spender
  * @param a Amount to be approved
  * @param d Deadline at which the permission is no longer valid
  * NOTE: Last three args (v, r, s) are the components of a valid ECDSA signature
  */
  function permit(address o, address spender, uint256 a, uint256 d, uint8 v, bytes32 r, bytes32 s) public virtual override {
    require(d >= block.timestamp, 'erc2612 expired deadline');

    bytes32 hashStruct = Hash.permit(o, spender, a, nonces[o]++, d);
    bytes32 hash = Hash.message(domain, hashStruct); 
    address signer = ecrecover(hash, v, r, s);

    require(signer != address(0) && signer == o, 'erc2612 invalid signature');
    _approve(o, spender, a);
  }
}",523
RealWorld_BA_39_Hash_RealWord_20240820123921.log,39,Hash,17433,5439,22872,77.0,0.195945,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.4;

/**
  @notice Encapsulation of the logic to produce EIP712 hashed domain and messages.
  Also to produce / verify hashed and signed Orders.
  See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md
  See/attribute https://github.com/0xProject/0x-monorepo/blob/development/contracts/utils/contracts/src/LibEIP712.sol
*/

library Hash {
  /// @dev struct represents the attributes of an offchain Swivel.Order
  struct Order {
    bytes32 key;
    address maker;
    address underlying;
    bool vault;
    bool exit;
    uint256 principal;
    uint256 premium;
    uint256 maturity;
    uint256 expiry;
  }

  // EIP712 Domain Separator typeHash
  // keccak256(abi.encodePacked(
  //     'EIP712Domain(',
  //     'string name,',
  //     'string version,',
  //     'uint256 chainId,',
  //     'address verifyingContract',
  //     ')'
  // ));
  bytes32 constant internal DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;

  // EIP712 typeHash of an Order 
  // keccak256(abi.encodePacked(
  //     'Order(',
  //     'bytes32 key,',
  //     'address maker,',
  //     'address underlying,',
  //     'bool vault,',
  //     'bool exit,',
  //     'uint256 principal,',
  //     'uint256 premium,',
  //     'uint256 maturity,',
  //     'uint256 expiry',
  //     ')'
  // ));
  bytes32 constant internal ORDER_TYPEHASH = 0x7ddd38ab5ed1c16b61ca90eeb9579e29da1ba821cf42d8cdef8f30a31a6a4146;

  /// @param n EIP712 domain name
  /// @param version EIP712 semantic version string
  /// @param i Chain ID
  /// @param verifier address of the verifying contract
  function domain(string memory n, string memory version, uint256 i, address verifier) internal pure returns (bytes32) {
    bytes32 hash;

    assembly {
      let nameHash := keccak256(add(n, 32), mload(n))
      let versionHash := keccak256(add(version, 32), mload(version))
      let pointer := mload(64)
      mstore(pointer, DOMAIN_TYPEHASH)
      mstore(add(pointer, 32), nameHash)
      mstore(add(pointer, 64), versionHash)
      mstore(add(pointer, 96), i)
      mstore(add(pointer, 128), verifier)
      hash := keccak256(pointer, 160)
    }

    return hash;
  }

  /// @param d Type hash of the domain separator (see Hash.domain)
  /// @param h EIP712 hash struct (order for example)
  function message(bytes32 d, bytes32 h) internal pure returns (bytes32) {
    bytes32 hash;

    assembly {
      let pointer := mload(64)
      mstore(pointer, 0x1901000000000000000000000000000000000000000000000000000000000000)
      mstore(add(pointer, 2), d)
      mstore(add(pointer, 34), h)
      hash := keccak256(pointer, 66)
    }

    return hash;
  }

  /// @param o A Swivel Order
  function order(Order calldata o) internal pure returns (bytes32) {
    // TODO assembly
    return keccak256(abi.encode(
      ORDER_TYPEHASH,
      o.key,
      o.maker,
      o.underlying,
      o.vault,
      o.exit,
      o.principal,
      o.premium,
      o.maturity,
      o.expiry
    ));
  }
}",887
RealWorld_BA_41_IAuction_RealWord_20240820135512.log,41,IAuction,9320,5670,14990,92.0,0.16,"pragma solidity =0.8.7;

import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./IBasket.sol"";
import ""./IFactory.sol"";

interface IAuction {
    struct Bounty {
        address token;
        uint256 amount;
        bool active;
    }

    function startAuction() external;
    function bondForRebalance() external;
    function settleAuction(
        uint256[] calldata,
        address[] calldata,
        uint256[] calldata,
        address[] calldata,
        uint256[] calldata
    ) external;
    function bondBurn() external;
    function killAuction() external;
    function addBounty(IERC20, uint256) external returns (uint256);
    function initialize(address, address) external;
    function initialized() external view returns (bool);

    function auctionOngoing() external view returns (bool);
    function auctionStart() external view returns (uint256);
    function hasBonded() external view returns (bool);
    function bondAmount() external view returns (uint256);
    function bondBlock() external view returns (uint256);

    function basket() external view returns (IBasket);
    function factory() external view returns (IFactory);
    function auctionBonder() external view returns (address);

    event AuctionStarted();
    event Bonded(address _bonder, uint256 _amount);
    event AuctionSettled(address _settler);
    event BondBurned(address _burned, address _burnee, uint256 _amount);
    event BountyAdded(IERC20 _token, uint256 _amount, uint256 _id);
    event BountyClaimed(address _claimer, address _token, uint256 _amount, uint256 _id);
}",367
RealWorld_BA_41_Basket_RealWord_20240820134943.log,41,Basket,33745,6007,39752,93.0,0.288865,"pragma solidity =0.8.7;

import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { ERC20Upgradeable } from ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import { Ownable } from ""@openzeppelin/contracts/access/Ownable.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import './interfaces/IAuction.sol';
import ""./interfaces/IBasket.sol"";
import ""./interfaces/IFactory.sol"";
import ""hardhat/console.sol"";

//TODO: add revert reasons or v8 custom errors back in
contract Basket is IBasket, ERC20Upgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    //TODO: recommend using block timestamp instead of block numbers here
    uint256 public constant TIMELOCK_DURATION = 4 * 60 * 24; // 1 day in blocks
    uint256 public constant ONE_YEAR = 365.25 days;
    uint256 private constant BASE = 1e18;

    address public publisher;
    uint256 public licenseFee;

    IFactory public override factory;
    IAuction public override auction;

    uint256 public override ibRatio;

    PendingPublisher public pendingPublisher;
    PendingLicenseFee public pendingLicenseFee;
    PendingWeights public pendingWeights;

    address[] public tokens;
    uint256[] public weights;

    uint256 public override lastFee;

    bool public override initialized;

    function initialize(IFactory.Proposal memory proposal, IAuction auction_) external override {
        require(address(factory) == address(0));
        require(!initialized);

        publisher = proposal.proposer;
        licenseFee = proposal.licenseFee;
        factory = IFactory(msg.sender);
        auction = auction_;
        ibRatio = BASE;
        tokens = proposal.tokens;
        weights = proposal.weights;
        approveUnderlying(address(auction));

        __ERC20_init(proposal.tokenName, proposal.tokenSymbol);

        initialized = true;
    }

    function getPendingWeights() external override view returns (address[] memory, uint256[] memory) {
        return (pendingWeights.tokens, pendingWeights.weights);
    }

    function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {
        require(_tokens.length > 0);
        require(_tokens.length == _weights.length);
        uint256 length = _tokens.length;
        address[] memory tokenList = new address[](length);

        // check uniqueness of tokens and not token(0)

        for (uint i = 0; i < length; i++) {
            require(_tokens[i] != address(0));
            require(_weights[i] > 0);

            for (uint256 x = 0; x < tokenList.length; x++) {
                require(_tokens[i] != tokenList[x]);
            }

            tokenList[i] = _tokens[i];
        }
    }

    function mint(uint256 amount) public nonReentrant override {
        mintTo(amount, msg.sender);
    }

    function mintTo(uint256 amount, address to) public nonReentrant override {
        require(auction.auctionOngoing() == false);
        require(amount > 0);

        handleFees();

        pullUnderlying(amount, msg.sender);

        _mint(to, amount);

        emit Minted(to, amount);
    }

    function burn(uint256 amount) public nonReentrant override {
        require(auction.auctionOngoing() == false);
        require(amount > 0);

        handleFees();

        pushUnderlying(amount, msg.sender);
        _burn(msg.sender, amount);
        
        emit Burned(msg.sender, amount);
    }

    function auctionBurn(uint256 amount) onlyAuction nonReentrant external override {
        handleFees();
        uint256 startSupply = totalSupply();
        _burn(msg.sender, amount);

        uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);
        ibRatio = newIbRatio;

        emit NewIBRatio(newIbRatio);
        emit Burned(msg.sender, amount);
    }

    function handleFees() private {
        if (lastFee == 0) {
            lastFee = block.timestamp;
        } else {
            uint256 startSupply = totalSupply();

            uint256 timeDiff = (block.timestamp - lastFee);
            uint256 feePct = timeDiff * licenseFee / ONE_YEAR;
            uint256 fee = startSupply * feePct / (BASE - feePct);

            _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);
            _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);
            lastFee = block.timestamp;

            uint256 newIbRatio = ibRatio * startSupply / totalSupply();
            ibRatio = newIbRatio;

            emit NewIBRatio(ibRatio);
        }
    }

    // changes publisher
    // timelocked
    function changePublisher(address newPublisher) onlyPublisher public override {
        require(newPublisher != address(0));

        if (pendingPublisher.publisher != address(0) && pendingPublisher.publisher == newPublisher) {
            require(block.number >= pendingPublisher.block + TIMELOCK_DURATION);
            publisher = newPublisher;

            pendingPublisher.publisher = address(0);

            emit ChangedPublisher(publisher);
        } else {
            pendingPublisher.publisher = newPublisher;
            pendingPublisher.block = block.number;

            emit NewPublisherSubmitted(newPublisher);
        }
    }

    //changes licenseFee
    // timelocked
    function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {
        require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);
        if (pendingLicenseFee.licenseFee != 0 && pendingLicenseFee.licenseFee == newLicenseFee) {
            require(block.number >= pendingLicenseFee.block + TIMELOCK_DURATION);
            licenseFee = newLicenseFee;

            pendingLicenseFee.licenseFee = 0;

            emit ChangedLicenseFee(licenseFee);
        } else {
            pendingLicenseFee.licenseFee = newLicenseFee;
            pendingLicenseFee.block = block.number;

            emit NewLicenseFeeSubmitted(newLicenseFee);
        }
    }

    // publish new index
    // timelocked
    function publishNewIndex(address[] memory _tokens, uint256[] memory _weights) onlyPublisher public override {
        validateWeights(_tokens, _weights);

        if (pendingWeights.pending) {
            require(block.number >= pendingWeights.block + TIMELOCK_DURATION);
            if (auction.auctionOngoing() == false) {
                auction.startAuction();

                emit PublishedNewIndex(publisher);
            } else if (auction.hasBonded()) {

            } else {
                auction.killAuction();

                pendingWeights.tokens = _tokens;
                pendingWeights.weights = _weights;
                pendingWeights.block = block.number;
            }
        } else {
            pendingWeights.pending = true;
            pendingWeights.tokens = _tokens;
            pendingWeights.weights = _weights;
            pendingWeights.block = block.number;

            emit NewIndexSubmitted();
        }
    }

    function setNewWeights() onlyAuction external override {
        tokens = pendingWeights.tokens;
        weights = pendingWeights.weights;
        pendingWeights.pending = false;

        approveUnderlying(address(auction));

        emit WeightsSet();
    }

    // delete pending index
    function deleteNewIndex() public override {
        require(msg.sender == publisher || msg.sender == address(auction));
        require(auction.auctionOngoing() == false);

        pendingWeights.pending = false;

        emit DeletedNewIndex(publisher);
    }

    function updateIBRatio(uint256 newRatio) onlyAuction external override returns (uint256) {
        ibRatio = newRatio;

        emit NewIBRatio(ibRatio);

        return ibRatio;
    }

    function approveUnderlying(address spender) private {
        for (uint256 i = 0; i < weights.length; i++) {
            IERC20(tokens[i]).safeApprove(spender, 0);
            IERC20(tokens[i]).safeApprove(spender, type(uint256).max);
        }
    }

    function pushUnderlying(uint256 amount, address to) private {
        for (uint256 i = 0; i < weights.length; i++) {
            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;
            IERC20(tokens[i]).safeTransfer(to, tokenAmount);
        }
    }

    function pullUnderlying(uint256 amount, address from) private {
        for (uint256 i = 0; i < weights.length; i++) {
            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;
            require(tokenAmount > 0);
            IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);
        }
    }

    modifier onlyAuction() {
        require(msg.sender == address(auction));
        _;
    }

    modifier onlyPublisher() {
        require(msg.sender == address(publisher));
        _;
    }
}",1922
RealWorld_BA_41_IBasket_RealWord_20240820135646.log,41,IBasket,9623,5309,14932,77.0,0.154295,"pragma solidity =0.8.7;

import ""./IAuction.sol"";

interface IBasket {
    struct PendingPublisher {
        address publisher;
        uint256 block;
    }

    struct PendingLicenseFee {
        uint256 licenseFee;
        uint256 block;
    }

    struct PendingWeights {
        address[] tokens;
        uint256[] weights;
        uint256 block;
        bool pending;
    }

    function initialize(IFactory.Proposal memory, IAuction) external;
    function mint(uint256) external;
    function mintTo(uint256, address) external;
    function burn(uint256) external;
    function changePublisher(address) external;
    function changeLicenseFee(uint256) external;
    function publishNewIndex(address[] calldata, uint256[] calldata) external;
    function deleteNewIndex() external;
    function auctionBurn(uint256) external;
    function updateIBRatio(uint256) external returns (uint256);
    function setNewWeights() external;
    function validateWeights(address[] memory, uint256[] memory) external pure;
    function initialized() external view returns (bool);

    function ibRatio() external view returns (uint256);
    function getPendingWeights() external view returns (address[] memory, uint256[] memory);
    function factory() external view returns (IFactory);
    function auction() external view returns (IAuction);
    function lastFee() external view returns (uint256);


    // TODO: none of these are used
    event Minted(address indexed _to, uint256 _amount);
    event Burned(address indexed _from, uint256 _amount);
    event ChangedPublisher(address indexed _newPublisher);
    event ChangedLicenseFee(uint256 _newLicenseFee);
    event NewPublisherSubmitted(address indexed _newPublisher);
    event NewLicenseFeeSubmitted(uint256 _newLicenseFee);
    event NewIndexSubmitted();
    event PublishedNewIndex(address _publisher);
    event DeletedNewIndex(address _publisher);
    event WeightsSet();
    event NewIBRatio(uint256);
}",411
RealWorld_BA_41_Factory_RealWord_20240820134819.log,41,Factory,17455,6580,24035,82.0,0.218875,"pragma solidity =0.8.7;

import ""hardhat/console.sol"";

import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { Ownable } from ""@openzeppelin/contracts/access/Ownable.sol"";
import { Clones } from ""@openzeppelin/contracts/proxy/Clones.sol"";
import ""./interfaces/IAuction.sol"";
import ""./interfaces/IBasket.sol"";
import ""./interfaces/IFactory.sol"";

contract Factory is IFactory, Ownable {
    using SafeERC20 for IERC20;

    uint256 private constant BASE = 1e18;

    constructor (IAuction _auctionImpl, IBasket _basketImpl) {
        auctionImpl = _auctionImpl;
        basketImpl = _basketImpl;
        ownerSplit = 0; //TODO: needed?
    }

    Proposal[] private _proposals;

    IAuction public override auctionImpl;
    IBasket public override basketImpl;

    uint256 public override minLicenseFee = 1e15; // 1e15 0.1%
    uint256 public override auctionDecrement = 10000;
    uint256 public override auctionMultiplier = 2;
    uint256 public override bondPercentDiv = 400;
    uint256 public override ownerSplit;

    function proposal(uint256 proposalId) external override view returns (Proposal memory) {
        return _proposals[proposalId];
    }

    function setMinLicenseFee(uint256 newMinLicenseFee) public override onlyOwner {
        minLicenseFee = newMinLicenseFee;
    }

    function setAuctionDecrement(uint256 newAuctionDecrement) public override onlyOwner {
        auctionDecrement = newAuctionDecrement;
    }

    function setAuctionMultiplier(uint256 newAuctionMultiplier) public override onlyOwner {
        auctionMultiplier = newAuctionMultiplier;
    }

    function setBondPercentDiv(uint256 newBondPercentDiv) public override onlyOwner {
        bondPercentDiv = newBondPercentDiv;
    }

    function setOwnerSplit(uint256 newOwnerSplit) public override onlyOwner {
        require(newOwnerSplit <= 2e17); // 20%

        ownerSplit = newOwnerSplit;
    }

    function getProposalWeights(uint256 id) external override view returns (address[] memory, uint256[] memory) {
        return (_proposals[id].tokens, _proposals[id].weights);
    }

    function proposeBasketLicense(
        uint256 licenseFee, 
        string memory tokenName, 
        string memory tokenSymbol, 
        address[] memory tokens,
        uint256[] memory weights
    ) public override returns (uint256 id) {
        basketImpl.validateWeights(tokens, weights);

        require(licenseFee >= minLicenseFee);

        // create proposal object
        Proposal memory proposal = Proposal({
            licenseFee: licenseFee,
            tokenName: tokenName,
            tokenSymbol: tokenSymbol,
            proposer: address(msg.sender),
            tokens: tokens,
            weights: weights,
            basket: address(0)
        });

        emit BasketLicenseProposed(msg.sender, tokenName);
        _proposals.push(proposal);

        return _proposals.length - 1;
    }

    function createBasket(uint256 idNumber) external override returns (IBasket) {
        Proposal memory bProposal = _proposals[idNumber];
        require(bProposal.basket == address(0));

        IAuction newAuction = IAuction(Clones.clone(address(auctionImpl)));
        IBasket newBasket = IBasket(Clones.clone(address(basketImpl)));

        _proposals[idNumber].basket = address(newBasket);

        newAuction.initialize(address(newBasket), address(this));
        newBasket.initialize(bProposal, newAuction);

        for (uint256 i = 0; i < bProposal.weights.length; i++) {
            IERC20 token = IERC20(bProposal.tokens[i]);
            token.safeTransferFrom(msg.sender, address(this), bProposal.weights[i]);
            token.safeApprove(address(newBasket), bProposal.weights[i]);
        }

        newBasket.mintTo(BASE, msg.sender);

        emit BasketCreated(address(newBasket));

        return newBasket;
    }
}",899
RealWorld_BA_41_TestToken_RealWord_20240820135248.log,41,TestToken,4204,3545,7749,56.0,0.09192,"pragma solidity =0.8.7;

import { ERC20 } from ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract TestToken is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) public {

    }

    function mint(uint256 amount) public {
        _mint(msg.sender, amount);
    }
}",77
RealWorld_BA_41_Auction_RealWord_20240820135118.log,41,Auction,22125,6233,28358,88.0,0.235285,"pragma solidity =0.8.7;

import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import './interfaces/IFactory.sol';
import './interfaces/IBasket.sol';
import ""./interfaces/IAuction.sol"";
import ""hardhat/console.sol"";

contract Auction is IAuction, ReentrancyGuard {
    using SafeERC20 for IERC20;

    uint256 private constant BASE = 1e18;
    uint256 private constant ONE_DAY = 4 * 60 * 24; // one day in blocks
    
    bool public override auctionOngoing;
    uint256 public override auctionStart;
    bool public override hasBonded;
    uint256 public override bondAmount;
    uint256 public override bondBlock;

    IBasket public override basket;
    IFactory public override factory;
    address public override auctionBonder;

    Bounty[] private _bounties;

    bool public override initialized;

    modifier onlyBasket() {
        require(msg.sender == address(basket), 'not basket');
        _;
    }

    function startAuction() onlyBasket public override {
        require(auctionOngoing == false, 'ongoing auction');

        auctionOngoing = true;
        auctionStart = block.number;

        emit AuctionStarted();
    }

    function killAuction() onlyBasket public override {
        auctionOngoing = false;
    }

    function initialize(address basket_, address factory_) public override {
        require(address(factory) == address(0));
        require(!initialized);

        basket = IBasket(basket_);
        factory = IFactory(factory_);
        initialized = true;
    }

    function bondForRebalance() public override {
        require(auctionOngoing);
        require(!hasBonded);

        bondBlock = block.number;

        IERC20 basketToken = IERC20(address(basket));
        bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();
        basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);
        hasBonded = true;
        auctionBonder = msg.sender;

        emit Bonded(msg.sender, bondAmount);
    }

    function settleAuction(
        uint256[] memory bountyIDs,
        address[] memory inputTokens,
        uint256[] memory inputWeights,
        address[] memory outputTokens,
        uint256[] memory outputWeights
    ) public nonReentrant override {
        require(auctionOngoing);
        require(hasBonded);
        require(bondBlock + ONE_DAY > block.number);
        require(msg.sender == auctionBonder);
        require(inputTokens.length == inputWeights.length);
        require(outputTokens.length == outputWeights.length);

        for (uint256 i = 0; i < inputTokens.length; i++) {
            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);
        }

        for (uint256 i = 0; i < outputTokens.length; i++) {
            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);
        }

        //TODO: name a and b or further split up
        uint256 a = factory.auctionMultiplier() * basket.ibRatio();
        uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();
        uint256 newRatio = a - b;

        (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();
        IERC20 basketAsERC20 = IERC20(address(basket));

        for (uint256 i = 0; i < pendingWeights.length; i++) {
            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;
            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);
        }

        basket.setNewWeights();
        basket.updateIBRatio(newRatio);
        auctionOngoing = false;
        hasBonded = false;

        basketAsERC20.safeTransfer(msg.sender, bondAmount);
        withdrawBounty(bountyIDs);

        emit AuctionSettled(msg.sender);
    }

    function bondBurn() external override {
        require(auctionOngoing);
        require(hasBonded);
        require(bondBlock + ONE_DAY <= block.number);

        basket.auctionBurn(bondAmount);
        hasBonded = false;
        auctionOngoing = false;
        basket.deleteNewIndex();

        emit BondBurned(msg.sender, auctionBonder, bondAmount);

        auctionBonder = address(0);
    }

    function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {
        // add bounty to basket
        token.safeTransferFrom(msg.sender, address(this), amount);
        _bounties.push(Bounty({
            token: address(token),
            amount: amount,
            active: true
        }));

        uint256 id = _bounties.length - 1;
        emit BountyAdded(token, amount, id);
        return id;
    }

    function withdrawBounty(uint256[] memory bountyIds) internal {
        // withdraw bounties
        for (uint256 i = 0; i < bountyIds.length; i++) {
            Bounty storage bounty = _bounties[bountyIds[i]];
            require(bounty.active);

            IERC20(bounty.token).safeTransfer(msg.sender, bounty.amount);
            bounty.active = false;

            emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);
        }
    }
 }",1168
RealWorld_BA_41_IFactory_RealWord_20240820135346.log,41,IFactory,9390,5868,15258,84.0,0.16431,"pragma solidity =0.8.7;

import ""./IBasket.sol"";

interface IFactory {
    struct Bounty {
        address token;
        uint256 amount;
        bool active;
    }

    struct Proposal {
        uint256 licenseFee;
        string tokenName;
        string tokenSymbol;
        address proposer;
        address[] tokens;
        uint256[] weights;
        address basket;
    }


    //TODO: validate these
    function proposal(uint256) external view returns (Proposal memory);
    function minLicenseFee() external view returns (uint256);
    function auctionDecrement() external view returns (uint256);
    function auctionMultiplier() external view returns (uint256);
    function bondPercentDiv() external view returns (uint256);
    function ownerSplit() external view returns (uint256);
    function auctionImpl() external view returns (IAuction);
    function basketImpl() external view returns (IBasket);
    function getProposalWeights(uint256 id) external view returns (address[] memory, uint256[] memory);

    function createBasket(uint256) external returns (IBasket);
    function proposeBasketLicense(uint256, string calldata, string calldata, address[] memory tokens, uint256[] memory weights) external returns (uint256);
    function setMinLicenseFee(uint256) external;
    function setAuctionDecrement(uint256) external;
    function setAuctionMultiplier(uint256) external;
    function setBondPercentDiv(uint256) external;
    function setOwnerSplit(uint256) external;

    event BasketCreated(address indexed basket);
    event BasketLicenseProposed(address indexed proposer, string indexed tokenName);
}",335
RealWorld_BA_42_UniswapV2TokenAdapter_RealWord_20240820153612.log,42,UniswapV2TokenAdapter,29550,6092,35642,104.0,0.26959,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@mochifi/library/contracts/UniswapV2Library.sol"";
import ""@mochifi/library/contracts/SushiswapV2Library.sol"";
import ""../interfaces/ICSSRRouter.sol"";
import ""../interfaces/ICSSRAdapter.sol"";
import ""../interfaces/IUniswapV2CSSR.sol"";
import ""../interfaces/IGovernanceOwned.sol"";

contract UniswapV2TokenAdapter is ICSSRAdapter {
    IGovernanceOwned public immutable owned;
    ICSSRRouter public immutable cssrRouter;
    IUniswapV2CSSR public immutable uniswapCSSR;
    IUniswapV2CSSR public immutable sushiCSSR;

    address[] public keyCurrency;
    uint256 public minimumLiquidity;
    mapping(address => bool) public isKeyCurrency;

    modifier onlyGov() {
        require(msg.sender == owned.governance(), ""!gov"");
        _;
    }

    constructor(
        address _owned,
        address _router,
        address _uniCSSR,
        address _sushiCSSR
    ) {
        owned = IGovernanceOwned(_owned);
        cssrRouter = ICSSRRouter(_router);
        uniswapCSSR = IUniswapV2CSSR(_uniCSSR);
        sushiCSSR = IUniswapV2CSSR(_sushiCSSR);
    }

    function addKeyCurrency(address _currency) external onlyGov {
        keyCurrency.push(_currency);
        isKeyCurrency[_currency] = true;
    }

    function removeKeyCurrency(uint256 _idx, address _currency)
        external
        onlyGov
    {
        require(keyCurrency[_idx] == _currency, ""!match"");
        keyCurrency[_idx] = keyCurrency[keyCurrency.length - 1];
        keyCurrency.pop();
        isKeyCurrency[_currency] = false;
    }

    function setMinimumLiquidity(uint256 _liquidity)
        external
        onlyGov
    {
        minimumLiquidity = _liquidity;
    }

    function support(address _asset) external view override returns (bool) {
        // check if liquidity passes the minimum
        for (uint256 i = 0; i < keyCurrency.length; i++) {
            if (aboveLiquidity(_asset, keyCurrency[i])) {
                return true;
            }
        }
        return false;
    }

    function update(address _asset, bytes memory _data)
        external
        override
        returns (float memory)
    {
        (uint256 cssrType, bytes memory data) = abi.decode(_data, (uint256, bytes));
        if(cssrType == 0){
            (
                address p,
                bytes memory bd,
                bytes memory ap,
                bytes memory rp,
                bytes memory pp0,
                bytes memory pp1
            ) = abi.decode(data, (address, bytes, bytes, bytes, bytes, bytes));
            require(isKeyCurrency[p], ""!keyCurrency"");
            (, uint256 bn, ) = uniswapCSSR.saveState(bd);
            address pair = UniswapV2Library.pairFor(
                uniswapCSSR.uniswapFactory(),
                _asset,
                p
            );
            uniswapCSSR.saveReserve(bn, pair, ap, rp, pp0, pp1);
        } else if(cssrType == 1){
            (
                address p,
                bytes memory bd,
                bytes memory ap,
                bytes memory rp,
                bytes memory pp0,
                bytes memory pp1
            ) = abi.decode(data, (address, bytes, bytes, bytes, bytes, bytes));
            require(isKeyCurrency[p], ""!keyCurrency"");
            (, uint256 bn, ) = sushiCSSR.saveState(bd);
            address pair = SushiswapV2Library.pairFor(
                sushiCSSR.uniswapFactory(),
                _asset,
                p
            );
            sushiCSSR.saveReserve(bn, pair, ap, rp, pp0, pp1);
        } else {
            revert(""!supported type"");
        }
        return getPrice(_asset);
    }

    function getPriceRaw(address _asset)
        public
        view
        returns (uint256 sumPrice, uint256 sumLiquidity)
    {
        for (uint256 i = 0; i < keyCurrency.length; i++) {
            address key = keyCurrency[i];
            float memory currencyPrice = cssrRouter.getPrice(key);
            if (_asset == key) {
                continue;
            }
            try uniswapCSSR.getLiquidity(_asset, key) returns (uint256 liq) {
                uint256 liquidityValue = convertToValue(liq, currencyPrice);
                if (liquidityValue >= minimumLiquidity) {
                    sumLiquidity += liquidityValue;
                    sumPrice +=
                        convertToValue(
                            uniswapCSSR.getExchangeRatio(_asset, key),
                            currencyPrice
                        ) *
                        liquidityValue;
                }
            } catch {
            }
            try sushiCSSR.getLiquidity(_asset, key) returns (uint256 liq) {
                uint256 liq = sushiCSSR.getLiquidity(_asset,key);
                uint256 liquidityValue = convertToValue(liq, currencyPrice);
                if (liquidityValue >= minimumLiquidity) {
                    sumLiquidity += liquidityValue;
                    sumPrice +=
                        convertToValue(
                            sushiCSSR.getExchangeRatio(_asset, key),
                            currencyPrice
                        ) *
                        liquidityValue;
                }
            } catch {
            }
        }
    }

    function getPrice(address _asset)
        public
        view
        override
        returns (float memory price)
    {
        (uint256 sumPrice, uint256 sumLiquidity) = getPriceRaw(_asset);
        require(sumLiquidity > 0, ""!updated"");
        return float({numerator: sumPrice / 2**112, denominator: sumLiquidity});
    }

    function getLiquidity(address _asset)
        external
        view
        override
        returns (uint256 sum)
    {
        for (uint256 i = 0; i < keyCurrency.length; i++) {
            address key = keyCurrency[i];
            float memory currencyPrice = cssrRouter.getPrice(key);
            if (_asset == key) {
                continue;
            }
            try uniswapCSSR.getLiquidity(_asset, key) returns (uint256 liq) {
                uint256 liquidityValue = convertToValue(liq, currencyPrice);
                if (liquidityValue >= minimumLiquidity) {
                    sum += liquidityValue;
                }
            } catch {
            }
            try sushiCSSR.getLiquidity(_asset, key) returns (uint256 liq) {
                uint256 liquidityValue = convertToValue(liq, currencyPrice);
                if (liquidityValue >= minimumLiquidity) {
                    sum += liquidityValue;
                }
            } catch {
            }
        }
    }

    function aboveLiquidity(address _asset, address _pairedWith)
        public
        view
        returns (bool)
    {
        try uniswapCSSR.getLiquidity(_asset, _pairedWith) returns (
            uint256 liq
        ) {
            float memory price = cssrRouter.getPrice(_pairedWith);
            return convertToValue(liq, price) >= minimumLiquidity;
        } catch {
            try sushiCSSR.getLiquidity(_asset, _pairedWith) returns (
                uint256 liq
            ) {
                float memory price = cssrRouter.getPrice(_pairedWith);
                return convertToValue(liq, price) >= minimumLiquidity;
            } catch {
                return false;
            }
        }
    }

    function convertToValue(uint256 _amount, float memory _price)
        internal
        pure
        returns (uint256)
    {
        return (_amount * _price.numerator) / _price.denominator;
    }
}",1687
RealWorld_BA_42_ICurveVotingEscrow_RealWord_20240820163028.log,42,ICurveVotingEscrow,4334,4490,8824,67.0,0.11147,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

interface ICurveVotingEscrow {
    function create_lock(uint256, uint256) external;

    function increase_amount(uint256) external;

    function increase_unlock_time(uint256) external;

    function withdraw() external;

    function smart_wallet_checker() external view returns (address);
}",79
RealWorld_BA_42_UniswapV2LPAdapter_RealWord_20240820153441.log,42,UniswapV2LPAdapter,20749,5278,26027,88.0,0.209305,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol"";
import {UniswapV2Library} from ""@mochifi/library/contracts/UniswapV2Library.sol"";
import ""../interfaces/ICSSRAdapter.sol"";
import ""../interfaces/ICSSRRouter.sol"";
import ""../interfaces/IUniswapV2CSSR.sol"";
contract UniswapV2LPAdapter is ICSSRAdapter {
    using Float for float;

    ICSSRRouter public immutable router;
    IUniswapV2CSSR public immutable cssr;
    address public immutable weth;
    address public immutable factory;
    //using uint256 since we don't need 224 for this
    uint256 public constant Q112 = 2**112;

    constructor(address _weth, address _factory, address _router, address _cssr) {
        weth = _weth;
        router = ICSSRRouter(_router);
        cssr = IUniswapV2CSSR(_cssr);
        factory = _factory;
    }

    function support(address _asset) external view override returns(bool) {
        address underlying = getUnderlyingAsset(IUniswapV2Pair(_asset));
        address calculatedAddress = UniswapV2Library.pairFor(factory, underlying, weth);
        return _asset == calculatedAddress;
    }

    function update(address _asset, bytes memory _proof) external override returns(float memory price) {
        address underlying = getUnderlyingAsset(IUniswapV2Pair(_asset));
        router.update(_asset, _proof);
        return _getPrice(IUniswapV2Pair(_asset), underlying);
    }

    function getUnderlyingAsset(IUniswapV2Pair _pair) public view returns(address underlyingAsset) {
        if (_pair.token0() == weth) {
            underlyingAsset = _pair.token1();
        } else if (_pair.token1() == weth) {
            underlyingAsset = _pair.token0();
        } else {
            revert(""!eth paired"");
        }
    }

    function getPrice(address _asset) external view override returns(float memory price){
        IUniswapV2Pair pair = IUniswapV2Pair(_asset);
        address underlying = getUnderlyingAsset(pair);
        return _getPrice(pair, underlying);
    }

    function _getPrice(IUniswapV2Pair _pair, address _underlying) internal view returns(float memory price) {
        uint256 eAvg = cssr.getExchangeRatio(_underlying, weth);
        (uint112 _reserve0, uint112 _reserve1,) = _pair.getReserves();
        uint256 aPool; // current asset pool
        uint256 ePool; // current weth pool
        if (_pair.token0() == _underlying) {
            aPool = uint(_reserve0);
            ePool = uint(_reserve1);
        } else {
            aPool = uint(_reserve1);
            ePool = uint(_reserve0);
        }

        uint256 eCurr = ePool * Q112 / aPool; // current price of 1 token in weth
        uint256 ePoolCalc; // calculated weth pool

        if (eCurr < eAvg) {
            // flashloan buying weth
            uint256 sqrtd = ePool * (
                (ePool * 9)
                +(aPool * 3988000 * eAvg / Q112)
            );
            uint256 eChange = (sqrt(sqrtd) - (ePool * 1997)) / 2000;
            ePoolCalc = ePool + eChange;
        } else {
            // flashloan selling weth
            uint256 a = aPool * eAvg;
            uint256 b = a * 9 / Q112;
            uint256 c = ePool * 3988000;
            uint256 sqRoot = sqrt( (a / Q112) * (b + c));
            uint256 d = a * 3 / Q112;
            uint256 eChange = ePool - ((d + sqRoot) / 2000);
            ePoolCalc = ePool - eChange;
        }

        uint256 num = ePoolCalc * 2;
        uint256 priceInEth;
        if (num > Q112) {
            priceInEth = (num / _pair.totalSupply()) * Q112;
        } else {
            priceInEth = num * Q112 / _pair.totalSupply();
        }

        return float({numerator:priceInEth, denominator: Q112}).mul(router.getPrice(weth));
    }

    function getLiquidity(address _asset) external view override returns(uint256) {
        address underlying = getUnderlyingAsset(IUniswapV2Pair(_asset));
        return router.getLiquidity(underlying);
    }

    function sqrt(uint x) internal pure returns (uint y) {
        if (x > 3) {
            uint z = x / 2 + 1;
            y = x;
            while (z < y) {
                y = z;
                z = (x / z + z) / 2;
            }
        } else if (x != 0) {
            y = 1;
        }
    }
}",1128
RealWorld_BA_42_UniswapV2Library_RealWord_20240820164500.log,42,UniswapV2Library,22216,5466,27682,89.0,0.2204,"// SPDX-License-Identifier: MIT
// fetched from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol
// slightly modified to remove SafeMath and 0.8 compatible
pragma solidity ^0.8.0;

import { IUniswapV2Pair } from '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';

library UniswapV2Library {

    // returns sorted token addresses, used to handle return values from pairs sorted in this order
    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
    }

    // calculates the CREATE2 address for a pair without making any external calls
    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {
        (address token0, address token1) = sortTokens(tokenA, tokenB);
        pair = address(bytes20(uint160(uint256(keccak256(abi.encodePacked(
                hex'ff',
                factory,
                keccak256(abi.encodePacked(token0, token1)),
                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'
            ))))));
    }

    // fetches and sorts the reserves for a pair
    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {
        (address token0,) = sortTokens(tokenA, tokenB);
        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();
        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
    }

    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset
    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {
        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');
        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        amountB = amountA * reserveB / reserveA;
    }

    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {
        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint amountInWithFee = amountIn * 997;
        uint numerator = amountInWithFee * reserveOut;
        uint denominator = reserveIn * 1000 + amountInWithFee;
        amountOut = numerator / denominator;
    }

    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {
        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint numerator = reserveIn * amountOut * 1000;
        uint denominator = (reserveOut - amountOut) * 997;
        amountIn = (numerator / denominator) + 1;
    }

    // performs chained getAmountOut calculations on any number of pairs
    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[0] = amountIn;
        for (uint i; i < path.length - 1; i++) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);
            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);
        }
    }

    // performs chained getAmountIn calculations on any number of pairs
    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[amounts.length - 1] = amountOut;
        for (uint i = path.length - 1; i > 0; i--) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);
            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);
        }
    }
}",1200
RealWorld_BA_42_IMochiProfile_RealWord_20240820162345.log,42,IMochiProfile,8615,5238,13853,92.0,0.147835,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@mochifi/library/contracts/Float.sol"";

enum AssetClass {
    Invalid,
    Stable,
    Alpha,
    Gamma,
    Delta,
    Zeta,
    Sigma,
    Revoked
}

interface IMochiProfile {
    function assetClass(address _asset) external view returns (AssetClass);

    function liquidityRequirement() external view returns (uint256);

    function minimumDebt() external view returns (uint256);

    function changeAssetClass(
        address[] calldata _asset,
        AssetClass[] calldata _class
    ) external;

    function changeLiquidityRequirement(uint256 _requirement) external;

    function changeMinimumDebt(uint256 _debt) external;

    function calculateFeeIndex(
        address _asset,
        uint256 _currentIndex,
        uint256 _lastAccrued
    ) external view returns (uint256);

    function creditCap(address _asset) external view returns (uint256);

    function delay() external view returns (uint256);

    function liquidationFactor(address _asset)
        external
        view
        returns (float memory);

    function maxCollateralFactor(address _asset)
        external
        view
        returns (float memory);

    function stabilityFee(address _asset) external view returns (float memory);

    function liquidationFee(address _asset)
        external
        view
        returns (float memory);

    function keeperFee(address _asset) external view returns (float memory);

    function utilizationRatio(address _asset)
        external
        view
        returns (float memory);
}",342
RealWorld_BA_42_AccountVerifier_RealWord_20240820165541.log,42,AccountVerifier,5925,4850,10775,83.0,0.126625,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;
pragma abicoder v2;

import { BlockVerifier } from ""./BlockVerifier.sol"";
import { MerklePatriciaVerifier } from ""./MerklePatriciaVerifier.sol"";
import { Rlp } from ""./Rlp.sol"";


library AccountVerifier {
    function getAccountStorageRoot(
        address account,
        bytes32 stateRoot,
        bytes memory accountProof
    ) internal pure returns(
        bytes32 storageRootHash
    ) {
        bytes memory accountDetailsBytes = MerklePatriciaVerifier.getValueFromProof(stateRoot, keccak256(abi.encodePacked(account)), accountProof);
        Rlp.Item[] memory accountDetails = Rlp.toList(Rlp.toItem(accountDetailsBytes));
        return Rlp.toBytes32(accountDetails[2]);
    }
}",172
RealWorld_BA_42_SushiswapV2CSSR_RealWord_20240820153930.log,42,SushiswapV2CSSR,34393,5462,39855,91.0,0.281205,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;
pragma abicoder v2;

import {SushiswapV2Library} from ""@mochifi/library/contracts/SushiswapV2Library.sol"";
import {UQ112x112} from ""@mochifi/library/contracts/UQ112x112.sol"";
import {BlockVerifier} from ""@mochifi/library/contracts/BlockVerifier.sol"";
import {MerklePatriciaVerifier} from ""@mochifi/library/contracts/MerklePatriciaVerifier.sol"";
import {Rlp} from ""@mochifi/library/contracts/Rlp.sol"";
import {AccountVerifier} from ""@mochifi/library/contracts/AccountVerifier.sol"";
import {IUniswapV2Pair} from ""@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol"";
import ""../interfaces/IUniswapV2CSSR.sol"";

contract SushiswapV2CSSR is IUniswapV2CSSR {
    address public immutable override uniswapFactory;
    using UQ112x112 for uint224;

    bytes32 public constant reserveTimestampSlotHash =
        keccak256(abi.encodePacked(uint256(8)));
    bytes32 public constant token0Slot =
        keccak256(abi.encodePacked(uint256(9)));
    bytes32 public constant token1Slot =
        keccak256(abi.encodePacked(uint256(10)));

    uint256 public constant WINDOW_SIZE = 10 minutes;

    mapping(uint256 => Window) public window;
    // blockNumber => stateRoot
    mapping(uint256 => BlockData) public blockState;
    // blockNumber => pair => observedData
    mapping(uint256 => mapping(address => ObservedData)) public observedData;

    constructor(address _uniswapFactory) {
        uniswapFactory = _uniswapFactory;
    }

    // stores block data
    function saveState(bytes memory blockData)
        external
        override
        returns (
            bytes32 stateRoot,
            uint256 blockNumber,
            uint256 blockTimestamp
        )
    {
        (stateRoot, blockTimestamp, blockNumber) = BlockVerifier
            .extractStateRootAndTimestamp(blockData);
        if (blockState[blockNumber].blockTimestamp != 0) {
            return (stateRoot, blockNumber, blockTimestamp);
        }
        blockState[blockNumber] = BlockData({
            blockTimestamp: blockTimestamp,
            stateRoot: stateRoot
        });
        updateWindow(uint128(blockNumber), blockTimestamp);
    }

    function updateWindow(uint128 blockNumber, uint256 timestamp) internal {
        uint256 idx = windowIndex(timestamp);
        Window memory _window = window[idx];
        if (_window.from == 0 && _window.to == 0) {
            _window = Window({from: blockNumber, to: blockNumber});
        } else if (_window.from > blockNumber) {
            _window = Window({from: blockNumber, to: _window.to});
        } else if (_window.to < blockNumber) {
            _window = Window({from: _window.from, to: blockNumber});
        }
        window[idx] = _window;
    }

    function windowIndex(uint256 timestamp) internal pure returns (uint256) {
        return (timestamp / WINDOW_SIZE) * WINDOW_SIZE;
    }

    // does not cair about pair address since all it does is save the data
    function saveReserve(
        uint256 blockNumber,
        address pair,
        bytes memory accountProof,
        bytes memory reserveProof,
        bytes memory price0Proof,
        bytes memory price1Proof
    ) external override returns (ObservedData memory data) {
        bytes32 stateRoot = blockState[blockNumber].stateRoot;
        if (observedData[blockNumber][pair].reserveTimestamp != 0) {
            return observedData[blockNumber][pair];
        }
        bytes32 storageRoot = AccountVerifier.getAccountStorageRoot(
            pair,
            stateRoot,
            accountProof
        );
        (
            data.reserve0,
            data.reserve1,
            data.reserveTimestamp
        ) = unpackReserveData(
            Rlp.rlpBytesToUint256(
                MerklePatriciaVerifier.getValueFromProof(
                    storageRoot,
                    reserveTimestampSlotHash,
                    reserveProof
                )
            )
        );
        data.price0Data = Rlp.rlpBytesToUint256(
            MerklePatriciaVerifier.getValueFromProof(
                storageRoot,
                token0Slot,
                price0Proof
            )
        );
        data.price1Data = Rlp.rlpBytesToUint256(
            MerklePatriciaVerifier.getValueFromProof(
                storageRoot,
                token1Slot,
                price1Proof
            )
        );
        observedData[blockNumber][pair] = data;
    }

    function unpackReserveData(uint256 packedReserveData)
        internal
        pure
        returns (
            uint112 reserve0,
            uint112 reserve1,
            uint32 reserveTimestamp
        )
    {
        reserve0 = uint112(packedReserveData & (2**112 - 1));
        reserve1 = uint112((packedReserveData >> 112) & (2**112 - 1));
        reserveTimestamp = uint32(packedReserveData >> (112 + 112));
    }

    // locked **denominator** amount paired with token
    function getLiquidity(address token, address denominator)
        external
        view
        override
        returns (uint256)
    {
        IUniswapV2Pair pair = IUniswapV2Pair(
            SushiswapV2Library.pairFor(uniswapFactory, token, denominator)
        );
        Window memory currentWindow = window[windowIndex(block.timestamp)];
        uint128 lastObserved = currentWindow.to;
        if (lastObserved == 0) {
            lastObserved = window[windowIndex(block.timestamp) - WINDOW_SIZE]
                .to;
            require(lastObserved != 0, ""!observed"");
        }
        BlockData memory state = blockState[lastObserved];
        require(block.timestamp - state.blockTimestamp < WINDOW_SIZE, ""stale"");
        bool denominationTokenIs0;
        if (pair.token0() == denominator) {
            denominationTokenIs0 = true;
        } else if (pair.token1() == denominator) {
            denominationTokenIs0 = false;
        } else {
            revert(""denominationToken invalid"");
        }
        ObservedData memory historicData = observedData[lastObserved][
            address(pair)
        ];
        return
            denominationTokenIs0
                ? historicData.reserve0
                : historicData.reserve1;
    }

    function getExchangeRatio(address token, address denominator)
        external
        view
        override
        returns (uint256)
    {
        IUniswapV2Pair pair = IUniswapV2Pair(
            SushiswapV2Library.pairFor(uniswapFactory, token, denominator)
        );
        Window memory currentWindow = window[windowIndex(block.timestamp)];
        uint128 lastObserved = currentWindow.to;
        if (lastObserved == 0) {
            lastObserved = window[windowIndex(block.timestamp) - WINDOW_SIZE]
                .to;
            require(lastObserved != 0, ""!observed"");
        }
        BlockData memory state = blockState[lastObserved];
        require(block.timestamp - state.blockTimestamp < WINDOW_SIZE, ""stale"");
        bool denominationTokenIs0;
        if (pair.token0() == denominator) {
            denominationTokenIs0 = true;
        } else if (pair.token1() == denominator) {
            denominationTokenIs0 = false;
        } else {
            revert(""denominationToken invalid"");
        }
        //now calculate
        //get historic data
        ObservedData memory historicData = observedData[lastObserved][
            address(pair)
        ];
        uint256 historicePriceCumulative = calculatedPriceCumulative(
            denominationTokenIs0
                ? historicData.reserve0
                : historicData.reserve1,
            denominationTokenIs0
                ? historicData.reserve1
                : historicData.reserve0,
            denominationTokenIs0
                ? historicData.price1Data
                : historicData.price0Data,
            state.blockTimestamp - uint256(historicData.reserveTimestamp)
        );
        //get current data
        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = pair
            .getReserves();
        uint256 currentPriceCumulative = calculatedPriceCumulative(
            denominationTokenIs0 ? reserve0 : reserve1,
            denominationTokenIs0 ? reserve1 : reserve0,
            denominationTokenIs0
                ? pair.price1CumulativeLast()
                : pair.price0CumulativeLast(),
            block.timestamp - blockTimestampLast
        );
        return
            (currentPriceCumulative - historicePriceCumulative) /
            (block.timestamp - state.blockTimestamp);
    }

    function calculatedPriceCumulative(
        uint112 reserve,
        uint112 pairedReserve,
        uint256 priceCumulativeLast,
        uint256 timeElapsed
    ) internal pure returns (uint256) {
        if (timeElapsed == 0) {
            return priceCumulativeLast;
        }
        return
            priceCumulativeLast +
            timeElapsed *
            uint256(UQ112x112.encode(reserve).uqdiv(pairedReserve));
    }
}",1979
RealWorld_BA_42_DutchAuctionLiquidator_RealWord_20240820160828.log,42,DutchAuctionLiquidator,18101,5343,23444,84.0,0.197365,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol"";
import ""@mochifi/library/contracts/Float.sol"";
import ""@mochifi/library/contracts/BeaconProxyDeployer.sol"";
import ""../interfaces/ILiquidator.sol"";
import ""../interfaces/IMochiEngine.sol"";

contract DutchAuctionLiquidator is ILiquidator {
    using Float for uint256;
    IMochiEngine public immutable engine;

    uint256 public constant DURATION = 2 days / 15;

    struct Auction {
        uint256 nftId;
        address vault;
        uint256 startedAt;
        uint256 boughtAt;
        uint256 collateral;
        uint256 debt;
    }

    mapping(uint256 => Auction) public auctions;

    constructor(address _engine) {
        engine = IMochiEngine(_engine);
    }

    function auctionId(address asset, uint256 nftId)
        public
        pure
        returns (uint256)
    {
        return uint256(keccak256(abi.encodePacked(asset, nftId)));
    }

    function price(uint256 _auctionId) external view returns (uint256) {
        Auction memory auction = auctions[_auctionId];
        return auction.debt + currentLiquidationFee(_auctionId);
    }

    function currentLiquidationFee(uint256 _auctionId)
        public
        view
        returns (uint256 liquidationFee)
    {
        Auction memory auction = auctions[_auctionId];
        liquidationFee = auction
            .debt
            .multiply(
                engine.mochiProfile().liquidationFee(
                    address(IMochiVault(auction.vault).asset())
                )
            )
            .multiply(
                float({
                    numerator: auction.startedAt + DURATION > block.number
                        ? auction.startedAt + DURATION - block.number
                        : 0,
                    denominator: DURATION
                })
            );
    }

    function triggerLiquidation(address _asset, uint256 _nftId)
        external
        override
    {
        IMochiVault vault = engine.vaultFactory().getVault(_asset);
        Auction storage auction = auctions[auctionId(_asset, _nftId)];
        require(auction.startedAt == 0 || auction.boughtAt != 0, ""on going"");
        uint256 debt = vault.currentDebt(_nftId);
        (, uint256 collateral, , , ) = vault.details(_nftId);

        vault.liquidate(_nftId, collateral, debt);

        auction.nftId = _nftId;
        auction.vault = address(vault);
        auction.startedAt = block.number;
        auction.boughtAt = 0;
        auction.collateral = collateral;
        auction.debt = debt;

        uint256 liquidationFee = debt.multiply(
            engine.mochiProfile().liquidationFee(address(_asset))
        );
        emit Triggered(auctionId(_asset, _nftId), debt + liquidationFee);
    }

    function settleLiquidation(
        uint256 _auctionId,
        uint256 _collateral,
        uint256 _repaid
    ) internal {
        Auction storage auction = auctions[_auctionId];
        require(auction.boughtAt == 0, ""liquidated"");
        IMochiVault vault = IMochiVault(auction.vault);
        //repay the debt first
        engine.usdm().transferFrom(msg.sender, address(this), _repaid);
        engine.usdm().burn(_repaid);
        IERC20 asset = vault.asset();
        auction.boughtAt = block.number;
        asset.transfer(msg.sender, _collateral);
        //transfer liquidation fee to feePool
        uint256 liquidationFee = currentLiquidationFee(_auctionId);
        engine.usdm().transferFrom(
            msg.sender,
            address(engine.feePool()),
            liquidationFee
        );

        emit Settled(_auctionId, _repaid + liquidationFee);
    }

    function buy(uint256 _auctionId) external {
        Auction memory auction = auctions[_auctionId];
        require(auction.startedAt != 0 && auction.boughtAt == 0, ""!on going"");
        settleLiquidation(_auctionId, auction.collateral, auction.debt);
    }
}",933
RealWorld_BA_42_MochiVaultFactory_RealWord_20240820160954.log,42,MochiVaultFactory,9081,5452,14533,111.0,0.154445,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@mochifi/library/contracts/Beacon.sol"";
import ""@mochifi/library/contracts/BeaconProxyDeployer.sol"";
import ""../interfaces/IMochiEngine.sol"";
import ""../interfaces/IMochiVaultFactory.sol"";

contract MochiVaultFactory is IMochiVaultFactory {
    IMochiEngine public immutable engine;
    Beacon public immutable beacon;
    address public template;

    constructor(address _engine) {
        beacon = new Beacon(address(0));
        engine = IMochiEngine(_engine);
    }

    function updateTemplate(address _newTemplate) external override {
        require(msg.sender == engine.governance(), ""!gov"");
        address(beacon).call(abi.encode(_newTemplate));
        template = _newTemplate;
    }

    function deployVault(address _asset)
        external
        override
        returns (IMochiVault)
    {
        bytes memory initCode = abi.encodeWithSelector(
            bytes4(keccak256(""initialize(address)"")),
            _asset
        );
        return
            IMochiVault(BeaconProxyDeployer.deploy(address(beacon), initCode));
    }

    function getVault(address _asset)
        external
        view
        override
        returns (IMochiVault)
    {
        bytes memory initCode = abi.encodeWithSelector(
            bytes4(keccak256(""initialize(address)"")),
            _asset
        );
        return
            IMochiVault(
                BeaconProxyDeployer.calculateAddress(
                    address(this),
                    address(beacon),
                    initCode
                )
            );
    }
}",348
RealWorld_BA_42_MochiVault_RealWord_20240820161147.log,42,MochiVault,51414,5273,56687,93.0,0.36253,"// SPDX-License-Identifier: (c) Mochi.Fi, 2021

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@mochifi/library/contracts/CheapERC20.sol"";
import ""../interfaces/IERC3156FlashLender.sol"";
import ""../interfaces/IMochiVault.sol"";
import ""../interfaces/IMochiEngine.sol"";
import ""../interfaces/IUSDM.sol"";

contract MochiVault is Initializable, IMochiVault, IERC3156FlashLender {
    using Float for uint256;
    using CheapERC20 for IERC20;

    bytes32 public constant CALLBACK_SUCCESS =
        keccak256(""ERC3156FlashBorrower.onFlashLoan"");

    /// immutable variables
    IMochiEngine public immutable engine;
    IERC20 public override asset;

    /// for accruing debt
    uint256 public debtIndex;
    uint256 public lastAccrued;

    /// storage variables
    uint256 public override deposits;
    uint256 public override debts;
    int256 public override claimable;

    ///Mochi waits until the stability fees hit 1% and then starts calculating debt after that.
    ///E.g. If the stability fees are 10% for a year
    ///Mochi will wait 36.5 days (the time period required for the pre-minted 1%)

    /// result
    uint256 public liquidated;

    mapping(uint256 => Detail) public override details;
    mapping(uint256 => uint256) public lastDeposit;

    modifier updateDebt(uint256 _id) {
        accrueDebt(_id);
        _;
    }

    modifier wait(uint256 _id) {
        require(
            lastDeposit[_id] + engine.mochiProfile().delay() <= block.timestamp,
            ""!wait""
        );
        accrueDebt(_id);
        _;
    }

    constructor(address _engine) {
        engine = IMochiEngine(_engine);
    }

    function initialize(address _asset) external override initializer {
        asset = IERC20(_asset);
        debtIndex = 1e18;
        lastAccrued = block.timestamp;
    }

    function liveDebtIndex() public view override returns (uint256 index) {
        return
            engine.mochiProfile().calculateFeeIndex(
                address(asset),
                debtIndex,
                lastAccrued
            );
    }

    function status(uint256 _id) public view override returns (Status) {
        return details[_id].status;
    }

    function currentDebt(uint256 _id) public view override returns (uint256) {
        require(details[_id].status != Status.Invalid, ""invalid"");
        uint256 newIndex = liveDebtIndex();
        return (details[_id].debt * newIndex) / details[_id].debtIndex;
    }

    function accrueDebt(uint256 _id) public {
        // global debt for vault
        // first, increase gloabal debt;
        uint256 currentIndex = liveDebtIndex();
        uint256 increased = (debts * currentIndex) / debtIndex - debts;
        debts += increased;
        claimable += int256(increased);
        // update global debtIndex
        debtIndex = currentIndex;
        lastAccrued = block.timestamp;
        // individual debt
        if (_id != type(uint256).max && details[_id].debtIndex < debtIndex) {
            require(details[_id].status != Status.Invalid, ""invalid"");
            if (details[_id].debt != 0) {
                uint256 increasedDebt = (details[_id].debt * debtIndex) /
                    details[_id].debtIndex -
                    details[_id].debt;
                uint256 discountedDebt = increasedDebt.multiply(
                    engine.discountProfile().discount(engine.nft().ownerOf(_id))
                );
                debts -= discountedDebt;
                claimable -= int256(discountedDebt);
                details[_id].debt += (increasedDebt - discountedDebt);
            }
            details[_id].debtIndex = debtIndex;
        }
    }

    function increase(
        uint256 _id,
        uint256 _deposits,
        uint256 _borrows,
        address _referrer,
        bytes memory _data
    ) external {
        if (_id == type(uint256).max) {
            // mint if _id is -1
            _id = mint(msg.sender, _referrer);
        }
        if (_deposits > 0) {
            deposit(_id, _deposits);
        }
        if (_borrows > 0) {
            borrow(_id, _borrows, _data);
        }
    }

    function decrease(
        uint256 _id,
        uint256 _withdraws,
        uint256 _repays,
        bytes memory _data
    ) external {
        if (_repays > 0) {
            repay(_id, _repays);
        }
        if (_withdraws > 0) {
            withdraw(_id, _withdraws, _data);
        }
    }

    function mint(address _recipient, address _referrer)
        public
        returns (uint256 id)
    {
        id = engine.nft().mint(address(asset), _recipient);
        details[id].debtIndex = liveDebtIndex();
        details[id].status = Status.Idle;
        details[id].referrer = _referrer;
    }

    /// anyone can deposit collateral to given id
    /// it will even allow depositing to liquidated vault so becareful when depositing
    function deposit(uint256 _id, uint256 _amount)
        public
        override
        updateDebt(_id)
    {
        // should it be able to deposit if invalid?
        require(engine.nft().asset(_id) == address(asset), ""!asset"");
        require(
            details[_id].status == Status.Idle ||
                details[_id].status == Status.Collaterized ||
                details[_id].status == Status.Active,
            ""!depositable""
        );
        lastDeposit[_id] = block.timestamp;
        deposits += _amount;
        details[_id].collateral += _amount;
        if (details[_id].status == Status.Idle) {
            details[_id].status = Status.Collaterized;
        }
        asset.cheapTransferFrom(msg.sender, address(this), _amount);
    }

    /// should only be able to withdraw if status is not liquidatable
    function withdraw(
        uint256 _id,
        uint256 _amount,
        bytes memory _data
    ) public override wait(_id) {
        require(engine.nft().ownerOf(_id) == msg.sender, ""!approved"");
        require(engine.nft().asset(_id) == address(asset), ""!asset"");
        // update prior to interaction
        float memory price = engine.cssr().update(address(asset), _data);
        require(
            !_liquidatable(
                details[_id].collateral - _amount,
                price,
                details[_id].debt
            ),
            ""!healthy""
        );
        float memory cf = engine.mochiProfile().maxCollateralFactor(
            address(asset)
        );
        uint256 maxMinted = (details[_id].collateral - _amount)
            .multiply(cf)
            .multiply(price);
        require(details[_id].debt <= maxMinted, "">cf"");
        deposits -= _amount;
        details[_id].collateral -= _amount;
        if (details[_id].collateral == 0) {
            details[_id].status = Status.Idle;
        }
        asset.cheapTransfer(engine.nft().ownerOf(_id), _amount);
    }

    function borrow(
        uint256 _id,
        uint256 _amount,
        bytes memory _data
    ) public override updateDebt(_id) {
        // update prior to interaction
        float memory price = engine.cssr().update(address(asset), _data);
        float memory cf = engine.mochiProfile().maxCollateralFactor(
            address(asset)
        );
        uint256 maxMinted = details[_id].collateral.multiply(cf).multiply(
            price
        );
        require(engine.nft().ownerOf(_id) == msg.sender, ""!approved"");
        require(engine.nft().asset(_id) == address(asset), ""!asset"");
        if(details[_id].debt + _amount > maxMinted) {
            _amount = maxMinted - details[_id].debt;
        }
        if(engine.mochiProfile().creditCap(address(asset)) < debts + _amount) {
            _amount = engine.mochiProfile().creditCap(address(asset)) - debts;
        }
        uint256 increasingDebt = (_amount * 1005) / 1000;
        uint256 totalDebt = details[_id].debt + increasingDebt;
        require(details[_id].debt + _amount >= engine.mochiProfile().minimumDebt(), ""<minimum"");
        require(
            !_liquidatable(details[_id].collateral, price, totalDebt),
            ""!healthy""
        );
        mintFeeToPool(increasingDebt - _amount, details[_id].referrer);
        // this will ensure debtIndex will not increase on further `updateDebt` triggers
        details[_id].debtIndex =
            (details[_id].debtIndex * (totalDebt)) /
            (details[_id].debt + _amount);
        details[_id].debt = totalDebt;
        details[_id].status = Status.Active;
        debts += _amount;
        engine.minter().mint(msg.sender, _amount);
    }

    /// someone sends usdm to this address and repays the debt
    /// will payback the leftover usdm
    function repay(uint256 _id, uint256 _amount)
        public
        override
        updateDebt(_id)
    {
        if (_amount > details[_id].debt) {
            _amount = details[_id].debt;
        }
        require(_amount > 0, ""zero"");
        if (debts < _amount) {
            // safe gaurd to some underflows
            debts = 0;
        } else {
            debts -= _amount;
        }
        details[_id].debt -= _amount;
        if (details[_id].debt == 0) {
            details[_id].status = Status.Collaterized;
        }
        engine.usdm().transferFrom(msg.sender, address(this), _amount);
        engine.usdm().burn(_amount);
    }

    function liquidate(
        uint256 _id,
        uint256 _collateral,
        uint256 _usdm
    ) external override updateDebt(_id) {
        require(msg.sender == address(engine.liquidator()), ""!liquidator"");
        require(engine.nft().asset(_id) == address(asset), ""!asset"");
        float memory price = engine.cssr().getPrice(address(asset));
        require(
            _liquidatable(details[_id].collateral, price, currentDebt(_id)),
            ""healthy""
        );

        debts -= _usdm;

        details[_id].collateral -= _collateral;
        details[_id].debt -= _usdm;

        asset.cheapTransfer(msg.sender, _collateral);
    }

    /// @dev returns if status is liquidatable with given `_collateral` amount and `_debt` amount
    /// @notice should return false if _collateral * liquidationLimit < _debt
    function _liquidatable(
        uint256 _collateral,
        float memory _price,
        uint256 _debt
    ) internal view returns (bool) {
        float memory lf = engine.mochiProfile().liquidationFactor(
            address(asset)
        );
        // when debt is lower than liquidation value, it can be liquidated
        return _collateral.multiply(lf) < _debt.divide(_price);
    }

    function liquidatable(uint256 _id) external view returns (bool) {
        float memory price = engine.cssr().getPrice(address(asset));
        return _liquidatable(details[_id].collateral, price, currentDebt(_id));
    }

    function claim() external updateDebt(type(uint256).max) {
        require(claimable > 0, ""!claimable"");
        // reserving 25% to prevent potential risks
        uint256 toClaim = (uint256(claimable) * 75) / 100;
        mintFeeToPool(toClaim, address(0));
    }

    function mintFeeToPool(uint256 _amount, address _referrer) internal {
        claimable -= int256(_amount);
        if (address(0) != _referrer) {
            engine.minter().mint(address(engine.referralFeePool()), _amount);
            engine.referralFeePool().addReward(_referrer);
        } else {
            engine.minter().mint(address(engine.treasury()), _amount);
        }
    }

    // Flash Loan
    function maxFlashLoan(address _token)
        external
        view
        override
        returns (uint256)
    {
        require(_token == address(asset), ""!supported"");
        return asset.balanceOf(address(this));
    }

    function flashFee(address _token, uint256 _amount)
        public
        view
        override
        returns (uint256)
    {
        //should return 0.1337% * _amount;
        require(_token == address(asset), ""!supported"");
        return (_amount * 1337) / 1000000;
    }

    function flashLoan(
        IERC3156FlashBorrower _receiver,
        address _token,
        uint256 _amount,
        bytes calldata _data
    ) external override returns (bool) {
        require(_token == address(asset), ""!supported"");
        uint256 fee = flashFee(_token, _amount);
        asset.cheapTransfer(address(_receiver), _amount);
        require(
            _receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) ==
                CALLBACK_SUCCESS,
            ""!callback""
        );
        asset.cheapTransferFrom(address(_receiver), address(this), _amount);
        asset.cheapTransferFrom(address(_receiver), engine.treasury(), fee);
        return true;
    }
}",3028
RealWorld_BA_42_DummyTemplate_RealWord_20240820165952.log,42,DummyTemplate,3900,3909,7809,67.0,0.09768,"// SPDX-License-Identifier: AGPL-3.0

/**
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

pragma solidity ^0.8.0;

contract DummyTemplate {
    string public name;
    
    function initialize(string memory _name) external returns (bool) {
        name = _name;
        return true;
    }
}",74
RealWorld_BA_42_MochiTreasuryV0_RealWord_20240820160413.log,42,MochiTreasuryV0,14405,6278,20683,93.0,0.197585,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol"";
import ""../interfaces/IMochiEngine.sol"";
import ""../interfaces/ICurveVotingEscrow.sol"";

contract MochiTreasuryV0 {
    IMochiEngine public immutable engine;

    IUniswapV2Router02 public immutable uniswapRouter;

    IERC20 public immutable crv;
    ICurveVotingEscrow public immutable veCrv;
    bool public lockCrv;
    uint256 public operationShare;
    uint256 public veCRVShare;

    constructor(
        address _engine,
        address _uniswap,
        address _crv,
        address _veCrv
    ) {
        engine = IMochiEngine(_engine);
        uniswapRouter = IUniswapV2Router02(_uniswap);
        crv = IERC20(_crv);
        veCrv = ICurveVotingEscrow(_veCrv);
        lockCrv = false;
    }

    receive() external payable {}

    function withdrawCRV() external {
        require(msg.sender == engine.governance(), ""!gov"");
        crv.transfer(msg.sender, crv.balanceOf(address(this)));
    }

    function withdrawLock() external {
        veCrv.withdraw();
    }

    function veCRVInitialize() external {
        require(lockCrv, ""!lock"");
        updateFee();
        _buyCRV();
        veCrv.create_lock(
            crv.balanceOf(address(this)),
            block.timestamp + 90 days
        );
    }

    function toggleLocking() external {
        require(msg.sender == engine.governance(), ""!gov"");
        lockCrv = !lockCrv;
    }

    function updateFee() public {
        uint256 updatedFee = engine.usdm().balanceOf(address(this)) -
            operationShare -
            veCRVShare;
        operationShare += updatedFee / 2;
        veCRVShare += updatedFee / 2;
    }

    function claimOperationCost() external {
        updateFee();
        engine.usdm().transfer(engine.operationWallet(), operationShare);
        operationShare = 0;
    }

    function veCRVlock() external {
        require(lockCrv, ""!lock"");
        updateFee();
        _buyCRV();
        _lockCRV();
        veCRVShare = 0;
    }

    function _buyCRV() internal {
        IUSDM usdm = engine.usdm();
        address[] memory path = new address[](2);
        path[0] = address(usdm);
        path[1] = address(crv);
        usdm.approve(address(uniswapRouter), veCRVShare);
        uniswapRouter.swapExactTokensForTokens(
            veCRVShare,
            1,
            path,
            address(this),
            type(uint256).max
        );
    }

    function _lockCRV() internal {
        crv.approve(address(veCrv), crv.balanceOf(address(this)));
        veCrv.increase_amount(crv.balanceOf(address(this)));
        veCrv.increase_unlock_time(block.timestamp + 90 days);
    }
}",688
RealWorld_BA_42_MockCollateral_RealWord_20240820155158.log,42,MockCollateral,4475,4108,8583,70.0,0.104535,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MockCollateral is ERC20 {
    constructor() ERC20(""Mock"", ""MOCK"") {
        _mint(msg.sender, 10000000000000000e18);
    }

    function mint(uint256 _amount) external {
        _mint(msg.sender, _amount);
    }
}",98
RealWorld_BA_42_NoMochiReferralFeePool_RealWord_20240820163945.log,42,NoMochiReferralFeePool,6341,5192,11533,81.0,0.135545,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""../interfaces/IMochiEngine.sol"";
import ""../interfaces/IReferralFeePool.sol"";

contract NoMochiReferralFeePool is IReferralFeePool {
    IMochiEngine public immutable engine;

    uint256 public rewards;

    mapping(address => uint256) public reward;

    constructor(address _engine) {
        engine = IMochiEngine(_engine);
    }

    function addReward(address _recipient) external override {
        uint256 newReward = engine.usdm().balanceOf(address(this)) - rewards;
        reward[_recipient] += newReward;
        rewards += newReward;
    }

    function claimReward() external {
        engine.usdm().transfer(msg.sender, reward[msg.sender]);
        rewards -= reward[msg.sender];
        reward[msg.sender] = 0;
    }
}",186
RealWorld_BA_42_FeePoolV0_RealWord_20240820163544.log,42,FeePoolV0,15764,5341,21105,78.0,0.18564,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol"";
import ""../interfaces/IFeePool.sol"";
import ""../interfaces/IUSDM.sol"";
import ""../interfaces/IMochiEngine.sol"";

contract FeePoolV0 is IFeePool {
    IMochiEngine public immutable engine;

    IUniswapV2Router02 public immutable uniswapRouter;

    address public crvVoterRewardPool;

    uint256 public treasuryRatio;

    uint256 public vMochiRatio;

    uint256 public mochiShare;

    uint256 public treasuryShare;

    constructor(address _engine, address _uniswap) {
        engine = IMochiEngine(_engine);
        uniswapRouter = IUniswapV2Router02(_uniswap);
        treasuryRatio = 20e16;
        vMochiRatio = 80e16;
    }

    function updateReserve() external override {
        uint256 newReserve = engine.usdm().balanceOf(address(this)) -
            mochiShare -
            treasuryShare;
        treasuryShare += (newReserve * treasuryRatio) / 1e18;
        mochiShare = engine.usdm().balanceOf(address(this)) - treasuryShare;
    }

    function changecrvVoterRewardPool(address _pool) external {
        require(msg.sender == engine.governance(), ""!gov"");
        crvVoterRewardPool = _pool;
    }

    function changeTreasuryRatio(uint256 _ratio) external {
        require(msg.sender == engine.governance(), ""!gov"");
        treasuryRatio = _ratio;
    }

    function changevMochiRatio(uint256 _ratio) external {
        require(msg.sender == engine.governance(), ""!gov"");
        vMochiRatio = _ratio;
    }

    // this will open up arb oppertunity for Mochi
    // so we will not reward the caller, caller can benefit from flashbot
    // should decide which market we should use UniV2?V3? BalancerV2?
    function distributeMochi() external {
        // buy Mochi with mochiShare
        _buyMochi();
        _shareMochi();
    }

    function _buyMochi() internal {
        IUSDM usdm = engine.usdm();
        address[] memory path = new address[](2);
        path[0] = address(usdm);
        path[1] = address(engine.mochi());
        usdm.approve(address(uniswapRouter), mochiShare);
        uniswapRouter.swapExactTokensForTokens(
            mochiShare,
            1,
            path,
            address(this),
            type(uint256).max
        );
    }

    function _shareMochi() internal {
        IMochi mochi = engine.mochi();
        uint256 mochiBalance = mochi.balanceOf(address(this));
        // send Mochi to vMochi Vault
        mochi.transfer(
            address(engine.vMochi()),
            (mochiBalance * vMochiRatio) / 1e18
        );
        // send Mochi to veCRV Holders
        mochi.transfer(
            crvVoterRewardPool,
            (mochiBalance * (1e18 - vMochiRatio)) / 1e18
        );
        // flush mochiShare
        mochiShare = 0;
        treasuryShare = 0;
    }

    function sendToTreasury() external {
        engine.usdm().transfer(engine.treasury(), treasuryShare);
        treasuryShare = 0;
    }
}",789
RealWorld_BA_42_MockCssrRouter_RealWord_20240820155311.log,42,MockCssrRouter,9911,4470,14381,77.0,0.138955,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@mochifi/cssr/contracts/interfaces/ICSSRRouter.sol"";
import ""@mochifi/cssr/contracts/interfaces/IUniswapV2CSSR.sol"";
import ""@mochifi/cssr/contracts/mocks/MockEngine.sol"";
import ""@mochifi/cssr/contracts/MochiCSSRv0.sol"";
import ""@mochifi/cssr/contracts/cssr/UniswapV2CSSR.sol"";
import ""@mochifi/cssr/contracts/cssr/SushiswapV2CSSR.sol"";
import ""@mochifi/cssr/contracts/adapter/ChainlinkAdapter.sol"";
import ""@mochifi/cssr/contracts/adapter/UniswapV2TokenAdapter.sol"";
import ""@mochifi/cssr/contracts/adapter/UniswapV2LPAdapter.sol"";
import ""@mochifi/cssr/contracts/adapter/SushiswapV2LPAdapter.sol"";

contract MockCssrRouter is ICSSRRouter {
    mapping(address => uint256) public numerator;

    function setPrice(address _asset, uint256 _newPrice) external {
        numerator[_asset] = _newPrice;
    }

    function update(address _asset, bytes memory _data)
        external
        override
        returns (float memory)
    {
        return getPrice(_asset);
    }

    function getPrice(address _asset)
        public
        view
        override
        returns (float memory)
    {
        // always 1 dollar
        if (numerator[_asset] == 0) {
            return float({numerator: 1e18, denominator: 1e18});
        } else {
            return float({numerator: numerator[_asset], denominator: 1e18});
        }
    }

    function getLiquidity(address _asset)
        external
        view
        override
        returns (uint256)
    {
        return 1_000_000_000_000e18;
    }
}",431
RealWorld_BA_42_usdm_RealWord_20240820160700.log,42,usdm,11313,5618,16931,85.0,0.168925,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""../interfaces/IMochiEngine.sol"";
import ""../interfaces/IERC3156FlashLender.sol"";

contract USDM is ERC20, IUSDM {
    IMochiEngine public immutable engine;

    uint256 private constant SCALE = 1e18;

    bytes32 public constant CALLBACK_SUCCESS =
        keccak256(""ERC3156FlashBorrower.onFlashLoan"");

    constructor(address _engine) ERC20(""USDM"", ""USDM"") {
        engine = IMochiEngine(_engine);
    }

    modifier onlyMinter() {
        require(msg.sender == address(engine.minter()), ""!minter"");
        _;
    }

    function mint(address _recipient, uint256 _amount)
        external
        override
        onlyMinter
    {
        _mint(_recipient, _amount);
    }

    function burn(uint256 _amount) external override {
        _burn(msg.sender, _amount);
    }

    function maxFlashLoan(address _token)
        external
        view
        override
        returns (uint256)
    {
        require(_token == address(this), ""!this"");
        return type(uint256).max - totalSupply();
    }

    function flashFee(address _token, uint256 _amount)
        public
        view
        override
        returns (uint256)
    {
        //should return 0.1337% * _amount;
        require(_token == address(this), ""!supported"");
        return (_amount * ((1337 * SCALE) / 1000000)) / SCALE;
    }

    function flashLoan(
        IERC3156FlashBorrower _receiver,
        address _token,
        uint256 _amount,
        bytes calldata _data
    ) external override returns (bool) {
        require(_token == address(this), ""!supported"");
        uint256 fee = flashFee(_token, _amount);
        _mint(address(_receiver), _amount);
        require(
            _receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) ==
                CALLBACK_SUCCESS,
            ""!callback""
        );
        _burn(address(_receiver), _amount);
        _transfer(address(_receiver), engine.treasury(), fee);
        return true;
    }
}",499
RealWorld_BA_42_UniswapV2CSSR_RealWord_20240820153758.log,42,UniswapV2CSSR,34949,5214,40163,90.0,0.279025,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;
pragma abicoder v2;

import {UniswapV2Library} from ""@mochifi/library/contracts/UniswapV2Library.sol"";
import {UQ112x112} from ""@mochifi/library/contracts/UQ112x112.sol"";
import {BlockVerifier} from ""@mochifi/library/contracts/BlockVerifier.sol"";
import {MerklePatriciaVerifier} from ""@mochifi/library/contracts/MerklePatriciaVerifier.sol"";
import {Rlp} from ""@mochifi/library/contracts/Rlp.sol"";
import {AccountVerifier} from ""@mochifi/library/contracts/AccountVerifier.sol"";
import {IUniswapV2Pair} from ""@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol"";
import ""../interfaces/IUniswapV2CSSR.sol"";

contract UniswapV2CSSR is IUniswapV2CSSR {
    address public immutable override uniswapFactory; // = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95 for mainnet;
    using UQ112x112 for uint224;

    bytes32 public constant reserveTimestampSlotHash =
        keccak256(abi.encodePacked(uint256(8)));
    bytes32 public constant token0Slot =
        keccak256(abi.encodePacked(uint256(9)));
    bytes32 public constant token1Slot =
        keccak256(abi.encodePacked(uint256(10)));

    uint256 public constant WINDOW_SIZE = 10 minutes;

    mapping(uint256 => Window) public window;
    // blockNumber => stateRoot
    mapping(uint256 => BlockData) public blockState;
    // blockNumber => pair => observedData
    mapping(uint256 => mapping(address => ObservedData)) public observedData;

    constructor(address _uniswapFactory) {
        uniswapFactory = _uniswapFactory;
    }

    // stores block data
    function saveState(bytes memory blockData)
        external
        override
        returns (
            bytes32 stateRoot,
            uint256 blockNumber,
            uint256 blockTimestamp
        )
    {
        (stateRoot, blockTimestamp, blockNumber) = BlockVerifier
            .extractStateRootAndTimestamp(blockData);
        if (blockState[blockNumber].blockTimestamp != 0) {
            return (stateRoot, blockNumber, blockTimestamp);
        }
        blockState[blockNumber] = BlockData({
            blockTimestamp: blockTimestamp,
            stateRoot: stateRoot
        });
        updateWindow(uint128(blockNumber), blockTimestamp);
    }

    function updateWindow(uint128 blockNumber, uint256 timestamp) internal {
        uint256 idx = windowIndex(timestamp);
        Window memory _window = window[idx];
        if (_window.from == 0 && _window.to == 0) {
            _window = Window({from: blockNumber, to: blockNumber});
        } else if (_window.from > blockNumber) {
            _window = Window({from: blockNumber, to: _window.to});
        } else if (_window.to < blockNumber) {
            _window = Window({from: _window.from, to: blockNumber});
        }
        window[idx] = _window;
    }

    function windowIndex(uint256 timestamp) internal pure returns (uint256) {
        return (timestamp / WINDOW_SIZE) * WINDOW_SIZE;
    }

    // does not cair about pair address since all it does is save the data
    function saveReserve(
        uint256 blockNumber,
        address pair,
        bytes memory accountProof,
        bytes memory reserveProof,
        bytes memory price0Proof,
        bytes memory price1Proof
    ) external override returns (ObservedData memory data) {
        bytes32 stateRoot = blockState[blockNumber].stateRoot;
        if (observedData[blockNumber][pair].reserveTimestamp != 0) {
            return observedData[blockNumber][pair];
        }
        bytes32 storageRoot = AccountVerifier.getAccountStorageRoot(
            pair,
            stateRoot,
            accountProof
        );
        (
            data.reserve0,
            data.reserve1,
            data.reserveTimestamp
        ) = unpackReserveData(
            Rlp.rlpBytesToUint256(
                MerklePatriciaVerifier.getValueFromProof(
                    storageRoot,
                    reserveTimestampSlotHash,
                    reserveProof
                )
            )
        );
        data.price0Data = Rlp.rlpBytesToUint256(
            MerklePatriciaVerifier.getValueFromProof(
                storageRoot,
                token0Slot,
                price0Proof
            )
        );
        data.price1Data = Rlp.rlpBytesToUint256(
            MerklePatriciaVerifier.getValueFromProof(
                storageRoot,
                token1Slot,
                price1Proof
            )
        );
        observedData[blockNumber][pair] = data;
    }

    function unpackReserveData(uint256 packedReserveData)
        internal
        pure
        returns (
            uint112 reserve0,
            uint112 reserve1,
            uint32 reserveTimestamp
        )
    {
        reserve0 = uint112(packedReserveData & (2**112 - 1));
        reserve1 = uint112((packedReserveData >> 112) & (2**112 - 1));
        reserveTimestamp = uint32(packedReserveData >> (112 + 112));
    }

    // locked **denominator** amount paired with token
    function getLiquidity(address token, address denominator)
        external
        view
        override
        returns (uint256)
    {
        IUniswapV2Pair pair = IUniswapV2Pair(
            UniswapV2Library.pairFor(uniswapFactory, token, denominator)
        );
        Window memory currentWindow = window[windowIndex(block.timestamp)];
        uint128 lastObserved = currentWindow.to;
        if (lastObserved == 0) {
            lastObserved = window[windowIndex(block.timestamp) - WINDOW_SIZE]
                .to;
            require(lastObserved != 0, ""!observed"");
        }
        BlockData memory state = blockState[lastObserved];
        require(block.timestamp - state.blockTimestamp < WINDOW_SIZE, ""stale"");
        bool denominationTokenIs0;
        if (pair.token0() == denominator) {
            denominationTokenIs0 = true;
        } else if (pair.token1() == denominator) {
            denominationTokenIs0 = false;
        } else {
            revert(""denominationToken invalid"");
        }
        ObservedData memory historicData = observedData[lastObserved][
            address(pair)
        ];
        return
            denominationTokenIs0
                ? historicData.reserve0
                : historicData.reserve1;
    }

    function getExchangeRatio(address token, address denominator)
        external
        view
        override
        returns (uint256)
    {
        IUniswapV2Pair pair = IUniswapV2Pair(
            UniswapV2Library.pairFor(uniswapFactory, token, denominator)
        );
        Window memory currentWindow = window[windowIndex(block.timestamp)];
        uint128 lastObserved = currentWindow.to;
        if (lastObserved == 0) {
            lastObserved = window[windowIndex(block.timestamp) - WINDOW_SIZE]
                .to;
            require(lastObserved != 0, ""!observed"");
        }
        BlockData memory state = blockState[lastObserved];
        require(block.timestamp - state.blockTimestamp < WINDOW_SIZE, ""stale"");
        bool denominationTokenIs0;
        if (pair.token0() == denominator) {
            denominationTokenIs0 = true;
        } else if (pair.token1() == denominator) {
            denominationTokenIs0 = false;
        } else {
            revert(""denominationToken invalid"");
        }
        //now calculate
        //get historic data
        ObservedData memory historicData = observedData[lastObserved][
            address(pair)
        ];
        uint256 historicePriceCumulative = calculatedPriceCumulative(
            denominationTokenIs0
                ? historicData.reserve0
                : historicData.reserve1,
            denominationTokenIs0
                ? historicData.reserve1
                : historicData.reserve0,
            denominationTokenIs0
                ? historicData.price1Data
                : historicData.price0Data,
            state.blockTimestamp - uint256(historicData.reserveTimestamp)
        );
        //get current data
        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = pair
            .getReserves();
        uint256 currentPriceCumulative = calculatedPriceCumulative(
            denominationTokenIs0 ? reserve0 : reserve1,
            denominationTokenIs0 ? reserve1 : reserve0,
            denominationTokenIs0
                ? pair.price1CumulativeLast()
                : pair.price0CumulativeLast(),
            block.timestamp - blockTimestampLast
        );
        return
            (currentPriceCumulative - historicePriceCumulative) /
            (block.timestamp - state.blockTimestamp);
    }

    function calculatedPriceCumulative(
        uint112 reserve,
        uint112 pairedReserve,
        uint256 priceCumulativeLast,
        uint256 timeElapsed
    ) internal pure returns (uint256) {
        if (timeElapsed == 0) {
            return priceCumulativeLast;
        }
        return
            priceCumulativeLast +
            timeElapsed *
            uint256(UQ112x112.encode(reserve).uqdiv(pairedReserve));
    }
}",2009
RealWorld_BA_42_IMochiVault_RealWord_20240820163414.log,42,IMochiVault,9788,5654,15442,88.0,0.16202,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
struct Detail {
    Status status;
    uint256 collateral;
    uint256 debt;
    uint256 debtIndex;
    address referrer;
}

enum Status {
    Invalid, // not minted
    Idle, // debt = 0, collateral = 0
    Collaterized, // debt = 0, collateral > 0
    Active, // debt > 0, collateral > 0
    Liquidated
}

interface IMochiVault {
    function liveDebtIndex() external view returns (uint256);

    function details(uint256 _nftId)
        external
        view
        returns (
            Status,
            uint256 collateral,
            uint256 debt,
            uint256 debtIndexe,
            address refferer
        );

    function status(uint256 _nftId) external view returns (Status);

    function asset() external view returns (IERC20);

    function deposits() external view returns (uint256);

    function debts() external view returns (uint256);

    function claimable() external view returns (int256);

    function currentDebt(uint256 _nftId) external view returns (uint256);

    function initialize(address _asset) external;

    function deposit(uint256 _nftId, uint256 _amount) external;

    function withdraw(
        uint256 _nftId,
        uint256 _amount,
        bytes memory _data
    ) external;

    function borrow(
        uint256 _nftId,
        uint256 _amount,
        bytes memory _data
    ) external;

    function repay(uint256 _nftId, uint256 _amount) external;

    function liquidate(
        uint256 _nftId,
        uint256 _collateral,
        uint256 _usdm
    ) external;
}",406
RealWorld_BA_42_IGovernanceOwned_RealWord_20240820154103.log,42,IGovernanceOwned,3401,3872,7273,62.0,0.094445,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface IGovernanceOwned {
    function governance() external view returns (address);
}",33
RealWorld_BA_42_IMochiEngine_RealWord_20240820162759.log,42,IMochiEngine,8547,4956,13503,73.0,0.141855,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@mochifi/vmochi/contracts/interfaces/IVMochi.sol"";
import ""@mochifi/cssr/contracts/interfaces/ICSSRRouter.sol"";
import ""./IMochiProfile.sol"";
import ""./IDiscountProfile.sol"";
import ""./IMochiVault.sol"";
import ""./IFeePool.sol"";
import ""./IReferralFeePool.sol"";
import ""./ILiquidator.sol"";
import ""./IUSDM.sol"";
import ""./IMochi.sol"";
import ""./IMinter.sol"";
import ""./IMochiNFT.sol"";
import ""./IMochiVaultFactory.sol"";

interface IMochiEngine {
    function mochi() external view returns (IMochi);

    function vMochi() external view returns (IVMochi);

    function usdm() external view returns (IUSDM);

    function cssr() external view returns (ICSSRRouter);

    function governance() external view returns (address);

    function treasury() external view returns (address);

    function operationWallet() external view returns (address);

    function mochiProfile() external view returns (IMochiProfile);

    function discountProfile() external view returns (IDiscountProfile);

    function feePool() external view returns (IFeePool);

    function referralFeePool() external view returns (IReferralFeePool);

    function liquidator() external view returns (ILiquidator);

    function minter() external view returns (IMinter);

    function nft() external view returns (IMochiNFT);

    function vaultFactory() external view returns (IMochiVaultFactory);
}",349
RealWorld_BA_42_IFeePool_RealWord_20240820163309.log,42,IFeePool,3499,3524,7023,63.0,0.087975,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

interface IFeePool {
    function updateReserve() external;
}",35
RealWorld_BA_42_UsdmMinter_RealWord_20240820155931.log,42,UsdmMinter,8323,5882,14205,96.0,0.159255,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""../interfaces/IMochiEngine.sol"";

contract MinterV0 is IMinter {
    IMochiEngine public immutable engine;

    mapping(address => bool) public isMinter;

    address[] public factories;

    constructor(address _engine) {
        engine = IMochiEngine(_engine);
    }

    modifier onlyPermission() {
        require(hasPermission(msg.sender), ""!permission"");
        _;
    }

    modifier onlyGov() {
        require(msg.sender == engine.governance(), ""!gov"");
        _;
    }

    function addMinter(address _minter) external onlyGov {
        isMinter[_minter] = true;
    }

    function removeMinter(address _minter) external onlyGov {
        isMinter[_minter] = false;
    }

    function mint(address _to, uint256 _amount)
        external
        override
        onlyPermission
    {
        engine.usdm().mint(_to, _amount);
    }

    function hasPermission(address _user) public view override returns (bool) {
        return isMinter[_user] || isVault(_user);
    }

    function isVault(address _vault) public view override returns (bool) {
        return
            address(
                engine.vaultFactory().getVault(
                    address(IMochiVault(_vault).asset())
                )
            ) == _vault;
    }
}",307
RealWorld_BA_42_BlockVerifier_RealWord_20240820165410.log,42,BlockVerifier,16868,5751,22619,89.0,0.19936,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

library BlockVerifier {
    function extractStateRootAndTimestamp(bytes memory rlpBytes) internal view returns (bytes32 stateRoot, uint256 blockTimestamp, uint256 blockNumber) {
        assembly {
            function revertWithReason(message, length) {
                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                mstore(4, 0x20)
                mstore(0x24, length)
                mstore(0x44, message)
                revert(0, add(0x44, length))
            }

            function readDynamic(prefixPointer) -> dataPointer, dataLength {
                let value := byte(0, mload(prefixPointer))
                switch lt(value, 0x80)
                case 1 {
                    dataPointer := prefixPointer
                    dataLength := 1
                }
                case 0 {
                    dataPointer := add(prefixPointer, 1)
                    dataLength := sub(value, 0x80)
                }
            }

            // get the length of the data
            let rlpLength := mload(rlpBytes)
            // move pointer forward, ahead of length
            rlpBytes := add(rlpBytes, 0x20)

            // we know the length of the block will be between 483 bytes and 709 bytes, which means it will have 2 length bytes after the prefix byte, so we can skip 3 bytes in
            // CONSIDER: we could save a trivial amount of gas by compressing most of this into a single add instruction
            let parentHashPrefixPointer := add(rlpBytes, 3)
            let parentHashPointer := add(parentHashPrefixPointer, 1)
            let uncleHashPrefixPointer := add(parentHashPointer, 32)
            let uncleHashPointer := add(uncleHashPrefixPointer, 1)
            let minerAddressPrefixPointer := add(uncleHashPointer, 32)
            let minerAddressPointer := add(minerAddressPrefixPointer, 1)
            let stateRootPrefixPointer := add(minerAddressPointer, 20)
            let stateRootPointer := add(stateRootPrefixPointer, 1)
            let transactionRootPrefixPointer := add(stateRootPointer, 32)
            let transactionRootPointer := add(transactionRootPrefixPointer, 1)
            let receiptsRootPrefixPointer := add(transactionRootPointer, 32)
            let receiptsRootPointer := add(receiptsRootPrefixPointer, 1)
            let logsBloomPrefixPointer := add(receiptsRootPointer, 32)
            let logsBloomPointer := add(logsBloomPrefixPointer, 3)
            let difficultyPrefixPointer := add(logsBloomPointer, 256)
            let difficultyPointer, difficultyLength := readDynamic(difficultyPrefixPointer)
            let blockNumberPrefixPointer := add(difficultyPointer, difficultyLength)
            let blockNumberPointer, blockNumberLength := readDynamic(blockNumberPrefixPointer)
            let gasLimitPrefixPointer := add(blockNumberPointer, blockNumberLength)
            let gasLimitPointer, gasLimitLength := readDynamic(gasLimitPrefixPointer)
            let gasUsedPrefixPointer := add(gasLimitPointer, gasLimitLength)
            let gasUsedPointer, gasUsedLength := readDynamic(gasUsedPrefixPointer)
            let timestampPrefixPointer := add(gasUsedPointer, gasUsedLength)
            let timestampPointer, timestampLength := readDynamic(timestampPrefixPointer)

            blockNumber := shr(sub(256, mul(blockNumberLength, 8)), mload(blockNumberPointer))
            let blockHash := blockhash(blockNumber)
            let rlpHash := keccak256(rlpBytes, rlpLength)
            if iszero(eq(blockHash, rlpHash)) { revertWithReason(""blockHash != rlpHash"", 20) }

            stateRoot := mload(stateRootPointer)
            blockTimestamp := shr(sub(256, mul(timestampLength, 8)), mload(timestampPointer))
        }
    }
}",854
RealWorld_BA_42_MochiProfileV0_RealWord_20240820160109.log,42,MochiProfileV0,39888,5711,45599,113.0,0.31366,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""../interfaces/IMochiProfile.sol"";
import ""../interfaces/IMochiEngine.sol"";

///@notice this is where policies including some math is registered will be able to swap the profile when current profile is not suitable
///@dev this profile is built with https://docs.google.com/spreadsheets/d/1T2WKpwj5QmueR7O8R9AXNbnHLc-rJ_-8DLdRI2eJZqA
contract MochiProfileV0 is IMochiProfile {
    using Float for float;
    using Float for uint256;
    IMochiEngine public immutable engine;

    uint256 public override liquidityRequirement;

    uint256 public override minimumDebt;

    mapping(address => AssetClass) internal _assetClass;

    mapping(address => uint256) public override creditCap;

    uint256 public immutable secPerYear;

    uint256 public override delay;

    constructor(address _engine) {
        secPerYear = 31536000;
        engine = IMochiEngine(_engine);

        liquidityRequirement = 1000000e18; // 1million dollar
        minimumDebt = 1000e18;
        delay = 3 minutes;
    }

    modifier onlyGov() {
        require(msg.sender == engine.governance(), ""!gov"");
        _;
    }

    function assetClass(address _asset)
        public
        view
        override
        returns (AssetClass)
    {
        return _assetClass[_asset];
    }

    function changeLiquidityRequirement(uint256 _requirement)
        external
        override
        onlyGov
    {
        liquidityRequirement = _requirement;
    }

    function registerAsset(address _asset) external {
        uint256 liq = engine.cssr().getLiquidity(_asset);
        require(liq >= liquidityRequirement, ""<liquidity"");
        _register(_asset, AssetClass.Sigma);
    }

    function registerAssetByGov(
        address[] calldata _asset,
        AssetClass[] calldata _classes
    ) external onlyGov {
        for (uint256 i = 0; i < _asset.length; i++) {
            _register(_asset[i], _classes[i]);
            engine.vaultFactory().deployVault(_asset[i]);
        }
    }

    function _register(address _asset, AssetClass _class) internal {
        _assetClass[_asset] = _class;
    }

    function changeMinimumDebt(uint256 _debt) external override onlyGov {
        minimumDebt = _debt;
    }

    function changeAssetClass(
        address[] calldata _assets,
        AssetClass[] calldata _classes
    ) external override onlyGov {
        for (uint256 i = 0; i < _assets.length; i++) {
            _assetClass[_assets[i]] = _classes[i];
        }
    }

    function changeCreditCap(
        address[] calldata _assets,
        uint256[] calldata _caps
    ) external onlyGov {
        for (uint256 i = 0; i < _assets.length; i++) {
            creditCap[_assets[i]] = _caps[i];
        }
    }

    function setDelay(uint256 _delay) external onlyGov {
        delay = _delay;
    }

    ///@notice The Collateral Factor at which the users vault will be liquidated
    function liquidationFactor(address _asset)
        public
        view
        override
        returns (float memory)
    {
        AssetClass class = assetClass(_asset);
        if (class == AssetClass.Stable) {
            return float({numerator: 95, denominator: 100});
        } else if (class == AssetClass.Alpha) {
            return float({numerator: 85, denominator: 100});
        } else if (class == AssetClass.Gamma) {
            return float({numerator: 80, denominator: 100});
        } else if (class == AssetClass.Delta) {
            return float({numerator: 75, denominator: 100});
        } else if (class == AssetClass.Zeta) {
            return float({numerator: 65, denominator: 100});
        } else if (class == AssetClass.Sigma) {
            return float({numerator: 40, denominator: 100});
        } else {
            revert(""invalid"");
        }
    }

    function riskFactor(address _asset) public view returns (uint256) {
        AssetClass class = assetClass(_asset);
        if (class == AssetClass.Stable) {
            return 1;
        } else if (class == AssetClass.Alpha) {
            return 2;
        } else if (class == AssetClass.Gamma) {
            return 3;
        } else if (class == AssetClass.Delta) {
            return 4;
        } else if (class == AssetClass.Zeta) {
            return 5;
        } else if (class == AssetClass.Sigma) {
            return 6;
        } else {
            revert(""invalid"");
        }
    }

    function maxCollateralFactor(address _asset)
        public
        view
        override
        returns (float memory)
    {
        AssetClass class = assetClass(_asset);
        if (class == AssetClass.Stable) {
            return float({numerator: 90, denominator: 100});
        } else if (class == AssetClass.Alpha) {
            return float({numerator: 80, denominator: 100});
        } else if (class == AssetClass.Gamma) {
            return float({numerator: 75, denominator: 100});
        } else if (class == AssetClass.Delta) {
            return float({numerator: 65, denominator: 100});
        } else if (class == AssetClass.Zeta) {
            return float({numerator: 55, denominator: 100});
        } else if (class == AssetClass.Sigma) {
            return float({numerator: 45, denominator: 100});
        } else {
            revert(""invalid"");
        }
    }

    function baseFee() public pure returns (float memory) {
        return float({numerator: 5, denominator: 1000});
    }

    function liquidationFee(address _asset)
        public
        view
        override
        returns (float memory)
    {
        AssetClass class = assetClass(_asset);
        if (class == AssetClass.Stable) {
            return float({numerator: 45, denominator: 1000});
        } else if (class == AssetClass.Alpha) {
            return float({numerator: 100, denominator: 1000});
        } else if (class == AssetClass.Gamma) {
            return float({numerator: 125, denominator: 1000});
        } else if (class == AssetClass.Delta) {
            return float({numerator: 150, denominator: 1000});
        } else if (class == AssetClass.Zeta) {
            return float({numerator: 175, denominator: 1000});
        } else if (class == AssetClass.Sigma) {
            return float({numerator: 200, denominator: 1000});
        } else {
            revert(""invalid"");
        }
    }

    function keeperFee(address _asset)
        public
        view
        override
        returns (float memory)
    {
        AssetClass class = assetClass(_asset);
        if (class == AssetClass.Stable) {
            return float({numerator: 5, denominator: 1000});
        } else if (class == AssetClass.Alpha) {
            return float({numerator: 10, denominator: 1000});
        } else if (class == AssetClass.Gamma) {
            return float({numerator: 15, denominator: 1000});
        } else if (class == AssetClass.Delta) {
            return float({numerator: 20, denominator: 1000});
        } else if (class == AssetClass.Zeta) {
            return float({numerator: 25, denominator: 1000});
        } else if (class == AssetClass.Sigma) {
            return float({numerator: 30, denominator: 1000});
        } else {
            revert(""invalid"");
        }
    }

    function maxFee(AssetClass _class) public pure returns (float memory) {
        if (_class == AssetClass.Stable) {
            return float({numerator: 10, denominator: 1000});
        } else if (_class == AssetClass.Alpha) {
            return float({numerator: 15, denominator: 1000});
        } else if (_class == AssetClass.Gamma) {
            return float({numerator: 20, denominator: 1000});
        } else if (_class == AssetClass.Delta) {
            return float({numerator: 21, denominator: 1000});
        } else if (_class == AssetClass.Zeta) {
            return float({numerator: 22, denominator: 1000});
        } else if (_class == AssetClass.Sigma) {
            return float({numerator: 23, denominator: 1000});
        } else {
            revert(""invalid"");
        }
    }

    function stabilityFee(address _asset)
        public
        view
        override
        returns (float memory)
    {
        float memory base = baseFee();
        AssetClass class = assetClass(_asset);
        float memory max = maxFee(class);
        float memory u = utilizationRatio(_asset);
        if (u.gt(float({numerator: 1, denominator: 1}))) {
            return max;
        }
        return base.add(max.sub(base).mul(u));
    }

    function calculateFeeIndex(
        address _asset,
        uint256 _currentIndex,
        uint256 _lastAccrued
    ) external view override returns (uint256) {
        float memory feePerYear = stabilityFee(_asset);
        uint256 timePassed = block.timestamp - _lastAccrued;
        float memory feeAccumulated = feePerYear.mul(
            float({numerator: timePassed, denominator: secPerYear})
        );
        return _currentIndex + _currentIndex.multiply(feeAccumulated);
    }

    ///@dev returns utilization ratio scaled with 1e18
    function utilizationRatio(address _asset)
        public
        view
        override
        returns (float memory ratio)
    {
        IMochiVault vault = engine.vaultFactory().getVault(_asset);
        uint256 debts = vault.debts();
        uint256 cap = creditCap[_asset];
        return float({numerator: debts, denominator: cap});
    }
}",2270
RealWorld_BA_42_MockDAI_RealWord_20240820155655.log,42,MockDAI,4462,3823,8285,65.0,0.09877,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MockDAI is ERC20 {
    constructor() ERC20(""MockDAI"", ""MOCKDAI"") {
        _mint(msg.sender, 10000000000000000e18);
    }

    function mint(uint256 _amount) external {
        _mint(msg.sender, _amount);
    }
}",102
RealWorld_BA_42_BeaconDeployerMock_RealWord_20240820165839.log,42,BeaconDeployerMock,6450,4954,11404,70.0,0.13133,"// SPDX-License-Identifier: AGPL-3.0

/**
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

pragma solidity ^0.8.0;

import ""../BeaconProxyDeployer.sol"";

contract BeaconDeployerMock {
    address private beacon;
    
    constructor(address beaconAddr) {
        beacon = beaconAddr;
    }
    
    function deploy(string calldata _name) external returns (address addr) {
        bytes memory initCode = abi.encodeWithSelector(
                bytes4(keccak256(""initialize(string)"")),
                _name
            );

        addr = BeaconProxyDeployer.deploy(beacon, initCode);
    }

    function deployCalculate(string calldata _name) external view returns (address addr) {
        bytes memory initCode = abi.encodeWithSelector(
                bytes4(keccak256(""initialize(string)"")),
                _name
            );

        addr = BeaconProxyDeployer.calculateAddress(address(this), beacon, initCode);
    }
}",202
RealWorld_BA_42_NoDiscountProfile_RealWord_20240820160304.log,42,NoDiscountProfile,3952,4792,8744,67.0,0.1156,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""../interfaces/IDiscountProfile.sol"";

contract NoDiscountProfile is IDiscountProfile {
    function discount(address) external pure override returns (float memory) {
        return float({numerator: 0, denominator: 1});
    }
}",73
RealWorld_BA_42_ICurveAddressProvider_RealWord_20240820154919.log,42,ICurveAddressProvider,3918,3865,7783,77.0,0.09689,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

//0x0000000022D53366457F9d5E68Ec105046FC4383

interface ICurveAddressProvider {
    function get_registry() external view returns (address);
}",58
RealWorld_BA_42_ICSSRRouter_RealWord_20240820154507.log,42,ICSSRRouter,4680,5163,9843,96.0,0.12666,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@mochifi/library/contracts/Float.sol"";

interface ICSSRRouter {
    function update(address _asset, bytes memory _data)
        external
        returns (float memory);

    function getPrice(address _asset) external view returns (float memory);

    function getLiquidity(address _asset) external view returns (uint256);
}",87
RealWorld_BA_42_SushiswapV2LPAdapter_RealWord_20240820153133.log,42,SushiswapV2LPAdapter,21416,5403,26819,91.0,0.21514,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol"";
import { SushiswapV2Library } from ""@mochifi/library/contracts/SushiswapV2Library.sol"";
import ""../interfaces/ICSSRAdapter.sol"";
import ""../interfaces/ICSSRRouter.sol"";
import ""../interfaces/IUniswapV2CSSR.sol"";
contract SushiswapV2LPAdapter is ICSSRAdapter {
    using Float for float;

    ICSSRRouter public immutable router;
    IUniswapV2CSSR public immutable cssr;
    address public immutable weth;
    address public immutable factory;
    //using uint256 since we don't need 224 for this
    uint256 public constant Q112 = 2**112;

    constructor(address _weth, address _factory, address _router, address _cssr) {
        weth = _weth;
        router = ICSSRRouter(_router);
        cssr = IUniswapV2CSSR(_cssr);
        factory = _factory;
    }

    function support(address _asset) external view override returns(bool) {
        address underlying = getUnderlyingAsset(IUniswapV2Pair(_asset));
        address calculatedAddress = SushiswapV2Library.pairFor(factory, underlying, weth);
        return _asset == calculatedAddress;
    }

    function update(address _asset, bytes memory _proof) external override returns(float memory price) {
        address underlying = getUnderlyingAsset(IUniswapV2Pair(_asset));
        router.update(_asset, _proof);
        return _getPrice(IUniswapV2Pair(_asset), underlying);
    }

    function getUnderlyingAsset(IUniswapV2Pair _pair) public view returns(address underlyingAsset) {
        if (_pair.token0() == weth) {
            underlyingAsset = _pair.token1();
        } else if (_pair.token1() == weth) {
            underlyingAsset = _pair.token0();
        } else {
            revert(""!eth paired"");
        }
    }

    function getPrice(address _asset) external view override returns(float memory price){
        IUniswapV2Pair pair = IUniswapV2Pair(_asset);
        address underlying = getUnderlyingAsset(pair);
        return _getPrice(pair, underlying);
    }

    function _getPrice(IUniswapV2Pair _pair, address _underlying) internal view returns(float memory price) {
        uint256 eAvg = cssr.getExchangeRatio(_underlying, weth);
        (uint112 _reserve0, uint112 _reserve1,) = _pair.getReserves();
        uint256 aPool; // current asset pool
        uint256 ePool; // current weth pool
        if (_pair.token0() == _underlying) {
            aPool = uint(_reserve0);
            ePool = uint(_reserve1);
        } else {
            aPool = uint(_reserve1);
            ePool = uint(_reserve0);
        }

        uint256 eCurr = ePool * Q112 / aPool; // current price of 1 token in weth
        uint256 ePoolCalc; // calculated weth pool

        if (eCurr < eAvg) {
            // flashloan buying weth
            uint256 sqrtd = ePool * (
                (ePool * 9)
                +(aPool * 3988000 * eAvg / Q112)
            );
            uint256 eChange = (sqrt(sqrtd) - (ePool * 1997)) / 2000;
            ePoolCalc = ePool + eChange;
        } else {
            // flashloan selling weth
            uint256 a = aPool * eAvg;
            uint256 b = a * 9 / Q112;
            uint256 c = ePool * 3988000;
            uint256 sqRoot = sqrt( (a / Q112) * (b + c));
            uint256 d = a * 3 / Q112;
            uint256 eChange = ePool - ((d + sqRoot) / 2000);
            ePoolCalc = ePool - eChange;
        }

        uint256 num = ePoolCalc * 2;
        uint256 priceInEth;
        if (num > Q112) {
            priceInEth = (num / _pair.totalSupply()) * Q112;
        } else {
            priceInEth = num * Q112 / _pair.totalSupply();
        }

        return float({numerator:priceInEth, denominator: Q112}).mul(router.getPrice(weth));
    }

    function getLiquidity(address _asset) external view override returns(uint256) {
        address underlying = getUnderlyingAsset(IUniswapV2Pair(_asset));
        return router.getLiquidity(underlying);
    }

    function sqrt(uint x) internal pure returns (uint y) {
        if (x > 3) {
            uint z = x / 2 + 1;
            y = x;
            while (z < y) {
                y = z;
                z = (x / z + z) / 2;
            }
        } else if (x != 0) {
            y = 1;
        }
    }
}",1131
RealWorld_BA_42_IMochiNFT_RealWord_20240820161504.log,42,IMochiNFT,4462,4320,8782,63.0,0.10871,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol"";

interface IMochiNFT is IERC721Enumerable {
    struct MochiInfo {
        address asset;
    }

    function asset(uint256 _id) external view returns (address);

    function mint(address _asset, address _owner) external returns (uint256);
}",97
RealWorld_BA_42_ReferralFeePoolV0_RealWord_20240820163704.log,42,ReferralFeePoolV0,8920,4724,13644,70.0,0.13908,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol"";
import ""../interfaces/IMochiEngine.sol"";
import ""../interfaces/IReferralFeePool.sol"";

contract ReferralFeePoolV0 is IReferralFeePool {
    IMochiEngine public immutable engine;
    IUniswapV2Router02 public immutable uniswapRouter;

    uint256 public rewards;

    mapping(address => uint256) public reward;

    constructor(address _engine, address _uniswap) {
        engine = IMochiEngine(_engine);
        uniswapRouter = IUniswapV2Router02(_uniswap);
    }

    function addReward(address _recipient) external override {
        uint256 newReward = engine.usdm().balanceOf(address(this)) - rewards;
        reward[_recipient] += newReward;
        rewards += newReward;
    }

    function claimRewardAsMochi() external {
        IUSDM usdm = engine.usdm();
        address[] memory path = new address[](2);
        path[0] = address(usdm);
        path[1] = uniswapRouter.WETH();
        path[2] = address(engine.mochi());
        usdm.approve(address(uniswapRouter), reward[msg.sender]);
        // we are going to ingore the slippages here
        uniswapRouter.swapExactTokensForTokens(
            reward[msg.sender],
            1,
            path,
            address(this),
            type(uint256).max
        );
        engine.mochi().transfer(
            msg.sender,
            engine.mochi().balanceOf(address(this))
        );
    }
}",369
RealWorld_BA_42_ICSSRAdapter_RealWord_20240820154207.log,42,ICSSRAdapter,4853,4236,9089,93.0,0.108985,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@mochifi/library/contracts/Float.sol"";

interface ICSSRAdapter {
    function update(address _asset, bytes memory _data)
        external
        returns (float memory price);

    function support(address _asset) external view returns (bool);

    function getPrice(address _asset)
        external
        view
        returns (float memory price);

    function getLiquidity(address _asset)
        external
        view
        returns (uint256 _liquidity);
}",115
RealWorld_BA_42_MockAdapter_RealWord_20240820152916.log,42,MockAdapter,7453,4837,12290,71.0,0.134005,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""../interfaces/ICSSRAdapter.sol"";

contract MockAdapter is ICSSRAdapter {

    mapping(address => uint256) public numerator;
    
    function setPrice(address _asset, uint256 _newPrice) external {
        numerator[_asset] = _newPrice;
    }

    function update(address _asset, bytes memory _data) external override returns(float memory price) {
        price = getPrice(_asset);
    }

    function support(address _asset) external override view returns(bool) {
        return true;
    }

    function getPrice(address _asset) public override view returns(float memory price) {
        if(numerator[_asset] == 0) {
            return float({numerator:1e18, denominator: 1e18});
        } else {
            return float({numerator:numerator[_asset], denominator: 1e18});
        }
    }
    
    function getLiquidity(address _asset)
        external
        view
        override
        returns (uint256)
    {
        return 1_000_000_000_000e18;
    }
}",241
RealWorld_BA_42_BeaconProxyDeployer_RealWord_20240820164108.log,42,BeaconProxyDeployer,11572,5434,17006,76.0,0.16654,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""./Create2BeaconMaker.sol"";
library BeaconProxyDeployer {
    function deploy(address beacon, bytes memory initializationCalldata)
        internal
        returns (address result)
    {
        bytes memory createCode =
            abi.encodePacked(
                type(Create2BeaconMaker).creationCode,
                abi.encode(address(beacon), initializationCalldata)
            );
        bytes32 salt = bytes32(0);

        // solhint-disable-next-line no-inline-assembly
        assembly {
            let encoded_data := add(0x20, createCode) // load initialization code.
            let encoded_size := mload(createCode) // load the init code's length.
            result := create2(
                // call `CREATE2` w/ 4 arguments.
                0, // forward any supplied endowment.
                encoded_data, // pass in initialization code.
                encoded_size, // pass in init code's length.
                salt // pass in the salt value.
            )

            // pass along failure message from failed contract deployment and revert.
            if iszero(result) {
                returndatacopy(0, 0, returndatasize())
                revert(0, returndatasize())
            }
        }
    }

    function calculateAddress(
        address deployer,
        address beacon,
        bytes memory initializationCalldata
    ) internal view returns (address addr) {
        bytes memory createCode =
            abi.encodePacked(
                type(Create2BeaconMaker).creationCode,
                abi.encode(address(beacon), initializationCalldata)
            );

        bytes32 salt = bytes32(0);
        // get the keccak256 hash of the init code for address derivation.
        bytes32 initCodeHash = keccak256(createCode);
        addr = address( // derive the target deployment address.
            uint160( // downcast to match the address type.
                uint256( // cast to uint to truncate upper digits.
                    keccak256( // compute CREATE2 hash using 4 inputs.
                        abi.encodePacked( // pack all inputs to the hash together.
                            bytes1(0xff), // pass in the control character.
                            deployer, // pass in the address of this contract.
                            salt, // pass in the salt from above.
                            initCodeHash // pass in hash of contract creation code.
                        )
                    )
                )
            )
        );
    }
}",512
RealWorld_BA_42_ICurveRegistry_RealWord_20240820154757.log,42,ICurveRegistry,5312,4829,10141,80.0,0.12314,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface ICurveRegistry {
    /*
     * @notice Get the number of coins in a pool
     * @dev For non-metapools, both returned values are identical even when the pool does not use wrapping/lending
     * @param _pool Pool address
     * @return Number of wrapped coins, number of underlying coins
     */
    function get_n_coins(address _pool)
        external
        view
        returns (uint256[2] memory _count);

    function get_pool_from_lp_token(address _lp)
        external
        view
        returns (address);
}",139
RealWorld_BA_42_Beacon_RealWord_20240820164345.log,42,Beacon,5553,4401,9954,73.0,0.115785,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

contract Beacon {
    address internal _implementation;
    address internal immutable _CONTROLLER;
    
    constructor(address impl) {
        _implementation = impl;
        _CONTROLLER = msg.sender;
    }
    
    fallback() external {
        if (msg.sender != _CONTROLLER) {
            // solhint-disable-next-line no-inline-assembly
          assembly {
            mstore(0, sload(0))
            return(0, 32)
          }
        } else {
            // solhint-disable-next-line no-inline-assembly
          assembly { sstore(0, calldataload(0)) }
        }
    }
}",151
RealWorld_BA_42_ILiquidator_RealWord_20240820162914.log,42,ILiquidator,4386,4038,8424,72.0,0.10269,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

interface ILiquidator {
    event Triggered(uint256 _auctionId, uint256 _price);
    event Settled(uint256 _auctionId, uint256 _price);

    function triggerLiquidation(address _asset, uint256 _nftId) external;
}",76
RealWorld_BA_42_Mochi_RealWord_20240820160548.log,42,Mochi,4030,4005,8035,69.0,0.10025,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract Mochi is ERC20 {
    constructor() ERC20(""Mochi"", ""MOCHI"") {
        _mint(msg.sender, 1000000000000e18);
    }
}",79
RealWorld_BA_42_IMochiPositionDescriptor_RealWord_20240820162126.log,42,IMochiPositionDescriptor,4033,4325,8358,66.0,0.106665,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

interface IMochiPositionDescriptor {
    function getTokenURI(address _position, uint256 _positionId)
        external
        view
        returns (string memory);
}",55
RealWorld_BA_42_NoMochiFeePool_RealWord_20240820163816.log,42,NoMochiFeePool,6127,5002,11129,87.0,0.130675,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""../interfaces/IFeePool.sol"";
import ""../interfaces/IMochiEngine.sol"";

contract NoMochiFeePool is IFeePool {
    IMochiEngine public immutable engine;
    address public withdrawer;

    constructor(address _withdrawer, address _engine) {
        engine = IMochiEngine(_engine);
        withdrawer = _withdrawer;
    }

    function updateReserve() external override {
        // no-op
    }

    function withdraw() external {
        engine.usdm().transfer(
            withdrawer,
            engine.usdm().balanceOf(address(this))
        );
    }

    function changeWithdrawer(address _withdrawer) external {
        require(msg.sender == engine.governance(), ""!gov"");
        withdrawer = _withdrawer;
    }
}",182
RealWorld_BA_42_IERC3156FlashBorrower_RealWord_20240820161939.log,42,IERC3156FlashBorrower,6424,5489,11913,105.0,0.1419,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

interface IERC3156FlashBorrower {
    /**
     * @dev Receive a flash loan.
     * @param initiator The initiator of the loan.
     * @param token The loan currency.
     * @param amount The amount of tokens lent.
     * @param fee The additional amount of tokens to repay.
     * @param data Arbitrary data structure, intended to contain user-defined parameters.
     * @return The keccak256 hash of ""ERC3156FlashBorrower.onFlashLoan""
     */
    function onFlashLoan(
        address initiator,
        address token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external returns (bytes32);
}",165
RealWorld_BA_42_MochiCSSRv0_RealWord_20240820152727.log,42,MochiCSSRv0,19308,6648,25956,107.0,0.2295,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interfaces/IGovernanceOwned.sol"";
import ""./interfaces/ICSSRAdapter.sol"";
import ""./interfaces/ICSSRRouter.sol"";

///@notice CSSR that mixes rate oracle(keydonix) and centralized(chainlink) / maintained(keep3r) oracle to broaden the oracle usage among small cap tokens
contract MochiCSSRv0 is ICSSRRouter {
    IGovernanceOwned public immutable owned;

    // bluechip will be
    // WETH,
    // WBTC,
    // USDC,
    // DAI
    mapping(address => bool) public blueChip;

    address public defaultPriceSource;
    address public defaultLiquiditySource;

    //to check if adapter is listed
    mapping(address => bool) public adapter;
    mapping(address => address) public priceSource;
    mapping(address => address) public liquiditySource;
    mapping(address => float) public lastPrice;

    ICSSRAdapter public fiatPriceAdapter;

    modifier onlyGov() {
        require(msg.sender == owned.governance(), ""!gov"");
        _;
    }

    constructor(address _owned) {
        owned = IGovernanceOwned(_owned);
    }

    function setBluechip(address[] calldata _assets) external onlyGov {
        for(uint256 i = 0; i<_assets.length; i++){
            blueChip[_assets[i]] = true;
        }
    }

    function removeBluechip(address[] calldata _assets) external onlyGov {
        for(uint256 i = 0; i<_assets.length; i++){
            blueChip[_assets[i]] = false;
        }
    }

    function listAdapter(address _adapter) external onlyGov {
        adapter[_adapter] = true;
    }

    function delistAdapter(address _adapter) external onlyGov {
        adapter[_adapter] = false;
    }

    function setFiatPriceAdapter(address _adapter) external onlyGov {
        fiatPriceAdapter = ICSSRAdapter(_adapter);
    }

    function setPriceSource(address _adapter, address[] calldata _assets) external onlyGov {
        require(adapter[_adapter], ""!listed"");
        for(uint256 i = 0; i<_assets.length; i++){
            require(ICSSRAdapter(_adapter).support(_assets[i]), ""!supported"");
            priceSource[_assets[i]] = _adapter;
        }
    }

    function setLiquiditySource(address _adapter, address[] calldata _assets)
        external
        onlyGov
    {
        require(adapter[_adapter], ""!listed"");
        for(uint256 i = 0; i<_assets.length; i++){
            require(ICSSRAdapter(_adapter).support(_assets[i]), ""!supported"");
            liquiditySource[_assets[i]] = _adapter;
        }
    }

    function setDefaultPriceSource(address _adapter) external onlyGov {
        require(adapter[_adapter], ""!listed"");
        defaultPriceSource = _adapter;
    }

    function setDefaultLiquiditySource(address _adapter) external onlyGov {
        require(adapter[_adapter], ""!listed"");
        defaultLiquiditySource = _adapter;
    }

    function update(address _asset, bytes memory _data)
        external
        override
        returns (float memory price)
    {
        if (blueChip[_asset]) {
            return fiatPriceAdapter.getPrice(_asset);
        }
        ICSSRAdapter priceAdapter = ICSSRAdapter(priceSource[_asset]);
        if (address(priceAdapter) == address(0)) {
            priceAdapter = ICSSRAdapter(defaultPriceSource);
        }
        price = priceAdapter.update(_asset, _data);
        lastPrice[_asset] = price;
    }

    function getPrice(address _asset)
        external
        view
        override
        returns (float memory)
    {
        if (blueChip[_asset]) {
            return fiatPriceAdapter.getPrice(_asset);
        } else {
            ICSSRAdapter priceAdapter = ICSSRAdapter(priceSource[_asset]);
            if (address(priceAdapter) == address(0)) {
                priceAdapter = ICSSRAdapter(defaultPriceSource);
            }
            return priceAdapter.getPrice(_asset);
        }
    }

    function getLiquidity(address _asset)
        public
        view
        override
        returns (uint256)
    {
        ICSSRAdapter liquidityAdapter = ICSSRAdapter(liquiditySource[_asset]);
        if (address(liquidityAdapter) == address(0)) {
            liquidityAdapter = ICSSRAdapter(defaultLiquiditySource);
        }
        return liquidityAdapter.getLiquidity(_asset);
    }
}",963
RealWorld_BA_42_MockEngine_RealWord_20240820153029.log,42,MockEngine,3690,3527,7217,62.0,0.08899,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""../interfaces/IGovernanceOwned.sol"";

contract MockOwned is IGovernanceOwned {
    address public override governance;

    constructor() {
        governance = msg.sender;
    }
}",54
RealWorld_BA_42_SushiswapV2Library_RealWord_20240820164943.log,42,SushiswapV2Library,22247,5521,27768,81.0,0.221655,"// SPDX-License-Identifier: MIT
// fetched from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol
// slightly modified to remove SafeMath and 0.8 compatible
pragma solidity ^0.8.0;

import { IUniswapV2Pair } from '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';

library SushiswapV2Library {

    // returns sorted token addresses, used to handle return values from pairs sorted in this order
    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
    }

    // calculates the CREATE2 address for a pair without making any external calls
    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {
        (address token0, address token1) = sortTokens(tokenA, tokenB);
        pair = address(bytes20(uint160(uint256(keccak256(abi.encodePacked(
                hex'ff',
                factory,
                keccak256(abi.encodePacked(token0, token1)),
                hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303'
            ))))));
    }

    // fetches and sorts the reserves for a pair
    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {
        (address token0,) = sortTokens(tokenA, tokenB);
        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();
        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
    }

    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset
    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {
        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');
        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        amountB = amountA * reserveB / reserveA;
    }

    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {
        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint amountInWithFee = amountIn * 997;
        uint numerator = amountInWithFee * reserveOut;
        uint denominator = reserveIn * 1000 + amountInWithFee;
        amountOut = numerator / denominator;
    }

    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {
        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint numerator = reserveIn * amountOut * 1000;
        uint denominator = (reserveOut - amountOut) * 997;
        amountIn = (numerator / denominator) + 1;
    }

    // performs chained getAmountOut calculations on any number of pairs
    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[0] = amountIn;
        for (uint i; i < path.length - 1; i++) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);
            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);
        }
    }

    // performs chained getAmountIn calculations on any number of pairs
    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[amounts.length - 1] = amountOut;
        for (uint i = path.length - 1; i > 0; i--) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);
            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);
        }
    }
}",1204
RealWorld_BA_42_IMochi_RealWord_20240820161609.log,42,IMochi,3759,4131,7890,73.0,0.101415,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IMochi is IERC20 {}",47
RealWorld_BA_42_ICurvePool_RealWord_20240820154646.log,42,ICurvePool,3988,4249,8237,69.0,0.10492,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface ICurvePool {
    function coins(uint256 _idx) external view returns (address);

    function get_virtual_price() external view returns (uint256);
}",49
RealWorld_BA_42_MerklePatriciaVerifier_RealWord_20240820165706.log,42,MerklePatriciaVerifier,22353,5435,27788,90.0,0.220465,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import { Rlp } from ""./Rlp.sol"";

library MerklePatriciaVerifier {
	/*
	 * @dev Extracts the value from a merkle proof
	 * @param expectedRoot The expected hash of the root node of the trie.
	 * @param path The path in the trie leading to value.
	 * @param proofNodesRlp RLP encoded array of proof nodes.
	 * @return The value proven to exist in the merkle patricia tree whose root is `expectedRoot` at the path `path`
	 *
	 * WARNING: Does not currently support validation of unset/0 values!
	 */
	function getValueFromProof(bytes32 expectedRoot, bytes32 path, bytes memory proofNodesRlp) internal pure returns (bytes memory value) {
		Rlp.Item memory rlpParentNodes = Rlp.toItem(proofNodesRlp);
		Rlp.Item[] memory parentNodes = Rlp.toList(rlpParentNodes);

		bytes memory currentNode;
		Rlp.Item[] memory currentNodeList;

		bytes32 nodeKey = expectedRoot;
		uint pathPtr = 0;

		// our input is a 32-byte path, but we have to prepend a single 0 byte to that and pass it along as a 33 byte memory array since that is what getNibbleArray wants
		bytes memory nibblePath = new bytes(33);
		assembly { mstore(add(nibblePath, 33), path) }
		nibblePath = _getNibbleArray(nibblePath);

		require(path.length != 0, ""empty path provided"");

		currentNode = Rlp.toBytes(parentNodes[0]);

		for (uint i=0; i<parentNodes.length; i++) {
			require(pathPtr <= nibblePath.length, ""Path overflow"");

			currentNode = Rlp.toBytes(parentNodes[i]);
			require(nodeKey == keccak256(currentNode), ""node doesn't match key"");
			currentNodeList = Rlp.toList(parentNodes[i]);

			if(currentNodeList.length == 17) {
				if(pathPtr == nibblePath.length) {
					return Rlp.toData(currentNodeList[16]);
				}

				uint8 nextPathNibble = uint8(nibblePath[pathPtr]);
				require(nextPathNibble <= 16, ""nibble too long"");
				nodeKey = Rlp.toBytes32(currentNodeList[nextPathNibble]);
				pathPtr += 1;
			} else if(currentNodeList.length == 2) {
				pathPtr += _nibblesToTraverse(Rlp.toData(currentNodeList[0]), nibblePath, pathPtr);
				// leaf node
				if(pathPtr == nibblePath.length) {
					return Rlp.toData(currentNodeList[1]);
				}
				//extension node
				require(_nibblesToTraverse(Rlp.toData(currentNodeList[0]), nibblePath, pathPtr) != 0, ""invalid extension node"");

				nodeKey = Rlp.toBytes32(currentNodeList[1]);
			} else {
				require(false, ""unexpected length array"");
			}
		}
		require(false, ""not enough proof nodes"");
	}

	function _nibblesToTraverse(bytes memory encodedPartialPath, bytes memory path, uint pathPtr) private pure returns (uint) {
		uint len;
		// encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath
		// and slicedPath have elements that are each one hex character (1 nibble)
		bytes memory partialPath = _getNibbleArray(encodedPartialPath);
		bytes memory slicedPath = new bytes(partialPath.length);

		// pathPtr counts nibbles in path
		// partialPath.length is a number of nibbles
		for(uint i=pathPtr; i<pathPtr+partialPath.length; i++) {
			bytes1 pathNibble = path[i];
			slicedPath[i-pathPtr] = pathNibble;
		}

		if(keccak256(partialPath) == keccak256(slicedPath)) {
			len = partialPath.length;
		} else {
			len = 0;
		}
		return len;
	}

	// bytes byteArray must be hp encoded
	function _getNibbleArray(bytes memory byteArray) private pure returns (bytes memory) {
		bytes memory nibbleArray;
		if (byteArray.length == 0) return nibbleArray;

		uint8 offset;
		uint8 hpNibble = uint8(_getNthNibbleOfBytes(0,byteArray));
		if(hpNibble == 1 || hpNibble == 3) {
			nibbleArray = new bytes(byteArray.length*2-1);
			bytes1 oddNibble = _getNthNibbleOfBytes(1,byteArray);
			nibbleArray[0] = oddNibble;
			offset = 1;
		} else {
			nibbleArray = new bytes(byteArray.length*2-2);
			offset = 0;
		}

		for(uint i=offset; i<nibbleArray.length; i++) {
			nibbleArray[i] = _getNthNibbleOfBytes(i-offset+2,byteArray);
		}
		return nibbleArray;
	}

	function _getNthNibbleOfBytes(uint n, bytes memory str) private pure returns (bytes1) {
		return bytes1(n%2==0 ? uint8(str[n/2])/0x10 : uint8(str[n/2])%0x10);
	}
}",1189
RealWorld_BA_42_Create2BeaconMaker_RealWord_20240820165238.log,42,Create2BeaconMaker,8835,5382,14217,90.0,0.151815,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

contract Create2BeaconMaker {
    constructor(address beacon, bytes memory initializationCalldata)
        payable
    {
        (, bytes memory returnData) = beacon.staticcall("""");
        address template = abi.decode(returnData, (address));
        // solhint-disable-next-line avoid-low-level-calls
        (bool success, ) = template.delegatecall(initializationCalldata);
        if (!success) {
            // pass along failure message from delegatecall and revert.
            // solhint-disable-next-line no-inline-assembly
            assembly {
                returndatacopy(0, 0, returndatasize())
                revert(0, returndatasize())
            }
        }

        // place eip-1167 runtime code in memory.
        bytes memory runtimeCode =
            abi.encodePacked(
                bytes6(0x3d3d3d3d3d73),
                beacon,
                bytes32(0x5afa3d82803e368260203750808036602082515af43d82803e903d91603a57fd),
                bytes2(0x5bf3)
            );

        // return Beacon Minimal Proxy code to write it to spawned contract runtime.
        // solhint-disable-next-line no-inline-assembly
        assembly {
            return(add(0x20, runtimeCode), 60) // Beacon Minimal Proxy runtime code, length
        }
    }
}",314
RealWorld_BA_42_ChainlinkAdapter_RealWord_20240820153306.log,42,ChainlinkAdapter,10758,5671,16429,93.0,0.16721,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
import ""@mochifi/library/contracts/Float.sol"";
import ""../interfaces/IGovernanceOwned.sol"";
import ""../interfaces/ICSSRAdapter.sol"";

contract ChainlinkAdapterEth is ICSSRAdapter {
    IGovernanceOwned public immutable owned;

    mapping(address => AggregatorV3Interface) public feed;

    modifier onlyGov() {
        require(msg.sender == owned.governance(), ""!gov"");
        _;
    }

    constructor(address _owned) {
        owned = IGovernanceOwned(_owned);
    }

    function update(address _asset, bytes calldata _data)
        external
        override
        returns (float memory)
    {
        return getPrice(_asset);
    }

    function setFeed(address[] calldata _assets, address[] calldata _feeds) external onlyGov {
        for(uint256 i = 0; i<_assets.length; i++) {
            feed[_assets[i]] = AggregatorV3Interface(_feeds[i]);
        }
    }

    function support(address _asset) external view override returns (bool) {
        return address(feed[_asset]) != address(0);
    }

    function getPrice(address _asset)
        public
        view
        override
        returns (float memory)
    {
        (, int256 price, , , ) = feed[_asset].latestRoundData();
        uint256 decimalSum = feed[_asset].decimals() +
            IERC20Metadata(_asset).decimals();
        if (decimalSum > 18) {
            return
                float({
                    numerator: uint256(price),
                    denominator: 10**(decimalSum - 18)
                });
        } else {
            return
                float({
                    numerator: uint256(price) * 10**(18 - decimalSum),
                    denominator: 1
                });
        }
    }

    function getLiquidity(address _asset)
        external
        view
        override
        returns (uint256)
    {
        revert(""chainlink adapter does not support liquidity"");
    }
}",470
RealWorld_BA_42_IDiscountProfile_RealWord_20240820161724.log,42,IDiscountProfile,4145,4630,8775,67.0,0.113325,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@mochifi/library/contracts/Float.sol"";

interface IDiscountProfile {
    function discount(address _user) external view returns (float memory);
}",54
RealWorld_BA_42_IUSDM_RealWord_20240820162234.log,42,IUSDM,4435,4400,8835,69.0,0.110175,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./IERC3156FlashLender.sol"";

interface IUSDM is IERC20, IERC3156FlashLender {
    function mint(address _recipient, uint256 _amount) external;

    function burn(uint256 _amount) external;
}",91
RealWorld_BA_42_Rlp_RealWord_20240820165107.log,42,Rlp,60188,5580,65768,89.0,0.41254,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

library Rlp {
    uint constant DATA_SHORT_START = 0x80;
    uint constant DATA_LONG_START = 0xB8;
    uint constant LIST_SHORT_START = 0xC0;
    uint constant LIST_LONG_START = 0xF8;

    uint constant DATA_LONG_OFFSET = 0xB7;
    uint constant LIST_LONG_OFFSET = 0xF7;


    struct Item {
        uint _unsafe_memPtr;    // Pointer to the RLP-encoded bytes.
        uint _unsafe_length;    // Number of bytes. This is the full length of the string.
    }

    struct Iterator {
        Item _unsafe_item;   // Item that's being iterated over.
        uint _unsafe_nextPtr;   // Position of the next item in the list.
    }

    /* Iterator */

    function next(Iterator memory self) internal pure returns (Item memory subItem) {
        require(hasNext(self), ""Rlp.sol:Rlp:next:1"");
        uint256 ptr = self._unsafe_nextPtr;
        uint256 itemLength = _itemLength(ptr);
        subItem._unsafe_memPtr = ptr;
        subItem._unsafe_length = itemLength;
        self._unsafe_nextPtr = ptr + itemLength;
    }

    function next(Iterator memory self, bool strict) internal pure returns (Item memory subItem) {
        subItem = next(self);
        require(!strict || _validate(subItem), ""Rlp.sol:Rlp:next:2"");
    }

    function hasNext(Iterator memory self) internal pure returns (bool) {
        Rlp.Item memory item = self._unsafe_item;
        return self._unsafe_nextPtr < item._unsafe_memPtr + item._unsafe_length;
    }

    /* Item */

    /// @dev Creates an Item from an array of RLP encoded bytes.
    /// @param self The RLP encoded bytes.
    /// @return An Item
    function toItem(bytes memory self) internal pure returns (Item memory) {
        uint len = self.length;
        if (len == 0) {
            return Item(0, 0);
        }
        uint memPtr;
        assembly {
            memPtr := add(self, 0x20)
        }
        return Item(memPtr, len);
    }

    /// @dev Creates an Item from an array of RLP encoded bytes.
    /// @param self The RLP encoded bytes.
    /// @param strict Will throw if the data is not RLP encoded.
    /// @return An Item
    function toItem(bytes memory self, bool strict) internal pure returns (Item memory) {
        Rlp.Item memory item = toItem(self);
        if(strict) {
            uint len = self.length;
            require(_payloadOffset(item) <= len, ""Rlp.sol:Rlp:toItem4"");
            require(_itemLength(item._unsafe_memPtr) == len, ""Rlp.sol:Rlp:toItem:5"");
            require(_validate(item), ""Rlp.sol:Rlp:toItem:6"");
        }
        return item;
    }

    /// @dev Check if the Item is null.
    /// @param self The Item.
    /// @return 'true' if the item is null.
    function isNull(Item memory self) internal pure returns (bool) {
        return self._unsafe_length == 0;
    }

    /// @dev Check if the Item is a list.
    /// @param self The Item.
    /// @return 'true' if the item is a list.
    function isList(Item memory self) internal pure returns (bool) {
        if (self._unsafe_length == 0)
            return false;
        uint memPtr = self._unsafe_memPtr;
        bool result;
        assembly {
            result := iszero(lt(byte(0, mload(memPtr)), 0xC0))
        }
        return result;
    }

    /// @dev Check if the Item is data.
    /// @param self The Item.
    /// @return 'true' if the item is data.
    function isData(Item memory self) internal pure returns (bool) {
        if (self._unsafe_length == 0)
            return false;
        uint memPtr = self._unsafe_memPtr;
        bool result;
        assembly {
            result := lt(byte(0, mload(memPtr)), 0xC0)
        }
        return result;
    }

    /// @dev Check if the Item is empty (string or list).
    /// @param self The Item.
    /// @return result 'true' if the item is null.
    function isEmpty(Item memory self) internal pure returns (bool) {
        if(isNull(self))
            return false;
        uint b0;
        uint memPtr = self._unsafe_memPtr;
        assembly {
            b0 := byte(0, mload(memPtr))
        }
        return (b0 == DATA_SHORT_START || b0 == LIST_SHORT_START);
    }

    /// @dev Get the number of items in an RLP encoded list.
    /// @param self The Item.
    /// @return The number of items.
    function items(Item memory self) internal pure returns (uint) {
        if (!isList(self))
            return 0;
        uint b0;
        uint memPtr = self._unsafe_memPtr;
        assembly {
            b0 := byte(0, mload(memPtr))
        }
        uint pos = memPtr + _payloadOffset(self);
        uint last = memPtr + self._unsafe_length - 1;
        uint itms;
        while(pos <= last) {
            pos += _itemLength(pos);
            itms++;
        }
        return itms;
    }

    /// @dev Create an iterator.
    /// @param self The Item.
    /// @return An 'Iterator' over the item.
    function iterator(Item memory self) internal pure returns (Iterator memory) {
        require(isList(self), ""Rlp.sol:Rlp:iterator:1"");
        uint ptr = self._unsafe_memPtr + _payloadOffset(self);
        Iterator memory it;
        it._unsafe_item = self;
        it._unsafe_nextPtr = ptr;
        return it;
    }

    /// @dev Return the RLP encoded bytes.
    /// @param self The Item.
    /// @return The bytes.
    function toBytes(Item memory self) internal pure returns (bytes memory) {
        uint256 len = self._unsafe_length;
        require(len != 0, ""Rlp.sol:Rlp:toBytes:2"");
        bytes memory bts;
        bts = new bytes(len);
        _copyToBytes(self._unsafe_memPtr, bts, len);
        return bts;
    }

    /// @dev Decode an Item into bytes. This will not work if the
    /// Item is a list.
    /// @param self The Item.
    /// @return The decoded string.
    function toData(Item memory self) internal pure returns (bytes memory) {
        require(isData(self));
        (uint256 rStartPos, uint256 len) = _decode(self);
        bytes memory bts;
        bts = new bytes(len);
        _copyToBytes(rStartPos, bts, len);
        return bts;
    }

    /// @dev Get the list of sub-items from an RLP encoded list.
    /// Warning: This is inefficient, as it requires that the list is read twice.
    /// @param self The Item.
    /// @return Array of Items.
    function toList(Item memory self) internal pure returns (Item[] memory) {
        require(isList(self), ""Rlp.sol:Rlp:toList:1"");
        uint256 numItems = items(self);
        Item[] memory list = new Item[](numItems);
        Rlp.Iterator memory it = iterator(self);
        uint idx;
        while(hasNext(it)) {
            list[idx] = next(it);
            idx++;
        }
        return list;
    }

    /// @dev Decode an Item into an ascii string. This will not work if the
    /// Item is a list.
    /// @param self The Item.
    /// @return The decoded string.
    function toAscii(Item memory self) internal pure returns (string memory) {
        require(isData(self), ""Rlp.sol:Rlp:toAscii:1"");
        (uint256 rStartPos, uint256 len) = _decode(self);
        bytes memory bts = new bytes(len);
        _copyToBytes(rStartPos, bts, len);
        string memory str = string(bts);
        return str;
    }

    /// @dev Decode an Item into a uint. This will not work if the
    /// Item is a list.
    /// @param self The Item.
    /// @return The decoded string.
    function toUint(Item memory self) internal pure returns (uint) {
        require(isData(self), ""Rlp.sol:Rlp:toUint:1"");
        (uint256 rStartPos, uint256 len) = _decode(self);
        require(len <= 32, ""Rlp.sol:Rlp:toUint:3"");
        require(len != 0, ""Rlp.sol:Rlp:toUint:4"");
        uint data;
        assembly {
            data := div(mload(rStartPos), exp(256, sub(32, len)))
        }
        return data;
    }

    /// @dev Decode an Item into a boolean. This will not work if the
    /// Item is a list.
    /// @param self The Item.
    /// @return The decoded string.
    function toBool(Item memory self) internal pure returns (bool) {
        require(isData(self), ""Rlp.sol:Rlp:toBool:1"");
        (uint256 rStartPos, uint256 len) = _decode(self);
        require(len == 1, ""Rlp.sol:Rlp:toBool:3"");
        uint temp;
        assembly {
            temp := byte(0, mload(rStartPos))
        }
        require(temp <= 1, ""Rlp.sol:Rlp:toBool:8"");
        return temp == 1 ? true : false;
    }

    /// @dev Decode an Item into a byte. This will not work if the
    /// Item is a list.
    /// @param self The Item.
    /// @return The decoded string.
    function toByte(Item memory self) internal pure returns (bytes1) {
        require(isData(self), ""Rlp.sol:Rlp:toByte:1"");
        (uint256 rStartPos, uint256 len) = _decode(self);
        require(len == 1, ""Rlp.sol:Rlp:toByte:3"");
        bytes1 temp;
        assembly {
            temp := byte(0, mload(rStartPos))
        }
        return bytes1(temp);
    }

    /// @dev Decode an Item into an int. This will not work if the
    /// Item is a list.
    /// @param self The Item.
    /// @return The decoded string.
    function toInt(Item memory self) internal pure returns (int) {
        return int(toUint(self));
    }

    /// @dev Decode an Item into a bytes32. This will not work if the
    /// Item is a list.
    /// @param self The Item.
    /// @return The decoded string.
    function toBytes32(Item memory self) internal pure returns (bytes32) {
        return bytes32(toUint(self));
    }

    /// @dev Decode an Item into an address. This will not work if the
    /// Item is a list.
    /// @param self The Item.
    /// @return The decoded string.
    function toAddress(Item memory self) internal pure returns (address) {
        require(isData(self), ""Rlp.sol:Rlp:toAddress:1"");
        (uint256 rStartPos, uint256 len) = _decode(self);
        require(len == 20, ""Rlp.sol:Rlp:toAddress:3"");
        address data;
        assembly {
            data := div(mload(rStartPos), exp(256, 12))
        }
        return data;
    }

    // Get the payload offset.
    function _payloadOffset(Item memory self) private pure returns (uint) {
        if(self._unsafe_length == 0)
            return 0;
        uint b0;
        uint memPtr = self._unsafe_memPtr;
        assembly {
            b0 := byte(0, mload(memPtr))
        }
        if(b0 < DATA_SHORT_START)
            return 0;
        if(b0 < DATA_LONG_START || (b0 >= LIST_SHORT_START && b0 < LIST_LONG_START))
            return 1;
        if(b0 < LIST_SHORT_START)
            return b0 - DATA_LONG_OFFSET + 1;
        return b0 - LIST_LONG_OFFSET + 1;
    }

    // Get the full length of an Item.
    function _itemLength(uint memPtr) private pure returns (uint len) {
        uint b0;
        assembly {
            b0 := byte(0, mload(memPtr))
        }
        if (b0 < DATA_SHORT_START)
            len = 1;
        else if (b0 < DATA_LONG_START)
            len = b0 - DATA_SHORT_START + 1;
        else if (b0 < LIST_SHORT_START) {
            assembly {
                let bLen := sub(b0, 0xB7) // bytes length (DATA_LONG_OFFSET)
                let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length
                len := add(1, add(bLen, dLen)) // total length
            }
        }
        else if (b0 < LIST_LONG_START)
            len = b0 - LIST_SHORT_START + 1;
        else {
            assembly {
                let bLen := sub(b0, 0xF7) // bytes length (LIST_LONG_OFFSET)
                let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length
                len := add(1, add(bLen, dLen)) // total length
            }
        }
    }

    // Get start position and length of the data.
    function _decode(Item memory self) private pure returns (uint memPtr, uint len) {
        require(isData(self), ""Rlp.sol:Rlp:_decode:1"");
        uint b0;
        uint start = self._unsafe_memPtr;
        assembly {
            b0 := byte(0, mload(start))
        }
        if (b0 < DATA_SHORT_START) {
            memPtr = start;
            len = 1;
            return (memPtr, len);
        }
        if (b0 < DATA_LONG_START) {
            len = self._unsafe_length - 1;
            memPtr = start + 1;
        } else {
            uint bLen;
            assembly {
                bLen := sub(b0, 0xB7) // DATA_LONG_OFFSET
            }
            len = self._unsafe_length - 1 - bLen;
            memPtr = start + bLen + 1;
        }
        return (memPtr, len);
    }

    // Assumes that enough memory has been allocated to store in target.
    function _copyToBytes(uint sourceBytes, bytes memory destinationBytes, uint btsLen) internal pure {
        // Exploiting the fact that 'tgt' was the last thing to be allocated,
        // we can write entire words, and just overwrite any excess.
        assembly {
            let words := div(add(btsLen, 31), 32)
            let sourcePointer := sourceBytes
            let destinationPointer := add(destinationBytes, 32)
            for { let i := 0 } lt(i, words) { i := add(i, 1) }
            {
                let offset := mul(i, 32)
                mstore(add(destinationPointer, offset), mload(add(sourcePointer, offset)))
            }
            mstore(add(destinationBytes, add(32, mload(destinationBytes))), 0)
        }
    }

    // Check that an Item is valid.
    function _validate(Item memory self) private pure returns (bool ret) {
        // Check that RLP is well-formed.
        uint b0;
        uint b1;
        uint memPtr = self._unsafe_memPtr;
        assembly {
            b0 := byte(0, mload(memPtr))
            b1 := byte(1, mload(memPtr))
        }
        if(b0 == DATA_SHORT_START + 1 && b1 < DATA_SHORT_START)
            return false;
        return true;
    }

    function rlpBytesToUint256(bytes memory source) internal pure returns (uint256 result) {
        return Rlp.toUint(Rlp.toItem(source));
    }
}",3545
RealWorld_BA_42_UQ112x112_RealWord_20240820164632.log,42,UQ112x112,6807,4520,11327,72.0,0.124435,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

// https://raw.githubusercontent.com/Uniswap/uniswap-v2-core/master/contracts/libraries/UQ112x112.sol
// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))

// range: [0, 2**112 - 1]
// resolution: 1 / 2**112

library UQ112x112 {
    uint224 constant Q112 = 2**112;

    // encode a uint112 as a UQ112x112
    function encode(uint112 y) internal pure returns (uint224 z) {
        z = uint224(y) * Q112; // never overflows
    }

    // divide a UQ112x112 by a uint112, returning a UQ112x112
    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {
        z = x / uint224(y);
    }
}",213
RealWorld_BA_42_IERC3156FlashLender_RealWord_20240820163137.log,42,IERC3156FlashLender,7632,4627,12259,89.0,0.1307,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""./IERC3156FlashBorrower.sol"";

interface IERC3156FlashLender {
    /**
     * @dev The amount of currency available to be lent.
     * @param token The loan currency.
     * @return The amount of `token` that can be borrowed.
     */
    function maxFlashLoan(address token) external view returns (uint256);

    /**
     * @dev The fee to be charged for a given loan.
     * @param token The loan currency.
     * @param amount The amount of tokens lent.
     * @return The amount of `token` to be charged for the loan, on top of the returned principal.
     */
    function flashFee(address token, uint256 amount)
        external
        view
        returns (uint256);

    /**
     * @dev Initiate a flash loan.
     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.
     * @param token The loan currency.
     * @param amount The amount of tokens lent.
     * @param data Arbitrary data structure, intended to contain user-defined parameters.
     */
    function flashLoan(
        IERC3156FlashBorrower receiver,
        address token,
        uint256 amount,
        bytes calldata data
    ) external returns (bool);
}",293
RealWorld_BA_42_IMochiVaultFactory_RealWord_20240820162519.log,42,IMochiVaultFactory,4210,3906,8116,87.0,0.09917,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""./IMochiVault.sol"";

interface IMochiVaultFactory {
    function updateTemplate(address _template) external;

    function deployVault(address _asset) external returns (IMochiVault);

    function getVault(address _asset) external view returns (IMochiVault);
}",80
RealWorld_BA_42_Float_RealWord_20240820164746.log,42,Float,17431,6097,23528,114.0,0.209095,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

struct float {
    uint256 numerator;
    uint256 denominator;
}

library Float {
    function multiply(uint256 a, float memory f) internal pure returns(uint256) {
        require(f.denominator != 0, ""div 0"");
        return a * f.numerator / f.denominator;
    }

    function inverse(float memory f) internal pure returns(float memory) {
        require(f.numerator != 0 && f.denominator != 0, ""div 0"");
        return float({
            numerator: f.denominator,
            denominator: f.numerator
        });
    }

    function divide(uint256 a, float memory f) internal pure returns(uint256) {
        require(f.denominator != 0, ""div 0"");
        return a * f.denominator / f.numerator;
    }

    function add(float memory a, float memory b) internal pure returns(float memory res) {
        require(a.denominator != 0 && b.denominator != 0, ""div 0"");
        res = float({
            numerator : a.numerator*b.denominator + a.denominator*b.numerator,
            denominator : a.denominator*b.denominator
        });
        if(res.numerator > 2**128 && res.denominator > 2**128){
            res.numerator = res.numerator / 2**64;
            res.denominator = res.denominator / 2**64;
        }
    }
    
    function sub(float memory a, float memory b) internal pure returns(float memory res) {
        require(a.denominator != 0 && b.denominator != 0, ""div 0"");
        res = float({
            numerator : a.numerator*b.denominator - b.numerator*a.denominator,
            denominator : a.denominator*b.denominator
        });
        if(res.numerator > 2**128 && res.denominator > 2**128){
            res.numerator = res.numerator / 2**64;
            res.denominator = res.denominator / 2**64;
        }
    }

    function mul(float memory a, float memory b) internal pure returns(float memory res) {
        require(a.denominator != 0 && b.denominator != 0, ""div 0"");
        res = float({
            numerator : a.numerator * b.numerator,
            denominator : a.denominator * b.denominator
        });
        if(res.numerator > 2**128 && res.denominator > 2**128){
            res.numerator = res.numerator / 2**64;
            res.denominator = res.denominator / 2**64;
        }
    }

    function gt(float memory a, float memory b) internal pure returns(bool) {
        require(a.denominator != 0 && b.denominator != 0, ""div 0"");
        return a.numerator * b.denominator > a.denominator * b.numerator;
    }

    function lt(float memory a, float memory b) internal pure returns(bool) {
        require(a.denominator != 0 && b.denominator != 0, ""div 0"");
        return a.numerator * b.denominator < a.denominator * b.numerator;
    }

    function gte(float memory a, float memory b) internal pure returns(bool) {
        require(a.denominator != 0 && b.denominator != 0, ""div 0"");
        return a.numerator * b.denominator >= a.denominator * b.numerator;
    }

    function lte(float memory a, float memory b) internal pure returns(bool) {
        require(a.denominator != 0 && b.denominator != 0, ""div 0"");
        return a.numerator * b.denominator <= a.denominator * b.numerator;
    }

    function equals(float memory a, float memory b) internal pure returns(bool) {
        require(a.denominator != 0 && b.denominator != 0, ""div 0"");
        return a.numerator * b.denominator == b.numerator * a.denominator;
    }
}",854
RealWorld_BA_42_MochiNft_RealWord_20240820161323.log,42,MochiNft,9096,5109,14205,99.0,0.14766,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import ""../interfaces/IMochiNFT.sol"";
import ""../interfaces/IMochiEngine.sol"";
import ""../interfaces/IMochiPositionDescriptor.sol"";

contract MochiNFT is IMochiNFT, ERC721Enumerable {
    IMochiEngine public immutable engine;
    address public descriptor;

    mapping(uint256 => MochiInfo) public info;

    constructor(address _engine) ERC721(""MochiPositionNFT"", ""MOCHI-POS"") {
        engine = IMochiEngine(_engine);
    }

    function setDescriptor(address _descriptor) external {
        require(msg.sender == engine.governance(), ""!governance"");
        descriptor = _descriptor;
    }

    function mint(address _asset, address _owner)
        external
        override
        returns (uint256 id)
    {
        require(
            msg.sender == address(engine.vaultFactory().getVault(_asset)),
            ""!vault""
        );
        id = totalSupply();
        _mint(_owner, id);
        info[id].asset = _asset;
    }

    function asset(uint256 _id) external view override returns (address) {
        return info[_id].asset;
    }

    function tokenURI(uint256 _id)
        public
        view
        override
        returns (string memory)
    {
        if (descriptor == address(0)) {
            return """";
        } else {
            return
                IMochiPositionDescriptor(descriptor).getTokenURI(
                    address(this),
                    _id
                );
        }
    }
}",357
RealWorld_BA_42_IMinter_RealWord_20240820162649.log,42,IMinter,4112,3888,8000,68.0,0.09832,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

interface IMinter {
    function mint(address _to, uint256 _amount) external;

    function hasPermission(address _user) external view returns (bool);

    function isVault(address _vault) external view returns(bool);
}",67
RealWorld_BA_42_MockVMochi_RealWord_20240820155430.log,42,MockVMochi,3537,3953,7490,72.0,0.096745,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@mochifi/vmochi/contracts/vMochi.sol"";

contract MockVMochi {}",44
RealWorld_BA_42_IUniswapV2CSSR_RealWord_20240820154342.log,42,IUniswapV2CSSR,7002,4904,11906,83.0,0.13309,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

struct Window {
    uint128 from;
    uint128 to;
}

struct BlockData {
    uint256 blockTimestamp;
    bytes32 stateRoot;
}

struct ObservedData {
    uint32 reserveTimestamp;
    uint112 reserve0;
    uint112 reserve1;
    uint256 price0Data;
    uint256 price1Data;
}

interface IUniswapV2CSSR {
    function uniswapFactory() external view returns (address);

    function getExchangeRatio(address token, address denominator)
        external
        view
        returns (uint256);

    function getLiquidity(address token, address denominator)
        external
        view
        returns (uint256);

    function saveState(bytes memory blockData)
        external
        returns (
            bytes32 stateRoot,
            uint256 blockNumber,
            uint256 blockTimestamp
        );

    function saveReserve(
        uint256 blockNumber,
        address pair,
        bytes memory accountProof,
        bytes memory reserveProof,
        bytes memory price0Proof,
        bytes memory price1Proof
    ) external returns (ObservedData memory data);
}",244
RealWorld_BA_42_IReferralFeePool_RealWord_20240820161833.log,42,IReferralFeePool,3774,4362,8136,64.0,0.10611,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

interface IReferralFeePool {
    function addReward(address _recipient) external;
}",39
RealWorld_BA_42_MockWETH_RealWord_20240820155545.log,42,MockWETH,4649,4516,9165,68.0,0.113565,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MockWETH is ERC20 {
    constructor() ERC20(""MockWETH"", ""MOCKWETH"") {
        _mint(msg.sender, 10000000000000000e18);
    }

    receive() external payable {}

    function mint(uint256 _amount) external {
        _mint(msg.sender, _amount);
    }
}",108
RealWorld_BA_42_VestedRewardPool_RealWord_20240820155802.log,42,VestedRewardPool,12820,5352,18172,87.0,0.17114,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""../interfaces/IMochi.sol"";
import ""@mochifi/vmochi/contracts/interfaces/IVMochi.sol"";

contract VestedRewardPool {
    IMochi public immutable mochi;
    IVMochi public immutable vMochi;

    uint256 public mochiUnderManagement;

    mapping(address => Vesting) public vesting;

    struct Vesting {
        uint256 vested;
        uint256 ends;
        uint256 claimable;
    }

    modifier checkClaimable(address recipient) {
        if (vesting[recipient].ends < block.timestamp) {
            vesting[recipient].claimable += vesting[recipient].vested;
            vesting[recipient].vested = 0;
            vesting[recipient].ends = 0;
        }
        _;
    }

    constructor(address _mochi, address _vmochi) {
        mochi = IMochi(_mochi);
        vMochi = IVMochi(_vmochi);
    }

    function vest(address _recipient) external checkClaimable(_recipient) {
        uint256 amount = mochi.balanceOf(address(this)) - mochiUnderManagement;
        uint256 weightedEnd = (vesting[_recipient].vested *
            vesting[_recipient].ends +
            amount *
            (block.timestamp + 90 days)) /
            (vesting[_recipient].vested + amount);
        vesting[_recipient].vested += amount;
        vesting[_recipient].ends = weightedEnd;
        mochiUnderManagement += amount;
    }

    function claim() external checkClaimable(msg.sender) {
        mochi.transfer(msg.sender, vesting[msg.sender].claimable);
        mochiUnderManagement -= vesting[msg.sender].claimable;
        vesting[msg.sender].claimable = 0;
    }

    function lock(uint256 _amount) external checkClaimable(msg.sender) {
        mochi.approve(address(vMochi), _amount);
        (, uint256 end) = vMochi.locked(msg.sender);
        if (end >= block.timestamp + 90 days) {
            vMochi.depositFor(msg.sender, _amount);
        } else {
            revert(""lock should be longer than 90 days"");
        }
        vesting[msg.sender].vested -= _amount;
        mochiUnderManagement -= _amount;
    }

    function forceClaim(uint256 _amount) external checkClaimable(msg.sender) {
        mochi.transfer(msg.sender, _amount / 2);
        mochi.transfer(address(vMochi), _amount / 2);
        vesting[msg.sender].vested -= _amount;
        mochiUnderManagement -= _amount;
    }
}",586
RealWorld_BA_42_CheapERC20_RealWord_20240820164226.log,42,CheapERC20,6763,4788,11551,77.0,0.129575,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

library CheapERC20 {
    function cheapTransfer(IERC20 asset, address to, uint value) internal {
        (bool success, bytes memory data) = address(asset).call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Mochi Vault: TRANSFER_FAILED');
    }
    
    function cheapTransferFrom(IERC20 asset, address from, address to, uint value) internal {
        (bool success, bytes memory data) = address(asset).call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Mochi Vault: TRANSFER_FROM_FAILED');
    }
}",205
RealWorld_BA_42_MochiEngine_RealWord_20240820155038.log,42,MochiEngine,13619,5065,18684,78.0,0.169395,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""./vault/MochiVaultFactory.sol"";
import ""./assets/usdm.sol"";
import ""./interfaces/IMochiEngine.sol"";

contract MochiEngine is IMochiEngine {
    // immutable values
    IMochiVaultFactory public immutable override vaultFactory;
    // mutable values
    IMochi public override mochi;
    IVMochi public override vMochi;
    address public override governance;
    address public override treasury;
    address public override operationWallet;
    IUSDM public override usdm;
    IMinter public override minter;
    ICSSRRouter public override cssr;
    IMochiProfile public override mochiProfile;
    IDiscountProfile public override discountProfile;
    ILiquidator public override liquidator;
    IFeePool public override feePool;
    IReferralFeePool public override referralFeePool;
    IMochiNFT public override nft;

    constructor(address _governance) {
        governance = _governance;
        vaultFactory = IMochiVaultFactory(new MochiVaultFactory(address(this)));
        operationWallet = msg.sender;
    }

    modifier onlyGov() {
        require(msg.sender == governance, ""!gov"");
        _;
    }

    function changeMochi(address _mochi) external onlyGov {
        mochi = IMochi(_mochi);
    }

    function changeVMochi(address _vmochi) external onlyGov {
        vMochi = IVMochi(_vmochi);
    }

    function changeUSDM(address _usdm) external onlyGov {
        usdm = IUSDM(_usdm);
    }

    function changeMinter(address _minter) external onlyGov {
        minter = IMinter(_minter);
    }

    function changeGovernance(address _governance) external onlyGov {
        governance = _governance;
    }

    function changeTreasury(address _treasury) external onlyGov {
        treasury = _treasury;
    }

    function changeOperationWallet(address _operation) external onlyGov {
        operationWallet = _operation;
    }

    function changeCSSR(address _cssr) external onlyGov {
        cssr = ICSSRRouter(_cssr);
    }

    function changeProfile(address _profile) external onlyGov {
        mochiProfile = IMochiProfile(_profile);
    }

    function changeDiscountProfile(address _profile) external onlyGov {
        discountProfile = IDiscountProfile(_profile);
    }

    function changeLiquidator(address _liquidator) external onlyGov {
        liquidator = ILiquidator(_liquidator);
    }

    function changeFeePool(address _feePool) external onlyGov {
        feePool = IFeePool(_feePool);
    }

    function changeReferralFeePool(address _referralFeePool) external onlyGov {
        referralFeePool = IReferralFeePool(_referralFeePool);
    }

    function changeNFT(address _nft) external onlyGov {
        nft = IMochiNFT(_nft);
    }
}",661
RealWorld_BA_43_DelegatedStaking_RealWord_20240820171451.log,43,DelegatedStaking,91466,5698,97164,125.0,0.57129,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";

contract DelegatedStaking is OwnableUpgradeable{
    using SafeERC20Upgradeable for IERC20Upgradeable;
    uint256 constant divider = 10**18; // 18 decimals used for scaling the rates
    uint128 validatorCoolDown; // how many epochs until validator unstaking is unlocked
    uint128 delegatorCoolDown; // how many epochs until delegator unstaking is unlocked
    uint128 maxCapMultiplier;
    uint128 validatorMinStakedRequired; // minimum # of tokens validator is required to have staked
    uint128 allocatedTokensPerEpoch; // # of tokens per epoch to be distributed
    uint128 rewardsLocked; // # of tokens the owner sent to the contract
    uint128 endEpoch; // the epoch when the contract will be out of allocated reward tokens
    uint128 totalGlobalShares; // global shares
    uint128 lastUpdateEpoch; // block # when the global exchange rate was updated last
    uint128 globalExchangeRate;
    uint128 validatorsN; // number of validators, used to get validator ids
    mapping(uint128 => Validator) validators; // id -> validator instance
    IERC20Upgradeable constant CQT = IERC20Upgradeable(0xD417144312DbF50465b1C641d016962017Ef6240);

    struct Staking {
        uint128 staked; // initial CQT amount staked
        uint128 shares; // # of validator shares that delegate owns
    }
    struct Unstaking {
        uint128 coolDownEnd; // epoch when unstaking can be redeemed
        uint128 amount;
    }
    struct Validator {
        address _address;
        address operator;
        uint128 commissionRate; // validator commission rate
        uint128 disabledEpoch; // epoch when validator got disabled, if set to 0, validator is enabled
        uint128 globalShares; // total number of global shares under a validator
        uint128 lastUpdateGlobalRate; // global exchange rate when the validator was updated the last time
        uint128 totalShares; // total number of validator shares
        uint128 delegated; // total number of tokens originally staked/delegated to the validator, this does not include interest
        uint128 exchangeRate; // validator exchange rate
        uint128 commissionAvailableToRedeem; // # of CQTs paid to the validator
        mapping(address => Staking) stakings;
        mapping(address => Unstaking[]) unstakings;
    }
    event RewardTokensDeposited(uint128 amount);
    event ValidatorAdded(uint128 indexed id, address indexed validator, address indexed operator);
    event ValidatorDisabled(uint128 indexed id);
    event Staked(uint128 indexed validatorId, address delegator, uint128 amount);
    event Unstaked(uint128 indexed validatorId, address indexed delegator, uint128 amount);
    event RecoveredUnstake(uint128 indexed validatorId, address indexed delegator, uint128 amount, uint128 unstakingId);
    event UnstakeRedeemed(uint128 indexed validatorId, address indexed delegator, uint128 amount);
    event RewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);
    event CommissionRewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);
    event AllocatedTokensTaken(uint128 amount);
    event MaxCapMultiplierChanged(uint128 amount);
    event TransferredUnstake(uint128 indexed oldValidatorId, uint128 indexed newValidatorId, address indexed delegator, uint128 amount, uint128 unstakingId);
    event EmissionRateChanged(uint128 newRate);
    event ValidatorCommissionRateChanged(uint128 indexed validatorId, uint128 newRate);
    event ValidatorMinStakedRequiredChanged(uint128 amount);
    event Initialized(uint128 minStakedRequired, uint128 validatorCoolDown, uint128 delegatorCoolDown, uint128 maxCapMultiplier, uint128 allocatedTokensPerEpoch, uint128 globalExchangeRate);

    // this is used to have the contract upgradeable
    function initialize(uint128 minStakedRequired) public initializer {
        __Ownable_init();
        validatorMinStakedRequired = minStakedRequired;
        validatorCoolDown = 180*6646; // ~ 6 months
        delegatorCoolDown = 28*6646; // ~ 28 days
        maxCapMultiplier = 10;
        allocatedTokensPerEpoch = 1*10**18; // should never be 0
        globalExchangeRate = 10**18; // 1 to 1
        emit Initialized(minStakedRequired, validatorCoolDown, delegatorCoolDown, maxCapMultiplier, allocatedTokensPerEpoch, globalExchangeRate);
    }

    // used to transfer CQT from delegators, validators and the owner to the contract
    function _transferToContract(address from, uint128 amount) internal {
        CQT.safeTransferFrom(from, address(this), amount);
    }

    // used to transfer CQT from contract, for rewards redemption or transferring out unstaked
    function _transferFromContract(address to, uint128 amount) internal {
        CQT.safeTransfer(to, amount);
    }

    // transfer CQT from the owner to the contract for rewards allocation, must change end epoch
    function depositRewardTokens(uint128 amount) public onlyOwner {
        require(amount >= allocatedTokensPerEpoch, ""Does not cover least 1 epoch"");
        require(amount % allocatedTokensPerEpoch == 0, ""Not multiple"");
        if (endEpoch != 0) {
            unchecked { endEpoch += amount / allocatedTokensPerEpoch; }
        }
        else{
            unchecked { rewardsLocked += amount; }
        }
        _transferToContract(msg.sender, amount);
        emit RewardTokensDeposited(amount);
    }

    // transfer reward CQT from the contract to the owner, must change end epoch and not allow transfer from the past
    function takeOutRewardTokens(uint128 amount) public onlyOwner {
        require(amount > 0, ""Amount is 0"");
        require(amount % allocatedTokensPerEpoch == 0, ""Not multiple"");
        if (endEpoch != 0){
            uint128 currentEpoch = uint128(block.number);
            uint128 epochs = amount / allocatedTokensPerEpoch;
            require(endEpoch - epochs > currentEpoch, ""Cannot takeout rewards from past"");
            unchecked { endEpoch = endEpoch - epochs; }
        }
        else{
            require(rewardsLocked >= amount, ""Amount is greater than available"");
            unchecked { rewardsLocked -= amount; }
        }
        _transferFromContract(msg.sender, amount);
        emit AllocatedTokensTaken(amount);
    }

    // update global exchange rate
    function _updateGlobalExchangeRate() internal {
        uint128 currentBlock = uint128(block.number);
        // if the program ended, set update epoch to the end epoch
        uint128 currentEpoch = currentBlock < endEpoch? currentBlock : endEpoch;
        if (currentEpoch != lastUpdateEpoch){
            // when no one has staked anything, do not update the rate
            if(totalGlobalShares > 0)
            {
                unchecked { globalExchangeRate += uint128(uint256(allocatedTokensPerEpoch) * divider * uint256(currentEpoch - lastUpdateEpoch)/uint256(totalGlobalShares)) ; }
            }
            lastUpdateEpoch = currentEpoch;
        }
    }

    // update validator exchange rate
    function _updateValidator(Validator storage v) internal {
        // if validator is disabled, we do not update it since it was updated during disabling transaction
        if(v.disabledEpoch == 0){
            if (v.totalShares == 0){
                // when validator stakes the first time, the exchange rate must be equal to the current global exchange rate
                v.exchangeRate = globalExchangeRate;
            }
            else {
                // the growth of global exchange rate since the validator was updated the last time
                uint128 rateDifference;
                unchecked { rateDifference = globalExchangeRate - v.lastUpdateGlobalRate; }
                // tokens given to the validator and its delegators since last update
                uint128 tokensGivenToValidator = _sharesToTokens(v.globalShares, rateDifference);
                // commission paid out of the tokens
                uint128 commissionPaid = uint128(uint256(tokensGivenToValidator) * uint256(v.commissionRate) /  divider);
                // increase validator exchange rate by distributing the leftover tokens through the validator shares
                v.exchangeRate += uint128(uint256(tokensGivenToValidator - commissionPaid) * divider / v.totalShares);
                // give commission tokens to the validator
                unchecked { v.commissionAvailableToRedeem += commissionPaid; }
            }
            // set the last update global rate to the current one
            v.lastUpdateGlobalRate = globalExchangeRate;
        }
    }
    // used to convert global shares or validator shares to CQT
    function _sharesToTokens(uint128 sharesN, uint128 rate) internal view returns(uint128){
        return uint128(uint256(sharesN) * uint256(rate) / divider);
    }
    // used to convert CQT to global shares or validator shares
    function _tokensToShares(uint128 amount, uint128 rate) internal view returns(uint128){
        return uint128(uint256(amount) * divider / uint256(rate));
    }

    function stake(uint128 validatorId, uint128 amount) public {
        _stake(validatorId, amount, true);
    }
    // need to update global exchange rate, validator data and then delegator instance
    // withTransfer set to false when delegators recover unstake, because the tokens are already in the contract
    function _stake(uint128 validatorId, uint128 amount, bool withTransfer) internal {
        require(amount >= divider, ""Amount must be at least 1 token"");
        require(validatorId < validatorsN, ""Invalid validator"");
        Validator storage v = validators[validatorId];
        require(v.disabledEpoch == 0, ""Validator is disabled"");
        // if this is the first stake, then set the end epoch
        if (endEpoch == 0){
            unchecked { endEpoch = uint128(block.number) + rewardsLocked / allocatedTokensPerEpoch; }
            rewardsLocked = 0; // no longer used and saves a bit of gas
        }
        require(endEpoch > block.number, ""Program ended"");
        _updateGlobalExchangeRate();
        _updateValidator(v);
        // if staker is validator who self delegates
        if (msg.sender == v._address){
            require(amount + v.stakings[msg.sender].staked >= validatorMinStakedRequired, ""Amount < min staked required"");
        }
        else {
            // otherwise need to check for max cap
            uint128 validatorStaked = v.stakings[v._address].staked;
            uint128 validatorMaxCap = validatorStaked * maxCapMultiplier;
            uint128 newDelegated = v.delegated - validatorStaked + amount;
            require(newDelegated <= validatorMaxCap, ""Validator max capacity exceeded"");
        }
        // it is set to true when there is a stake
        // it is set to false when we recover delegation from unstaking
        if (withTransfer)
            _transferToContract(msg.sender, amount);
        Staking storage s = v.stakings[msg.sender];

        // update global shares #
        uint128 globalSharesToAdd = _tokensToShares(amount, globalExchangeRate);
        unchecked { totalGlobalShares += globalSharesToAdd; }
        unchecked { v.globalShares += globalSharesToAdd; }

        // update validator shares #
        uint128 newDelegatorSharesN = _tokensToShares(amount, v.exchangeRate);
        unchecked { v.totalShares += newDelegatorSharesN; }
        unchecked { s.shares += newDelegatorSharesN; }
        unchecked { v.delegated += amount; }
        unchecked { s.staked += amount; }
        emit Staked(validatorId, msg.sender, amount);
    }

    // need to update global exchange rate, validator data and then delegator instance
    function unstake(uint128 validatorId, uint128 amount) public {
        require(validatorId < validatorsN, ""Invalid validator"");
        Validator storage v = validators[validatorId];
        Staking storage s = v.stakings[msg.sender];
        require(s.staked >= amount, ""Staked < amount provided"");
        bool isValidator = msg.sender == v._address;
        _updateGlobalExchangeRate();
        _updateValidator(v);
        // only update if the validator is enabled, otherwise the global shares were already excluded during disableValidator call and the rest does not matter anymore
        uint128 validatorSharesRemove = _tokensToShares(amount, v.exchangeRate);
        require(validatorSharesRemove > 0, ""Unstake amount is too small"");
        if (v.disabledEpoch == 0){
            // if validator is enabled and the program has not ended -> check for unstaking beyond max cap or min stake required
            if (isValidator && endEpoch > block.number){
                uint128 newValidatorStaked = s.staked - amount;
                uint128 newValidatorMaxCap = newValidatorStaked * maxCapMultiplier;
                uint128 delegated = v.delegated - s.staked;
                require(delegated <= newValidatorMaxCap, ""Cannot unstake beyond max cap"");
                require(newValidatorStaked >= validatorMinStakedRequired, ""Unstake > min staked required"");
            }

            // update global shares #
            uint128 globalSharesRemove = _tokensToShares(amount, globalExchangeRate);
            require(globalSharesRemove > 0, ""Unstake amount is too small"");
            unchecked { totalGlobalShares -= globalSharesRemove;}
            unchecked { v.globalShares -= globalSharesRemove; }

            // update validator shares #
            unchecked { v.totalShares -= validatorSharesRemove; }
            unchecked { v.delegated -= amount; }
        }
        unchecked { s.shares -= validatorSharesRemove; }
        unchecked { s.staked -= amount; }

        // create unstaking instance
        uint128 coolDownEnd = v.disabledEpoch != 0 ? v.disabledEpoch : uint128(block.number);
        unchecked { coolDownEnd += (isValidator ? validatorCoolDown : delegatorCoolDown); }
        v.unstakings[msg.sender].push(Unstaking( coolDownEnd, amount));
        emit Unstaked(validatorId, msg.sender, amount);
    }

    // restake unstaked tokens
    function recoverUnstaking(uint128 amount, uint128 validatorId, uint128 unstakingId) public{
        Unstaking storage us = validators[validatorId].unstakings[msg.sender][unstakingId];
        require(us.amount >= amount, ""Unstaking has less tokens"");
        _stake(validatorId, amount, false);
        us.amount -= amount;
        // set cool down end to 0 to release gas if new unstaking amount is 0
        if(us.amount == 0)
            us.coolDownEnd = 0;
        emit RecoveredUnstake(validatorId, msg.sender, amount, unstakingId);
    }

    // if amount is 0 then redeem all
    function _redeemRewards( uint128 validatorId, address beneficiary, uint128 amount) internal {
        require(beneficiary!=address(0x0), ""Invalid beneficiary"");
        _updateGlobalExchangeRate();
        Validator storage v = validators[validatorId];
        _updateValidator(v);
        Staking storage s = v.stakings[msg.sender];

        uint128 rewards = _sharesToTokens(s.shares, v.exchangeRate) - s.staked;
        if(msg.sender == v._address){
            if(amount == 0){
                unchecked { amount = rewards + v.commissionAvailableToRedeem; }
            }
            require(rewards + v.commissionAvailableToRedeem >= amount, ""Redeem amount > available"");
            // first redeem rewards from commission
            uint128 commissionLeftOver = amount < v.commissionAvailableToRedeem ? v.commissionAvailableToRedeem - amount : 0;
            // if there is more, redeem  it from regular rewards
            if (commissionLeftOver == 0){
                uint128 validatorSharesRemove = _tokensToShares(amount - v.commissionAvailableToRedeem, v.exchangeRate);
                unchecked { s.shares -= validatorSharesRemove; }
                unchecked { v.totalShares -= validatorSharesRemove; }
            }
            emit CommissionRewardRedeemed(validatorId, beneficiary, v.commissionAvailableToRedeem - commissionLeftOver);
            v.commissionAvailableToRedeem = commissionLeftOver;
        }
        else {
            if(amount == 0){
                amount = rewards;
            }
            require(rewards >= amount, ""Redeem amount > available"");
            uint128 validatorSharesRemove = _tokensToShares(amount, v.exchangeRate);
            unchecked { s.shares -= validatorSharesRemove; }
            unchecked { v.totalShares -= validatorSharesRemove; }
        }
        _transferFromContract(beneficiary, amount);

        // update global shares #
        // this includes commission and rewards earned
        // only update if the validator is enabled, otherwise the shares were already excluded during disableValidator call
        if (v.disabledEpoch == 0){
            uint128 globalSharesRemove = _tokensToShares(amount, globalExchangeRate);
            unchecked { totalGlobalShares -= globalSharesRemove; }
            unchecked { v.globalShares -= globalSharesRemove; }
        }
        emit RewardRedeemed(validatorId, beneficiary, amount);
    }

    // redeem all available rewards
    function redeemAllRewards( uint128 validatorId, address beneficiary) external {
        _redeemRewards(validatorId, beneficiary, 0);
    }

    // if validator calls redeem rewards, first tokens paid from comissions will be redeemed and then regular rewards
    function redeemRewards( uint128 validatorId, address beneficiary, uint128 amount) external {
        require(amount > 0, ""Amount is 0"");
        _redeemRewards(validatorId, beneficiary, amount);
    }

    // add new validator instance
    function addValidator(address validator, address operator, uint128 commissionRate) public onlyOwner {
        require(commissionRate < divider, ""Rate must be less than 100%"");
        uint128 N = validatorsN;
        validators[N]._address = validator;
        validators[N].operator = operator;
        validators[N].commissionRate = commissionRate;
        emit ValidatorAdded(N, validator, operator);
        unchecked { validatorsN += 1; }
    }

    // can only be called by the owner or the validator, disabling will allow validator to fully unstake
    // validator instance can only be disabled once and can never be reenabled
    function disableValidator(uint128 validatorId) public {
        Validator storage v = validators[validatorId];
        require(v.disabledEpoch == 0, ""Validator is already disabled"");
        require(v._address == msg.sender || msg.sender == owner(), ""Caller is not owner or validator"");
        _updateGlobalExchangeRate();
        _updateValidator(v);
        v.disabledEpoch = uint128(block.number) < endEpoch? uint128(block.number) : endEpoch;
        unchecked { totalGlobalShares -= v.globalShares; }
        emit ValidatorDisabled(validatorId);
    }

    // change emission rate, should reset end epoch
    function setAllocatedTokensPerEpoch(uint128 amount) public onlyOwner {
        require(amount > 0, ""Amount is 0"");
        uint128 toTransfer;
        if (endEpoch != 0){
            _updateGlobalExchangeRate();
            // get number of epochs from now to the end epoch
            uint128 epochs = endEpoch > uint128(block.number) ? endEpoch - uint128(block.number) : 0;
            // calculate how much rewards would be distributed with the old emission rate
            uint128 futureRewards = allocatedTokensPerEpoch * epochs;
            // calculate how many epochs will be covered
            uint128 addEpochs = futureRewards / amount;
            toTransfer = futureRewards % amount;
            require(addEpochs != 0, ""This amount will end the program"");
            unchecked { endEpoch = uint128(block.number) + addEpochs; }
        }
        else {
          toTransfer = rewardsLocked % amount;
        }
        allocatedTokensPerEpoch = amount;
        emit EmissionRateChanged(amount);
        if(toTransfer > 0)
            _transferFromContract(msg.sender, toTransfer);

    }

    // we assume that we will never set it to less than what is staked already
    function setMaxCapMultiplier(uint128 amount) public onlyOwner {
        require(amount > 0, ""Must be greater than 0"");
        maxCapMultiplier = amount;
        emit MaxCapMultiplierChanged(amount);
    }

    // only owner can change commission rate
    function setValidatorCommissionRate(uint128 amount, uint128 validatorId) public onlyOwner {
        require(amount < divider, ""Rate must be less than 100%"");
        _updateGlobalExchangeRate();
        _updateValidator(validators[validatorId]);
        validators[validatorId].commissionRate = amount;
        emit ValidatorCommissionRateChanged(validatorId, amount);
    }

    // we are assuming there will never be a case when the owner sets the value to something extremely big and if that happens accidentally, we will just recall the function
    function setValidatorMinStakedRequired(uint128 amount) public onlyOwner {
        validatorMinStakedRequired = amount;
        emit ValidatorMinStakedRequiredChanged(amount);
    }

    // if a validator gets disabled, delegators can redelegate their tokens to another validator
    // first they need to unstake
    function redelegateUnstaked(uint128 amount, uint128 oldValidatorId, uint128 newValidatorId, uint128 unstakingId) public {
        require(validators[oldValidatorId].disabledEpoch != 0, ""Validator is not disabled"");
        require(validators[oldValidatorId]._address != msg.sender, ""Validator cannot redelegate"");
        Unstaking storage us = validators[oldValidatorId].unstakings[msg.sender][unstakingId];
        require(us.amount >= amount, ""Unstaking has less tokens"");
        _stake(newValidatorId, amount, false);
        unchecked { us.amount -= amount; }
        // set cool down end to 0 to release gas if new unstaking amount is 0
        if(us.amount == 0)
            us.coolDownEnd = 0;
        emit TransferredUnstake(oldValidatorId, newValidatorId, msg.sender, amount, unstakingId);
    }

    // transfer out unlocked unstaked tokens back to the delegator
    function transferUnstakedOut(uint128 amount, uint128 validatorId, uint128 unstakingId) public {
        Unstaking storage us = validators[validatorId].unstakings[msg.sender][unstakingId];
        require( uint128(block.number) > us.coolDownEnd, ""Cooldown period has not ended"" );
        require(us.amount >= amount, ""Amount is too high"");
        _transferFromContract(msg.sender, amount);
        unchecked { us.amount -= amount; }
        // set cool down end to 0 to release gas if new unstaking amount is 0
        if (us.amount == 0)
            us.coolDownEnd = 0;
        emit UnstakeRedeemed(validatorId, msg.sender, amount);
    }

    // returns details of each validator
    // array index is id
    function getValidatorsDetails() public view returns (uint128[] memory commissionRates, uint128[] memory delegated) {
        commissionRates = new uint128[](validatorsN);
        delegated = new uint128[](validatorsN);
        for (uint128 i = 0; i < validatorsN; ++i){
            Validator storage v = validators[i];
            commissionRates[i] = v.commissionRate;
            delegated[i] = v.delegated - v.stakings[v._address].staked;
        }
        return (commissionRates, delegated);
    }

    // this follows the same logic as _updateGlobalExchangeRate and _updateValidator
    // array index is id of validator
    function getDelegatorDetails(address delegator) public view returns( uint128[] memory delegated,  uint128[] memory rewardsAvailable, uint128[] memory commissionRewards) {
       delegated = new uint128[](validatorsN);
       rewardsAvailable = new uint128[](validatorsN);
       commissionRewards = new uint128[](validatorsN);
       uint256 currentEpoch = block.number < endEpoch? block.number: endEpoch;
       uint128 newGlobalExchangeRate = uint128((uint256(allocatedTokensPerEpoch) * divider/totalGlobalShares)*(currentEpoch - lastUpdateEpoch)) + globalExchangeRate;
       Validator storage v;
       Staking storage s;
        for (uint128 i = 0; i < validatorsN; ++i){
            v = validators[i];
            s = v.stakings[delegator];
            delegated[i] = s.staked;
            if (v.disabledEpoch == 0){
                uint128 newTokensGiven = _sharesToTokens(v.globalShares, newGlobalExchangeRate - v.lastUpdateGlobalRate);
                uint128 commissionPaid = uint128(uint256(newTokensGiven) * uint256(v.commissionRate) /  divider);
                uint128 rateIncrease = uint128(uint256(newTokensGiven - commissionPaid) * divider / v.totalShares);
                rewardsAvailable[i] = _sharesToTokens(s.shares, v.exchangeRate + rateIncrease) - s.staked;
                if(delegator == v._address)
                    commissionRewards[i] = v.commissionAvailableToRedeem + commissionPaid;
            }
            else {
                rewardsAvailable[i] = _sharesToTokens(s.shares, v.exchangeRate) - s.staked;
                if(delegator == v._address)
                    commissionRewards[i] = v.commissionAvailableToRedeem;
            }
        }
        return (delegated, rewardsAvailable, commissionRewards);
    }

    function getMetadata() public view returns(uint128,  uint128, uint128, uint128, uint128 ){
        uint128 totalStaked = uint128(uint256(totalGlobalShares) * uint256(globalExchangeRate) / divider);
        return (allocatedTokensPerEpoch, endEpoch, maxCapMultiplier, totalStaked, validatorsN);
    }
}",5629
RealWorld_BA_44_MockZrxExchangeProxy_RealWord_20240820171944.log,44,MockZrxExchangeProxy,19215,5542,24757,89.0,0.206915,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

// test input data from the 0x API
// 0xd9627aa4000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000008430000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee869584cd0000000000000000000000001000000000000000000000000000000000000011000000000000000000000000000000000000000000000052beeb861f60df6a37

contract MockZrxExchangeProxy {
    // well behaved function that takes 1000 * 1e18 _1[0] tokens and returns 1000e18
    // _1[1] tokens if possible.
    //
    // function selector: 0xd9627aa4 (real selector in use on mainnet)
    function sellToUniswap(address[] calldata _1, uint256 _2, uint256 _3, bool _4) external payable {
        require(_1.length > 1, ""tokens"");
        IERC20 tokenToSell = IERC20(_1[0]);
        IERC20 tokenToBuy = IERC20(_1[1]);
        tokenToSell.transferFrom(msg.sender, address(this), 1000 ether);
        tokenToBuy.transfer(msg.sender, 1000 ether);
    }

    // well behaved function that takes 1000 * 1e18 _1[0] tokens and returns 1 ETH,
    // if possible.
    //
    // function selector: 0x22170963
    function sellToUniswap1(address[] calldata _1, uint256 _2, uint256 _3, bool _4) external payable {
        require(_1.length > 0, ""tokens"");
        IERC20 tokenToSell = IERC20(_1[0]);
        IERC20 tokenToBuy = IERC20(_1[1]);
        tokenToSell.transferFrom(msg.sender, address(this), 1000 ether);
        payable(address(msg.sender)).transfer(1 ether);
    }

    // well behaved function that takes 1 ETH and returns 1000 * 1e18 _1[1]
    // tokens, if possible.
    //
    // function selector: 0x02af0bb5
    function sellToUniswap2(address[] calldata _1, uint256 _2, uint256 _3, bool _4) external payable {
        require(msg.value == 1 ether, ""mispaid"");
        require(_1.length > 1, ""tokens"");
        IERC20(_1[1]).transfer(msg.sender, 1000 ether);
    }

    // function that reverts
    //
    // function selector: 0x9b1d1f41
    function sellToUniswap3(address[] calldata _1, uint256 _2, uint256 _3, bool _4) external payable {
        revert(""Sorry fren"");
    }

    // malicious function that takes all ETH and returns nothing
    //
    // function selector: 0xb88ce71e
    function sellToUniswap4(address[] calldata _1, uint256 _2, uint256 _3, bool _4) external payable {
        // yep that's it :)
    }

    // malicious function that takes all approved _1[0] tokens and returns a
    // small amount of ETH
    //
    // function selector: 0x1f9b9985
    function sellToUniswap5(address[] calldata _1, uint256 _2, uint256 _3, bool _4) external payable {
        if(_1.length > 0) {
            IERC20 token = IERC20(_1[0]);
            uint256 allowance = token.allowance(msg.sender, address(this));
            IERC20(_1[0]).transferFrom(msg.sender, address(this), allowance);
            payable(address(msg.sender)).transfer(0.1 ether);
            // see you later sucker!
        }
    }

    fallback() external payable {}
    receive() external payable {}
}",1006
RealWorld_BA_44_Swap_RealWord_20240820172115.log,44,Swap,46902,5994,52896,102.0,0.35439,"pragma solidity ^0.8.0;

import ""../governance/EmergencyPausable.sol"";
import ""../utils/Math.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Swap is EmergencyPausable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;
    using Math for uint256;

    /// @notice An address to receive swap fees. The 0 address prevents fee
    ///         withdrawal.
    address payable public feeRecipient;
    /// @notice divide by the SWAP_FEE_DIVISOR to get the fee ratio, deducted
    ///         from the proceeds of each swap.
    uint256 public swapFee;
    uint256 public constant SWAP_FEE_DIVISOR = 100_000;

    event SwappedTokens(
        address tokenSold,
        address tokenBought,
        uint256 amountSold,
        uint256 amountBought,
        uint256 amountBoughtFee
    );

    event NewSwapFee(
        uint256 newSwapFee
    );

    event NewFeeRecipient(
        address newFeeRecipient
    );

    event FeesSwept(
        address token,
        uint256 amount,
        address recipient
    );

    /// @param owner_ A new contract owner, expected to implement
    ///               TimelockGovernorWithEmergencyGovernance.
    /// @param feeRecipient_ A payable address to receive swap fees. Setting the
    ///        0 address prevents fee withdrawal, and can be set later by
    ///        governance.
    /// @param swapFee_ A fee, which divided by SWAP_FEE_DIVISOR sets the fee
    ///                 ratio charged for each swap.
    constructor(address owner_, address payable feeRecipient_, uint256 swapFee_) {
        require(owner_ != address(0), ""Swap::constructor: Owner must not be 0"");
        transferOwnership(owner_);
        feeRecipient = feeRecipient_;
        emit NewFeeRecipient(feeRecipient);
        swapFee = swapFee_;
        emit NewSwapFee(swapFee);
    }

    /// @notice Set the fee taken from each swap's proceeds.
    /// @dev Only timelocked governance can set the swap fee.
    /// @param swapFee_ A fee, which divided by SWAP_FEE_DIVISOR sets the fee ratio.
    function setSwapFee(uint256 swapFee_) external onlyTimelock {
        require(swapFee_ < SWAP_FEE_DIVISOR, ""Swap::setSwapFee: Swap fee must not exceed 100%"");
        swapFee = swapFee_;
        emit NewSwapFee(swapFee);
    }

    /// @notice Set the address permitted to receive swap fees.
    /// @dev Only timelocked governance can set the fee recipient.
    /// @param feeRecipient_ A payable address to receive swap fees. Setting the
    ///        0 address prevents fee withdrawal.
    function setFeeRecipient(address payable feeRecipient_) external onlyTimelock {
        feeRecipient = feeRecipient_;
        emit NewFeeRecipient(feeRecipient);
    }

    /// @notice Swap by filling a 0x quote.
    /// @dev Execute a swap by filling a 0x quote, as provided by the 0x API.
    ///      Charges a governable swap fee that comes out of the bought asset,
    ///      be it token or ETH. Unfortunately, the fee is also charged on any
    ///      refunded ETH from 0x protocol fees due to an implementation oddity.
    ///      This behavior shouldn't impact most users.
    ///
    ///      Learn more about the 0x API and quotes at https://0x.org/docs/api
    /// @param zrxSellTokenAddress The contract address of the token to be sold,
    ///        as returned by the 0x `/swap/v1/quote` API endpoint. If selling
    ///        unwrapped ETH included via msg.value, this should be address(0)
    /// @param amountToSell Amount of token to sell, with the same precision as
    ///        zrxSellTokenAddress. This information is also encoded in zrxData.
    ///        If selling unwrapped ETH via msg.value, this should be 0.
    /// @param zrxBuyTokenAddress The contract address of the token to be bought,
    ///        as returned by the 0x `/swap/v1/quote` API endpoint. To buy
    ///        unwrapped ETH, use `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`
    /// @param minimumAmountReceived The minimum amount expected to be received
    ///        from filling the quote, before the swap fee is deducted, in
    ///        zrxBuyTokenAddress. Reverts if not met
    /// @param zrxAllowanceTarget Contract address that needs to be approved for
    ///        zrxSellTokenAddress, as returned by the 0x `/swap/v1/quote` API
    ///        endpoint. Should be address(0) for purchases uses unwrapped ETH
    /// @param zrxTo Contract to fill the 0x quote, as returned by the 0x
    ///        `/swap/v1/quote` API endpoint
    /// @param zrxData Data encoding the 0x quote, as returned by the 0x
    ///        `/swap/v1/quote` API endpoint
    /// @param deadline Timestamp after which the swap will be reverted.
    function swapByQuote(
        address zrxSellTokenAddress,
        uint256 amountToSell,
        address zrxBuyTokenAddress,
        uint256 minimumAmountReceived,
        address zrxAllowanceTarget,
        address payable zrxTo,
        bytes calldata zrxData,
        uint256 deadline
    ) external payable whenNotPaused nonReentrant {
        require(
            block.timestamp <= deadline,
            ""Swap::swapByQuote: Deadline exceeded""
        );
        require(
            !signifiesETHOrZero(zrxSellTokenAddress) || msg.value > 0,
            ""Swap::swapByQuote: Unwrapped ETH must be swapped via msg.value""
        );

        // if zrxAllowanceTarget is 0, this is an ETH sale
        if (zrxAllowanceTarget != address(0)) {
            // transfer tokens to this contract
            IERC20(zrxSellTokenAddress).safeTransferFrom(msg.sender, address(this), amountToSell);
            // approve token transfer to 0x contracts
            // TODO (handle approval special cases like USDT, KNC, etc)
            IERC20(zrxSellTokenAddress).safeIncreaseAllowance(zrxAllowanceTarget, amountToSell);
        }

        // execute 0x quote
        (uint256 boughtERC20Amount, uint256 boughtETHAmount) = fillZrxQuote(
            IERC20(zrxBuyTokenAddress),
            zrxTo,
            zrxData,
            msg.value
        );

        require(
            (
                !signifiesETHOrZero(zrxBuyTokenAddress) &&
                boughtERC20Amount >= minimumAmountReceived
            ) ||
            (
                signifiesETHOrZero(zrxBuyTokenAddress) &&
                boughtETHAmount >= minimumAmountReceived
            ),
            ""Swap::swapByQuote: Minimum swap proceeds requirement not met""
        );
        if (boughtERC20Amount > 0) {
            // take the swap fee from the ERC20 proceeds and return the rest
            uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtERC20Amount).div(SWAP_FEE_DIVISOR);
            IERC20(zrxBuyTokenAddress).safeTransfer(msg.sender, toTransfer);
            // return any refunded ETH
            payable(msg.sender).transfer(boughtETHAmount);

            emit SwappedTokens(
                zrxSellTokenAddress,
                zrxBuyTokenAddress,
                amountToSell,
                boughtERC20Amount,
                boughtERC20Amount.sub(toTransfer)
            );
        } else {

            // take the swap fee from the ETH proceeds and return the rest. Note
            // that if any 0x protocol fee is refunded in ETH, it also suffers
            // the swap fee tax
            uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtETHAmount).div(SWAP_FEE_DIVISOR);
            payable(msg.sender).transfer(toTransfer);
            emit SwappedTokens(
                zrxSellTokenAddress,
                zrxBuyTokenAddress,
                amountToSell,
                boughtETHAmount,
                boughtETHAmount.sub(toTransfer)
            );
        }
        if (zrxAllowanceTarget != address(0)) {
            // remove any dangling token allowance
            IERC20(zrxSellTokenAddress).safeApprove(zrxAllowanceTarget, 0);
        }
    }

    /// @notice Fill a 0x quote as provided by the API, and return any ETH or
    ///         ERC20 proceeds.
    /// @dev Learn more at https://0x.org/docs/api
    /// @param zrxBuyTokenAddress The contract address of the token to be bought,
    ///        as provided by the 0x API. `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`
    ///        signifies the user is buying unwrapped ETH.
    /// @param zrxTo Contract to fill the 0x quote, as provided by the 0x API
    /// @param zrxData Data encoding the 0x quote, as provided by the 0x API
    /// @param ethAmount The amount of ETH required to fill the quote, including
    ///        any ETH being traded as well as protocol fees
    /// @return any positive `zrxBuyTokenAddress` ERC20 balance change, as well
    ///         as any positive ETH balance change
    function fillZrxQuote(
        IERC20 zrxBuyTokenAddress,
        address payable zrxTo,
        bytes calldata zrxData,
        uint256 ethAmount
    ) internal returns (uint256, uint256) {
        uint256 originalERC20Balance = 0;
        if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {
            originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));
        }
        uint256 originalETHBalance = address(this).balance;

        (bool success,) = zrxTo.call{value: ethAmount}(zrxData);
        require(success, ""Swap::fillZrxQuote: Failed to fill quote"");

        uint256 ethDelta = address(this).balance.subOrZero(originalETHBalance);
        uint256 erc20Delta;
        if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {
            erc20Delta = zrxBuyTokenAddress.balanceOf(address(this)).subOrZero(originalERC20Balance);
            require(erc20Delta > 0, ""Swap::fillZrxQuote: Didn't receive bought token"");
        } else {
            require(ethDelta > 0, ""Swap::fillZrxQuote: Didn't receive bought ETH"");
        }

        return (erc20Delta, ethDelta);
    }

    /// @notice Test whether an address is zero, or the magic address the 0x
    ///         platform uses to signify ""unwrapped ETH"" rather than an ERC20.
    /// @param tokenAddress An address that might point toward an ERC-20.
    function signifiesETHOrZero(address tokenAddress) internal pure returns (bool) {
        return (
            tokenAddress == address(0) ||
            tokenAddress == address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee)
        );
    }

    /// @notice Sweeps accrued ETH and ERC20 swap fees to the pre-established
    ///         fee recipient address.
    /// @dev Fees are tracked based on the contract's balances, rather than
    ///      using any additional bookkeeping. If there are bugs in swap
    ///      accounting, this function could jeopardize funds.
    /// @param tokens An array of ERC20 contracts to withdraw token fees
    function sweepFees(
        address[] calldata tokens
    ) external nonReentrant {
        require(
            feeRecipient != address(0),
            ""Swap::withdrawAccruedFees: feeRecipient is not initialized""
        );
        for (uint8 i = 0; i<tokens.length; i++) {
            uint256 balance = IERC20(tokens[i]).balanceOf(address(this));
            if (balance > 0) {
                IERC20(tokens[i]).safeTransfer(feeRecipient, balance);
                emit FeesSwept(tokens[i], balance, feeRecipient);
            }
        }
        feeRecipient.transfer(address(this).balance);
        emit FeesSwept(address(0), address(this).balance, feeRecipient);
    }

    fallback() external payable {}
    receive() external payable {}
}",2733
RealWorld_BA_44_EmergencyGovernable_RealWord_20240820172412.log,44,EmergencyGovernable,12372,5495,17867,83.0,0.17176,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

/// @dev Base for contracts with actions that should be emergency-governable.
///      Implies Ownable, and assumes the owner is a
///      TimelockGovernorWithEmergencyGovernance. Provides the
///      onlyTimelockOrEmergencyGovernance modifier, which allows the system
///      governor's timelock OR the system governor's emergency governance
///      address to make a change.
contract EmergencyGovernable is Ownable {
    /// @dev Casts the owner to the expected
    ///      TimelockGovernorWithEmergencyGovernance interface.
    function governor()
        internal
        view
        returns (TimelockGovernorWithEmergencyGovernance)
    {
        return TimelockGovernorWithEmergencyGovernance(owner());
    }

    /// @dev Assumes this contract's owner is a governor implementing
    ///      TimelockGovernorWithEmergencyGovernance, and only allows
    ///      the modified function to be invoked from that governor's
    ///      timelock.
    ///
    ///      Note that applying this modifier means that transferring ownership
    ///      to a contract or EOA that does _not_ implement the
    ///      TimelockGovernorWithEmergencyGovernance interface will prevent
    ///      the modified function from being called. The governor is _not_
    ///      permitted to call the modified function directly.
    modifier onlyTimelock {
        require(
            msg.sender == governor().timelock(),
            ""Only governor may call this function.""
        );
        _;
    }

    /// @dev Assumes this contract's owner is a governor implementing
    ///      TimelockGovernorWithEmergencyGovernance, and only allows
    ///      the modified function to be invoked from either that governor's
    ///      timelock or its emergency governance address.
    ///
    ///      Note that applying this modifier means that transferring ownership
    ///      to a contract or EOA that does _not_ implement the
    ///      TimelockGovernorWithEmergencyGovernance interface will prevent
    ///      the modified function from being called. The governor is _not_
    ///      permitted to call the modified function directly.
    modifier onlyTimelockOrEmergencyGovernance {
        require(
            msg.sender == governor().emergencyGovernance() ||
                msg.sender == governor().timelock(),
            ""Only emergency governor or governor may call this function.""
        );
        _;
    }
}

interface TimelockGovernorWithEmergencyGovernance {
    function timelock() external returns (address);

    function emergencyGovernance() external returns (address);
}",566
RealWorld_BA_44_MockToken_RealWord_20240820171837.log,44,MockToken,3884,3836,7720,65.0,0.09614,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MockToken is ERC20 {
    constructor(uint256 supply) ERC20(""MockToken"", ""MTO"") {
        _mint(msg.sender, supply);
    }
}",60
RealWorld_BA_44_Math_RealWord_20240820172259.log,44,Math,5737,4470,10207,71.0,0.118085,"pragma solidity ^0.8.0;

library Math {

    function subOrZero(uint256 a, uint256 b) internal pure returns (uint256) {
        return a > b ? a - b : 0;
    }

    function subOrZero(uint128 a, uint128 b) internal pure returns (uint128) {
        return a > b ? a - b : 0;
    }

    function subOrZero(uint64 a, uint64 b) internal pure returns (uint64) {
        return a > b ? a - b : 0;
    }

    function subOrZero(uint32 a, uint32 b) internal pure returns (uint32) {
        return a > b ? a - b : 0;
    }
}",157
RealWorld_BA_44_EmergencyPausable_RealWord_20240820172537.log,44,EmergencyPausable,7533,5633,13166,116.0,0.150325,"pragma solidity ^0.8.0;

import ""./EmergencyGovernable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/// @dev Base for contracts with actions that should be emergency-pausable.
///      Implies Ownable, and assumes the owner is a
///      TimelockGovernorWithEmergencyGovernance. Includes `whenPaused` and
///      `whenNotPaused` modifiers which restrict a modified function
///      based on the whether `pause` has been called. The `pause` function
///      is restricted to timelocked or emergency governance.
contract EmergencyPausable is EmergencyGovernable, Pausable {
    /// @notice Pause all functions with the `whenNotPaused` modifier. Modified
    ///         functions will revert if called.
    /// @dev Only timelocked or emergency governance may call this function.
    function pause() external onlyTimelockOrEmergencyGovernance {
        super._pause();
    }

    /// @notice Unpause all functions with the `whenNotPaused` modifier. Modified
    ///         functions will no longer revert.
    /// @dev Only timelocked or emergency governance may call this function.
    function unpause() external onlyTimelockOrEmergencyGovernance {
        super._unpause();
    }
}",269
RealWorld_BA_45_ComptrollerMock_RealWord_20240820175454.log,45,ComptrollerMock,7450,5367,12817,96.0,0.14459,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";

contract ComptrollerMock {
    address public unionToken;
    uint256 public rewardAmount;

    function __ComptrollerMock_init() public {}

    function getRewardsMultiplier(address account, address token) public view returns (uint256) {}

    function setRewardsInfo(address _unionToken, uint256 _rewardAmount) external {
        unionToken = _unionToken;
        rewardAmount = _rewardAmount;
    }

    function withdrawRewards(address sender, address) external returns (uint256) {
        IERC20Upgradeable(unionToken).transfer(sender, rewardAmount);
        return rewardAmount;
    }

    function calculateRewardsByBlocks(
        address account,
        address token,
        uint256 futureBlocks
    ) public view returns (uint256) {}

    function calculateRewards(address account, address token) public view returns (uint256) {
        return calculateRewardsByBlocks(account, token, 0);
    }

    function inflationPerBlock(uint256) public view returns (uint256) {}

    function updateTotalStaked(address, uint256) external pure returns (bool) {
        return true;
    }
}",276
RealWorld_BA_45_IUserManager_RealWord_20240820182952.log,45,IUserManager,22182,5844,28026,87.0,0.22779,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

/**
 * @title UserManager Interface
 * @dev Manages the Union members credit lines, and their vouchees and borrowers info.
 */
interface IUserManager {
    /**
     *  @dev Check if the account is a valid member
     *  @param account Member address
     *  @return Address whether is member
     */
    function checkIsMember(address account) external view returns (bool);

    /**
     *  @dev Get member borrowerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getBorrowerAddresses(address account) external view returns (address[] memory);

    /**
     *  @dev Get member stakerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getStakerAddresses(address account) external view returns (address[] memory);

    /**
     *  @dev Get member backer asset
     *  @param account Member address
     *  @param borrower Borrower address
     *  @return Trust amount, vouch amount, and locked stake amount
     */
    function getBorrowerAsset(address account, address borrower)
        external
        view
        returns (
            uint256,
            uint256,
            uint256
        );

    /**
     *  @dev Get member stakers asset
     *  @param account Member address
     *  @param staker Staker address
     *  @return Vouch amount and lockedStake
     */
    function getStakerAsset(address account, address staker)
        external
        view
        returns (
            uint256,
            uint256,
            uint256
        );

    /**
     *  @dev Get the member's available credit line
     *  @param account Member address
     *  @return Limit
     */
    function getCreditLimit(address account) external view returns (int256);

    function totalStaked() external view returns (uint256);

    function totalFrozen() external view returns (uint256);

    function getFrozenCoinAge(address staker, uint256 pastBlocks) external view returns (uint256);

    /**
     *  @dev Add a new member
     *  Accept claims only from the admin
     *  @param account Member address
     */
    function addMember(address account) external;

    /**
     *  @dev Update the trust amount for exisitng members.
     *  @param borrower Borrower address
     *  @param trustAmount Trust amount
     */
    function updateTrust(address borrower, uint256 trustAmount) external;

    /**
     *  @dev Apply for membership, and burn UnionToken as application fees
     *  @param newMember New member address
     */
    function registerMember(address newMember) external;

    /**
     *  @dev Stop vouch for other member.
     *  @param staker Staker address
     *  @param account Account address
     */
    function cancelVouch(address staker, address account) external;

    /**
     *  @dev Change the credit limit model
     *  Accept claims only from the admin
     *  @param newCreditLimitModel New credit limit model address
     */
    function setCreditLimitModel(address newCreditLimitModel) external;

    /**
     *  @dev Get the user's locked stake from all his backed loans
     *  @param staker Staker address
     *  @return LockedStake
     */
    function getTotalLockedStake(address staker) external view returns (uint256);

    /**
     *  @dev Get staker's defaulted / frozen staked token amount
     *  @param staker Staker address
     *  @return Frozen token amount
     */
    function getTotalFrozenAmount(address staker) external view returns (uint256);

    /**
     *  @dev Update userManager locked info
     *  @param borrower Borrower address
     *  @param amount Borrow or repay amount(Including previously accrued interest)
     *  @param isBorrow True is borrow, false is repay
     */
    function updateLockedData(
        address borrower,
        uint256 amount,
        bool isBorrow
    ) external;

    /**
     *  @dev Get the user's deposited stake amount
     *  @param account Member address
     *  @return Deposited stake amount
     */
    function getStakerBalance(address account) external view returns (uint256);

    /**
     *  @dev Stake
     *  @param amount Amount
     */
    function stake(uint256 amount) external;

    /**
     *  @dev Unstake
     *  @param amount Amount
     */
    function unstake(uint256 amount) external;

    /**
     *  @dev Update total frozen
     *  @param account borrower address
     *  @param isOverdue account is overdue
     */
    function updateTotalFrozen(address account, bool isOverdue) external;

    function batchUpdateTotalFrozen(address[] calldata account, bool[] calldata isOverdue) external;

    /**
     *  @dev Repay user's loan overdue, called only from the lending market
     *  @param account User address
     *  @param lastRepay Last repay block number
     */
    function repayLoanOverdue(
        address account,
        address token,
        uint256 lastRepay
    ) external;
}",1158
RealWorld_BA_45_CreditLimitByMedian_RealWord_20240820181150.log,45,CreditLimitByMedian,17676,5951,23627,91.0,0.2074,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/utils/math/Math.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

import ""../interfaces/ICreditLimitModel.sol"";

contract CreditLimitByMedian is Ownable, ICreditLimitModel {
    using Math for uint256;

    bool public constant override isCreditLimitModel = true;
    uint256 public override effectiveNumber;

    constructor(uint256 effectiveNumber_) {
        effectiveNumber = effectiveNumber_;
    }

    function getCreditLimit(uint256[] memory vouchs) public view override returns (uint256) {
        if (vouchs.length >= effectiveNumber) {
            return _findMedian(vouchs);
        } else {
            return 0;
        }
    }

    function getLockedAmount(
        LockedInfo[] memory array,
        address account,
        uint256 amount,
        bool isIncrease
    ) public pure override returns (uint256) {
        if (array.length == 0) return 0;

        uint256 newLockedAmount;
        if (isIncrease) {
            for (uint256 i = 0; i < array.length; i++) {
                uint256 remainingVouchingAmount;
                if (array[i].vouchingAmount > array[i].lockedAmount) {
                    remainingVouchingAmount = array[i].vouchingAmount - array[i].lockedAmount;
                } else {
                    remainingVouchingAmount = 0;
                }

                if (remainingVouchingAmount > array[i].availableStakingAmount) {
                    if (array[i].availableStakingAmount > amount) {
                        newLockedAmount = array[i].lockedAmount + amount;
                    } else {
                        newLockedAmount = array[i].lockedAmount + array[i].availableStakingAmount;
                    }
                } else {
                    if (remainingVouchingAmount > amount) {
                        newLockedAmount = array[i].lockedAmount + amount;
                    } else {
                        newLockedAmount = array[i].lockedAmount + remainingVouchingAmount;
                    }
                }

                if (account == array[i].staker) {
                    return newLockedAmount;
                }
            }
        } else {
            for (uint256 i = 0; i < array.length; i++) {
                if (array[i].lockedAmount > amount) {
                    newLockedAmount = array[i].lockedAmount - 1;
                } else {
                    newLockedAmount = 0;
                }

                if (account == array[i].staker) {
                    return newLockedAmount;
                }
            }
        }

        return 0;
    }

    function setEffectNumber(uint256 number) external onlyOwner {
        effectiveNumber = number;
    }

    /**
     *  @dev Find median from uint array
     *  @param array array
     *  @return uint256
     */
    function _findMedian(uint256[] memory array) private pure returns (uint256) {
        uint256[] memory arr = _sortArray(array);
        if (arr.length == 0) return 0;

        if (arr.length % 2 == 0) {
            uint256 num1 = arr[arr.length >> 1];
            uint256 num2 = arr[(arr.length >> 1) - 1];
            return num1.average(num2);
        } else {
            return arr[arr.length >> 1];
        }
    }

    /**
     *  @dev Sort uint array
     *  @param arr array
     *  @return uint256 array
     */
    function _sortArray(uint256[] memory arr) private pure returns (uint256[] memory) {
        uint256 length = arr.length;

        for (uint256 i = 0; i < length; i++) {
            for (uint256 j = i + 1; j < length; j++) {
                if (arr[i] < arr[j]) {
                    uint256 temp = arr[j];
                    arr[j] = arr[i];
                    arr[i] = temp;
                }
            }
        }

        return arr;
    }
}",861
RealWorld_BA_45_UUPSProxy_RealWord_20240820173604.log,45,UUPSProxy,5347,4649,9996,78.0,0.119715,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol"";

// Kept for backwards compatibility with older versions of Hardhat and Truffle plugins.
contract UUPSProxy is ERC1967Proxy {
    constructor(
        address _logic,
        address, // This is completely unused by the uups proxy, required to remain compatible with hardhat deploy: https://github.com/wighawag/hardhat-deploy/issues/146
        bytes memory _data
    ) payable ERC1967Proxy(_logic, _data) {}
}",135
RealWorld_BA_45_FixedInterestRateModelMock_RealWord_20240820175021.log,45,FixedInterestRateModelMock,6050,4500,10550,89.0,0.12025,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

contract FixedInterestRateModelMock {
    bool public constant isInterestRateModel = true;
    uint256 public interestRatePerBlock;

    constructor(uint256 interestRatePerBlock_) {
        interestRatePerBlock = interestRatePerBlock_;
    }

    function getBorrowRate() public view returns (uint256) {
        return interestRatePerBlock;
    }

    function getSupplyRate(uint256 reserveFactorMantissa) public view returns (uint256) {
        uint256 ratio = uint256(1e18) - reserveFactorMantissa;
        return (interestRatePerBlock * ratio) / 1e18;
    }

    function setInterestRate(uint256 interestRatePerBlock_) external {
        interestRatePerBlock = interestRatePerBlock_;
    }
}",179
RealWorld_BA_45_UToken_RealWord_20240820182048.log,45,UToken,110512,6041,116553,113.0,0.67338,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;
pragma abicoder v1;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../Controller.sol"";
import ""../interfaces/IUserManager.sol"";
import ""../interfaces/IAssetManager.sol"";
import ""../interfaces/IUErc20.sol"";
import ""../interfaces/IInterestRateModel.sol"";

/**
 *  @title UToken Contract
 *  @dev Union accountBorrows can borrow and repay thru this component.
 */
contract UToken is Controller, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IUErc20;

    bool public constant IS_UTOKEN = true;
    uint256 public constant WAD = 1e18;
    uint256 internal constant BORROW_RATE_MAX_MANTISSA = 0.0005e16; //Maximum borrow rate that can ever be applied (.0005% / block)
    uint256 internal constant RESERVE_FACTORY_MAX_MANTISSA = 1e18; //Maximum fraction of interest that can be set aside for reserves

    address public underlying;
    IInterestRateModel public interestRateModel;
    uint256 internal initialExchangeRateMantissa; //Initial exchange rate used when minting the first UTokens (used when totalSupply = 0)
    uint256 public reserveFactorMantissa; //Fraction of interest currently set aside for reserves
    uint256 public accrualBlockNumber; //Block number that interest was last accrued at
    uint256 public borrowIndex; //Accumulator of the total earned interest rate since the opening of the market
    uint256 public totalBorrows; //Total amount of outstanding borrows of the underlying in this market
    uint256 public totalReserves; //Total amount of reserves of the underlying held in this marke
    uint256 public totalRedeemable; //Calculates the exchange rate from the underlying to the uToken
    uint256 public overdueBlocks; //overdue duration, based on the number of blocks
    uint256 public originationFee;
    uint256 public debtCeiling; //The debt limit for the whole system
    uint256 public maxBorrow;
    uint256 public minBorrow;
    address public assetManager;
    address public userManager;
    IUErc20 public uErc20;

    struct BorrowSnapshot {
        uint256 principal;
        uint256 interest;
        uint256 interestIndex;
        uint256 lastRepay; //Calculate if it is overdue
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) internal accountBorrows;

    /**
     *  @dev Change of the interest rate model
     *  @param oldInterestRateModel Old interest rate model address
     *  @param newInterestRateModel New interest rate model address
     */
    event LogNewMarketInterestRateModel(address oldInterestRateModel, address newInterestRateModel);

    event LogMint(address minter, uint256 underlyingAmount, uint256 uTokenAmount);

    event LogRedeem(address redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn, uint256 redeemAmount);

    event LogReservesAdded(address reserver, uint256 actualAddAmount, uint256 totalReservesNew);

    event LogReservesReduced(address receiver, uint256 reduceAmount, uint256 totalReservesNew);

    /**
     *  @dev Event borrow
     *  @param account Member address
     *  @param amount Borrow amount
     *  @param fee Origination fee
     */
    event LogBorrow(address indexed account, uint256 amount, uint256 fee);

    /**
     *  @dev Event repay
     *  @param account Member address
     *  @param amount Repay amount
     */
    event LogRepay(address indexed account, uint256 amount);

    /**
     *  @dev modifier limit member
     */
    modifier onlyMember(address account) {
        require(IUserManager(userManager).checkIsMember(account), ""UToken: caller is not a member"");
        _;
    }

    modifier onlyAssetManager() {
        require(msg.sender == assetManager, ""UToken: caller is not assetManager"");
        _;
    }

    modifier onlyUserManager() {
        require(msg.sender == userManager, ""UToken: caller is not userManager"");
        _;
    }

    function __UToken_init(
        IUErc20 uErc20_,
        address underlying_,
        uint256 initialExchangeRateMantissa_,
        uint256 reserveFactorMantissa_,
        uint256 originationFee_,
        uint256 debtCeiling_,
        uint256 maxBorrow_,
        uint256 minBorrow_,
        uint256 overdueBlocks_,
        address admin_
    ) public initializer {
        require(initialExchangeRateMantissa_ > 0, ""initial exchange rate must be greater than zero."");
        require(address(underlying_) != address(0), ""underlying token is zero"");
        require(
            reserveFactorMantissa_ >= 0 && reserveFactorMantissa_ <= RESERVE_FACTORY_MAX_MANTISSA,
            ""reserveFactorMantissa error""
        );
        uErc20 = uErc20_;
        Controller.__Controller_init(admin_);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        underlying = underlying_;
        originationFee = originationFee_;
        debtCeiling = debtCeiling_;
        maxBorrow = maxBorrow_;
        minBorrow = minBorrow_;
        overdueBlocks = overdueBlocks_;
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        reserveFactorMantissa = reserveFactorMantissa_;
        accrualBlockNumber = getBlockNumber();
        borrowIndex = WAD;
    }

    function setAssetManager(address assetManager_) external onlyAdmin {
        assetManager = assetManager_;
    }

    function setUserManager(address userManager_) external onlyAdmin {
        userManager = userManager_;
    }

    /**
     *  @dev Change loan origination fee value
     *  Accept claims only from the admin
     *  @param originationFee_ Fees deducted for each loan transaction
     */
    function setOriginationFee(uint256 originationFee_) external onlyAdmin {
        originationFee = originationFee_;
    }

    /**
     *  @dev Update the market debt ceiling to a fixed amount, for example, 1 billion DAI etc.
     *  Accept claims only from the admin
     *  @param debtCeiling_ The debt limit for the whole system
     */
    function setDebtCeiling(uint256 debtCeiling_) external onlyAdmin {
        debtCeiling = debtCeiling_;
    }

    /**
     *  @dev Update the minimum loan size
     *  Accept claims only from the admin
     *  @param minBorrow_ Minimum loan amount per user
     */
    function setMinBorrow(uint256 minBorrow_) external onlyAdmin {
        minBorrow = minBorrow_;
    }

    /**
     *  @dev Update the max loan size
     *  Accept claims only from the admin
     *  @param maxBorrow_ Max loan amount per user
     */
    function setMaxBorrow(uint256 maxBorrow_) external onlyAdmin {
        maxBorrow = maxBorrow_;
    }

    /**
     *  @dev Change loan overdue duration, based on the number of blocks
     *  Accept claims only from the admin
     *  @param overdueBlocks_ Maximum late repayment block. The number of arrivals is a default
     */
    function setOverdueBlocks(uint256 overdueBlocks_) external onlyAdmin {
        overdueBlocks = overdueBlocks_;
    }

    /**
     *  @dev Change to a different interest rate model
     *  Accept claims only from the admin
     *  @param newInterestRateModel New interest rate model address
     */
    function setInterestRateModel(address newInterestRateModel) external onlyAdmin {
        _setInterestRateModelFresh(newInterestRateModel);
    }

    function setReserveFactor(uint256 reserveFactorMantissa_) external onlyAdmin {
        require(
            reserveFactorMantissa_ >= 0 && reserveFactorMantissa_ <= RESERVE_FACTORY_MAX_MANTISSA,
            ""reserveFactorMantissa error""
        );
        reserveFactorMantissa = reserveFactorMantissa_;
    }

    /**
     *  @dev Returns the remaining amount that can be borrowed from the market.
     *  @return Remaining total amount
     */
    function getRemainingLoanSize() public view returns (uint256) {
        if (debtCeiling >= totalBorrows) {
            return debtCeiling - totalBorrows;
        } else {
            return 0;
        }
    }

    /**
     *  @dev Get the last repay block
     *  @param account Member address
     *  @return lastRepay
     */
    function getLastRepay(address account) public view returns (uint256 lastRepay) {
        lastRepay = accountBorrows[account].lastRepay;
    }

    /**
     *  @dev Get member interest index
     *  @param account Member address
     *  @return interestIndex
     */
    function getInterestIndex(address account) public view returns (uint256 interestIndex) {
        interestIndex = accountBorrows[account].interestIndex;
    }

    /**
     *  @dev Check if the member's loan is overdue
     *  @param account Member address
     *  @return isOverdue
     */
    function checkIsOverdue(address account) public view returns (bool isOverdue) {
        if (getBorrowed(account) == 0) {
            isOverdue = false;
        } else {
            uint256 lastRepay = getLastRepay(account);
            uint256 diff = getBlockNumber() - lastRepay;
            isOverdue = (overdueBlocks < diff);
        }
    }

    /**
     *  @dev Get the origination fee
     *  @param amount Amount to be calculated
     *  @return Handling fee
     */
    function calculatingFee(uint256 amount) public view returns (uint256) {
        return (originationFee * amount) / WAD;
    }

    /**
     *  @dev Get member loan data
     *  @param member Member address
     *  @return principal totalBorrowed asset apr limit isOverdue lastRepay
     */
    function getLoan(address member)
        public
        view
        returns (
            uint256 principal,
            uint256 totalBorrowed,
            address asset,
            uint256 apr,
            int256 limit,
            bool isOverdue,
            uint256 lastRepay
        )
    {
        principal = accountBorrows[msg.sender].principal;
        totalBorrowed = borrowBalanceStoredInternal(member);
        asset = underlying;
        apr = borrowRatePerBlock();
        lastRepay = getLastRepay(member);
        limit = _getCreditLimit(member);
        isOverdue = checkIsOverdue(member);
    }

    /**
     *  @dev Get the borrowed principle
     *  @param account Member address
     *  @return borrowed
     */
    function getBorrowed(address account) public view returns (uint256 borrowed) {
        borrowed = accountBorrows[account].principal;
    }

    /**
     *  @dev Get a member's current owed balance, including the principle and interest but without updating the user's states.
     *  @param account Member address
     *  @return Borrowed amount
     */
    function borrowBalanceView(address account) public view returns (uint256) {
        return accountBorrows[account].principal + calculatingInterest(account);
    }

    /**
     *  @dev Get a member's total owed, including the principle and the interest calculated based on the interest index.
     *  @param account Member address
     *  @return Borrowed amount
     */
    function borrowBalanceStoredInternal(address account) internal view returns (uint256) {
        BorrowSnapshot memory loan = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (loan.principal == 0) {
            return 0;
        }

        uint256 principalTimesIndex = (loan.principal + loan.interest) * borrowIndex;
        return principalTimesIndex / loan.interestIndex;
    }

    /**
     *  @dev Get the borrowing interest rate per block
     *  @return Borrow rate
     */
    function borrowRatePerBlock() public view returns (uint256) {
        uint256 borrowRateMantissa = interestRateModel.getBorrowRate();
        require(borrowRateMantissa <= BORROW_RATE_MAX_MANTISSA, ""borrow rate is absurdly high"");
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this UToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() public view returns (uint256) {
        return interestRateModel.getSupplyRate(reserveFactorMantissa);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint256) {
        require(accrueInterest(), ""UToken: accrue interest failed"");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the UToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint256) {
        uint256 totalSupply_ = uErc20.totalSupply();
        if (totalSupply_ == 0) {
            return initialExchangeRateMantissa;
        } else {
            return (totalRedeemable * WAD) / totalSupply_;
        }
    }

    /**
     *  @dev Calculating member's borrowed interest
     *  @param account Member address
     *  @return Interest amount
     */
    function calculatingInterest(address account) public view returns (uint256) {
        BorrowSnapshot memory loan = accountBorrows[account];

        if (loan.principal == 0) {
            return 0;
        }

        uint256 borrowRate = borrowRatePerBlock();
        uint256 currentBlockNumber = getBlockNumber();
        uint256 blockDelta = currentBlockNumber - accrualBlockNumber;
        uint256 simpleInterestFactor = borrowRate * blockDelta;
        uint256 borrowIndexNew = (simpleInterestFactor * borrowIndex) / WAD + borrowIndex;

        uint256 principalTimesIndex = (loan.principal + loan.interest) * borrowIndexNew;
        uint256 balance = principalTimesIndex / loan.interestIndex;

        return balance - accountBorrows[account].principal;
    }

    /**
     *  @dev Borrowing from the market
     *  Accept claims only from the member
     *  Borrow amount must in the range of creditLimit, minBorrow, maxBorrow, debtCeiling and not overdue
     *  @param amount Borrow amount
     */
    function borrow(uint256 amount) external onlyMember(msg.sender) whenNotPaused nonReentrant {
        IAssetManager assetManagerContract = IAssetManager(assetManager);
        require(amount >= minBorrow, ""UToken: amount less than loan size min"");

        require(amount <= getRemainingLoanSize(), ""UToken: amount more than loan global size max"");

        uint256 fee = calculatingFee(amount);
        require(borrowBalanceView(msg.sender) + amount + fee <= maxBorrow, ""UToken: amount large than borrow size max"");

        require(!checkIsOverdue(msg.sender), ""UToken: Member has loans overdue"");

        require(amount <= assetManagerContract.getLoanableAmount(underlying), ""UToken: Not enough to lend out"");
        require(
            uint256(_getCreditLimit(msg.sender)) >= amount + fee,
            ""UToken: The loan amount plus fee is greater than credit limit""
        );

        require(accrueInterest(), ""UToken: accrue interest failed"");

        uint256 borrowedAmount = borrowBalanceStoredInternal(msg.sender);

        //Set lastRepay init data
        if (accountBorrows[msg.sender].lastRepay == 0) {
            accountBorrows[msg.sender].lastRepay = getBlockNumber();
        }

        uint256 accountBorrowsNew = borrowedAmount + amount + fee;
        uint256 totalBorrowsNew = totalBorrows + amount + fee;
        uint256 oldPrincipal = accountBorrows[msg.sender].principal;

        accountBorrows[msg.sender].principal += amount + fee;
        uint256 newPrincipal = accountBorrows[msg.sender].principal;
        IUserManager(userManager).updateLockedData(msg.sender, newPrincipal - oldPrincipal, true);
        accountBorrows[msg.sender].interest = accountBorrowsNew - accountBorrows[msg.sender].principal;
        accountBorrows[msg.sender].interestIndex = borrowIndex;
        totalBorrows = totalBorrowsNew;
        // The origination fees contribute to the reserve
        totalReserves += fee;

        require(assetManagerContract.withdraw(underlying, msg.sender, amount), ""UToken: Failed to withdraw"");

        emit LogBorrow(msg.sender, amount, fee);
    }

    function repayBorrow(uint256 repayAmount) external whenNotPaused nonReentrant {
        _repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    function repayBorrowBehalf(address borrower, uint256 repayAmount) external whenNotPaused nonReentrant {
        _repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    /**
     *  @dev Repay the loan
     *  Accept claims only from the member
     *  Updated member lastPaymentEpoch only when the repayment amount is greater than interest
     *  @param payer Payer address
     *  @param borrower Borrower address
     *  @param amount Repay amount
     */
    function _repayBorrowFresh(
        address payer,
        address borrower,
        uint256 amount
    ) private {
        IUErc20 assetToken = IUErc20(underlying);
        //In order to prevent the state from being changed, put the value at the top
        bool isOverdue = checkIsOverdue(borrower);
        uint256 oldPrincipal = accountBorrows[borrower].principal;
        require(accrueInterest(), ""UToken: accrue interest failed"");
        require(accrualBlockNumber == getBlockNumber(), ""UToken: market not fresh"");

        uint256 interest = calculatingInterest(borrower);
        uint256 borrowedAmount = borrowBalanceStoredInternal(borrower);

        uint256 repayAmount;
        if (amount > borrowedAmount) {
            repayAmount = borrowedAmount;
        } else {
            repayAmount = amount;
        }

        require(repayAmount > 0, ""UToken: repay amount or owed amount is zero"");

        require(assetToken.allowance(payer, address(this)) >= repayAmount, ""UToken: Not enough allowance to repay"");

        uint256 toReserveAmount;
        uint256 toRedeemableAmount;
        if (repayAmount >= interest) {
            toReserveAmount = (interest * reserveFactorMantissa) / WAD;
            toRedeemableAmount = interest - toReserveAmount;

            if (isOverdue) {
                IUserManager(userManager).updateTotalFrozen(borrower, false);
                IUserManager(userManager).repayLoanOverdue(borrower, underlying, accountBorrows[borrower].lastRepay);
            }
            accountBorrows[borrower].principal = borrowedAmount - repayAmount;
            accountBorrows[borrower].interest = 0;

            if (accountBorrows[borrower].principal == 0) {
                //LastRepay is cleared when the arrears are paid off, and reinitialized the next time the loan is borrowed
                accountBorrows[borrower].lastRepay = 0;
            } else {
                accountBorrows[borrower].lastRepay = getBlockNumber();
            }
        } else {
            toReserveAmount = (repayAmount * reserveFactorMantissa) / WAD;
            toRedeemableAmount = repayAmount - toReserveAmount;
            accountBorrows[borrower].interest = interest - repayAmount;
        }

        totalReserves += toReserveAmount;
        totalRedeemable += toRedeemableAmount;

        uint256 newPrincipal = accountBorrows[borrower].principal;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows -= repayAmount;

        IUserManager(userManager).updateLockedData(borrower, oldPrincipal - newPrincipal, false);

        assetToken.safeTransferFrom(payer, address(this), repayAmount);

        assetToken.safeApprove(assetManager, 0);
        assetToken.safeApprove(assetManager, repayAmount);

        require(IAssetManager(assetManager).deposit(underlying, repayAmount), ""UToken: Deposit failed"");

        emit LogRepay(borrower, repayAmount);
    }

    function repayBorrowWithPermit(
        address borrower,
        uint256 amount,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IUErc20 erc20Token = IUErc20(underlying);
        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);

        _repayBorrowFresh(msg.sender, borrower, amount);
    }

    /**
     *  @dev Accrue interest
     *  @return Accrue interest finished
     */
    function accrueInterest() public returns (bool) {
        uint256 borrowRate = borrowRatePerBlock();
        uint256 currentBlockNumber = getBlockNumber();
        uint256 blockDelta = currentBlockNumber - accrualBlockNumber;

        uint256 simpleInterestFactor = borrowRate * blockDelta;
        uint256 interestAccumulated = (simpleInterestFactor * totalBorrows) / WAD;
        uint256 totalBorrowsNew = interestAccumulated + totalBorrows;
        uint256 borrowIndexNew = (simpleInterestFactor * borrowIndex) / WAD + borrowIndex;

        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;

        return true;
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint256) {
        return exchangeRateCurrent() * uErc20.balanceOf(owner);
    }

    function mint(uint256 mintAmount) external whenNotPaused nonReentrant {
        require(accrueInterest(), ""UToken: accrue interest failed"");
        uint256 exchangeRate = exchangeRateStored();
        IUErc20 assetToken = IUErc20(underlying);
        uint256 balanceBefore = assetToken.balanceOf(address(this));
        require(assetToken.allowance(msg.sender, address(this)) >= mintAmount, ""UToken: Not enough allowance"");
        assetToken.safeTransferFrom(msg.sender, address(this), mintAmount);
        uint256 balanceAfter = assetToken.balanceOf(address(this));
        uint256 actualMintAmount = balanceAfter - balanceBefore;
        totalRedeemable += actualMintAmount;
        uint256 mintTokens = (actualMintAmount * WAD) / exchangeRate;
        uErc20.mint(msg.sender, mintTokens);

        assetToken.safeApprove(assetManager, 0);
        assetToken.safeApprove(assetManager, actualMintAmount);

        require(IAssetManager(assetManager).deposit(underlying, actualMintAmount), ""UToken: Deposit failed"");

        emit LogMint(msg.sender, actualMintAmount, mintTokens);
    }

    /**
     * @notice Sender redeems uTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of uTokens to redeem into underlying
     */
    function redeem(uint256 redeemTokens) external whenNotPaused nonReentrant {
        require(accrueInterest(), ""UToken: accrue interest failed"");
        _redeemFresh(payable(msg.sender), redeemTokens, 0);
    }

    /**
     * @notice Sender redeems uTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to receive from redeeming uTokens
     */
    function redeemUnderlying(uint256 redeemAmount) external whenNotPaused nonReentrant {
        require(accrueInterest(), ""UToken: accrue interest failed"");
        _redeemFresh(payable(msg.sender), 0, redeemAmount);
    }

    /**
     * @notice User redeems uTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of uTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
     * @param redeemAmountIn The number of underlying tokens to receive from redeeming uTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
     */
    function _redeemFresh(
        address payable redeemer,
        uint256 redeemTokensIn,
        uint256 redeemAmountIn
    ) internal {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, ""one of redeemTokensIn or redeemAmountIn must be zero"");

        IAssetManager assetManagerContract = IAssetManager(assetManager);

        uint256 exchangeRate = exchangeRateStored();

        uint256 redeemTokens;
        uint256 redeemAmount;

        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            redeemTokens = redeemTokensIn;
            redeemAmount = (redeemTokensIn * exchangeRate) / WAD;
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */
            redeemTokens = (redeemAmountIn * WAD) / exchangeRate;
            redeemAmount = redeemAmountIn;
        }

        require(totalRedeemable >= redeemAmount, ""redeem amount error"");
        totalRedeemable -= redeemAmount;
        uErc20.burn(redeemer, redeemTokens);

        require(assetManagerContract.withdraw(underlying, redeemer, redeemAmount), ""UToken: Failed to withdraw"");

        emit LogRedeem(redeemer, redeemTokensIn, redeemAmountIn, redeemAmount);
    }

    function addReserves(uint256 addAmount) external whenNotPaused nonReentrant {
        require(accrueInterest(), ""UToken: accrue interest failed"");
        IUErc20 assetToken = IUErc20(underlying);
        uint256 balanceBefore = assetToken.balanceOf(address(this));
        require(assetToken.allowance(msg.sender, address(this)) >= addAmount, ""UToken: Not enough allowance"");
        assetToken.safeTransferFrom(msg.sender, address(this), addAmount);
        uint256 balanceAfter = assetToken.balanceOf(address(this));
        uint256 actualAddAmount = balanceAfter - balanceBefore;

        uint256 totalReservesNew = totalReserves + actualAddAmount;
        /* Revert on overflow */
        require(totalReservesNew >= totalReserves, ""add reserves unexpected overflow"");
        totalReserves = totalReservesNew;

        assetToken.safeApprove(assetManager, 0);
        assetToken.safeApprove(assetManager, balanceAfter);

        require(IAssetManager(assetManager).deposit(underlying, balanceAfter), ""UToken: Deposit failed"");

        emit LogReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function removeReserves(address receiver, uint256 reduceAmount) external whenNotPaused nonReentrant onlyAdmin {
        require(accrueInterest(), ""UToken: accrue interest failed"");
        require(reduceAmount <= totalReserves, ""amount is large than totalReserves"");

        IAssetManager assetManagerContract = IAssetManager(assetManager);

        uint256 totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, ""reduce reserves unexpected underflow"");

        totalReserves = totalReservesNew;

        require(assetManagerContract.withdraw(underlying, receiver, reduceAmount), ""UToken: Failed to withdraw"");

        emit LogReservesReduced(receiver, reduceAmount, totalReservesNew);
    }

    function debtWriteOff(address borrower, uint256 amount) external whenNotPaused onlyUserManager {
        uint256 oldPrincipal = accountBorrows[borrower].principal;
        uint256 repayAmount;
        if (amount > oldPrincipal) {
            repayAmount = oldPrincipal;
        } else {
            repayAmount = amount;
        }

        accountBorrows[borrower].principal = oldPrincipal - repayAmount;
        totalBorrows -= repayAmount;
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint256) {
        return block.number;
    }

    function _setInterestRateModelFresh(address newInterestRateModel_) private {
        address oldInterestRateModel = address(interestRateModel);
        address newInterestRateModel = newInterestRateModel_;
        require(
            IInterestRateModel(newInterestRateModel).isInterestRateModel(),
            ""UToken: new model is not a interestRateModel""
        );
        interestRateModel = IInterestRateModel(newInterestRateModel);

        emit LogNewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);
    }

    /**
     *  @dev Update borrower overdue info
     *  @param account Borrower address
     */
    function updateOverdueInfo(address account) external whenNotPaused {
        if (checkIsOverdue(account)) {
            IUserManager(userManager).updateTotalFrozen(account, true);
        }
    }

    /**
     *  @dev Batch update borrower overdue info
     *  @param accounts Borrowers address
     */
    function batchUpdateOverdueInfos(address[] calldata accounts) external whenNotPaused {
        address[] memory overdueAccounts = new address[](accounts.length);
        bool[] memory isOverdues = new bool[](accounts.length);
        for (uint256 i = 0; i < accounts.length; i++) {
            if (checkIsOverdue(accounts[i])) {
                overdueAccounts[i] = accounts[i];
                isOverdues[i] = true;
            }
        }
        IUserManager(userManager).batchUpdateTotalFrozen(overdueAccounts, isOverdues);
    }

    /**
     *  @dev Get a member's available credit limit
     *  @param account Member address
     *  @return Member credit limit
     */
    function _getCreditLimit(address account) private view returns (int256) {
        return IUserManager(userManager).getCreditLimit(account);
    }
}",6882
RealWorld_BA_45_Whitelistable_RealWord_20240820174000.log,45,Whitelistable,9848,4951,14799,73.0,0.14826,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;
pragma abicoder v1;

import ""@openzeppelin/contracts/access/Ownable.sol"";

abstract contract Whitelistable is Ownable {
    // allow all transfers when set as false
    bool public whitelistEnabled;

    // allow transfers when `whitelistEnabled` is set as true
    mapping(address => bool) internal _whitelisted;

    event Whitelisted(address indexed _account);
    event Unwhitelisted(address indexed _account);
    event WhitelistEnabled();
    event WhitelistDisabled();

    modifier checkWhitelist() {
        if (whitelistEnabled) {
            require(_whitelisted[msg.sender], ""Whitelistable: address not whitelisted"");
        }
        _;
    }

    /**
     * @notice enable whitelist and only allow transfers from whitelisted addresses
     */
    function enableWhitelist() external onlyOwner {
        whitelistEnabled = true;
        emit WhitelistEnabled();
    }

    /**
     * @notice disable whitelist and allow transfers for everyone
     */
    function disableWhitelist() external onlyOwner {
        whitelistEnabled = false;
        emit WhitelistDisabled();
    }

    /**
     * @dev Checks if account is whitelisted
     * @param _account The address to check
     */
    function isWhitelisted(address _account) public view returns (bool) {
        return _whitelisted[_account];
    }

    /**
     * @dev Adds account to whitelist
     * @param _account The address to whitelist
     */
    function whitelist(address _account) public onlyOwner {
        _whitelisted[_account] = true;
        emit Whitelisted(_account);
    }

    /**
     * @dev Removes account from whitelist
     * @param _account The address to remove from the whitelist
     */
    function unwhitelist(address _account) external onlyOwner {
        _whitelisted[_account] = false;
        emit Unwhitelisted(_account);
    }
}",424
RealWorld_BA_45_Treasury_RealWord_20240820182400.log,45,Treasury,18755,6051,24806,91.0,0.214795,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;
pragma abicoder v1;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

contract Treasury {
    using SafeERC20 for IERC20;

    /// @notice Reference to token to drip (immutable)
    IERC20 public immutable token;
    address public admin;

    struct Schedule {
        uint256 dripStart; //The block number when the Treasury started (immutable)
        uint256 amount; //Total amount to drip (immutable)
        uint256 dripRate; //Tokens per block that to drip to target (immutable)
        address target; //Target to receive dripped tokens (immutable)
        uint256 dripped; //Amount that has already been dripped
    }

    mapping(address => Schedule) public tokenSchedules; //0: target address, 1: Schedule

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Treasury: not admin"");
        _;
    }

    constructor(IERC20 token_) {
        admin = msg.sender;
        token = token_;
    }

    function setAdmin(address admin_) public onlyAdmin {
        admin = admin_;
    }

    /**
     * @notice Drips the maximum amount of tokens to match the drip rate since inception
     * @dev Note: this will only drip up to the amount of tokens available.
     * @return The amount of tokens dripped in this call
     */
    function drip(address target) public returns (uint256) {
        require(tokenSchedules[target].target != address(0), ""Target schedule doesn't exist"");
        // First, read storage into memory
        IERC20 token_ = token;
        uint256 dripRate_ = tokenSchedules[target].dripRate;
        uint256 dripStart_ = tokenSchedules[target].dripStart;
        uint256 dripped_ = tokenSchedules[target].dripped;
        address target_ = tokenSchedules[target].target;
        uint256 totalAmount_ = tokenSchedules[target].amount;
        uint256 blockNumber_ = block.number;

        require(blockNumber_ >= dripStart_, ""not yet started"");
        uint256 treasuryBalance_ = token_.balanceOf(address(this)); // TODO: Verify this is a static call

        // Next, calculate intermediate values
        uint256 dripTotal_ = _min((blockNumber_ - dripStart_) * dripRate_, totalAmount_);
        uint256 deltaDrip_;
        if (dripTotal_ > dripped_) {
            deltaDrip_ = dripTotal_ - dripped_;
        } else {
            deltaDrip_ = 0;
        }
        uint256 toDrip_ = _min(treasuryBalance_, deltaDrip_);
        uint256 drippedNext_ = dripped_ + toDrip_;

        // Finally, write new `dripped` value and transfer tokens to target
        tokenSchedules[target_].dripped = drippedNext_;
        token_.safeTransfer(target_, toDrip_);

        return toDrip_;
    }

    function addSchedule(
        uint256 dripStart_,
        uint256 dripRate_,
        address target_,
        uint256 amount_
    ) public onlyAdmin {
        require(tokenSchedules[target_].target == address(0), ""Target schedule already exists"");
        Schedule memory schedule;
        schedule.dripStart = dripStart_;
        schedule.dripRate = dripRate_;
        schedule.target = target_;
        schedule.amount = amount_;
        schedule.dripped = 0;
        tokenSchedules[target_] = schedule;
    }

    function editSchedule(
        uint256 dripStart_,
        uint256 dripRate_,
        address target_,
        uint256 amount_
    ) public onlyAdmin {
        require(tokenSchedules[target_].target != address(0), ""Target schedule doesn't exist"");
        tokenSchedules[target_].dripStart = dripStart_;
        tokenSchedules[target_].dripRate = dripRate_;
        tokenSchedules[target_].amount = amount_;
    }

    function grantToken(address account, uint256 amount) public onlyAdmin {
        IERC20 token_ = token;
        uint256 treasuryBalance_ = token_.balanceOf(address(this));
        require(amount <= treasuryBalance_, ""amount larger than balance"");
        token_.safeTransfer(account, amount);
    }

    function _min(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a <= b) {
            return a;
        } else {
            return b;
        }
    }
}",970
RealWorld_BA_45_IDai_RealWord_20240820183812.log,45,IDai,4173,4272,8445,78.0,0.106305,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

interface IDai {
    function permit(
        address holder,
        address spender,
        uint256 nonce,
        uint256 expiry,
        bool allowed,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}",69
RealWorld_BA_45_UErc20_RealWord_20240820181824.log,45,UErc20,5218,4051,9269,63.0,0.10711,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;
pragma abicoder v1;

import ""@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract UErc20 is ERC20Permit, Ownable {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) ERC20Permit(name) {} // solhint-disable-line no-empty-blocks

    function mint(address account, uint256 amount) external onlyOwner {
        _mint(account, amount);
    }

    function burn(address account, uint256 amount) external onlyOwner {
        _burn(account, amount);
    }
}",153
RealWorld_BA_45_SumOfTrust_RealWord_20240820181323.log,45,SumOfTrust,18068,5715,23783,118.0,0.20464,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/utils/math/Math.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

import ""../interfaces/ICreditLimitModel.sol"";

contract SumOfTrust is Ownable, ICreditLimitModel {
    using Math for uint256;

    bool public constant override isCreditLimitModel = true;
    uint256 public override effectiveNumber;

    constructor(uint256 effectiveNumber_) {
        effectiveNumber = effectiveNumber_;
    }

    function getCreditLimit(uint256[] memory vouchs) public view override returns (uint256) {
        if (vouchs.length >= effectiveNumber) {
            uint256 limit;
            for (uint256 i = 0; i < vouchs.length; i++) {
                limit += vouchs[i];
            }

            return limit;
        } else {
            return 0;
        }
    }

    function getLockedAmount(
        LockedInfo[] memory array,
        address account,
        uint256 amount,
        bool isIncrease
    ) public pure override returns (uint256) {
        if (array.length == 0) return 0;

        uint256 remaining = amount;
        uint256 newLockedAmount;
        if (isIncrease) {
            array = _sortArray(array, true);
            for (uint256 i = 0; i < array.length; i++) {
                uint256 remainingVouchingAmount;
                if (array[i].vouchingAmount > array[i].lockedAmount) {
                    remainingVouchingAmount = array[i].vouchingAmount - array[i].lockedAmount;
                } else {
                    remainingVouchingAmount = 0;
                }

                if (remainingVouchingAmount > array[i].availableStakingAmount) {
                    if (array[i].availableStakingAmount > remaining) {
                        newLockedAmount = array[i].lockedAmount + remaining;
                        remaining = 0;
                    } else {
                        newLockedAmount = array[i].lockedAmount + array[i].availableStakingAmount;
                        remaining = remaining - array[i].availableStakingAmount;
                    }
                } else {
                    if (remainingVouchingAmount > remaining) {
                        newLockedAmount = array[i].lockedAmount + remaining;
                        remaining = 0;
                    } else {
                        newLockedAmount = array[i].lockedAmount + remainingVouchingAmount;
                        remaining -= remainingVouchingAmount;
                    }
                }

                if (account == array[i].staker) {
                    return newLockedAmount;
                }
            }
        } else {
            array = _sortArray(array, false);
            for (uint256 i = 0; i < array.length; i++) {
                if (array[i].lockedAmount > remaining) {
                    newLockedAmount = array[i].lockedAmount - remaining;
                    remaining = 0;
                } else {
                    newLockedAmount = 0;
                    remaining -= array[i].lockedAmount;
                }

                if (account == array[i].staker) {
                    return newLockedAmount;
                }
            }
        }

        return 0;
    }

    function setEffectNumber(uint256 number) external onlyOwner {
        effectiveNumber = number;
    }

    function _sortArray(LockedInfo[] memory arr, bool isPositive) private pure returns (LockedInfo[] memory) {
        uint256 length = arr.length;

        for (uint256 i = 0; i < length; i++) {
            for (uint256 j = i + 1; j < length; j++) {
                if (isPositive) {
                    if (arr[i].vouchingAmount < arr[j].vouchingAmount) {
                        LockedInfo memory temp = arr[j];
                        arr[j] = arr[i];
                        arr[i] = temp;
                    }
                } else {
                    if (arr[i].vouchingAmount > arr[j].vouchingAmount) {
                        LockedInfo memory temp = arr[j];
                        arr[j] = arr[i];
                        arr[i] = temp;
                    }
                }
            }
        }

        return arr;
    }
}",865
RealWorld_BA_45_UserManagerMock_RealWord_20240820175915.log,45,UserManagerMock,17883,6098,23981,153.0,0.211375,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

/**
 * @title UserManager Contract
 * @dev Manages the Union members credit lines, and their vouchees and borrowers info.
 */
contract UserManagerMock {
    uint256 public constant MAX_TRUST_LIMIT = 100;
    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;

    uint256 public newMemberFee; // New member application fee
    uint256 public totalStaked;
    uint256 public totalFrozen;
    bool public isMember;
    int256 public limit;
    uint256 public stakerBalance;
    uint256 public totalLockedStake;
    uint256 public totalFrozenAmount;

    function __UserManager_init() public {
        newMemberFee = 10**18; // Set the default membership fee
    }

    function setNewMemberFee(uint256 amount) public {
        newMemberFee = amount;
    }

    function setIsMember(bool isMember_) public {
        isMember = isMember_;
    }

    function checkIsMember(address) public view returns (bool) {
        return isMember;
    }

    function setStakerBalance(uint256 stakerBalance_) public {
        stakerBalance = stakerBalance_;
    }

    function getStakerBalance(address) public view returns (uint256) {
        return stakerBalance;
    }

    function setTotalLockedStake(uint256 totalLockedStake_) public {
        totalLockedStake = totalLockedStake_;
    }

    function getTotalLockedStake(address) public view returns (uint256) {
        return totalLockedStake;
    }

    function setTotalFrozenAmount(uint256 totalFrozenAmount_) public {
        totalFrozenAmount = totalFrozenAmount_;
    }

    function getTotalFrozenAmount(address) public view returns (uint256) {
        return totalFrozenAmount;
    }

    function setCreditLimit(int256 limit_) public {
        limit = limit_;
    }

    function getCreditLimit(address) public view returns (int256) {
        return limit;
    }

    function getBorrowerAddresses(address account) public view returns (address[] memory) {}

    function getStakerAddresses(address account) public view returns (address[] memory) {}

    function getBorrowerAsset(address account, address borrower)
        public
        view
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {}

    function getStakerAsset(address account, address staker)
        public
        view
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {}

    function getLockedStake(address staker, address borrower) public view returns (uint256) {}

    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {}

    function addMember(address account) public {}

    function updateTrust(address borrower_, uint256 trustAmount) external {}

    function cancelVouch(address staker, address borrower) external {}

    function registerMemberWithPermit(
        address newMember,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {}

    function registerMember(address newMember) public {}

    function updateLockedData(
        address borrower,
        uint256 amount,
        bool isBorrow
    ) external {}

    function stake(uint256 amount) public {}

    /**
     *  @dev stakeWithPermit
     *  @param amount Amount
     */
    function stakeWithPermit(
        uint256 amount,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {}

    function unstake(uint256 amount) external {}

    function withdrawRewards() external {}

    function updateTotalFrozen(address, bool) external {}

    function batchUpdateTotalFrozen(address[] calldata, bool[] calldata) external {}

    function repayLoanOverdue(
        address account,
        address token,
        uint256 lastRepay
    ) external {}

    //Only supports sumOfTrust
    function debtWriteOff(address borrower, uint256 amount) public {}

    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view returns (uint256) {}
}",904
RealWorld_BA_45_PureTokenAdapter_RealWord_20240820174738.log,45,PureTokenAdapter,15162,4996,20158,74.0,0.17573,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;
pragma abicoder v1;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""../interfaces/IMoneyMarketAdapter.sol"";
import ""../Controller.sol"";

contract PureTokenAdapter is Controller, IMoneyMarketAdapter {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    address public assetManager;
    mapping(address => uint256) public override floorMap;
    mapping(address => uint256) public override ceilingMap;

    modifier checkTokenSupported(address tokenAddress) {
        require(_supportsToken(tokenAddress), ""PureTokenAdapter: token not supported"");
        _;
    }

    modifier onlyAssetManager() {
        require(msg.sender == assetManager, ""PureTokenAdapter: only asset manager can call"");
        _;
    }

    function __PureTokenAdapter_init(address _assetManager) public initializer {
        Controller.__Controller_init(msg.sender);
        assetManager = _assetManager;
    }

    function setAssetManager(address _assetManager) external onlyAdmin {
        assetManager = _assetManager;
    }

    function setFloor(address tokenAddress, uint256 floor) external onlyAdmin {
        floorMap[tokenAddress] = floor;
    }

    function setCeiling(address tokenAddress, uint256 ceiling) external onlyAdmin {
        ceilingMap[tokenAddress] = ceiling;
    }

    function getRate(address) external pure override returns (uint256) {
        return 0;
    }

    // solhint-disable-next-line no-empty-blocks
    function deposit(address tokenAddress) external view override checkTokenSupported(tokenAddress) {
        // Don't have to do anything because AssetManager already transfered tokens here
    }

    function withdraw(
        address tokenAddress,
        address recipient,
        uint256 tokenAmount
    ) external override onlyAssetManager checkTokenSupported(tokenAddress) {
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        token.safeTransfer(recipient, tokenAmount);
    }

    function withdrawAll(address tokenAddress, address recipient)
        external
        override
        onlyAssetManager
        checkTokenSupported(tokenAddress)
    {
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        token.safeTransfer(recipient, token.balanceOf(address(this)));
    }

    function claimTokens(address tokenAddress, address recipient) external override onlyAssetManager {
        _claimTokens(tokenAddress, recipient);
    }

    function getSupply(address tokenAddress) external view override returns (uint256) {
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        return token.balanceOf(address(this));
    }

    function getSupplyView(address tokenAddress) external view override returns (uint256) {
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        return token.balanceOf(address(this));
    }

    function supportsToken(address tokenAddress) external view override returns (bool) {
        return _supportsToken(tokenAddress);
    }

    function _supportsToken(address tokenAddress) internal view returns (bool) {
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        return tokenAddress != address(0) && token.balanceOf(address(this)) >= 0; // simple check if the token is ERC20 compatible
    }

    function _claimTokens(address tokenAddress, address recipient) private {
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        uint256 balance = token.balanceOf(address(this));
        token.safeTransfer(recipient, balance);
    }
}",769
RealWorld_BA_45_IComptroller_RealWord_20240820183242.log,45,IComptroller,9188,5593,14781,77.0,0.1578,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

/**
 * @title Comptroller Interface
 * @dev Work with UnionToken and UserManager to calculate the Union rewards based on the staking info from UserManager, and be ready to support multiple UserManagers for various tokens when we support multiple assets.
 */
interface IComptroller {
    /**
     *  @dev Get the reward multipier based on the account status
     *  @param account Account address
     *  @return Multiplier number (in wei)
     */
    function getRewardsMultiplier(address account, address token) external view returns (uint256);

    /**
     *  @dev Withdraw rewards
     *  @return Amount of rewards
     */
    function withdrawRewards(address sender, address token) external returns (uint256);

    function addFrozenCoinAge(
        address staker,
        address token,
        uint256 lockedStake,
        uint256 lastRepay
    ) external;

    function updateTotalStaked(address token, uint256 totalStaked) external returns (bool);

    /**
     *  @dev Calculate unclaimed rewards based on blocks
     *  @param account User address
     *  @param futureBlocks Number of blocks in the future
     *  @return Unclaimed rewards
     */
    function calculateRewardsByBlocks(
        address account,
        address token,
        uint256 futureBlocks
    ) external view returns (uint256);

    /**
     *  @dev Calculate currently unclaimed rewards
     *  @param account Account address
     *  @return Unclaimed rewards
     */
    function calculateRewards(address account, address token) external view returns (uint256);
}",360
RealWorld_BA_45_Controller_RealWord_20240820173435.log,45,Controller,16882,5517,22399,86.0,0.19475,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol"";

/**
 * @title Controller component
 * @dev For easy access to any core components
 */
abstract contract Controller is Initializable, UUPSUpgradeable, AccessControlUpgradeable {
    bytes32 public constant ROLE_ADMIN = keccak256(""ROLE_ADMIN"");

    mapping(address => address) private _admins;
    // slither-disable-next-line uninitialized-state
    bool private _paused;
    // slither-disable-next-line uninitialized-state
    address public pauseGuardian;

    /**
     * @dev Emitted when the pause is triggered by a pauser (`account`).
     */
    event Paused(address account);

    /**
     * @dev Emitted when the pause is lifted by a pauser (`account`).
     */
    event Unpaused(address account);

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
        require(!_paused, ""Controller: paused"");
        _;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is paused.
     */
    modifier whenPaused() {
        require(_paused, ""Controller: not paused"");
        _;
    }

    modifier onlyAdmin() {
        require(hasRole(ROLE_ADMIN, msg.sender), ""Controller: not admin"");
        _;
    }

    modifier onlyGuardian() {
        require(pauseGuardian == msg.sender, ""Controller: caller does not have the guardian role"");
        _;
    }

    //When using minimal deploy, do not call initialize directly during deploy, because msg.sender is the proxyFactory address, and you need to call it manually
    function __Controller_init(address admin_) public initializer {
        require(admin_ != address(0), ""Controller: address zero"");
        _paused = false;
        _admins[admin_] = admin_;
        __UUPSUpgradeable_init();
        _setupRole(ROLE_ADMIN, admin_);
        pauseGuardian = admin_;
    }

    function _authorizeUpgrade(address) internal view override onlyAdmin {}

    /**
     * @dev Check if the address provided is the admin
     * @param account Account address
     */
    function isAdmin(address account) public view returns (bool) {
        return hasRole(ROLE_ADMIN, account);
    }

    /**
     * @dev Add a new admin account
     * @param account Account address
     */
    function addAdmin(address account) public onlyAdmin {
        require(account != address(0), ""Controller: address zero"");
        require(_admins[account] == address(0), ""Controller: admin already existed"");

        _admins[account] = account;
        _setupRole(ROLE_ADMIN, account);
    }

    /**
     * @dev Set pauseGuardian account
     * @param account Account address
     */
    function setGuardian(address account) public onlyAdmin {
        pauseGuardian = account;
    }

    /**
     * @dev Renouce the admin from the sender's address
     */
    function renounceAdmin() public {
        renounceRole(ROLE_ADMIN, msg.sender);
        delete _admins[msg.sender];
    }

    /**
     * @dev Returns true if the contract is paused, and false otherwise.
     */
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Called by a pauser to pause, triggers stopped state.
     */
    function pause() public onlyGuardian whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev Called by a pauser to unpause, returns to normal state.
     */
    function unpause() public onlyGuardian whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }

    uint256[50] private ______gap;
}",860
RealWorld_BA_45_UTokenMock_RealWord_20240820174854.log,45,UTokenMock,18801,5580,24381,85.0,0.205605,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";

import ""../interfaces/IUserManager.sol"";

/**
 *  @title UToken Contract
 *  @dev Union accountBorrows can borrow and repay thru this component.
 */
contract UTokenMock is ERC20Upgradeable {
    bool public constant IS_UTOKEN = true;
    uint256 public constant WAD = 1e18;
    uint256 internal constant BORROW_RATE_MAX_MANTISSA = 0.0005e16; //Maximum borrow rate that can ever be applied (.0005% / block)
    uint256 internal constant RESERVE_FACTORY_MAX_MANTISSA = 1e18; //Maximum fraction of interest that can be set aside for reserves

    bytes32 public constant PERMIT_TYPEHASH =
        keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");

    bool public isOverdue;

    function __UToken_init() public initializer {
        ERC20Upgradeable.__ERC20_init(""uToken"", ""uToken"");
    }

    function updateOverdueInfo(
        address userManager,
        address account,
        bool _isOverdue
    ) external {
        IUserManager(userManager).updateTotalFrozen(account, _isOverdue);
    }

    function updateLockedData(
        address userManager,
        address account,
        uint256 amount
    ) external {
        IUserManager(userManager).updateLockedData(account, amount, true);
    }

    function setIsOverdue(bool _isOverdue) public returns (bool) {
        return isOverdue = _isOverdue;
    }

    function checkIsOverdue(address) public view returns (bool) {
        return isOverdue;
    }

    function getRemainingLoanSize() public pure returns (uint256) {
        return 0;
    }

    function getLastRepay(address) public pure returns (uint256 lastRepay) {
        lastRepay = 0;
    }

    function getInterestIndex(address) public pure returns (uint256 interestIndex) {
        interestIndex = 0;
    }

    function calculatingFee(uint256) public pure returns (uint256) {
        return 0;
    }

    function getLoan(address)
        public
        view
        returns (
            uint256 principal,
            uint256 totalBorrowed,
            address asset,
            uint256 apr,
            int256 limit,
            bool _isOverdue,
            uint256 lastRepay
        )
    {}

    function getBorrowed(address) public view returns (uint256) {}

    function borrowBalanceView(address) public pure returns (uint256) {
        return 0;
    }

    function borrowRatePerBlock() public view returns (uint256) {}

    function supplyRatePerBlock() public pure returns (uint256) {
        return 0;
    }

    function exchangeRateCurrent() public view returns (uint256) {
        return exchangeRateStored();
    }

    function exchangeRateStored() public view returns (uint256) {}

    function calculatingInterest(address) public pure returns (uint256) {
        return 0;
    }

    function repayBorrowWithPermit(
        address,
        uint256,
        uint256,
        uint256,
        uint8,
        bytes32,
        bytes32
    ) public {}

    function accrueInterest() public pure returns (bool) {
        return true;
    }

    function balanceOfUnderlying(address owner) external view returns (uint256) {
        return balanceOf(owner);
    }

    function mint(uint256 mintAmount) external {
        _mint(msg.sender, mintAmount);
    }

    function redeem(uint256) external {}

    function redeemUnderlying(uint256) external {}

    function addReserves(uint256) external {}

    function removeReserves(address, uint256) external {}

    function debtWriteOff(address, uint256) external {}

    function getBlockNumber() internal view returns (uint256) {
        return block.number;
    }

    function batchUpdateOverdueInfos(address[] calldata accounts) external {}

    function getChainId() internal view returns (uint256) {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        return chainId;
    }

    function permit(
        address,
        address,
        uint256,
        uint256,
        uint8,
        bytes32,
        bytes32
    ) external {}
}",962
RealWorld_BA_45_IMarketRegistry_RealWord_20240820183527.log,45,IMarketRegistry,6505,4368,10873,69.0,0.119885,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

/**
 * @title MarketRegistry Interface
 * @dev Registering and managing all the lending markets.
 */
interface IMarketRegistry {
    function getUTokens() external view returns (address[] memory);

    function getUserManagers() external view returns (address[] memory);

    /**
     *  @dev Returns the market address of the token
     *  @return The market address
     */
    function tokens(address token) external view returns (address, address);

    function createUToken(
        address token,
        address assetManager,
        uint256 originationFee,
        uint256 globalMaxLoan,
        uint256 maxBorrow,
        uint256 minLoan,
        uint256 maxLateBlock,
        address interestRateModel
    ) external returns (address);

    function createUserManager(
        address assetManager,
        address unionToken,
        address stakingToken,
        address creditLimitModel,
        address inflationIndexModel,
        address comptroller
    ) external returns (address);
}",221
RealWorld_BA_45_MarketRegistryMock_RealWord_20240820180150.log,45,MarketRegistryMock,9764,4857,14621,84.0,0.14596,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

contract MarketRegistryMock is Initializable {
    struct Market {
        address uToken;
        address userManager;
    }

    address[] public uTokenList;
    address[] public userManagerList;
    mapping(address => Market) public tokens;

    function __MarketRegistryMock_init() public initializer {}

    function addUToken(address token, address uToken) public {
        uTokenList.push(uToken);
        tokens[token].uToken = uToken;
    }

    function addUserManager(address token, address userManager) public {
        userManagerList.push(userManager);
        tokens[token].userManager = userManager;
    }

    function deleteMarket(address token) public {
        address oldUToken = tokens[token].uToken;
        bool uTokenExist = false;
        uint256 uTokenIndex = 0;

        for (uint256 i = 0; i < uTokenList.length; i++) {
            if (oldUToken == uTokenList[i]) {
                uTokenExist = true;
                uTokenIndex = i;
            }
        }

        if (uTokenExist) {
            uTokenList[uTokenIndex] = uTokenList[uTokenList.length - 1];
            uTokenList.pop();
        }

        tokens[token].uToken = address(0);

        address oldUserManager = tokens[token].userManager;
        bool userManagerExist = false;
        uint256 userManagerIndex = 0;

        for (uint256 i = 0; i < userManagerList.length; i++) {
            if (oldUserManager == userManagerList[i]) {
                userManagerExist = true;
                userManagerIndex = i;
            }
        }

        if (userManagerExist) {
            userManagerList[userManagerIndex] = userManagerList[userManagerList.length - 1];
            userManagerList.pop();
        }

        tokens[token].userManager = address(0);
    }
}",414
RealWorld_BA_45_Comptroller_RealWord_20240820173836.log,45,Comptroller,50080,5112,55192,82.0,0.35264,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";

import ""../Controller.sol"";
import ""../WadRayMath.sol"";
import ""../interfaces/IComptroller.sol"";
import ""../interfaces/IMarketRegistry.sol"";
import ""../interfaces/IUserManager.sol"";

//For the time being, only the reward calculation of a single token is supported, and the contract needs to be revised after determining the reward calculation scheme of multiple tokens
contract Comptroller is Controller, IComptroller {
    using WadRayMath for uint256;
    using SafeERC20Upgradeable for IERC20Upgradeable;

    struct Info {
        uint256 frozenCoinAge;
        uint256 updatedBlock; //last withdraw rewards block
        uint256 inflationIndex; //last withdraw rewards inflationIndex
        uint256 accrued; //the unionToken accrued but not yet transferred to each user
    }

    struct UserManagerData {
        uint256 userStaked;
        uint256 totalFrozen;
        uint256 totalStaked;
        uint256 userFrozen;
        uint256 frozenCoinAge;
        uint256 totalLocked;
        bool isMember;
    }

    uint256 public constant INIT_INFLATION_INDEX = 10**18;
    uint256 public constant nonMemberRatio = 75 * 10**16; // 75%;
    uint256 public constant memberRatio = 10**18; // 100%;
    uint256 public halfDecayPoint;
    uint256 public gInflationIndex; // store the latest inflation index
    uint256 public gLastUpdatedBlock; // block number when updating the inflation index
    IERC20Upgradeable public unionToken;
    IMarketRegistry public marketRegistry;
    //1 address account, 2 address token
    mapping(address => mapping(address => Info)) public users;

    modifier onlyUserManager(address token) {
        require(msg.sender == _getUserManager(token), ""UnionToken: only user manager can call"");
        _;
    }

    /**
     *  @dev Withdraw rewards event
     *  @param account The staker's address
     *  @param amount The amount of Union tokens to withdraw
     */
    event LogWithdrawRewards(address indexed account, uint256 amount);

    function __Comptroller_init(address unionToken_, address marketRegistry_) public initializer {
        Controller.__Controller_init(msg.sender);
        unionToken = IERC20Upgradeable(unionToken_);
        marketRegistry = IMarketRegistry(marketRegistry_);
        gInflationIndex = INIT_INFLATION_INDEX;
        gLastUpdatedBlock = block.number;
        halfDecayPoint = 100000;
    }

    function setHalfDecayPoint(uint256 point) public onlyAdmin {
        halfDecayPoint = point;
    }

    /**
     *  @dev Get the reward multipier based on the account status
     *  @param account Account address
     *  @param token ERC20 token address
     *  @return Multiplier number (in wei)
     */
    function getRewardsMultiplier(address account, address token) public view override returns (uint256) {
        IUserManager userManagerContract = IUserManager(_getUserManager(token));
        uint256 stakingAmount = userManagerContract.getStakerBalance(account);
        uint256 lockedStake = userManagerContract.getTotalLockedStake(account);
        uint256 totalFrozen = userManagerContract.getTotalFrozenAmount(account);
        bool isMember = userManagerContract.checkIsMember(account);
        return _getRewardsMultiplier(stakingAmount, lockedStake, totalFrozen, isMember);
    }

    /**
     *  @dev Withdraw rewards
     *  @param token Staking token address
     *  @return Amount of rewards
     */
    function withdrawRewards(address sender, address token)
        external
        override
        whenNotPaused
        onlyUserManager(token)
        returns (uint256)
    {
        uint256 amount = calculateRewardsByBlocks(sender, token, 0);
        IUserManager userManagerContract = IUserManager(_getUserManager(token));
        // update the global states
        uint256 totalStaked_ = userManagerContract.totalStaked() - userManagerContract.totalFrozen();
        gInflationIndex = _getInflationIndexNew(totalStaked_, block.number - gLastUpdatedBlock);
        gLastUpdatedBlock = block.number;
        users[sender][token].frozenCoinAge = 0;
        users[sender][token].updatedBlock = block.number;
        users[sender][token].inflationIndex = gInflationIndex;
        if (unionToken.balanceOf(address(this)) >= amount && amount > 0) {
            unionToken.safeTransfer(sender, amount);
            users[sender][token].accrued = 0;
            emit LogWithdrawRewards(sender, amount);

            return amount;
        } else {
            users[sender][token].accrued = amount;
            emit LogWithdrawRewards(sender, 0);

            return 0;
        }
    }

    /**
     *  @dev Calculate unclaimed rewards based on blocks
     *  @param account User address
     *  @param token Staking token address
     *  @param futureBlocks Number of blocks in the future
     *  @return Unclaimed rewards
     */
    function calculateRewardsByBlocks(
        address account,
        address token,
        uint256 futureBlocks
    ) public view override returns (uint256) {
        IUserManager userManagerContract = IUserManager(_getUserManager(token));
        Info memory userInfo = users[account][token];
        UserManagerData memory userManagerData;

        userManagerData.totalFrozen = userManagerContract.totalFrozen();
        userManagerData.userStaked = userManagerContract.getStakerBalance(account);
        userManagerData.userFrozen = userManagerContract.getTotalFrozenAmount(account);
        userManagerData.totalStaked = userManagerContract.totalStaked() - userManagerData.totalFrozen;

        uint256 lastUpdatedBlock = userInfo.updatedBlock;
        if (block.number < lastUpdatedBlock) {
            lastUpdatedBlock = block.number;
        }

        uint256 pastBlocks = block.number - lastUpdatedBlock + futureBlocks;
        userManagerData.frozenCoinAge =
            userManagerContract.getFrozenCoinAge(account, pastBlocks) +
            userInfo.frozenCoinAge;

        userManagerData.totalLocked = userManagerContract.getTotalLockedStake(account);
        userManagerData.isMember = userManagerContract.checkIsMember(account);

        uint256 inflationIndex = _getRewardsMultiplier(
            userManagerData.userStaked,
            userManagerData.totalLocked,
            userManagerData.userFrozen,
            userManagerData.isMember
        );

        return
            userInfo.accrued +
            _calculateRewards(
                account,
                token,
                userManagerData.totalStaked,
                userManagerData.userStaked,
                userManagerData.frozenCoinAge,
                pastBlocks,
                inflationIndex
            );
    }

    /**
     *  @dev Calculate currently unclaimed rewards
     *  @param account Account address
     *  @param token Staking token address
     *  @return Unclaimed rewards
     */
    function calculateRewards(address account, address token) public view override returns (uint256) {
        return calculateRewardsByBlocks(account, token, 0);
    }

    /**
     *  @dev When total staked change update inflation index
     *  @param totalStaked totalStaked amount
     *  @return Whether succeeded
     */
    function updateTotalStaked(address token, uint256 totalStaked)
        external
        override
        whenNotPaused
        onlyUserManager(token)
        returns (bool)
    {
        if (totalStaked > 0) {
            gInflationIndex = _getInflationIndexNew(totalStaked, block.number - gLastUpdatedBlock);
        }
        gLastUpdatedBlock = block.number;

        return true;
    }

    function addFrozenCoinAge(
        address staker,
        address token,
        uint256 lockedStake,
        uint256 lastRepay
    ) external override onlyUserManager(token) {
        uint256 lastBlock = users[staker][token].updatedBlock;
        uint256 blocks;
        if (lastBlock > lastRepay) {
            // Frozen CoinAge here has been accounted for when the user withdraws the rewards, so here just need to calculate the delta between block.number and lastBlock
            blocks = block.number - lastBlock;
        } else {
            blocks = block.number - lastRepay;
        }

        users[staker][token].frozenCoinAge += lockedStake * blocks;
    }

    /**
     *  @dev Calculate new inflation index based on # of blocks
     *  @param totalStaked_ Number of total staked tokens in the system
     *  @param blockDelta Number of blocks
     *  @return New inflation index
     */
    function _getInflationIndexNew(uint256 totalStaked_, uint256 blockDelta) private view returns (uint256) {
        if (totalStaked_ == 0) {
            return INIT_INFLATION_INDEX;
        }

        if (blockDelta == 0) {
            return gInflationIndex;
        }

        return _getInflationIndex(totalStaked_, gInflationIndex, blockDelta);
    }

    function _calculateRewards(
        address account,
        address token,
        uint256 totalStaked,
        uint256 userStaked,
        uint256 frozenCoinAge,
        uint256 pastBlocks,
        uint256 inflationIndex
    ) private view returns (uint256) {
        uint256 startInflationIndex = users[account][token].inflationIndex;
        require(userStaked * pastBlocks >= frozenCoinAge, "" Comptroller: frozen coin age error"");

        if (userStaked == 0 || totalStaked == 0 || startInflationIndex == 0 || pastBlocks == 0) {
            return 0;
        }

        uint256 effectiveStakeAmount = (userStaked * pastBlocks - frozenCoinAge) / pastBlocks;

        uint256 curInflationIndex = _getInflationIndexNew(totalStaked, pastBlocks);

        require(curInflationIndex >= startInflationIndex, ""Comptroller: inflationIndex error"");

        return (curInflationIndex - startInflationIndex).wadMul(effectiveStakeAmount).wadMul(inflationIndex);
    }

    function _getUserManager(address token) private view returns (address userManager) {
        (, userManager) = marketRegistry.tokens(token);
    }

    /**
     *  @dev Calculate inflation per block
     *  @param effectiveTotalStake Effective total stake
     *  @return Inflation amount, div totalSupply is the inflation rate
     */
    function inflationPerBlock(uint256 effectiveTotalStake) public view returns (uint256) {
        uint256 index = effectiveTotalStake / halfDecayPoint;
        return lookup(index);
    }

    function lookup(uint256 index) public pure returns (uint256) {
        if (index <= 0.00001 * 10**18) {
            return 1 * 10**18;
        } else if (index <= 0.0001 * 10**18) {
            return 0.9 * 10**18;
        } else if (index <= 0.001 * 10**18) {
            return 0.8 * 10**18;
        } else if (index <= 0.01 * 10**18) {
            return 0.7 * 10**18;
        } else if (index <= 0.1 * 10**18) {
            return 0.6 * 10**18;
        } else if (index <= 1 * 10**18) {
            return 0.5 * 10**18;
        } else if (index <= 5 * 10**18) {
            return 0.25 * 10**18;
        } else if (index <= 10 * 10**18) {
            return 0.1 * 10**18;
        } else if (index <= 100 * 10**18) {
            return 0.01 * 10**18;
        } else if (index <= 1000 * 10**18) {
            return 0.001 * 10**18;
        } else if (index <= 10000 * 10**18) {
            return 0.0001 * 10**18;
        } else if (index <= 100000 * 10**18) {
            return 0.00001 * 10**18;
        } else {
            return 0.000001 * 10**18;
        }
    }

    function _getInflationIndex(
        uint256 effectiveAmount,
        uint256 inflationIndex,
        uint256 blockDelta
    ) private view returns (uint256) {
        return blockDelta * inflationPerBlock(effectiveAmount).wadDiv(effectiveAmount) + inflationIndex;
    }

    function _getRewardsMultiplier(
        uint256 userStaked,
        uint256 lockedStake,
        uint256 totalFrozen_,
        bool isMember_
    ) private pure returns (uint256) {
        if (isMember_) {
            if (userStaked == 0 || totalFrozen_ >= lockedStake || totalFrozen_ >= userStaked) {
                return memberRatio;
            }

            uint256 effectiveLockedAmount = lockedStake - totalFrozen_;
            uint256 effectiveStakeAmount = userStaked - totalFrozen_;

            uint256 lendingRatio = effectiveLockedAmount.wadDiv(effectiveStakeAmount);

            return lendingRatio + memberRatio;
        } else {
            return nonMemberRatio;
        }
    }
}",2909
RealWorld_BA_45_ControllerMock_RealWord_20240820175808.log,45,ControllerMock,3528,4436,7964,65.0,0.10636,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""../Controller.sol"";

contract ControllerMock is Controller {}",30
RealWorld_BA_45_IUErc20_RealWord_20240820183401.log,45,IUErc20,5184,5455,10639,84.0,0.13502,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol"";

interface IUErc20 is IERC20MetadataUpgradeable {
    function mint(address account, uint256 amount) external;

    function burn(address account, uint256 amount) external;

    function permit(
        address holder,
        address spender,
        uint256 nonce,
        uint256 expiry,
        bool allowed,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}",126
RealWorld_BA_45_CompoundAdapter_RealWord_20240820174422.log,45,CompoundAdapter,23050,6016,29066,93.0,0.23557,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;
pragma abicoder v1;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""../interfaces/IMoneyMarketAdapter.sol"";
import ""../Controller.sol"";

abstract contract CToken is IERC20Upgradeable {
    function supplyRatePerBlock() external view virtual returns (uint256);

    function mint(uint256 mintAmount) external virtual returns (uint256);

    function redeemUnderlying(uint256 redeemAmount) external virtual returns (uint256);

    function balanceOfUnderlying(address owner) external virtual returns (uint256);

    function exchangeRateStored() external view virtual returns (uint256);
}

/**
 * @title CompoundAdapter
 *  @dev The implementation of Compound.Finance MoneyMarket that integrates with AssetManager.
 */
contract CompoundAdapter is Controller, IMoneyMarketAdapter {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    mapping(address => address) public tokenToCToken;

    address public assetManager;
    mapping(address => uint256) public override floorMap;
    mapping(address => uint256) public override ceilingMap;

    modifier checkTokenSupported(address tokenAddress) {
        require(_supportsToken(tokenAddress), ""Token not supported"");
        _;
    }

    modifier onlyAssetManager() {
        require(msg.sender == assetManager, ""Only asset manager can call"");
        _;
    }

    function __CompoundAdapter_init(address _assetManager) public initializer {
        Controller.__Controller_init(msg.sender);
        assetManager = _assetManager;
    }

    function setAssetManager(address _assetManager) external onlyAdmin {
        assetManager = _assetManager;
    }

    function setFloor(address tokenAddress, uint256 floor) external onlyAdmin {
        floorMap[tokenAddress] = floor;
    }

    function setCeiling(address tokenAddress, uint256 ceiling) external onlyAdmin {
        ceilingMap[tokenAddress] = ceiling;
    }

    function mapTokenToCToken(address tokenAddress, address cTokenAddress) external onlyAdmin {
        tokenToCToken[tokenAddress] = cTokenAddress;
    }

    function getRate(address tokenAddress) external view override returns (uint256) {
        address cTokenAddress = tokenToCToken[tokenAddress];
        CToken cToken = CToken(cTokenAddress);

        return cToken.supplyRatePerBlock();
    }

    function deposit(address tokenAddress) external override checkTokenSupported(tokenAddress) {
        // get cToken
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        address cTokenAddress = tokenToCToken[tokenAddress];
        CToken cToken = CToken(cTokenAddress);
        uint256 amount = token.balanceOf(address(this));
        // mint cTokens
        token.safeApprove(cTokenAddress, 0);
        token.safeApprove(cTokenAddress, amount);
        uint256 result = cToken.mint(amount);
        require(result == 0, ""Error minting the cToken"");
    }

    function withdraw(
        address tokenAddress,
        address recipient,
        uint256 tokenAmount
    ) external override onlyAssetManager checkTokenSupported(tokenAddress) {
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        address cTokenAddress = tokenToCToken[tokenAddress];
        CToken cToken = CToken(cTokenAddress);

        uint256 result = cToken.redeemUnderlying(tokenAmount);
        require(result == 0, ""Error redeeming the cToken"");
        token.safeTransfer(recipient, tokenAmount);
    }

    function withdrawAll(address tokenAddress, address recipient)
        external
        override
        onlyAssetManager
        checkTokenSupported(tokenAddress)
    {
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        address cTokenAddress = tokenToCToken[tokenAddress];
        CToken cToken = CToken(cTokenAddress);

        uint256 result = cToken.redeemUnderlying(cToken.balanceOfUnderlying(address(this)));
        require(result == 0, ""Error redeeming the cToken"");
        token.safeTransfer(recipient, token.balanceOf(address(this)));
    }

    function claimTokens(address tokenAddress, address recipient) external override onlyAssetManager {
        _claimTokens(tokenAddress, recipient);
    }

    function getSupply(address tokenAddress) external override returns (uint256) {
        address cTokenAddress = tokenToCToken[tokenAddress];
        CToken cToken = CToken(cTokenAddress);

        // hack for preventing a rounding issue in `redeemUnderlying`
        if (cToken.balanceOf(address(this)) <= 10) {
            return 0;
        }

        return cToken.balanceOfUnderlying(address(this));
    }

    function getSupplyView(address tokenAddress) external view override returns (uint256) {
        address cTokenAddress = tokenToCToken[tokenAddress];
        CToken cToken = CToken(cTokenAddress);

        // hack for preventing a rounding issue in `redeemUnderlying`
        if (cToken.balanceOf(address(this)) <= 10) {
            return 0;
        }

        uint256 exchangeRate = cToken.exchangeRateStored();
        uint256 balance = cToken.balanceOf(address(this));
        return (balance * exchangeRate) / 10**18;
    }

    function supportsToken(address tokenAddress) external view override returns (bool) {
        return _supportsToken(tokenAddress);
    }

    function _supportsToken(address tokenAddress) internal view returns (bool) {
        address cTokenAddress = tokenToCToken[tokenAddress];

        return cTokenAddress != address(0);
    }

    function _claimTokens(address tokenAddress, address recipient) private {
        require(recipient != address(0), ""Recipient can not be zero"");
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        uint256 balance = token.balanceOf(address(this));
        token.safeTransfer(recipient, balance);
    }
}",1268
RealWorld_BA_45_AaveMock_RealWord_20240820175330.log,45,AaveMock,9734,5205,14939,82.0,0.15277,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";

interface IErc20 is IERC20Upgradeable {
    function mint(address account, uint256 amount) external;

    function burn(address account, uint256 amount) external;
}

contract AaveMock is Initializable {
    uint128 public rate;
    address public aToken;

    function __AaveMock_init(uint128 _rate, address _aToken) public initializer {
        rate = _rate;
        aToken = _aToken;
    }

    function getReserveData(address)
        external
        view
        returns (
            uint256,
            uint128,
            uint128,
            uint128,
            uint128,
            uint128,
            uint40,
            address,
            address,
            address,
            address,
            uint8
        )
    {
        return (0, 0, 0, rate, 0, 0, 0, aToken, address(0), address(0), address(0), 0);
    }

    function deposit(
        address asset,
        uint256 amount,
        address onBehalfOf,
        uint16
    ) external {
        IErc20(asset).transferFrom(onBehalfOf, address(this), amount);
        IErc20(aToken).mint(msg.sender, amount);
    }

    function withdraw(
        address asset,
        uint256 amount,
        address to
    ) external {
        uint256 userBalance = IErc20(aToken).balanceOf(msg.sender);
        uint256 amountToWithdraw = amount;
        if (amount == type(uint256).max) {
            amountToWithdraw = userBalance;
        }
        IErc20(aToken).burn(msg.sender, amountToWithdraw);
        IErc20(asset).transfer(to, amountToWithdraw);
    }
}",419
RealWorld_BA_45_AssetManagerMock_RealWord_20240820175632.log,45,AssetManagerMock,20079,5295,25374,94.0,0.206295,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;
pragma abicoder v1;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""../Controller.sol"";
import ""../interfaces/IMarketRegistry.sol"";
import ""../interfaces/IMoneyMarketAdapter.sol"";
import ""../interfaces/IAssetManager.sol"";

/**
 *  @title AssetManager
 *  @dev Manage the token assets deposited by components and admins, and invest tokens to the integrated underlying lending protocols.
 */
contract AssetManagerMock is Controller {
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using AddressUpgradeable for address;

    IMoneyMarketAdapter[] public moneyMarkets;
    mapping(address => Market) public supportedMarkets;
    address[] public supportedTokensList;
    //record admin or userManager balance
    mapping(address => mapping(address => uint256)) public balances; //1 user 2 token
    mapping(address => uint256) public totalPrincipal; //total stake amount
    address public marketRegistry;
    uint256[] public withdrawSeq; // Priority sequence of money market indices for processing withdraws

    struct Market {
        bool isSupported;
    }

    function __AssetManager_init() public initializer {}

    function getPoolBalance(address tokenAddress) public view returns (uint256) {
        IERC20Upgradeable poolToken = IERC20Upgradeable(tokenAddress);
        uint256 balance = poolToken.balanceOf(address(this));
        if (isMarketSupported(tokenAddress)) {
            return totalSupplyView(tokenAddress) + balance;
        } else {
            return balance;
        }
    }

    function getLoanableAmount(address tokenAddress) public view returns (uint256) {
        uint256 poolBalance = getPoolBalance(tokenAddress);
        if (poolBalance > totalPrincipal[tokenAddress]) return poolBalance - totalPrincipal[tokenAddress];
        return 0;
    }

    function totalSupply(address) public pure returns (uint256) {
        return 0;
    }

    function totalSupplyView(address) public pure returns (uint256) {
        return 0;
    }

    function isMarketSupported(address) public pure returns (bool) {
        return false;
    }

    function deposit(address token, uint256 amount) external returns (bool) {
        IERC20Upgradeable poolToken = IERC20Upgradeable(token);
        require(amount > 0, ""AssetManager: amount can not be zero"");

        if (!_isUToken(msg.sender, token)) {
            balances[msg.sender][token] += amount;
            totalPrincipal[token] += amount;
        }

        poolToken.safeTransferFrom(msg.sender, address(this), amount);

        return true;
    }

    function withdraw(
        address token,
        address account,
        uint256 amount
    ) external returns (bool) {
        uint256 remaining = amount;

        // If there are tokens in Asset Manager then transfer them on priority
        uint256 selfBalance = IERC20Upgradeable(token).balanceOf(address(this));
        if (selfBalance > 0) {
            uint256 withdrawAmount = selfBalance < remaining ? selfBalance : remaining;
            remaining -= withdrawAmount;
            IERC20Upgradeable(token).safeTransfer(account, withdrawAmount);
        }

        if (!_isUToken(msg.sender, token)) {
            balances[msg.sender][token] = balances[msg.sender][token] - amount + remaining;
            totalPrincipal[token] = totalPrincipal[token] - amount + remaining;
        }

        return true;
    }

    function debtWriteOff(address token, uint256 amount) external {}

    function addToken(address tokenAddress) external {
        supportedTokensList.push(tokenAddress);
        supportedMarkets[tokenAddress].isSupported = true;
    }

    /**
     *  @dev Claim the tokens left on AssetManager balance, in case there are tokens get stuck here.
     *  @param tokenAddress ERC20 token address
     *  @param recipient Recipient address
     */
    function claimTokens(address tokenAddress, address recipient) external {
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        uint256 balance = token.balanceOf(address(this));
        token.safeTransfer(recipient, balance);
    }

    function _checkSenderBalance(
        address sender,
        address tokenAddress,
        uint256 amount
    ) private view returns (bool) {
        if (_isUToken(sender, tokenAddress)) {
            // For all the lending markets, which have no deposits, return the tokens from the pool
            return getLoanableAmount(tokenAddress) >= amount;
        } else {
            return balances[sender][tokenAddress] >= amount;
        }
    }

    function _isUToken(address, address) private pure returns (bool) {
        return true;
    }

    function _isUserManager(address, address) private pure returns (bool) {
        return true;
    }
}",1078
RealWorld_BA_45_IUnionToken_RealWord_20240820182834.log,45,IUnionToken,10572,4989,15561,76.0,0.15264,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

/**
 * @title UnionToken Interface
 * @dev Mint and distribute UnionTokens.
 */
interface IUnionToken {
    /**
     *  @dev Get total supply
     *  @return Total supply
     */
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount) external returns (bool);

    function mint(address account, uint256 amount) external returns (bool);

    /**
     *  @dev Determine the prior number of votes for an account as of a block number. Block number must be a finalized block or else this function will revert to prevent misinformation.
     *  @param account The address of the account to check
     *  @param blockNumber The block number to get the vote balance at
     *  @return The number of votes the account had as of the given block
     */
    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint256);

    /**
     *  @dev Allows to spend owner's Union tokens by the specified spender.
     *  The function can be called by anyone, but requires having allowance parameters
     *  signed by the owner according to EIP712.
     *  @param owner The owner's address, cannot be zero address.
     *  @param spender The spender's address, cannot be zero address.
     *  @param value The allowance amount, in wei.
     *  @param deadline The allowance expiration date (unix timestamp in UTC).
     *  @param v A final byte of signature (ECDSA component).
     *  @param r The first 32 bytes of signature (ECDSA component).
     *  @param s The second 32 bytes of signature (ECDSA component).
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    function burnFrom(address account, uint256 amount) external;
}",448
RealWorld_BA_45_SumOfTrustMock_RealWord_20240820180733.log,45,SumOfTrustMock,17019,5496,22515,74.0,0.195015,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

contract SumOfTrustMock {
    struct LockedInfo {
        address staker;
        uint256 vouchingAmount;
        uint256 lockedAmount;
        uint256 availableStakingAmount;
    }

    bool public constant isCreditLimitModel = true;
    uint256 public effectiveNumber;

    constructor(uint256 effectiveNumber_) {
        effectiveNumber = effectiveNumber_;
    }

    function getCreditLimit(uint256[] memory vouchs) public view returns (uint256) {
        if (vouchs.length >= effectiveNumber) {
            uint256 limit;
            for (uint256 i = 0; i < vouchs.length; i++) {
                limit = limit + vouchs[i];
            }

            return limit;
        } else {
            return 0;
        }
    }

    function getLockedAmount(
        LockedInfo[] memory array,
        address account,
        uint256 amount,
        bool isIncrease
    ) public pure returns (uint256) {
        if (array.length == 0) return 0;

        uint256 remaining = amount;
        uint256 newLockedAmount;
        if (isIncrease) {
            array = _sortArray(array, true);
            for (uint256 i = 0; i < array.length; i++) {
                uint256 remainingVouchingAmount;
                if (array[i].vouchingAmount > array[i].lockedAmount) {
                    remainingVouchingAmount = array[i].vouchingAmount - array[i].lockedAmount;
                } else {
                    remainingVouchingAmount = 0;
                }

                if (remainingVouchingAmount > array[i].availableStakingAmount) {
                    if (array[i].availableStakingAmount > remaining) {
                        newLockedAmount = array[i].lockedAmount + remaining;
                        remaining = 0;
                    } else {
                        newLockedAmount = array[i].lockedAmount + array[i].availableStakingAmount;
                        remaining = remaining - array[i].availableStakingAmount;
                    }
                } else {
                    if (remainingVouchingAmount > remaining) {
                        newLockedAmount = array[i].lockedAmount + remaining;
                        remaining = 0;
                    } else {
                        newLockedAmount = array[i].lockedAmount + remainingVouchingAmount;
                        remaining -= remainingVouchingAmount;
                    }
                }

                if (account == array[i].staker) {
                    return newLockedAmount;
                }
            }
        } else {
            array = _sortArray(array, false);
            for (uint256 i = 0; i < array.length; i++) {
                if (array[i].lockedAmount > remaining) {
                    newLockedAmount = array[i].lockedAmount - remaining;
                    remaining = 0;
                } else {
                    newLockedAmount = 0;
                    remaining -= array[i].lockedAmount;
                }

                if (account == array[i].staker) {
                    return newLockedAmount;
                }
            }
        }

        return 0;
    }

    function setEffectNumber(uint256 number) external {
        effectiveNumber = number;
    }

    function _sortArray(LockedInfo[] memory arr, bool isPositive) private pure returns (LockedInfo[] memory) {
        uint256 l = arr.length;
        for (uint256 i = 0; i < l; i++) {
            for (uint256 j = i + 1; j < l; j++) {
                if (isPositive) {
                    if (arr[i].vouchingAmount < arr[j].vouchingAmount) {
                        LockedInfo memory temp = arr[j];
                        arr[j] = arr[i];
                        arr[i] = temp;
                    }
                } else {
                    if (arr[i].vouchingAmount > arr[j].vouchingAmount) {
                        LockedInfo memory temp = arr[j];
                        arr[j] = arr[i];
                        arr[i] = temp;
                    }
                }
            }
        }

        return arr;
    }
}",846
RealWorld_BA_45_ICreditLimitModel_RealWord_20240820182651.log,45,ICreditLimitModel,6841,5040,11881,101.0,0.135005,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

/**
 * @title CreditLimitModel Interface
 *  @dev Calculate the user's credit line based on the trust he receives from the vouchees.
 */
interface ICreditLimitModel {
    struct LockedInfo {
        address staker;
        uint256 vouchingAmount;
        uint256 lockedAmount;
        uint256 availableStakingAmount;
    }

    function isCreditLimitModel() external pure returns (bool);

    function effectiveNumber() external returns (uint256);

    /**
     * @notice Calculates the staker locked amount
     * @return Member credit limit
     */
    function getLockedAmount(
        LockedInfo[] calldata vouchAmountList,
        address staker,
        uint256 amount,
        bool isIncrease
    ) external pure returns (uint256);

    /**
     * @notice Calculates the member credit limit by vouchs
     * @return Member credit limit
     */
    function getCreditLimit(uint256[] calldata vouchs) external view returns (uint256);
}",227
RealWorld_BA_45_UserManager_RealWord_20240820181009.log,45,UserManager,114667,6350,121017,99.0,0.700335,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../Controller.sol"";
import ""../interfaces/IAssetManager.sol"";
import ""../interfaces/ICreditLimitModel.sol"";
import ""../interfaces/IUserManager.sol"";
import ""../interfaces/IComptroller.sol"";
import ""../interfaces/IUnionToken.sol"";
import ""../interfaces/IDai.sol"";
import ""../interfaces/IUToken.sol"";

/**
 * @title UserManager Contract
 * @dev Manages the Union members credit lines, and their vouchees and borrowers info.
 */
contract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    struct Member {
        bool isMember;
        CreditLine creditLine;
    }

    //address: member address, uint256: trustAmount
    struct CreditLine {
        mapping(address => uint256) borrowers;
        address[] borrowerAddresses;
        mapping(address => uint256) stakers;
        address[] stakerAddresses;
        mapping(address => uint256) lockedAmount;
    }

    struct TrustInfo {
        address[] stakerAddresses;
        address[] borrowerAddresses;
        uint256 effectiveCount;
        address staker;
        uint256 vouchingAmount;
        uint256 stakingAmount;
        uint256 availableStakingAmount;
        uint256 lockedStake;
        uint256 totalLockedStake;
    }

    uint256 public constant MAX_TRUST_LIMIT = 100;
    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;
    address public stakingToken;
    address public unionToken;
    address public assetManager;
    IUToken public uToken;
    ICreditLimitModel public creditLimitModel;
    IComptroller public comptroller;
    uint256 public newMemberFee; // New member application fee

    // slither-disable-next-line constable-states
    uint256 public override totalStaked;
    // slither-disable-next-line constable-states
    uint256 public override totalFrozen;
    mapping(address => Member) private members;
    // slither-disable-next-line uninitialized-state
    mapping(address => uint256) public stakers; //1 user address 2 amount
    mapping(address => uint256) public memberFrozen; //1 user address 2 frozen amount

    modifier onlyMember(address account) {
        require(checkIsMember(account), ""UserManager: caller does not have the Member role"");
        _;
    }

    modifier onlyMarketOrAdmin() {
        require(
            address(uToken) == msg.sender || isAdmin(msg.sender),
            ""UserManager: caller does not the market or admin""
        );
        _;
    }

    /**
     *  @dev Update new credit limit model event
     *  @param newCreditLimitModel New credit limit model address
     */
    event LogNewCreditLimitModel(address newCreditLimitModel);

    /**
     *  @dev Add new member event
     *  @param member New member address
     */
    event LogAddMember(address member);

    /**
     *  @dev Update vouch for existing member event
     *  @param staker Trustee address
     *  @param borrower The address gets vouched for
     *  @param trustAmount Vouch amount
     */
    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);

    /**
     *  @dev New member application event
     *  @param account New member's voucher address
     *  @param borrower New member address
     */
    event LogRegisterMember(address indexed account, address indexed borrower);

    /**
     *  @dev Cancel vouching for other member event
     *  @param account New member's voucher address
     *  @param borrower The address gets vouched for
     */
    event LogCancelVouch(address indexed account, address indexed borrower);

    /**
     *  @dev Stake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to stake
     */
    event LogStake(address indexed account, uint256 amount);

    /**
     *  @dev Unstake event
     *  @param account The staker's address
     *  @param amount The amount of tokens to unstake
     */
    event LogUnstake(address indexed account, uint256 amount);

    /**
     *  @dev DebtWriteOff event
     *  @param staker The staker's address
     *  @param borrower The borrower's address
     *  @param amount The amount of write off
     */
    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);

    function __UserManager_init(
        address assetManager_,
        address unionToken_,
        address stakingToken_,
        address creditLimitModel_,
        address comptroller_,
        address admin_
    ) public initializer {
        Controller.__Controller_init(admin_);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        _setCreditLimitModel(creditLimitModel_);
        comptroller = IComptroller(comptroller_);
        assetManager = assetManager_;
        unionToken = unionToken_;
        stakingToken = stakingToken_;
        newMemberFee = 10**18; // Set the default membership fee
    }

    function setUToken(address uToken_) public onlyAdmin {
        uToken = IUToken(uToken_);
    }

    function setNewMemberFee(uint256 amount) public onlyAdmin {
        newMemberFee = amount;
    }

    /**
     *  @dev Change the credit limit model
     *  Accept claims only from the admin
     *  @param newCreditLimitModel New credit limit model address
     */
    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {
        _setCreditLimitModel(newCreditLimitModel);
    }

    function _setCreditLimitModel(address newCreditLimitModel) private {
        require(
            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),
            ""MemberMnager: new model is not a creditLimitModel""
        );
        creditLimitModel = ICreditLimitModel(newCreditLimitModel);

        emit LogNewCreditLimitModel(newCreditLimitModel);
    }

    /**
     *  @dev Check if the account is a valid member
     *  @param account Member address
     *  @return Address whether is member
     */
    function checkIsMember(address account) public view override returns (bool) {
        return members[account].isMember;
    }

    /**
     *  @dev Get member borrowerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getBorrowerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.borrowerAddresses;
    }

    /**
     *  @dev Get member stakerAddresses
     *  @param account Member address
     *  @return Address array
     */
    function getStakerAddresses(address account) public view override returns (address[] memory) {
        return members[account].creditLine.stakerAddresses;
    }

    /**
     *  @dev Get member backer asset
     *  @param account Member address
     *  @param borrower Borrower address
     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount
     */
    function getBorrowerAsset(address account, address borrower)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.borrowers[borrower];
        lockedStake = getLockedStake(account, borrower);
        vouchingAmount = getVouchingAmount(account, borrower);
    }

    /**
     *  @dev Get member stakers asset
     *  @param account Member address
     *  @param staker Staker address
     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake
     */
    function getStakerAsset(address account, address staker)
        public
        view
        override
        returns (
            uint256 trustAmount,
            uint256 vouchingAmount,
            uint256 lockedStake
        )
    {
        trustAmount = members[account].creditLine.stakers[staker];
        lockedStake = getLockedStake(staker, account);
        vouchingAmount = getVouchingAmount(staker, account);
    }

    /**
     *  @dev Get staker locked stake for a borrower
     *  @param staker Staker address
     *  @param borrower Borrower address
     *  @return LockedStake
     */
    function getLockedStake(address staker, address borrower) public view returns (uint256) {
        return members[staker].creditLine.lockedAmount[borrower];
    }

    /**
     *  @dev Get the user's locked stake from all his backed loans
     *  @param staker Staker address
     *  @return LockedStake
     */
    function getTotalLockedStake(address staker) public view override returns (uint256) {
        uint256 totalLockedStake = 0;
        uint256 stakingAmount = stakers[staker];
        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        address borrower;
        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            borrower = borrowerAddresses[i];
            totalLockedStake += getLockedStake(staker, borrower);
        }

        if (stakingAmount >= totalLockedStake) {
            return totalLockedStake;
        } else {
            return stakingAmount;
        }
    }

    /**
     *  @dev Get staker's defaulted / frozen staked token amount
     *  @param staker Staker address
     *  @return Frozen token amount
     */
    function getTotalFrozenAmount(address staker) public view override returns (uint256) {
        TrustInfo memory trustInfo;
        uint256 totalFrozenAmount = 0;
        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;
        trustInfo.stakingAmount = stakers[staker];

        address borrower;
        for (uint256 i = 0; i < trustInfo.borrowerAddresses.length; i++) {
            borrower = trustInfo.borrowerAddresses[i];
            if (uToken.checkIsOverdue(borrower)) {
                totalFrozenAmount += getLockedStake(staker, borrower);
            }
        }

        if (trustInfo.stakingAmount >= totalFrozenAmount) {
            return totalFrozenAmount;
        } else {
            return trustInfo.stakingAmount;
        }
    }

    /**
     *  @dev Get the member's available credit line
     *  @param borrower Member address
     *  @return Credit line amount
     */
    function getCreditLimit(address borrower) public view override returns (int256) {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        // Get the number of effective vouchee, first
        trustInfo.effectiveCount = 0;
        uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            trustInfo.staker = trustInfo.stakerAddresses[i];

            trustInfo.stakingAmount = stakers[trustInfo.staker];

            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit
            if (trustInfo.vouchingAmount > 0) {
                //availableStakingAmount is stakers free stake amount
                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);

                trustInfo.availableStakingAmount = trustInfo.stakingAmount;
                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);
                if (trustInfo.stakingAmount <= totalLockedStake) {
                    trustInfo.availableStakingAmount = 0;
                } else {
                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;
                }

                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);

                require(
                    trustInfo.vouchingAmount >= trustInfo.lockedStake,
                    ""UserManager: vouchingAmount or lockedStake data error""
                );

                //The actual effective guarantee amount cannot exceed availableStakingAmount,
                if (trustInfo.vouchingAmount >= trustInfo.availableStakingAmount + trustInfo.lockedStake) {
                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;
                } else {
                    if (trustInfo.vouchingAmount <= trustInfo.lockedStake) {
                        limits[trustInfo.effectiveCount] = 0;
                    } else {
                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;
                    }
                }
                trustInfo.effectiveCount += 1;
            }
        }

        uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);
        for (uint256 j = 0; j < trustInfo.effectiveCount; j++) {
            creditlimits[j] = limits[j];
        }

        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));
    }

    /**
     *  @dev Get vouching amount
     *  @param staker Staker address
     *  @param borrower Borrower address
     */
    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {
        uint256 totalStake = stakers[staker];
        uint256 trustAmount = members[borrower].creditLine.stakers[staker];
        if (trustAmount > totalStake) {
            return totalStake;
        } else {
            return trustAmount;
        }
    }

    /**
     *  @dev Get the user's deposited stake amount
     *  @param account Member address
     *  @return Deposited stake amount
     */
    function getStakerBalance(address account) public view override returns (uint256) {
        return stakers[account];
    }

    /**
     *  @dev Add member
     *  Accept claims only from the admin
     *  @param account Member address
     */
    function addMember(address account) public override onlyAdmin {
        require(!checkIsMember(account), ""UserManager: address is already member"");
        members[account].isMember = true;
        emit LogAddMember(account);
    }

    /**
     *  @dev Update the trust amount for exisitng members.
     *  @param borrower_ Account address
     *  @param trustAmount Trust amount
     */
    function updateTrust(address borrower_, uint256 trustAmount)
        external
        override
        onlyMember(msg.sender)
        whenNotPaused
    {
        require(borrower_ != address(0), ""borrower cannot be zero"");
        address borrower = borrower_;

        TrustInfo memory trustInfo;
        trustInfo.staker = msg.sender;
        require(trustInfo.staker != borrower, ""UserManager: Can't vouch for self"");
        require(
            members[borrower].creditLine.stakerAddresses.length < MAX_TRUST_LIMIT &&
                members[trustInfo.staker].creditLine.borrowerAddresses.length < MAX_TRUST_LIMIT,
            ""UserManager: trust reach limit""
        );
        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;
        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);
        require(
            trustAmount >= trustInfo.lockedStake,
            ""UserManager: trust amount cannot be less than the locked amount ""
        );
        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (trustInfo.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
            }
        }

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {
                stakerExist = true;
            }
        }

        if (!borrowerExist) {
            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);
        }

        if (!stakerExist) {
            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);
        }

        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;
        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;
        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);
    }

    /**
     *  @dev Stop vouch for other member.
     *  @param staker Staker address
     *  @param borrower borrower address
     */
    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {
        require(
            msg.sender == staker || msg.sender == borrower,
            ""UserManager: Accept claims only from the staker or borrower""
        );

        require(getLockedStake(staker, borrower) == 0, ""UserManager: LockedStake is not zero"");

        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;
        bool stakerExist = false;
        uint256 stakerIndex = 0;
        for (uint256 i = 0; i < stakerCount; i++) {
            if (members[borrower].creditLine.stakerAddresses[i] == staker) {
                stakerExist = true;
                stakerIndex = i;
            }
        }

        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;
        bool borrowerExist = false;
        uint256 borrowerIndex = 0;
        for (uint256 i = 0; i < borrowerCount; i++) {
            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {
                borrowerExist = true;
                borrowerIndex = i;
            }
        }

        //delete address
        if (borrowerExist) {
            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[
                borrowerCount - 1
            ];
            members[staker].creditLine.borrowerAddresses.pop();
        }

        if (stakerExist) {
            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[
                stakerCount - 1
            ];
            members[borrower].creditLine.stakerAddresses.pop();
        }

        delete members[staker].creditLine.borrowers[borrower];
        delete members[borrower].creditLine.stakers[staker];

        emit LogCancelVouch(staker, borrower);
    }

    function registerMemberWithPermit(
        address newMember,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);
        registerMember(newMember);
    }

    /**
     *  @dev Apply for membership, and burn UnionToken as application fees
     *  @param newMember New member address
     */
    function registerMember(address newMember) public override whenNotPaused {
        IUnionToken unionTokenContract = IUnionToken(unionToken);
        require(!checkIsMember(newMember), ""UserManager: address is already member"");
        require(unionTokenContract.balanceOf(msg.sender) >= newMemberFee, ""UserManager: balance not enough"");

        uint256 effectiveStakerNumber = 0;
        for (uint256 i = 0; i < members[newMember].creditLine.stakerAddresses.length; i++) {
            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];
            if (checkIsMember(stakerAddress) && getVouchingAmount(stakerAddress, newMember) > 0)
                effectiveStakerNumber += 1;
        }

        require(
            effectiveStakerNumber >= creditLimitModel.effectiveNumber(),
            ""UserManager: not enough effective stakers""
        );

        members[newMember].isMember = true;

        unionTokenContract.burnFrom(msg.sender, newMemberFee);

        emit LogRegisterMember(msg.sender, newMember);
    }

    function updateLockedData(
        address borrower,
        uint256 amount,
        bool isBorrow
    ) external override onlyMarketOrAdmin {
        TrustInfo memory trustInfo;
        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;

        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](
            trustInfo.stakerAddresses.length
        );

        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {
            ICreditLimitModel.LockedInfo memory lockedInfo;

            trustInfo.staker = trustInfo.stakerAddresses[i];
            trustInfo.stakingAmount = stakers[trustInfo.staker];
            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);

            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);
            if (trustInfo.stakingAmount <= trustInfo.totalLockedStake) {
                trustInfo.availableStakingAmount = 0;
            } else {
                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;
            }

            lockedInfo.staker = trustInfo.staker;
            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;
            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);
            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;

            lockedInfoList[i] = lockedInfo;
        }

        for (uint256 i = 0; i < lockedInfoList.length; i++) {
            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(
                lockedInfoList,
                lockedInfoList[i].staker,
                amount,
                isBorrow
            );
        }
    }

    /**
     *  @dev Stake
     *  @param amount Amount
     */
    function stake(uint256 amount) public override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);

        comptroller.withdrawRewards(msg.sender, stakingToken);

        uint256 balance = stakers[msg.sender];

        require(balance + amount <= MAX_STAKE_AMOUNT, ""UserManager: Stake limit hit"");

        stakers[msg.sender] = balance + amount;
        totalStaked += amount;

        require(
            erc20Token.allowance(msg.sender, address(this)) >= amount,
            ""UserManager: not enough allowance to stake""
        );
        erc20Token.safeTransferFrom(msg.sender, address(this), amount);
        erc20Token.safeApprove(assetManager, 0);
        erc20Token.safeApprove(assetManager, amount);

        require(IAssetManager(assetManager).deposit(stakingToken, amount), ""UserManager: Deposit failed"");

        emit LogStake(msg.sender, amount);
    }

    /**
     *  @dev stakeWithPermit
     *  @param amount Amount
     */
    function stakeWithPermit(
        uint256 amount,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IDai erc20Token = IDai(stakingToken);
        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);

        stake(amount);
    }

    /**
     *  @dev Unstake
     *  @param amount Amount
     */
    function unstake(uint256 amount) external override whenNotPaused nonReentrant {
        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);
        uint256 stakingAmount = stakers[msg.sender];
        require(
            stakingAmount - getTotalLockedStake(msg.sender) >= amount,
            ""UserManager: unstake balance is insufficient""
        );

        comptroller.withdrawRewards(msg.sender, stakingToken);

        stakers[msg.sender] = stakingAmount - amount;
        totalStaked -= amount;

        require(
            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),
            ""UserManager: withdraw failed""
        );

        erc20Token.safeTransfer(msg.sender, amount);

        emit LogUnstake(msg.sender, amount);
    }

    function withdrawRewards() external whenNotPaused nonReentrant {
        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);
        require(rewards > 0, ""UserManager: not enough rewards"");
    }

    /**
     *  @dev Repay user's loan overdue, called only from the lending market
     *  @param account User address
     *  @param token The asset token repaying to
     *  @param lastRepay Last repay block number
     */
    function repayLoanOverdue(
        address account,
        address token,
        uint256 lastRepay
    ) external override whenNotPaused onlyMarketOrAdmin {
        address[] memory stakerAddresses = getStakerAddresses(account);
        for (uint256 i = 0; i < stakerAddresses.length; i++) {
            address staker = stakerAddresses[i];
            (, , uint256 lockedStake) = getStakerAsset(account, staker);

            comptroller.addFrozenCoinAge(staker, token, lockedStake, lastRepay);
        }
    }

    //Only supports sumOfTrust
    function debtWriteOff(address borrower, uint256 amount) public {
        require(amount > 0, ""UserManager: amount can not be zero"");
        require(totalStaked >= amount, ""UserManager: amount exceeds the totalStaked"");
        require(uToken.checkIsOverdue(borrower), ""UserManager: only call when borrower is overdue"");
        uint256 lockedAmount = getLockedStake(msg.sender, borrower);
        require(lockedAmount >= amount, ""UserManager: amount exceeds the locked amount"");

        _updateTotalFrozen(borrower, true);
        require(totalFrozen >= amount, ""UserManager: amount exceeds the totalFrozen"");
        comptroller.withdrawRewards(msg.sender, stakingToken);

        //The borrower is still overdue, do not call comptroller.addFrozenCoinAge

        stakers[msg.sender] -= amount;
        totalStaked -= amount;
        totalFrozen -= amount;
        if (memberFrozen[borrower] >= amount) {
            memberFrozen[borrower] -= amount;
        } else {
            memberFrozen[borrower] = 0;
        }
        members[msg.sender].creditLine.lockedAmount[borrower] = lockedAmount - amount;
        uint256 trustAmount = members[msg.sender].creditLine.borrowers[borrower];
        uint256 newTrustAmount = trustAmount - amount;
        members[msg.sender].creditLine.borrowers[borrower] = newTrustAmount;
        members[borrower].creditLine.stakers[msg.sender] = newTrustAmount;
        IAssetManager(assetManager).debtWriteOff(stakingToken, amount);
        uToken.debtWriteOff(borrower, amount);
        emit LogDebtWriteOff(msg.sender, borrower, amount);
    }

    /**
     *  @dev Update total frozen
     *  @param account borrower address
     *  @param isOverdue account is overdue
     */
    function updateTotalFrozen(address account, bool isOverdue) external override onlyMarketOrAdmin whenNotPaused {
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        _updateTotalFrozen(account, isOverdue);
    }

    function batchUpdateTotalFrozen(address[] calldata accounts, bool[] calldata isOverdues)
        external
        override
        onlyMarketOrAdmin
        whenNotPaused
    {
        require(accounts.length == isOverdues.length, ""UserManager: params length error"");
        require(totalStaked >= totalFrozen, ""UserManager: total stake amount error"");
        uint256 effectiveTotalStaked = totalStaked - totalFrozen;
        comptroller.updateTotalStaked(stakingToken, effectiveTotalStaked);
        for (uint256 i = 0; i < accounts.length; i++) {
            if (accounts[i] != address(0)) _updateTotalFrozen(accounts[i], isOverdues[i]);
        }
    }

    function _updateTotalFrozen(address account, bool isOverdue) private {
        if (isOverdue) {
            //isOverdue = true, user overdue needs to increase totalFrozen

            //The sum of the locked amount of all stakers on this borrower, which is the frozen amount that needs to be updated
            uint256 amount;
            for (uint256 i = 0; i < members[account].creditLine.stakerAddresses.length; i++) {
                address staker = members[account].creditLine.stakerAddresses[i];
                uint256 lockedStake = getLockedStake(staker, account);
                amount += lockedStake;
            }

            if (memberFrozen[account] == 0) {
                //I havent updated the frozen amount about this borrower before, just increase the amount directly
                totalFrozen += amount;
            } else {
                //I have updated the frozen amount of this borrower before. After increasing the amount, subtract the previously increased value to avoid repeated additions.
                totalFrozen = totalFrozen + amount - memberFrozen[account];
            }
            //Record the increased value of this borrower this time
            memberFrozen[account] = amount;
        } else {
            //isOverdue = false, the user loan needs to reduce the number of frozen last time to return to normal
            if (totalFrozen > memberFrozen[account]) {
                //Minus the frozen amount added last time
                totalFrozen -= memberFrozen[account];
            } else {
                totalFrozen = 0;
            }
            memberFrozen[account] = 0;
        }
    }

    function getFrozenCoinAge(address staker, uint256 pastBlocks) public view override returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * blocks);
                } else {
                    totalFrozenCoinAge = totalFrozenCoinAge + (lockedStake * pastBlocks);
                }
            }
        }

        return totalFrozenCoinAge;
    }

    function _getFrozenCoinAge(address staker, uint256 pastBlocks) private view returns (uint256) {
        uint256 totalFrozenCoinAge = 0;

        address[] memory borrowerAddresses = getBorrowerAddresses(staker);

        for (uint256 i = 0; i < borrowerAddresses.length; i++) {
            address borrower = borrowerAddresses[i];
            uint256 blocks = block.number - uToken.getLastRepay(borrower);
            if (uToken.checkIsOverdue(borrower)) {
                (, , uint256 lockedStake) = getStakerAsset(borrower, staker);

                if (pastBlocks >= blocks) {
                    totalFrozenCoinAge += lockedStake * blocks;
                } else {
                    totalFrozenCoinAge += lockedStake * pastBlocks;
                }
            }
        }

        return totalFrozenCoinAge;
    }
}",7100
RealWorld_BA_45_IInterestRateModel_RealWord_20240820182533.log,45,IInterestRateModel,7103,4896,11999,76.0,0.133435,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

/**
 * @title InterestRateModel Interface
 *  @dev Calculate the borrowers' interest rate.
 */
interface IInterestRateModel {
    /**
     * @dev Check to see if it is a valid interest rate model
     * @return Return true for a valid interest rate model
     */
    function isInterestRateModel() external pure returns (bool);

    /**
     * @dev Calculates the current borrow interest rate per block
     * @return The borrow rate per block (as a percentage, and scaled by 1e18)
     */
    function getBorrowRate() external view returns (uint256);

    /**
     * @dev Calculates the current suppier interest rate per block
     * @return The supply rate per block (as a percentage, and scaled by 1e18)
     */
    function getSupplyRate(uint256 reserveFactorMantissa) external view returns (uint256);

    /**
     * @dev Set the borrow interest rate per block
     */
    function setInterestRate(uint256 interestRatePerBlock_) external;
}",236
RealWorld_BA_45_FaucetERC20_RealWord_20240820180444.log,45,FaucetERC20,12889,5747,18636,90.0,0.179385,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";

contract FaucetERC20 is Initializable, ERC20Upgradeable {
    string public constant version = ""1"";

    // --- EIP712 niceties ---
    bytes32 public DOMAIN_SEPARATOR;
    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;

    mapping(address => uint256) public nonces;

    function __FaucetERC20_init(string memory name, string memory symbol) public initializer {
        ERC20Upgradeable.__ERC20_init(name, symbol);

        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
                keccak256(bytes(name)),
                keccak256(bytes(version)),
                getChainId(),
                address(this)
            )
        );
    }

    receive() external payable {
        mint(msg.sender, 1 ether);
    }

    function mint(address to, uint256 value) public returns (bool) {
        // require(value <= 10000000 ether, ""dont be greedy"");
        _mint(to, value);
        return true;
    }

    function burn(address to, uint256 value) public returns (bool) {
        // require(value <= 10000000 ether, ""dont be greedy"");
        _burn(to, value);
        return true;
    }

    function permit(
        address holder,
        address spender,
        uint256 nonce,
        uint256 expiry,
        bool allowed,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        bytes32 digest = keccak256(
            abi.encodePacked(
                ""\x19\x01"",
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(PERMIT_TYPEHASH, holder, spender, nonce, expiry, allowed))
            )
        );

        require(holder != address(0), ""invalid-address-0"");
        require(holder == ecrecover(digest, v, r, s), ""invalid-permit"");
        require(expiry == 0 || block.timestamp <= expiry, ""permit-expired"");
        require(nonce == nonces[holder]++, ""invalid-nonce"");
        uint256 wad = allowed ? type(uint256).max : 0;
        _approve(holder, spender, wad);
    }

    function getChainId() internal view returns (uint256) {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        return chainId;
    }
}",595
RealWorld_BA_45_UnionTokenMock_RealWord_20240820175152.log,45,UnionTokenMock,13049,5945,18994,96.0,0.184145,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/token/ERC20/extensions/ERC20VotesComp.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"";

/**
 * @title UnionToken Contract
 * @dev Mint and distribute UnionTokens.
 */
contract UnionTokenMock is ERC20VotesComp, ERC20Burnable {
    //The EIP-712 typehash for the contract's domain
    bytes32 public constant DOMAIN_TYPEHASH =
        keccak256(""EIP712Domain(string name,uint256 chainId,address verifyingContract)"");

    //The EIP-712 typehash for the delegation struct used by the contract
    bytes32 public constant DELEGATION_TYPEHASH =
        keccak256(""Delegation(address delegatee,uint256 nonce,uint256 expiry)"");

    bytes32 public constant PERMIT_TYPEHASH =
        keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");

    /// @notice Minimum time between mints
    uint256 public constant minimumTimeBetweenMints = 1 days * 365;

    /// @notice The timestamp after which minting may occur
    uint256 public mintingAllowedAfter;

    uint256 public constant INIT_CIRCULATING = 100000000 * 10**18;

    /// @notice Cap on the percentage of totalSupply that can be minted at each mint
    uint256 public constant mintCap = 4;

    constructor(string memory name, string memory symbol) ERC20(name, symbol) ERC20Permit(name) {
        if (balanceOf(msg.sender) == 0) {
            _mint(msg.sender, INIT_CIRCULATING);
        }
    }

    function mint(address dst, uint256 amount) external returns (bool) {
        require(amount <= (totalSupply() * mintCap) / 100, ""exceeded mint cap"");

        _mint(dst, amount);

        return true;
    }

    function _mint(address account, uint256 amount) internal override(ERC20, ERC20Votes) {
        super._mint(account, amount);
        require(block.timestamp >= mintingAllowedAfter, ""minting not allowed yet"");

        // record the mint
        mintingAllowedAfter = minimumTimeBetweenMints + block.timestamp;
    }

    function _burn(address account, uint256 amount) internal override(ERC20, ERC20Votes) {
        super._burn(account, amount);
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        super._beforeTokenTransfer(from, to, amount);
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override(ERC20, ERC20Votes) {
        super._afterTokenTransfer(from, to, amount);
    }
}",604
RealWorld_BA_45_IMoneyMarketAdapter_RealWord_20240820183932.log,45,IMoneyMarketAdapter,10581,4983,15564,89.0,0.152565,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

/**
 * @title MoneyMarketAdapter Interface
 *  @dev Working with AssetManager to support external money markets, like Compound etc.
 */
interface IMoneyMarketAdapter {
    /**
     * @dev Returns the interest rate per block for the given token.
     */
    function getRate(address tokenAddress) external view returns (uint256);

    /**
     * @dev Deposits the given amount of tokens in the underlying money market.
     */
    function deposit(address tokenAddress) external;

    /**
     * @dev Withdraws the given amount of tokens from the underlying money market and transfers them to `recipient`.
     */
    function withdraw(
        address tokenAddress,
        address recipient,
        uint256 amount
    ) external;

    /**
     * @dev Withdraws all the tokens from the underlying money market and transfers them to `recipient`.
     */
    function withdrawAll(address tokenAddress, address recipient) external;

    function claimTokens(address tokenAddress, address recipient) external;

    /**
     * @dev Returns the supply for the given token, including accrued interest. This function can have side effects.
     */
    function getSupply(address tokenAddress) external returns (uint256);

    /**
     * @dev Returns the supply for the given token; it might not include accrued interest. This function *cannot* have side effects.
     */
    function getSupplyView(address tokenAddress) external view returns (uint256);

    /**
     * @dev Indicates if the adapter supports the token with the given address.
     */
    function supportsToken(address tokenAddress) external view returns (bool);

    /**
     * @dev The minimum amount that should be deposited in money market before moving to next priority market
     * @param tokenAddress The address of token whose floor is being fetched
     */
    function floorMap(address tokenAddress) external view returns (uint256);

    /**
     * @dev The maximum amount that should be deposited in money market
     * @param tokenAddress The address of token whose ceiling is being fetched
     */
    function ceilingMap(address tokenAddress) external view returns (uint256);
}",447
RealWorld_BA_45_MarketRegistry_RealWord_20240820181930.log,45,MarketRegistry,14160,5206,19366,76.0,0.17492,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""../Controller.sol"";

/**
 * @title MarketRegistry Contract
 * @dev Registering and managing all the lending markets.
 */
contract MarketRegistry is Controller {
    struct Market {
        address uToken;
        address userManager;
    }

    address[] public uTokenList;
    address[] public userManagerList;
    mapping(address => Market) public tokens;

    event LogAddUToken(address indexed tokenAddress, address contractAddress);

    event LogAddUserManager(address indexed tokenAddress, address contractAddress);

    modifier newToken(address token) {
        require(tokens[token].uToken == address(0), ""MarketRegistry: has already exist this uToken"");
        _;
    }

    modifier newUserManager(address token) {
        require(tokens[token].userManager == address(0), ""MarketRegistry: has already exist this userManager"");
        _;
    }

    /**
     *  @dev Initialization function
     */
    function __MarketRegistry_init() public initializer {
        Controller.__Controller_init(msg.sender);
    }

    /**
     *  @dev Retrieves the value of the state variable `uTokenList`
     *  @return Stored uToken address
     */
    function getUTokens() public view returns (address[] memory) {
        return uTokenList;
    }

    function getUserManagers() public view returns (address[] memory) {
        return userManagerList;
    }

    function addUToken(address token, address uToken) public newToken(token) onlyAdmin {
        uTokenList.push(uToken);
        tokens[token].uToken = uToken;
        emit LogAddUToken(token, uToken);
    }

    function addUserManager(address token, address userManager) public newUserManager(token) onlyAdmin {
        userManagerList.push(userManager);
        tokens[token].userManager = userManager;
        emit LogAddUserManager(token, userManager);
    }

    function deleteMarket(address token) public onlyAdmin {
        address oldUToken = tokens[token].uToken;
        bool uTokenExist = false;
        uint256 uTokenIndex = 0;

        for (uint256 i = 0; i < uTokenList.length; i++) {
            if (oldUToken == uTokenList[i]) {
                uTokenExist = true;
                uTokenIndex = i;
            }
        }

        if (uTokenExist) {
            uTokenList[uTokenIndex] = uTokenList[uTokenList.length - 1];
            uTokenList.pop();
        }

        delete tokens[token].uToken;

        address oldUserManager = tokens[token].userManager;
        bool userManagerExist = false;
        uint256 userManagerIndex = 0;

        for (uint256 i = 0; i < userManagerList.length; i++) {
            if (oldUserManager == userManagerList[i]) {
                userManagerExist = true;
                userManagerIndex = i;
            }
        }

        if (userManagerExist) {
            userManagerList[userManagerIndex] = userManagerList[userManagerList.length - 1];
            userManagerList.pop();
        }

        delete tokens[token].userManager;
    }
}",646
RealWorld_BA_45_AssetManager_RealWord_20240820174557.log,45,AssetManager,67955,5609,73564,99.0,0.451955,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;
pragma abicoder v1;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""../Controller.sol"";
import ""../interfaces/IMarketRegistry.sol"";
import ""../interfaces/IMoneyMarketAdapter.sol"";
import ""../interfaces/IAssetManager.sol"";

/**
 *  @title AssetManager
 *  @dev Manage the token assets deposited by components and admins, and invest tokens to the integrated underlying lending protocols.
 */
contract AssetManager is Controller, ReentrancyGuardUpgradeable, IAssetManager {
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using AddressUpgradeable for address;

    IMoneyMarketAdapter[] public moneyMarkets;
    mapping(address => Market) public supportedMarkets;
    address[] public supportedTokensList;
    //record admin or userManager balance
    mapping(address => mapping(address => uint256)) public balances; //1 user 2 token
    mapping(address => uint256) public totalPrincipal; //total stake amount
    address public marketRegistry;
    // slither-disable-next-line uninitialized-state
    uint256[] public withdrawSeq; // Priority sequence of money market indices for processing withdraws

    struct Market {
        bool isSupported;
    }

    modifier checkMarketSupported(address token) {
        require(isMarketSupported(token), ""AssetManager: token not support"");
        _;
    }

    modifier onlyAuth(address token) {
        require(
            _isUToken(msg.sender, token) || _isUserManager(msg.sender, token),
            ""AssetManager: sender must uToken or userManager""
        );
        _;
    }

    /**
     *  @dev Emit when making a deposit
     *  @param token Depositing token address
     *  @param account Account address
     *  @param amount Deposit amount, in wei
     */
    event LogDeposit(address indexed token, address indexed account, uint256 amount);
    /**
     *  @dev Emit when withdrawing from AssetManager
     *  @param token Depositing token address
     *  @param account Account address
     *  @param amount Withdraw amount, in wei
     *  @param remaining The amount cannot be withdrawn
     */
    event LogWithdraw(address indexed token, address indexed account, uint256 amount, uint256 remaining);
    /**
     *  @dev Emit when rebalancing among the integrated money markets
     *  @param tokenAddress The address of the token to be rebalanced
     *  @param percentages Array of the percentages of the tokens to deposit to the money markets
     */
    event LogRebalance(address tokenAddress, uint256[] percentages);

    function __AssetManager_init(address _marketRegistry) public initializer {
        Controller.__Controller_init(msg.sender);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        marketRegistry = _marketRegistry;
    }

    function setMarketRegistry(address _marketRegistry) external onlyAdmin {
        marketRegistry = _marketRegistry;
    }

    /**
     *  @dev Get the balance of asset manager, plus the total amount of tokens deposited to all the underlying lending protocols
     *  @param tokenAddress ERC20 token address
     *  @return Pool balance
     */
    function getPoolBalance(address tokenAddress) public view override returns (uint256) {
        IERC20Upgradeable poolToken = IERC20Upgradeable(tokenAddress);
        uint256 balance = poolToken.balanceOf(address(this));
        if (isMarketSupported(tokenAddress)) {
            return totalSupplyView(tokenAddress) + balance;
        } else {
            return balance;
        }
    }

    /**
     *  @dev Returns the amount of the lending pool balance minus the amount of total staked.
     *  @param tokenAddress ERC20 token address
     *  @return Amount can be borrowed
     */
    function getLoanableAmount(address tokenAddress) public view override returns (uint256) {
        uint256 poolBalance = getPoolBalance(tokenAddress);
        if (poolBalance > totalPrincipal[tokenAddress]) return poolBalance - totalPrincipal[tokenAddress];
        return 0;
    }

    /**
     *  @dev Get the total amount of tokens deposited to all the integrated underlying protocols without side effects.
     *  @param tokenAddress ERC20 token address
     *  @return Total market balance
     */
    function totalSupply(address tokenAddress) public override returns (uint256) {
        if (isMarketSupported(tokenAddress)) {
            uint256 tokenSupply = 0;
            for (uint256 i = 0; i < moneyMarkets.length; i++) {
                if (!moneyMarkets[i].supportsToken(tokenAddress)) {
                    continue;
                }
                tokenSupply += moneyMarkets[i].getSupply(tokenAddress);
            }

            return tokenSupply;
        } else {
            return 0;
        }
    }

    /**
     *  @dev Get the total amount of tokens deposited to all the integrated underlying protocols, but without side effects. Safe to call anytime, but may not get the most updated number for the current block. Call totalSupply() for that purpose.
     *  @param tokenAddress ERC20 token address
     *  @return Total market balance
     */
    function totalSupplyView(address tokenAddress) public view override returns (uint256) {
        if (isMarketSupported(tokenAddress)) {
            uint256 tokenSupply = 0;
            for (uint256 i = 0; i < moneyMarkets.length; i++) {
                if (!moneyMarkets[i].supportsToken(tokenAddress)) {
                    continue;
                }
                tokenSupply += moneyMarkets[i].getSupplyView(tokenAddress);
            }

            return tokenSupply;
        } else {
            return 0;
        }
    }

    /**
     *  @dev Check if there is an underlying protocol available for the given ERC20 token.
     *  @param tokenAddress ERC20 token address
     *  @return Whether is supported
     */
    function isMarketSupported(address tokenAddress) public view override returns (bool) {
        return supportedMarkets[tokenAddress].isSupported;
    }

    /**
     *  @dev Deposit tokens to AssetManager, and those tokens will be passed along to adapters to deposit to integrated asset protocols if any is available.
     *  @param token ERC20 token address
     *  @param amount ERC20 token address
     *  @return Deposited amount
     */
    function deposit(address token, uint256 amount)
        external
        override
        whenNotPaused
        onlyAuth(token)
        nonReentrant
        returns (bool)
    {
        IERC20Upgradeable poolToken = IERC20Upgradeable(token);
        require(amount > 0, ""AssetManager: amount can not be zero"");

        if (!_isUToken(msg.sender, token)) {
            balances[msg.sender][token] += amount;
            totalPrincipal[token] += amount;
        }

        bool remaining = true;
        if (isMarketSupported(token)) {
            // assumption: markets are arranged in order of decreasing liquidity
            // iterate markets till floors are filled
            // floors define minimum amount to maintain confidence in liquidity
            for (uint256 i = 0; i < moneyMarkets.length && remaining; i++) {
                IMoneyMarketAdapter moneyMarket = moneyMarkets[i];

                if (!moneyMarket.supportsToken(token)) continue;
                if (moneyMarket.floorMap(token) <= moneyMarket.getSupply(token)) continue;

                poolToken.safeTransferFrom(msg.sender, address(moneyMarket), amount);
                moneyMarket.deposit(token);
                remaining = false;
            }

            // assumption: less liquid markets provide more yield
            // iterate markets in reverse to optimize for yield
            // do this only if floors are filled i.e. min liquidity satisfied
            // dposit in the market where ceiling is not being exceeded
            for (uint256 j = moneyMarkets.length; j > 0 && remaining; j--) {
                IMoneyMarketAdapter moneyMarket = moneyMarkets[j - 1];
                if (!moneyMarket.supportsToken(token)) continue;

                uint256 supply = moneyMarket.getSupply(token);
                uint256 ceiling = moneyMarket.ceilingMap(token);
                if (ceiling <= supply) continue;
                if (supply + amount > ceiling) continue;

                poolToken.safeTransferFrom(msg.sender, address(moneyMarket), amount);
                moneyMarket.deposit(token);
                remaining = false;
            }
        }

        if (remaining) {
            poolToken.safeTransferFrom(msg.sender, address(this), amount);
        }

        emit LogDeposit(token, msg.sender, amount);

        return true;
    }

    /**
     *  @dev Withdraw from AssetManager
     *  @param token ERC20 token address
     *  @param account User address
     *  @param amount ERC20 token address
     *  @return Withdraw amount
     */
    function withdraw(
        address token,
        address account,
        uint256 amount
    ) external override whenNotPaused nonReentrant onlyAuth(token) returns (bool) {
        require(_checkSenderBalance(msg.sender, token, amount), ""AssetManager: balance not enough to withdraw"");

        uint256 remaining = amount;

        // If there are tokens in Asset Manager then transfer them on priority
        uint256 selfBalance = IERC20Upgradeable(token).balanceOf(address(this));
        if (selfBalance > 0) {
            uint256 withdrawAmount = selfBalance < remaining ? selfBalance : remaining;
            remaining -= withdrawAmount;
            IERC20Upgradeable(token).safeTransfer(account, withdrawAmount);
        }

        if (isMarketSupported(token)) {
            // iterate markets according to defined sequence and withdraw
            for (uint256 i = 0; i < withdrawSeq.length && remaining > 0; i++) {
                IMoneyMarketAdapter moneyMarket = moneyMarkets[withdrawSeq[i]];
                if (!moneyMarket.supportsToken(token)) continue;

                uint256 supply = moneyMarket.getSupply(token);
                if (supply == 0) continue;

                uint256 withdrawAmount = supply < remaining ? supply : remaining;
                remaining -= withdrawAmount;
                moneyMarket.withdraw(token, account, withdrawAmount);
            }
        }

        if (!_isUToken(msg.sender, token)) {
            balances[msg.sender][token] = balances[msg.sender][token] - amount + remaining;
            totalPrincipal[token] = totalPrincipal[token] - amount + remaining;
        }

        emit LogWithdraw(token, account, amount, remaining);

        return true;
    }

    function debtWriteOff(address token, uint256 amount) external override {
        require(balances[msg.sender][token] >= amount, ""AssetManager: balance not enough"");
        balances[msg.sender][token] -= amount;
        totalPrincipal[token] -= amount;
    }

    /**
     *  @dev Add a new ERC20 token to support in AssetManager
     *  @param tokenAddress ERC20 token address
     */
    function addToken(address tokenAddress) external override onlyAdmin {
        require(!supportedMarkets[tokenAddress].isSupported, ""AssetManager: token is exist"");
        supportedTokensList.push(tokenAddress);
        supportedMarkets[tokenAddress].isSupported = true;

        approveAllMarketsMax(tokenAddress);
    }

    /**
     *  @dev For a give token set allowance for all integrated money markets
     *  @param tokenAddress ERC20 token address
     */
    function approveAllMarketsMax(address tokenAddress) public override onlyAdmin {
        IERC20Upgradeable poolToken = IERC20Upgradeable(tokenAddress);
        for (uint256 i = 0; i < moneyMarkets.length; i++) {
            poolToken.safeApprove(address(moneyMarkets[i]), 0);
            poolToken.safeApprove(address(moneyMarkets[i]), type(uint256).max);
        }
    }

    /**
     *  @dev Add a new adapter for the underlying lending protocol
     *  @param adapterAddress adapter address
     */
    function addAdapter(address adapterAddress) external override onlyAdmin {
        bool isExist = false;
        for (uint256 i = 0; i < moneyMarkets.length; i++) {
            if (adapterAddress == address(moneyMarkets[i])) isExist = true;
        }

        if (!isExist) moneyMarkets.push(IMoneyMarketAdapter(adapterAddress));

        approveAllTokensMax(adapterAddress);
    }

    function overwriteAdapters(address[] calldata adapters) external onlyAdmin {
        moneyMarkets = new IMoneyMarketAdapter[](adapters.length);
        for (uint256 i = 0; i < adapters.length; i++) {
            moneyMarkets[i] = IMoneyMarketAdapter(adapters[i]);
        }
    }

    /**
     *  @dev For a give moeny market set allowance for all underlying tokens
     *  @param adapterAddress Address of adaptor for money market
     */
    function approveAllTokensMax(address adapterAddress) public override onlyAdmin {
        for (uint256 i = 0; i < supportedTokensList.length; i++) {
            IERC20Upgradeable poolToken = IERC20Upgradeable(supportedTokensList[i]);
            poolToken.safeApprove(adapterAddress, 0);
            poolToken.safeApprove(adapterAddress, type(uint256).max);
        }
    }

    /**
     *  @dev Set withdraw sequence
     *  @param newSeq priority sequence of money market indices to be used while withdrawing
     */
    function changeWithdrawSequence(uint256[] calldata newSeq) external override onlyAdmin {
        withdrawSeq = newSeq;
    }

    /**
     * @dev Take all the supply of `tokenAddress` and redistribute it according to `percentages`.
     *
     * Rejects if the token is not supported.
     *
     * @param tokenAddress Address of the token that is going to be rebalanced
     * @param percentages A list of percentages, expressed as units in 10000, indicating how to deposit the tokens in
     * each underlying money market. The length of this array is one less than the amount of money markets: the last
     * money market will receive the remaining tokens. For example, if there are 3 money markets, and you want to
     * rebalance so that the first one has 10.5% of the tokens, the second one 55%, and the third one 34.5%, this param
     * will be [1050, 5500].
     */
    function rebalance(address tokenAddress, uint256[] calldata percentages)
        external
        override
        checkMarketSupported(tokenAddress)
        onlyAdmin
    {
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        require(percentages.length + 1 == moneyMarkets.length, ""AssetManager: percentages error"");

        for (uint256 i = 0; i < moneyMarkets.length; i++) {
            if (!moneyMarkets[i].supportsToken(tokenAddress)) {
                continue;
            }
            moneyMarkets[i].withdrawAll(tokenAddress, address(this));
        }

        uint256 tokenSupply = token.balanceOf(address(this));

        for (uint256 i = 0; i < percentages.length; i++) {
            if (!moneyMarkets[i].supportsToken(tokenAddress)) {
                continue;
            }
            uint256 amountToDeposit = (tokenSupply * percentages[i]) / 10000;
            if (amountToDeposit == 0) {
                continue;
            }
            token.safeTransfer(address(moneyMarkets[i]), amountToDeposit);
            moneyMarkets[i].deposit(tokenAddress);
        }

        uint256 remainingTokens = token.balanceOf(address(this));
        if (moneyMarkets[moneyMarkets.length - 1].supportsToken(tokenAddress) && remainingTokens > 0) {
            token.safeTransfer(address(moneyMarkets[moneyMarkets.length - 1]), remainingTokens);
            moneyMarkets[moneyMarkets.length - 1].deposit(tokenAddress);
        }

        require(token.balanceOf(address(this)) == 0, ""AssetManager: there are remaining funds in the fund pool"");

        emit LogRebalance(tokenAddress, percentages);
    }

    /**
     *  @dev Claim the tokens left on AssetManager balance, in case there are tokens get stuck here.
     *  @param tokenAddress ERC20 token address
     *  @param recipient Recipient address
     */
    function claimTokens(address tokenAddress, address recipient) external override onlyAdmin {
        require(recipient != address(0), ""AsstManager: recipient can not be zero"");
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        uint256 balance = token.balanceOf(address(this));
        token.safeTransfer(recipient, balance);
    }

    /**
     *  @dev Claim the tokens stuck in the integrated adapters
     *  @param index MoneyMarkets array index
     *  @param tokenAddress ERC20 token address
     *  @param recipient Recipient address
     */
    function claimTokensFromAdapter(
        uint256 index,
        address tokenAddress,
        address recipient
    ) external override onlyAdmin {
        IMoneyMarketAdapter moneyMarket = moneyMarkets[index];
        moneyMarket.claimTokens(tokenAddress, recipient);
    }

    /**
     *  @dev Get the number of supported underlying protocols.
     *  @return MoneyMarkets length
     */
    function moneyMarketsCount() external view override returns (uint256) {
        return moneyMarkets.length;
    }

    /**
     *  @dev Get the count of supported tokens
     *  @return Number of supported tokens
     */
    function supportedTokensCount() external view override returns (uint256) {
        return supportedTokensList.length;
    }

    /**
     *  @dev Get the supported lending protocol
     *  @param tokenAddress ERC20 token address
     *  @param marketId MoneyMarkets array index
     *  @return rate tokenSupply, rate(compound is supplyRatePerBlock 1e18, aave is supplyRatePerYear 1e27)
     */
    function getMoneyMarket(address tokenAddress, uint256 marketId)
        external
        view
        override
        returns (uint256 rate, uint256 tokenSupply)
    {
        rate = moneyMarkets[marketId].getRate(tokenAddress);
        tokenSupply += moneyMarkets[marketId].getSupplyView(tokenAddress);
    }

    function _checkSenderBalance(
        address sender,
        address tokenAddress,
        uint256 amount
    ) private view returns (bool) {
        if (_isUToken(sender, tokenAddress)) {
            // For all the lending markets, which have no deposits, return the tokens from the pool
            return getLoanableAmount(tokenAddress) >= amount;
        } else {
            return balances[sender][tokenAddress] >= amount;
        }
    }

    function _isUToken(address sender, address token) private view returns (bool) {
        (address uTokenAddress, ) = IMarketRegistry(marketRegistry).tokens(token);
        return uTokenAddress == sender;
    }

    function _isUserManager(address sender, address token) private view returns (bool) {
        (, address userManagerAddress) = IMarketRegistry(marketRegistry).tokens(token);
        return userManagerAddress == sender;
    }
}",4121
RealWorld_BA_45_FixedInterestRateModel_RealWord_20240820181659.log,45,FixedInterestRateModel,8188,5114,13302,83.0,0.14322,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;
pragma abicoder v1;

import ""@openzeppelin/contracts/access/Ownable.sol"";

import ""../interfaces/IInterestRateModel.sol"";

contract FixedInterestRateModel is Ownable, IInterestRateModel {
    bool public constant override isInterestRateModel = true;
    uint256 public interestRatePerBlock;

    /**
     *  @dev Update interest parameters event
     *  @param interestRate New interest rate, 1e18 = 100%
     */
    event LogNewInterestParams(uint256 interestRate);

    constructor(uint256 interestRatePerBlock_) {
        interestRatePerBlock = interestRatePerBlock_;

        emit LogNewInterestParams(interestRatePerBlock_);
    }

    function getBorrowRate() public view override returns (uint256) {
        return interestRatePerBlock;
    }

    function getSupplyRate(uint256 reserveFactorMantissa) public view override returns (uint256) {
        require(reserveFactorMantissa <= 1e18, ""reserveFactorMantissa error"");
        uint256 ratio = uint256(1e18) - reserveFactorMantissa;
        return (interestRatePerBlock * ratio) / 1e18;
    }

    function setInterestRate(uint256 interestRatePerBlock_) external override onlyOwner {
        interestRatePerBlock = interestRatePerBlock_;
        emit LogNewInterestParams(interestRatePerBlock_);
    }
}",311
RealWorld_BA_45_IUToken_RealWord_20240820183638.log,45,IUToken,20909,6352,27261,92.0,0.231585,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

/**
 *  @title UToken Interface
 *  @dev Union members can borrow and repay thru this component.
 */
interface IUToken {
    /**
     *  @dev Returns the remaining amount that can be borrowed from the market.
     *  @return Remaining total amount
     */
    function getRemainingLoanSize() external view returns (uint256);

    /**
     *  @dev Get the borrowed principle
     *  @param account Member address
     *  @return Borrowed amount
     */
    function getBorrowed(address account) external view returns (uint256);

    /**
     *  @dev Get the last repay block
     *  @param account Member address
     *  @return Block number
     */
    function getLastRepay(address account) external view returns (uint256);

    /**
     *  @dev Get member interest index
     *  @param account Member address
     *  @return Interest index
     */
    function getInterestIndex(address account) external view returns (uint256);

    /**
     *  @dev Check if the member's loan is overdue
     *  @param account Member address
     *  @return Check result
     */
    function checkIsOverdue(address account) external view returns (bool);

    /**
     *  @dev Get the borrowing interest rate per block
     *  @return Borrow rate
     */
    function borrowRatePerBlock() external view returns (uint256);

    /**
     *  @dev Get the origination fee
     *  @param amount Amount to be calculated
     *  @return Handling fee
     */
    function calculatingFee(uint256 amount) external view returns (uint256);

    /**
     *  @dev Get member loan data
     *  @param member Member address
     *  @return Loan
     */
    function getLoan(address member)
        external
        view
        returns (
            uint256,
            uint256,
            address,
            uint256,
            int256,
            bool,
            uint256
        );

    /**
     *  @dev Calculating member's borrowed interest
     *  @param account Member address
     *  @return Interest amount
     */
    function calculatingInterest(address account) external view returns (uint256);

    /**
     *  @dev Get a member's current owed balance, including the principle and interest but without updating the user's states.
     *  @param account Member address
     *  @return Borrowed amount
     */
    function borrowBalanceView(address account) external view returns (uint256);

    /**
     *  @dev Change loan origination fee value
     *  Accept claims only from the admin
     *  @param originationFee_ Fees deducted for each loan transaction
     */
    function setOriginationFee(uint256 originationFee_) external;

    /**
     *  @dev Update the market debt ceiling to a fixed amount, for example, 1 billion DAI etc.
     *  Accept claims only from the admin
     *  @param debtCeiling_ The debt limit for the whole system
     */
    function setDebtCeiling(uint256 debtCeiling_) external;

    /**
     *  @dev Update the minimum loan size
     *  Accept claims only from the admin
     *  @param minLoan_ Minimum loan amount per user
     */
    function setMinLoan(uint256 minLoan_) external;

    /**
     *  @dev Change loan overdue duration, based on the number of blocks
     *  Accept claims only from the admin
     *  @param overdueBlocks_ Maximum late repayment block. The number of arrivals is a default
     */
    function setOverdueBlocks(uint256 overdueBlocks_) external;

    /**
     *  @dev Change to a different interest rate model
     *  Accept claims only from the admin
     *  @param newInterestRateModel New interest rate model address
     */
    function setInterestRateModel(address newInterestRateModel) external;

    /**
     *  @dev Borrowing from the market
     *  Accept claims only from the member
     *  Borrow amount must in the range of creditLimit, minLoan, debtCeiling and not overdue
     *  @param amount Borrow amount
     */
    function borrow(uint256 amount) external;

    /**
     *  @dev Repay the loan
     *  Accept claims only from the member
     *  Updated member lastPaymentEpoch only when the repayment amount is greater than interest
     *  @param account Borrower address
     *  @param amount Repay amount
     */
    function repay(address account, uint256 amount) external;

    /**
     *  @dev Update borrower overdue info
     *  @param account Borrower address
     */
    function updateOverdueInfo(address account) external;

    /**
     *  @dev debt write off
     *  @param borrower Borrower address
     *  @param amount WriteOff amount
     */
    function debtWriteOff(address borrower, uint256 amount) external;
}",1077
RealWorld_BA_45_UnionToken_RealWord_20240820174115.log,45,UnionToken,15479,6164,21643,86.0,0.200675,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/token/ERC20/extensions/ERC20VotesComp.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"";

import ""./Whitelistable.sol"";

/**
 * @title UnionToken Contract
 * @dev Mint and distribute UnionTokens.
 */
contract UnionToken is ERC20VotesComp, ERC20Burnable, Whitelistable {
    //The EIP-712 typehash for the contract's domain
    bytes32 public constant DOMAIN_TYPEHASH =
        keccak256(""EIP712Domain(string name,uint256 chainId,address verifyingContract)"");

    //The EIP-712 typehash for the delegation struct used by the contract
    bytes32 public constant DELEGATION_TYPEHASH =
        keccak256(""Delegation(address delegatee,uint256 nonce,uint256 expiry)"");

    bytes32 public constant PERMIT_TYPEHASH =
        keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");

    /// @notice Minimum time between mints
    uint256 public constant minimumTimeBetweenMints = 1 days * 365;

    /// @notice The timestamp after which minting may occur
    uint256 public mintingAllowedAfter;

    uint256 public constant INIT_CIRCULATING = 100000000 * 10**18;

    /// @notice Cap on the percentage of totalSupply that can be minted at each mint
    uint256 public constant mintCap = 4;

    constructor(
        string memory name,
        string memory symbol,
        uint256 mintingAllowedAfter_
    ) ERC20(name, symbol) ERC20Permit(name) {
        require(mintingAllowedAfter_ >= block.timestamp, ""minting can only begin after deployment"");

        //If the balance is not 0, the data has been migrated and it is not a newly deployed contract. At this time, INIT_CIRCULATING tokens are not pre-mined
        if (balanceOf(msg.sender) == 0) {
            _mint(msg.sender, INIT_CIRCULATING);
        }

        mintingAllowedAfter = mintingAllowedAfter_;
        whitelistEnabled = false;
        whitelist(msg.sender);
    }

    function mint(address dst, uint256 amount) external onlyOwner returns (bool) {
        require(amount <= (totalSupply() * mintCap) / 100, ""exceeded mint cap"");

        _mint(dst, amount);

        return true;
    }

    function _mint(address account, uint256 amount) internal override(ERC20, ERC20Votes) {
        super._mint(account, amount);
        require(block.timestamp >= mintingAllowedAfter, ""minting not allowed yet"");

        // record the mint
        mintingAllowedAfter = minimumTimeBetweenMints + block.timestamp;
    }

    function _burn(address account, uint256 amount) internal override(ERC20, ERC20Votes) {
        super._burn(account, amount);
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        super._beforeTokenTransfer(from, to, amount);

        if (whitelistEnabled) {
            require(isWhitelisted(msg.sender) || to == address(0), ""Whitelistable: address not whitelisted"");
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override(ERC20, ERC20Votes) {
        super._afterTokenTransfer(from, to, amount);
    }
}",749
RealWorld_BA_45_UnionGovernor_RealWord_20240820181523.log,45,UnionGovernor,21024,5181,26205,93.0,0.20874,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/governance/Governor.sol"";
import ""@openzeppelin/contracts/governance/compatibility/GovernorCompatibilityBravo.sol"";
import ""@openzeppelin/contracts/governance/extensions/GovernorVotesComp.sol"";
import ""@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol"";

contract UnionGovernor is GovernorCompatibilityBravo, GovernorVotesComp, GovernorTimelockControl {
    uint256 public proposalCount;
    mapping(address => uint256) public latestProposalIds;

    constructor(ERC20VotesComp _token, TimelockController _timelock)
        Governor(""Union Governor"")
        GovernorVotesComp(_token)
        GovernorTimelockControl(_timelock)
    // solhint-disable-next-line no-empty-blocks
    {

    }

    function votingDelay() public pure virtual override returns (uint256) {
        return 6575; // 1 day
    }

    function votingPeriod() public pure virtual override returns (uint256) {
        return 46027; // 1 week
    }

    function proposalThreshold() public pure virtual override returns (uint256) {
        return 50000e18;
    }

    function quorum(uint256 blockNumber) public view override returns (uint256) {
        return (token.getPastTotalSupply(blockNumber) * 4e16) / 1e18; //4%
    }

    function getVotes(address account, uint256 blockNumber)
        public
        view
        override(IGovernor, GovernorVotesComp)
        returns (uint256)
    {
        return super.getVotes(account, blockNumber);
    }

    function state(uint256 proposalId)
        public
        view
        override(Governor, IGovernor, GovernorTimelockControl)
        returns (ProposalState)
    {
        return super.state(proposalId);
    }

    function propose(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        string memory description
    ) public override(IGovernor, Governor, GovernorCompatibilityBravo) returns (uint256) {
        _checkUserLatestProposal();
        proposalCount++;
        uint256 proposalId = hashProposal(targets, values, calldatas, keccak256(bytes(description)));
        latestProposalIds[_msgSender()] = proposalId;
        return super.propose(targets, values, calldatas, description);
    }

    function propose(
        address[] memory targets,
        uint256[] memory values,
        string[] memory signatures,
        bytes[] memory calldatas,
        string memory description
    ) public override(GovernorCompatibilityBravo) returns (uint256) {
        //Will execute propose(address[] memory targets,uint256[] memory values,bytes[] memory calldatas,string memory description).No additional processing logic is required
        return super.propose(targets, values, signatures, calldatas, description);
    }

    function _countVote(
        uint256 proposalId,
        address account,
        uint8 support,
        uint256 weight
    ) internal override(Governor, GovernorCompatibilityBravo) {
        return super._countVote(proposalId, account, support, weight);
    }

    function _quorumReached(uint256 proposalId)
        internal
        view
        override(Governor, GovernorCompatibilityBravo)
        returns (bool)
    {
        return super._quorumReached(proposalId);
    }

    function _voteSucceeded(uint256 proposalId)
        internal
        view
        override(Governor, GovernorCompatibilityBravo)
        returns (bool)
    {
        return super._voteSucceeded(proposalId);
    }

    function _execute(
        uint256 proposalId,
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) internal override(Governor, GovernorTimelockControl) {
        super._execute(proposalId, targets, values, calldatas, descriptionHash);
    }

    function _cancel(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) internal override(Governor, GovernorTimelockControl) returns (uint256) {
        return super._cancel(targets, values, calldatas, descriptionHash);
    }

    function _executor() internal view override(Governor, GovernorTimelockControl) returns (address) {
        return super._executor();
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(Governor, IERC165, GovernorTimelockControl)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    function _checkUserLatestProposal() private view {
        uint256 latestProposalId = latestProposalIds[_msgSender()];
        if (latestProposalId != 0) {
            ProposalState proposersLatestProposalState = state(latestProposalId);
            require(proposersLatestProposalState != ProposalState.Active, ""Governor: found an already active proposal"");
            require(
                proposersLatestProposalState != ProposalState.Pending,
                ""Governor: found an already pending proposal""
            );
        }
    }
}",1117
RealWorld_BA_45_CompoundMock_RealWord_20240820180849.log,45,CompoundMock,9362,4820,14182,78.0,0.14321,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";

contract CompoundMock is Initializable, ERC20Upgradeable {
    uint256 public rate;
    uint256 public constant EXCHANGE_RATE = 1e18;
    IERC20Upgradeable public underlyingToken;

    function __CompoundMock_init(uint256 _rate, address _underlyingToken) public initializer {
        rate = _rate;
        underlyingToken = IERC20Upgradeable(_underlyingToken);
    }

    function supplyRatePerBlock() external view returns (uint256) {
        return rate;
    }

    function mint(uint256 mintAmount) external returns (uint256) {
        underlyingToken.transferFrom(msg.sender, address(this), mintAmount);
        _mint(msg.sender, (mintAmount * EXCHANGE_RATE) / 10**18);
        return 0;
    }

    function mintOther(address account, uint256 mintAmount) external returns (uint256) {
        underlyingToken.transferFrom(msg.sender, address(this), mintAmount);
        _mint(account, (mintAmount * EXCHANGE_RATE) / 10**18);
        return 0;
    }

    function redeemUnderlying(uint256 redeemAmount) external returns (uint256) {
        underlyingToken.transfer(msg.sender, redeemAmount);
        _burn(msg.sender, (redeemAmount * EXCHANGE_RATE) / 10**18);
        return 0;
    }

    function balanceOfUnderlying(address owner) external view returns (uint256) {
        return (balanceOf(owner) * EXCHANGE_RATE) / 10**18;
    }

    function exchangeRateStored() external pure returns (uint256) {
        return EXCHANGE_RATE;
    }
}",415
RealWorld_BA_45_TreasuryVester_RealWord_20240820182243.log,45,TreasuryVester,9444,4966,14410,75.0,0.14654,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;
pragma abicoder v1;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

contract TreasuryVester {
    using SafeERC20 for IERC20;

    address public unionToken;
    address public recipient;
    uint256 public vestingAmount;
    uint256 public vestingBegin;
    uint256 public vestingCliff;
    uint256 public vestingEnd;
    uint256 public lastUpdate;

    constructor(
        address unionToken_,
        address recipient_,
        uint256 vestingAmount_,
        uint256 vestingBegin_,
        uint256 vestingCliff_,
        uint256 vestingEnd_
    ) {
        require(vestingBegin_ >= block.timestamp, ""vesting begin too early"");
        require(vestingCliff_ >= vestingBegin_, ""cliff is too early"");
        require(vestingEnd_ > vestingCliff_, ""end is too early"");

        unionToken = unionToken_;
        recipient = recipient_;
        vestingAmount = vestingAmount_;
        vestingBegin = vestingBegin_;
        vestingCliff = vestingCliff_;
        vestingEnd = vestingEnd_;
        lastUpdate = vestingBegin;
    }

    function claim() public {
        require(block.timestamp >= vestingCliff, ""not time yet"");
        uint256 amount;
        if (block.timestamp >= vestingEnd) {
            amount = IERC20(unionToken).balanceOf(address(this));
        } else {
            amount = (vestingAmount * (block.timestamp - lastUpdate)) / (vestingEnd - vestingBegin);
            lastUpdate = block.timestamp;
        }
        IERC20(unionToken).safeTransfer(recipient, amount);
    }
}",393
RealWorld_BA_45_IAssetManager_RealWord_20240820183121.log,45,IAssetManager,22321,5314,27635,79.0,0.217885,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

/**
 *  @title AssetManager Interface
 *  @dev Manage the token balances staked by the users and deposited by admins, and invest tokens to the integrated underlying lending protocols.
 */
interface IAssetManager {
    /**
     *  @dev Returns the balance of asset manager, plus the total amount of tokens deposited to all the underlying lending protocols.
     *  @param tokenAddress ERC20 token address
     *  @return Lending pool balance
     */
    function getPoolBalance(address tokenAddress) external view returns (uint256);

    /**
     *  @dev Returns the amount of the lending pool balance minus the amount of total staked.
     *  @param tokenAddress ERC20 token address
     *  @return Amount can be borrowed
     */
    function getLoanableAmount(address tokenAddress) external view returns (uint256);

    /**
     *  @dev Get the total amount of tokens deposited to all the integrated underlying protocols without side effects.
     *  @param tokenAddress ERC20 token address
     *  @return Total market balance
     */
    function totalSupply(address tokenAddress) external returns (uint256);

    /**
     *  @dev Get the total amount of tokens deposited to all the integrated underlying protocols, but without side effects. Safe to call anytime, but may not get the most updated number for the current block. Call totalSupply() for that purpose.
     *  @param tokenAddress ERC20 token address
     *  @return Total market balance
     */
    function totalSupplyView(address tokenAddress) external view returns (uint256);

    /**
     *  @dev Check if there is an underlying protocol available for the given ERC20 token.
     *  @param tokenAddress ERC20 token address
     *  @return Whether is supported
     */
    function isMarketSupported(address tokenAddress) external view returns (bool);

    /**
     *  @dev Deposit tokens to AssetManager, and those tokens will be passed along to adapters to deposit to integrated asset protocols if any is available.
     *  @param token ERC20 token address
     *  @param amount Deposit amount, in wei
     *  @return Deposited amount
     */
    function deposit(address token, uint256 amount) external returns (bool);

    /**
     *  @dev Withdraw from AssetManager
     *  @param token ERC20 token address
     *  @param account User address
     *  @param amount Withdraw amount, in wei
     *  @return Withdraw amount
     */
    function withdraw(
        address token,
        address account,
        uint256 amount
    ) external returns (bool);

    /**
     *  @dev Add a new ERC20 token to support in AssetManager
     *  @param tokenAddress ERC20 token address
     */
    function addToken(address tokenAddress) external;

    /**
     *  @dev Add a new adapter for the underlying lending protocol
     *  @param adapterAddress adapter address
     */
    function addAdapter(address adapterAddress) external;

    /**
     *  @dev For a give token set allowance for all integrated money markets
     *  @param tokenAddress ERC20 token address
     */
    function approveAllMarketsMax(address tokenAddress) external;

    /**
     *  @dev For a give moeny market set allowance for all underlying tokens
     *  @param adapterAddress Address of adaptor for money market
     */
    function approveAllTokensMax(address adapterAddress) external;

    /**
     *  @dev Set withdraw sequence
     *  @param newSeq priority sequence of money market indices to be used while withdrawing
     */
    function changeWithdrawSequence(uint256[] calldata newSeq) external;

    /**
     *  @dev Rebalance the tokens between integrated lending protocols
     *  @param tokenAddress ERC20 token address
     *  @param percentages Proportion
     */
    function rebalance(address tokenAddress, uint256[] calldata percentages) external;

    /**
     *  @dev Claim the tokens left on AssetManager balance, in case there are tokens get stuck here.
     *  @param tokenAddress ERC20 token address
     *  @param recipient Recipient address
     */
    function claimTokens(address tokenAddress, address recipient) external;

    /**
     *  @dev Claim the tokens stuck in the integrated adapters
     *  @param index MoneyMarkets array index
     *  @param tokenAddress ERC20 token address
     *  @param recipient Recipient address
     */
    function claimTokensFromAdapter(
        uint256 index,
        address tokenAddress,
        address recipient
    ) external;

    /**
     *  @dev Get the number of supported underlying protocols.
     *  @return MoneyMarkets length
     */
    function moneyMarketsCount() external view returns (uint256);

    /**
     *  @dev Get the count of supported tokens
     *  @return Number of supported tokens
     */
    function supportedTokensCount() external view returns (uint256);

    /**
     *  @dev Get the supported lending protocol
     *  @param tokenAddress ERC20 token address
     *  @param marketId MoneyMarkets array index
     *  @return tokenSupply
     */
    function getMoneyMarket(address tokenAddress, uint256 marketId) external view returns (uint256, uint256);

    /**
     *  @dev debt write off
     *  @param tokenAddress ERC20 token address
     *  @param amount WriteOff amount
     */
    function debtWriteOff(address tokenAddress, uint256 amount) external;
}",1187
RealWorld_BA_45_CompoundAdapterMock_RealWord_20240820180316.log,45,CompoundAdapterMock,10064,5634,15698,86.0,0.163,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";

contract CompoundAdapterMock is Initializable {
    bool public isSupport;
    mapping(address => uint256) public floorMap;
    mapping(address => uint256) public ceilingMap;

    function __CompoundAdapterMock_init() public initializer {}

    function setSupport() external {
        isSupport = !isSupport;
    }

    function setFloor(address tokenAddress, uint256 floor) external {
        floorMap[tokenAddress] = floor;
    }

    function setCeiling(address tokenAddress, uint256 ceiling) external {
        ceilingMap[tokenAddress] = ceiling;
    }

    function claimTokens(address tokenAddress, address recipient) external {
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        uint256 balance = token.balanceOf(address(this));
        token.transfer(recipient, balance);
    }

    function supportsToken(address) external view returns (bool) {
        return isSupport;
    }

    function getSupplyView(address tokenAddress) external view returns (uint256) {
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        return token.balanceOf(address(this));
    }

    function getSupply(address tokenAddress) external view returns (uint256) {
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        return token.balanceOf(address(this));
    }

    function deposit(address) external {}

    function withdraw(
        address tokenAddress,
        address recipient,
        uint256 tokenAmount
    ) external {
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        token.transfer(recipient, tokenAmount);
    }

    function withdrawAll(address tokenAddress, address recipient) external {
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        token.transfer(recipient, token.balanceOf(address(this)));
    }
}",430
RealWorld_BA_45_WadRayMath_RealWord_20240820173724.log,45,WadRayMath,6112,4148,10260,69.0,0.11352,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

/**
 * @title WadRayMath library
 * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)
 */

library WadRayMath {
    uint256 internal constant WAD = 1e18;
    uint256 internal constant halfWAD = WAD / 2;

    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {
        return (halfWAD + a * b) / WAD;
    }

    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 halfB = b / 2;

        return (halfB + a * WAD) / b;
    }
}",181
RealWorld_BA_45_UnionGovernorMock_RealWord_20240820180616.log,45,UnionGovernorMock,5240,4298,9538,74.0,0.11216,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""../governance/UnionGovernor.sol"";

contract UnionGovernorMock is UnionGovernor {
    constructor(ERC20VotesComp _token, TimelockController _timelock) UnionGovernor(_token, _timelock) {}

    function votingDelay() public pure override returns (uint256) {
        return 2;
    }

    function votingPeriod() public pure override returns (uint256) {
        return 5760;
    }

    function proposalThreshold() public pure override returns (uint256) {
        return 50000e18;
    }
}",139
RealWorld_BA_45_AaveAdapter_RealWord_20240820174243.log,45,AaveAdapter,22903,6821,29724,97.0,0.250935,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;
pragma abicoder v1;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""../interfaces/IMoneyMarketAdapter.sol"";
import ""../Controller.sol"";

abstract contract AToken is IERC20Upgradeable {
    function scaledBalanceOf(address user) external view virtual returns (uint256);

    function getScaledUserBalanceAndSupply(address user) external view virtual returns (uint256, uint256);

    function scaledTotalSupply() external view virtual returns (uint256);

    function isTransferAllowed(address user, uint256 amount) external view virtual returns (bool);
}

abstract contract LendingPool {
    function deposit(
        address asset,
        uint256 amount,
        address onBehalfOf,
        uint16 referralCode
    ) external virtual;

    function withdraw(
        address asset,
        uint256 amount,
        address to
    ) external virtual;

    function getReserveData(address asset)
        external
        view
        virtual
        returns (
            uint256,
            uint128,
            uint128,
            uint128,
            uint128,
            uint128,
            uint40,
            address,
            address,
            address,
            address,
            uint8
        );
}

/**
 * @title AaveAdapter
 *  @dev The implementation of Aave.Finance MoneyMarket that integrates with AssetManager.
 */
contract AaveAdapter is Controller, IMoneyMarketAdapter {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    uint256 private constant UINT256_MAX = type(uint256).max;
    mapping(address => address) public tokenToAToken;
    address public assetManager;
    mapping(address => uint256) public override floorMap;
    mapping(address => uint256) public override ceilingMap;
    LendingPool public lendingPool;

    modifier checkTokenSupported(address tokenAddress) {
        require(_supportsToken(tokenAddress), ""AaveAdapter: Token not supported"");
        _;
    }

    modifier onlyAssetManager() {
        require(msg.sender == assetManager, ""AaveAdapter: only asset manager can call"");
        _;
    }

    function __AaveAdapter_init(address _assetManager, LendingPool _lendingPool) public initializer {
        Controller.__Controller_init(msg.sender);
        assetManager = _assetManager;
        lendingPool = _lendingPool;
    }

    function setAssetManager(address _assetManager) external onlyAdmin {
        assetManager = _assetManager;
    }

    function setFloor(address tokenAddress, uint256 floor) external onlyAdmin {
        floorMap[tokenAddress] = floor;
    }

    function setCeiling(address tokenAddress, uint256 ceiling) external onlyAdmin {
        ceilingMap[tokenAddress] = ceiling;
    }

    function mapTokenToAToken(address tokenAddress) external onlyAdmin {
        address aTokenAddress;
        (, , , , , , , aTokenAddress, , , , ) = lendingPool.getReserveData(tokenAddress);
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        //AToken aToken = AToken(aTokenAddress);
        token.safeApprove(address(lendingPool), 0);
        token.safeApprove(address(lendingPool), UINT256_MAX);
        tokenToAToken[tokenAddress] = aTokenAddress;
    }

    function getRate(address tokenAddress) external view override returns (uint256) {
        uint128 currentLiquidityRate;
        (, , , currentLiquidityRate, , , , , , , , ) = lendingPool.getReserveData(tokenAddress);
        return uint256(currentLiquidityRate);
    }

    function deposit(address tokenAddress) external override checkTokenSupported(tokenAddress) {
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        uint256 amount = token.balanceOf(address(this));
        lendingPool.deposit(tokenAddress, amount, address(this), 0);
    }

    function withdraw(
        address tokenAddress,
        address recipient,
        uint256 tokenAmount
    ) external override onlyAssetManager checkTokenSupported(tokenAddress) {
        lendingPool.withdraw(tokenAddress, tokenAmount, recipient);
    }

    function withdrawAll(address tokenAddress, address recipient)
        external
        override
        onlyAssetManager
        checkTokenSupported(tokenAddress)
    {
        lendingPool.withdraw(tokenAddress, UINT256_MAX, recipient);
    }

    function claimTokens(address tokenAddress, address recipient) external override onlyAssetManager {
        _claimTokens(tokenAddress, recipient);
    }

    function _getSupply(address tokenAddress) private view returns (uint256) {
        address aTokenAddress = tokenToAToken[tokenAddress];
        AToken aToken = AToken(aTokenAddress);
        uint256 balance = aToken.balanceOf(address(this));

        if (balance <= 10) {
            return 0;
        }

        return balance;
    }

    function getSupply(address tokenAddress) external view override returns (uint256) {
        return _getSupply(tokenAddress);
    }

    function getSupplyView(address tokenAddress) external view override returns (uint256) {
        return _getSupply(tokenAddress);
    }

    function supportsToken(address tokenAddress) external view override returns (bool) {
        return _supportsToken(tokenAddress);
    }

    function _supportsToken(address tokenAddress) internal view returns (bool) {
        address aTokenAddress = tokenToAToken[tokenAddress];

        return aTokenAddress != address(0);
    }

    function _claimTokens(address tokenAddress, address recipient) private {
        require(recipient != address(0), ""AaveAdapter: Recipient can not be zero"");
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        uint256 balance = token.balanceOf(address(this));
        token.safeTransfer(recipient, balance);
    }
}",1249
RealWorld_BA_47_ERC165Upgradeable_RealWord_20240820205713.log,47,ERC165Upgradeable,10312,4546,14858,99.0,0.14248,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./IERC165Upgradeable.sol"";
import ""../proxy/Initializable.sol"";

/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts may inherit from this and call {_registerInterface} to declare
 * their support of an interface.
 */
contract ERC165Upgradeable is Initializable, IERC165Upgradeable {
    /*
     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7
     */
    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;

    /**
     * @dev Mapping of interface ids to whether or not it's supported.
     */
    mapping(bytes4 => bool) private _supportedInterfaces;

    function __ERC165_init() internal initializer {
        __ERC165_init_unchained();
    }

    function __ERC165_init_unchained() internal initializer {
        // Derived contracts need only register support for their own interfaces,
        // we register support for ERC165 itself here
        _registerInterface(_INTERFACE_ID_ERC165);
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     *
     * Time complexity O(1), guaranteed to always use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {
        return _supportedInterfaces[interfaceId];
    }

    /**
     * @dev Registers the contract as an implementer of the interface defined by
     * `interfaceId`. Support of the actual ERC165 interface is automatic and
     * registering its interface id is not required.
     *
     * See {IERC165-supportsInterface}.
     *
     * Requirements:
     *
     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).
     */
    function _registerInterface(bytes4 interfaceId) internal virtual {
        require(interfaceId != 0xffffffff, ""ERC165: invalid interface id"");
        _supportedInterfaces[interfaceId] = true;
    }
    uint256[49] private __gap;
}",448
RealWorld_BA_47_IERC721Upgradeable_RealWord_20240820194420.log,47,IERC721Upgradeable,21129,5261,26390,123.0,0.210865,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""../../introspection/IERC165Upgradeable.sol"";

/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721Upgradeable is IERC165Upgradeable {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId) external view returns (address operator);

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool _approved) external;

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);

    /**
      * @dev Safely transfers `tokenId` token from `from` to `to`.
      *
      * Requirements:
      *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
      * - `tokenId` token must exist and be owned by `from`.
      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
      *
      * Emits a {Transfer} event.
      */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
}",1095
RealWorld_BA_47_ERC20CappedUpgradeable_RealWord_20240820192958.log,47,ERC20CappedUpgradeable,9009,4843,13852,91.0,0.141905,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./ERC20Upgradeable.sol"";
import ""../../proxy/Initializable.sol"";

/**
 * @dev Extension of {ERC20} that adds a cap to the supply of tokens.
 */
abstract contract ERC20CappedUpgradeable is Initializable, ERC20Upgradeable {
    uint256 private _cap;

    /**
     * @dev Sets the value of the `cap`. This value is immutable, it can only be
     * set once during construction.
     */
    function __ERC20Capped_init(uint256 cap) internal initializer {
        __Context_init_unchained();
        __ERC20Capped_init_unchained(cap);
    }

    function __ERC20Capped_init_unchained(uint256 cap) internal initializer {
        require(cap > 0, ""ERC20Capped: cap is 0"");
        _cap = cap;
    }

    /**
     * @dev Returns the cap on the token's total supply.
     */
    function cap() public view returns (uint256) {
        return _cap;
    }

    /**
     * @dev See {ERC20-_beforeTokenTransfer}.
     *
     * Requirements:
     *
     * - minted tokens must not cause the total supply to go over the cap.
     */
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {
        super._beforeTokenTransfer(from, to, amount);

        if (from == address(0)) { // When minting tokens
            require(totalSupply().add(amount) <= _cap, ""ERC20Capped: cap exceeded"");
        }
    }
    uint256[49] private __gap;
}",355
RealWorld_BA_47_IERC777Upgradeable_RealWord_20240820193931.log,47,IERC777Upgradeable,25747,5732,31479,119.0,0.243375,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface of the ERC777Token standard as defined in the EIP.
 *
 * This contract uses the
 * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let
 * token holders and recipients react to token movements by using setting implementers
 * for the associated interfaces in said registry. See {IERC1820Registry} and
 * {ERC1820Implementer}.
 */
interface IERC777Upgradeable {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the smallest part of the token that is not divisible. This
     * means all token operations (creation, movement and destruction) must have
     * amounts that are a multiple of this number.
     *
     * For most token contracts, this value will equal 1.
     */
    function granularity() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by an account (`owner`).
     */
    function balanceOf(address owner) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * If send or receive hooks are registered for the caller and `recipient`,
     * the corresponding functions will be called with `data` and empty
     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.
     *
     * Emits a {Sent} event.
     *
     * Requirements
     *
     * - the caller must have at least `amount` tokens.
     * - `recipient` cannot be the zero address.
     * - if `recipient` is a contract, it must implement the {IERC777Recipient}
     * interface.
     */
    function send(address recipient, uint256 amount, bytes calldata data) external;

    /**
     * @dev Destroys `amount` tokens from the caller's account, reducing the
     * total supply.
     *
     * If a send hook is registered for the caller, the corresponding function
     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.
     *
     * Emits a {Burned} event.
     *
     * Requirements
     *
     * - the caller must have at least `amount` tokens.
     */
    function burn(uint256 amount, bytes calldata data) external;

    /**
     * @dev Returns true if an account is an operator of `tokenHolder`.
     * Operators can send and burn tokens on behalf of their owners. All
     * accounts are their own operator.
     *
     * See {operatorSend} and {operatorBurn}.
     */
    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);

    /**
     * @dev Make an account an operator of the caller.
     *
     * See {isOperatorFor}.
     *
     * Emits an {AuthorizedOperator} event.
     *
     * Requirements
     *
     * - `operator` cannot be calling address.
     */
    function authorizeOperator(address operator) external;

    /**
     * @dev Revoke an account's operator status for the caller.
     *
     * See {isOperatorFor} and {defaultOperators}.
     *
     * Emits a {RevokedOperator} event.
     *
     * Requirements
     *
     * - `operator` cannot be calling address.
     */
    function revokeOperator(address operator) external;

    /**
     * @dev Returns the list of default operators. These accounts are operators
     * for all token holders, even if {authorizeOperator} was never called on
     * them.
     *
     * This list is immutable, but individual holders may revoke these via
     * {revokeOperator}, in which case {isOperatorFor} will return false.
     */
    function defaultOperators() external view returns (address[] memory);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must
     * be an operator of `sender`.
     *
     * If send or receive hooks are registered for `sender` and `recipient`,
     * the corresponding functions will be called with `data` and
     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.
     *
     * Emits a {Sent} event.
     *
     * Requirements
     *
     * - `sender` cannot be the zero address.
     * - `sender` must have at least `amount` tokens.
     * - the caller must be an operator for `sender`.
     * - `recipient` cannot be the zero address.
     * - if `recipient` is a contract, it must implement the {IERC777Recipient}
     * interface.
     */
    function operatorSend(
        address sender,
        address recipient,
        uint256 amount,
        bytes calldata data,
        bytes calldata operatorData
    ) external;

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the total supply.
     * The caller must be an operator of `account`.
     *
     * If a send hook is registered for `account`, the corresponding function
     * will be called with `data` and `operatorData`. See {IERC777Sender}.
     *
     * Emits a {Burned} event.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     * - the caller must be an operator for `account`.
     */
    function operatorBurn(
        address account,
        uint256 amount,
        bytes calldata data,
        bytes calldata operatorData
    ) external;

    event Sent(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256 amount,
        bytes data,
        bytes operatorData
    );

    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);

    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);

    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);

    event RevokedOperator(address indexed operator, address indexed tokenHolder);
}",1404
RealWorld_BA_47_ERC721PausableUpgradeable_RealWord_20240820194625.log,47,ERC721PausableUpgradeable,7555,4780,12335,91.0,0.133375,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./ERC721Upgradeable.sol"";
import ""../../utils/PausableUpgradeable.sol"";
import ""../../proxy/Initializable.sol"";

/**
 * @dev ERC721 token with pausable token transfers, minting and burning.
 *
 * Useful for scenarios such as preventing trades until the end of an evaluation
 * period, or having an emergency switch for freezing all token transfers in the
 * event of a large bug.
 */
abstract contract ERC721PausableUpgradeable is Initializable, ERC721Upgradeable, PausableUpgradeable {
    function __ERC721Pausable_init() internal initializer {
        __Context_init_unchained();
        __ERC165_init_unchained();
        __Pausable_init_unchained();
        __ERC721Pausable_init_unchained();
    }

    function __ERC721Pausable_init_unchained() internal initializer {
    }
    /**
     * @dev See {ERC721-_beforeTokenTransfer}.
     *
     * Requirements:
     *
     * - the contract must not be paused.
     */
    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {
        super._beforeTokenTransfer(from, to, tokenId);

        require(!paused(), ""ERC721Pausable: token transfer while paused"");
    }
    uint256[50] private __gap;
}",293
RealWorld_BA_47_ERC1155Upgradeable_RealWord_20240820200509.log,47,ERC1155Upgradeable,61490,5237,66727,117.0,0.41219,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./IERC1155Upgradeable.sol"";
import ""./IERC1155MetadataURIUpgradeable.sol"";
import ""./IERC1155ReceiverUpgradeable.sol"";
import ""../../GSN/ContextUpgradeable.sol"";
import ""../../introspection/ERC165Upgradeable.sol"";
import ""../../math/SafeMathUpgradeable.sol"";
import ""../../utils/AddressUpgradeable.sol"";
import ""../../proxy/Initializable.sol"";

/**
 *
 * @dev Implementation of the basic standard multi-token.
 * See https://eips.ethereum.org/EIPS/eip-1155
 * Originally based on code by Enjin: https://github.com/enjin/erc-1155
 *
 * _Available since v3.1._
 */
contract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {
    using SafeMathUpgradeable for uint256;
    using AddressUpgradeable for address;

    // Mapping from token ID to account balances
    mapping (uint256 => mapping(address => uint256)) private _balances;

    // Mapping from account to operator approvals
    mapping (address => mapping(address => bool)) private _operatorApprovals;

    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json
    string private _uri;

    /*
     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e
     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4
     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465
     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5
     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a
     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6
     *
     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^
     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26
     */
    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;

    /*
     *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c
     */
    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;

    /**
     * @dev See {_setURI}.
     */
    function __ERC1155_init(string memory uri) internal initializer {
        __Context_init_unchained();
        __ERC165_init_unchained();
        __ERC1155_init_unchained(uri);
    }

    function __ERC1155_init_unchained(string memory uri) internal initializer {
        _setURI(uri);

        // register the supported interfaces to conform to ERC1155 via ERC165
        _registerInterface(_INTERFACE_ID_ERC1155);

        // register the supported interfaces to conform to ERC1155MetadataURI via ERC165
        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);
    }

    /**
     * @dev See {IERC1155MetadataURI-uri}.
     *
     * This implementation returns the same URI for *all* token types. It relies
     * on the token type ID substitution mechanism
     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].
     *
     * Clients calling this function must replace the `\{id\}` substring with the
     * actual token type ID.
     */
    function uri(uint256) external view override returns (string memory) {
        return _uri;
    }

    /**
     * @dev See {IERC1155-balanceOf}.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function balanceOf(address account, uint256 id) public view override returns (uint256) {
        require(account != address(0), ""ERC1155: balance query for the zero address"");
        return _balances[id][account];
    }

    /**
     * @dev See {IERC1155-balanceOfBatch}.
     *
     * Requirements:
     *
     * - `accounts` and `ids` must have the same length.
     */
    function balanceOfBatch(
        address[] memory accounts,
        uint256[] memory ids
    )
        public
        view
        override
        returns (uint256[] memory)
    {
        require(accounts.length == ids.length, ""ERC1155: accounts and ids length mismatch"");

        uint256[] memory batchBalances = new uint256[](accounts.length);

        for (uint256 i = 0; i < accounts.length; ++i) {
            require(accounts[i] != address(0), ""ERC1155: batch balance query for the zero address"");
            batchBalances[i] = _balances[ids[i]][accounts[i]];
        }

        return batchBalances;
    }

    /**
     * @dev See {IERC1155-setApprovalForAll}.
     */
    function setApprovalForAll(address operator, bool approved) public virtual override {
        require(_msgSender() != operator, ""ERC1155: setting approval status for self"");

        _operatorApprovals[_msgSender()][operator] = approved;
        emit ApprovalForAll(_msgSender(), operator, approved);
    }

    /**
     * @dev See {IERC1155-isApprovedForAll}.
     */
    function isApprovedForAll(address account, address operator) public view override returns (bool) {
        return _operatorApprovals[account][operator];
    }

    /**
     * @dev See {IERC1155-safeTransferFrom}.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    )
        public
        virtual
        override
    {
        require(to != address(0), ""ERC1155: transfer to the zero address"");
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not owner nor approved""
        );

        address operator = _msgSender();

        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);

        _balances[id][from] = _balances[id][from].sub(amount, ""ERC1155: insufficient balance for transfer"");
        _balances[id][to] = _balances[id][to].add(amount);

        emit TransferSingle(operator, from, to, id, amount);

        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);
    }

    /**
     * @dev See {IERC1155-safeBatchTransferFrom}.
     */
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    )
        public
        virtual
        override
    {
        require(ids.length == amounts.length, ""ERC1155: ids and amounts length mismatch"");
        require(to != address(0), ""ERC1155: transfer to the zero address"");
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: transfer caller is not owner nor approved""
        );

        address operator = _msgSender();

        _beforeTokenTransfer(operator, from, to, ids, amounts, data);

        for (uint256 i = 0; i < ids.length; ++i) {
            uint256 id = ids[i];
            uint256 amount = amounts[i];

            _balances[id][from] = _balances[id][from].sub(
                amount,
                ""ERC1155: insufficient balance for transfer""
            );
            _balances[id][to] = _balances[id][to].add(amount);
        }

        emit TransferBatch(operator, from, to, ids, amounts);

        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);
    }

    /**
     * @dev Sets a new URI for all token types, by relying on the token type ID
     * substitution mechanism
     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].
     *
     * By this mechanism, any occurrence of the `\{id\}` substring in either the
     * URI or any of the amounts in the JSON file at said URI will be replaced by
     * clients with the token type ID.
     *
     * For example, the `https://token-cdn-domain/\{id\}.json` URI would be
     * interpreted by clients as
     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`
     * for token type ID 0x4cce0.
     *
     * See {uri}.
     *
     * Because these URIs cannot be meaningfully represented by the {URI} event,
     * this function emits no events.
     */
    function _setURI(string memory newuri) internal virtual {
        _uri = newuri;
    }

    /**
     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {
        require(account != address(0), ""ERC1155: mint to the zero address"");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);

        _balances[id][account] = _balances[id][account].add(amount);
        emit TransferSingle(operator, address(0), account, id, amount);

        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);
    }

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.
     *
     * Requirements:
     *
     * - `ids` and `amounts` must have the same length.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
     * acceptance magic value.
     */
    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {
        require(to != address(0), ""ERC1155: mint to the zero address"");
        require(ids.length == amounts.length, ""ERC1155: ids and amounts length mismatch"");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);

        for (uint i = 0; i < ids.length; i++) {
            _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);
        }

        emit TransferBatch(operator, address(0), to, ids, amounts);

        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);
    }

    /**
     * @dev Destroys `amount` tokens of token type `id` from `account`
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens of token type `id`.
     */
    function _burn(address account, uint256 id, uint256 amount) internal virtual {
        require(account != address(0), ""ERC1155: burn from the zero address"");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), """");

        _balances[id][account] = _balances[id][account].sub(
            amount,
            ""ERC1155: burn amount exceeds balance""
        );

        emit TransferSingle(operator, account, address(0), id, amount);
    }

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.
     *
     * Requirements:
     *
     * - `ids` and `amounts` must have the same length.
     */
    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {
        require(account != address(0), ""ERC1155: burn from the zero address"");
        require(ids.length == amounts.length, ""ERC1155: ids and amounts length mismatch"");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, account, address(0), ids, amounts, """");

        for (uint i = 0; i < ids.length; i++) {
            _balances[ids[i]][account] = _balances[ids[i]][account].sub(
                amounts[i],
                ""ERC1155: burn amount exceeds balance""
            );
        }

        emit TransferBatch(operator, account, address(0), ids, amounts);
    }

    /**
     * @dev Hook that is called before any token transfer. This includes minting
     * and burning, as well as batched variants.
     *
     * The same hook is called on both single and batched variants. For single
     * transfers, the length of the `id` and `amount` arrays will be 1.
     *
     * Calling conditions (for each `id` and `amount` pair):
     *
     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * of token type `id` will be  transferred to `to`.
     * - When `from` is zero, `amount` tokens of token type `id` will be minted
     * for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`
     * will be burned.
     * - `from` and `to` are never both zero.
     * - `ids` and `amounts` have the same, non-zero length.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    )
        internal virtual
    { }

    function _doSafeTransferAcceptanceCheck(
        address operator,
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    )
        private
    {
        if (to.isContract()) {
            try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {
                if (response != IERC1155ReceiverUpgradeable(to).onERC1155Received.selector) {
                    revert(""ERC1155: ERC1155Receiver rejected tokens"");
                }
            } catch Error(string memory reason) {
                revert(reason);
            } catch {
                revert(""ERC1155: transfer to non ERC1155Receiver implementer"");
            }
        }
    }

    function _doSafeBatchTransferAcceptanceCheck(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    )
        private
    {
        if (to.isContract()) {
            try IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {
                if (response != IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived.selector) {
                    revert(""ERC1155: ERC1155Receiver rejected tokens"");
                }
            } catch Error(string memory reason) {
                revert(reason);
            } catch {
                revert(""ERC1155: transfer to non ERC1155Receiver implementer"");
            }
        }
    }

    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {
        uint256[] memory array = new uint256[](1);
        array[0] = element;

        return array;
    }
    uint256[47] private __gap;
}",3667
RealWorld_BA_47_ImplementationProvider_RealWord_20240820190600.log,47,ImplementationProvider,4849,4193,9042,87.0,0.108105,"pragma solidity ^0.5.0;

/**
 * @title ImplementationProvider
 * @dev Abstract contract for providing implementation addresses for other contracts by name.
 */
contract ImplementationProvider {
  /**
   * @dev Abstract function to return the implementation address of a contract.
   * @param contractName Name of the contract.
   * @return Implementation address of the contract.
   */
  function getImplementation(string memory contractName) public view returns (address);
}",92
RealWorld_BA_47_ERC721Upgradeable_RealWord_20240820195056.log,47,ERC721Upgradeable,73145,4974,78119,114.0,0.465205,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../../GSN/ContextUpgradeable.sol"";
import ""./IERC721Upgradeable.sol"";
import ""./IERC721MetadataUpgradeable.sol"";
import ""./IERC721EnumerableUpgradeable.sol"";
import ""./IERC721ReceiverUpgradeable.sol"";
import ""../../introspection/ERC165Upgradeable.sol"";
import ""../../math/SafeMathUpgradeable.sol"";
import ""../../utils/AddressUpgradeable.sol"";
import ""../../utils/EnumerableSetUpgradeable.sol"";
import ""../../utils/EnumerableMapUpgradeable.sol"";
import ""../../utils/StringsUpgradeable.sol"";
import ""../../proxy/Initializable.sol"";

/**
 * @title ERC721 Non-Fungible Token Standard basic implementation
 * @dev see https://eips.ethereum.org/EIPS/eip-721
 */
contract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable, IERC721EnumerableUpgradeable {
    using SafeMathUpgradeable for uint256;
    using AddressUpgradeable for address;
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;
    using EnumerableMapUpgradeable for EnumerableMapUpgradeable.UintToAddressMap;
    using StringsUpgradeable for uint256;

    // Equals to `bytes4(keccak256(""onERC721Received(address,address,uint256,bytes)""))`
    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`
    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

    // Mapping from holder address to their (enumerable) set of owned tokens
    mapping (address => EnumerableSetUpgradeable.UintSet) private _holderTokens;

    // Enumerable mapping from token ids to their owners
    EnumerableMapUpgradeable.UintToAddressMap private _tokenOwners;

    // Mapping from token ID to approved address
    mapping (uint256 => address) private _tokenApprovals;

    // Mapping from owner to operator approvals
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Token name
    string private _name;

    // Token symbol
    string private _symbol;

    // Optional mapping for token URIs
    mapping (uint256 => string) private _tokenURIs;

    // Base URI
    string private _baseURI;

    /*
     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231
     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e
     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3
     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc
     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465
     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5
     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd
     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e
     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde
     *
     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^
     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd
     */
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    /*
     *     bytes4(keccak256('name()')) == 0x06fdde03
     *     bytes4(keccak256('symbol()')) == 0x95d89b41
     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd
     *
     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f
     */
    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;

    /*
     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd
     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59
     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7
     *
     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63
     */
    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;

    /**
     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
     */
    function __ERC721_init(string memory name, string memory symbol) internal initializer {
        __Context_init_unchained();
        __ERC165_init_unchained();
        __ERC721_init_unchained(name, symbol);
    }

    function __ERC721_init_unchained(string memory name, string memory symbol) internal initializer {
        _name = name;
        _symbol = symbol;

        // register the supported interfaces to conform to ERC721 via ERC165
        _registerInterface(_INTERFACE_ID_ERC721);
        _registerInterface(_INTERFACE_ID_ERC721_METADATA);
        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);
    }

    /**
     * @dev See {IERC721-balanceOf}.
     */
    function balanceOf(address owner) public view override returns (uint256) {
        require(owner != address(0), ""ERC721: balance query for the zero address"");

        return _holderTokens[owner].length();
    }

    /**
     * @dev See {IERC721-ownerOf}.
     */
    function ownerOf(uint256 tokenId) public view override returns (address) {
        return _tokenOwners.get(tokenId, ""ERC721: owner query for nonexistent token"");
    }

    /**
     * @dev See {IERC721Metadata-name}.
     */
    function name() public view override returns (string memory) {
        return _name;
    }

    /**
     * @dev See {IERC721Metadata-symbol}.
     */
    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev See {IERC721Metadata-tokenURI}.
     */
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(_exists(tokenId), ""ERC721Metadata: URI query for nonexistent token"");

        string memory _tokenURI = _tokenURIs[tokenId];

        // If there is no base URI, return the token URI.
        if (bytes(_baseURI).length == 0) {
            return _tokenURI;
        }
        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).
        if (bytes(_tokenURI).length > 0) {
            return string(abi.encodePacked(_baseURI, _tokenURI));
        }
        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.
        return string(abi.encodePacked(_baseURI, tokenId.toString()));
    }

    /**
    * @dev Returns the base URI set via {_setBaseURI}. This will be
    * automatically added as a prefix in {tokenURI} to each token's URI, or
    * to the token ID if no specific URI is set for that token ID.
    */
    function baseURI() public view returns (string memory) {
        return _baseURI;
    }

    /**
     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.
     */
    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {
        return _holderTokens[owner].at(index);
    }

    /**
     * @dev See {IERC721Enumerable-totalSupply}.
     */
    function totalSupply() public view override returns (uint256) {
        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds
        return _tokenOwners.length();
    }

    /**
     * @dev See {IERC721Enumerable-tokenByIndex}.
     */
    function tokenByIndex(uint256 index) public view override returns (uint256) {
        (uint256 tokenId, ) = _tokenOwners.at(index);
        return tokenId;
    }

    /**
     * @dev See {IERC721-approve}.
     */
    function approve(address to, uint256 tokenId) public virtual override {
        address owner = ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");

        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),
            ""ERC721: approve caller is not owner nor approved for all""
        );

        _approve(to, tokenId);
    }

    /**
     * @dev See {IERC721-getApproved}.
     */
    function getApproved(uint256 tokenId) public view override returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");

        return _tokenApprovals[tokenId];
    }

    /**
     * @dev See {IERC721-setApprovalForAll}.
     */
    function setApprovalForAll(address operator, bool approved) public virtual override {
        require(operator != _msgSender(), ""ERC721: approve to caller"");

        _operatorApprovals[_msgSender()][operator] = approved;
        emit ApprovalForAll(_msgSender(), operator, approved);
    }

    /**
     * @dev See {IERC721-isApprovedForAll}.
     */
    function isApprovedForAll(address owner, address operator) public view override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    /**
     * @dev See {IERC721-transferFrom}.
     */
    function transferFrom(address from, address to, uint256 tokenId) public virtual override {
        //solhint-disable-next-line max-line-length
        require(_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721: transfer caller is not owner nor approved"");

        _transfer(from, to, tokenId);
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {
        safeTransferFrom(from, to, tokenId, """");
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _safeTransfer(from, to, tokenId, _data);
    }

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * `_data` is additional data, it has no specified format and it is sent in call to `to`.
     *
     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
     * implement alternative mechanisms to perform token transfer, such as signature-based.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    /**
     * @dev Returns whether `tokenId` exists.
     *
     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
     *
     * Tokens start existing when they are minted (`_mint`),
     * and stop existing when they are burned (`_burn`).
     */
    function _exists(uint256 tokenId) internal view returns (bool) {
        return _tokenOwners.contains(tokenId);
    }

    /**
     * @dev Returns whether `spender` is allowed to manage `tokenId`.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    /**
     * @dev Safely mints `tokenId` and transfers it to `to`.
     *
     * Requirements:
     d*
     * - `tokenId` must not exist.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function _safeMint(address to, uint256 tokenId) internal virtual {
        _safeMint(to, tokenId, """");
    }

    /**
     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
     */
    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {
        _mint(to, tokenId);
        require(_checkOnERC721Received(address(0), to, tokenId, _data), ""ERC721: transfer to non ERC721Receiver implementer"");
    }

    /**
     * @dev Mints `tokenId` and transfers it to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
     *
     * Requirements:
     *
     * - `tokenId` must not exist.
     * - `to` cannot be the zero address.
     *
     * Emits a {Transfer} event.
     */
    function _mint(address to, uint256 tokenId) internal virtual {
        require(to != address(0), ""ERC721: mint to the zero address"");
        require(!_exists(tokenId), ""ERC721: token already minted"");

        _beforeTokenTransfer(address(0), to, tokenId);

        _holderTokens[to].add(tokenId);

        _tokenOwners.set(tokenId, to);

        emit Transfer(address(0), to, tokenId);
    }

    /**
     * @dev Destroys `tokenId`.
     * The approval is cleared when the token is burned.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     *
     * Emits a {Transfer} event.
     */
    function _burn(uint256 tokenId) internal virtual {
        address owner = ownerOf(tokenId);

        _beforeTokenTransfer(owner, address(0), tokenId);

        // Clear approvals
        _approve(address(0), tokenId);

        // Clear metadata (if any)
        if (bytes(_tokenURIs[tokenId]).length != 0) {
            delete _tokenURIs[tokenId];
        }

        _holderTokens[owner].remove(tokenId);

        _tokenOwners.remove(tokenId);

        emit Transfer(owner, address(0), tokenId);
    }

    /**
     * @dev Transfers `tokenId` from `from` to `to`.
     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     *
     * Emits a {Transfer} event.
     */
    function _transfer(address from, address to, uint256 tokenId) internal virtual {
        require(ownerOf(tokenId) == from, ""ERC721: transfer of token that is not own"");
        require(to != address(0), ""ERC721: transfer to the zero address"");

        _beforeTokenTransfer(from, to, tokenId);

        // Clear approvals from the previous owner
        _approve(address(0), tokenId);

        _holderTokens[from].remove(tokenId);
        _holderTokens[to].add(tokenId);

        _tokenOwners.set(tokenId, to);

        emit Transfer(from, to, tokenId);
    }

    /**
     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {
        require(_exists(tokenId), ""ERC721Metadata: URI set of nonexistent token"");
        _tokenURIs[tokenId] = _tokenURI;
    }

    /**
     * @dev Internal function to set the base URI for all token IDs. It is
     * automatically added as a prefix to the value returned in {tokenURI},
     * or to the token ID if {tokenURI} is empty.
     */
    function _setBaseURI(string memory baseURI_) internal virtual {
        _baseURI = baseURI_;
    }

    /**
     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
     * The call is not executed if the target address is not a contract.
     *
     * @param from address representing the previous owner of the given token ID
     * @param to target address that will receive the tokens
     * @param tokenId uint256 ID of the token to be transferred
     * @param _data bytes optional data to send along with the call
     * @return bool whether the call correctly returned the expected magic value
     */
    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)
        private returns (bool)
    {
        if (!to.isContract()) {
            return true;
        }
        bytes memory returndata = to.functionCall(abi.encodeWithSelector(
            IERC721ReceiverUpgradeable(to).onERC721Received.selector,
            _msgSender(),
            from,
            tokenId,
            _data
        ), ""ERC721: transfer to non ERC721Receiver implementer"");
        bytes4 retval = abi.decode(returndata, (bytes4));
        return (retval == _ERC721_RECEIVED);
    }

    function _approve(address to, uint256 tokenId) private {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    /**
     * @dev Hook that is called before any token transfer. This includes minting
     * and burning.
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
     * transferred to `to`.
     * - When `from` is zero, `tokenId` will be minted for `to`.
     * - When `to` is zero, ``from``'s `tokenId` will be burned.
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }
    uint256[41] private __gap;
}",4361
RealWorld_BA_47_IERC721EnumerableUpgradeable_RealWord_20240820194303.log,47,IERC721EnumerableUpgradeable,6764,4228,10992,75.0,0.11838,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""./IERC721Upgradeable.sol"";

/**
 * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */
interface IERC721EnumerableUpgradeable is IERC721Upgradeable {

    /**
     * @dev Returns the total amount of tokens stored by the contract.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.
     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.
     */
    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);

    /**
     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.
     * Use along with {totalSupply} to enumerate all tokens.
     */
    function tokenByIndex(uint256 index) external view returns (uint256);
}",235
RealWorld_BA_47_Initializable_RealWord_20240820200708.log,47,Initializable,11600,5270,16870,95.0,0.1634,"// SPDX-License-Identifier: MIT

pragma solidity >=0.4.24 <0.7.0;


/**
 * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed
 * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an
 * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer
 * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.
 * 
 * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as
 * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.
 * 
 * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure
 * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.
 */
abstract contract Initializable {

    /**
     * @dev Indicates that the contract has been initialized.
     */
    bool private _initialized;

    /**
     * @dev Indicates that the contract is in the process of being initialized.
     */
    bool private _initializing;

    /**
     * @dev Modifier to protect an initializer function from being invoked twice.
     */
    modifier initializer() {
        require(_initializing || _isConstructor() || !_initialized, ""Initializable: contract is already initialized"");

        bool isTopLevelCall = !_initializing;
        if (isTopLevelCall) {
            _initializing = true;
            _initialized = true;
        }

        _;

        if (isTopLevelCall) {
            _initializing = false;
        }
    }

    /// @dev Returns true if and only if the function is running in the constructor
    function _isConstructor() private view returns (bool) {
        // extcodesize checks the size of the code stored in an address, and
        // address returns the current address. Since the code is still not
        // deployed when running a constructor, any checks on its code size will
        // yield zero, making it an effective way to detect if a contract is
        // under construction or not.
        address self = address(this);
        uint256 cs;
        // solhint-disable-next-line no-inline-assembly
        assembly { cs := extcodesize(self) }
        return cs == 0;
    }
}",525
RealWorld_BA_47_Proxy_RealWord_20240820191518.log,47,Proxy,10855,4848,15703,89.0,0.151235,"pragma solidity ^0.5.0;

/**
 * @title Proxy
 * @dev Implements delegation of calls to other contracts, with proper
 * forwarding of return values and bubbling of failures.
 * It defines a fallback function that delegates all calls to the address
 * returned by the abstract _implementation() internal function.
 */
contract Proxy {
  /**
   * @dev Fallback function.
   * Implemented entirely in `_fallback`.
   */
  function () payable external {
    _fallback();
  }

  /**
   * @return The Address of the implementation.
   */
  function _implementation() internal view returns (address);

  /**
   * @dev Delegates execution to an implementation contract.
   * This is a low level function that doesn't return to its internal call site.
   * It will return to the external caller whatever the implementation returns.
   * @param implementation Address to delegate.
   */
  function _delegate(address implementation) internal {
    assembly {
      // Copy msg.data. We take full control of memory in this inline assembly
      // block because it will not return to Solidity code. We overwrite the
      // Solidity scratch pad at memory position 0.
      calldatacopy(0, 0, calldatasize)

      // Call the implementation.
      // out and outsize are 0 because we don't know the size yet.
      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)

      // Copy the returned data.
      returndatacopy(0, 0, returndatasize)

      switch result
      // delegatecall returns 0 on error.
      case 0 { revert(0, returndatasize) }
      default { return(0, returndatasize) }
    }
  }

  /**
   * @dev Function that is run as the first thing in the fallback function.
   * Can be redefined in derived contracts to add functionality.
   * Redefinitions must call super._willFallback().
   */
  function _willFallback() internal {
  }

  /**
   * @dev fallback implementation.
   * Extracted to enable manual triggering.
   */
  function _fallback() internal {
    _willFallback();
    _delegate(_implementation());
  }
}",475
RealWorld_BA_47_IERC777RecipientUpgradeable_RealWord_20240820193439.log,47,IERC777RecipientUpgradeable,7242,4227,11469,79.0,0.12075,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.
 *
 * Accounts can be notified of {IERC777} tokens being sent to them by having a
 * contract implement this interface (contract holders can be their own
 * implementer) and registering it on the
 * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].
 *
 * See {IERC1820Registry} and {ERC1820Implementer}.
 */
interface IERC777RecipientUpgradeable {
    /**
     * @dev Called by an {IERC777} token contract whenever tokens are being
     * moved or created into a registered account (`to`). The type of operation
     * is conveyed by `from` being the zero address or not.
     *
     * This call occurs _after_ the token contract's state is updated, so
     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.
     *
     * This function may revert to prevent the operation from being executed.
     */
    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external;
}",281
RealWorld_BA_47_Initializable_RealWord_20240820185619.log,47,Initializable,10549,4143,14692,79.0,0.135605,"pragma solidity >=0.4.24 <0.7.0;


/**
 * @title Initializable
 *
 * @dev Helper contract to support initializer functions. To use it, replace
 * the constructor with a function that has the `initializer` modifier.
 * WARNING: Unlike constructors, initializer functions must be manually
 * invoked. This applies both to deploying an Initializable contract, as well
 * as extending an Initializable contract via inheritance.
 * WARNING: When used with inheritance, manual care must be taken to not invoke
 * a parent initializer twice, or ensure that all initializers are idempotent,
 * because this is not dealt with automatically as with constructors.
 */
contract Initializable {

  /**
   * @dev Indicates that the contract has been initialized.
   */
  bool private initialized;

  /**
   * @dev Indicates that the contract is in the process of being initialized.
   */
  bool private initializing;

  /**
   * @dev Modifier to use in the initializer function of a contract.
   */
  modifier initializer() {
    require(initializing || isConstructor() || !initialized, ""Contract instance has already been initialized"");

    bool isTopLevelCall = !initializing;
    if (isTopLevelCall) {
      initializing = true;
      initialized = true;
    }

    _;

    if (isTopLevelCall) {
      initializing = false;
    }
  }

  /// @dev Returns true if and only if the function is running in the constructor
  function isConstructor() private view returns (bool) {
    // extcodesize checks the size of the code stored in an address, and
    // address returns the current address. Since the code is still not
    // deployed when running a constructor, any checks on its code size will
    // yield zero, making it an effective way to detect if a contract is
    // under construction or not.
    address self = address(this);
    uint256 cs;
    assembly { cs := extcodesize(self) }
    return cs == 0;
  }

  // Reserved storage space to allow for layout changes in the future.
  uint256[50] private ______gap;
}",445
RealWorld_BA_47_ERC1820ImplementerUpgradeable_RealWord_20240820205229.log,47,ERC1820ImplementerUpgradeable,9357,5042,14399,95.0,0.147625,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./IERC1820ImplementerUpgradeable.sol"";
import ""../proxy/Initializable.sol"";

/**
 * @dev Implementation of the {IERC1820Implementer} interface.
 *
 * Contracts may inherit from this and call {_registerInterfaceForAddress} to
 * declare their willingness to be implementers.
 * {IERC1820Registry-setInterfaceImplementer} should then be called for the
 * registration to be complete.
 */
contract ERC1820ImplementerUpgradeable is Initializable, IERC1820ImplementerUpgradeable {
    function __ERC1820Implementer_init() internal initializer {
        __ERC1820Implementer_init_unchained();
    }

    function __ERC1820Implementer_init_unchained() internal initializer {
    }
    bytes32 constant private _ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(""ERC1820_ACCEPT_MAGIC""));

    mapping(bytes32 => mapping(address => bool)) private _supportedInterfaces;

    /**
     * See {IERC1820Implementer-canImplementInterfaceForAddress}.
     */
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) public view override returns (bytes32) {
        return _supportedInterfaces[interfaceHash][account] ? _ERC1820_ACCEPT_MAGIC : bytes32(0x00);
    }

    /**
     * @dev Declares the contract as willing to be an implementer of
     * `interfaceHash` for `account`.
     *
     * See {IERC1820Registry-setInterfaceImplementer} and
     * {IERC1820Registry-interfaceHash}.
     */
    function _registerInterfaceForAddress(bytes32 interfaceHash, address account) internal virtual {
        _supportedInterfaces[interfaceHash][account] = true;
    }
    uint256[49] private __gap;
}",389
RealWorld_BA_47_ERC1155PresetMinterPauserUpgradeable_RealWord_20240820210759.log,47,ERC1155PresetMinterPauserUpgradeable,19992,5469,25461,130.0,0.20934,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../access/AccessControlUpgradeable.sol"";
import ""../GSN/ContextUpgradeable.sol"";
import ""../token/ERC1155/ERC1155Upgradeable.sol"";
import ""../token/ERC1155/ERC1155BurnableUpgradeable.sol"";
import ""../token/ERC1155/ERC1155PausableUpgradeable.sol"";
import ""../proxy/Initializable.sol"";

/**
 * @dev {ERC1155} token, including:
 *
 *  - ability for holders to burn (destroy) their tokens
 *  - a minter role that allows for token minting (creation)
 *  - a pauser role that allows to stop all token transfers
 *
 * This contract uses {AccessControl} to lock permissioned functions using the
 * different roles - head to its documentation for details.
 *
 * The account that deploys the contract will be granted the minter and pauser
 * roles, as well as the default admin role, which will let it grant both minter
 * and pauser roles to other accounts.
 */
contract ERC1155PresetMinterPauserUpgradeable is Initializable, ContextUpgradeable, AccessControlUpgradeable, ERC1155BurnableUpgradeable, ERC1155PausableUpgradeable {
    function initialize(string memory uri) public virtual initializer {
        __ERC1155PresetMinterPauser_init(uri);
    }
    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");
    bytes32 public constant PAUSER_ROLE = keccak256(""PAUSER_ROLE"");

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE`, and `PAUSER_ROLE` to the account that
     * deploys the contract.
     */
    function __ERC1155PresetMinterPauser_init(string memory uri) internal initializer {
        __Context_init_unchained();
        __AccessControl_init_unchained();
        __ERC165_init_unchained();
        __ERC1155_init_unchained(uri);
        __ERC1155Burnable_init_unchained();
        __Pausable_init_unchained();
        __ERC1155Pausable_init_unchained();
        __ERC1155PresetMinterPauser_init_unchained(uri);
    }

    function __ERC1155PresetMinterPauser_init_unchained(string memory uri) internal initializer {
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());

        _setupRole(MINTER_ROLE, _msgSender());
        _setupRole(PAUSER_ROLE, _msgSender());
    }

    /**
     * @dev Creates `amount` new tokens for `to`, of token type `id`.
     *
     * See {ERC1155-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     */
    function mint(address to, uint256 id, uint256 amount, bytes memory data) public virtual {
        require(hasRole(MINTER_ROLE, _msgSender()), ""ERC1155PresetMinterPauser: must have minter role to mint"");

        _mint(to, id, amount, data);
    }

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] variant of {mint}.
     */
    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) public virtual {
        require(hasRole(MINTER_ROLE, _msgSender()), ""ERC1155PresetMinterPauser: must have minter role to mint"");

        _mintBatch(to, ids, amounts, data);
    }

    /**
     * @dev Pauses all token transfers.
     *
     * See {ERC1155Pausable} and {Pausable-_pause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function pause() public virtual {
        require(hasRole(PAUSER_ROLE, _msgSender()), ""ERC1155PresetMinterPauser: must have pauser role to pause"");
        _pause();
    }

    /**
     * @dev Unpauses all token transfers.
     *
     * See {ERC1155Pausable} and {Pausable-_unpause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function unpause() public virtual {
        require(hasRole(PAUSER_ROLE, _msgSender()), ""ERC1155PresetMinterPauser: must have pauser role to unpause"");
        _unpause();
    }

    function _beforeTokenTransfer(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    )
        internal virtual override(ERC1155Upgradeable, ERC1155PausableUpgradeable)
    {
        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);
    }
    uint256[50] private __gap;
}",1067
RealWorld_BA_47_AddressUpgradeable_RealWord_20240820204749.log,47,AddressUpgradeable,24718,4707,29425,86.0,0.21773,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

/**
 * @dev Collection of functions related to the address type
 */
library AddressUpgradeable {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies in extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, ""Address: insufficient balance"");

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }("""");
        require(success, ""Address: unable to send value, recipient may have reverted"");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain`call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, ""Address: low-level call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return _functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, ""Address: insufficient balance for call"");
        return _functionCallWithValue(target, data, value, errorMessage);
    }

    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
        require(isContract(target), ""Address: call to non-contract"");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}",1341
RealWorld_BA_47_PaymentSplitterUpgradeable_RealWord_20240820202646.log,47,PaymentSplitterUpgradeable,22970,5448,28418,105.0,0.22381,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../GSN/ContextUpgradeable.sol"";
import ""../math/SafeMathUpgradeable.sol"";
import ""../proxy/Initializable.sol"";

/**
 * @title PaymentSplitter
 * @dev This contract allows to split Ether payments among a group of accounts. The sender does not need to be aware
 * that the Ether will be split in this way, since it is handled transparently by the contract.
 *
 * The split can be in equal parts or in any other arbitrary proportion. The way this is specified is by assigning each
 * account to a number of shares. Of all the Ether that this contract receives, each account will then be able to claim
 * an amount proportional to the percentage of total shares they were assigned.
 *
 * `PaymentSplitter` follows a _pull payment_ model. This means that payments are not automatically forwarded to the
 * accounts but kept in this contract, and the actual transfer is triggered as a separate step by calling the {release}
 * function.
 */
contract PaymentSplitterUpgradeable is Initializable, ContextUpgradeable {
    using SafeMathUpgradeable for uint256;

    event PayeeAdded(address account, uint256 shares);
    event PaymentReleased(address to, uint256 amount);
    event PaymentReceived(address from, uint256 amount);

    uint256 private _totalShares;
    uint256 private _totalReleased;

    mapping(address => uint256) private _shares;
    mapping(address => uint256) private _released;
    address[] private _payees;

    /**
     * @dev Creates an instance of `PaymentSplitter` where each account in `payees` is assigned the number of shares at
     * the matching position in the `shares` array.
     *
     * All addresses in `payees` must be non-zero. Both arrays must have the same non-zero length, and there must be no
     * duplicates in `payees`.
     */
    function __PaymentSplitter_init(address[] memory payees, uint256[] memory shares) internal initializer {
        __Context_init_unchained();
        __PaymentSplitter_init_unchained(payees, shares);
    }

    function __PaymentSplitter_init_unchained(address[] memory payees, uint256[] memory shares) internal initializer {
        // solhint-disable-next-line max-line-length
        require(payees.length == shares.length, ""PaymentSplitter: payees and shares length mismatch"");
        require(payees.length > 0, ""PaymentSplitter: no payees"");

        for (uint256 i = 0; i < payees.length; i++) {
            _addPayee(payees[i], shares[i]);
        }
    }

    /**
     * @dev The Ether received will be logged with {PaymentReceived} events. Note that these events are not fully
     * reliable: it's possible for a contract to receive Ether without triggering this function. This only affects the
     * reliability of the events, and not the actual splitting of Ether.
     *
     * To learn more about this see the Solidity documentation for
     * https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function[fallback
     * functions].
     */
    receive () external payable virtual {
        emit PaymentReceived(_msgSender(), msg.value);
    }

    /**
     * @dev Getter for the total shares held by payees.
     */
    function totalShares() public view returns (uint256) {
        return _totalShares;
    }

    /**
     * @dev Getter for the total amount of Ether already released.
     */
    function totalReleased() public view returns (uint256) {
        return _totalReleased;
    }

    /**
     * @dev Getter for the amount of shares held by an account.
     */
    function shares(address account) public view returns (uint256) {
        return _shares[account];
    }

    /**
     * @dev Getter for the amount of Ether already released to a payee.
     */
    function released(address account) public view returns (uint256) {
        return _released[account];
    }

    /**
     * @dev Getter for the address of the payee number `index`.
     */
    function payee(uint256 index) public view returns (address) {
        return _payees[index];
    }

    /**
     * @dev Triggers a transfer to `account` of the amount of Ether they are owed, according to their percentage of the
     * total shares and their previous withdrawals.
     */
    function release(address payable account) public virtual {
        require(_shares[account] > 0, ""PaymentSplitter: account has no shares"");

        uint256 totalReceived = address(this).balance.add(_totalReleased);
        uint256 payment = totalReceived.mul(_shares[account]).div(_totalShares).sub(_released[account]);

        require(payment != 0, ""PaymentSplitter: account is not due payment"");

        _released[account] = _released[account].add(payment);
        _totalReleased = _totalReleased.add(payment);

        account.transfer(payment);
        emit PaymentReleased(account, payment);
    }

    /**
     * @dev Add a new payee to the contract.
     * @param account The address of the payee to add.
     * @param shares_ The number of shares owned by the payee.
     */
    function _addPayee(address account, uint256 shares_) private {
        require(account != address(0), ""PaymentSplitter: account is the zero address"");
        require(shares_ > 0, ""PaymentSplitter: shares are 0"");
        require(_shares[account] == 0, ""PaymentSplitter: account already has shares"");

        _payees.push(account);
        _shares[account] = shares_;
        _totalShares = _totalShares.add(shares_);
        emit PayeeAdded(account, shares_);
    }
    uint256[45] private __gap;
}",1244
RealWorld_BA_47_Package_RealWord_20240820190305.log,47,Package,25650,5836,31486,93.0,0.24497,"pragma solidity ^0.5.0;

import ""../ownership/Ownable.sol"";

/**
 * @title Package
 * @dev A package is composed by a set of versions, identified via semantic versioning,
 * where each version has a contract address that refers to a reusable implementation,
 * plus an optional content URI with metadata. Note that the semver identifier is restricted
 * to major, minor, and patch, as prerelease tags are not supported.
 */
contract Package is OpenZeppelinUpgradesOwnable {
  /**
   * @dev Emitted when a version is added to the package.
   * @param semanticVersion Name of the added version.
   * @param contractAddress Contract associated with the version.
   * @param contentURI Optional content URI with metadata of the version.
   */
  event VersionAdded(uint64[3] semanticVersion, address contractAddress, bytes contentURI);

  struct Version {
    uint64[3] semanticVersion;
    address contractAddress;
    bytes contentURI; 
  }

  mapping (bytes32 => Version) internal versions;
  mapping (uint64 => bytes32) internal majorToLatestVersion;
  uint64 internal latestMajor;

  /**
   * @dev Returns a version given its semver identifier.
   * @param semanticVersion Semver identifier of the version.
   * @return Contract address and content URI for the version, or zero if not exists.
   */
  function getVersion(uint64[3] memory semanticVersion) public view returns (address contractAddress, bytes memory contentURI) {
    Version storage version = versions[semanticVersionHash(semanticVersion)];
    return (version.contractAddress, version.contentURI); 
  }

  /**
   * @dev Returns a contract for a version given its semver identifier.
   * This method is equivalent to `getVersion`, but returns only the contract address.
   * @param semanticVersion Semver identifier of the version.
   * @return Contract address for the version, or zero if not exists.
   */
  function getContract(uint64[3] memory semanticVersion) public view returns (address contractAddress) {
    Version storage version = versions[semanticVersionHash(semanticVersion)];
    return version.contractAddress;
  }

  /**
   * @dev Adds a new version to the package. Only the Owner can add new versions.
   * Reverts if the specified semver identifier already exists. 
   * Emits a `VersionAdded` event if successful.
   * @param semanticVersion Semver identifier of the version.
   * @param contractAddress Contract address for the version, must be non-zero.
   * @param contentURI Optional content URI for the version.
   */
  function addVersion(uint64[3] memory semanticVersion, address contractAddress, bytes memory contentURI) public onlyOwner {
    require(contractAddress != address(0), ""Contract address is required"");
    require(!hasVersion(semanticVersion), ""Given version is already registered in package"");
    require(!semanticVersionIsZero(semanticVersion), ""Version must be non zero"");

    // Register version
    bytes32 versionId = semanticVersionHash(semanticVersion);
    versions[versionId] = Version(semanticVersion, contractAddress, contentURI);
    
    // Update latest major
    uint64 major = semanticVersion[0];
    if (major > latestMajor) {
      latestMajor = semanticVersion[0];
    }

    // Update latest version for this major
    uint64 minor = semanticVersion[1];
    uint64 patch = semanticVersion[2];
    uint64[3] storage latestVersionForMajor = versions[majorToLatestVersion[major]].semanticVersion;
    if (semanticVersionIsZero(latestVersionForMajor) // No latest was set for this major
       || (minor > latestVersionForMajor[1]) // Or current minor is greater 
       || (minor == latestVersionForMajor[1] && patch > latestVersionForMajor[2]) // Or current patch is greater
       ) { 
      majorToLatestVersion[major] = versionId;
    }

    emit VersionAdded(semanticVersion, contractAddress, contentURI);
  }

  /**
   * @dev Checks whether a version is present in the package.
   * @param semanticVersion Semver identifier of the version.
   * @return true if the version is registered in this package, false otherwise.
   */
  function hasVersion(uint64[3] memory semanticVersion) public view returns (bool) {
    Version storage version = versions[semanticVersionHash(semanticVersion)];
    return address(version.contractAddress) != address(0);
  }

  /**
   * @dev Returns the version with the highest semver identifier registered in the package.
   * For instance, if `1.2.0`, `1.3.0`, and `2.0.0` are present, will always return `2.0.0`, regardless 
   * of the order in which they were registered. Returns zero if no versions are registered.
   * @return Semver identifier, contract address, and content URI for the version, or zero if not exists.
   */
  function getLatest() public view returns (uint64[3] memory semanticVersion, address contractAddress, bytes memory contentURI) {
    return getLatestByMajor(latestMajor);
  }

  /**
   * @dev Returns the version with the highest semver identifier for the given major.
   * For instance, if `1.2.0`, `1.3.0`, and `2.0.0` are present, will return `1.3.0` for major `1`, 
   * regardless of the order in which they were registered. Returns zero if no versions are registered
   * for the specified major.
   * @param major Major identifier to query
   * @return Semver identifier, contract address, and content URI for the version, or zero if not exists.
   */
  function getLatestByMajor(uint64 major) public view returns (uint64[3] memory semanticVersion, address contractAddress, bytes memory contentURI) {
    Version storage version = versions[majorToLatestVersion[major]];
    return (version.semanticVersion, version.contractAddress, version.contentURI); 
  }

  function semanticVersionHash(uint64[3] memory version) internal pure returns (bytes32) {
    return keccak256(abi.encodePacked(version[0], version[1], version[2]));
  }

  function semanticVersionIsZero(uint64[3] memory version) internal pure returns (bool) {
    return version[0] == 0 && version[1] == 0 && version[2] == 0;
  }
}",1389
RealWorld_BA_47_MathUpgradeable_RealWord_20240820210242.log,47,MathUpgradeable,6746,4046,10792,74.0,0.11465,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Standard math utilities missing in the Solidity language.
 */
library MathUpgradeable {
    /**
     * @dev Returns the largest of two numbers.
     */
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? a : b;
    }

    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two numbers. The result is rounded towards
     * zero.
     */
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow, so we distribute
        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
    }
}",223
RealWorld_BA_47_IERC1820ImplementerUpgradeable_RealWord_20240820204917.log,47,IERC1820ImplementerUpgradeable,5952,4287,10239,79.0,0.1155,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface for an ERC1820 implementer, as defined in the
 * https://eips.ethereum.org/EIPS/eip-1820#interface-implementation-erc1820implementerinterface[EIP].
 * Used by contracts that will be registered as implementers in the
 * {IERC1820Registry}.
 */
interface IERC1820ImplementerUpgradeable {
    /**
     * @dev Returns a special value (`ERC1820_ACCEPT_MAGIC`) if this contract
     * implements `interfaceHash` for `account`.
     *
     * See {IERC1820Registry-setInterfaceImplementer}.
     */
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external view returns (bytes32);
}",169
RealWorld_BA_47_IERC777SenderUpgradeable_RealWord_20240820193757.log,47,IERC777SenderUpgradeable,7414,4989,12403,92.0,0.13685,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface of the ERC777TokensSender standard as defined in the EIP.
 *
 * {IERC777} Token holders can be notified of operations performed on their
 * tokens by having a contract implement this interface (contract holders can be
 *  their own implementer) and registering it on the
 * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].
 *
 * See {IERC1820Registry} and {ERC1820Implementer}.
 */
interface IERC777SenderUpgradeable {
    /**
     * @dev Called by an {IERC777} token contract whenever a registered holder's
     * (`from`) tokens are about to be moved or destroyed. The type of operation
     * is conveyed by `to` being the zero address or not.
     *
     * This call occurs _before_ the token contract's state is updated, so
     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.
     *
     * This function may revert to prevent the operation from being executed.
     */
    function tokensToSend(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external;
}",286
RealWorld_BA_47_ERC20Upgradeable_RealWord_20240820192141.log,47,ERC20Upgradeable,45213,5435,50648,99.0,0.334765,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../../GSN/ContextUpgradeable.sol"";
import ""./IERC20Upgradeable.sol"";
import ""../../math/SafeMathUpgradeable.sol"";
import ""../../utils/AddressUpgradeable.sol"";
import ""../../proxy/Initializable.sol"";

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {
    using SafeMathUpgradeable for uint256;
    using AddressUpgradeable for address;

    mapping (address => uint256) internal _balances;

    mapping (address => mapping (address => uint256)) internal _allowances;

    uint256 internal _totalSupply;

    string internal _name;
    string internal _symbol;
    uint8 internal _decimals;

    /**
     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with
     * a default value of 18.
     *
     * To select a different value for {decimals}, use {_setupDecimals}.
     *
     * All three of these values are immutable: they can only be set once during
     * construction.
     */
    function __ERC20_init(string memory name, string memory symbol) internal initializer {
        __Context_init_unchained();
        __ERC20_init_unchained(name, symbol);
    }

    function __ERC20_init_unchained(string memory name, string memory symbol) internal initializer {
        _name = name;
        _symbol = symbol;
        _decimals = 18;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is
     * called.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view returns (uint8) {
        return _decimals;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, ""ERC20: decreased allowance below zero""));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] = _balances[sender].sub(amount, ""ERC20: transfer amount exceeds balance"");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, ""ERC20: burn amount exceeds balance"");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Sets {decimals} to a value other than the default one of 18.
     *
     * WARNING: This function should only be called from the constructor. Most
     * applications that interact with token contracts will not expect
     * {decimals} to ever change, and may work incorrectly if it does.
     */
    function _setupDecimals(uint8 decimals_) internal {
        _decimals = decimals_;
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be to transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
    uint256[44] private __gap;
}",2654
RealWorld_BA_47_ERC721HolderUpgradeable_RealWord_20240820194927.log,47,ERC721HolderUpgradeable,6850,4283,11133,87.0,0.11991,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./IERC721ReceiverUpgradeable.sol"";
import ""../../proxy/Initializable.sol"";

  /**
   * @dev Implementation of the {IERC721Receiver} interface.
   *
   * Accepts all token transfers. 
   * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.
   */
contract ERC721HolderUpgradeable is Initializable, IERC721ReceiverUpgradeable {
    function __ERC721Holder_init() internal initializer {
        __ERC721Holder_init_unchained();
    }

    function __ERC721Holder_init_unchained() internal initializer {
    }

    /**
     * @dev See {IERC721Receiver-onERC721Received}.
     *
     * Always returns `IERC721Receiver.onERC721Received.selector`.
     */
    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {
        return this.onERC721Received.selector;
    }
    uint256[50] private __gap;
}",241
RealWorld_BA_47_Ownable_RealWord_20240820190011.log,47,Ownable,12679,5300,17979,86.0,0.169395,"pragma solidity ^0.5.0;

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of ""user permissions"".
 *
 * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/ownership/Ownable.sol
 * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts
 * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the
 * build/artifacts folder) as well as the vanilla Ownable implementation from an openzeppelin version.
 */
contract OpenZeppelinUpgradesOwnable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev The Ownable constructor sets the original `owner` of the contract to the sender
     * account.
     */
    constructor () internal {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    /**
     * @return the address of the owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(isOwner());
        _;
    }

    /**
     * @return true if `msg.sender` is the owner of the contract.
     */
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * @notice Renouncing to ownership will leave the contract without an owner.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     */
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}",559
RealWorld_BA_47_SafeERC20Upgradeable_RealWord_20240820193131.log,47,SafeERC20Upgradeable,16760,5272,22032,99.0,0.18924,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./IERC20Upgradeable.sol"";
import ""../../math/SafeMathUpgradeable.sol"";
import ""../../utils/AddressUpgradeable.sol"";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20Upgradeable {
    using SafeMathUpgradeable for uint256;
    using AddressUpgradeable for address;

    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            ""SafeERC20: approve from non-zero to non-zero allowance""
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, ""SafeERC20: decreased allowance below zero"");
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, ""SafeERC20: low-level call failed"");
        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), ""SafeERC20: ERC20 operation did not succeed"");
        }
    }
}",866
RealWorld_BA_47_ArraysUpgradeable_RealWord_20240820204251.log,47,ArraysUpgradeable,8838,4680,13518,107.0,0.13779,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../math/MathUpgradeable.sol"";

/**
 * @dev Collection of functions related to array types.
 */
library ArraysUpgradeable {
   /**
     * @dev Searches a sorted `array` and returns the first index that contains
     * a value greater or equal to `element`. If no such index exists (i.e. all
     * values in the array are strictly less than `element`), the array length is
     * returned. Time complexity O(log n).
     *
     * `array` is expected to be sorted in ascending order, and to contain no
     * repeated elements.
     */
    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {
        if (array.length == 0) {
            return 0;
        }

        uint256 low = 0;
        uint256 high = array.length;

        while (low < high) {
            uint256 mid = MathUpgradeable.average(low, high);

            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
            // because Math.average rounds down (it does integer division with truncation).
            if (array[mid] > element) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.
        if (low > 0 && array[low - 1] == element) {
            return low - 1;
        } else {
            return low;
        }
    }
}",350
RealWorld_BA_47_SignedSafeMathUpgradeable_RealWord_20240820205854.log,47,SignedSafeMathUpgradeable,13638,4588,18226,120.0,0.15995,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @title SignedSafeMath
 * @dev Signed math operations with safety checks that revert on error.
 */
library SignedSafeMathUpgradeable {
    int256 constant private _INT256_MIN = -2**255;

    /**
     * @dev Returns the multiplication of two signed integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(int256 a, int256 b) internal pure returns (int256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        require(!(a == -1 && b == _INT256_MIN), ""SignedSafeMath: multiplication overflow"");

        int256 c = a * b;
        require(c / a == b, ""SignedSafeMath: multiplication overflow"");

        return c;
    }

    /**
     * @dev Returns the integer division of two signed integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(int256 a, int256 b) internal pure returns (int256) {
        require(b != 0, ""SignedSafeMath: division by zero"");
        require(!(b == -1 && a == _INT256_MIN), ""SignedSafeMath: division overflow"");

        int256 c = a / b;

        return c;
    }

    /**
     * @dev Returns the subtraction of two signed integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(int256 a, int256 b) internal pure returns (int256) {
        int256 c = a - b;
        require((b >= 0 && c <= a) || (b < 0 && c > a), ""SignedSafeMath: subtraction overflow"");

        return c;
    }

    /**
     * @dev Returns the addition of two signed integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(int256 a, int256 b) internal pure returns (int256) {
        int256 c = a + b;
        require((b >= 0 && c >= a) || (b < 0 && c < a), ""SignedSafeMath: addition overflow"");

        return c;
    }
}",676
RealWorld_BA_47_CountersUpgradeable_RealWord_20240820204124.log,47,CountersUpgradeable,8804,4300,13104,85.0,0.13002,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../math/SafeMathUpgradeable.sol"";

/**
 * @title Counters
 * @author Matt Condon (@shrugs)
 * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number
 * of elements in a mapping, issuing ERC721 ids, or counting request ids.
 *
 * Include with `using Counters for Counters.Counter;`
 * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}
 * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never
 * directly accessed.
 */
library CountersUpgradeable {
    using SafeMathUpgradeable for uint256;

    struct Counter {
        // This variable should never be directly accessed by users of the library: interactions must be restricted to
        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add
        // this feature: see https://github.com/ethereum/solidity/issues/4637
        uint256 _value; // default: 0
    }

    function current(Counter storage counter) internal view returns (uint256) {
        return counter._value;
    }

    function increment(Counter storage counter) internal {
        // The {SafeMath} overflow check can be skipped here, see the comment at the top
        counter._value += 1;
    }

    function decrement(Counter storage counter) internal {
        counter._value = counter._value.sub(1);
    }
}",356
RealWorld_BA_47_ERC1155ReceiverUpgradeable_RealWord_20240820195553.log,47,ERC1155ReceiverUpgradeable,6342,4661,11003,92.0,0.12493,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./IERC1155ReceiverUpgradeable.sol"";
import ""../../introspection/ERC165Upgradeable.sol"";
import ""../../proxy/Initializable.sol"";

/**
 * @dev _Available since v3.1._
 */
abstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {
    function __ERC1155Receiver_init() internal initializer {
        __ERC165_init_unchained();
        __ERC1155Receiver_init_unchained();
    }

    function __ERC1155Receiver_init_unchained() internal initializer {
        _registerInterface(
            ERC1155ReceiverUpgradeable(0).onERC1155Received.selector ^
            ERC1155ReceiverUpgradeable(0).onERC1155BatchReceived.selector
        );
    }
    uint256[50] private __gap;
}",188
RealWorld_BA_47_GSNRecipientUpgradeable_RealWord_20240820201219.log,47,GSNRecipientUpgradeable,41946,5148,47094,105.0,0.31269,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./IRelayRecipientUpgradeable.sol"";
import ""./IRelayHubUpgradeable.sol"";
import ""./ContextUpgradeable.sol"";
import ""../proxy/Initializable.sol"";

/**
 * @dev Base GSN recipient contract: includes the {IRelayRecipient} interface
 * and enables GSN support on all contracts in the inheritance tree.
 *
 * TIP: This contract is abstract. The functions {IRelayRecipient-acceptRelayedCall},
 *  {_preRelayedCall}, and {_postRelayedCall} are not implemented and must be
 * provided by derived contracts. See the
 * xref:ROOT:gsn-strategies.adoc#gsn-strategies[GSN strategies] for more
 * information on how to use the pre-built {GSNRecipientSignature} and
 * {GSNRecipientERC20Fee}, or how to write your own.
 */
abstract contract GSNRecipientUpgradeable is Initializable, IRelayRecipientUpgradeable, ContextUpgradeable {
    function __GSNRecipient_init() internal initializer {
        __Context_init_unchained();
        __GSNRecipient_init_unchained();
    }

    function __GSNRecipient_init_unchained() internal initializer {
        _relayHub = 0xD216153c06E857cD7f72665E0aF1d7D82172F494;
    }
    // Default RelayHub address, deployed on mainnet and all testnets at the same address
    address private _relayHub;

    uint256 constant private _RELAYED_CALL_ACCEPTED = 0;
    uint256 constant private _RELAYED_CALL_REJECTED = 11;

    // How much gas is forwarded to postRelayedCall
    uint256 constant internal _POST_RELAYED_CALL_MAX_GAS = 100000;

    /**
     * @dev Emitted when a contract changes its {IRelayHub} contract to a new one.
     */
    event RelayHubChanged(address indexed oldRelayHub, address indexed newRelayHub);

    /**
     * @dev Returns the address of the {IRelayHub} contract for this recipient.
     */
    function getHubAddr() public view override returns (address) {
        return _relayHub;
    }

    /**
     * @dev Switches to a new {IRelayHub} instance. This method is added for future-proofing: there's no reason to not
     * use the default instance.
     *
     * IMPORTANT: After upgrading, the {GSNRecipient} will no longer be able to receive relayed calls from the old
     * {IRelayHub} instance. Additionally, all funds should be previously withdrawn via {_withdrawDeposits}.
     */
    function _upgradeRelayHub(address newRelayHub) internal virtual {
        address currentRelayHub = _relayHub;
        require(newRelayHub != address(0), ""GSNRecipient: new RelayHub is the zero address"");
        require(newRelayHub != currentRelayHub, ""GSNRecipient: new RelayHub is the current one"");

        emit RelayHubChanged(currentRelayHub, newRelayHub);

        _relayHub = newRelayHub;
    }

    /**
     * @dev Returns the version string of the {IRelayHub} for which this recipient implementation was built. If
     * {_upgradeRelayHub} is used, the new {IRelayHub} instance should be compatible with this version.
     */
    // This function is view for future-proofing, it may require reading from
    // storage in the future.
    function relayHubVersion() public view returns (string memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return ""1.0.0"";
    }

    /**
     * @dev Withdraws the recipient's deposits in `RelayHub`.
     *
     * Derived contracts should expose this in an external interface with proper access control.
     */
    function _withdrawDeposits(uint256 amount, address payable payee) internal virtual {
        IRelayHubUpgradeable(_relayHub).withdraw(amount, payee);
    }

    // Overrides for Context's functions: when called from RelayHub, sender and
    // data require some pre-processing: the actual sender is stored at the end
    // of the call data, which in turns means it needs to be removed from it
    // when handling said data.

    /**
     * @dev Replacement for msg.sender. Returns the actual sender of a transaction: msg.sender for regular transactions,
     * and the end-user for GSN relayed calls (where msg.sender is actually `RelayHub`).
     *
     * IMPORTANT: Contracts derived from {GSNRecipient} should never use `msg.sender`, and use {_msgSender} instead.
     */
    function _msgSender() internal view virtual override returns (address payable) {
        if (msg.sender != _relayHub) {
            return msg.sender;
        } else {
            return _getRelayedCallSender();
        }
    }

    /**
     * @dev Replacement for msg.data. Returns the actual calldata of a transaction: msg.data for regular transactions,
     * and a reduced version for GSN relayed calls (where msg.data contains additional information).
     *
     * IMPORTANT: Contracts derived from {GSNRecipient} should never use `msg.data`, and use {_msgData} instead.
     */
    function _msgData() internal view virtual override returns (bytes memory) {
        if (msg.sender != _relayHub) {
            return msg.data;
        } else {
            return _getRelayedCallData();
        }
    }

    // Base implementations for pre and post relayedCall: only RelayHub can invoke them, and data is forwarded to the
    // internal hook.

    /**
     * @dev See `IRelayRecipient.preRelayedCall`.
     *
     * This function should not be overridden directly, use `_preRelayedCall` instead.
     *
     * * Requirements:
     *
     * - the caller must be the `RelayHub` contract.
     */
    function preRelayedCall(bytes memory context) public virtual override returns (bytes32) {
        require(msg.sender == getHubAddr(), ""GSNRecipient: caller is not RelayHub"");
        return _preRelayedCall(context);
    }

    /**
     * @dev See `IRelayRecipient.preRelayedCall`.
     *
     * Called by `GSNRecipient.preRelayedCall`, which asserts the caller is the `RelayHub` contract. Derived contracts
     * must implement this function with any relayed-call preprocessing they may wish to do.
     *
     */
    function _preRelayedCall(bytes memory context) internal virtual returns (bytes32);

    /**
     * @dev See `IRelayRecipient.postRelayedCall`.
     *
     * This function should not be overridden directly, use `_postRelayedCall` instead.
     *
     * * Requirements:
     *
     * - the caller must be the `RelayHub` contract.
     */
    function postRelayedCall(bytes memory context, bool success, uint256 actualCharge, bytes32 preRetVal) public virtual override {
        require(msg.sender == getHubAddr(), ""GSNRecipient: caller is not RelayHub"");
        _postRelayedCall(context, success, actualCharge, preRetVal);
    }

    /**
     * @dev See `IRelayRecipient.postRelayedCall`.
     *
     * Called by `GSNRecipient.postRelayedCall`, which asserts the caller is the `RelayHub` contract. Derived contracts
     * must implement this function with any relayed-call postprocessing they may wish to do.
     *
     */
    function _postRelayedCall(bytes memory context, bool success, uint256 actualCharge, bytes32 preRetVal) internal virtual;

    /**
     * @dev Return this in acceptRelayedCall to proceed with the execution of a relayed call. Note that this contract
     * will be charged a fee by RelayHub
     */
    function _approveRelayedCall() internal pure returns (uint256, bytes memory) {
        return _approveRelayedCall("""");
    }

    /**
     * @dev See `GSNRecipient._approveRelayedCall`.
     *
     * This overload forwards `context` to _preRelayedCall and _postRelayedCall.
     */
    function _approveRelayedCall(bytes memory context) internal pure returns (uint256, bytes memory) {
        return (_RELAYED_CALL_ACCEPTED, context);
    }

    /**
     * @dev Return this in acceptRelayedCall to impede execution of a relayed call. No fees will be charged.
     */
    function _rejectRelayedCall(uint256 errorCode) internal pure returns (uint256, bytes memory) {
        return (_RELAYED_CALL_REJECTED + errorCode, """");
    }

    /*
     * @dev Calculates how much RelayHub will charge a recipient for using `gas` at a `gasPrice`, given a relayer's
     * `serviceFee`.
     */
    function _computeCharge(uint256 gas, uint256 gasPrice, uint256 serviceFee) internal pure returns (uint256) {
        // The fee is expressed as a percentage. E.g. a value of 40 stands for a 40% fee, so the recipient will be
        // charged for 1.4 times the spent amount.
        return (gas * gasPrice * (100 + serviceFee)) / 100;
    }

    function _getRelayedCallSender() private pure returns (address payable result) {
        // We need to read 20 bytes (an address) located at array index msg.data.length - 20. In memory, the array
        // is prefixed with a 32-byte length value, so we first add 32 to get the memory read index. However, doing
        // so would leave the address in the upper 20 bytes of the 32-byte word, which is inconvenient and would
        // require bit shifting. We therefore subtract 12 from the read index so the address lands on the lower 20
        // bytes. This can always be done due to the 32-byte prefix.

        // The final memory read index is msg.data.length - 20 + 32 - 12 = msg.data.length. Using inline assembly is the
        // easiest/most-efficient way to perform this operation.

        // These fields are not accessible from assembly
        bytes memory array = msg.data;
        uint256 index = msg.data.length;

        // solhint-disable-next-line no-inline-assembly
        assembly {
            // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.
            result := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)
        }
        return result;
    }

    function _getRelayedCallData() private pure returns (bytes memory) {
        // RelayHub appends the sender address at the end of the calldata, so in order to retrieve the actual msg.data,
        // we must strip the last 20 bytes (length of an address type) from it.

        uint256 actualDataLength = msg.data.length - 20;
        bytes memory actualData = new bytes(actualDataLength);

        for (uint256 i = 0; i < actualDataLength; ++i) {
            actualData[i] = msg.data[i];
        }

        return actualData;
    }
    uint256[49] private __gap;
}",2425
RealWorld_BA_47_GSNRecipientSignatureUpgradeable_RealWord_20240820202047.log,47,GSNRecipientSignatureUpgradeable,13537,5840,19377,92.0,0.184485,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./GSNRecipientUpgradeable.sol"";
import ""../cryptography/ECDSAUpgradeable.sol"";
import ""../proxy/Initializable.sol"";

/**
 * @dev A xref:ROOT:gsn-strategies.adoc#gsn-strategies[GSN strategy] that allows relayed transactions through when they are
 * accompanied by the signature of a trusted signer. The intent is for this signature to be generated by a server that
 * performs validations off-chain. Note that nothing is charged to the user in this scheme. Thus, the server should make
 * sure to account for this in their economic and threat model.
 */
contract GSNRecipientSignatureUpgradeable is Initializable, GSNRecipientUpgradeable {
    using ECDSAUpgradeable for bytes32;

    address private _trustedSigner;

    enum GSNRecipientSignatureErrorCodes {
        INVALID_SIGNER
    }

    /**
     * @dev Sets the trusted signer that is going to be producing signatures to approve relayed calls.
     */
    function __GSNRecipientSignature_init(address trustedSigner) internal initializer {
        __Context_init_unchained();
        __GSNRecipient_init_unchained();
        __GSNRecipientSignature_init_unchained(trustedSigner);
    }

    function __GSNRecipientSignature_init_unchained(address trustedSigner) internal initializer {
        require(trustedSigner != address(0), ""GSNRecipientSignature: trusted signer is the zero address"");
        _trustedSigner = trustedSigner;
    }

    /**
     * @dev Ensures that only transactions with a trusted signature can be relayed through the GSN.
     */
    function acceptRelayedCall(
        address relay,
        address from,
        bytes memory encodedFunction,
        uint256 transactionFee,
        uint256 gasPrice,
        uint256 gasLimit,
        uint256 nonce,
        bytes memory approvalData,
        uint256
    )
        public
        view
        virtual
        override
        returns (uint256, bytes memory)
    {
        bytes memory blob = abi.encodePacked(
            relay,
            from,
            encodedFunction,
            transactionFee,
            gasPrice,
            gasLimit,
            nonce, // Prevents replays on RelayHub
            getHubAddr(), // Prevents replays in multiple RelayHubs
            address(this) // Prevents replays in multiple recipients
        );
        if (keccak256(blob).toEthSignedMessageHash().recover(approvalData) == _trustedSigner) {
            return _approveRelayedCall();
        } else {
            return _rejectRelayedCall(uint256(GSNRecipientSignatureErrorCodes.INVALID_SIGNER));
        }
    }

    function _preRelayedCall(bytes memory) internal virtual override returns (bytes32) { }

    function _postRelayedCall(bytes memory, bool, uint256, bytes32) internal virtual override { }
    uint256[49] private __gap;
}",621
RealWorld_BA_47_AdminUpgradeabilityProxy_RealWord_20240820190729.log,47,AdminUpgradeabilityProxy,7624,5158,12782,98.0,0.14128,"pragma solidity ^0.5.0;

import './BaseAdminUpgradeabilityProxy.sol';

/**
 * @title AdminUpgradeabilityProxy
 * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for 
 * initializing the implementation, admin, and init data.
 */
contract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {
  /**
   * Contract constructor.
   * @param _logic address of the initial implementation.
   * @param _admin Address of the proxy administrator.
   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.
   * It should include the signature and the parameters of the function to be called, as described in
   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.
   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.
   */
  constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) public payable {
    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));
    _setAdmin(_admin);
  }
}",263
RealWorld_BA_47_Address_RealWord_20240820185859.log,47,Address,8867,4363,13230,70.0,0.131595,"pragma solidity ^0.5.0;

/**
 * Utility library of inline functions on addresses
 *
 * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/utils/Address.sol
 * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts
 * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the
 * build/artifacts folder) as well as the vanilla Address implementation from an openzeppelin version.
 */
library OpenZeppelinUpgradesAddress {
    /**
     * Returns whether the target address is a contract
     * @dev This function will return false if invoked during the constructor of a contract,
     * as the code is not actually created until after the constructor finishes.
     * @param account address of the account to check
     * @return whether the target address is a contract
     */
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        // XXX Currently there is no better way to check if there is a contract in an address
        // than to check the size of the code at that address.
        // See https://ethereum.stackexchange.com/a/14016/36603
        // for more details about how this works.
        // TODO Check this again before the Serenity release, because all addresses will be
        // contracts then.
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}",329
RealWorld_BA_47_EnumerableSetUpgradeable_RealWord_20240820204440.log,47,EnumerableSetUpgradeable,33663,5321,38984,99.0,0.274735,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Library for managing
 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive
 * types.
 *
 * Sets have the following properties:
 *
 * - Elements are added, removed, and checked for existence in constant time
 * (O(1)).
 * - Elements are enumerated in O(n). No guarantees are made on the ordering.
 *
 * ```
 * contract Example {
 *     // Add the library methods
 *     using EnumerableSet for EnumerableSet.AddressSet;
 *
 *     // Declare a set state variable
 *     EnumerableSet.AddressSet private mySet;
 * }
 * ```
 *
 * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`
 * (`UintSet`) are supported.
 */
library EnumerableSetUpgradeable {
    // To implement this library for multiple types with as little code
    // repetition as possible, we write it in terms of a generic Set type with
    // bytes32 values.
    // The Set implementation uses private functions, and user-facing
    // implementations (such as AddressSet) are just wrappers around the
    // underlying Set.
    // This means that we can only create new EnumerableSets for types that fit
    // in bytes32.

    struct Set {
        // Storage of set values
        bytes32[] _values;

        // Position of the value in the `values` array, plus 1 because index 0
        // means a value is not in the set.
        mapping (bytes32 => uint256) _indexes;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function _add(Set storage set, bytes32 value) private returns (bool) {
        if (!_contains(set, value)) {
            set._values.push(value);
            // The value is stored at length-1, but we add 1 to all indexes
            // and use 0 as a sentinel value
            set._indexes[value] = set._values.length;
            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function _remove(Set storage set, bytes32 value) private returns (bool) {
        // We read and store the value's index to prevent multiple reads from the same storage slot
        uint256 valueIndex = set._indexes[value];

        if (valueIndex != 0) { // Equivalent to contains(set, value)
            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in
            // the array, and then remove the last element (sometimes called as 'swap and pop').
            // This modifies the order of the array, as noted in {at}.

            uint256 toDeleteIndex = valueIndex - 1;
            uint256 lastIndex = set._values.length - 1;

            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs
            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.

            bytes32 lastvalue = set._values[lastIndex];

            // Move the last value to the index where the value to delete is
            set._values[toDeleteIndex] = lastvalue;
            // Update the index for the moved value
            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based

            // Delete the slot where the moved value was stored
            set._values.pop();

            // Delete the index for the deleted slot
            delete set._indexes[value];

            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function _contains(Set storage set, bytes32 value) private view returns (bool) {
        return set._indexes[value] != 0;
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function _length(Set storage set) private view returns (uint256) {
        return set._values.length;
    }

   /**
    * @dev Returns the value stored at position `index` in the set. O(1).
    *
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function _at(Set storage set, uint256 index) private view returns (bytes32) {
        require(set._values.length > index, ""EnumerableSet: index out of bounds"");
        return set._values[index];
    }

    // AddressSet

    struct AddressSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(AddressSet storage set, address value) internal returns (bool) {
        return _add(set._inner, bytes32(uint256(value)));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(AddressSet storage set, address value) internal returns (bool) {
        return _remove(set._inner, bytes32(uint256(value)));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(AddressSet storage set, address value) internal view returns (bool) {
        return _contains(set._inner, bytes32(uint256(value)));
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(AddressSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

   /**
    * @dev Returns the value stored at position `index` in the set. O(1).
    *
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function at(AddressSet storage set, uint256 index) internal view returns (address) {
        return address(uint256(_at(set._inner, index)));
    }


    // UintSet

    struct UintSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(UintSet storage set, uint256 value) internal returns (bool) {
        return _add(set._inner, bytes32(value));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(UintSet storage set, uint256 value) internal returns (bool) {
        return _remove(set._inner, bytes32(value));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(UintSet storage set, uint256 value) internal view returns (bool) {
        return _contains(set._inner, bytes32(value));
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function length(UintSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

   /**
    * @dev Returns the value stored at position `index` in the set. O(1).
    *
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function at(UintSet storage set, uint256 index) internal view returns (uint256) {
        return uint256(_at(set._inner, index));
    }
}",1869
RealWorld_BA_47_ERC1155HolderUpgradeable_RealWord_20240820200340.log,47,ERC1155HolderUpgradeable,6673,5256,11929,87.0,0.138485,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./ERC1155ReceiverUpgradeable.sol"";
import ""../../proxy/Initializable.sol"";

/**
 * @dev _Available since v3.1._
 */
contract ERC1155HolderUpgradeable is Initializable, ERC1155ReceiverUpgradeable {
    function __ERC1155Holder_init() internal initializer {
        __ERC165_init_unchained();
        __ERC1155Receiver_init_unchained();
        __ERC1155Holder_init_unchained();
    }

    function __ERC1155Holder_init_unchained() internal initializer {
    }
    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {
        return this.onERC1155Received.selector;
    }

    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {
        return this.onERC1155BatchReceived.selector;
    }
    uint256[50] private __gap;
}",226
RealWorld_BA_47_IERC721MetadataUpgradeable_RealWord_20240820194758.log,47,IERC721MetadataUpgradeable,5597,4306,9903,87.0,0.114105,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""./IERC721Upgradeable.sol"";

/**
 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */
interface IERC721MetadataUpgradeable is IERC721Upgradeable {

    /**
     * @dev Returns the token collection name.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the token collection symbol.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
     */
    function tokenURI(uint256 tokenId) external view returns (string memory);
}",164
RealWorld_BA_47_IERC1155ReceiverUpgradeable_RealWord_20240820195727.log,47,IERC1155ReceiverUpgradeable,12275,5461,17736,95.0,0.170595,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../../introspection/IERC165Upgradeable.sol"";

/**
 * _Available since v3.1._
 */
interface IERC1155ReceiverUpgradeable is IERC165Upgradeable {

    /**
        @dev Handles the receipt of a single ERC1155 token type. This function is
        called at the end of a `safeTransferFrom` after the balance has been updated.
        To accept the transfer, this must return
        `bytes4(keccak256(""onERC1155Received(address,address,uint256,uint256,bytes)""))`
        (i.e. 0xf23a6e61, or its own function selector).
        @param operator The address which initiated the transfer (i.e. msg.sender)
        @param from The address which previously owned the token
        @param id The ID of the token being transferred
        @param value The amount of tokens being transferred
        @param data Additional data with no specified format
        @return `bytes4(keccak256(""onERC1155Received(address,address,uint256,uint256,bytes)""))` if transfer is allowed
    */
    function onERC1155Received(
        address operator,
        address from,
        uint256 id,
        uint256 value,
        bytes calldata data
    )
        external
        returns(bytes4);

    /**
        @dev Handles the receipt of a multiple ERC1155 token types. This function
        is called at the end of a `safeBatchTransferFrom` after the balances have
        been updated. To accept the transfer(s), this must return
        `bytes4(keccak256(""onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)""))`
        (i.e. 0xbc197c81, or its own function selector).
        @param operator The address which initiated the batch transfer (i.e. msg.sender)
        @param from The address which previously owned the token
        @param ids An array containing ids of each token being transferred (order and length must match values array)
        @param values An array containing amounts of each token being transferred (order and length must match ids array)
        @param data Additional data with no specified format
        @return `bytes4(keccak256(""onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)""))` if transfer is allowed
    */
    function onERC1155BatchReceived(
        address operator,
        address from,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    )
        external
        returns(bytes4);
}",557
RealWorld_BA_47_UpgradeabilityProxy_RealWord_20240820191959.log,47,UpgradeabilityProxy,7657,5082,12739,100.0,0.139925,"pragma solidity ^0.5.0;

import './BaseUpgradeabilityProxy.sol';

/**
 * @title UpgradeabilityProxy
 * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing
 * implementation and init data.
 */
contract UpgradeabilityProxy is BaseUpgradeabilityProxy {
  /**
   * @dev Contract constructor.
   * @param _logic Address of the initial implementation.
   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.
   * It should include the signature and the parameters of the function to be called, as described in
   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.
   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.
   */
  constructor(address _logic, bytes memory _data) public payable {
    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));
    _setImplementation(_logic);
    if(_data.length > 0) {
      (bool success,) = _logic.delegatecall(_data);
      require(success);
    }
  }  
}",258
RealWorld_BA_47_IERC20Upgradeable_RealWord_20240820193312.log,47,IERC20Upgradeable,12695,4897,17592,85.0,0.161415,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20Upgradeable {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",613
RealWorld_BA_47_RefundEscrowUpgradeable_RealWord_20240820203007.log,47,RefundEscrowUpgradeable,15532,5544,21076,101.0,0.18854,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./ConditionalEscrowUpgradeable.sol"";
import ""../../proxy/Initializable.sol"";

/**
 * @title RefundEscrow
 * @dev Escrow that holds funds for a beneficiary, deposited from multiple
 * parties.
 * @dev Intended usage: See {Escrow}. Same usage guidelines apply here.
 * @dev The owner account (that is, the contract that instantiates this
 * contract) may deposit, close the deposit period, and allow for either
 * withdrawal by the beneficiary, or refunds to the depositors. All interactions
 * with `RefundEscrow` will be made through the owner contract.
 */
contract RefundEscrowUpgradeable is Initializable, ConditionalEscrowUpgradeable {
    enum State { Active, Refunding, Closed }

    event RefundsClosed();
    event RefundsEnabled();

    State private _state;
    address payable private _beneficiary;

    /**
     * @dev Constructor.
     * @param beneficiary The beneficiary of the deposits.
     */
    function __RefundEscrow_init(address payable beneficiary) internal initializer {
        __Context_init_unchained();
        __Ownable_init_unchained();
        __Escrow_init_unchained();
        __ConditionalEscrow_init_unchained();
        __RefundEscrow_init_unchained(beneficiary);
    }

    function __RefundEscrow_init_unchained(address payable beneficiary) internal initializer {
        require(beneficiary != address(0), ""RefundEscrow: beneficiary is the zero address"");
        _beneficiary = beneficiary;
        _state = State.Active;
    }

    /**
     * @return The current state of the escrow.
     */
    function state() public view returns (State) {
        return _state;
    }

    /**
     * @return The beneficiary of the escrow.
     */
    function beneficiary() public view returns (address) {
        return _beneficiary;
    }

    /**
     * @dev Stores funds that may later be refunded.
     * @param refundee The address funds will be sent to if a refund occurs.
     */
    function deposit(address refundee) public payable virtual override {
        require(_state == State.Active, ""RefundEscrow: can only deposit while active"");
        super.deposit(refundee);
    }

    /**
     * @dev Allows for the beneficiary to withdraw their funds, rejecting
     * further deposits.
     */
    function close() public onlyOwner virtual {
        require(_state == State.Active, ""RefundEscrow: can only close while active"");
        _state = State.Closed;
        emit RefundsClosed();
    }

    /**
     * @dev Allows for refunds to take place, rejecting further deposits.
     */
    function enableRefunds() public onlyOwner virtual {
        require(_state == State.Active, ""RefundEscrow: can only enable refunds while active"");
        _state = State.Refunding;
        emit RefundsEnabled();
    }

    /**
     * @dev Withdraws the beneficiary's funds.
     */
    function beneficiaryWithdraw() public virtual {
        require(_state == State.Closed, ""RefundEscrow: beneficiary can only withdraw while closed"");
        _beneficiary.transfer(address(this).balance);
    }

    /**
     * @dev Returns whether refundees can withdraw their deposits (be refunded). The overridden function receives a
     * 'payee' argument, but we ignore it here since the condition is global, not per-payee.
     */
    function withdrawalAllowed(address) public view override returns (bool) {
        return _state == State.Refunding;
    }
    uint256[49] private __gap;
}",764
RealWorld_BA_47_ERC20BurnableUpgradeable_RealWord_20240820192516.log,47,ERC20BurnableUpgradeable,9031,5399,14430,95.0,0.153135,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../../GSN/ContextUpgradeable.sol"";
import ""./ERC20Upgradeable.sol"";
import ""../../proxy/Initializable.sol"";

/**
 * @dev Extension of {ERC20} that allows token holders to destroy both their own
 * tokens and those that they have an allowance for, in a way that can be
 * recognized off-chain (via event analysis).
 */
abstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {
    function __ERC20Burnable_init() internal initializer {
        __Context_init_unchained();
        __ERC20Burnable_init_unchained();
    }

    function __ERC20Burnable_init_unchained() internal initializer {
    }
    /**
     * @dev Destroys `amount` tokens from the caller.
     *
     * See {ERC20-_burn}.
     */
    function burn(uint256 amount) public virtual {
        _burn(_msgSender(), amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, deducting from the caller's
     * allowance.
     *
     * See {ERC20-_burn} and {ERC20-allowance}.
     *
     * Requirements:
     *
     * - the caller must have allowance for ``accounts``'s tokens of at least
     * `amount`.
     */
    function burnFrom(address account, uint256 amount) public virtual {
        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, ""ERC20: burn amount exceeds allowance"");

        _approve(account, _msgSender(), decreasedAllowance);
        _burn(account, amount);
    }
    uint256[50] private __gap;
}",364
RealWorld_BA_47_StringsUpgradeable_RealWord_20240820203825.log,47,StringsUpgradeable,7715,4284,11999,79.0,0.124255,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev String operations.
 */
library StringsUpgradeable {
    /**
     * @dev Converts a `uint256` to its ASCII `string` representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return ""0"";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        uint256 index = digits - 1;
        temp = value;
        while (temp != 0) {
            buffer[index--] = byte(uint8(48 + temp % 10));
            temp /= 10;
        }
        return string(buffer);
    }
}",242
RealWorld_BA_47_SafeMathUpgradeable_RealWord_20240820210056.log,47,SafeMathUpgradeable,22417,4752,27169,104.0,0.207125,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMathUpgradeable {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, ""SafeMath: subtraction overflow"");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, ""SafeMath: division by zero"");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, ""SafeMath: modulo by zero"");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}",1213
RealWorld_BA_47_ERC20PausableUpgradeable_RealWord_20240820192833.log,47,ERC20PausableUpgradeable,7855,4711,12566,83.0,0.133495,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./ERC20Upgradeable.sol"";
import ""../../utils/PausableUpgradeable.sol"";
import ""../../proxy/Initializable.sol"";

/**
 * @dev ERC20 token with pausable token transfers, minting and burning.
 *
 * Useful for scenarios such as preventing trades until the end of an evaluation
 * period, or having an emergency switch for freezing all token transfers in the
 * event of a large bug.
 */
abstract contract ERC20PausableUpgradeable is Initializable, ERC20Upgradeable, PausableUpgradeable {
    function __ERC20Pausable_init() internal initializer {
        __Context_init_unchained();
        __Pausable_init_unchained();
        __ERC20Pausable_init_unchained();
    }

    function __ERC20Pausable_init_unchained() internal initializer {
    }
    /**
     * @dev See {ERC20-_beforeTokenTransfer}.
     *
     * Requirements:
     *
     * - the contract must not be paused.
     */
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {
        super._beforeTokenTransfer(from, to, amount);

        require(!paused(), ""ERC20Pausable: token transfer while paused"");
    }
    uint256[50] private __gap;
}",284
RealWorld_BA_47_InitializableUpgradeabilityProxy_RealWord_20240820191356.log,47,InitializableUpgradeabilityProxy,7628,5028,12656,80.0,0.1387,"pragma solidity ^0.5.0;

import './BaseUpgradeabilityProxy.sol';

/**
 * @title InitializableUpgradeabilityProxy
 * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing
 * implementation and init data.
 */
contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {
  /**
   * @dev Contract initializer.
   * @param _logic Address of the initial implementation.
   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.
   * It should include the signature and the parameters of the function to be called, as described in
   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.
   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.
   */
  function initialize(address _logic, bytes memory _data) public payable {
    require(_implementation() == address(0));
    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));
    _setImplementation(_logic);
    if(_data.length > 0) {
      (bool success,) = _logic.delegatecall(_data);
      require(success);
    }
  }  
}",273
RealWorld_BA_47_WrappedIbbtc_RealWord_20240820185307.log,47,WrappedIbbtc,22487,5418,27905,76.0,0.220795,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.6.12;

import ""../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""./ICoreOracle.sol"";

/*
    Wrapped Interest-Bearing Bitcoin (Non-Ethereum mainnet variant)
*/
contract WrappedIbbtc is Initializable, ERC20Upgradeable {
    address public governance;
    address public pendingGovernance;
    ERC20Upgradeable public ibbtc; 

    ICoreOracle public oracle;

    event SetOracle(address oracle);
    event SetPendingGovernance(address pendingGovernance);
    event AcceptPendingGovernance(address pendingGovernance);

    /// ===== Modifiers =====
    modifier onlyPendingGovernance() {
        require(msg.sender == pendingGovernance, ""onlyPendingGovernance"");
        _;
    }

    modifier onlyGovernance() {
        require(msg.sender == governance, ""onlyGovernance"");
        _;
    }

    modifier onlyOracle() {
        require(msg.sender == address(oracle), ""onlyOracle"");
        _;
    }

    function initialize(address _governance, address _ibbtc, address _oracle) public initializer {
        __ERC20_init(""Wrapped Interest-Bearing Bitcoin"", ""wibBTC"");
        governance = _governance;
        oracle = ICoreOracle(_oracle);
        ibbtc = ERC20Upgradeable(_ibbtc);

        emit SetOracle(_oracle);
    }

    /// ===== Permissioned: Governance =====
    function setPendingGovernance(address _pendingGovernance) external onlyGovernance {
        pendingGovernance = _pendingGovernance;
        emit SetPendingGovernance(pendingGovernance);
    }

    function setOracle(address _oracle) external onlyGovernance {
        oracle = ICoreOracle(_oracle);
        emit SetOracle(_oracle);
    }

    /// ===== Permissioned: Pending Governance =====
    function acceptPendingGovernance() external onlyPendingGovernance {
        governance = pendingGovernance;
        emit AcceptPendingGovernance(pendingGovernance);
    }

    /// ===== Permissionless Calls =====

    /// @dev Deposit ibBTC to mint wibBTC shares
    function mint(uint256 _shares) external {
        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));
        _mint(_msgSender(), _shares);
    }

    /// @dev Redeem wibBTC for ibBTC. Denominated in shares.
    function burn(uint256 _shares) external {
        _burn(_msgSender(), _shares);
        require(ibbtc.transfer(_msgSender(), _shares));
    }

    /// ===== Transfer Overrides =====
    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        /// @dev the _balances mapping represents the underlying ibBTC shares (""non-rebased balances"")
        /// @dev the naming confusion is due to maintaining original ERC20 code as much as possible

        uint256 amountInShares = balanceToShares(amount);

        _transfer(sender, recipient, amountInShares);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        /// @dev the _balances mapping represents the underlying ibBTC shares (""non-rebased balances"")
        /// @dev the naming confusion is due to maintaining original ERC20 code as much as possible

        uint256 amountInShares = balanceToShares(amount);

        _transfer(_msgSender(), recipient, amountInShares);
        return true;
    }

    /// ===== View Methods =====

    /// @dev Current pricePerShare read live from oracle
    function pricePerShare() public view virtual returns (uint256) {
        return oracle.pricePerShare();
    }

    /// @dev Wrapped ibBTC shares of account
    function sharesOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /// @dev Current account shares * pricePerShare
    function balanceOf(address account) public view override returns (uint256) {
        return sharesOf(account).mul(pricePerShare()).div(1e18);
    }

    /// @dev Total wrapped ibBTC shares
    function totalShares() public view returns (uint256) {
        return _totalSupply;
    }

    /// @dev Current total shares * pricePerShare
    function totalSupply() public view override returns (uint256) {
        return totalShares().mul(pricePerShare()).div(1e18);
    }

    function balanceToShares(uint256 balance) public view returns (uint256) {
        return balance.mul(1e18).div(pricePerShare());
    }

    function sharesToBalance(uint256 shares) public view returns (uint256) {
        return shares.mul(pricePerShare()).div(1e18);
    }
}",1204
RealWorld_BA_47_ProxyAdmin_RealWord_20240820191056.log,47,ProxyAdmin,13799,5255,19054,93.0,0.174095,"pragma solidity ^0.5.0;

import ""../ownership/Ownable.sol"";
import ""./AdminUpgradeabilityProxy.sol"";

/**
 * @title ProxyAdmin
 * @dev This contract is the admin of a proxy, and is in charge
 * of upgrading it as well as transferring it to another admin.
 */
contract ProxyAdmin is OpenZeppelinUpgradesOwnable {
  
  /**
   * @dev Returns the current implementation of a proxy.
   * This is needed because only the proxy admin can query it.
   * @return The address of the current implementation of the proxy.
   */
  function getProxyImplementation(AdminUpgradeabilityProxy proxy) public view returns (address) {
    // We need to manually run the static call since the getter cannot be flagged as view
    // bytes4(keccak256(""implementation()"")) == 0x5c60da1b
    (bool success, bytes memory returndata) = address(proxy).staticcall(hex""5c60da1b"");
    require(success);
    return abi.decode(returndata, (address));
  }

  /**
   * @dev Returns the admin of a proxy. Only the admin can query it.
   * @return The address of the current admin of the proxy.
   */
  function getProxyAdmin(AdminUpgradeabilityProxy proxy) public view returns (address) {
    // We need to manually run the static call since the getter cannot be flagged as view
    // bytes4(keccak256(""admin()"")) == 0xf851a440
    (bool success, bytes memory returndata) = address(proxy).staticcall(hex""f851a440"");
    require(success);
    return abi.decode(returndata, (address));
  }

  /**
   * @dev Changes the admin of a proxy.
   * @param proxy Proxy to change admin.
   * @param newAdmin Address to transfer proxy administration to.
   */
  function changeProxyAdmin(AdminUpgradeabilityProxy proxy, address newAdmin) public onlyOwner {
    proxy.changeAdmin(newAdmin);
  }

  /**
   * @dev Upgrades a proxy to the newest implementation of a contract.
   * @param proxy Proxy to be upgraded.
   * @param implementation the address of the Implementation.
   */
  function upgrade(AdminUpgradeabilityProxy proxy, address implementation) public onlyOwner {
    proxy.upgradeTo(implementation);
  }

  /**
   * @dev Upgrades a proxy to the newest implementation of a contract and forwards a function call to it.
   * This is useful to initialize the proxied contract.
   * @param proxy Proxy to be upgraded.
   * @param implementation Address of the Implementation.
   * @param data Data to send as msg.data in the low level call.
   * It should include the signature and the parameters of the function to be called, as described in
   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.
   */
  function upgradeAndCall(AdminUpgradeabilityProxy proxy, address implementation, bytes memory data) payable public onlyOwner {
    proxy.upgradeToAndCall.value(msg.value)(implementation, data);
  }
}",662
RealWorld_BA_47_IRelayHubUpgradeable_RealWord_20240820201406.log,47,IRelayHubUpgradeable,47204,5517,52721,103.0,0.34636,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface for `RelayHub`, the core contract of the GSN. Users should not need to interact with this contract
 * directly.
 *
 * See the https://github.com/OpenZeppelin/openzeppelin-gsn-helpers[OpenZeppelin GSN helpers] for more information on
 * how to deploy an instance of `RelayHub` on your local test network.
 */
interface IRelayHubUpgradeable {
    // Relay management

    /**
     * @dev Adds stake to a relay and sets its `unstakeDelay`. If the relay does not exist, it is created, and the caller
     * of this function becomes its owner. If the relay already exists, only the owner can call this function. A relay
     * cannot be its own owner.
     *
     * All Ether in this function call will be added to the relay's stake.
     * Its unstake delay will be assigned to `unstakeDelay`, but the new value must be greater or equal to the current one.
     *
     * Emits a {Staked} event.
     */
    function stake(address relayaddr, uint256 unstakeDelay) external payable;

    /**
     * @dev Emitted when a relay's stake or unstakeDelay are increased
     */
    event Staked(address indexed relay, uint256 stake, uint256 unstakeDelay);

    /**
     * @dev Registers the caller as a relay.
     * The relay must be staked for, and not be a contract (i.e. this function must be called directly from an EOA).
     *
     * This function can be called multiple times, emitting new {RelayAdded} events. Note that the received
     * `transactionFee` is not enforced by {relayCall}.
     *
     * Emits a {RelayAdded} event.
     */
    function registerRelay(uint256 transactionFee, string calldata url) external;

    /**
     * @dev Emitted when a relay is registered or re-registered. Looking at these events (and filtering out
     * {RelayRemoved} events) lets a client discover the list of available relays.
     */
    event RelayAdded(address indexed relay, address indexed owner, uint256 transactionFee, uint256 stake, uint256 unstakeDelay, string url);

    /**
     * @dev Removes (deregisters) a relay. Unregistered (but staked for) relays can also be removed.
     *
     * Can only be called by the owner of the relay. After the relay's `unstakeDelay` has elapsed, {unstake} will be
     * callable.
     *
     * Emits a {RelayRemoved} event.
     */
    function removeRelayByOwner(address relay) external;

    /**
     * @dev Emitted when a relay is removed (deregistered). `unstakeTime` is the time when unstake will be callable.
     */
    event RelayRemoved(address indexed relay, uint256 unstakeTime);

    /** Deletes the relay from the system, and gives back its stake to the owner.
     *
     * Can only be called by the relay owner, after `unstakeDelay` has elapsed since {removeRelayByOwner} was called.
     *
     * Emits an {Unstaked} event.
     */
    function unstake(address relay) external;

    /**
     * @dev Emitted when a relay is unstaked for, including the returned stake.
     */
    event Unstaked(address indexed relay, uint256 stake);

    // States a relay can be in
    enum RelayState {
        Unknown, // The relay is unknown to the system: it has never been staked for
        Staked, // The relay has been staked for, but it is not yet active
        Registered, // The relay has registered itself, and is active (can relay calls)
        Removed    // The relay has been removed by its owner and can no longer relay calls. It must wait for its unstakeDelay to elapse before it can unstake
    }

    /**
     * @dev Returns a relay's status. Note that relays can be deleted when unstaked or penalized, causing this function
     * to return an empty entry.
     */
    function getRelay(address relay) external view returns (uint256 totalStake, uint256 unstakeDelay, uint256 unstakeTime, address payable owner, RelayState state);

    // Balance management

    /**
     * @dev Deposits Ether for a contract, so that it can receive (and pay for) relayed transactions.
     *
     * Unused balance can only be withdrawn by the contract itself, by calling {withdraw}.
     *
     * Emits a {Deposited} event.
     */
    function depositFor(address target) external payable;

    /**
     * @dev Emitted when {depositFor} is called, including the amount and account that was funded.
     */
    event Deposited(address indexed recipient, address indexed from, uint256 amount);

    /**
     * @dev Returns an account's deposits. These can be either a contract's funds, or a relay owner's revenue.
     */
    function balanceOf(address target) external view returns (uint256);

    /**
     * Withdraws from an account's balance, sending it back to it. Relay owners call this to retrieve their revenue, and
     * contracts can use it to reduce their funding.
     *
     * Emits a {Withdrawn} event.
     */
    function withdraw(uint256 amount, address payable dest) external;

    /**
     * @dev Emitted when an account withdraws funds from `RelayHub`.
     */
    event Withdrawn(address indexed account, address indexed dest, uint256 amount);

    // Relaying

    /**
     * @dev Checks if the `RelayHub` will accept a relayed operation.
     * Multiple things must be true for this to happen:
     *  - all arguments must be signed for by the sender (`from`)
     *  - the sender's nonce must be the current one
     *  - the recipient must accept this transaction (via {acceptRelayedCall})
     *
     * Returns a `PreconditionCheck` value (`OK` when the transaction can be relayed), or a recipient-specific error
     * code if it returns one in {acceptRelayedCall}.
     */
    function canRelay(
        address relay,
        address from,
        address to,
        bytes calldata encodedFunction,
        uint256 transactionFee,
        uint256 gasPrice,
        uint256 gasLimit,
        uint256 nonce,
        bytes calldata signature,
        bytes calldata approvalData
    ) external view returns (uint256 status, bytes memory recipientContext);

    // Preconditions for relaying, checked by canRelay and returned as the corresponding numeric values.
    enum PreconditionCheck {
        OK,                         // All checks passed, the call can be relayed
        WrongSignature,             // The transaction to relay is not signed by requested sender
        WrongNonce,                 // The provided nonce has already been used by the sender
        AcceptRelayedCallReverted,  // The recipient rejected this call via acceptRelayedCall
        InvalidRecipientStatusCode  // The recipient returned an invalid (reserved) status code
    }

    /**
     * @dev Relays a transaction.
     *
     * For this to succeed, multiple conditions must be met:
     *  - {canRelay} must `return PreconditionCheck.OK`
     *  - the sender must be a registered relay
     *  - the transaction's gas price must be larger or equal to the one that was requested by the sender
     *  - the transaction must have enough gas to not run out of gas if all internal transactions (calls to the
     * recipient) use all gas available to them
     *  - the recipient must have enough balance to pay the relay for the worst-case scenario (i.e. when all gas is
     * spent)
     *
     * If all conditions are met, the call will be relayed and the recipient charged. {preRelayedCall}, the encoded
     * function and {postRelayedCall} will be called in that order.
     *
     * Parameters:
     *  - `from`: the client originating the request
     *  - `to`: the target {IRelayRecipient} contract
     *  - `encodedFunction`: the function call to relay, including data
     *  - `transactionFee`: fee (%) the relay takes over actual gas cost
     *  - `gasPrice`: gas price the client is willing to pay
     *  - `gasLimit`: gas to forward when calling the encoded function
     *  - `nonce`: client's nonce
     *  - `signature`: client's signature over all previous params, plus the relay and RelayHub addresses
     *  - `approvalData`: dapp-specific data forwarded to {acceptRelayedCall}. This value is *not* verified by the
     * `RelayHub`, but it still can be used for e.g. a signature.
     *
     * Emits a {TransactionRelayed} event.
     */
    function relayCall(
        address from,
        address to,
        bytes calldata encodedFunction,
        uint256 transactionFee,
        uint256 gasPrice,
        uint256 gasLimit,
        uint256 nonce,
        bytes calldata signature,
        bytes calldata approvalData
    ) external;

    /**
     * @dev Emitted when an attempt to relay a call failed.
     *
     * This can happen due to incorrect {relayCall} arguments, or the recipient not accepting the relayed call. The
     * actual relayed call was not executed, and the recipient not charged.
     *
     * The `reason` parameter contains an error code: values 1-10 correspond to `PreconditionCheck` entries, and values
     * over 10 are custom recipient error codes returned from {acceptRelayedCall}.
     */
    event CanRelayFailed(address indexed relay, address indexed from, address indexed to, bytes4 selector, uint256 reason);

    /**
     * @dev Emitted when a transaction is relayed.
     * Useful when monitoring a relay's operation and relayed calls to a contract
     *
     * Note that the actual encoded function might be reverted: this is indicated in the `status` parameter.
     *
     * `charge` is the Ether value deducted from the recipient's balance, paid to the relay's owner.
     */
    event TransactionRelayed(address indexed relay, address indexed from, address indexed to, bytes4 selector, RelayCallStatus status, uint256 charge);

    // Reason error codes for the TransactionRelayed event
    enum RelayCallStatus {
        OK,                      // The transaction was successfully relayed and execution successful - never included in the event
        RelayedCallFailed,       // The transaction was relayed, but the relayed call failed
        PreRelayedFailed,        // The transaction was not relayed due to preRelatedCall reverting
        PostRelayedFailed,       // The transaction was relayed and reverted due to postRelatedCall reverting
        RecipientBalanceChanged  // The transaction was relayed and reverted due to the recipient's balance changing
    }

    /**
     * @dev Returns how much gas should be forwarded to a call to {relayCall}, in order to relay a transaction that will
     * spend up to `relayedCallStipend` gas.
     */
    function requiredGas(uint256 relayedCallStipend) external view returns (uint256);

    /**
     * @dev Returns the maximum recipient charge, given the amount of gas forwarded, gas price and relay fee.
     */
    function maxPossibleCharge(uint256 relayedCallStipend, uint256 gasPrice, uint256 transactionFee) external view returns (uint256);

     // Relay penalization.
     // Any account can penalize relays, removing them from the system immediately, and rewarding the
    // reporter with half of the relay's stake. The other half is burned so that, even if the relay penalizes itself, it
    // still loses half of its stake.

    /**
     * @dev Penalize a relay that signed two transactions using the same nonce (making only the first one valid) and
     * different data (gas price, gas limit, etc. may be different).
     *
     * The (unsigned) transaction data and signature for both transactions must be provided.
     */
    function penalizeRepeatedNonce(bytes calldata unsignedTx1, bytes calldata signature1, bytes calldata unsignedTx2, bytes calldata signature2) external;

    /**
     * @dev Penalize a relay that sent a transaction that didn't target ``RelayHub``'s {registerRelay} or {relayCall}.
     */
    function penalizeIllegalTransaction(bytes calldata unsignedTx, bytes calldata signature) external;

    /**
     * @dev Emitted when a relay is penalized.
     */
    event Penalized(address indexed relay, address sender, uint256 amount);

    /**
     * @dev Returns an account's nonce in `RelayHub`.
     */
    function getNonce(address from) external view returns (uint256);
}",2788
RealWorld_BA_47_BaseAdminUpgradeabilityProxy_RealWord_20240820191231.log,47,BaseAdminUpgradeabilityProxy,17294,5172,22466,83.0,0.18991,"pragma solidity ^0.5.0;

import './UpgradeabilityProxy.sol';

/**
 * @title BaseAdminUpgradeabilityProxy
 * @dev This contract combines an upgradeability proxy with an authorization
 * mechanism for administrative tasks.
 * All external functions in this contract must be guarded by the
 * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity
 * feature proposal that would enable this to be done automatically.
 */
contract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {
  /**
   * @dev Emitted when the administration has been transferred.
   * @param previousAdmin Address of the previous admin.
   * @param newAdmin Address of the new admin.
   */
  event AdminChanged(address previousAdmin, address newAdmin);

  /**
   * @dev Storage slot with the admin of the contract.
   * This is the keccak-256 hash of ""eip1967.proxy.admin"" subtracted by 1, and is
   * validated in the constructor.
   */

  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;

  /**
   * @dev Modifier to check whether the `msg.sender` is the admin.
   * If it is, it will run the function. Otherwise, it will delegate the call
   * to the implementation.
   */
  modifier ifAdmin() {
    if (msg.sender == _admin()) {
      _;
    } else {
      _fallback();
    }
  }

  /**
   * @return The address of the proxy admin.
   */
  function admin() external ifAdmin returns (address) {
    return _admin();
  }

  /**
   * @return The address of the implementation.
   */
  function implementation() external ifAdmin returns (address) {
    return _implementation();
  }

  /**
   * @dev Changes the admin of the proxy.
   * Only the current admin can call this function.
   * @param newAdmin Address to transfer proxy administration to.
   */
  function changeAdmin(address newAdmin) external ifAdmin {
    require(newAdmin != address(0), ""Cannot change the admin of a proxy to the zero address"");
    emit AdminChanged(_admin(), newAdmin);
    _setAdmin(newAdmin);
  }

  /**
   * @dev Upgrade the backing implementation of the proxy.
   * Only the admin can call this function.
   * @param newImplementation Address of the new implementation.
   */
  function upgradeTo(address newImplementation) external ifAdmin {
    _upgradeTo(newImplementation);
  }

  /**
   * @dev Upgrade the backing implementation of the proxy and call a function
   * on the new implementation.
   * This is useful to initialize the proxied contract.
   * @param newImplementation Address of the new implementation.
   * @param data Data to send as msg.data in the low level call.
   * It should include the signature and the parameters of the function to be called, as described in
   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.
   */
  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {
    _upgradeTo(newImplementation);
    (bool success,) = newImplementation.delegatecall(data);
    require(success);
  }

  /**
   * @return The admin slot.
   */
  function _admin() internal view returns (address adm) {
    bytes32 slot = ADMIN_SLOT;
    assembly {
      adm := sload(slot)
    }
  }

  /**
   * @dev Sets the address of the proxy admin.
   * @param newAdmin Address of the new proxy admin.
   */
  function _setAdmin(address newAdmin) internal {
    bytes32 slot = ADMIN_SLOT;

    assembly {
      sstore(slot, newAdmin)
    }
  }

  /**
   * @dev Only fall back when the sender is not the admin.
   */
  function _willFallback() internal {
    require(msg.sender != _admin(), ""Cannot call fallback function from the proxy admin"");
    super._willFallback();
  }
}",883
RealWorld_BA_47_BaseUpgradeabilityProxy_RealWord_20240820190909.log,47,BaseUpgradeabilityProxy,10136,5490,15626,105.0,0.16048,"pragma solidity ^0.5.0;

import './Proxy.sol';
import '../utils/Address.sol';

/**
 * @title BaseUpgradeabilityProxy
 * @dev This contract implements a proxy that allows to change the
 * implementation address to which it will delegate.
 * Such a change is called an implementation upgrade.
 */
contract BaseUpgradeabilityProxy is Proxy {
  /**
   * @dev Emitted when the implementation is upgraded.
   * @param implementation Address of the new implementation.
   */
  event Upgraded(address indexed implementation);

  /**
   * @dev Storage slot with the address of the current implementation.
   * This is the keccak-256 hash of ""eip1967.proxy.implementation"" subtracted by 1, and is
   * validated in the constructor.
   */
  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

  /**
   * @dev Returns the current implementation.
   * @return Address of the current implementation
   */
  function _implementation() internal view returns (address impl) {
    bytes32 slot = IMPLEMENTATION_SLOT;
    assembly {
      impl := sload(slot)
    }
  }

  /**
   * @dev Upgrades the proxy to a new implementation.
   * @param newImplementation Address of the new implementation.
   */
  function _upgradeTo(address newImplementation) internal {
    _setImplementation(newImplementation);
    emit Upgraded(newImplementation);
  }

  /**
   * @dev Sets the implementation address of the proxy.
   * @param newImplementation Address of the new implementation.
   */
  function _setImplementation(address newImplementation) internal {
    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), ""Cannot set a proxy implementation to a non-contract address"");

    bytes32 slot = IMPLEMENTATION_SLOT;

    assembly {
      sstore(slot, newImplementation)
    }
  }
}",413
RealWorld_BA_47_ERC20SnapshotUpgradeable_RealWord_20240820192653.log,47,ERC20SnapshotUpgradeable,33167,5339,38506,98.0,0.272615,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../../math/SafeMathUpgradeable.sol"";
import ""../../utils/ArraysUpgradeable.sol"";
import ""../../utils/CountersUpgradeable.sol"";
import ""./ERC20Upgradeable.sol"";
import ""../../proxy/Initializable.sol"";

/**
 * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and
 * total supply at the time are recorded for later access.
 *
 * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.
 * In naive implementations it's possible to perform a ""double spend"" attack by reusing the same balance from different
 * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be
 * used to create an efficient ERC20 forking mechanism.
 *
 * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a
 * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot
 * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id
 * and the account address.
 *
 * ==== Gas Costs
 *
 * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log
 * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much
 * smaller since identical balances in subsequent snapshots are stored as a single entry.
 *
 * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is
 * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent
 * transfers will have normal cost until the next snapshot, and so on.
 */
abstract contract ERC20SnapshotUpgradeable is Initializable, ERC20Upgradeable {
    function __ERC20Snapshot_init() internal initializer {
        __Context_init_unchained();
        __ERC20Snapshot_init_unchained();
    }

    function __ERC20Snapshot_init_unchained() internal initializer {
    }
    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:
    // https://github.com/Giveth/minimd/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol

    using SafeMathUpgradeable for uint256;
    using ArraysUpgradeable for uint256[];
    using CountersUpgradeable for CountersUpgradeable.Counter;

    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a
    // Snapshot struct, but that would impede usage of functions that work on an array.
    struct Snapshots {
        uint256[] ids;
        uint256[] values;
    }

    mapping (address => Snapshots) private _accountBalanceSnapshots;
    Snapshots private _totalSupplySnapshots;

    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.
    CountersUpgradeable.Counter private _currentSnapshotId;

    /**
     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.
     */
    event Snapshot(uint256 id);

    /**
     * @dev Creates a new snapshot and returns its snapshot id.
     *
     * Emits a {Snapshot} event that contains the same id.
     *
     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a
     * set of accounts, for example using {AccessControl}, or it may be open to the public.
     *
     * [WARNING]
     * ====
     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,
     * you must consider that it can potentially be used by attackers in two ways.
     *
     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow
     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target
     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs
     * section above.
     *
     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.
     * ====
     */
    function _snapshot() internal virtual returns (uint256) {
        _currentSnapshotId.increment();

        uint256 currentId = _currentSnapshotId.current();
        emit Snapshot(currentId);
        return currentId;
    }

    /**
     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.
     */
    function balanceOfAt(address account, uint256 snapshotId) public view returns (uint256) {
        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);

        return snapshotted ? value : balanceOf(account);
    }

    /**
     * @dev Retrieves the total supply at the time `snapshotId` was created.
     */
    function totalSupplyAt(uint256 snapshotId) public view returns(uint256) {
        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);

        return snapshotted ? value : totalSupply();
    }


    // Update balance and/or total supply snapshots before the values are modified. This is implemented
    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {
      super._beforeTokenTransfer(from, to, amount);

      if (from == address(0)) {
        // mint
        _updateAccountSnapshot(to);
        _updateTotalSupplySnapshot();
      } else if (to == address(0)) {
        // burn
        _updateAccountSnapshot(from);
        _updateTotalSupplySnapshot();
      } else {
        // transfer
        _updateAccountSnapshot(from);
        _updateAccountSnapshot(to);
      }
    }

    function _valueAt(uint256 snapshotId, Snapshots storage snapshots)
        private view returns (bool, uint256)
    {
        require(snapshotId > 0, ""ERC20Snapshot: id is 0"");
        // solhint-disable-next-line max-line-length
        require(snapshotId <= _currentSnapshotId.current(), ""ERC20Snapshot: nonexistent id"");

        // When a valid snapshot is queried, there are three possibilities:
        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never
        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds
        //  to this id is the current one.
        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the
        //  requested id, and its value is the one to return.
        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be
        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is
        //  larger than the requested one.
        //
        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if
        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does
        // exactly this.

        uint256 index = snapshots.ids.findUpperBound(snapshotId);

        if (index == snapshots.ids.length) {
            return (false, 0);
        } else {
            return (true, snapshots.values[index]);
        }
    }

    function _updateAccountSnapshot(address account) private {
        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));
    }

    function _updateTotalSupplySnapshot() private {
        _updateSnapshot(_totalSupplySnapshots, totalSupply());
    }

    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {
        uint256 currentId = _currentSnapshotId.current();
        if (_lastSnapshotId(snapshots.ids) < currentId) {
            snapshots.ids.push(currentId);
            snapshots.values.push(currentValue);
        }
    }

    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {
        if (ids.length == 0) {
            return 0;
        } else {
            return ids[ids.length - 1];
        }
    }
    uint256[46] private __gap;
}",1881
RealWorld_BA_47_ECDSA_RealWord_20240820185740.log,47,ECDSA,16735,5069,21804,77.0,0.185055,"pragma solidity ^0.5.2;

/**
 * @title Elliptic curve signature operations
 * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d
 * TODO Remove this library once solidity supports passing a signature to ecrecover.
 * See https://github.com/ethereum/solidity/issues/864
 *
 * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/79dd498b16b957399f84b9aa7e720f98f9eb83e3/contracts/cryptography/ECDSA.sol
 * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts
 * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the
 * build/artifacts folder) as well as the vanilla implementation from an openzeppelin version.
 */

library OpenZeppelinUpgradesECDSA {
    /**
     * @dev Recover signer address from a message by using their signature
     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.
     * @param signature bytes signature, the signature is generated using web3.eth.sign()
     */
    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
        // Check the signature length
        if (signature.length != 65) {
            return (address(0));
        }

        // Divide the signature in r, s and v variables
        bytes32 r;
        bytes32 s;
        uint8 v;

        // ecrecover takes the signature parameters, and the only way to get them
        // currently is to use assembly.
        // solhint-disable-next-line no-inline-assembly
        assembly {
            r := mload(add(signature, 0x20))
            s := mload(add(signature, 0x40))
            v := byte(0, mload(add(signature, 0x60)))
        }

        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most
        // signatures from current libraries generate a unique signature with an s-value in the lower half order.
        //
        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
        // these malleable signatures as well.
        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
            return address(0);
        }

        if (v != 27 && v != 28) {
            return address(0);
        }

        // If the signature is valid (and not malleable), return the signer address
        return ecrecover(hash, v, r, s);
    }

    /**
     * toEthSignedMessageHash
     * @dev prefix a bytes32 value with ""\x19Ethereum Signed Message:""
     * and hash the result
     */
    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
        // 32 is the length in bytes of hash,
        // enforced by the type signature above
        return keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash));
    }
}",867
RealWorld_BA_47_ERC1155PausableUpgradeable_RealWord_20240820200032.log,47,ERC1155PausableUpgradeable,8998,4991,13989,87.0,0.14481,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./ERC1155Upgradeable.sol"";
import ""../../utils/PausableUpgradeable.sol"";
import ""../../proxy/Initializable.sol"";

/**
 * @dev ERC1155 token with pausable token transfers, minting and burning.
 *
 * Useful for scenarios such as preventing trades until the end of an evaluation
 * period, or having an emergency switch for freezing all token transfers in the
 * event of a large bug.
 *
 * _Available since v3.1._
 */
abstract contract ERC1155PausableUpgradeable is Initializable, ERC1155Upgradeable, PausableUpgradeable {
    function __ERC1155Pausable_init() internal initializer {
        __Context_init_unchained();
        __ERC165_init_unchained();
        __Pausable_init_unchained();
        __ERC1155Pausable_init_unchained();
    }

    function __ERC1155Pausable_init_unchained() internal initializer {
    }
    /**
     * @dev See {ERC1155-_beforeTokenTransfer}.
     *
     * Requirements:
     *
     * - the contract must not be paused.
     */
    function _beforeTokenTransfer(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    )
        internal virtual override
    {
        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);

        require(!paused(), ""ERC1155Pausable: token transfer while paused"");
    }
    uint256[50] private __gap;
}",345
RealWorld_BA_47_ERC20PresetMinterPauserUpgradeable_RealWord_20240820210600.log,47,ERC20PresetMinterPauserUpgradeable,17731,5730,23461,117.0,0.203255,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../access/AccessControlUpgradeable.sol"";
import ""../GSN/ContextUpgradeable.sol"";
import ""../token/ERC20/ERC20Upgradeable.sol"";
import ""../token/ERC20/ERC20BurnableUpgradeable.sol"";
import ""../token/ERC20/ERC20PausableUpgradeable.sol"";
import ""../proxy/Initializable.sol"";

/**
 * @dev {ERC20} token, including:
 *
 *  - ability for holders to burn (destroy) their tokens
 *  - a minter role that allows for token minting (creation)
 *  - a pauser role that allows to stop all token transfers
 *
 * This contract uses {AccessControl} to lock permissioned functions using the
 * different roles - head to its documentation for details.
 *
 * The account that deploys the contract will be granted the minter and pauser
 * roles, as well as the default admin role, which will let it grant both minter
 * and pauser roles to other accounts.
 */
contract ERC20PresetMinterPauserUpgradeable is Initializable, ContextUpgradeable, AccessControlUpgradeable, ERC20BurnableUpgradeable, ERC20PausableUpgradeable {
    function initialize(string memory name, string memory symbol) public virtual initializer {
        __ERC20PresetMinterPauser_init(name, symbol);
    }
    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");
    bytes32 public constant PAUSER_ROLE = keccak256(""PAUSER_ROLE"");

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the
     * account that deploys the contract.
     *
     * See {ERC20-constructor}.
     */
    function __ERC20PresetMinterPauser_init(string memory name, string memory symbol) internal initializer {
        __Context_init_unchained();
        __AccessControl_init_unchained();
        __ERC20_init_unchained(name, symbol);
        __ERC20Burnable_init_unchained();
        __Pausable_init_unchained();
        __ERC20Pausable_init_unchained();
        __ERC20PresetMinterPauser_init_unchained(name, symbol);
    }

    function __ERC20PresetMinterPauser_init_unchained(string memory name, string memory symbol) internal initializer {
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());

        _setupRole(MINTER_ROLE, _msgSender());
        _setupRole(PAUSER_ROLE, _msgSender());
    }

    /**
     * @dev Creates `amount` new tokens for `to`.
     *
     * See {ERC20-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     */
    function mint(address to, uint256 amount) public virtual {
        require(hasRole(MINTER_ROLE, _msgSender()), ""ERC20PresetMinterPauser: must have minter role to mint"");
        _mint(to, amount);
    }

    /**
     * @dev Pauses all token transfers.
     *
     * See {ERC20Pausable} and {Pausable-_pause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function pause() public virtual {
        require(hasRole(PAUSER_ROLE, _msgSender()), ""ERC20PresetMinterPauser: must have pauser role to pause"");
        _pause();
    }

    /**
     * @dev Unpauses all token transfers.
     *
     * See {ERC20Pausable} and {Pausable-_unpause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function unpause() public virtual {
        require(hasRole(PAUSER_ROLE, _msgSender()), ""ERC20PresetMinterPauser: must have pauser role to unpause"");
        _unpause();
    }

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override(ERC20Upgradeable, ERC20PausableUpgradeable) {
        super._beforeTokenTransfer(from, to, amount);
    }
    uint256[50] private __gap;
}",910
RealWorld_BA_47_AccessControlUpgradeable_RealWord_20240820200845.log,47,AccessControlUpgradeable,32973,5399,38372,110.0,0.272845,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../utils/EnumerableSetUpgradeable.sol"";
import ""../utils/AddressUpgradeable.sol"";
import ""../GSN/ContextUpgradeable.sol"";
import ""../proxy/Initializable.sol"";

/**
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms.
 *
 * Roles are referred to by their `bytes32` identifier. These should be exposed
 * in the external API and be unique. The best way to achieve this is by
 * using `public constant` hash digests:
 *
 * ```
 * bytes32 public constant MY_ROLE = keccak256(""MY_ROLE"");
 * ```
 *
 * Roles can be used to represent a set of permissions. To restrict access to a
 * function call, use {hasRole}:
 *
 * ```
 * function foo() public {
 *     require(hasRole(MY_ROLE, msg.sender));
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {_setRoleAdmin}.
 *
 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it.
 */
abstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable {
    function __AccessControl_init() internal initializer {
        __Context_init_unchained();
        __AccessControl_init_unchained();
    }

    function __AccessControl_init_unchained() internal initializer {
    }
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;
    using AddressUpgradeable for address;

    struct RoleData {
        EnumerableSetUpgradeable.AddressSet members;
        bytes32 adminRole;
    }

    mapping (bytes32 => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     *
     * _Available since v3.1._
     */
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {_setupRole}.
     */
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members.contains(account);
    }

    /**
     * @dev Returns the number of accounts that have `role`. Can be used
     * together with {getRoleMember} to enumerate all bearers of a role.
     */
    function getRoleMemberCount(bytes32 role) public view returns (uint256) {
        return _roles[role].members.length();
    }

    /**
     * @dev Returns one of the accounts that have `role`. `index` must be a
     * value between 0 and {getRoleMemberCount}, non-inclusive.
     *
     * Role bearers are not sorted in any particular way, and their ordering may
     * change at any point.
     *
     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure
     * you perform all queries on the same block. See the following
     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]
     * for more information.
     */
    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {
        return _roles[role].members.at(index);
    }

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roles[role].adminRole;
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) public virtual {
        require(hasRole(_roles[role].adminRole, _msgSender()), ""AccessControl: sender must be an admin to grant"");

        _grantRole(role, account);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) public virtual {
        require(hasRole(_roles[role].adminRole, _msgSender()), ""AccessControl: sender must be an admin to revoke"");

        _revokeRole(role, account);
    }

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) public virtual {
        require(account == _msgSender(), ""AccessControl: can only renounce roles for self"");

        _revokeRole(role, account);
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event. Note that unlike {grantRole}, this function doesn't perform any
     * checks on the calling account.
     *
     * [WARNING]
     * ====
     * This function should only be called from the constructor when setting
     * up the initial roles for the system.
     *
     * Using this function in any other way is effectively circumventing the admin
     * system imposed by {AccessControl}.
     * ====
     */
    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }

    /**
     * @dev Sets `adminRole` as ``role``'s admin role.
     *
     * Emits a {RoleAdminChanged} event.
     */
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);
        _roles[role].adminRole = adminRole;
    }

    function _grantRole(bytes32 role, address account) private {
        if (_roles[role].members.add(account)) {
            emit RoleGranted(role, account, _msgSender());
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (_roles[role].members.remove(account)) {
            emit RoleRevoked(role, account, _msgSender());
        }
    }
    uint256[49] private __gap;
}",1854
RealWorld_BA_47_IERC165Upgradeable_RealWord_20240820205406.log,47,IERC165Upgradeable,6293,4347,10640,92.0,0.118405,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165Upgradeable {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}",195
RealWorld_BA_47_ERC777Upgradeable_RealWord_20240820193600.log,47,ERC777Upgradeable,68587,5114,73701,115.0,0.445215,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../../GSN/ContextUpgradeable.sol"";
import ""./IERC777Upgradeable.sol"";
import ""./IERC777RecipientUpgradeable.sol"";
import ""./IERC777SenderUpgradeable.sol"";
import ""../../token/ERC20/IERC20Upgradeable.sol"";
import ""../../math/SafeMathUpgradeable.sol"";
import ""../../utils/AddressUpgradeable.sol"";
import ""../../introspection/IERC1820RegistryUpgradeable.sol"";
import ""../../proxy/Initializable.sol"";

/**
 * @dev Implementation of the {IERC777} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 *
 * Support for ERC20 is included in this contract, as specified by the EIP: both
 * the ERC777 and ERC20 interfaces can be safely used when interacting with it.
 * Both {IERC777-Sent} and {IERC20-Transfer} events are emitted on token
 * movements.
 *
 * Additionally, the {IERC777-granularity} value is hard-coded to `1`, meaning that there
 * are no special restrictions in the amount of tokens that created, moved, or
 * destroyed. This makes integration with ERC20 applications seamless.
 */
contract ERC777Upgradeable is Initializable, ContextUpgradeable, IERC777Upgradeable, IERC20Upgradeable {
    using SafeMathUpgradeable for uint256;
    using AddressUpgradeable for address;

    IERC1820RegistryUpgradeable constant internal _ERC1820_REGISTRY = IERC1820RegistryUpgradeable(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);

    mapping(address => uint256) private _balances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;

    // We inline the result of the following hashes because Solidity doesn't resolve them at compile time.
    // See https://github.com/ethereum/solidity/issues/4024.

    // keccak256(""ERC777TokensSender"")
    bytes32 constant private _TOKENS_SENDER_INTERFACE_HASH =
        0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;

    // keccak256(""ERC777TokensRecipient"")
    bytes32 constant private _TOKENS_RECIPIENT_INTERFACE_HASH =
        0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;

    // This isn't ever read from - it's only used to respond to the defaultOperators query.
    address[] private _defaultOperatorsArray;

    // Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).
    mapping(address => bool) private _defaultOperators;

    // For each account, a mapping of its operators and revoked default operators.
    mapping(address => mapping(address => bool)) private _operators;
    mapping(address => mapping(address => bool)) private _revokedDefaultOperators;

    // ERC20-allowances
    mapping (address => mapping (address => uint256)) private _allowances;

    /**
     * @dev `defaultOperators` may be an empty array.
     */
    function __ERC777_init(
        string memory name,
        string memory symbol,
        address[] memory defaultOperators
    ) internal initializer {
        __Context_init_unchained();
        __ERC777_init_unchained(name, symbol, defaultOperators);
    }

    function __ERC777_init_unchained(
        string memory name,
        string memory symbol,
        address[] memory defaultOperators
    ) internal initializer {
        _name = name;
        _symbol = symbol;

        _defaultOperatorsArray = defaultOperators;
        for (uint256 i = 0; i < _defaultOperatorsArray.length; i++) {
            _defaultOperators[_defaultOperatorsArray[i]] = true;
        }

        // register interfaces
        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(""ERC777Token""), address(this));
        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(""ERC20Token""), address(this));
    }

    /**
     * @dev See {IERC777-name}.
     */
    function name() public view override returns (string memory) {
        return _name;
    }

    /**
     * @dev See {IERC777-symbol}.
     */
    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev See {ERC20-decimals}.
     *
     * Always returns 18, as per the
     * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).
     */
    function decimals() public pure returns (uint8) {
        return 18;
    }

    /**
     * @dev See {IERC777-granularity}.
     *
     * This implementation always returns `1`.
     */
    function granularity() public view override returns (uint256) {
        return 1;
    }

    /**
     * @dev See {IERC777-totalSupply}.
     */
    function totalSupply() public view override(IERC20Upgradeable, IERC777Upgradeable) returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Returns the amount of tokens owned by an account (`tokenHolder`).
     */
    function balanceOf(address tokenHolder) public view override(IERC20Upgradeable, IERC777Upgradeable) returns (uint256) {
        return _balances[tokenHolder];
    }

    /**
     * @dev See {IERC777-send}.
     *
     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.
     */
    function send(address recipient, uint256 amount, bytes memory data) public override  {
        _send(_msgSender(), recipient, amount, data, """", true);
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}
     * interface if it is a contract.
     *
     * Also emits a {Sent} event.
     */
    function transfer(address recipient, uint256 amount) public override returns (bool) {
        require(recipient != address(0), ""ERC777: transfer to the zero address"");

        address from = _msgSender();

        _callTokensToSend(from, from, recipient, amount, """", """");

        _move(from, from, recipient, amount, """", """");

        _callTokensReceived(from, from, recipient, amount, """", """", false);

        return true;
    }

    /**
     * @dev See {IERC777-burn}.
     *
     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.
     */
    function burn(uint256 amount, bytes memory data) public override  {
        _burn(_msgSender(), amount, data, """");
    }

    /**
     * @dev See {IERC777-isOperatorFor}.
     */
    function isOperatorFor(
        address operator,
        address tokenHolder
    ) public view override returns (bool) {
        return operator == tokenHolder ||
            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||
            _operators[tokenHolder][operator];
    }

    /**
     * @dev See {IERC777-authorizeOperator}.
     */
    function authorizeOperator(address operator) public override  {
        require(_msgSender() != operator, ""ERC777: authorizing self as operator"");

        if (_defaultOperators[operator]) {
            delete _revokedDefaultOperators[_msgSender()][operator];
        } else {
            _operators[_msgSender()][operator] = true;
        }

        emit AuthorizedOperator(operator, _msgSender());
    }

    /**
     * @dev See {IERC777-revokeOperator}.
     */
    function revokeOperator(address operator) public override  {
        require(operator != _msgSender(), ""ERC777: revoking self as operator"");

        if (_defaultOperators[operator]) {
            _revokedDefaultOperators[_msgSender()][operator] = true;
        } else {
            delete _operators[_msgSender()][operator];
        }

        emit RevokedOperator(operator, _msgSender());
    }

    /**
     * @dev See {IERC777-defaultOperators}.
     */
    function defaultOperators() public view override returns (address[] memory) {
        return _defaultOperatorsArray;
    }

    /**
     * @dev See {IERC777-operatorSend}.
     *
     * Emits {Sent} and {IERC20-Transfer} events.
     */
    function operatorSend(
        address sender,
        address recipient,
        uint256 amount,
        bytes memory data,
        bytes memory operatorData
    )
    public override
    {
        require(isOperatorFor(_msgSender(), sender), ""ERC777: caller is not an operator for holder"");
        _send(sender, recipient, amount, data, operatorData, true);
    }

    /**
     * @dev See {IERC777-operatorBurn}.
     *
     * Emits {Burned} and {IERC20-Transfer} events.
     */
    function operatorBurn(address account, uint256 amount, bytes memory data, bytes memory operatorData) public override {
        require(isOperatorFor(_msgSender(), account), ""ERC777: caller is not an operator for holder"");
        _burn(account, amount, data, operatorData);
    }

    /**
     * @dev See {IERC20-allowance}.
     *
     * Note that operator and allowance concepts are orthogonal: operators may
     * not have allowance, and accounts with allowance may not be operators
     * themselves.
     */
    function allowance(address holder, address spender) public view override returns (uint256) {
        return _allowances[holder][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Note that accounts cannot have allowance issued by their operators.
     */
    function approve(address spender, uint256 value) public override returns (bool) {
        address holder = _msgSender();
        _approve(holder, spender, value);
        return true;
    }

   /**
    * @dev See {IERC20-transferFrom}.
    *
    * Note that operator and allowance concepts are orthogonal: operators cannot
    * call `transferFrom` (unless they have allowance), and accounts with
    * allowance cannot call `operatorSend` (unless they are operators).
    *
    * Emits {Sent}, {IERC20-Transfer} and {IERC20-Approval} events.
    */
    function transferFrom(address holder, address recipient, uint256 amount) public override returns (bool) {
        require(recipient != address(0), ""ERC777: transfer to the zero address"");
        require(holder != address(0), ""ERC777: transfer from the zero address"");

        address spender = _msgSender();

        _callTokensToSend(spender, holder, recipient, amount, """", """");

        _move(spender, holder, recipient, amount, """", """");
        _approve(holder, spender, _allowances[holder][spender].sub(amount, ""ERC777: transfer amount exceeds allowance""));

        _callTokensReceived(spender, holder, recipient, amount, """", """", false);

        return true;
    }

    /**
     * @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * If a send hook is registered for `account`, the corresponding function
     * will be called with `operator`, `data` and `operatorData`.
     *
     * See {IERC777Sender} and {IERC777Recipient}.
     *
     * Emits {Minted} and {IERC20-Transfer} events.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - if `account` is a contract, it must implement the {IERC777Recipient}
     * interface.
     */
    function _mint(
        address account,
        uint256 amount,
        bytes memory userData,
        bytes memory operatorData
    )
    internal virtual
    {
        require(account != address(0), ""ERC777: mint to the zero address"");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, address(0), account, amount);

        // Update state variables
        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);

        _callTokensReceived(operator, address(0), account, amount, userData, operatorData, true);

        emit Minted(operator, account, amount, userData, operatorData);
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Send tokens
     * @param from address token holder address
     * @param to address recipient address
     * @param amount uint256 amount of tokens to transfer
     * @param userData bytes extra information provided by the token holder (if any)
     * @param operatorData bytes extra information provided by the operator (if any)
     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient
     */
    function _send(
        address from,
        address to,
        uint256 amount,
        bytes memory userData,
        bytes memory operatorData,
        bool requireReceptionAck
    )
        internal
    {
        require(from != address(0), ""ERC777: send from the zero address"");
        require(to != address(0), ""ERC777: send to the zero address"");

        address operator = _msgSender();

        _callTokensToSend(operator, from, to, amount, userData, operatorData);

        _move(operator, from, to, amount, userData, operatorData);

        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);
    }

    /**
     * @dev Burn tokens
     * @param from address token holder address
     * @param amount uint256 amount of tokens to burn
     * @param data bytes extra information provided by the token holder
     * @param operatorData bytes extra information provided by the operator (if any)
     */
    function _burn(
        address from,
        uint256 amount,
        bytes memory data,
        bytes memory operatorData
    )
        internal virtual
    {
        require(from != address(0), ""ERC777: burn from the zero address"");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, from, address(0), amount);

        _callTokensToSend(operator, from, address(0), amount, data, operatorData);

        // Update state variables
        _balances[from] = _balances[from].sub(amount, ""ERC777: burn amount exceeds balance"");
        _totalSupply = _totalSupply.sub(amount);

        emit Burned(operator, from, amount, data, operatorData);
        emit Transfer(from, address(0), amount);
    }

    function _move(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes memory userData,
        bytes memory operatorData
    )
        private
    {
        _beforeTokenTransfer(operator, from, to, amount);

        _balances[from] = _balances[from].sub(amount, ""ERC777: transfer amount exceeds balance"");
        _balances[to] = _balances[to].add(amount);

        emit Sent(operator, from, to, amount, userData, operatorData);
        emit Transfer(from, to, amount);
    }

    /**
     * @dev See {ERC20-_approve}.
     *
     * Note that accounts cannot have allowance issued by their operators.
     */
    function _approve(address holder, address spender, uint256 value) internal {
        require(holder != address(0), ""ERC777: approve from the zero address"");
        require(spender != address(0), ""ERC777: approve to the zero address"");

        _allowances[holder][spender] = value;
        emit Approval(holder, spender, value);
    }

    /**
     * @dev Call from.tokensToSend() if the interface is registered
     * @param operator address operator requesting the transfer
     * @param from address token holder address
     * @param to address recipient address
     * @param amount uint256 amount of tokens to transfer
     * @param userData bytes extra information provided by the token holder (if any)
     * @param operatorData bytes extra information provided by the operator (if any)
     */
    function _callTokensToSend(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes memory userData,
        bytes memory operatorData
    )
        private
    {
        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(from, _TOKENS_SENDER_INTERFACE_HASH);
        if (implementer != address(0)) {
            IERC777SenderUpgradeable(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);
        }
    }

    /**
     * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but
     * tokensReceived() was not registered for the recipient
     * @param operator address operator requesting the transfer
     * @param from address token holder address
     * @param to address recipient address
     * @param amount uint256 amount of tokens to transfer
     * @param userData bytes extra information provided by the token holder (if any)
     * @param operatorData bytes extra information provided by the operator (if any)
     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient
     */
    function _callTokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes memory userData,
        bytes memory operatorData,
        bool requireReceptionAck
    )
        private
    {
        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(to, _TOKENS_RECIPIENT_INTERFACE_HASH);
        if (implementer != address(0)) {
            IERC777RecipientUpgradeable(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);
        } else if (requireReceptionAck) {
            require(!to.isContract(), ""ERC777: token recipient contract has no implementer for ERC777TokensRecipient"");
        }
    }

    /**
     * @dev Hook that is called before any token transfer. This includes
     * calls to {send}, {transfer}, {operatorSend}, minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be to transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(address operator, address from, address to, uint256 amount) internal virtual { }
    uint256[41] private __gap;
}",4119
RealWorld_BA_47_App_RealWord_20240820190139.log,47,App,21204,5402,26606,84.0,0.21406,"pragma solidity ^0.5.0;

import ""./ImplementationProvider.sol"";
import ""./Package.sol"";
import ""../upgradeability/AdminUpgradeabilityProxy.sol"";
import ""../ownership/Ownable.sol"";

/**
 * @title App
 * @dev Contract for upgradeable applications.
 * It handles the creation of proxies.
 */
contract App is OpenZeppelinUpgradesOwnable {
  /**
   * @dev Emitted when a new proxy is created.
   * @param proxy Address of the created proxy.
   */
  event ProxyCreated(address proxy);

  /**
   * @dev Emitted when a package dependency is changed in the application.
   * @param providerName Name of the package that changed.
   * @param package Address of the package associated to the name.
   * @param version Version of the package in use.
   */
  event PackageChanged(string providerName, address package, uint64[3] version);

  /**
   * @dev Tracks a package in a particular version, used for retrieving implementations
   */
  struct ProviderInfo {
    Package package;
    uint64[3] version;
  }

  /**
   * @dev Maps from dependency name to a tuple of package and version
   */
  mapping(string => ProviderInfo) internal providers;

  /**
   * @dev Constructor function.
   */
  constructor() public { }

  /**
   * @dev Returns the provider for a given package name, or zero if not set.
   * @param packageName Name of the package to be retrieved.
   * @return The provider.
   */
  function getProvider(string memory packageName) public view returns (ImplementationProvider provider) {
    ProviderInfo storage info = providers[packageName];
    if (address(info.package) == address(0)) return ImplementationProvider(0);
    return ImplementationProvider(info.package.getContract(info.version));
  }

  /**
   * @dev Returns information on a package given its name.
   * @param packageName Name of the package to be queried.
   * @return A tuple with the package address and pinned version given a package name, or zero if not set
   */
  function getPackage(string memory packageName) public view returns (Package, uint64[3] memory) {
    ProviderInfo storage info = providers[packageName];
    return (info.package, info.version);
  }

  /**
   * @dev Sets a package in a specific version as a dependency for this application.
   * Requires the version to be present in the package.
   * @param packageName Name of the package to set or overwrite.
   * @param package Address of the package to register.
   * @param version Version of the package to use in this application.
   */
  function setPackage(string memory packageName, Package package, uint64[3] memory version) public onlyOwner {
    require(package.hasVersion(version), ""The requested version must be registered in the given package"");
    providers[packageName] = ProviderInfo(package, version);
    emit PackageChanged(packageName, address(package), version);
  }

  /**
   * @dev Unsets a package given its name.
   * Reverts if the package is not set in the application.
   * @param packageName Name of the package to remove.
   */
  function unsetPackage(string memory packageName) public onlyOwner {
    require(address(providers[packageName].package) != address(0), ""Package to unset not found"");
    delete providers[packageName];
    emit PackageChanged(packageName, address(0), [uint64(0), uint64(0), uint64(0)]);
  }

  /**
   * @dev Returns the implementation address for a given contract name, provided by the `ImplementationProvider`.
   * @param packageName Name of the package where the contract is contained.
   * @param contractName Name of the contract.
   * @return Address where the contract is implemented.
   */
  function getImplementation(string memory packageName, string memory contractName) public view returns (address) {
    ImplementationProvider provider = getProvider(packageName);
    if (address(provider) == address(0)) return address(0);
    return provider.getImplementation(contractName);
  }

  /**
   * @dev Creates a new proxy for the given contract and forwards a function call to it.
   * This is useful to initialize the proxied contract.
   * @param packageName Name of the package where the contract is contained.
   * @param contractName Name of the contract.
   * @param admin Address of the proxy administrator.
   * @param data Data to send as msg.data to the corresponding implementation to initialize the proxied contract.
   * It should include the signature and the parameters of the function to be called, as described in
   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.
   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.
   * @return Address of the new proxy.
   */
   function create(string memory packageName, string memory contractName, address admin, bytes memory data) payable public returns (AdminUpgradeabilityProxy) {
     address implementation = getImplementation(packageName, contractName);
     AdminUpgradeabilityProxy proxy = (new AdminUpgradeabilityProxy).value(msg.value)(implementation, admin, data);
     emit ProxyCreated(address(proxy));
     return proxy;
  }
}",1100
RealWorld_BA_47_InitializableAdminUpgradeabilityProxy_RealWord_20240820191826.log,47,InitializableAdminUpgradeabilityProxy,8084,5284,13368,91.0,0.1461,"pragma solidity ^0.5.0;

import './BaseAdminUpgradeabilityProxy.sol';
import './InitializableUpgradeabilityProxy.sol';

/**
 * @title InitializableAdminUpgradeabilityProxy
 * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for 
 * initializing the implementation, admin, and init data.
 */
contract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {
  /**
   * Contract initializer.
   * @param _logic address of the initial implementation.
   * @param _admin Address of the proxy administrator.
   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.
   * It should include the signature and the parameters of the function to be called, as described in
   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.
   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.
   */
  function initialize(address _logic, address _admin, bytes memory _data) public payable {
    require(_implementation() == address(0));
    InitializableUpgradeabilityProxy.initialize(_logic, _data);
    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));
    _setAdmin(_admin);
  }
}",293
RealWorld_BA_47_ERC721BurnableUpgradeable_RealWord_20240820194132.log,47,ERC721BurnableUpgradeable,7102,4928,12030,89.0,0.13407,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../../GSN/ContextUpgradeable.sol"";
import ""./ERC721Upgradeable.sol"";
import ""../../proxy/Initializable.sol"";

/**
 * @title ERC721 Burnable Token
 * @dev ERC721 Token that can be irreversibly burned (destroyed).
 */
abstract contract ERC721BurnableUpgradeable is Initializable, ContextUpgradeable, ERC721Upgradeable {
    function __ERC721Burnable_init() internal initializer {
        __Context_init_unchained();
        __ERC165_init_unchained();
        __ERC721Burnable_init_unchained();
    }

    function __ERC721Burnable_init_unchained() internal initializer {
    }
    /**
     * @dev Burns `tokenId`. See {ERC721-_burn}.
     *
     * Requirements:
     *
     * - The caller must own `tokenId` or be an approved operator.
     */
    function burn(uint256 tokenId) public virtual {
        //solhint-disable-next-line max-line-length
        require(_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721Burnable: caller is not owner nor approved"");
        _burn(tokenId);
    }
    uint256[50] private __gap;
}",259
RealWorld_BA_47_OwnableUpgradeable_RealWord_20240820201037.log,47,OwnableUpgradeable,12396,5203,17599,100.0,0.16604,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../GSN/ContextUpgradeable.sol"";
import ""../proxy/Initializable.sol"";
/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
contract OwnableUpgradeable is Initializable, ContextUpgradeable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    function __Ownable_init() internal initializer {
        __Context_init_unchained();
        __Ownable_init_unchained();
    }

    function __Ownable_init_unchained() internal initializer {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(_owner == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
    uint256[49] private __gap;
}",551
RealWorld_BA_47_ReentrancyGuardUpgradeable_RealWord_20240820203703.log,47,ReentrancyGuardUpgradeable,14046,4723,18769,80.0,0.16469,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;
import ""../proxy/Initializable.sol"";

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
contract ReentrancyGuardUpgradeable is Initializable {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    function __ReentrancyGuard_init() internal initializer {
        __ReentrancyGuard_init_unchained();
    }

    function __ReentrancyGuard_init_unchained() internal initializer {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
    uint256[49] private __gap;
}",675
RealWorld_BA_47_PausableUpgradeable_RealWord_20240820203528.log,47,PausableUpgradeable,12019,4538,16557,93.0,0.150855,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../GSN/ContextUpgradeable.sol"";
import ""../proxy/Initializable.sol"";

/**
 * @dev Contract module which allows children to implement an emergency stop
 * mechanism that can be triggered by an authorized account.
 *
 * This module is used through inheritance. It will make available the
 * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
 * the functions of your contract. Note that they will not be pausable by
 * simply including this module, only once the modifiers are put in place.
 */
contract PausableUpgradeable is Initializable, ContextUpgradeable {
    /**
     * @dev Emitted when the pause is triggered by `account`.
     */
    event Paused(address account);

    /**
     * @dev Emitted when the pause is lifted by `account`.
     */
    event Unpaused(address account);

    bool private _paused;

    /**
     * @dev Initializes the contract in unpaused state.
     */
    function __Pausable_init() internal initializer {
        __Context_init_unchained();
        __Pausable_init_unchained();
    }

    function __Pausable_init_unchained() internal initializer {
        _paused = false;
    }

    /**
     * @dev Returns true if the contract is paused, and false otherwise.
     */
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    modifier whenNotPaused() {
        require(!_paused, ""Pausable: paused"");
        _;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is paused.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    modifier whenPaused() {
        require(_paused, ""Pausable: not paused"");
        _;
    }

    /**
     * @dev Triggers stopped state.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(_msgSender());
    }

    /**
     * @dev Returns to normal state.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(_msgSender());
    }
    uint256[49] private __gap;
}",557
RealWorld_BA_47_ERC721PresetMinterPauserAutoIdUpgradeable_RealWord_20240820210358.log,47,ERC721PresetMinterPauserAutoIdUpgradeable,21078,5758,26836,120.0,0.22055,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../access/AccessControlUpgradeable.sol"";
import ""../GSN/ContextUpgradeable.sol"";
import ""../utils/CountersUpgradeable.sol"";
import ""../token/ERC721/ERC721Upgradeable.sol"";
import ""../token/ERC721/ERC721BurnableUpgradeable.sol"";
import ""../token/ERC721/ERC721PausableUpgradeable.sol"";
import ""../proxy/Initializable.sol"";

/**
 * @dev {ERC721} token, including:
 *
 *  - ability for holders to burn (destroy) their tokens
 *  - a minter role that allows for token minting (creation)
 *  - a pauser role that allows to stop all token transfers
 *  - token ID and URI autogeneration
 *
 * This contract uses {AccessControl} to lock permissioned functions using the
 * different roles - head to its documentation for details.
 *
 * The account that deploys the contract will be granted the minter and pauser
 * roles, as well as the default admin role, which will let it grant both minter
 * and pauser roles to other accounts.
 */
contract ERC721PresetMinterPauserAutoIdUpgradeable is Initializable, ContextUpgradeable, AccessControlUpgradeable, ERC721BurnableUpgradeable, ERC721PausableUpgradeable {
    function initialize(string memory name, string memory symbol, string memory baseURI) public virtual initializer {
        __ERC721PresetMinterPauserAutoId_init(name, symbol, baseURI);
    }
    using CountersUpgradeable for CountersUpgradeable.Counter;

    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");
    bytes32 public constant PAUSER_ROLE = keccak256(""PAUSER_ROLE"");

    CountersUpgradeable.Counter private _tokenIdTracker;

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    function __ERC721PresetMinterPauserAutoId_init(string memory name, string memory symbol, string memory baseURI) internal initializer {
        __Context_init_unchained();
        __AccessControl_init_unchained();
        __ERC165_init_unchained();
        __ERC721_init_unchained(name, symbol);
        __ERC721Burnable_init_unchained();
        __Pausable_init_unchained();
        __ERC721Pausable_init_unchained();
        __ERC721PresetMinterPauserAutoId_init_unchained(name, symbol, baseURI);
    }

    function __ERC721PresetMinterPauserAutoId_init_unchained(string memory name, string memory symbol, string memory baseURI) internal initializer {
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());

        _setupRole(MINTER_ROLE, _msgSender());
        _setupRole(PAUSER_ROLE, _msgSender());

        _setBaseURI(baseURI);
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     */
    function mint(address to) public virtual {
        require(hasRole(MINTER_ROLE, _msgSender()), ""ERC721PresetMinterPauserAutoId: must have minter role to mint"");

        // We cannot just use balanceOf to create the new tokenId because tokens
        // can be burned (destroyed), so we need a separate counter.
        _mint(to, _tokenIdTracker.current());
        _tokenIdTracker.increment();
    }

    /**
     * @dev Pauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_pause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function pause() public virtual {
        require(hasRole(PAUSER_ROLE, _msgSender()), ""ERC721PresetMinterPauserAutoId: must have pauser role to pause"");
        _pause();
    }

    /**
     * @dev Unpauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_unpause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function unpause() public virtual {
        require(hasRole(PAUSER_ROLE, _msgSender()), ""ERC721PresetMinterPauserAutoId: must have pauser role to unpause"");
        _unpause();
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override(ERC721Upgradeable, ERC721PausableUpgradeable) {
        super._beforeTokenTransfer(from, to, tokenId);
    }
    uint256[49] private __gap;
}",1105
RealWorld_BA_47_IERC1155MetadataURIUpgradeable_RealWord_20240820195904.log,47,IERC1155MetadataURIUpgradeable,5841,4512,10353,86.0,0.119445,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""./IERC1155Upgradeable.sol"";

/**
 * @dev Interface of the optional ERC1155MetadataExtension interface, as defined
 * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].
 *
 * _Available since v3.1._
 */
interface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {
    /**
     * @dev Returns the URI for token type `id`.
     *
     * If the `\{id\}` substring is present in the URI, it must be replaced by
     * clients with the actual token type ID.
     */
    function uri(uint256 id) external view returns (string memory);
}",162
RealWorld_BA_47_ICore_RealWord_20240820185029.log,47,ICore,5903,6176,12079,85.0,0.153035,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

interface ICore {
    function mint(
        uint256 btc,
        address account,
        bytes32[] calldata merkleProof
    ) external returns (uint256);

    function redeem(uint256 btc, address account) external returns (uint256);

    function btcToBbtc(uint256 btc) external view returns (uint256, uint256);

    function bBtcToBtc(uint256 bBtc) external view returns (uint256 btc, uint256 fee);

    function pricePerShare() external view returns (uint256);

    function setGuestList(address guestlist) external;

    function collectFee() external;

    function owner() external view returns (address);
}",155
RealWorld_BA_47_ERC165CheckerUpgradeable_RealWord_20240820205038.log,47,ERC165CheckerUpgradeable,19865,5265,25130,109.0,0.204625,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

/**
 * @dev Library used to query support of an interface declared via {IERC165}.
 *
 * Note that these functions return the actual result of the query: they do not
 * `revert` if an interface is not supported. It is up to the caller to decide
 * what to do in these cases.
 */
library ERC165CheckerUpgradeable {
    // As per the EIP-165 spec, no interface should ever match 0xffffffff
    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;

    /*
     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7
     */
    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;

    /**
     * @dev Returns true if `account` supports the {IERC165} interface,
     */
    function supportsERC165(address account) internal view returns (bool) {
        // Any contract that implements ERC165 must explicitly indicate support of
        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid
        return _supportsERC165Interface(account, _INTERFACE_ID_ERC165) &&
            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);
    }

    /**
     * @dev Returns true if `account` supports the interface defined by
     * `interfaceId`. Support for {IERC165} itself is queried automatically.
     *
     * See {IERC165-supportsInterface}.
     */
    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {
        // query support of both ERC165 as per the spec and support of _interfaceId
        return supportsERC165(account) &&
            _supportsERC165Interface(account, interfaceId);
    }

    /**
     * @dev Returns true if `account` supports all the interfaces defined in
     * `interfaceIds`. Support for {IERC165} itself is queried automatically.
     *
     * Batch-querying can lead to gas savings by skipping repeated checks for
     * {IERC165} support.
     *
     * See {IERC165-supportsInterface}.
     */
    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {
        // query support of ERC165 itself
        if (!supportsERC165(account)) {
            return false;
        }

        // query support of each interface in _interfaceIds
        for (uint256 i = 0; i < interfaceIds.length; i++) {
            if (!_supportsERC165Interface(account, interfaceIds[i])) {
                return false;
            }
        }

        // all interfaces supported
        return true;
    }

    /**
     * @notice Query if a contract implements an interface, does not check ERC165 support
     * @param account The address of the contract to query for support of an interface
     * @param interfaceId The interface identifier, as specified in ERC-165
     * @return true if the contract at account indicates support of the interface with
     * identifier interfaceId, false otherwise
     * @dev Assumes that account contains a contract that supports ERC165, otherwise
     * the behavior of this method is undefined. This precondition can be checked
     * with {supportsERC165}.
     * Interface identification is specified in ERC-165.
     */
    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {
        // success determines whether the staticcall succeeded and result determines
        // whether the contract at account indicates support of _interfaceId
        (bool success, bool result) = _callERC165SupportsInterface(account, interfaceId);

        return (success && result);
    }

    /**
     * @notice Calls the function with selector 0x01ffc9a7 (ERC165) and suppresses throw
     * @param account The address of the contract to query for support of an interface
     * @param interfaceId The interface identifier, as specified in ERC-165
     * @return success true if the STATICCALL succeeded, false otherwise
     * @return result true if the STATICCALL succeeded and the contract at account
     * indicates support of the interface with identifier interfaceId, false otherwise
     */
    function _callERC165SupportsInterface(address account, bytes4 interfaceId)
        private
        view
        returns (bool, bool)
    {
        bytes memory encodedParams = abi.encodeWithSelector(_INTERFACE_ID_ERC165, interfaceId);
        (bool success, bytes memory result) = account.staticcall{ gas: 30000 }(encodedParams);
        if (result.length < 32) return (false, false);
        return (success, abi.decode(result, (bool)));
    }
}",1008
RealWorld_BA_47_ECDSAUpgradeable_RealWord_20240820202342.log,47,ECDSAUpgradeable,17797,5071,22868,95.0,0.190405,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.
 *
 * These functions can be used to verify that a message was signed by the holder
 * of the private keys of a given address.
 */
library ECDSAUpgradeable {
    /**
     * @dev Returns the address that signed a hashed message (`hash`) with
     * `signature`. This address can then be used for verification purposes.
     *
     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
     * this function rejects them by requiring the `s` value to be in the lower
     * half order, and the `v` value to be either 27 or 28.
     *
     * IMPORTANT: `hash` _must_ be the result of a hash operation for the
     * verification to be secure: it is possible to craft signatures that
     * recover to arbitrary addresses for non-hashed data. A safe way to ensure
     * this is by receiving a hash of the original message (which may otherwise
     * be too long), and then calling {toEthSignedMessageHash} on it.
     */
    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
        // Check the signature length
        if (signature.length != 65) {
            revert(""ECDSA: invalid signature length"");
        }

        // Divide the signature in r, s and v variables
        bytes32 r;
        bytes32 s;
        uint8 v;

        // ecrecover takes the signature parameters, and the only way to get them
        // currently is to use assembly.
        // solhint-disable-next-line no-inline-assembly
        assembly {
            r := mload(add(signature, 0x20))
            s := mload(add(signature, 0x40))
            v := byte(0, mload(add(signature, 0x60)))
        }

        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most
        // signatures from current libraries generate a unique signature with an s-value in the lower half order.
        //
        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
        // these malleable signatures as well.
        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
            revert(""ECDSA: invalid signature 's' value"");
        }

        if (v != 27 && v != 28) {
            revert(""ECDSA: invalid signature 'v' value"");
        }

        // If the signature is valid (and not malleable), return the signer address
        address signer = ecrecover(hash, v, r, s);
        require(signer != address(0), ""ECDSA: invalid signature"");

        return signer;
    }

    /**
     * @dev Returns an Ethereum Signed Message, created from a `hash`. This
     * replicates the behavior of the
     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]
     * JSON-RPC method.
     *
     * See {recover}.
     */
    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
        // 32 is the length in bytes of hash,
        // enforced by the type signature above
        return keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash));
    }
}",922
RealWorld_BA_47_ImplementationDirectory_RealWord_20240820190440.log,47,ImplementationDirectory,11451,5237,16688,78.0,0.161995,"pragma solidity ^0.5.0;

import ""./ImplementationProvider.sol"";
import ""../ownership/Ownable.sol"";
import '../utils/Address.sol';

/**
 * @title ImplementationDirectory
 * @dev Implementation provider that stores contract implementations in a mapping.
 */
contract ImplementationDirectory is ImplementationProvider, OpenZeppelinUpgradesOwnable {
  /**
   * @dev Emitted when the implementation of a contract is changed.
   * @param contractName Name of the contract.
   * @param implementation Address of the added implementation.
   */
  event ImplementationChanged(string contractName, address indexed implementation);

  /**
   * @dev Emitted when the implementation directory is frozen.
   */
  event Frozen();

  /// @dev Mapping where the addresses of the implementations are stored.
  mapping (string => address) internal implementations;

  /// @dev Mutability state of the directory.
  bool public frozen;

  /**
   * @dev Modifier that allows functions to be called only before the contract is frozen.
   */
  modifier whenNotFrozen() {
    require(!frozen, ""Cannot perform action for a frozen implementation directory"");
    _;
  }

  /**
   * @dev Makes the directory irreversibly immutable.
   * It can only be called once, by the owner.
   */
  function freeze() onlyOwner whenNotFrozen public {
    frozen = true;
    emit Frozen();
  }

  /**
   * @dev Returns the implementation address of a contract.
   * @param contractName Name of the contract.
   * @return Address of the implementation.
   */
  function getImplementation(string memory contractName) public view returns (address) {
    return implementations[contractName];
  }

  /**
   * @dev Sets the address of the implementation of a contract in the directory.
   * @param contractName Name of the contract.
   * @param implementation Address of the implementation.
   */
  function setImplementation(string memory contractName, address implementation) public onlyOwner whenNotFrozen {
    require(OpenZeppelinUpgradesAddress.isContract(implementation), ""Cannot set implementation in directory with a non-contract address"");
    implementations[contractName] = implementation;
    emit ImplementationChanged(contractName, implementation);
  }

  /**
   * @dev Removes the address of a contract implementation from the directory.
   * @param contractName Name of the contract.
   */
  function unsetImplementation(string memory contractName) public onlyOwner whenNotFrozen {
    implementations[contractName] = address(0);
    emit ImplementationChanged(contractName, address(0));
  }
}",521
RealWorld_BA_47_GSNRecipientERC20FeeUpgradeable_RealWord_20240820201857.log,47,GSNRecipientERC20FeeUpgradeable,29063,5155,34218,108.0,0.248415,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./GSNRecipientUpgradeable.sol"";
import ""../math/SafeMathUpgradeable.sol"";
import ""../access/OwnableUpgradeable.sol"";
import ""../token/ERC20/SafeERC20Upgradeable.sol"";
import ""../token/ERC20/ERC20Upgradeable.sol"";
import ""../proxy/Initializable.sol"";

/**
 * @dev A xref:ROOT:gsn-strategies.adoc#gsn-strategies[GSN strategy] that charges transaction fees in a special purpose ERC20
 * token, which we refer to as the gas payment token. The amount charged is exactly the amount of Ether charged to the
 * recipient. This means that the token is essentially pegged to the value of Ether.
 *
 * The distribution strategy of the gas payment token to users is not defined by this contract. It's a mintable token
 * whose only minter is the recipient, so the strategy must be implemented in a derived contract, making use of the
 * internal {_mint} function.
 */
contract GSNRecipientERC20FeeUpgradeable is Initializable, GSNRecipientUpgradeable {
    using SafeERC20Upgradeable for __unstable__ERC20OwnedUpgradeable;
    using SafeMathUpgradeable for uint256;

    enum GSNRecipientERC20FeeErrorCodes {
        INSUFFICIENT_BALANCE
    }

    __unstable__ERC20OwnedUpgradeable private _token;

    /**
     * @dev The arguments to the constructor are the details that the gas payment token will have: `name` and `symbol`. `decimals` is hard-coded to 18.
     */
    function __GSNRecipientERC20Fee_init(string memory name, string memory symbol) internal initializer {
        __Context_init_unchained();
        __GSNRecipient_init_unchained();
        __GSNRecipientERC20Fee_init_unchained(name, symbol);
    }

    function __GSNRecipientERC20Fee_init_unchained(string memory name, string memory symbol) internal initializer {
        _token = new __unstable__ERC20OwnedUpgradeable();
        _token.initialize(name, symbol);
    }

    /**
     * @dev Returns the gas payment token.
     */
    function token() public view returns (IERC20Upgradeable) {
        return IERC20Upgradeable(_token);
    }

    /**
     * @dev Internal function that mints the gas payment token. Derived contracts should expose this function in their public API, with proper access control mechanisms.
     */
    function _mint(address account, uint256 amount) internal virtual {
        _token.mint(account, amount);
    }

    /**
     * @dev Ensures that only users with enough gas payment token balance can have transactions relayed through the GSN.
     */
    function acceptRelayedCall(
        address,
        address from,
        bytes memory,
        uint256 transactionFee,
        uint256 gasPrice,
        uint256,
        uint256,
        bytes memory,
        uint256 maxPossibleCharge
    )
        public
        view
        virtual
        override
        returns (uint256, bytes memory)
    {
        if (_token.balanceOf(from) < maxPossibleCharge) {
            return _rejectRelayedCall(uint256(GSNRecipientERC20FeeErrorCodes.INSUFFICIENT_BALANCE));
        }

        return _approveRelayedCall(abi.encode(from, maxPossibleCharge, transactionFee, gasPrice));
    }

    /**
     * @dev Implements the precharge to the user. The maximum possible charge (depending on gas limit, gas price, and
     * fee) will be deducted from the user balance of gas payment token. Note that this is an overestimation of the
     * actual charge, necessary because we cannot predict how much gas the execution will actually need. The remainder
     * is returned to the user in {_postRelayedCall}.
     */
    function _preRelayedCall(bytes memory context) internal virtual override returns (bytes32) {
        (address from, uint256 maxPossibleCharge) = abi.decode(context, (address, uint256));

        // The maximum token charge is pre-charged from the user
        _token.safeTransferFrom(from, address(this), maxPossibleCharge);
    }

    /**
     * @dev Returns to the user the extra amount that was previously charged, once the actual execution cost is known.
     */
    function _postRelayedCall(bytes memory context, bool, uint256 actualCharge, bytes32) internal virtual override {
        (address from, uint256 maxPossibleCharge, uint256 transactionFee, uint256 gasPrice) =
            abi.decode(context, (address, uint256, uint256, uint256));

        // actualCharge is an _estimated_ charge, which assumes postRelayedCall will use all available gas.
        // This implementation's gas cost can be roughly estimated as 10k gas, for the two SSTORE operations in an
        // ERC20 transfer.
        uint256 overestimation = _computeCharge(_POST_RELAYED_CALL_MAX_GAS.sub(10000), gasPrice, transactionFee);
        actualCharge = actualCharge.sub(overestimation);

        // After the relayed call has been executed and the actual charge estimated, the excess pre-charge is returned
        _token.safeTransfer(from, maxPossibleCharge.sub(actualCharge));
    }
    uint256[49] private __gap;
}

/**
 * @title __unstable__ERC20Owned
 * @dev An ERC20 token owned by another contract, which has minting permissions and can use transferFrom to receive
 * anyone's tokens. This contract is an internal helper for GSNRecipientERC20Fee, and should not be used
 * outside of this context.
 */
// solhint-disable-next-line contract-name-camelcase
contract __unstable__ERC20OwnedUpgradeable is Initializable, ERC20Upgradeable, OwnableUpgradeable {
    function initialize(string memory name, string memory symbol) public virtual initializer {
        ____unstable__ERC20Owned_init(name, symbol);
    }
    uint256 private constant _UINT256_MAX = 2**256 - 1;

    function ____unstable__ERC20Owned_init(string memory name, string memory symbol) internal initializer {
        __Context_init_unchained();
        __ERC20_init_unchained(name, symbol);
        __Ownable_init_unchained();
        ____unstable__ERC20Owned_init_unchained(name, symbol);
    }

    function ____unstable__ERC20Owned_init_unchained(string memory name, string memory symbol) internal initializer { }

    // The owner (GSNRecipientERC20Fee) can mint tokens
    function mint(address account, uint256 amount) public onlyOwner {
        _mint(account, amount);
    }

    // The owner has 'infinite' allowance for all token holders
    function allowance(address tokenOwner, address spender) public view override returns (uint256) {
        if (spender == owner()) {
            return _UINT256_MAX;
        } else {
            return super.allowance(tokenOwner, spender);
        }
    }

    // Allowance for the owner cannot be changed (it is always 'infinite')
    function _approve(address tokenOwner, address spender, uint256 value) internal override {
        if (spender == owner()) {
            return;
        } else {
            super._approve(tokenOwner, spender, value);
        }
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        if (recipient == owner()) {
            _transfer(sender, recipient, amount);
            return true;
        } else {
            return super.transferFrom(sender, recipient, amount);
        }
    }
    uint256[50] private __gap;
}",1614
RealWorld_BA_47_ConditionalEscrowUpgradeable_RealWord_20240820202833.log,47,ConditionalEscrowUpgradeable,7477,4646,12123,92.0,0.130305,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./EscrowUpgradeable.sol"";
import ""../../proxy/Initializable.sol"";

/**
 * @title ConditionalEscrow
 * @dev Base abstract escrow to only allow withdrawal if a condition is met.
 * @dev Intended usage: See {Escrow}. Same usage guidelines apply here.
 */
abstract contract ConditionalEscrowUpgradeable is Initializable, EscrowUpgradeable {
    function __ConditionalEscrow_init() internal initializer {
        __Context_init_unchained();
        __Ownable_init_unchained();
        __Escrow_init_unchained();
        __ConditionalEscrow_init_unchained();
    }

    function __ConditionalEscrow_init_unchained() internal initializer {
    }
    /**
     * @dev Returns whether an address is allowed to withdraw their funds. To be
     * implemented by derived contracts.
     * @param payee The destination address of the funds.
     */
    function withdrawalAllowed(address payee) public view virtual returns (bool);

    function withdraw(address payable payee) public virtual override {
        require(withdrawalAllowed(payee), ""ConditionalEscrow: payee is not allowed to withdraw"");
        super.withdraw(payee);
    }
    uint256[50] private __gap;
}",270
RealWorld_BA_47_IERC1820RegistryUpgradeable_RealWord_20240820205540.log,47,IERC1820RegistryUpgradeable,20689,4463,25152,91.0,0.192705,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Interface of the global ERC1820 Registry, as defined in the
 * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register
 * implementers for interfaces in this registry, as well as query support.
 *
 * Implementers may be shared by multiple accounts, and can also implement more
 * than a single interface for each account. Contracts can implement interfaces
 * for themselves, but externally-owned accounts (EOA) must delegate this to a
 * contract.
 *
 * {IERC165} interfaces can also be queried via the registry.
 *
 * For an in-depth explanation and source code analysis, see the EIP text.
 */
interface IERC1820RegistryUpgradeable {
    /**
     * @dev Sets `newManager` as the manager for `account`. A manager of an
     * account is able to set interface implementers for it.
     *
     * By default, each account is its own manager. Passing a value of `0x0` in
     * `newManager` will reset the manager to this initial state.
     *
     * Emits a {ManagerChanged} event.
     *
     * Requirements:
     *
     * - the caller must be the current manager for `account`.
     */
    function setManager(address account, address newManager) external;

    /**
     * @dev Returns the manager for `account`.
     *
     * See {setManager}.
     */
    function getManager(address account) external view returns (address);

    /**
     * @dev Sets the `implementer` contract as ``account``'s implementer for
     * `interfaceHash`.
     *
     * `account` being the zero address is an alias for the caller's address.
     * The zero address can also be used in `implementer` to remove an old one.
     *
     * See {interfaceHash} to learn how these are created.
     *
     * Emits an {InterfaceImplementerSet} event.
     *
     * Requirements:
     *
     * - the caller must be the current manager for `account`.
     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not
     * end in 28 zeroes).
     * - `implementer` must implement {IERC1820Implementer} and return true when
     * queried for support, unless `implementer` is the caller. See
     * {IERC1820Implementer-canImplementInterfaceForAddress}.
     */
    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;

    /**
     * @dev Returns the implementer of `interfaceHash` for `account`. If no such
     * implementer is registered, returns the zero address.
     *
     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28
     * zeroes), `account` will be queried for support of it.
     *
     * `account` being the zero address is an alias for the caller's address.
     */
    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);

    /**
     * @dev Returns the interface hash for an `interfaceName`, as defined in the
     * corresponding
     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].
     */
    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);

    /**
     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.
     *  @param account Address of the contract for which to update the cache.
     *  @param interfaceId ERC165 interface for which to update the cache.
     */
    function updateERC165Cache(address account, bytes4 interfaceId) external;

    /**
     *  @notice Checks whether a contract implements an ERC165 interface or not.
     *  If the result is not cached a direct lookup on the contract address is performed.
     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling
     *  {updateERC165Cache} with the contract address.
     *  @param account Address of the contract to check.
     *  @param interfaceId ERC165 interface to check.
     *  @return True if `account` implements `interfaceId`, false otherwise.
     */
    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);

    /**
     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.
     *  @param account Address of the contract to check.
     *  @param interfaceId ERC165 interface to check.
     *  @return True if `account` implements `interfaceId`, false otherwise.
     */
    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);

    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);

    event ManagerChanged(address indexed account, address indexed newManager);
}",1098
RealWorld_BA_47_Create2Upgradeable_RealWord_20240820203946.log,47,Create2Upgradeable,12626,4922,17548,96.0,0.16157,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.
 * `CREATE2` can be used to compute in advance the address where a smart
 * contract will be deployed, which allows for interesting new mechanisms known
 * as 'counterfactual interactions'.
 *
 * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more
 * information.
 */
library Create2Upgradeable {
    /**
     * @dev Deploys a contract using `CREATE2`. The address where the contract
     * will be deployed can be known in advance via {computeAddress}.
     *
     * The bytecode for a contract can be obtained from Solidity with
     * `type(contractName).creationCode`.
     *
     * Requirements:
     *
     * - `bytecode` must not be empty.
     * - `salt` must have not been used for `bytecode` already.
     * - the factory must have a balance of at least `amount`.
     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.
     */
    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {
        address addr;
        require(address(this).balance >= amount, ""Create2: insufficient balance"");
        require(bytecode.length != 0, ""Create2: bytecode length is zero"");
        // solhint-disable-next-line no-inline-assembly
        assembly {
            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)
        }
        require(addr != address(0), ""Create2: Failed on deploy"");
        return addr;
    }

    /**
     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the
     * `bytecodeHash` or `salt` will result in a new destination address.
     */
    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {
        return computeAddress(salt, bytecodeHash, address(this));
    }

    /**
     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at
     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.
     */
    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {
        bytes32 _data = keccak256(
            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)
        );
        return address(uint256(_data));
    }
}",580
RealWorld_BA_47_ICoreOracle_RealWord_20240820185156.log,47,ICoreOracle,3475,4288,7763,69.0,0.103135,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

interface ICoreOracle {
    function pricePerShare() external view returns (uint256);
}",35
RealWorld_BA_47_WrappedIbbtcEth_RealWord_20240820185425.log,47,WrappedIbbtcEth,25434,6424,31858,112.0,0.25565,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.6.12;

import ""../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""./ICore.sol"";

/*
    Wrapped Interest-Bearing Bitcoin (Ethereum mainnet variant)
*/
contract WrappedIbbtcEth is Initializable, ERC20Upgradeable {
    address public governance;
    address public pendingGovernance;
    ERC20Upgradeable public ibbtc; 
    
    ICore public core;

    uint256 public pricePerShare;
    uint256 public lastPricePerShareUpdate;

    event SetCore(address core);
    event SetPricePerShare(uint256 pricePerShare, uint256 updateTimestamp);
    event SetPendingGovernance(address pendingGovernance);
    event AcceptPendingGovernance(address pendingGovernance);

    /// ===== Modifiers =====
    modifier onlyPendingGovernance() {
        require(msg.sender == pendingGovernance, ""onlyPendingGovernance"");
        _;
    }

    modifier onlyGovernance() {
        require(msg.sender == governance, ""onlyGovernance"");
        _;
    }

    function initialize(address _governance, address _ibbtc, address _core) public initializer {
        __ERC20_init(""Wrapped Interest-Bearing Bitcoin"", ""wibBTC"");
        governance = _governance;
        core = ICore(_core);
        ibbtc = ERC20Upgradeable(_ibbtc);

        updatePricePerShare();

        emit SetCore(_core);
    }

    /// ===== Permissioned: Governance =====
    function setPendingGovernance(address _pendingGovernance) external onlyGovernance {
        pendingGovernance = _pendingGovernance;
        emit SetPendingGovernance(pendingGovernance);
    }

    /// @dev The ibBTC token is technically capable of having it's Core contract changed via governance process. This allows the wrapper to adapt.
    /// @dev This function should be run atomically with setCore() on ibBTC if that eventuality ever arises.
    function setCore(address _core) external onlyGovernance {
        core = ICore(_core);
        emit SetCore(_core);
    }

    /// ===== Permissioned: Pending Governance =====
    function acceptPendingGovernance() external onlyPendingGovernance {
        governance = pendingGovernance;
        emit AcceptPendingGovernance(pendingGovernance);
    }

    /// ===== Permissionless Calls =====

    /// @dev Update live ibBTC price per share from core
    /// @dev We cache this to reduce gas costs of mint / burn / transfer operations.
    /// @dev Update function is permissionless, and must be updated at least once every X time as a sanity check to ensure value is up-to-date
    function updatePricePerShare() public virtual returns (uint256) {
        pricePerShare = core.pricePerShare();
        lastPricePerShareUpdate = now;

        emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate);
    }

    /// @dev Deposit ibBTC to mint wibBTC shares
    function mint(uint256 _shares) external {
        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));
        _mint(_msgSender(), _shares);
    }

    /// @dev Redeem wibBTC for ibBTC. Denominated in shares.
    function burn(uint256 _shares) external {
        _burn(_msgSender(), _shares);
        require(ibbtc.transfer(_msgSender(), _shares));
    }

    /// ===== Transfer Overrides =====
    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        /// The _balances mapping represents the underlying ibBTC shares (""non-rebased balances"")
        /// Some naming confusion emerges due to maintaining original ERC20 var names

        uint256 amountInShares = balanceToShares(amount);

        _transfer(sender, recipient, amountInShares);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        /// The _balances mapping represents the underlying ibBTC shares (""non-rebased balances"")
        /// Some naming confusion emerges due to maintaining original ERC20 var names

        uint256 amountInShares = balanceToShares(amount);

        _transfer(_msgSender(), recipient, amountInShares);
        return true;
    }

    /// ===== View Methods =====

    /// @dev Wrapped ibBTC shares of account
    function sharesOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /// @dev Current account shares * pricePerShare
    function balanceOf(address account) public view override returns (uint256) {
        return sharesOf(account).mul(pricePerShare).div(1e18);
    }

    /// @dev Total wrapped ibBTC shares
    function totalShares() public view returns (uint256) {
        return _totalSupply;
    }

    /// @dev Current total shares * pricePerShare
    function totalSupply() public view override returns (uint256) {
        return totalShares().mul(pricePerShare).div(1e18);
    }

    function balanceToShares(uint256 balance) public view returns (uint256) {
        return balance.mul(1e18).div(pricePerShare);
    }

    function sharesToBalance(uint256 shares) public view returns (uint256) {
        return shares.mul(pricePerShare).div(1e18);
    }
}",1337
RealWorld_BA_47_EnumerableMapUpgradeable_RealWord_20240820203338.log,47,EnumerableMapUpgradeable,35654,5188,40842,108.0,0.28203,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Library for managing an enumerable variant of Solidity's
 * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]
 * type.
 *
 * Maps have the following properties:
 *
 * - Entries are added, removed, and checked for existence in constant time
 * (O(1)).
 * - Entries are enumerated in O(n). No guarantees are made on the ordering.
 *
 * ```
 * contract Example {
 *     // Add the library methods
 *     using EnumerableMap for EnumerableMap.UintToAddressMap;
 *
 *     // Declare a set state variable
 *     EnumerableMap.UintToAddressMap private myMap;
 * }
 * ```
 *
 * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are
 * supported.
 */
library EnumerableMapUpgradeable {
    // To implement this library for multiple types with as little code
    // repetition as possible, we write it in terms of a generic Map type with
    // bytes32 keys and values.
    // The Map implementation uses private functions, and user-facing
    // implementations (such as Uint256ToAddressMap) are just wrappers around
    // the underlying Map.
    // This means that we can only create new EnumerableMaps for types that fit
    // in bytes32.

    struct MapEntry {
        bytes32 _key;
        bytes32 _value;
    }

    struct Map {
        // Storage of map keys and values
        MapEntry[] _entries;

        // Position of the entry defined by a key in the `entries` array, plus 1
        // because index 0 means a key is not in the map.
        mapping (bytes32 => uint256) _indexes;
    }

    /**
     * @dev Adds a key-value pair to a map, or updates the value for an existing
     * key. O(1).
     *
     * Returns true if the key was added to the map, that is if it was not
     * already present.
     */
    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {
        // We read and store the key's index to prevent multiple reads from the same storage slot
        uint256 keyIndex = map._indexes[key];

        if (keyIndex == 0) { // Equivalent to !contains(map, key)
            map._entries.push(MapEntry({ _key: key, _value: value }));
            // The entry is stored at length-1, but we add 1 to all indexes
            // and use 0 as a sentinel value
            map._indexes[key] = map._entries.length;
            return true;
        } else {
            map._entries[keyIndex - 1]._value = value;
            return false;
        }
    }

    /**
     * @dev Removes a key-value pair from a map. O(1).
     *
     * Returns true if the key was removed from the map, that is if it was present.
     */
    function _remove(Map storage map, bytes32 key) private returns (bool) {
        // We read and store the key's index to prevent multiple reads from the same storage slot
        uint256 keyIndex = map._indexes[key];

        if (keyIndex != 0) { // Equivalent to contains(map, key)
            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one
            // in the array, and then remove the last entry (sometimes called as 'swap and pop').
            // This modifies the order of the array, as noted in {at}.

            uint256 toDeleteIndex = keyIndex - 1;
            uint256 lastIndex = map._entries.length - 1;

            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs
            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.

            MapEntry storage lastEntry = map._entries[lastIndex];

            // Move the last entry to the index where the entry to delete is
            map._entries[toDeleteIndex] = lastEntry;
            // Update the index for the moved entry
            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based

            // Delete the slot where the moved entry was stored
            map._entries.pop();

            // Delete the index for the deleted slot
            delete map._indexes[key];

            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Returns true if the key is in the map. O(1).
     */
    function _contains(Map storage map, bytes32 key) private view returns (bool) {
        return map._indexes[key] != 0;
    }

    /**
     * @dev Returns the number of key-value pairs in the map. O(1).
     */
    function _length(Map storage map) private view returns (uint256) {
        return map._entries.length;
    }

   /**
    * @dev Returns the key-value pair stored at position `index` in the map. O(1).
    *
    * Note that there are no guarantees on the ordering of entries inside the
    * array, and it may change when more entries are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {
        require(map._entries.length > index, ""EnumerableMap: index out of bounds"");

        MapEntry storage entry = map._entries[index];
        return (entry._key, entry._value);
    }

    /**
     * @dev Returns the value associated with `key`.  O(1).
     *
     * Requirements:
     *
     * - `key` must be in the map.
     */
    function _get(Map storage map, bytes32 key) private view returns (bytes32) {
        return _get(map, key, ""EnumerableMap: nonexistent key"");
    }

    /**
     * @dev Same as {_get}, with a custom error message when `key` is not in the map.
     */
    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {
        uint256 keyIndex = map._indexes[key];
        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)
        return map._entries[keyIndex - 1]._value; // All indexes are 1-based
    }

    // UintToAddressMap

    struct UintToAddressMap {
        Map _inner;
    }

    /**
     * @dev Adds a key-value pair to a map, or updates the value for an existing
     * key. O(1).
     *
     * Returns true if the key was added to the map, that is if it was not
     * already present.
     */
    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {
        return _set(map._inner, bytes32(key), bytes32(uint256(value)));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the key was removed from the map, that is if it was present.
     */
    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {
        return _remove(map._inner, bytes32(key));
    }

    /**
     * @dev Returns true if the key is in the map. O(1).
     */
    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {
        return _contains(map._inner, bytes32(key));
    }

    /**
     * @dev Returns the number of elements in the map. O(1).
     */
    function length(UintToAddressMap storage map) internal view returns (uint256) {
        return _length(map._inner);
    }

   /**
    * @dev Returns the element stored at position `index` in the set. O(1).
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {
        (bytes32 key, bytes32 value) = _at(map._inner, index);
        return (uint256(key), address(uint256(value)));
    }

    /**
     * @dev Returns the value associated with `key`.  O(1).
     *
     * Requirements:
     *
     * - `key` must be in the map.
     */
    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {
        return address(uint256(_get(map._inner, bytes32(key))));
    }

    /**
     * @dev Same as {get}, with a custom error message when `key` is not in the map.
     */
    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {
        return address(uint256(_get(map._inner, bytes32(key), errorMessage)));
    }
}",2016
RealWorld_BA_47_MerkleProofUpgradeable_RealWord_20240820202221.log,47,MerkleProofUpgradeable,7889,5141,13030,79.0,0.142265,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev These functions deal with verification of Merkle trees (hash trees),
 */
library MerkleProofUpgradeable {
    /**
     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree
     * defined by `root`. For this, a `proof` must be provided, containing
     * sibling hashes on the branch from the leaf to the root of the tree. Each
     * pair of leaves and each pair of pre-images are assumed to be sorted.
     */
    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash <= proofElement) {
                // Hash(current computed hash + current element of the proof)
                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
            } else {
                // Hash(current element of the proof + current computed hash)
                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
            }
        }

        // Check if the computed hash (root) is equal to the provided root
        return computedHash == root;
    }
}",293
RealWorld_BA_47_PullPaymentUpgradeable_RealWord_20240820202519.log,47,PullPaymentUpgradeable,13893,5144,19037,85.0,0.172345,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""./escrow/EscrowUpgradeable.sol"";
import ""../proxy/Initializable.sol"";

/**
 * @dev Simple implementation of a
 * https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls[pull-payment]
 * strategy, where the paying contract doesn't interact directly with the
 * receiver account, which must withdraw its payments itself.
 *
 * Pull-payments are often considered the best practice when it comes to sending
 * Ether, security-wise. It prevents recipients from blocking execution, and
 * eliminates reentrancy concerns.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 *
 * To use, derive from the `PullPayment` contract, and use {_asyncTransfer}
 * instead of Solidity's `transfer` function. Payees can query their due
 * payments with {payments}, and retrieve them with {withdrawPayments}.
 */
contract PullPaymentUpgradeable is Initializable {
    EscrowUpgradeable private _escrow;

    function __PullPayment_init() internal initializer {
        __PullPayment_init_unchained();
    }

    function __PullPayment_init_unchained() internal initializer {
        _escrow = new EscrowUpgradeable();
        _escrow.initialize();
    }

    /**
     * @dev Withdraw accumulated payments, forwarding all gas to the recipient.
     *
     * Note that _any_ account can call this function, not just the `payee`.
     * This means that contracts unaware of the `PullPayment` protocol can still
     * receive funds this way, by having a separate account call
     * {withdrawPayments}.
     *
     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.
     * Make sure you trust the recipient, or are either following the
     * checks-effects-interactions pattern or using {ReentrancyGuard}.
     *
     * @param payee Whose payments will be withdrawn.
     */
    function withdrawPayments(address payable payee) public virtual {
        _escrow.withdraw(payee);
    }

    /**
     * @dev Returns the payments owed to an address.
     * @param dest The creditor's address.
     */
    function payments(address dest) public view returns (uint256) {
        return _escrow.depositsOf(dest);
    }

    /**
     * @dev Called by the payer to store the sent amount as credit to be pulled.
     * Funds sent in this way are stored in an intermediate {Escrow} contract, so
     * there is no danger of them being spent before withdrawal.
     *
     * @param dest The destination address of the funds.
     * @param amount The amount to transfer.
     */
    function _asyncTransfer(address dest, uint256 amount) internal virtual {
        _escrow.deposit{ value: amount }(dest);
    }
    uint256[49] private __gap;
}",660
RealWorld_BA_47_EscrowUpgradeable_RealWord_20240820203150.log,47,EscrowUpgradeable,13352,5380,18732,106.0,0.17436,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../../math/SafeMathUpgradeable.sol"";
import ""../../access/OwnableUpgradeable.sol"";
import ""../../utils/AddressUpgradeable.sol"";
import ""../../proxy/Initializable.sol"";

 /**
  * @title Escrow
  * @dev Base escrow contract, holds funds designated for a payee until they
  * withdraw them.
  *
  * Intended usage: This contract (and derived escrow contracts) should be a
  * standalone contract, that only interacts with the contract that instantiated
  * it. That way, it is guaranteed that all Ether will be handled according to
  * the `Escrow` rules, and there is no need to check for payable functions or
  * transfers in the inheritance tree. The contract that uses the escrow as its
  * payment method should be its owner, and provide public methods redirecting
  * to the escrow's deposit and withdraw.
  */
contract EscrowUpgradeable is Initializable, OwnableUpgradeable {
    function initialize() public virtual initializer {
        __Escrow_init();
    }
    function __Escrow_init() internal initializer {
        __Context_init_unchained();
        __Ownable_init_unchained();
        __Escrow_init_unchained();
    }

    function __Escrow_init_unchained() internal initializer {
    }
    using SafeMathUpgradeable for uint256;
    using AddressUpgradeable for address payable;

    event Deposited(address indexed payee, uint256 weiAmount);
    event Withdrawn(address indexed payee, uint256 weiAmount);

    mapping(address => uint256) private _deposits;

    function depositsOf(address payee) public view returns (uint256) {
        return _deposits[payee];
    }

    /**
     * @dev Stores the sent amount as credit to be withdrawn.
     * @param payee The destination address of the funds.
     */
    function deposit(address payee) public virtual payable onlyOwner {
        uint256 amount = msg.value;
        _deposits[payee] = _deposits[payee].add(amount);

        emit Deposited(payee, amount);
    }

    /**
     * @dev Withdraw accumulated balance for a payee, forwarding all gas to the
     * recipient.
     *
     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.
     * Make sure you trust the recipient, or are either following the
     * checks-effects-interactions pattern or using {ReentrancyGuard}.
     *
     * @param payee The address whose funds will be withdrawn and transferred to.
     */
    function withdraw(address payable payee) public virtual onlyOwner {
        uint256 payment = _deposits[payee];

        _deposits[payee] = 0;

        payee.sendValue(payment);

        emit Withdrawn(payee, payment);
    }
    uint256[49] private __gap;
}",626
RealWorld_BA_47_TokenTimelockUpgradeable_RealWord_20240820192322.log,47,TokenTimelockUpgradeable,11301,4727,16028,113.0,0.151045,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./SafeERC20Upgradeable.sol"";
import ""../../proxy/Initializable.sol"";

/**
 * @dev A token holder contract that will allow a beneficiary to extract the
 * tokens after a given release time.
 *
 * Useful for simple vesting schedules like ""advisors get all of their tokens
 * after 1 year"".
 */
contract TokenTimelockUpgradeable is Initializable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    // ERC20 basic token contract being held
    IERC20Upgradeable private _token;

    // beneficiary of tokens after they are released
    address private _beneficiary;

    // timestamp when token release is enabled
    uint256 private _releaseTime;

    function __TokenTimelock_init(IERC20Upgradeable token, address beneficiary, uint256 releaseTime) internal initializer {
        __TokenTimelock_init_unchained(token, beneficiary, releaseTime);
    }

    function __TokenTimelock_init_unchained(IERC20Upgradeable token, address beneficiary, uint256 releaseTime) internal initializer {
        // solhint-disable-next-line not-rely-on-time
        require(releaseTime > block.timestamp, ""TokenTimelock: release time is before current time"");
        _token = token;
        _beneficiary = beneficiary;
        _releaseTime = releaseTime;
    }

    /**
     * @return the token being held.
     */
    function token() public view returns (IERC20Upgradeable) {
        return _token;
    }

    /**
     * @return the beneficiary of the tokens.
     */
    function beneficiary() public view returns (address) {
        return _beneficiary;
    }

    /**
     * @return the time when the tokens are released.
     */
    function releaseTime() public view returns (uint256) {
        return _releaseTime;
    }

    /**
     * @notice Transfers tokens held by timelock to beneficiary.
     */
    function release() public virtual {
        // solhint-disable-next-line not-rely-on-time
        require(block.timestamp >= _releaseTime, ""TokenTimelock: current time is before release time"");

        uint256 amount = _token.balanceOf(address(this));
        require(amount > 0, ""TokenTimelock: no tokens to release"");

        _token.safeTransfer(_beneficiary, amount);
    }
    uint256[47] private __gap;
}",515
RealWorld_BA_47_SafeCastUpgradeable_RealWord_20240820204621.log,47,SafeCastUpgradeable,30133,4578,34711,86.0,0.242225,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;


/**
 * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow
 * checks.
 *
 * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can
 * easily result in undesired exploitation or bugs, since developers usually
 * assume that overflows raise errors. `SafeCast` restores this intuition by
 * reverting the transaction when such an operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 *
 * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing
 * all math on `uint256` and `int256` and then downcasting.
 */
library SafeCastUpgradeable {

    /**
     * @dev Returns the downcasted uint128 from uint256, reverting on
     * overflow (when the input is greater than largest uint128).
     *
     * Counterpart to Solidity's `uint128` operator.
     *
     * Requirements:
     *
     * - input must fit into 128 bits
     */
    function toUint128(uint256 value) internal pure returns (uint128) {
        require(value < 2**128, ""SafeCast: value doesn\'t fit in 128 bits"");
        return uint128(value);
    }

    /**
     * @dev Returns the downcasted uint64 from uint256, reverting on
     * overflow (when the input is greater than largest uint64).
     *
     * Counterpart to Solidity's `uint64` operator.
     *
     * Requirements:
     *
     * - input must fit into 64 bits
     */
    function toUint64(uint256 value) internal pure returns (uint64) {
        require(value < 2**64, ""SafeCast: value doesn\'t fit in 64 bits"");
        return uint64(value);
    }

    /**
     * @dev Returns the downcasted uint32 from uint256, reverting on
     * overflow (when the input is greater than largest uint32).
     *
     * Counterpart to Solidity's `uint32` operator.
     *
     * Requirements:
     *
     * - input must fit into 32 bits
     */
    function toUint32(uint256 value) internal pure returns (uint32) {
        require(value < 2**32, ""SafeCast: value doesn\'t fit in 32 bits"");
        return uint32(value);
    }

    /**
     * @dev Returns the downcasted uint16 from uint256, reverting on
     * overflow (when the input is greater than largest uint16).
     *
     * Counterpart to Solidity's `uint16` operator.
     *
     * Requirements:
     *
     * - input must fit into 16 bits
     */
    function toUint16(uint256 value) internal pure returns (uint16) {
        require(value < 2**16, ""SafeCast: value doesn\'t fit in 16 bits"");
        return uint16(value);
    }

    /**
     * @dev Returns the downcasted uint8 from uint256, reverting on
     * overflow (when the input is greater than largest uint8).
     *
     * Counterpart to Solidity's `uint8` operator.
     *
     * Requirements:
     *
     * - input must fit into 8 bits.
     */
    function toUint8(uint256 value) internal pure returns (uint8) {
        require(value < 2**8, ""SafeCast: value doesn\'t fit in 8 bits"");
        return uint8(value);
    }

    /**
     * @dev Converts a signed int256 into an unsigned uint256.
     *
     * Requirements:
     *
     * - input must be greater than or equal to 0.
     */
    function toUint256(int256 value) internal pure returns (uint256) {
        require(value >= 0, ""SafeCast: value must be positive"");
        return uint256(value);
    }

    /**
     * @dev Returns the downcasted int128 from int256, reverting on
     * overflow (when the input is less than smallest int128 or
     * greater than largest int128).
     *
     * Counterpart to Solidity's `int128` operator.
     *
     * Requirements:
     *
     * - input must fit into 128 bits
     *
     * _Available since v3.1._
     */
    function toInt128(int256 value) internal pure returns (int128) {
        require(value >= -2**127 && value < 2**127, ""SafeCast: value doesn\'t fit in 128 bits"");
        return int128(value);
    }

    /**
     * @dev Returns the downcasted int64 from int256, reverting on
     * overflow (when the input is less than smallest int64 or
     * greater than largest int64).
     *
     * Counterpart to Solidity's `int64` operator.
     *
     * Requirements:
     *
     * - input must fit into 64 bits
     *
     * _Available since v3.1._
     */
    function toInt64(int256 value) internal pure returns (int64) {
        require(value >= -2**63 && value < 2**63, ""SafeCast: value doesn\'t fit in 64 bits"");
        return int64(value);
    }

    /**
     * @dev Returns the downcasted int32 from int256, reverting on
     * overflow (when the input is less than smallest int32 or
     * greater than largest int32).
     *
     * Counterpart to Solidity's `int32` operator.
     *
     * Requirements:
     *
     * - input must fit into 32 bits
     *
     * _Available since v3.1._
     */
    function toInt32(int256 value) internal pure returns (int32) {
        require(value >= -2**31 && value < 2**31, ""SafeCast: value doesn\'t fit in 32 bits"");
        return int32(value);
    }

    /**
     * @dev Returns the downcasted int16 from int256, reverting on
     * overflow (when the input is less than smallest int16 or
     * greater than largest int16).
     *
     * Counterpart to Solidity's `int16` operator.
     *
     * Requirements:
     *
     * - input must fit into 16 bits
     *
     * _Available since v3.1._
     */
    function toInt16(int256 value) internal pure returns (int16) {
        require(value >= -2**15 && value < 2**15, ""SafeCast: value doesn\'t fit in 16 bits"");
        return int16(value);
    }

    /**
     * @dev Returns the downcasted int8 from int256, reverting on
     * overflow (when the input is less than smallest int8 or
     * greater than largest int8).
     *
     * Counterpart to Solidity's `int8` operator.
     *
     * Requirements:
     *
     * - input must fit into 8 bits.
     *
     * _Available since v3.1._
     */
    function toInt8(int256 value) internal pure returns (int8) {
        require(value >= -2**7 && value < 2**7, ""SafeCast: value doesn\'t fit in 8 bits"");
        return int8(value);
    }

    /**
     * @dev Converts an unsigned uint256 into a signed int256.
     *
     * Requirements:
     *
     * - input must be less than or equal to maxInt256.
     */
    function toInt256(uint256 value) internal pure returns (int256) {
        require(value < 2**255, ""SafeCast: value doesn't fit in an int256"");
        return int256(value);
    }
}",1694
RealWorld_BA_47_ProxyFactory_RealWord_20240820191649.log,47,ProxyFactory,18807,5934,24741,95.0,0.212715,"pragma solidity ^0.5.3;

import ""./InitializableAdminUpgradeabilityProxy.sol"";
import ""../cryptography/ECDSA.sol"";

contract ProxyFactory {
  
  event ProxyCreated(address proxy);

  bytes32 private contractCodeHash;

  constructor() public {
    contractCodeHash = keccak256(
      type(InitializableAdminUpgradeabilityProxy).creationCode
    );
  }

  function deployMinimal(address _logic, bytes memory _data) public returns (address proxy) {
    // Adapted from https://github.com/optionality/clone-factory/blob/32782f82dfc5a00d103a7e61a17a5dedbd1e8e9d/contracts/CloneFactory.sol
    bytes20 targetBytes = bytes20(_logic);
    assembly {
      let clone := mload(0x40)
      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
      mstore(add(clone, 0x14), targetBytes)
      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
      proxy := create(0, clone, 0x37)
    }
    
    emit ProxyCreated(address(proxy));

    if(_data.length > 0) {
      (bool success,) = proxy.call(_data);
      require(success);
    }    
  }

  function deploy(uint256 _salt, address _logic, address _admin, bytes memory _data) public returns (address) {
    return _deployProxy(_salt, _logic, _admin, _data, msg.sender);
  }

  function deploySigned(uint256 _salt, address _logic, address _admin, bytes memory _data, bytes memory _signature) public returns (address) {
    address signer = getSigner(_salt, _logic, _admin, _data, _signature);
    require(signer != address(0), ""Invalid signature"");
    return _deployProxy(_salt, _logic, _admin, _data, signer);
  }

  function getDeploymentAddress(uint256 _salt, address _sender) public view returns (address) {
    // Adapted from https://github.com/archanova/solidity/blob/08f8f6bedc6e71c24758d20219b7d0749d75919d/contracts/contractCreator/ContractCreator.sol
    bytes32 salt = _getSalt(_salt, _sender);
    bytes32 rawAddress = keccak256(
      abi.encodePacked(
        bytes1(0xff),
        address(this),
        salt,
        contractCodeHash
      )
    );

    return address(bytes20(rawAddress << 96));
  }

  function getSigner(uint256 _salt, address _logic, address _admin, bytes memory _data, bytes memory _signature) public view returns (address) {
    bytes32 msgHash = OpenZeppelinUpgradesECDSA.toEthSignedMessageHash(
      keccak256(
        abi.encodePacked(
          _salt, _logic, _admin, _data, address(this)
        )
      )
    );

    return OpenZeppelinUpgradesECDSA.recover(msgHash, _signature);
  }

  function _deployProxy(uint256 _salt, address _logic, address _admin, bytes memory _data, address _sender) internal returns (address) {
    InitializableAdminUpgradeabilityProxy proxy = _createProxy(_salt, _sender);
    emit ProxyCreated(address(proxy));
    proxy.initialize(_logic, _admin, _data);
    return address(proxy);
  }

  function _createProxy(uint256 _salt, address _sender) internal returns (InitializableAdminUpgradeabilityProxy) {
    address payable addr;
    bytes memory code = type(InitializableAdminUpgradeabilityProxy).creationCode;
    bytes32 salt = _getSalt(_salt, _sender);

    assembly {
      addr := create2(0, add(code, 0x20), mload(code), salt)
      if iszero(extcodesize(addr)) {
        revert(0, 0)
      }
    }

    return InitializableAdminUpgradeabilityProxy(addr);
  }

  function _getSalt(uint256 _salt, address _sender) internal pure returns (bytes32) {
    return keccak256(abi.encodePacked(_salt, _sender)); 
  }
}",951
RealWorld_BA_47_IERC721ReceiverUpgradeable_RealWord_20240820195252.log,47,IERC721ReceiverUpgradeable,6355,4357,10712,90.0,0.118915,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @title ERC721 token receiver interface
 * @dev Interface for any contract that wants to support safeTransfers
 * from ERC721 asset contracts.
 */
interface IERC721ReceiverUpgradeable {
    /**
     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
     * by `operator` from `from`, this function is called.
     *
     * It must return its Solidity selector to confirm the token transfer.
     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
     *
     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
     */
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)
    external returns (bytes4);
}",198
RealWorld_BA_47_ERC1155BurnableUpgradeable_RealWord_20240820200201.log,47,ERC1155BurnableUpgradeable,8240,5357,13597,97.0,0.14834,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./ERC1155Upgradeable.sol"";
import ""../../proxy/Initializable.sol"";

/**
 * @dev Extension of {ERC1155} that allows token holders to destroy both their
 * own tokens and those that they have been approved to use.
 *
 * _Available since v3.1._
 */
abstract contract ERC1155BurnableUpgradeable is Initializable, ERC1155Upgradeable {
    function __ERC1155Burnable_init() internal initializer {
        __Context_init_unchained();
        __ERC165_init_unchained();
        __ERC1155Burnable_init_unchained();
    }

    function __ERC1155Burnable_init_unchained() internal initializer {
    }
    function burn(address account, uint256 id, uint256 value) public virtual {
        require(
            account == _msgSender() || isApprovedForAll(account, _msgSender()),
            ""ERC1155: caller is not owner nor approved""
        );

        _burn(account, id, value);
    }

    function burnBatch(address account, uint256[] memory ids, uint256[] memory values) public virtual {
        require(
            account == _msgSender() || isApprovedForAll(account, _msgSender()),
            ""ERC1155: caller is not owner nor approved""
        );

        _burnBatch(account, ids, values);
    }
    uint256[50] private __gap;
}",303
RealWorld_BA_47_ContextUpgradeable_RealWord_20240820201738.log,47,ContextUpgradeable,7442,4210,11652,77.0,0.12141,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;
import ""../proxy/Initializable.sol"";

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract ContextUpgradeable is Initializable {
    function __Context_init() internal initializer {
        __Context_init_unchained();
    }

    function __Context_init_unchained() internal initializer {
    }
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
    uint256[50] private __gap;
}",250
RealWorld_BA_47_IRelayRecipientUpgradeable_RealWord_20240820201551.log,47,IRelayRecipientUpgradeable,17817,5027,22844,105.0,0.189625,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Base interface for a contract that will be called via the GSN from {IRelayHub}.
 *
 * TIP: You don't need to write an implementation yourself! Inherit from {GSNRecipient} instead.
 */
interface IRelayRecipientUpgradeable {
    /**
     * @dev Returns the address of the {IRelayHub} instance this recipient interacts with.
     */
    function getHubAddr() external view returns (address);

    /**
     * @dev Called by {IRelayHub} to validate if this recipient accepts being charged for a relayed call. Note that the
     * recipient will be charged regardless of the execution result of the relayed call (i.e. if it reverts or not).
     *
     * The relay request was originated by `from` and will be served by `relay`. `encodedFunction` is the relayed call
     * calldata, so its first four bytes are the function selector. The relayed call will be forwarded `gasLimit` gas,
     * and the transaction executed with a gas price of at least `gasPrice`. ``relay``'s fee is `transactionFee`, and the
     * recipient will be charged at most `maxPossibleCharge` (in wei). `nonce` is the sender's (`from`) nonce for
     * replay attack protection in {IRelayHub}, and `approvalData` is a optional parameter that can be used to hold a signature
     * over all or some of the previous values.
     *
     * Returns a tuple, where the first value is used to indicate approval (0) or rejection (custom non-zero error code,
     * values 1 to 10 are reserved) and the second one is data to be passed to the other {IRelayRecipient} functions.
     *
     * {acceptRelayedCall} is called with 50k gas: if it runs out during execution, the request will be considered
     * rejected. A regular revert will also trigger a rejection.
     */
    function acceptRelayedCall(
        address relay,
        address from,
        bytes calldata encodedFunction,
        uint256 transactionFee,
        uint256 gasPrice,
        uint256 gasLimit,
        uint256 nonce,
        bytes calldata approvalData,
        uint256 maxPossibleCharge
    )
        external
        view
        returns (uint256, bytes memory);

    /**
     * @dev Called by {IRelayHub} on approved relay call requests, before the relayed call is executed. This allows to e.g.
     * pre-charge the sender of the transaction.
     *
     * `context` is the second value returned in the tuple by {acceptRelayedCall}.
     *
     * Returns a value to be passed to {postRelayedCall}.
     *
     * {preRelayedCall} is called with 100k gas: if it runs out during execution or otherwise reverts, the relayed call
     * will not be executed, but the recipient will still be charged for the transaction's cost.
     */
    function preRelayedCall(bytes calldata context) external returns (bytes32);

    /**
     * @dev Called by {IRelayHub} on approved relay call requests, after the relayed call is executed. This allows to e.g.
     * charge the user for the relayed call costs, return any overcharges from {preRelayedCall}, or perform
     * contract-specific bookkeeping.
     *
     * `context` is the second value returned in the tuple by {acceptRelayedCall}. `success` is the execution status of
     * the relayed call. `actualCharge` is an estimate of how much the recipient will be charged for the transaction,
     * not including any gas used by {postRelayedCall} itself. `preRetVal` is {preRelayedCall}'s return value.
     *
     *
     * {postRelayedCall} is called with 100k gas: if it runs out during execution or otherwise reverts, the relayed call
     * and the call to {preRelayedCall} will be reverted retroactively, but the recipient will still be charged for the
     * transaction's cost.
     */
    function postRelayedCall(bytes calldata context, bool success, uint256 actualCharge, bytes32 preRetVal) external;
}",917
RealWorld_BA_47_IERC1155Upgradeable_RealWord_20240820195424.log,47,IERC1155Upgradeable,18714,5401,24115,87.0,0.20159,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""../../introspection/IERC165Upgradeable.sol"";

/**
 * @dev Required interface of an ERC1155 compliant contract, as defined in the
 * https://eips.ethereum.org/EIPS/eip-1155[EIP].
 *
 * _Available since v3.1._
 */
interface IERC1155Upgradeable is IERC165Upgradeable {
    /**
     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.
     */
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);

    /**
     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all
     * transfers.
     */
    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);

    /**
     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to
     * `approved`.
     */
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);

    /**
     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.
     *
     * If an {URI} event was emitted for `id`, the standard
     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value
     * returned by {IERC1155MetadataURI-uri}.
     */
    event URI(string value, uint256 indexed id);

    /**
     * @dev Returns the amount of tokens of token type `id` owned by `account`.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function balanceOf(address account, uint256 id) external view returns (uint256);

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.
     *
     * Requirements:
     *
     * - `accounts` and `ids` must have the same length.
     */
    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);

    /**
     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,
     *
     * Emits an {ApprovalForAll} event.
     *
     * Requirements:
     *
     * - `operator` cannot be the caller.
     */
    function setApprovalForAll(address operator, bool approved) external;

    /**
     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.
     *
     * See {setApprovalForAll}.
     */
    function isApprovedForAll(address account, address operator) external view returns (bool);

    /**
     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.
     * - `from` must have a balance of tokens of type `id` of at least `amount`.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.
     *
     * Emits a {TransferBatch} event.
     *
     * Requirements:
     *
     * - `ids` and `amounts` must have the same length.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
     * acceptance magic value.
     */
    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;
}",975
RealWorld_BA_49_OverlayV1Comptroller_RealWord_20240820232902.log,49,OverlayV1Comptroller,63183,5392,68575,119.0,0.423755,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""../libraries/FixedPoint.sol"";

import ""./OverlayV1Governance.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

abstract contract OverlayV1Comptroller {

    using FixedPoint for uint256;

    uint256 private constant INVERSE_E = 0x51AF86713316A9A;
    uint256 private constant ONE = 1e18;

    // length of roller arrays when we circle
    uint256 constant CHORD = 60;

    // current element for new rolls
    uint256 public impactCycloid;
    uint256 public brrrrdCycloid;

    Roller[60] public impactRollers;
    Roller[60] public brrrrdRollers;

    struct Roller {
        uint time;
        uint ying;
        uint yang;
    }

    struct ImpactRoller {
        uint time;
        uint lPressure;
        uint sPressure;
    }

    struct BrrrrRoller {
        uint time;
        uint brrr;
        uint anti;
    }

    uint256 public immutable impactWindow;
    uint256 internal staticCap;
    uint256 public lmbda;

    uint256[2] public brrrrdAccumulator;
    uint256 public brrrrdWindowMicro;
    uint256 public brrrrdWindowMacro;
    uint256 public brrrrdExpected;
    uint256 public brrrrdFiling;

    constructor (
        uint256 _impactWindow
    ) {

        impactWindow = _impactWindow;

        impactRollers[0] = Roller({
            time: block.timestamp,
            ying: 0,
            yang: 0
        });

        brrrrdRollers[0] = Roller({
            time: block.timestamp,
            ying: 0,
            yang: 0
        });

    }

    function brrrr (
        uint _brrrr,
        uint _antiBrrrr
    ) internal {

        uint _now = block.timestamp;
        uint _brrrrdFiling = brrrrdFiling;

        if ( _now > _brrrrdFiling ) { // time to roll in the brrrrr

            uint _brrrrdCycloid = brrrrdCycloid;

            Roller memory _roller = brrrrdRollers[_brrrrdCycloid];

            uint _lastMoment = _roller.time;

            _roller.time = _brrrrdFiling;
            _roller.ying += brrrrdAccumulator[0];
            _roller.yang += brrrrdAccumulator[1];

            brrrrdCycloid = roll(brrrrdRollers, _roller, _lastMoment, _brrrrdCycloid);

            brrrrdAccumulator[0] = _brrrr;
            brrrrdAccumulator[1] = _antiBrrrr;

            uint _brrrrdWindowMicro = brrrrdWindowMicro;

            brrrrdFiling += _brrrrdWindowMicro
                + ( ( ( _now - _brrrrdFiling ) / _brrrrdWindowMicro ) * _brrrrdWindowMicro );

        } else { // add to the brrrr accumulator

            brrrrdAccumulator[0] += _brrrr;
            brrrrdAccumulator[1] += _antiBrrrr;

        }

    }

    function getBrrrrd () public view returns (
        uint brrrrd_,
        uint antiBrrrrd_
    ) {

        (  ,Roller memory _rollerNow,
            Roller memory _rollerThen ) = scry(
                brrrrdRollers,
                brrrrdCycloid,
                brrrrdWindowMacro
            );

        brrrrd_ = brrrrdAccumulator[0] + _rollerNow.ying - _rollerThen.ying;

        antiBrrrrd_ = brrrrdAccumulator[1] + _rollerNow.yang - _rollerThen.yang;

    }


    /// @notice Takes in the open interest and appllies Overlay's monetary policy
    /// @dev The impact is a measure of the demand placed on the market over a
    /// rolling window. It determines the amount of collateral to be burnt.
    /// This is akin to slippage in an order book model.
    /// @param _isLong Is it taking out open interest on the long or short side?
    /// @param _oi The amount of open interest attempting to be taken out
    /// @param _cap The current open interest cap
    /// @return impact_ A factor between zero and one to be applied to initial
    /// open interest to determine how much to take from the initial collateral
    /// before calculating the final collateral and open interest
    function intake (
        bool _isLong,
        uint _oi,
        uint _cap
    ) internal returns (
        uint impact_
    ) {

        (   Roller memory _rollerImpact,
            uint _lastMoment,
            uint _impact ) = _intake(_isLong, _oi, _cap);

        impactCycloid = roll(
            impactRollers,
            _rollerImpact,
            _lastMoment,
            impactCycloid
        );

        impact_ = _oi.mulUp(_impact);

        brrrr( 0, impact_ );

    }


    /// @notice Internal method to get historic impact data for impact factor
    /// @dev Historic data is represented as a sum of pressure accumulating
    /// over the impact window.
    /// @dev Pressure is the fraction of the open interest cap that any given
    /// build tries to take out on one side.  It can range from zero to infinity
    /// but will settle at a reasonable value otherwise any build will burn all
    /// of its initial collateral and receive a worthless position.
    /// @dev The sum of historic pressure is multiplied with lambda to yield
    /// the power by which we raise the inverse of Euler's number in order to
    /// determine the final impact.
    /// @param _isLong The side that open interest is being be taken out on.
    /// @param _oi The amount of open interest.
    /// @param _cap The open interest cap.
    /// @return rollerNow_ The current roller for the impact rollers. Impact
    /// from this particular call is accumulated on it for writing to storage.
    /// @return lastMoment_ The timestamp of the previously written roller
    /// which to determine whether to write to the current or the next.
    /// @return impact_ The factor by which to take from initial collateral.
    function _intake (
        bool _isLong,
        uint _oi,
        uint _cap
    ) internal view returns (
        Roller memory rollerNow_,
        uint lastMoment_,
        uint impact_
    ) {

        (   uint _lastMoment,
            Roller memory _rollerNow,
            Roller memory _rollerImpact ) = scry(
                impactRollers,
                impactCycloid,
                impactWindow );

        uint _pressure = _oi.divDown(_cap);

        if (_isLong) _rollerNow.ying += _pressure;
        else _rollerNow.yang += _pressure;

        uint _power = lmbda.mulDown(_isLong
            ? _rollerNow.ying - _rollerImpact.ying
            : _rollerNow.yang - _rollerImpact.yang
        );

        lastMoment_ = _lastMoment;
        rollerNow_ = _rollerNow;
        impact_ = _pressure != 0
            ? ONE.sub(INVERSE_E.powUp(_power))
            : 0;

    }


    /// @notice Internal function to compute cap.
    /// @dev Determines the cap relative to depth and dynamic or static
    /// @param _dynamic If printing has exceeded expectations and the
    /// cap is dynamic or static.
    /// @param _depth The depth of the market feed in OVL terms.
    /// @param _staticCap The static cap of the market.
    /// @param _brrrrd How much has been printed. Only passed if printing
    /// has occurred.
    /// @param _brrrrdExpected How much the market expects to print before
    /// engaging the dynamic cap. Only passed if printing has occurred.
    function _oiCap (
        bool _dynamic,
        uint _depth,
        uint _staticCap,
        uint _brrrrd,
        uint _brrrrdExpected
    ) internal pure returns (
        uint cap_
    ) {

        if (_dynamic) {

            uint _dynamicCap = ( 2e18 - _brrrrd.divDown(_brrrrdExpected) ).mulDown(_staticCap);
            cap_ = Math.min(_staticCap, Math.min(_dynamicCap, _depth));

        } else cap_ = Math.min(_staticCap, _depth);

    }


    /// @notice The open interest cap for the market
    /// @dev Returns the open interest cap for the market.
    /// @return cap_ The open interest cap.
    function oiCap () public virtual view returns (
        uint cap_
    ) {

        (   uint _brrrrd,
            uint _antiBrrrrd ) = getBrrrrd();

        uint _brrrrdExpected = brrrrdExpected;

        bool _burnt;
        bool _expected;
        bool _surpassed;

        if (_brrrrd < _antiBrrrrd) _burnt = true;
        else {
            _brrrrd -= _antiBrrrrd;
            _expected = _brrrrd < _brrrrdExpected;
            _surpassed = _brrrrd > _brrrrdExpected * 2;
        }

        cap_ = _surpassed ? 0 : _burnt || _expected
            ? _oiCap(false, depth(), staticCap, 0, 0)
            : _oiCap(true, depth(), staticCap, _brrrrd, brrrrdExpected);

    }


    /// @notice The time weighted liquidity of the market feed in OVL terms.
    /// @return depth_ The amount of liquidity in the market feed in OVL terms.
    function depth () public virtual view returns (uint depth_);

    /// @notice Performs arithmetic to turn market liquidity into OVL terms.
    /// @dev Derived from cnstant product formula X*Y=K and tailored 
    /// to Uniswap V3 selective liquidity provision.
    /// @param _marketLiquidity Amount of liquidity in market in ETH terms.
    /// @param _ovlPrice Price of OVL against ETH.
    /// @return depth_ Market depth in OVL terms.
    function computeDepth (
        uint _marketLiquidity,
        uint _ovlPrice
    ) public virtual view returns (uint depth_);


    function pressure (
        bool _isLong,
        uint _oi,
        uint _cap
    ) public view returns (uint pressure_) {
        (   ,
            Roller memory _rollerNow,
            Roller memory _rollerImpact ) = scry(
                impactRollers,
                impactCycloid,
                impactWindow );

        pressure_ = (_isLong
            ? _rollerNow.ying - _rollerImpact.ying
            : _rollerNow.yang - _rollerImpact.yang
        );

        pressure_ += _oi.divDown(_cap);

    }

    function impact (
        bool _isLong,
        uint _oi,
        uint _cap
    ) public view returns (uint impact_) {

        uint _pressure = pressure(_isLong, _oi, _cap);

        uint _power = lmbda.mulDown(_pressure);

        uint _impact = _pressure != 0
            ? ONE.sub(INVERSE_E.powUp(_power))
            : 0;

        impact_ = _oi.mulUp(_impact);

    }


    /// @notice The function that saves onto the respective roller array
    /// @dev This is multi purpose in that it can write to either the
    /// brrrrd rollers or the impact rollers. It knows when to increment the
    /// cycloid to point to the next roller index. It konws when it needs needs
    /// to write to the next roller or if it can safely write to the current one.
    /// If the current cycloid is the length of the array, then it sets to zero.
    /// @param rollers The set of rollers array from storage. It can operate on
    /// either the brrrrd rollers or the impact rollers.
    /// @param _roller The current roller to be written.
    /// @param _lastMoment The moment of the last write to determine to write to
    /// a new roller or the current one.
    /// @param _cycloid The current position of the circular buffer which
    /// always points to the most recent time.
    /// @return cycloid_ The next value of the cycloid.
    function roll (
        Roller[60] storage rollers,
        Roller memory _roller,
        uint _lastMoment,
        uint _cycloid
    ) internal returns (
        uint cycloid_
    ) {

        if (_roller.time != _lastMoment) {

            _cycloid += 1;

            if (_cycloid < CHORD) {

                rollers[_cycloid] = _roller;

            } else {

                _cycloid = 0;

                rollers[_cycloid] = _roller;

            }

        } else {

            rollers[_cycloid] = _roller;

        }

        cycloid_ = _cycloid;

    }


    /// @notice First part of retrieving historic roller values
    /// @dev Checks to see if the current roller is satisfactory and if not
    /// searches deeper into the roller array.
    /// @param rollers The roller array, either impact or brrrrd
    /// @param _cycloid The current impact or brrrrd cycloid
    /// @param _ago The target time
    /// @return lastMoment_ The time the most recent roller was written
    /// @return rollerNow_ The current roller with the time set to now
    /// @return rollerThen_ The roller closest and earlier to the target time
    function scry (
        Roller[60] storage rollers,
        uint _cycloid,
        uint _ago
    ) internal view returns (
        uint lastMoment_,
        Roller memory rollerNow_,
        Roller memory rollerThen_
    ) {

        uint _time = block.timestamp;

        rollerNow_ = rollers[_cycloid];

        lastMoment_ = rollerNow_.time;

        uint _target = _time - _ago;

        if (rollerNow_.time <= _target) {

            rollerNow_.time = _time;
            rollerThen_.ying = rollerNow_.ying;
            rollerThen_.yang = rollerNow_.yang;

            return ( lastMoment_, rollerNow_, rollerThen_ );

        } else if (_time != rollerNow_.time) {

            rollerNow_.time = _time;

        }

        (   Roller memory _beforeOrAt,
            Roller memory _atOrAfter ) = scryRollers(rollers, _cycloid, _target);

        rollerThen_ = _beforeOrAt;

    }


    function scryRollers (
        Roller[60] storage rollers,
        uint _cycloid,
        uint _target
    ) internal view returns (
        Roller memory beforeOrAt_,
        Roller memory atOrAfter_
    ) {

        beforeOrAt_ = rollers[_cycloid];

        // if the target is at or after the newest roller, we can return early
        if (beforeOrAt_.time <= _target) {

            if (beforeOrAt_.time == _target) {

                // if newest roller equals target, we're in the same block, so we can ignore atOrAfter
                return ( beforeOrAt_, atOrAfter_ );

            } else {

                atOrAfter_.time = block.timestamp;
                atOrAfter_.ying = beforeOrAt_.ying;
                atOrAfter_.yang = beforeOrAt_.yang;

                return ( beforeOrAt_, atOrAfter_ );

            }
        }

        // now, set before to the oldest roller
        _cycloid = ( _cycloid + 1 ) % CHORD;

        beforeOrAt_ = rollers[_cycloid];

        if ( beforeOrAt_.time <= 1 ) {

            beforeOrAt_ = rollers[0];

        }

        if (_target <= beforeOrAt_.time) return ( beforeOrAt_, beforeOrAt_ );
        else return binarySearch(
            rollers,
            uint32(_target),
            uint16(_cycloid)
        );

    }

    function binarySearch(
        Roller[60] storage self,
        uint32 _target,
        uint16 _cycloid
    ) private view returns (
        Roller memory beforeOrAt_,
        Roller memory atOrAfter_
    ) {

        uint256 l = (_cycloid + 1) % CHORD; // oldest print
        uint256 r = l + CHORD - 1; // newest print
        uint256 i;
        while (true) {
            i = (l + r) / 2;

            beforeOrAt_ = self[ i % CHORD ];

            // we've landed on an uninitialized roller, keep searching
            if (beforeOrAt_.time <= 1) { l = i + 1; continue; }

            atOrAfter_ = self[ (i + 1) % CHORD ];

            bool _targetAtOrAfter = beforeOrAt_.time <= _target;

            if (_targetAtOrAfter && _target <= atOrAfter_.time) break;

            if (!_targetAtOrAfter) r = i - 1;
            else l = i + 1;
        }
    }

}",3827
RealWorld_BA_49_IUniV3Oracle_RealWord_20240820235031.log,49,IUniV3Oracle,4775,4413,9188,89.0,0.112135,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IUniswapV3Oracle {
    function token0() external view returns (address);
    function token1() external view returns (address);
    function pricePoints(uint256) external view returns (uint256, uint256, uint256);
    function pricePointsLength() external view returns (uint256);
}",81
RealWorld_BA_49_IUniswapV3PoolOwnerActions_RealWord_20240821000341.log,49,IUniswapV3PoolOwnerActions,7438,4660,12098,93.0,0.13039,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Permissioned pool actions
/// @notice Contains pool methods that may only be called by the factory owner
interface IUniswapV3PoolOwnerActions {
    /// @notice Set the denominator of the protocol's % share of the fees
    /// @param feeProtocol0 new protocol fee for token0 of the pool
    /// @param feeProtocol1 new protocol fee for token1 of the pool
    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;

    /// @notice Collect the protocol fee accrued to the pool
    /// @param recipient The address to which collected protocol fees should be sent
    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1
    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0
    /// @return amount0 The protocol fee collected in token0
    /// @return amount1 The protocol fee collected in token1
    function collectProtocol(
        address recipient,
        uint128 amount0Requested,
        uint128 amount1Requested
    ) external returns (uint128 amount0, uint128 amount1);
}",280
RealWorld_BA_49_IAccessControl_RealWord_20240820231437.log,49,IAccessControl,14874,4715,19589,113.0,0.16867,"// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.3.2 (access/IAccessControl.sol)

pragma solidity ^0.8.0;

/**
 * @dev External interface of AccessControl declared to support ERC165 detection.
 */
interface IAccessControl {
    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     *
     * _Available since v3.1._
     */
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {AccessControl-_setupRole}.
     */
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) external view returns (bool);

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {AccessControl-_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) external;
}",711
RealWorld_BA_49_UniTest_RealWord_20240820230424.log,49,UniTest,15006,5596,20602,132.0,0.18695,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""../market/OverlayV1Comptroller.sol"";
import ""../interfaces/IUniswapV3Pool.sol"";
import ""../libraries/UniswapV3OracleLibrary/TickMath.sol"";
import ""../libraries/UniswapV3OracleLibrary/FullMath.sol"";
import ""../libraries/UniswapV3OracleLibrary/UniswapV3OracleLibraryV2.sol"";

contract UniTest {

    address base0;
    address quote0;
    IUniswapV3Pool feed0;

    address base1;
    address quote1;
    IUniswapV3Pool feed1;

    constructor (
        address _base0,
        address _quote0,
        address _feed0,
        address _base1,
        address _quote1,
        address _feed1
    ) { 
        base0 = _base0;
        quote0 = _quote0;
        feed0 = IUniswapV3Pool(_feed0);
        base1 = _base1;
        quote1 = _quote1;
        feed1 = IUniswapV3Pool(_feed1);
    }

    function testUniLiq (
        uint32 _ago
    ) public view returns (
        uint x_,
        uint y_,
        uint z_
    ) {

        uint32[] memory _secondsAgo = new uint32[](2);
        _secondsAgo[0] = _ago;
        _secondsAgo[1] = 0;

        address f0t0 = feed0.token0();
        address f0t1 = feed0.token1();

        address f1t0 = feed1.token0();
        address f1t1 = feed1.token1();


        ( int56[] memory _ticks, uint160[] memory _invLiqs ) = feed0.observe(_secondsAgo);

        uint256 _sqrtPrice = TickMath.getSqrtRatioAtTick(
            int24((_ticks[1] - _ticks[0]) / int56(int32(_ago)))
        ); 

        // liquidity of USDC/ETH
        uint256 _liquidity = ( uint160(_ago) << 128 ) / ( _invLiqs[1] - _invLiqs[0] );

        uint _ethAmount = f0t0 == base0 
            ? ( uint256(_liquidity) << 96 ) / _sqrtPrice
            : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, 0x1000000000000000000000000);

        ( _ticks, ) = feed1.observe(_secondsAgo);

        uint _price = OracleLibraryV2.getQuoteAtTick(
            int24((_ticks[1] - _ticks[0]) / int56(int32(_ago))),
            1e18,
            base1,
            quote1
        );

        x_ = _price;
        y_ = ( _ethAmount * 1e18 ) / _price;
        z_ = _ethAmount;

    }

    function thing () public view returns (int) {

        int _staticCap = 10;
        int _brrrrd = 3;
        int _brrrr = 5;

        _brrrrd = _staticCap < ( _brrrrd += _brrrr ) 
            ? _brrrrd
            : _staticCap;

        return _brrrrd;

    }

}",737
RealWorld_BA_49_OverlayV1OVLCollateral_RealWord_20240820230638.log,49,OverlayV1OVLCollateral,49399,5081,54480,121.0,0.348615,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""../libraries/Position.sol"";
import ""../libraries/FixedPoint.sol"";
import ""@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol"";
import ""../interfaces/IOverlayV1Market.sol"";
import ""../interfaces/IOverlayV1Mothership.sol"";
import ""../interfaces/IOverlayToken.sol"";
import ""../interfaces/IOverlayTokenNew.sol"";

contract OverlayV1OVLCollateral is ERC1155Supply {

    event log(string k, uint v);
    event log_addr(string k, address v);

    using Position for Position.Info;
    using FixedPoint for uint256;

    bytes32 constant private GOVERNOR = keccak256(""GOVERNOR"");

    mapping (address => mapping(uint => uint)) internal currentBlockPositionsLong;
    mapping (address => mapping(uint => uint)) internal currentBlockPositionsShort;
    mapping (address => MarketInfo) public marketInfo;
    struct MarketInfo {
        uint marginMaintenance;
        uint marginRewardRate;
        uint maxLeverage;
    }

    Position.Info[] public positions;

    IOverlayV1Mothership public immutable mothership;
    IOverlayTokenNew immutable public ovl;

    uint256 public fees;
    uint256 public liquidations;

    event Build(
        address market,
        uint256 positionId,
        uint256 oi,
        uint256 debt
    );

    event Unwind(
        address market,
        uint256 positionId,
        uint256 oi,
        uint256 debt
    );

    event Liquidate(
        uint256 positionId,
        uint256 oi,
        uint256 reward,
        address rewarded
    );

    event Update(
        uint feesCollected,
        uint feesBurned,
        uint liquidationsCollected,
        uint liquidationsBurned
    );

    modifier onlyGovernor () {
        require(mothership.hasRole(GOVERNOR, msg.sender), ""OVLV1:!governor"");
        _;
    }

    constructor (
        string memory _uri,
        address _mothership
    ) ERC1155(_uri) {

        mothership = IOverlayV1Mothership(_mothership);

        ovl = IOverlayV1Mothership(_mothership).ovl();

        positions.push(Position.Info({
            market: address(0),
            isLong: false,
            leverage: 0,
            pricePoint: 0,
            oiShares: 0,
            debt: 0,
            cost: 0
        }));

    }

    function setMarketInfo (
        address _market,
        uint _marginMaintenance,
        uint _marginRewardRate,
        uint _maxLeverage
    ) external onlyGovernor {

        marketInfo[_market].marginMaintenance = _marginMaintenance;
        marketInfo[_market].marginRewardRate = _marginRewardRate;
        marketInfo[_market].maxLeverage = _maxLeverage;

    }

    function marginMaintenance(
        address _market
    ) external view returns (
        uint marginMaintenance_
    ) {

        marginMaintenance_ = marketInfo[_market].marginMaintenance;

    }

    function maxLeverage(
        address _market
    ) external view returns (
        uint maxLeverage_
    ) {

        maxLeverage_ = marketInfo[_market].maxLeverage;

    }

    function marginRewardRate(
        address _market
    ) external view returns (
        uint marginRewardRate_
    ) {

        marginRewardRate_ = marketInfo[_market].marginRewardRate;

    }


    /// @notice Disburses fees
    function disburse () public {

        (   uint256 _marginBurnRate,
            uint256 _feeBurnRate,
            address _feeTo ) = mothership.getUpdateParams();

        uint _feeForward = fees;
        uint _feeBurn = _feeForward.mulUp(_feeBurnRate);
        _feeForward = _feeForward - _feeBurn;

        uint _liqForward = liquidations;
        uint _liqBurn = _liqForward.mulUp(_marginBurnRate);
        _liqForward -= _liqBurn;

        fees = 0;
        liquidations = 0;

        emit Update(
            _feeForward,
            _feeBurn,
            _liqForward,
            _liqBurn
        );

        ovl.burn(address(this), _feeBurn + _liqBurn);
        ovl.transfer(_feeTo, _feeForward + _liqForward);

    }

    function getCurrentBlockPositionId (
        address _market,
        bool _isLong,
        uint _leverage,
        uint _pricePointNext
    ) internal returns (
        uint positionId_
    ) {

        mapping(uint=>uint) storage _currentBlockPositions = _isLong
            ? currentBlockPositionsLong[_market]
            : currentBlockPositionsShort[_market];

        positionId_ = _currentBlockPositions[_leverage];

        Position.Info storage position = positions[positionId_];

        if (position.pricePoint < _pricePointNext) {

            positions.push(Position.Info({
                market: _market,
                isLong: _isLong,
                leverage: _leverage,
                pricePoint: _pricePointNext,
                oiShares: 0,
                debt: 0,
                cost: 0
            }));

            positionId_ = positions.length - 1;

            _currentBlockPositions[_leverage] = positionId_;

        }

    }


    /// @notice Build a position on Overlay with OVL collateral
    /// @dev This interacts with an Overlay Market to register oi and hold 
    /// positions on behalf of users.
    /// @param _market The address of the desired market to interact with.
    /// @param _collateral The amount of OVL to use as collateral in the position.
    /// @param _leverage The amount of leverage to use in the position
    /// @param _isLong Whether to take out a position on the long or short side.
    /// @param _oiMinimum Minimum acceptable amount of OI after impact and fees.
    /// @return positionId_ Id of the built position for on chain convenience.
    function build (
        address _market,
        uint256 _collateral,
        uint256 _leverage,
        bool _isLong,
        uint256 _oiMinimum
    ) external returns (
        uint positionId_
    ) {

        require(mothership.marketActive(_market), ""OVLV1:!market"");
        require(_leverage <= marketInfo[_market].maxLeverage, ""OVLV1:lev>max"");

        (   uint _oiAdjusted,
            uint _collateralAdjusted,
            uint _debtAdjusted,
            uint _fee,
            uint _impact,
            uint _pricePointNext ) = IOverlayV1Market(_market)
                .enterOI(
                    _isLong,
                    _collateral,
                    _leverage
                );

        require(_oiAdjusted >= _oiMinimum, ""OVLV1:oi<min"");

        uint _positionId = getCurrentBlockPositionId(
            _market,
            _isLong,
            _leverage,
            _pricePointNext
        );

        Position.Info storage pos = positions[_positionId];

        pos.oiShares += _oiAdjusted;
        pos.cost += _collateralAdjusted;
        pos.debt += _debtAdjusted;

        fees += _fee;

        emit Build(_market, _positionId, _oiAdjusted, _debtAdjusted);

        ovl.transferFromBurn(msg.sender, address(this), _collateralAdjusted + _fee, _impact);

        // ovl.burn(msg.sender, _impact);

        _mint(msg.sender, _positionId, _oiAdjusted, """"); // WARNING: last b/c erc1155 callback

        positionId_ = _positionId;

    }

    /// @notice Unwinds shares of an existing position.
    /// @dev Interacts with a market contract to realize the PnL on a position.
    /// @param _positionId Id of the position to be unwound.
    /// @param _shares Number of shars to unwind from the position.
    function unwind (
        uint256 _positionId,
        uint256 _shares
    ) external {

        require( 0 < _shares && _shares <= balanceOf(msg.sender, _positionId), ""OVLV1:!shares"");

        Position.Info storage pos = positions[_positionId];

        require(0 < pos.oiShares, ""OVLV1:liquidated"");

        {

        (   uint _oi,
            uint _oiShares,
            uint _priceFrame ) = IOverlayV1Market(pos.market)
                .exitData(
                    pos.isLong,
                    pos.pricePoint
                );

        uint _totalPosShares = totalSupply(_positionId);

        uint _userOiShares = _shares;
        uint _userNotional = _shares * pos.notional(_oi, _oiShares, _priceFrame) / _totalPosShares;
        uint _userDebt = _shares * pos.debt / _totalPosShares;
        uint _userCost = _shares * pos.cost / _totalPosShares;
        uint _userOi = _shares * pos.oi(_oi, _oiShares) / _totalPosShares;

        emit Unwind(pos.market, _positionId, _userOi, _userDebt);

        // TODO: think through edge case of underwater position ... and fee adjustments ...
        uint _feeAmount = _userNotional.mulUp(mothership.fee());

        uint _userValueAdjusted = _userNotional - _feeAmount;
        if (_userValueAdjusted > _userDebt) _userValueAdjusted -= _userDebt;
        else _userValueAdjusted = 0;

        fees += _feeAmount; // adds to fee pot, which is transferred on update

        pos.debt -= _userDebt;
        pos.cost -= _userCost;
        pos.oiShares -= _userOiShares;

        // ovl.transfer(msg.sender, _userCost);

        // mint/burn excess PnL = valueAdjusted - cost
        if (_userCost < _userValueAdjusted) {

            ovl.transferMint(
                msg.sender, 
                _userCost, 
                _userValueAdjusted - _userCost
            );

        } else {

            ovl.transferBurn(
                msg.sender, 
                _userValueAdjusted, 
                _userCost - _userValueAdjusted
            );

        }


        IOverlayV1Market(pos.market).exitOI(
            pos.isLong,
            _userOi,
            _userOiShares,
            _userCost < _userValueAdjusted ? _userValueAdjusted - _userCost : 0,
            _userCost < _userValueAdjusted ? 0 : _userCost - _userValueAdjusted
        );

        }

        _burn(msg.sender, _positionId, _shares);

    }

    /// @notice Liquidates an existing position.
    /// @dev Interacts with an Overlay Market to exit all open interest
    /// associated with a liquidatable positoin.
    /// @param _positionId ID of the position being liquidated.
    /// @param _rewardsTo Address to send liquidation reward to.
    function liquidate (
        uint256 _positionId,
        address _rewardsTo
    ) external {

        Position.Info storage pos = positions[_positionId];

        require(0 < pos.oiShares, ""OVLV1:liquidated"");

        bool _isLong = pos.isLong;

        (   uint _oi,
            uint _oiShares,
            uint _priceFrame ) = IOverlayV1Market(pos.market)
                .exitData(
                    _isLong,
                    pos.pricePoint
                );

        MarketInfo memory _marketInfo = marketInfo[pos.market];

        require(pos.isLiquidatable(
            _oi,
            _oiShares,
            _priceFrame,
            _marketInfo.marginMaintenance
        ), ""OVLV1:!liquidatable"");

        uint _value = pos.value(_oi, _oiShares, _priceFrame);

        IOverlayV1Market(pos.market).exitOI(
            _isLong,
            pos.oi(_oi, _oiShares),
            pos.oiShares,
            0,
            pos.cost - _value
        );

        // TODO: which is better on gas
        pos.oiShares = 0;
        pos.debt = 0;
        // positions[positionId].oiShares = 0;

        uint _toReward = _value.mulUp(_marketInfo.marginRewardRate);

        liquidations += _value - _toReward;

        emit Liquidate(
            _positionId,
            _oi,
            _toReward,
            _rewardsTo
        );

        // ovl.burn(address(this), pos.cost - _value);
        ovl.transferBurn(_rewardsTo, _toReward, pos.cost - _value);

    }


    /// @notice Retrieves required information from market contract 
    /// to calculate position value with.
    /// @dev Gets price frame, total open interest and 
    /// total open interest shares from an Overlay market.
    /// @param _positionId ID of position to determine value of.
    /// @return value_ Value of the position
    function value (
        uint _positionId
    ) public view returns (
        uint256 value_
    ) {

        Position.Info storage pos = positions[_positionId];

        IOverlayV1Market _market = IOverlayV1Market(pos.market);

        (   uint _oi,
            uint _oiShares,
            uint _priceFrame ) = _market
            .positionInfo(
                pos.isLong,
                pos.pricePoint
            );

        value_ = pos.value(
            _oi,
            _oiShares,
            _priceFrame
        );

    }

}",2908
RealWorld_BA_49_IUniswapV3PoolImmutables_RealWord_20240821000657.log,49,IUniswapV3PoolImmutables,9983,3996,13979,97.0,0.129835,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Pool state that never changes
/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values
interface IUniswapV3PoolImmutables {
    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface
    /// @return The contract address
    function factory() external view returns (address);

    /// @notice The first of the two tokens of the pool, sorted by address
    /// @return The token contract address
    function token0() external view returns (address);

    /// @notice The second of the two tokens of the pool, sorted by address
    /// @return The token contract address
    function token1() external view returns (address);

    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6
    /// @return The fee
    function fee() external view returns (uint24);

    /// @notice The pool tick spacing
    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
    /// This value is an int24 to avoid casting even though it is always positive.
    /// @return The tick spacing
    function tickSpacing() external view returns (int24);

    /// @notice The maximum amount of position liquidity that can use any tick in the range
    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and
    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool
    /// @return The max amount of liquidity per tick
    function maxLiquidityPerTick() external view returns (uint128);
}",435
RealWorld_BA_49_Scratchpad_RealWord_20240820221728.log,49,Scratchpad,4920,4642,9562,112.0,0.11744,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;


contract Scratchpad {

    int56[][] public observations;

    constructor( int56[][] memory _observations ) {

        uint len = _observations.length;
        for (uint i = 0; i < len; i++) observations.push(_observations[i]);

        // immutables
    }

    function include_observations ( int56[][] calldata _observations ) external {

        uint len = _observations.length;
        for (uint i = 0; i < len; i++) observations.push(_observations[i]);

    }

}",123
RealWorld_BA_49_ERC20Mock_RealWord_20240820223252.log,49,ERC20Mock,4661,3867,8528,116.0,0.100645,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract ERC20Mock is ERC20 {

  constructor(
    string memory _name,
    string memory _symbol
  ) ERC20(_name, _symbol) {}

  function mint(address _recipient, uint256 _amount) external {
    _mint(_recipient, _amount);
  }

  function burn(address _account, uint256 _amount) external {
    _burn(_account, _amount);
  }

}",117
RealWorld_BA_49_IUniV3OracleMock_RealWord_20240820234110.log,49,IUniV3OracleMock,6397,5318,11715,125.0,0.138345,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IUniswapV3OracleMock {

    struct Shim {
        uint timestamp;
        uint128 liquidity;
        int24 tick;
        uint16 cardinality;
    }
    struct Observation {
        uint32 blockTimestamp;
        int56 tickCumulative;
        uint160 secondsPerLiquidityCumulativeX128;
        bool initialized;
    }

    function token0() external view returns (address);
    function token1() external view returns (address);
    function observationsLength() external view returns (uint);
    function loadObservations(Observation[] calldata, Shim[] calldata) external;
    function shims(uint) external view returns (Shim memory);
    function observations(uint) external view returns (Observation memory);
    function observe(uint32[] calldata) external view returns (int56[] memory, uint160[] memory);
    function cardinality() external view returns(uint16);

}",202
RealWorld_BA_49_UniswapV3Listener_RealWord_20240820222327.log,49,UniswapV3Listener,8366,5489,13855,121.0,0.15161,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""./libraries/UniswapV3OracleLibrary/UniswapV3OracleLibraryV2.sol"";
import ""./interfaces/IUniV3Oracle.sol"";
import ""./interfaces/IUniswapV3Pool.sol"";
import ""./market/OverlayV1Market.sol"";

contract UniswapV3Listener {

    address public immutable uniV3Pool;
    address public immutable token0;
    address public immutable token1;

    constructor(
        address _uniV3Pool
    ) {

        // immutables
        uniV3Pool = _uniV3Pool;
        token0 = IUniswapV3Pool(_uniV3Pool).token0();
        token1 = IUniswapV3Pool(_uniV3Pool).token1();

    }

    function see_tick () public view returns (int24) {

        return OracleLibraryV2.consult(uniV3Pool, 10 minutes, 0);

    }

    function listen (
        uint amountIn,
        address base
    ) public view returns (uint) {

        int24 tick = OracleLibraryV2.consult(uniV3Pool, 10 minutes, 0);

        uint gas = gasleft();
        uint quote = OracleLibraryV2.getQuoteAtTick(
            tick, 
            uint128(amountIn), 
            base == token0 ? token0 : token1,
            base != token0 ? token0 : token1
        );

        return quote;

    }

}",322
RealWorld_BA_49_MirinFactoryMock_RealWord_20240820223450.log,49,MirinFactoryMock,6863,4658,11521,106.0,0.127475,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""./MirinOracleMock.sol"";

contract MirinFactoryMock {

    mapping(address => bool) public isPool;
    address[] public allPools;

    function createPool(
        uint256[] memory timestamps,
        uint256[] memory price0Cumulatives,
        uint256[] memory price1Cumulatives
    ) external returns (MirinOracleMock pool) {
        pool = new MirinOracleMock(
            timestamps,
            price0Cumulatives,
            price1Cumulatives
        );
        isPool[address(pool)] = true;
        allPools.push(address(pool));
    }

    function addPricePoints(
        address pool,
        uint256[] memory timestamps,
        uint256[] memory price0Cumulatives,
        uint256[] memory price1Cumulatives
    ) external {
        require(isPool[pool], ""!pool"");
        MirinOracleMock(pool).addPricePoints(
            timestamps,
            price0Cumulatives,
            price1Cumulatives
        );
    }
}",228
RealWorld_BA_49_IUniswapV3PoolActions_RealWord_20240820235730.log,49,IUniswapV3PoolActions,26794,5859,32653,113.0,0.25115,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Permissionless pool actions
/// @notice Contains pool methods that can be called by anyone
interface IUniswapV3PoolActions {
    /// @notice Sets the initial price for the pool
    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value
    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96
    function initialize(uint160 sqrtPriceX96) external;

    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position
    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback
    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends
    /// on tickLower, tickUpper, the amount of liquidity, and the current price.
    /// @param recipient The address for which the liquidity will be created
    /// @param tickLower The lower tick of the position in which to add liquidity
    /// @param tickUpper The upper tick of the position in which to add liquidity
    /// @param amount The amount of liquidity to mint
    /// @param data Any data that should be passed through to the callback
    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback
    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback
    function mint(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount,
        bytes calldata data
    ) external returns (uint256 amount0, uint256 amount1);

    /// @notice Collects tokens owed to a position
    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.
    /// @param recipient The address which should receive the fees collected
    /// @param tickLower The lower tick of the position for which to collect fees
    /// @param tickUpper The upper tick of the position for which to collect fees
    /// @param amount0Requested How much token0 should be withdrawn from the fees owed
    /// @param amount1Requested How much token1 should be withdrawn from the fees owed
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collect(
        address recipient,
        int24 tickLower,
        int24 tickUpper,
        uint128 amount0Requested,
        uint128 amount1Requested
    ) external returns (uint128 amount0, uint128 amount1);

    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position
    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0
    /// @dev Fees must be collected separately via a call to #collect
    /// @param tickLower The lower tick of the position for which to burn liquidity
    /// @param tickUpper The upper tick of the position for which to burn liquidity
    /// @param amount How much liquidity to burn
    /// @return amount0 The amount of token0 sent to the recipient
    /// @return amount1 The amount of token1 sent to the recipient
    function burn(
        int24 tickLower,
        int24 tickUpper,
        uint128 amount
    ) external returns (uint256 amount0, uint256 amount1);

    /// @notice Swap token0 for token1, or token1 for token0
    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback
    /// @param recipient The address to receive the output of the swap
    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0
    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this
    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap
    /// @param data Any data to be passed through to the callback
    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive
    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive
    function swap(
        address recipient,
        bool zeroForOne,
        int256 amountSpecified,
        uint160 sqrtPriceLimitX96,
        bytes calldata data
    ) external returns (int256 amount0, int256 amount1);

    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback
    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback
    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling
    /// with 0 amount{0,1} and sending the donation amount(s) from the callback
    /// @param recipient The address which will receive the token0 and token1 amounts
    /// @param amount0 The amount of token0 to send
    /// @param amount1 The amount of token1 to send
    /// @param data Any data to be passed through to the callback
    function flash(
        address recipient,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external;

    /// @notice Increase the maximum number of price and liquidity observations that this pool will store
    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to
    /// the input observationCardinalityNext.
    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store
    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
}",1453
RealWorld_BA_49_ComptrollerShim_RealWord_20240820225954.log,49,ComptrollerShim,22461,5845,28306,151.0,0.229205,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""../market/OverlayV1PricePoint.sol"";
import ""../market/OverlayV1Comptroller.sol"";
import ""../interfaces/IOverlayToken.sol"";
import ""../interfaces/IUniswapV3Pool.sol"";
import ""../libraries/UniswapV3OracleLibrary/UniswapV3OracleLibraryV2.sol"";
import ""../libraries/FixedPoint.sol"";

contract ComptrollerShim is OverlayV1Comptroller {

    using FixedPoint for uint256;

    uint256 internal X96 = 0x1000000000000000000000000;

    IOverlayToken public ovl;

    address public ovlFeed;
    address public marketFeed;
    address public eth;

    bool public ethIs0;

    uint public macroWindow;
    uint public microWindow;

    constructor (
        uint _lmbda,
        uint _staticCap,
        uint _brrrrdExpected,
        uint _brrrrdWindowMacro,
        uint _brrrrdWindowMicro,
        uint _priceWindowMacro,
        uint _priceWindowMicro,
        address _marketFeed,
        address _ovlFeed,
        address _ovl,
        address _eth
    ) OverlayV1Comptroller (
        _priceWindowMicro
    ){

        lmbda = _lmbda;
        staticCap = _staticCap;
        brrrrdExpected = _brrrrdExpected;
        brrrrdWindowMacro = _brrrrdWindowMacro;
        brrrrdWindowMicro = _brrrrdWindowMicro;
        macroWindow = _priceWindowMacro;
        microWindow = _priceWindowMicro;
        marketFeed = _marketFeed;
        ovlFeed = _ovlFeed;
        ethIs0 = IUniswapV3Pool(_ovlFeed).token0() == _eth;

    }


    function depth () public view override returns (uint depth_) {

        depth_ = staticCap;

    }


    function computeDepth (
        uint _marketLiquidity,
        uint _ovlPrice
    ) public override view returns (
        uint depth_
    ) {

        depth_ = ((_marketLiquidity * 1e18) / _ovlPrice)
            .mulUp(lmbda)    
            .divDown(2e18);

    }

    function readFeed () public view returns (
        uint256 depth_
    ) { 

        int56[] memory _ticks;
        uint160[] memory _liqs;

        uint32[] memory _secondsAgo = new uint32[](2);

        _secondsAgo[1] = uint32(microWindow);

        ( _ticks, _liqs ) = IUniswapV3Pool(marketFeed).observe(_secondsAgo);

        uint256 _sqrtPrice = TickMath.getSqrtRatioAtTick(
            int24((_ticks[0] - _ticks[1]) / int56(int32(int(microWindow))))
        );

        uint256 _liquidity = (uint160(microWindow) << 128) / ( _liqs[0] - _liqs[1] );

        uint _ethAmount = ethIs0
            ? ( uint256(_liquidity) << 96 ) / _sqrtPrice
            : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96);

        _secondsAgo[1] = uint32(macroWindow);

        ( _ticks, ) = IUniswapV3Pool(ovlFeed).observe(_secondsAgo);

        uint _ovlPrice = OracleLibraryV2.getQuoteAtTick(
            int24((_ticks[0] - _ticks[1]) / int56(int32(int(macroWindow)))),
            1e18,
            address(ovl),
            eth
        );

        depth_ = lmbda.mulUp(( _ethAmount * 1e18 ) / _ovlPrice).divDown(2e18);

    }

    function setRoller (
        uint index,
        uint __timestamp,
        uint __longPressure,
        uint __shortPressure
    ) public {

        impactRollers[index].time = __timestamp;
        impactRollers[index].ying = __longPressure;
        impactRollers[index].yang = __shortPressure;

    }

    function viewScry(
        uint _ago
    ) public view returns (
        Roller memory rollerNow_,
        Roller memory rollerThen_
    ) {

        uint lastMoment;

        (   lastMoment,
            rollerNow_,
            rollerThen_ ) = scry(impactRollers, impactCycloid, _ago);


    }

    function brrrrBatch (
        uint[] memory _brrrr,
        uint[] memory _antiBrrrr
    ) public {

        uint len = _brrrr.length;

        for (uint i = 0; i < len; i++) {

            brrrr( _brrrr[i], _antiBrrrr[i] );

        }

    }

    function impactBatch (
        bool[] memory _isLong,
        uint[] memory _oi
    ) public returns (
        uint impact_
    ) {

        uint len = _isLong.length;

        for (uint i = 0; i < len; i++) {

            uint _cap = oiCap();

            impact_ = intake(_isLong[i], _oi[i], _cap);

        }

    }

    function viewImpact (
        bool _isLong,
        uint _oi
    ) public view returns (
        uint impact_
    ) {

        uint _cap = oiCap();

        ( ,,impact_ ) = _intake(_isLong, _oi, _cap);

    }

}",1210
RealWorld_BA_49_UniswapV3OracleMockStale_RealWord_20240820222530.log,49,UniswapV3OracleMockStale,7569,5191,12760,126.0,0.141665,"// SPDX-License-Identifier: Cheese
pragma solidity >=0.5.0;


contract UniswapV3OracleMockStale {

    address public immutable token0;
    address public immutable token1;

    uint public immutable deployed;
    uint public immutable window;

    int56[][] public observations;

    constructor(
        address _token0, 
        address _token1,
        uint _window
    ) {

        token0 = _token0;
        token1 = _token1;
        window = _window;
        deployed = block.timestamp;

    }

    function addObservations (
        int56[][] calldata _observations
    ) external {

        uint len = _observations.length;
        for (uint i = 0; i < len; i++) observations.push(_observations[i]);

    }

    function observe (
        uint32[] calldata __
    ) external view returns (
        int56[] memory, 
        uint160[] memory
    ) {

        uint index = ( block.timestamp - deployed ) / window;

        int56[] memory tickCumulatives_ = observations[index];
        uint160[] memory secondsPerLiquidityCumulativeX128s_;

        return ( tickCumulatives_, secondsPerLiquidityCumulativeX128s_ );

    }

}",264
RealWorld_BA_49_IUniswapV3PoolEvents_RealWord_20240820235925.log,49,IUniswapV3PoolEvents,25758,5947,31705,126.0,0.24773,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Events emitted by a pool
/// @notice Contains all events emitted by the pool
interface IUniswapV3PoolEvents {
    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool
    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize
    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96
    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool
    event Initialize(uint160 sqrtPriceX96, int24 tick);

    /// @notice Emitted when liquidity is minted for a given position
    /// @param sender The address that minted the liquidity
    /// @param owner The owner of the position and recipient of any minted liquidity
    /// @param tickLower The lower tick of the position
    /// @param tickUpper The upper tick of the position
    /// @param amount The amount of liquidity minted to the position range
    /// @param amount0 How much token0 was required for the minted liquidity
    /// @param amount1 How much token1 was required for the minted liquidity
    event Mint(
        address sender,
        address indexed owner,
        int24 indexed tickLower,
        int24 indexed tickUpper,
        uint128 amount,
        uint256 amount0,
        uint256 amount1
    );

    /// @notice Emitted when fees are collected by the owner of a position
    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees
    /// @param owner The owner of the position for which fees are collected
    /// @param tickLower The lower tick of the position
    /// @param tickUpper The upper tick of the position
    /// @param amount0 The amount of token0 fees collected
    /// @param amount1 The amount of token1 fees collected
    event Collect(
        address indexed owner,
        address recipient,
        int24 indexed tickLower,
        int24 indexed tickUpper,
        uint128 amount0,
        uint128 amount1
    );

    /// @notice Emitted when a position's liquidity is removed
    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect
    /// @param owner The owner of the position for which liquidity is removed
    /// @param tickLower The lower tick of the position
    /// @param tickUpper The upper tick of the position
    /// @param amount The amount of liquidity to remove
    /// @param amount0 The amount of token0 withdrawn
    /// @param amount1 The amount of token1 withdrawn
    event Burn(
        address indexed owner,
        int24 indexed tickLower,
        int24 indexed tickUpper,
        uint128 amount,
        uint256 amount0,
        uint256 amount1
    );

    /// @notice Emitted by the pool for any swaps between token0 and token1
    /// @param sender The address that initiated the swap call, and that received the callback
    /// @param recipient The address that received the output of the swap
    /// @param amount0 The delta of the token0 balance of the pool
    /// @param amount1 The delta of the token1 balance of the pool
    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96
    /// @param liquidity The liquidity of the pool after the swap
    /// @param tick The log base 1.0001 of price of the pool after the swap
    event Swap(
        address indexed sender,
        address indexed recipient,
        int256 amount0,
        int256 amount1,
        uint160 sqrtPriceX96,
        uint128 liquidity,
        int24 tick
    );

    /// @notice Emitted by the pool for any flashes of token0/token1
    /// @param sender The address that initiated the swap call, and that received the callback
    /// @param recipient The address that received the tokens from flash
    /// @param amount0 The amount of token0 that was flashed
    /// @param amount1 The amount of token1 that was flashed
    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee
    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee
    event Flash(
        address indexed sender,
        address indexed recipient,
        uint256 amount0,
        uint256 amount1,
        uint256 paid0,
        uint256 paid1
    );

    /// @notice Emitted by the pool for increases to the number of observations that can be stored
    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index
    /// just before a mint/swap/burn.
    /// @param observationCardinalityNextOld The previous value of the next observation cardinality
    /// @param observationCardinalityNextNew The updated value of the next observation cardinality
    event IncreaseObservationCardinalityNext(
        uint16 observationCardinalityNextOld,
        uint16 observationCardinalityNextNew
    );

    /// @notice Emitted when the protocol fee is changed by the pool
    /// @param feeProtocol0Old The previous value of the token0 protocol fee
    /// @param feeProtocol1Old The previous value of the token1 protocol fee
    /// @param feeProtocol0New The updated value of the token0 protocol fee
    /// @param feeProtocol1New The updated value of the token1 protocol fee
    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);

    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner
    /// @param sender The address that collects the protocol fees
    /// @param recipient The address that receives the collected protocol fees
    /// @param amount0 The amount of token0 protocol fees that is withdrawn
    /// @param amount0 The amount of token1 protocol fees that is withdrawn
    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);
}",1355
RealWorld_BA_49_IUniswapV3PoolDerivedState_RealWord_20240821000516.log,49,IUniswapV3PoolDerivedState,12793,4839,17632,99.0,0.160745,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Pool state that is not stored
/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the
/// blockchain. The functions here may have variable gas costs.
interface IUniswapV3PoolDerivedState {
    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp
    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
    /// you must call it with secondsAgos = [3600, 0].
    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned
    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp
    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block
    /// timestamp
    function observe(uint32[] calldata secondsAgos)
        external
        view
        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);

    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range
    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.
    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first
    /// snapshot is taken and the second snapshot is taken.
    /// @param tickLower The lower tick of the range
    /// @param tickUpper The upper tick of the range
    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range
    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range
    /// @return secondsInside The snapshot of seconds per liquidity for the range
    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)
        external
        view
        returns (
            int56 tickCumulativeInside,
            uint160 secondsPerLiquidityInsideX128,
            uint32 secondsInside
        );
}",584
RealWorld_BA_49_IOverlayTokenNew_RealWord_20240820234634.log,49,IOverlayTokenNew,9205,5129,14334,132.0,0.148605,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IOverlayTokenNew {

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function decimals() external view returns (uint);

    function symbol () external view returns (string memory);
    
    function name () external view returns (string memory);

    function totalSupply() external view returns (uint256);

    function balanceOf(
        address account
    ) external view returns (
        uint256
    );

    function allowance(
        address owner, 
        address spender
    ) external view returns (
        uint256
    );

    function approve(
        address spender, 
        uint256 amount
    ) external returns (
        bool
    );

    function transfer(
        address recipient, 
        uint256 amount
    ) external returns (
        bool
    );

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (
        bool
    );

    function burn(
        address account, 
        uint256 amount
    ) external;

    function mint(
        address account, 
        uint256 amount
    ) external;

    function transferBurn(
        address recipient,
        uint256 amount,
        uint256 burnt
    ) external returns (
        bool
    );

    function transferFromBurn(
        address sender,
        address recipient,
        uint256 amount,
        uint256 burnt
    ) external returns (
        bool
    );

    function transferMint(
        address recipient,
        uint256 amount,
        uint256 mint
    ) external returns (
        bool
    );

    function transferFromMint(
        address sender,
        address recipient,
        uint256 amount,
        uint256 mint
    ) external returns (
        bool
    );

}",384
RealWorld_BA_49_ERC165_RealWord_20240820232135.log,49,ERC165,7065,4786,11851,99.0,0.131045,"// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.3.2 (utils/introspection/ERC165.sol)

pragma solidity ^0.8.0;

import ""./IERC165.sol"";

/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 * for the additional interface id that will be supported. For example:
 *
 * ```solidity
 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 * }
 * ```
 *
 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 */
abstract contract ERC165 is IERC165 {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}",223
RealWorld_BA_49_OverlayToken_RealWord_20240820221923.log,49,OverlayToken,7399,4946,12345,112.0,0.135915,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/AccessControlEnumerable.sol"";

contract OverlayToken is AccessControlEnumerable, ERC20(""Overlay"", ""OVL"") {

  bytes32 public constant ADMIN_ROLE = 0x00;
  bytes32 public constant MINTER_ROLE = keccak256(""MINTER"");
  bytes32 public constant BURNER_ROLE = keccak256(""BURNER"");

  constructor() {

    _setupRole(ADMIN_ROLE, msg.sender);
    _setupRole(MINTER_ROLE, msg.sender);
    _setRoleAdmin(MINTER_ROLE, ADMIN_ROLE);
    _setRoleAdmin(BURNER_ROLE, ADMIN_ROLE);

  }

  modifier onlyMinter() {
    require(hasRole(MINTER_ROLE, msg.sender), ""only minter"");
    _;
  }

  modifier onlyBurner() {
    require(hasRole(BURNER_ROLE, msg.sender), ""only burner"");
    _;
  }

  function mint(address _recipient, uint256 _amount) external onlyMinter {
      _mint(_recipient, _amount);
  }

  function burn(address _account, uint256 _amount) external onlyBurner {
      _burn(_account, _amount);
  }
}",277
RealWorld_BA_49_IMirinOracle_RealWord_20240820235558.log,49,IMirinOracle,4366,3964,8330,90.0,0.10111,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IMirinOracle {
    function token0() external view returns (address);
    function token1() external view returns (address);
    function pricePoints(uint256) external view returns (uint256, uint256, uint256);
    function pricePointsLength() external view returns (uint256);
}",78
RealWorld_BA_49_Strings_RealWord_20240820231951.log,49,Strings,11479,4245,15724,102.0,0.142295,"// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.3.2 (utils/Strings.sol)

pragma solidity ^0.8.0;

/**
 * @dev String operations.
 */
library Strings {
    bytes16 private constant _HEX_SYMBOLS = ""0123456789abcdef"";

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return ""0"";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return ""0x00"";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = ""0"";
        buffer[1] = ""x"";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, ""Strings: hex length insufficient"");
        return string(buffer);
    }
}",520
RealWorld_BA_49_IUniswapV3PoolState_RealWord_20240821000133.log,49,IUniswapV3PoolState,26540,5656,32196,126.0,0.24582,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Pool state that can change
/// @notice These methods compose the pool's state, and can change with any frequency including multiple times
/// per transaction
interface IUniswapV3PoolState {
    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
    /// when accessed externally.
    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
    /// boundary.
    /// observationIndex The index of the last oracle observation that was written,
    /// observationCardinality The current maximum number of observations stored in the pool,
    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
    /// feeProtocol The protocol fee for both tokens of the pool.
    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
    /// unlocked Whether the pool is currently locked to reentrancy
    function slot0()
        external
        view
        returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        );

    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
    /// @dev This value can overflow the uint256
    function feeGrowthGlobal0X128() external view returns (uint256);

    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
    /// @dev This value can overflow the uint256
    function feeGrowthGlobal1X128() external view returns (uint256);

    /// @notice The amounts of token0 and token1 that are owed to the protocol
    /// @dev Protocol fees will never exceed uint128 max in either token
    function protocolFees() external view returns (uint128 token0, uint128 token1);

    /// @notice The currently in range liquidity available to the pool
    /// @dev This value has no relationship to the total liquidity across all ticks
    function liquidity() external view returns (uint128);

    /// @notice Look up information about a specific tick in the pool
    /// @param tick The tick to look up
    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or
    /// tick upper,
    /// liquidityNet how much liquidity changes when the pool price crosses the tick,
    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,
    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,
    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick
    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,
    /// secondsOutside the seconds spent on the other side of the tick from the current tick,
    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.
    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.
    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for
    /// a specific position.
    function ticks(int24 tick)
        external
        view
        returns (
            uint128 liquidityGross,
            int128 liquidityNet,
            uint256 feeGrowthOutside0X128,
            uint256 feeGrowthOutside1X128,
            int56 tickCumulativeOutside,
            uint160 secondsPerLiquidityOutsideX128,
            uint32 secondsOutside,
            bool initialized
        );

    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information
    function tickBitmap(int16 wordPosition) external view returns (uint256);

    /// @notice Returns the information about a position by the position's key
    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
    /// @return _liquidity The amount of liquidity in the position,
    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
    function positions(bytes32 key)
        external
        view
        returns (
            uint128 _liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );

    /// @notice Returns data about a specific observation index
    /// @param index The element of the observations array to fetch
    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time
    /// ago, rather than at a specific index in the array.
    /// @return blockTimestamp The timestamp of the observation,
    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,
    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,
    /// Returns initialized whether the observation has been initialized and the values are safe to use
    function observations(uint256 index)
        external
        view
        returns (
            uint32 blockTimestamp,
            int56 tickCumulative,
            uint160 secondsPerLiquidityCumulativeX128,
            bool initialized
        );
}",1444
RealWorld_BA_49_IUniV3Factory_RealWord_20240820233718.log,49,IUniV3Factory,4062,4330,8392,115.0,0.10691,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IUniV3Factory {
    function isPool(address) external view returns (bool);
    function addObservationPoints (int56[][] calldata observations) external;
}",52
RealWorld_BA_49_UniswapV3OracleMock_RealWord_20240820223000.log,49,UniswapV3OracleMock,61189,6028,67217,170.0,0.426505,"pragma solidity >=0.5.0;


contract UniswapV3OracleMock {

    using OracleMock for OracleMock.Observation[65535];
    struct Shim {
        uint timestamp;
        uint128 liquidity;
        int24 tick;
        uint16 cardinality;
    }

    uint16 public cardinality;

    address immutable public token0;
    address immutable public token1;

    Shim[65535] public shims;
    OracleMock.Observation[65535] public observations;

    constructor (address _token0, address _token1) { 

        token0 = _token0;
        token1 = _token1;

    }

    event log(string k, uint256 v);

    function observe(
        uint32[] calldata secondsAgos
    ) external view returns (
        int56[] memory tickCumulatives, 
        uint160[] memory secondsPerLiquidityCumulativeX128s
    ) {

        uint target = block.timestamp;

        ( Shim memory beforeOrAt, Shim memory atOrAfter ) = binarySearch(
            shims,
            target,
            cardinality
        );

        int24 _tick;
        uint128 _liquidity;
        uint16 _cardinality;

        if (atOrAfter.timestamp == target) {

            _tick = atOrAfter.tick;
            _liquidity = atOrAfter.liquidity;
            _cardinality = atOrAfter.cardinality;

        } else {

            _tick = beforeOrAt.tick;
            _liquidity = beforeOrAt.liquidity;
            _cardinality = beforeOrAt.cardinality;

        } 

        return
            observations.observe(
                uint32(target),
                secondsAgos,
                _tick,
                _cardinality - 1,
                _liquidity,
                _cardinality
            );

    }


    function loadObservations(
        OracleMock.Observation[] calldata _observations,
        Shim[] calldata _shims
    ) external {

        uint len = _observations.length;

        for (uint i = 0; i < len; i++) {

            uint _card = cardinality;

            observations[_card] = _observations[i];
            shims[_card] = _shims[i];

            cardinality += 1;

        }

    }

    function binarySearch(
        Shim[65535] storage self,
        uint target,
        uint16 _cardinality
    ) private view returns (Shim memory beforeOrAt, Shim memory atOrAfter) {
        uint256 l = 0;// oldest observation
        uint256 r = _cardinality - 1; // newest observation
        uint256 i;
        while (true) {
            i = (l + r) / 2;

            beforeOrAt = self[i % _cardinality];

            atOrAfter = self[(i + 1) % _cardinality];

            bool targetAtOrAfter = beforeOrAt.timestamp <= target;

            // check if we've found the answer!
            if (targetAtOrAfter && target <= atOrAfter.timestamp) break;

            if (!targetAtOrAfter) r = i - 1;
            else l = i + 1;
        }
    }

}

/// @title Oracle
/// @notice Provides price and liquidity data useful for a wide variety of system designs
/// @dev Instances of stored oracle data, ""observations"", are collected in the oracle array
/// Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the
/// maximum length of the oracle array. New slots will be added when the array is fully populated.
/// Observations are overwritten when the full length of the oracle array is populated.
/// The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()
library OracleMock {
    struct Observation {
        // the block timestamp of the observation
        uint32 blockTimestamp;
        // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized
        int56 tickCumulative;
        // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized
        uint160 secondsPerLiquidityCumulativeX128;
        // whether or not the observation is initialized
        bool initialized;
    }

    /// @notice Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values
    /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows
    /// @param last The specified observation to be transformed
    /// @param blockTimestamp The timestamp of the new observation
    /// @param tick The active tick at the time of the new observation
    /// @param liquidity The total in-range liquidity at the time of the new observation
    /// @return Observation The newly populated observation
    function transform(
        Observation memory last,
        uint32 blockTimestamp,
        int24 tick,
        uint128 liquidity
    ) private pure returns (Observation memory) {
        uint32 delta = blockTimestamp - last.blockTimestamp;
        return
            Observation({
                blockTimestamp: blockTimestamp,
                tickCumulative: last.tickCumulative + int56(tick) * int56(uint56(delta)),
                secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +
                    ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),
                initialized: true
            });
    }

    /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array
    /// @param self The stored oracle array
    /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32
    /// @return cardinality The number of populated elements in the oracle array
    /// @return cardinalityNext The new length of the oracle array, independent of population
    function initialize(Observation[65535] storage self, uint32 time)
        internal
        returns (uint16 cardinality, uint16 cardinalityNext)
    {
        self[0] = Observation({
            blockTimestamp: time,
            tickCumulative: 0,
            secondsPerLiquidityCumulativeX128: 0,
            initialized: true
        });
        return (1, 1);
    }

    /// @notice comparator for 32-t timestamps
    /// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time
    /// @param time A timestamp truncated to 32 bits
    /// @param a A comparison timestamp from which to determine the relative position of `time`
    /// @param b From which to determine the relative position of `time`
    /// @return bool Whether `a` is chronologically <= `b`
    function lte(
        uint32 time,
        uint32 a,
        uint32 b
    ) private pure returns (bool) {
        // if there hasn't been overflow, no need to adjust
        if (a <= time && b <= time) return a <= b;

        uint256 aAdjusted = a > time ? a : a + 2**32;
        uint256 bAdjusted = b > time ? b : b + 2**32;

        return aAdjusted <= bAdjusted;
    }

    /// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.
    /// The result may be the same observation, or adjacent observations.
    /// @dev The answer must be contained in the array, used when the target is located within the stored observation
    /// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation
    /// @param self The stored oracle array
    /// @param time The current block.timestamp
    /// @param target The timestamp at which the reserved observation should be for
    /// @param index The index of the observation that was most recently written to the observations array
    /// @param cardinality The number of populated elements in the oracle array
    /// @return beforeOrAt The observation recorded before, or at, the target
    /// @return atOrAfter The observation recorded at, or after, the target
    function binarySearch(
        Observation[65535] storage self,
        uint32 time,
        uint32 target,
        uint16 index,
        uint16 cardinality
    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {
        uint256 l = (index + 1) % cardinality; // oldest observation
        uint256 r = l + cardinality - 1; // newest observation
        uint256 i;
        while (true) {
            i = (l + r) / 2;

            beforeOrAt = self[i % cardinality];

            // we've landed on an uninitialized tick, keep searching higher (more recently)
            if (!beforeOrAt.initialized) {
                l = i + 1;
                continue;
            }

            atOrAfter = self[(i + 1) % cardinality];

            bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);

            // check if we've found the answer!
            if (targetAtOrAfter && lte(time, target, atOrAfter.blockTimestamp)) break;

            if (!targetAtOrAfter) r = i - 1;
            else l = i + 1;
        }
    }

    /// @notice Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied
    /// @dev Assumes there is at least 1 initialized observation.
    /// Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.
    /// @param self The stored oracle array
    /// @param time The current block.timestamp
    /// @param target The timestamp at which the reserved observation should be for
    /// @param tick The active tick at the time of the returned or simulated observation
    /// @param index The index of the observation that was most recently written to the observations array
    /// @param liquidity The total pool liquidity at the time of the call
    /// @param cardinality The number of populated elements in the oracle array
    /// @return beforeOrAt The observation which occurred at, or before, the given timestamp
    /// @return atOrAfter The observation which occurred at, or after, the given timestamp
    function getSurroundingObservations(
        Observation[65535] storage self,
        uint32 time,
        uint32 target,
        int24 tick,
        uint16 index,
        uint128 liquidity,
        uint16 cardinality
    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {
        // optimistically set before to the newest observation
        beforeOrAt = self[index];

        // if the target is chronologically at or after the newest observation, we can early return
        if (lte(time, beforeOrAt.blockTimestamp, target)) {
            if (beforeOrAt.blockTimestamp == target) {
                // if newest observation equals target, we're in the same block, so we can ignore atOrAfter
                return (beforeOrAt, atOrAfter);
            } else {
                // otherwise, we need to transform
                return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));
            }
        }

        // now, set before to the oldest observation
        beforeOrAt = self[(index + 1) % cardinality];
        if (!beforeOrAt.initialized) beforeOrAt = self[0];

        // ensure that the target is chronologically at or after the oldest observation
        require(lte(time, beforeOrAt.blockTimestamp, target), 'OLD');

        // if we've reached this point, we have to binary search
        return binarySearch(self, time, target, index, cardinality);
    }

    /// @dev Reverts if an observation at or before the desired observation timestamp does not exist.
    /// 0 may be passed as `secondsAgo' to return the current cumulative values.
    /// If called with a timestamp falling between two observations, returns the counterfactual accumulator values
    /// at exactly the timestamp between the two observations.
    /// @param self The stored oracle array
    /// @param time The current block timestamp
    /// @param secondsAgo The amount of time to look back, in seconds, at which point to return an observation
    /// @param tick The current tick
    /// @param index The index of the observation that was most recently written to the observations array
    /// @param liquidity The current in-range pool liquidity
    /// @param cardinality The number of populated elements in the oracle array
    /// @return tickCumulative The tick * time elapsed since the pool was first initialized, as of `secondsAgo`
    /// @return secondsPerLiquidityCumulativeX128 The time elapsed / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`
    function observeSingle(
        Observation[65535] storage self,
        uint32 time,
        uint32 secondsAgo,
        int24 tick,
        uint16 index,
        uint128 liquidity,
        uint16 cardinality
    )   internal view returns (
        int56 tickCumulative, 
        uint160 secondsPerLiquidityCumulativeX128
    ) {
        if (secondsAgo == 0) {
            Observation memory last = self[index];
            if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);
            return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);
        }

        uint32 target = time - secondsAgo;

        (Observation memory beforeOrAt, Observation memory atOrAfter) =
            getSurroundingObservations(self, time, target, tick, index, liquidity, cardinality);
        

        if (target == beforeOrAt.blockTimestamp) {
            // we're at the left boundary
            return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);
        } else if (target == atOrAfter.blockTimestamp) {
            // we're at the right boundary
            return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);
        } else {
            // we're in the middle
            uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;
            uint32 targetDelta = target - beforeOrAt.blockTimestamp;
            return (
                beforeOrAt.tickCumulative +
                    ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / int56(uint56(observationTimeDelta))) *
                    int56(uint56(targetDelta)),
                beforeOrAt.secondsPerLiquidityCumulativeX128 +
                    uint160(
                        (uint256(
                            atOrAfter.secondsPerLiquidityCumulativeX128 - beforeOrAt.secondsPerLiquidityCumulativeX128
                        ) * targetDelta) / observationTimeDelta
                    )
            );
        }
    }

    event log(string l, uint v);

    /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`
    /// @dev Reverts if `secondsAgos` > oldest observation
    /// @param self The stored oracle array
    /// @param time The current block.timestamp
    /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation
    /// @param tick The current tick
    /// @param index The index of the observation that was most recently written to the observations array
    /// @param liquidity The current in-range pool liquidity
    /// @param cardinality The number of populated elements in the oracle array
    /// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`
    /// @return secondsPerLiquidityCumulativeX128s The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`
    function observe(
        Observation[65535] storage self,
        uint32 time,
        uint32[] memory secondsAgos,
        int24 tick,
        uint16 index,
        uint128 liquidity,
        uint16 cardinality
    )   internal view returns (
        int56[] memory tickCumulatives, 
        uint160[] memory secondsPerLiquidityCumulativeX128s
    ) {
        require(cardinality > 0, 'I');

        tickCumulatives = new int56[](secondsAgos.length);
        secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);
        for (uint256 i = 0; i < secondsAgos.length; i++) {
            (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(
                self,
                time,
                secondsAgos[i],
                tick,
                index,
                liquidity,
                cardinality
            );
        }
    }
}",3650
RealWorld_BA_49_OverlayV1Mothership_RealWord_20240821000836.log,49,OverlayV1Mothership,22926,5615,28541,141.0,0.22693,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@openzeppelin/contracts/access/AccessControlEnumerable.sol"";
import ""../interfaces/IOverlayV1Market.sol"";
import ""../OverlayToken.sol"";

contract OverlayV1Mothership is AccessControlEnumerable {

    uint16 public constant MIN_FEE = 1; // 0.01%
    uint16 public constant MAX_FEE = 100; // 1.00%

    uint16 public constant MIN_MARGIN_MAINTENANCE = 100; // 1% maintenance
    uint16 public constant MAX_MARGIN_MAINTENANCE = 6000; // 60% maintenance

    bytes32 public constant ADMIN = 0x00;
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant GUARDIAN = keccak256(""GUARDIAN"");
    bytes32 public constant MINTER = keccak256(""MINTER"");
    bytes32 public constant BURNER = keccak256(""BURNER"");

    // ovl erc20 token
    address public ovl;

    // portion of liquidations to burn on update
    uint public marginBurnRate;

    // global params adjustable by gov
    // build/unwind trading fee
    uint public fee;
    // portion of build/unwind fee burnt
    uint public feeBurnRate;
    // address to send fees to
    address public feeTo;

    mapping(address => bool) public marketActive;
    mapping(address => bool) public marketExists;
    address[] public allMarkets;

    mapping(address => bool) public collateralExists;
    mapping(address => bool) public collateralActive;
    address[] public allCollateral;

    modifier onlyGovernor () {
        require(hasRole(GOVERNOR, msg.sender), ""OVLV1:!gov"");
        _;
    }

    modifier onlyGuardian () {
        require(hasRole(GUARDIAN, msg.sender), ""OVLV1:!guard"");
        _;
    }

    constructor(
        address _feeTo,
        uint _fee,
        uint _feeBurnRate,
        uint _marginBurnRate
    ) {

        _setupRole(ADMIN, msg.sender);
        _setupRole(GOVERNOR, msg.sender);
        _setupRole(GUARDIAN, msg.sender);
        _setRoleAdmin(GOVERNOR, ADMIN);
        _setRoleAdmin(GUARDIAN, ADMIN);

        // global params
        fee = _fee;
        feeBurnRate = _feeBurnRate;
        feeTo = _feeTo;
        marginBurnRate = _marginBurnRate;

    }

    function setOVL (address _ovl) external onlyGovernor {

        ovl = _ovl;

    }

    function totalMarkets () external view returns (uint) {
        return allMarkets.length;
    }

    /// @notice Initializes an existing market contract after deployment
    /// @dev Should be called after contract deployment in specific market factory.createMarket
    function initializeMarket(address market) external onlyGovernor {

        require(!marketExists[market], ""OVLV1:!!initialized"");

        marketExists[market] = true;
        marketActive[market] = true;

        allMarkets.push(market);

    }

    /// @notice Disables an existing market contract for a mirin market
    function disableMarket(address market) external onlyGovernor {

        require(marketActive[market], ""OVLV1: !enabled"");

        marketActive[market] = false;

    }

    /// @notice Enables an existing market contract for a mirin market
    function enableMarket(address market) external onlyGovernor {

        require(marketExists[market], ""OVLV1: !exists"");

        require(!marketActive[market], ""OVLV1: !disabled"");

        marketActive[market] = true;

    }

    function initializeCollateral (address _collateral) external onlyGovernor {

        require(!collateralExists[_collateral], ""OVLV1:!!iintialized"");

        collateralExists[_collateral] = true;
        collateralActive[_collateral] = true;

        allCollateral.push(_collateral);

        OverlayToken(ovl).grantRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);

        OverlayToken(ovl).grantRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);

    }

    function enableCollateral (address _collateral) external onlyGovernor {

        require(collateralExists[_collateral], ""OVLV1:!exists"");

        require(!collateralActive[_collateral], ""OVLV1:!disabled"");

        OverlayToken(ovl).grantRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);

        OverlayToken(ovl).grantRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);

    }

    function disableCollateral (address _collateral) external onlyGovernor {

        require(collateralActive[_collateral], ""OVLV1:!enabled"");

        OverlayToken(ovl).revokeRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);

        OverlayToken(ovl).revokeRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);

    }

    /// @notice Allows gov to adjust per market params

    /// @notice Allows gov to adjust global params
    function adjustGlobalParams(
        uint16 _fee,
        uint16 _feeBurnRate,
        address _feeTo
    ) external onlyGovernor {
        fee = _fee;
        feeBurnRate = _feeBurnRate;
        feeTo = _feeTo;
    }

    function getUpdateParams() external view returns (
        uint,
        uint,
        address
    ) {
        return (
            marginBurnRate,
            feeBurnRate,
            feeTo
        );
    }

}",1243
RealWorld_BA_49_LogExpMath_RealWord_20240820224248.log,49,LogExpMath,97711,5416,103127,167.0,0.596875,"// SPDX-License-Identifier: MIT
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
// documentation files (the Software), to deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
// Software.

// THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

pragma solidity ^0.8.7;

import ""../utils/Errors.sol"";

/* solhint-disable */

/**
 * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).
 *
 * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural
 * exponentiation and logarithm (where the base is Euler's number).
 *
 * @author Fernando Martinelli - @fernandomartinelli
 * @author Sergio Yuhjtman - @sergioyuhjtman
 * @author Daniel Fernandez - @dmf7z
 */
library LogExpMath {
    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying
    // two numbers, and multiply by ONE when dividing them.

    // All arguments and return values are 18 decimal fixed point numbers.
    int256 constant ONE_18 = 1e18;

    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the
    // case of ln36, 36 decimals.
    int256 constant ONE_20 = 1e20;
    int256 constant ONE_36 = 1e36;

    // The domain of natural exponentiation is bound by the word size and number of decimals used.
    //
    // Because internally the result will be stored using 20 decimals, the largest possible result is
    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.
    // The smallest possible result is 10^(-18), which makes largest negative argument
    // ln(10^(-18)) = -41.446531673892822312.
    // We use 130.0 and -41.0 to have some safety margin.
    int256 constant MAX_NATURAL_EXPONENT = 130e18;
    int256 constant MIN_NATURAL_EXPONENT = -41e18;

    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point
    // 256 bit integer.
    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;
    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;

    uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(ONE_20);

    // 18 decimal constants
    int256 constant x0 = 128000000000000000000; // 27
    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // e(x0) (no decimals)
    int256 constant x1 = 64000000000000000000; // 26
    int256 constant a1 = 6235149080811616882910000000; // e(x1) (no decimals)

    // 20 decimal constants
    int256 constant x2 = 3200000000000000000000; // 25
    int256 constant a2 = 7896296018268069516100000000000000; // e(x2)
    int256 constant x3 = 1600000000000000000000; // 24
    int256 constant a3 = 888611052050787263676000000; // e(x3)
    int256 constant x4 = 800000000000000000000; // 23
    int256 constant a4 = 298095798704172827474000; // e(x4)
    int256 constant x5 = 400000000000000000000; // 22
    int256 constant a5 = 5459815003314423907810; // e(x5)
    int256 constant x6 = 200000000000000000000; // 21
    int256 constant a6 = 738905609893065022723; // e(x6)
    int256 constant x7 = 100000000000000000000; // 20
    int256 constant a7 = 271828182845904523536; // e(x7)
    int256 constant x8 = 50000000000000000000; // 2-1
    int256 constant a8 = 164872127070012814685; // e(x8)
    int256 constant x9 = 25000000000000000000; // 2-2
    int256 constant a9 = 128402541668774148407; // e(x9)
    int256 constant x10 = 12500000000000000000; // 2-3
    int256 constant a10 = 113314845306682631683; // e(x10)
    int256 constant x11 = 6250000000000000000; // 2-4
    int256 constant a11 = 106449445891785942956; // e(x11)

    /**
     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.
     *
     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.
     */
    function pow(uint256 x, uint256 y) internal pure returns (uint256) {
        unchecked {


        // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to
        // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means
        // x^y = exp(y * ln(x)).

        // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.
        _require(x < 2**255, Errors.X_OUT_OF_BOUNDS);
        int256 x_int256 = int256(x);

        // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In
        // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.

        // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.
        _require(y < MILD_EXPONENT_BOUND, Errors.Y_OUT_OF_BOUNDS);
        int256 y_int256 = int256(y);

        int256 logx_times_y;
        if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {
            int256 ln_36_x = _ln_36(x_int256);

            // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just
            // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal
            // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the
            // (downscaled) last 18 decimals.
            logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);
        } else {
            logx_times_y = _ln(x_int256) * y_int256;
        }
        logx_times_y /= ONE_18;

        // Finally, we compute exp(y * ln(x)) to arrive at x^y
        _require(
            MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,
            Errors.PRODUCT_OUT_OF_BOUNDS
        );

        return uint256(exp(logx_times_y));

        }
    }

    /**
     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.
     *
     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.
     */
    function exp(int256 x) internal pure returns (int256) {
        _require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, Errors.INVALID_EXPONENT);

        unchecked {

        if (x < 0) {
            // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it
            // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).
            // Fixed point division requires multiplying by ONE_18.
            return ((ONE_18 * ONE_18) / exp(-x));
        }

        // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,
        // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7
        // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the
        // decomposition.
        // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this
        // decomposition, which will be lower than the smallest x_n.
        // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.
        // We mutate x by subtracting x_n, making it the remainder of the decomposition.

        // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause
        // intermediate overflows. Instead we store them as plain integers, with 0 decimals.
        // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the
        // decomposition.

        // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct
        // it and compute the accumulated product.

        int256 firstAN;
        if (x >= x0) {
            x -= x0;
            firstAN = a0;
        } else if (x >= x1) {
            x -= x1;
            firstAN = a1;
        } else {
            firstAN = 1; // One with no decimal places
        }

        // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the
        // smaller terms.
        x *= 100;

        // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point
        // one. Recall that fixed point multiplication requires dividing by ONE_20.
        int256 product = ONE_20;

        if (x >= x2) {
            x -= x2;
            product = (product * a2) / ONE_20;
        }
        if (x >= x3) {
            x -= x3;
            product = (product * a3) / ONE_20;
        }
        if (x >= x4) {
            x -= x4;
            product = (product * a4) / ONE_20;
        }
        if (x >= x5) {
            x -= x5;
            product = (product * a5) / ONE_20;
        }
        if (x >= x6) {
            x -= x6;
            product = (product * a6) / ONE_20;
        }
        if (x >= x7) {
            x -= x7;
            product = (product * a7) / ONE_20;
        }
        if (x >= x8) {
            x -= x8;
            product = (product * a8) / ONE_20;
        }
        if (x >= x9) {
            x -= x9;
            product = (product * a9) / ONE_20;
        }

        // x10 and x11 are unnecessary here since we have high enough precision already.

        // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series
        // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).

        int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.
        int256 term; // Each term in the sum, where the nth term is (x^n / n!).

        // The first term is simply x.
        term = x;
        seriesSum += term;

        // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,
        // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.

        term = ((term * x) / ONE_20) / 2;
        seriesSum += term;

        term = ((term * x) / ONE_20) / 3;
        seriesSum += term;

        term = ((term * x) / ONE_20) / 4;
        seriesSum += term;

        term = ((term * x) / ONE_20) / 5;
        seriesSum += term;

        term = ((term * x) / ONE_20) / 6;
        seriesSum += term;

        term = ((term * x) / ONE_20) / 7;
        seriesSum += term;

        term = ((term * x) / ONE_20) / 8;
        seriesSum += term;

        term = ((term * x) / ONE_20) / 9;
        seriesSum += term;

        term = ((term * x) / ONE_20) / 10;
        seriesSum += term;

        term = ((term * x) / ONE_20) / 11;
        seriesSum += term;

        term = ((term * x) / ONE_20) / 12;
        seriesSum += term;

        // 12 Taylor terms are sufficient for 18 decimal precision.

        // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor
        // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply
        // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),
        // and then drop two digits to return an 18 decimal value.

        return (((product * seriesSum) / ONE_20) * firstAN) / 100;

        }

    }

    /**
     * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.
     */
    function log(int256 arg, int256 base) internal pure returns (int256) {
        // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).

        // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by
        // upscaling.

        unchecked {

        int256 logBase;
        if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {
            logBase = _ln_36(base);
        } else {
            logBase = _ln(base) * ONE_18;
        }

        int256 logArg;
        if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {
            logArg = _ln_36(arg);
        } else {
            logArg = _ln(arg) * ONE_18;
        }

        // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places
        return (logArg * ONE_18) / logBase;

        }

    }

    /**
     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.
     */
    function ln(int256 a) internal pure returns (int256) {
        // The real natural logarithm is not defined for negative numbers or zero.
        _require(a > 0, Errors.OUT_OF_BOUNDS);
        if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {
            return _ln_36(a) / ONE_18;
        } else {
            return _ln(a);
        }
    }

    /**
     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.
     */
    function _ln(int256 a) private pure returns (int256) {

        unchecked {

        if (a < ONE_18) {
            // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less
            // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.
            // Fixed point division requires multiplying by ONE_18.
            return (-_ln((ONE_18 * ONE_18) / a));
        }

        // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which
        // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,
        // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot
        // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.
        // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this
        // decomposition, which will be lower than the smallest a_n.
        // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.
        // We mutate a by subtracting a_n, making it the remainder of the decomposition.

        // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point
        // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by
        // ONE_18 to convert them to fixed point.
        // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide
        // by it and compute the accumulated sum.

        int256 sum = 0;
        if (a >= a0 * ONE_18) {
            a /= a0; // Integer, not fixed point division
            sum += x0;
        }

        if (a >= a1 * ONE_18) {
            a /= a1; // Integer, not fixed point division
            sum += x1;
        }

        // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.
        sum *= 100;
        a *= 100;

        // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.

        if (a >= a2) {
            a = (a * ONE_20) / a2;
            sum += x2;
        }

        if (a >= a3) {
            a = (a * ONE_20) / a3;
            sum += x3;
        }

        if (a >= a4) {
            a = (a * ONE_20) / a4;
            sum += x4;
        }

        if (a >= a5) {
            a = (a * ONE_20) / a5;
            sum += x5;
        }

        if (a >= a6) {
            a = (a * ONE_20) / a6;
            sum += x6;
        }

        if (a >= a7) {
            a = (a * ONE_20) / a7;
            sum += x7;
        }

        if (a >= a8) {
            a = (a * ONE_20) / a8;
            sum += x8;
        }

        if (a >= a9) {
            a = (a * ONE_20) / a9;
            sum += x9;
        }

        if (a >= a10) {
            a = (a * ONE_20) / a10;
            sum += x10;
        }

        if (a >= a11) {
            a = (a * ONE_20) / a11;
            sum += x11;
        }

        // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series
        // that converges rapidly for values of `a` close to one - the same one used in ln_36.
        // Let z = (a - 1) / (a + 1).
        // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))

        // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires
        // division by ONE_20.
        int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);
        int256 z_squared = (z * z) / ONE_20;

        // num is the numerator of the series: the z^(2 * n + 1) term
        int256 num = z;

        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z
        int256 seriesSum = num;

        // In each step, the numerator is multiplied by z^2
        num = (num * z_squared) / ONE_20;
        seriesSum += num / 3;

        num = (num * z_squared) / ONE_20;
        seriesSum += num / 5;

        num = (num * z_squared) / ONE_20;
        seriesSum += num / 7;

        num = (num * z_squared) / ONE_20;
        seriesSum += num / 9;

        num = (num * z_squared) / ONE_20;
        seriesSum += num / 11;

        // 6 Taylor terms are sufficient for 36 decimal precision.

        // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)
        seriesSum *= 2;

        // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both
        // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal
        // value.

        return (sum + seriesSum) / 100;

        }

    }

    /**
     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,
     * for x close to one.
     *
     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.
     */
    function _ln_36(int256 x) private pure returns (int256) {

        unchecked {

        // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits
        // worthwhile.

        // First, we transform x to a 36 digit fixed point value.
        x *= ONE_18;

        // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).
        // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))

        // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires
        // division by ONE_36.
        int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);
        int256 z_squared = (z * z) / ONE_36;

        // num is the numerator of the series: the z^(2 * n + 1) term
        int256 num = z;

        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z
        int256 seriesSum = num;

        // In each step, the numerator is multiplied by z^2
        num = (num * z_squared) / ONE_36;
        seriesSum += num / 3;

        num = (num * z_squared) / ONE_36;
        seriesSum += num / 5;

        num = (num * z_squared) / ONE_36;
        seriesSum += num / 7;

        num = (num * z_squared) / ONE_36;
        seriesSum += num / 9;

        num = (num * z_squared) / ONE_36;
        seriesSum += num / 11;

        num = (num * z_squared) / ONE_36;
        seriesSum += num / 13;

        num = (num * z_squared) / ONE_36;
        seriesSum += num / 15;

        // 8 Taylor terms are sufficient for 36 decimal precision.

        // All that remains is multiplying by 2 (non fixed point).
        return seriesSum * 2;

        }

    }
}",5936
RealWorld_BA_49_AccessControlEnumerable_RealWord_20240820231243.log,49,AccessControlEnumerable,14462,5346,19808,112.0,0.17923,"// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.3.2 (access/AccessControlEnumerable.sol)

pragma solidity ^0.8.0;

import ""./EnumerableSet.sol"";
import ""./AccessControl.sol"";
import ""./IAccessControlEnumerable.sol"";

/**
 * @dev Extension of {AccessControl} that allows enumerating the members of each role.
 */
abstract contract AccessControlEnumerable is AccessControl, IAccessControlEnumerable {
    using EnumerableSet for EnumerableSet.AddressSet;

    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);
    }

    /**
     * @dev Returns one of the accounts that have `role`. `index` must be a
     * value between 0 and {getRoleMemberCount}, non-inclusive.
     *
     * Role bearers are not sorted in any particular way, and their ordering may
     * change at any point.
     *
     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure
     * you perform all queries on the same block. See the following
     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]
     * for more information.
     */
    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {
        return _roleMembers[role].at(index);
    }

    /**
     * @dev Returns the number of accounts that have `role`. Can be used
     * together with {getRoleMember} to enumerate all bearers of a role.
     */
    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {
        return _roleMembers[role].length();
    }

    /**
     * @dev Overload {grantRole} to track enumerable memberships
     */
    function grantRole(bytes32 role, address account) public override(AccessControl, IAccessControl) {
        super.grantRole(role, account);
        _roleMembers[role].add(account);
    }

    /**
     * @dev Overload {revokeRole} to track enumerable memberships
     */
    function revokeRole(bytes32 role, address account) public override(AccessControl, IAccessControl) {
        super.revokeRole(role, account);
        _roleMembers[role].remove(account);
    }

    /**
     * @dev Overload {renounceRole} to track enumerable memberships
     */
    function renounceRole(bytes32 role, address account) public override(AccessControl, IAccessControl) {
        super.renounceRole(role, account);
        _roleMembers[role].remove(account);
    }

    /**
     * @dev Overload {_setupRole} to track enumerable memberships
     */
    function _setupRole(bytes32 role, address account) internal override {
        super._setupRole(role, account);
        _roleMembers[role].add(account);
    }
}",671
RealWorld_BA_49_OverlayV1UniswapV3MarketZeroLambdaShim_RealWord_20240820230227.log,49,OverlayV1UniswapV3MarketZeroLambdaShim,7542,5114,12656,115.0,0.13999,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""../OverlayV1UniswapV3Market.sol"";
import ""../libraries/FixedPoint.sol"";

contract OverlayV1UniswapV3MarketZeroLambdaShim is OverlayV1UniswapV3Market {

    using FixedPoint for uint256;

    constructor(
        address _mothership,
        address _ovlFeed,
        address _marketFeed,
        address _quote,
        address _eth,
        uint128 _amountIn,
        uint256 _macroWindow,
        uint256 _microWindow,
        uint256 _priceFrameCap
    ) OverlayV1UniswapV3Market (
        _mothership,
        _ovlFeed,
        _marketFeed,
        _quote,
        _eth,
        _amountIn,
        _macroWindow,
        _microWindow,
        _priceFrameCap
    ) { }


    function update () public virtual override returns (uint cap_) {

        cap_ = super.update();
        cap_ = lmbda == 0 ? staticCap : cap_;

    }

    function oiCap () public override view returns ( 
        uint cap_ 
    ) {

        cap_ = super.oiCap();
        cap_ = lmbda == 0 ? staticCap : cap_;

    }



}",279
RealWorld_BA_49_OverlayV1UniswapV3MultiplexMarket_RealWord_20240820222117.log,49,OverlayV1UniswapV3MultiplexMarket,40921,5487,46408,128.0,0.314345,"// // SPDX-License-Identifier: MIT
// pragma solidity ^0.8.7;

// import ""./libraries/FixedPoint.sol"";
// import ""./libraries/UniswapV3OracleLibrary/UniswapV3OracleLibraryV2.sol"";
// import ""./interfaces/IUniswapV3Pool.sol"";
// import ""./market/OverlayV1Market.sol"";

// contract OverlayV1UniswapV3MultiplexMarket is OverlayV1Market {

//     using FixedPoint for uint256;

//     uint32 public immutable macroWindow; // window size for main TWAP
//     uint32 public immutable microWindow; // window size for bid/ask TWAP

//     address public immutable feed0;
//     address public immutable base0;
//     address public immutable quote0;
//     uint128 public immutable in0;

//     address public immutable feed1;
//     address public immutable base1;
//     address public immutable quote1;
//     uint128 public immutable in1;

//     uint256 public toUpdate;
//     uint256 public updated;
//     uint256 public compounded;

//     constructor(
//         address _mothership,
//         address _uniV3Feed0,
//         address _quote0,
//         uint128 _amountIn0,
//         address _uniV3Feed1,
//         address _quote1,
//         uint128 _amountIn1,
//         uint32 _macroWindow,
//         uint32 _microWindow
//     ) OverlayV1Market(
//         _mothership
//     ) {

//         // immutables
//         macroWindow = _macroWindow;
//         microWindow = _microWindow;

//         feed0 = _uniV3Feed0;
//         feed1 = _uniV3Feed0;

//         address _f0Token0 = IUniswapV3Pool(_uniV3Feed0).token0();
//         address _f0Token1 = IUniswapV3Pool(_uniV3Feed0).token1();
//         address _f1Token0 = IUniswapV3Pool(_uniV3Feed1).token0();
//         address _f1Token1 = IUniswapV3Pool(_uniV3Feed1).token1();

//         base0 = _f0Token0 != _quote0 ? _f0Token0 : _f0Token1;
//         base1 = _f1Token0 != _quote0 ? _f1Token0 : _f1Token1;
//         quote0 = _f0Token0 == _quote0 ? _f0Token0 : _f0Token1;
//         quote1 = _f1Token0 == _quote0 ? _f1Token0 : _f1Token1;

//         in0 = _amountIn0;
//         in1 = _amountIn0;

//         uint _price = OracleLibraryV2.getQuoteAtTick(
//             OracleLibraryV2.consult(_uniV3Feed0, uint32(_macroWindow), uint32(0)),
//             uint128(_amountIn0),
//             _f0Token0 != _quote0 ? _f0Token0 : _f0Token1,
//             _f0Token0 == _quote0 ? _f0Token0 : _f0Token1
//         );

//         _price = _price.mulUp(OracleLibraryV2.getQuoteAtTick(
//             OracleLibraryV2.consult(_uniV3Feed1, uint32(_macroWindow), uint32(0)),
//             uint128(_amountIn1),
//             _f1Token0 != _quote1 ? _f1Token0 : _f1Token1,
//             _f1Token0 == _quote1 ? _f1Token0 : _f1Token1
//         ));

//         setpricePointNext(PricePoint(_price, _price, _price));

//         toUpdate = type(uint256).max;
//         updated = block.timestamp;
//         compounded = block.timestamp;

//     }

//     function price (
//         uint32 _at
//     ) public view returns (
//         PricePoint memory
//     ) { 

//         uint32[] memory _secondsAgo = new uint32[](3);
//         _secondsAgo[0] = _at + macroWindow;
//         _secondsAgo[1] = _at + microWindow;
//         _secondsAgo[2] = _at;

//         uint _microPrice;
//         uint _macroPrice;

//         ( int56[] memory _ticks, ) = IUniswapV3Pool(feed0).observe(_secondsAgo);

//         _macroPrice = OracleLibraryV2.getQuoteAtTick(
//             int24((_ticks[2] - _ticks[0]) / int56(int32(macroWindow))),
//             in0,
//             base0,
//             quote0
//         );

//         _microPrice = OracleLibraryV2.getQuoteAtTick(
//             int24((_ticks[2] - _ticks[1]) / int56(int32(microWindow))),
//             in0,
//             base0,
//             quote0
//         );

//         ( _ticks, ) = IUniswapV3Pool(feed1).observe(_secondsAgo);

//         _macroPrice = _macroPrice.mulUp(OracleLibraryV2.getQuoteAtTick(
//             int24((_ticks[2] - _ticks[0]) / int56(int32(macroWindow))),
//             in1,
//             base1,
//             quote1
//         ));

//         _macroPrice = _macroPrice.mulUp(OracleLibraryV2.getQuoteAtTick(
//             int24((_ticks[2] - _ticks[1]) / int56(int32(microWindow))),
//             in1,
//             base1,
//             quote1
//         ));

//         return insertSpread(_microPrice, _macroPrice);

//     }
//         function depth () internal view override returns (uint256 depth_) {}

//     function epochs (
//         uint _time,
//         uint _from,
//         uint _between
//     ) public view returns (
//         uint updatesThen_,
//         uint updatesNow_,
//         uint tUpdate_,
//         uint t1Update_,
//         uint compoundings_,
//         uint tCompounding_,
//         uint t1Compounding_
//     ) { 

//         uint _updatePeriod = updatePeriod;
//         uint _compoundPeriod = compoundingPeriod;
//         uint _compounded = compounded;

//         if (_between < _time) {

//             updatesThen_ = ( _between - _from ) / _updatePeriod;

//             updatesNow_ = ( _time - _between ) / _updatePeriod;

//         } else {

//             updatesNow_ = ( _time - _from ) / _updatePeriod;

//         }
        
//         tUpdate_ = _from + ( ( updatesThen_ + updatesNow_ ) * _updatePeriod );

//         t1Update_ = tUpdate_ + _updatePeriod;

//         compoundings_ = ( _time - compounded ) / _compoundPeriod;

//         tCompounding_ = _compounded + ( compoundings_ * _compoundPeriod );

//         t1Compounding_ = tCompounding_ + _compoundPeriod;

//     }

//     function staticUpdate () internal override returns (bool updated_) {

//         uint _toUpdate = toUpdate;
//         uint _updated = updated;

//         (   uint _updatesThen,,,,
//             uint _compoundings,
//             uint _tCompounding, ) = epochs(block.timestamp, _updated, _toUpdate);

//         // only update if there is a position to update
//         if (0 < _updatesThen) {

//             uint32 _then = uint32(block.timestamp - _toUpdate);
//             PricePoint memory _price = price(_then);
//             setpricePointNext(_price);
//             updated = _toUpdate;
//             toUpdate = type(uint256).max;
//             updated_ = true;

//         }

//         if (0 < _compoundings) {
//             updateFunding(_compoundings);
//             compounded = _tCompounding;
//         }

//     }

//     function entryUpdate () internal override returns (
//         uint256 t1Compounding_
//     ) {

//         uint _toUpdate = toUpdate;

//         (   uint _updatesThen,,,
//             uint _tp1Update,
//             uint _compoundings,
//             uint _tCompounding,
//             uint _t1Compounding ) = epochs(block.timestamp, updated, _toUpdate);

//         if (0 < _updatesThen) {
//             uint32 _then = uint32(block.timestamp - _toUpdate);
//             PricePoint memory _price = price(_then);
//             setpricePointNext(_price);
//             updated = _toUpdate;
//         }

//         if (0 < _compoundings) {
//             updateFunding(_compoundings);
//             compounded = _tCompounding;
//         }

//         if (_toUpdate != _tp1Update) toUpdate = _tp1Update;

//         t1Compounding_ = _t1Compounding;

//     }

//     function exitUpdate () internal override returns (uint tCompounding_) {

//         uint _toUpdate = toUpdate;

//         (   uint _updatesThen,
//             uint _updatesNow,
//             uint _tUpdate,,
//             uint _compoundings,
//             uint _tCompounding, ) = epochs(block.timestamp, updated, _toUpdate);

            
//         if (0 < _updatesThen) {

//             uint32 _then = uint32(block.timestamp - _toUpdate);
//             PricePoint memory _price = price(_then);
//             setpricePointNext(_price);

//         }

//         if (0 < _updatesNow) { 

//             uint32 _then = uint32(block.timestamp - _tUpdate);
//             PricePoint memory _price = price(_then);
//             setpricePointNext(_price);

//             updated = _tUpdate;
//             toUpdate = type(uint256).max;

//         }

//         if (0 < _compoundings) {

//             updateFunding(1);
//             updateFunding(_compoundings - 1);

//         }

//         tCompounding_ = _tCompounding;

//     }

//     function oi () public view returns (
//         uint oiLong_, 
//         uint oiShort_
//     ) {

//         ( ,,,,uint _compoundings,, ) = epochs(block.timestamp, updated, toUpdate);

//         oiLong_ = __oiLong__;
//         oiShort_ = __oiShort__;
//         uint _k = k;
//         uint _queuedOiLong = queuedOiLong;
//         uint _queuedOiShort = queuedOiShort;

//         if (0 < _compoundings) {

//             ( oiLong_, oiShort_, ) = computeFunding(
//                 oiLong_,
//                 oiShort_,
//                 1,
//                 _k
//             );

//             ( oiLong_, oiShort_, ) = computeFunding(
//                 oiLong_ += _queuedOiLong,
//                 oiShort_ += _queuedOiShort,
//                 _compoundings - 1,
//                 _k
//             );

//         } else {

//             oiLong_ += _queuedOiLong;
//             oiShort_ += _queuedOiShort;

//         }

//     }

//     function oiLong () external view returns (uint oiLong_) {
//         (   oiLong_, ) = oi();
//     }

//     function oiShort () external view returns (uint oiShort_) {
//         (  ,oiShort_ ) = oi();
//     }

// }",2522
RealWorld_BA_49_AccessControl_RealWord_20240820232445.log,49,AccessControl,30934,5238,36172,117.0,0.25943,"// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.3.2 (access/AccessControl.sol)

pragma solidity ^0.8.0;

import ""./Context.sol"";
import ""./Strings.sol"";
import ""./ERC165.sol"";
import ""./IAccessControl.sol"";

/**
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms. This is a lightweight version that doesn't allow enumerating role
 * members except through off-chain means by accessing the contract event logs. Some
 * applications may benefit from on-chain enumerability, for those cases see
 * {AccessControlEnumerable}.
 *
 * Roles are referred to by their `bytes32` identifier. These should be exposed
 * in the external API and be unique. The best way to achieve this is by
 * using `public constant` hash digests:
 *
 * ```
 * bytes32 public constant MY_ROLE = keccak256(""MY_ROLE"");
 * ```
 *
 * Roles can be used to represent a set of permissions. To restrict access to a
 * function call, use {hasRole}:
 *
 * ```
 * function foo() public {
 *     require(hasRole(MY_ROLE, msg.sender));
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {_setRoleAdmin}.
 *
 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it.
 */
abstract contract AccessControl is Context, IAccessControl, ERC165 {
    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    /**
     * @dev Modifier that checks that an account has a specific role. Reverts
     * with a standardized message including the required role.
     *
     * The format of the revert reason is given by the following regular expression:
     *
     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
     *
     * _Available since v4.1._
     */
    modifier onlyRole(bytes32 role) {
        _checkRole(role, _msgSender());
        _;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
    }

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) public view override returns (bool) {
        return _roles[role].members[account];
    }

    /**
     * @dev Revert with a standard message if `account` is missing `role`.
     *
     * The format of the revert reason is given by the following regular expression:
     *
     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
     */
    function _checkRole(bytes32 role, address account) internal view {
        if (!hasRole(role, account)) {
            revert(
                string(
                    abi.encodePacked(
                        ""AccessControl: account "",
                        Strings.toHexString(uint160(account), 20),
                        "" is missing role "",
                        Strings.toHexString(uint256(role), 32)
                    )
                )
            );
        }
    }

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {
        return _roles[role].adminRole;
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
        _grantRole(role, account);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
        _revokeRole(role, account);
    }

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been revoked `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) public virtual override {
        require(account == _msgSender(), ""AccessControl: can only renounce roles for self"");

        _revokeRole(role, account);
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event. Note that unlike {grantRole}, this function doesn't perform any
     * checks on the calling account.
     *
     * [WARNING]
     * ====
     * This function should only be called from the constructor when setting
     * up the initial roles for the system.
     *
     * Using this function in any other way is effectively circumventing the admin
     * system imposed by {AccessControl}.
     * ====
     *
     * NOTE: This function is deprecated in favor of {_grantRole}.
     */
    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }

    /**
     * @dev Sets `adminRole` as ``role``'s admin role.
     *
     * Emits a {RoleAdminChanged} event.
     */
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        bytes32 previousAdminRole = getRoleAdmin(role);
        _roles[role].adminRole = adminRole;
        emit RoleAdminChanged(role, previousAdminRole, adminRole);
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * Internal function without access restriction.
     */
    function _grantRole(bytes32 role, address account) internal virtual {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, _msgSender());
        }
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * Internal function without access restriction.
     */
    function _revokeRole(bytes32 role, address account) internal virtual {
        if (hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, _msgSender());
        }
    }
}",1729
RealWorld_BA_49_TickMath_RealWord_20240820225315.log,49,TickMath,49631,5413,55044,119.0,0.356415,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Math library for computing sqrt prices from ticks and vice versa
/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports
/// prices between 2**-128 and 2**128
library TickMath {
    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128
    int24 internal constant MIN_TICK = -887272;
    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128
    int24 internal constant MAX_TICK = -MIN_TICK;

    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
    uint160 internal constant MIN_SQRT_RATIO = 4295128739;
    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)
    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;

    /// @notice Calculates sqrt(1.0001^tick) * 2^96
    /// @dev Throws if |tick| > max tick
    /// @param tick The input tick for the above formula
    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
    /// at the given tick
    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
        require(absTick <= uint256(uint24(MAX_TICK)), 'T');

        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;

        if (tick > 0) ratio = type(uint256).max / ratio;

        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint
        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent
        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
    }

    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio
    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may
    /// ever return.
    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96
    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio
    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
        // second inequality must be < because the price can never reach the price at the max tick
        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');
        uint256 ratio = uint256(sqrtPriceX96) << 32;

        uint256 r = ratio;
        uint256 msb = 0;

        assembly {
            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(5, gt(r, 0xFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(4, gt(r, 0xFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(3, gt(r, 0xFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(2, gt(r, 0xF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(1, gt(r, 0x3))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := gt(r, 0x1)
            msb := or(msb, f)
        }

        if (msb >= 128) r = ratio >> (msb - 127);
        else r = ratio << (127 - msb);

        int256 log_2 = (int256(msb) - 128) << 64;

        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(63, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(62, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(61, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(60, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(59, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(58, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(57, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(56, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(55, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(54, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(53, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(52, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(51, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(50, f))
        }

        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number

        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);

        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
    }
}",2861
RealWorld_BA_49_PoolAddress_RealWord_20240820225127.log,49,PoolAddress,10333,4693,15026,105.0,0.145525,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee
library PoolAddress {
    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;

    /// @notice The identifying key of the pool
    struct PoolKey {
        address token0;
        address token1;
        uint24 fee;
    }

    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels
    /// @param tokenA The first token of a pool, unsorted
    /// @param tokenB The second token of a pool, unsorted
    /// @param fee The fee level of the pool
    /// @return Poolkey The pool details with ordered token0 and token1 assignments
    function getPoolKey(
        address tokenA,
        address tokenB,
        uint24 fee
    ) internal pure returns (PoolKey memory) {
        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);
        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});
    }

    /// @notice Deterministically computes the pool address given the factory and PoolKey
    /// @param factory The Uniswap V3 factory contract address
    /// @param key The PoolKey
    /// @return pool The contract address of the V3 pool
    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {
        require(key.token0 < key.token1);
        pool = address(
            uint160(uint256(
                keccak256(
                    abi.encodePacked(
                        hex'ff',
                        factory,
                        keccak256(abi.encode(key.token0, key.token1, key.fee)),
                        POOL_INIT_CODE_HASH
                    )
                )
            ))
        );
    }
}",441
RealWorld_BA_49_OverlayV1Governance_RealWord_20240820233103.log,49,OverlayV1Governance,15325,5285,20610,124.0,0.182325,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""../interfaces/IOverlayV1Mothership.sol"";
import ""../interfaces/IOverlayToken.sol"";
import ""../interfaces/IOverlayTokenNew.sol"";
import ""./OverlayV1Comptroller.sol"";
import ""./OverlayV1OI.sol"";
import ""./OverlayV1PricePoint.sol"";

abstract contract OverlayV1Governance is
    OverlayV1Comptroller,
    OverlayV1OI,
    OverlayV1PricePoint {

    uint constant private ONE = 1e18;

    bytes32 constant private COLLATERAL = keccak256(""COLLATERAL"");
    bytes32 constant private GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 constant private MARKET = keccak256(""MARKET"");

    address public immutable ovl;

    IOverlayV1Mothership public immutable mothership;

    uint256 public leverageMax;

    mapping (address => bool) public isCollateral;

    modifier onlyCollateral () {
        require(isCollateral[msg.sender], ""OVLV1:!collateral"");
        _;
    }

    modifier onlyGovernor () {
        require(mothership.hasRole(GOVERNOR, msg.sender), ""OVLV1:!governor"");
        _;
    }

    modifier enabled() {
        require(mothership.hasRole(MARKET, address(this)), ""OVLV1:!enabled"");
        _;
    }

    constructor(
        address _mothership
    ) {

        mothership = IOverlayV1Mothership(_mothership);
        ovl = address(IOverlayV1Mothership(_mothership).ovl());

    }

    function addCollateral (address _collateral) public onlyGovernor {

        isCollateral[_collateral] = true;

    }

    function removeCollateral (address _collateral) public onlyGovernor {

        isCollateral[_collateral] = false;

    }

    function setEverything (
        uint256 _k,
        uint256 _pbnj,
        uint256 _compoundPeriod,
        uint256 _lmbda,
        uint256 _staticCap,
        uint256 _brrrrdExpected,
        uint256 _brrrrdWindowMacro,
        uint256 _brrrrdWindowMicro
    ) public onlyGovernor {

        setK(_k);

        setSpread(_pbnj);

        setPeriods(
            _compoundPeriod
        );

        setComptrollerParams(
            _lmbda,
            _staticCap,
            _brrrrdExpected,
            _brrrrdWindowMacro,
            _brrrrdWindowMicro
        );

    }

    function setSpread(
        uint256 _pbnj
    ) public onlyGovernor {

        pbnj = _pbnj;

    }

    function setK (
        uint256 _k
    ) public onlyGovernor {
        k = _k;
    }

    function setPeriods(
        uint256 _compoundingPeriod
    ) public onlyGovernor {

        compoundingPeriod = _compoundingPeriod;

    }

    function setComptrollerParams (
        uint256 _lmbda,
        uint256 _staticCap,
        uint256 _brrrrExpected,
        uint256 _brrrrdWindowMacro,
        uint256 _brrrrdWindowMicro
    ) public onlyGovernor {

        lmbda = _lmbda;
        staticCap = _staticCap;
        brrrrdExpected = _brrrrExpected;
        brrrrdWindowMacro = _brrrrdWindowMacro;
        brrrrdWindowMicro = _brrrrdWindowMicro;

    }

}",781
RealWorld_BA_49_UniswapV3OracleLibraryV2_RealWord_20240820224728.log,49,UniswapV3OracleLibraryV2,15439,5881,21320,125.0,0.194815,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0 <=0.8.7;

import '../../interfaces/IUniswapV3Pool.sol';
import './TickMath.sol';
import './FullMath.sol';
import './LowGasSafeMath.sol';
import './PoolAddress.sol';

/// @title Oracle library
/// @notice Provides functions to integrate with V3 pool oracle
library OracleLibraryV2 {


    /// @notice Fetches time-weighted average tick using Uniswap V3 oracle
    /// @param pool Address of Uniswap V3 pool that we want to observe
    /// @param secondsAgoStart end of twap time
    /// @param secondsAgoEnd start of twap time
    /// @return timeWeightedAverageTick The time-weighted average tick from (block.timestamp - period) to block.timestamp
    function consult(
        address pool, 
        uint32 secondsAgoStart, 
        uint32 secondsAgoEnd
    ) internal view returns (int24 timeWeightedAverageTick) {
        uint32 period = secondsAgoStart - secondsAgoEnd;

        require(period != 0, 'BP');

        uint32[] memory secondAgos = new uint32[](2);
        secondAgos[0] = secondsAgoStart;
        secondAgos[1] = secondsAgoEnd;

        (int56[] memory tickCumulatives, ) = IUniswapV3Pool(pool).observe(secondAgos);
        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];

        timeWeightedAverageTick = int24(tickCumulativesDelta / int56(int32(period)));

        // Always round to negative infinity
        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(int32(period)) != 0)) timeWeightedAverageTick--;

    }

    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange
    /// @param tick Tick value used to calculate the quote
    /// @param baseAmount Amount of token to be converted
    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination
    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination
    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken
    function getQuoteAtTick(
        int24 tick,
        uint128 baseAmount,
        address baseToken,
        address quoteToken
    ) internal pure returns (uint256 quoteAmount) {
        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);

        // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself
        if (sqrtRatioX96 <= type(uint128).max) {
            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;
            quoteAmount = baseToken < quoteToken
                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)
                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);
        } else {
            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);
            quoteAmount = baseToken < quoteToken
                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)
                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);
        }
    }
}",759
RealWorld_BA_49_FixedPoint_RealWord_20240820224026.log,49,FixedPoint,24464,6044,30508,140.0,0.2432,"// SPDX-License-Identifier: GPL-3.0-or-later
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity ^0.8.7;
import ""./LogExpMath.sol"";
import ""../utils/Errors.sol"";

/* solhint-disable private-vars-leading-underscore */

library FixedPoint {
    uint256 internal constant ONE = 1e18; // 18 decimal places
    uint256 internal constant MAX_POW_RELATIVE_ERROR = 10000; // 10^(-14)

    // Minimum base for the power function when the exponent is 'free' (larger than ONE).
    uint256 internal constant MIN_POW_BASE_FREE_EXPONENT = 0.7e18;

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        // Fixed Point addition is the same as regular checked addition

        uint256 c = a + b;
        _require(c >= a, Errors.ADD_OVERFLOW);
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        // Fixed Point addition is the same as regular checked addition

        _require(b <= a, Errors.SUB_OVERFLOW);
        uint256 c = a - b;
        return c;
    }

    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 product = a * b;
        _require(a == 0 || product / a == b, Errors.MUL_OVERFLOW);

        return product / ONE;
    }

    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 product = a * b;
        _require(a == 0 || product / a == b, Errors.MUL_OVERFLOW);

        if (product == 0) {
            return 0;
        } else {
            // The traditional divUp formula is:
            // divUp(x, y) := (x + y - 1) / y
            // To avoid intermediate overflow in the addition, we distribute the division and get:
            // divUp(x, y) := (x - 1) / y + 1
            // Note that this requires x != 0, which we already tested for.

            return ((product - 1) / ONE) + 1;
        }
    }

    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {
        _require(b != 0, Errors.ZERO_DIVISION);

        if (a == 0) {
            return 0;
        } else {
            uint256 aInflated = a * ONE;
            _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow

            return aInflated / b;
        }
    }

    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {
        _require(b != 0, Errors.ZERO_DIVISION);

        if (a == 0) {
            return 0;
        } else {
            uint256 aInflated = a * ONE;
            _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow

            // The traditional divUp formula is:
            // divUp(x, y) := (x + y - 1) / y
            // To avoid intermediate overflow in the addition, we distribute the division and get:
            // divUp(x, y) := (x - 1) / y + 1
            // Note that this requires x != 0, which we already tested for.

            return ((aInflated - 1) / b) + 1;
        }
    }

    /**
     * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above
     * the true value (that is, the error function expected - actual is always positive).
     */
    function powDown(uint256 x, uint256 y) internal pure returns (uint256) {

        if (0 == y || x == ONE) return ONE;

        uint256 raw = LogExpMath.pow(x, y);
        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);

        if (raw < maxError) {
            return 0;
        } else {
            return sub(raw, maxError);
        }

    }

    /**
     * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below
     * the true value (that is, the error function expected - actual is always negative).
     */
    function powUp(uint256 x, uint256 y) internal pure returns (uint256) {

        if (ONE == x || y == 0) return ONE;

        uint256 raw = LogExpMath.pow(x, y);
        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);

        return add(raw, maxError);

    }

    /**
     * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.
     *
     * Useful when computing the complement for values with some level of relative error, as it strips this error and
     * prevents intermediate negative values.
     */
    function complement(uint256 x) internal pure returns (uint256) {
        return (x < ONE) ? (ONE - x) : 0;
    }
}",1278
RealWorld_BA_49_Errors_RealWord_20240820225728.log,49,Errors,48109,5417,53526,144.0,0.348885,"// SPDX-License-Identifier: GPL-3.0-or-later
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity ^0.8.7;

// solhint-disable

/**
 * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are
 * supported.
 */
function _require(bool condition, uint256 errorCode) pure {
    if (!condition) _revert(errorCode);
}

/**
 * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.
 */
function _revert(uint256 errorCode) pure {
    // We're going to dynamically create a revert string based on the error code, with the following format:
    // 'BAL#{errorCode}'
    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).
    //
    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a
    // number (8 to 16 bits) than the individual string characters.
    //
    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a
    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a
    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.
    assembly {
        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999
        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for
        // the '0' character.

        let units := add(mod(errorCode, 10), 0x30)

        errorCode := div(errorCode, 10)
        let tenths := add(mod(errorCode, 10), 0x30)

        errorCode := div(errorCode, 10)
        let hundreds := add(mod(errorCode, 10), 0x30)

        // With the individual characters, we can now construct the full string. The ""BAL#"" part is a known constant
        // (0x42414c23): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the
        // characters to it, each shifted by a multiple of 8.
        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits
        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte
        // array).

        let revertReason := shl(200, add(0x42414c23000000, add(add(units, shl(8, tenths)), shl(16, hundreds))))

        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded
        // message will have the following layout:
        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]

        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We
        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.
        mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)
        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).
        mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)
        // The string length is fixed: 7 characters.
        mstore(0x24, 7)
        // Finally, the string itself is stored.
        mstore(0x44, revertReason)

        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of
        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.
        revert(0, 100)
    }
}

library Errors {
    // Math
    uint256 internal constant ADD_OVERFLOW = 0;
    uint256 internal constant SUB_OVERFLOW = 1;
    uint256 internal constant SUB_UNDERFLOW = 2;
    uint256 internal constant MUL_OVERFLOW = 3;
    uint256 internal constant ZERO_DIVISION = 4;
    uint256 internal constant DIV_INTERNAL = 5;
    uint256 internal constant X_OUT_OF_BOUNDS = 6;
    uint256 internal constant Y_OUT_OF_BOUNDS = 7;
    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;
    uint256 internal constant INVALID_EXPONENT = 9;

    // Input
    uint256 internal constant OUT_OF_BOUNDS = 100;
    uint256 internal constant UNSORTED_ARRAY = 101;
    uint256 internal constant UNSORTED_TOKENS = 102;
    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;
    uint256 internal constant ZERO_TOKEN = 104;

    // Shared pools
    uint256 internal constant MIN_TOKENS = 200;
    uint256 internal constant MAX_TOKENS = 201;
    uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;
    uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;
    uint256 internal constant MINIMUM_BPT = 204;
    uint256 internal constant CALLER_NOT_VAULT = 205;
    uint256 internal constant UNINITIALIZED = 206;
    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;
    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;
    uint256 internal constant EXPIRED_PERMIT = 209;
    uint256 internal constant NOT_TWO_TOKENS = 210;

    // Pools
    uint256 internal constant MIN_AMP = 300;
    uint256 internal constant MAX_AMP = 301;
    uint256 internal constant MIN_WEIGHT = 302;
    uint256 internal constant MAX_STABLE_TOKENS = 303;
    uint256 internal constant MAX_IN_RATIO = 304;
    uint256 internal constant MAX_OUT_RATIO = 305;
    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;
    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;
    uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;
    uint256 internal constant INVALID_TOKEN = 309;
    uint256 internal constant UNHANDLED_JOIN_KIND = 310;
    uint256 internal constant ZERO_INVARIANT = 311;
    uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;
    uint256 internal constant ORACLE_NOT_INITIALIZED = 313;
    uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;
    uint256 internal constant ORACLE_INVALID_INDEX = 315;
    uint256 internal constant ORACLE_BAD_SECS = 316;
    uint256 internal constant AMP_END_TIME_TOO_CLOSE = 317;
    uint256 internal constant AMP_ONGOING_UPDATE = 318;
    uint256 internal constant AMP_RATE_TOO_HIGH = 319;
    uint256 internal constant AMP_NO_ONGOING_UPDATE = 320;
    uint256 internal constant STABLE_INVARIANT_DIDNT_CONVERGE = 321;
    uint256 internal constant STABLE_GET_BALANCE_DIDNT_CONVERGE = 322;
    uint256 internal constant RELAYER_NOT_CONTRACT = 323;
    uint256 internal constant BASE_POOL_RELAYER_NOT_CALLED = 324;
    uint256 internal constant REBALANCING_RELAYER_REENTERED = 325;
    uint256 internal constant GRADUAL_UPDATE_TIME_TRAVEL = 326;
    uint256 internal constant SWAPS_DISABLED = 327;
    uint256 internal constant CALLER_IS_NOT_LBP_OWNER = 328;
    uint256 internal constant PRICE_RATE_OVERFLOW = 329;
    uint256 internal constant INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED = 330;

    // Lib
    uint256 internal constant REENTRANCY = 400;
    uint256 internal constant SENDER_NOT_ALLOWED = 401;
    uint256 internal constant PAUSED = 402;
    uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;
    uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;
    uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;
    uint256 internal constant INSUFFICIENT_BALANCE = 406;
    uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;
    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;
    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;
    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;
    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;
    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;
    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;
    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;
    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;
    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;
    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;
    uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;
    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;
    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;
    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;
    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;
    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;
    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;
    uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;
    uint256 internal constant CALLER_IS_NOT_OWNER = 426;
    uint256 internal constant NEW_OWNER_IS_ZERO = 427;
    uint256 internal constant CODE_DEPLOYMENT_FAILED = 428;
    uint256 internal constant CALL_TO_NON_CONTRACT = 429;
    uint256 internal constant LOW_LEVEL_CALL_FAILED = 430;

    // Vault
    uint256 internal constant INVALID_POOL_ID = 500;
    uint256 internal constant CALLER_NOT_POOL = 501;
    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;
    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;
    uint256 internal constant INVALID_SIGNATURE = 504;
    uint256 internal constant EXIT_BELOW_MIN = 505;
    uint256 internal constant JOIN_ABOVE_MAX = 506;
    uint256 internal constant SWAP_LIMIT = 507;
    uint256 internal constant SWAP_DEADLINE = 508;
    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;
    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;
    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;
    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;
    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;
    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;
    uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;
    uint256 internal constant INSUFFICIENT_ETH = 516;
    uint256 internal constant UNALLOCATED_ETH = 517;
    uint256 internal constant ETH_TRANSFER = 518;
    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;
    uint256 internal constant TOKENS_MISMATCH = 520;
    uint256 internal constant TOKEN_NOT_REGISTERED = 521;
    uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;
    uint256 internal constant TOKENS_ALREADY_SET = 523;
    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;
    uint256 internal constant NONZERO_TOKEN_BALANCE = 525;
    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;
    uint256 internal constant POOL_NO_TOKENS = 527;
    uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;

    // Fees
    uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;
    uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;
    uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;
}",2769
RealWorld_BA_49_FullMath_RealWord_20240820225517.log,49,FullMath,23211,5396,28607,129.0,0.223975,"// SPDX-License-Identifier: MIT
pragma solidity >=0.4.0;

/// @title Contains 512-bit math functions
/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision
/// @dev Handles ""phantom overflow"" i.e., allows multiplication and division where an intermediate value overflows 256 bits
library FullMath {
    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0
    /// @param a The multiplicand
    /// @param b The multiplier
    /// @param denominator The divisor
    /// @return result The 256-bit result
    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv
    function mulDiv(
        uint256 a,
        uint256 b,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        // 512-bit multiply [prod1 prod0] = a * b
        // Compute the product mod 2**256 and mod 2**256 - 1
        // then use the Chinese Remainder Theorem to reconstruct
        // the 512 bit result. The result is stored in two 256
        // variables such that product = prod1 * 2**256 + prod0
        uint256 prod0; // Least significant 256 bits of the product
        uint256 prod1; // Most significant 256 bits of the product
        assembly {
            let mm := mulmod(a, b, not(0))
            prod0 := mul(a, b)
            prod1 := sub(sub(mm, prod0), lt(mm, prod0))
        }

        // Handle non-overflow cases, 256 by 256 division
        if (prod1 == 0) {
            require(denominator > 0);
            assembly {
                result := div(prod0, denominator)
            }
            return result;
        }

        // Make sure the result is less than 2**256.
        // Also prevents denominator == 0
        require(denominator > prod1);

        ///////////////////////////////////////////////
        // 512 by 256 division.
        ///////////////////////////////////////////////

        // Make division exact by subtracting the remainder from [prod1 prod0]
        // Compute remainder using mulmod
        uint256 remainder;
        assembly {
            remainder := mulmod(a, b, denominator)
        }
        // Subtract 256 bit number from 512 bit number
        assembly {
            prod1 := sub(prod1, gt(remainder, prod0))
            prod0 := sub(prod0, remainder)
        }

        // Factor powers of two out of denominator
        // Compute largest power of two divisor of denominator.
        // Always >= 1.
        uint256 twos = uint256(-int256(denominator) & int256(denominator));
        // Divide denominator by power of two
        assembly {
            denominator := div(denominator, twos)
        }

        // Divide [prod1 prod0] by the factors of two
        assembly {
            prod0 := div(prod0, twos)
        }
        // Shift in bits from prod1 into prod0. For this we need
        // to flip `twos` such that it is 2**256 / twos.
        // If twos is zero, then it becomes one
        assembly {
            twos := add(div(sub(0, twos), twos), 1)
        }
        prod0 |= prod1 * twos;

        // Invert denominator mod 2**256
        // Now that denominator is an odd number, it has an inverse
        // modulo 2**256 such that denominator * inv = 1 mod 2**256.
        // Compute the inverse by starting with a seed that is correct
        // correct for four bits. That is, denominator * inv = 1 mod 2**4
        uint256 inv = (3 * denominator) ^ 2;
        // Now use Newton-Raphson iteration to improve the precision.
        // Thanks to Hensel's lifting lemma, this also works in modular
        // arithmetic, doubling the correct bits in each step.
        inv *= 2 - denominator * inv; // inverse mod 2**8
        inv *= 2 - denominator * inv; // inverse mod 2**16
        inv *= 2 - denominator * inv; // inverse mod 2**32
        inv *= 2 - denominator * inv; // inverse mod 2**64
        inv *= 2 - denominator * inv; // inverse mod 2**128
        inv *= 2 - denominator * inv; // inverse mod 2**256

        // Because the division is now exact we can divide by multiplying
        // with the modular inverse of denominator. This will give us the
        // correct result modulo 2**256. Since the precoditions guarantee
        // that the outcome is less than 2**256, this is the final result.
        // We don't need to compute the high bits of the result and prod1
        // is no longer required.
        result = prod0 * inv;
        return result;
    }

    /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0
    /// @param a The multiplicand
    /// @param b The multiplier
    /// @param denominator The divisor
    /// @return result The 256-bit result
    function mulDivRoundingUp(
        uint256 a,
        uint256 b,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        result = mulDiv(a, b, denominator);
        if (mulmod(a, b, denominator) > 0) {
            require(result < type(uint256).max);
            result++;
        }
    }
}",1248
RealWorld_BA_49_IERC165_RealWord_20240820232316.log,49,IERC165,6240,3920,10160,87.0,0.1096,"// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.3.2 (utils/introspection/IERC165.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}",215
RealWorld_BA_49_Position_RealWord_20240820223819.log,49,Position,37189,5458,42647,124.0,0.295105,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@openzeppelin/contracts/utils/math/Math.sol"";
import ""./FixedPoint.sol"";

library Position {

    using FixedPoint for uint256;

    struct Info {
        address market; // the market for the position
        bool isLong; // whether long or short
        uint leverage; // discrete initial leverage amount
        uint pricePoint; // pricePointIndex
        uint256 oiShares; // shares of total open interest on long/short side, depending on isLong value
        uint256 debt; // total debt associated with this position
        uint256 cost; // total amount of collateral initially locked; effectively, cost to enter position
    }

    uint256 constant TWO = 2e18;

    function _initialOi (
        Info memory _self
    ) private pure returns (
        uint initialOi_
    ) {

        initialOi_ = _self.cost + _self.debt;

    }

    function _oi (
        Info memory _self,
        uint256 totalOi,
        uint256 totalOiShares
    ) private pure returns (uint256 oi_) {

        oi_ = _self.oiShares
            .mulDown(totalOi)
            .divUp(totalOiShares);

    }

    /// @dev Floors to zero, so won't properly compute if self is underwater
    function _value (
        Info memory _self,
        uint256 totalOi,
        uint256 totalOiShares,
        uint256 priceFrame
    ) private pure returns (uint256 val_) {

        uint256 __oi = _oi(_self, totalOi, totalOiShares);

        if (_self.isLong) { // oi * priceFrame - debt

            val_ = __oi.mulDown(priceFrame);
            val_ -= Math.min(val_, _self.debt); // floor to 0

        } else { // oi * (2 - priceFrame) - debt

            val_ = __oi.mulDown(2e18);
            val_ -= Math.min(val_, _self.debt + __oi.mulDown(priceFrame)); // floor to 0

        }

    }

    /// @dev is true when position value < 0
    function _isUnderwater(
        Info memory _self,
        uint256 totalOi,
        uint256 totalOiShares,
        uint256 priceFrame
    ) private pure returns (bool isUnder) {

        uint256 __oi = _oi(_self, totalOi, totalOiShares);

        bool _long = _self.isLong;

        if (_long) isUnder = __oi.mulDown(priceFrame) < _self.debt;
        else isUnder = __oi.mulDown(priceFrame) + _self.debt < ( __oi * 2 );

    }

    /// @dev Floors to _self.debt, so won't properly compute if _self is underwater
    function _notional (
        Info memory _self,
        uint256 totalOi,
        uint256 totalOiShares,
        uint256 priceFrame
    ) private pure returns (uint256 notion) {

        uint256 val = _value(
            _self,
            totalOi,
            totalOiShares,
            priceFrame
        );

        notion = val + _self.debt;

    }

    /// @dev ceils uint256.max if position value <= 0
    function _openLeverage (
        Info memory _self,
        uint256 totalOi,
        uint256 totalOiShares,
        uint256 priceFrame
    ) private pure returns (uint lev) {

        uint val = _value(
            _self,
            totalOi,
            totalOiShares,
            priceFrame
        );

        if (val != 0) {

            uint256 notion = _notional(
                _self,
                totalOi,
                totalOiShares,
                priceFrame
            );

            lev = notion.divDown(val);

        } else lev = type(uint256).max;

    }

    /// @dev floors zero if position value <= 0; equiv to 1 / open leverage
    function _openMargin (
        Info memory _self,
        uint256 totalOi,
        uint256 totalOiShares,
        uint256 priceFrame
    ) private pure returns (uint margin) {

        uint notion = _notional(
            _self,
            totalOi,
            totalOiShares,
            priceFrame
        );

        if (notion != 0) {

            uint256 val = _value(
                _self,
                totalOi,
                totalOiShares,
                priceFrame
            );

            margin = val.divDown(notion);

        } else margin = 0;

    }

    /// @dev is true when open margin < maintenance margin
    function _isLiquidatable (
        Info memory _self,
        uint256 _totalOi,
        uint256 _totalOiShares,
        uint256 _priceFrame,
        uint256 _marginMaintenance
    ) private pure returns (
        bool can_
    ) {

        uint _val = _value(
            _self,
            _totalOi,
            _totalOiShares,
            _priceFrame
        );

        uint _initOi = _initialOi(_self);

        uint _maintenanceMargin = _initOi.mulUp(_marginMaintenance);

        can_ = _val < _maintenanceMargin;

    }

    function _liquidationPrice (
        Info memory _self,
        uint256 _totalOi,
        uint256 _totalOiShares,
        uint256 _priceEntry,
        uint256 _marginMaintenance
    ) private pure returns (uint256 liqPrice) {

        uint256 _posOi = _oi(_self, _totalOi, _totalOiShares);
        uint256 _posInitialOi = _initialOi(_self);

        uint256 _oiFrame = _posInitialOi.mulUp(_marginMaintenance)
            .add(_self.debt)
            .divDown(_posOi);

        if (_self.isLong) liqPrice = _priceEntry.mulUp(_oiFrame);
        else liqPrice = _priceEntry.mulUp(TWO.sub(_oiFrame));

    }

    function initialOi (
        Info storage self
    ) internal view returns (
        uint256 initialOi_
    ) {

        Info memory _self = self;

        initialOi_ = _initialOi(_self);

    }

    /// @notice Computes the open interest of a position
    function oi (
        Info storage self,
        uint256 totalOi,
        uint256 totalOiShares
    ) internal view returns (uint256) {

        Info memory _self = self;

        return _oi(_self, totalOi, totalOiShares);

    }

    /// @notice Computes the value of a position
    /// @dev Floors to zero, so won't properly compute if self is underwater
    function value(
        Info storage self,
        uint256 totalOi,
        uint256 totalOiShares,
        uint256 priceFrame
    ) internal view returns (uint256) {

        Info memory _self = self;

        return _value(
            _self,
            totalOi,
            totalOiShares,
            priceFrame
        );

    }

    /// @notice Whether position is underwater
    /// @dev is true when position value <= 0
    function isUnderwater(
        Info storage self,
        uint256 totalOi,
        uint256 totalOiShares,
        uint256 priceFrame
    ) internal view returns (bool) {

        Info memory _self = self;

        return _isUnderwater(
            _self,
            totalOi,
            totalOiShares,
            priceFrame
        );

    }

    /// @notice Computes the notional of a position
    /// @dev Floors to _self.debt if value <= 0
    function notional(
        Info storage self,
        uint256 totalOi,
        uint256 totalOiShares,
        uint256 priceFrame
    ) internal view returns (uint256) {

        Info memory _self = self;

        return _notional(
            _self,
            totalOi,
            totalOiShares,
            priceFrame
        );

    }

    /// @notice Computes the open leverage of a position
    /// @dev ceils uint256.max if position value <= 0
    function openLeverage(
        Info storage self,
        uint256 totalOi,
        uint256 totalOiShares,
        uint256 priceFrame
    ) internal view returns (uint) {

        Info memory _self = self;

        return _openLeverage(
            _self,
            totalOi,
            totalOiShares,
            priceFrame
        );

    }

    /// @notice Computes the open margin of a position
    /// @dev floors zero if position value <= 0
    function openMargin(
        Info storage self,
        uint256 totalOi,
        uint256 totalOiShares,
        uint256 priceFrame
    ) internal view returns (uint) {

        Info memory _self = self;

        return _openMargin(
            _self,
            totalOi,
            totalOiShares,
            priceFrame
        );

    }

    /// @notice Whether a position can be liquidated
    /// @dev is true when value < maintenance margin
    function isLiquidatable(
        Info storage self,
        uint256 totalOi,
        uint256 totalOiShares,
        uint256 priceFrame,
        uint256 marginMaintenance
    ) internal view returns (bool) {

        Info memory _self = self;

        return _isLiquidatable(
            _self,
            totalOi,
            totalOiShares,
            priceFrame,
            marginMaintenance
        );

    }

    /// @notice Computes the liquidation price of a position
    /// @dev price when value < maintenance margin
    function liquidationPrice(
        Info storage self,
        uint256 totalOi,
        uint256 totalOiShares,
        uint256 priceEntry,
        uint256 marginMaintenance
    ) internal view returns (
        uint256 liquidationPrice_
    ) {

        Info memory _self = self;

        liquidationPrice_ = _liquidationPrice(
            _self,
            totalOi,
            totalOiShares,
            priceEntry,
            marginMaintenance
        );

    }
}",2118
RealWorld_BA_49_IAccessControlEnumerable_RealWord_20240820231054.log,49,IAccessControlEnumerable,7844,4932,12776,107.0,0.13786,"// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.3.2 (access/IAccessControlEnumerable.sol)

pragma solidity ^0.8.0;

import ""./IAccessControl.sol"";

/**
 * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.
 */
interface IAccessControlEnumerable is IAccessControl {
    /**
     * @dev Returns one of the accounts that have `role`. `index` must be a
     * value between 0 and {getRoleMemberCount}, non-inclusive.
     *
     * Role bearers are not sorted in any particular way, and their ordering may
     * change at any point.
     *
     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure
     * you perform all queries on the same block. See the following
     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]
     * for more information.
     */
    function getRoleMember(bytes32 role, uint256 index) external view returns (address);

    /**
     * @dev Returns the number of accounts that have `role`. Can be used
     * together with {getRoleMember} to enumerate all bearers of a role.
     */
    function getRoleMemberCount(bytes32 role) external view returns (uint256);
}",294
RealWorld_BA_49_IUniswapV3Pool_RealWord_20240820234438.log,49,IUniswapV3Pool,6663,4926,11589,114.0,0.131835,"pragma solidity >=0.5.0;

import './uniV3Pool/IUniswapV3PoolImmutables.sol';
import './uniV3Pool/IUniswapV3PoolState.sol';
import './uniV3Pool/IUniswapV3PoolDerivedState.sol';
import './uniV3Pool/IUniswapV3PoolActions.sol';
import './uniV3Pool/IUniswapV3PoolOwnerActions.sol';
import './uniV3Pool/IUniswapV3PoolEvents.sol';

/// @title The interface for a Uniswap V3 Pool
/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform
/// to the ERC20 specification
/// @dev The pool interface is broken up into many smaller pieces
interface IUniswapV3Pool is
    IUniswapV3PoolImmutables,
    IUniswapV3PoolState,
    IUniswapV3PoolDerivedState,
    IUniswapV3PoolActions,
    IUniswapV3PoolOwnerActions,
    IUniswapV3PoolEvents
{

}",242
RealWorld_BA_49_IOverlayV1Mothership_RealWord_20240820233915.log,49,IOverlayV1Mothership,9387,5205,14592,113.0,0.151035,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""./IOverlayToken.sol"";
import ""./IOverlayTokenNew.sol"";

interface IOverlayV1Mothership {

    function ovl () external view returns (
        IOverlayTokenNew ovl_
    );

    function marketActive(
        address
    ) external view returns (
        bool
    );

    function marketExists(
        address
    ) external view returns (
        bool
    );

    function allMarkets(
        uint marketIndex
    ) external view returns (
        address marketAddress
    );

    function collateralActive(
        address
    ) external view returns (
        bool
    );

    function collateralExists(
        address
    ) external view returns (
        bool
    );

    function allCollateral(
        uint collateralIndex
    ) external view returns (
        address collateralAddress
    );

    function totalMarkets () external view returns (
            uint
    );

    function getGlobalParams() external view returns (
        uint16 fee_,
        uint16 feeBurnRate_,
        address feeTo_,
        uint8 marginMaintenance_,
        uint8 marginBurnRate_
    );

    function getUpdateParams() external view returns (
        uint marginBurnRate_,
        uint feeBurnRate_,
        address feeTo_
    );

    function getMarginParams() external view returns (
        uint marginMaintenance_,
        uint marginRewardRate_
    );

    function fee() external view returns (uint256);

    function updateMarket(
        address _market,
        address _rewardsTo
    ) external;

    function massUpdateMarkets(
        address _rewardsTo
    ) external;

    function hasRole(
        bytes32 _role,
        address _account
    ) external view returns (
        bool
    );

}",370
RealWorld_BA_49_EnumerableSet_RealWord_20240820231632.log,49,EnumerableSet,49314,4930,54244,108.0,0.34517,"// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.3.2 (utils/structs/EnumerableSet.sol)

pragma solidity ^0.8.0;

/**
 * @dev Library for managing
 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive
 * types.
 *
 * Sets have the following properties:
 *
 * - Elements are added, removed, and checked for existence in constant time
 * (O(1)).
 * - Elements are enumerated in O(n). No guarantees are made on the ordering.
 *
 * ```
 * contract Example {
 *     // Add the library methods
 *     using EnumerableSet for EnumerableSet.AddressSet;
 *
 *     // Declare a set state variable
 *     EnumerableSet.AddressSet private mySet;
 * }
 * ```
 *
 * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)
 * and `uint256` (`UintSet`) are supported.
 */
library EnumerableSet {
    // To implement this library for multiple types with as little code
    // repetition as possible, we write it in terms of a generic Set type with
    // bytes32 values.
    // The Set implementation uses private functions, and user-facing
    // implementations (such as AddressSet) are just wrappers around the
    // underlying Set.
    // This means that we can only create new EnumerableSets for types that fit
    // in bytes32.

    struct Set {
        // Storage of set values
        bytes32[] _values;
        // Position of the value in the `values` array, plus 1 because index 0
        // means a value is not in the set.
        mapping(bytes32 => uint256) _indexes;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function _add(Set storage set, bytes32 value) private returns (bool) {
        if (!_contains(set, value)) {
            set._values.push(value);
            // The value is stored at length-1, but we add 1 to all indexes
            // and use 0 as a sentinel value
            set._indexes[value] = set._values.length;
            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function _remove(Set storage set, bytes32 value) private returns (bool) {
        // We read and store the value's index to prevent multiple reads from the same storage slot
        uint256 valueIndex = set._indexes[value];

        if (valueIndex != 0) {
            // Equivalent to contains(set, value)
            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in
            // the array, and then remove the last element (sometimes called as 'swap and pop').
            // This modifies the order of the array, as noted in {at}.

            uint256 toDeleteIndex = valueIndex - 1;
            uint256 lastIndex = set._values.length - 1;

            if (lastIndex != toDeleteIndex) {
                bytes32 lastvalue = set._values[lastIndex];

                // Move the last value to the index where the value to delete is
                set._values[toDeleteIndex] = lastvalue;
                // Update the index for the moved value
                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex
            }

            // Delete the slot where the moved value was stored
            set._values.pop();

            // Delete the index for the deleted slot
            delete set._indexes[value];

            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function _contains(Set storage set, bytes32 value) private view returns (bool) {
        return set._indexes[value] != 0;
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function _length(Set storage set) private view returns (uint256) {
        return set._values.length;
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function _at(Set storage set, uint256 index) private view returns (bytes32) {
        return set._values[index];
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function _values(Set storage set) private view returns (bytes32[] memory) {
        return set._values;
    }

    // Bytes32Set

    struct Bytes32Set {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
        return _add(set._inner, value);
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
        return _remove(set._inner, value);
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
        return _contains(set._inner, value);
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(Bytes32Set storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
        return _at(set._inner, index);
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {
        return _values(set._inner);
    }

    // AddressSet

    struct AddressSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(AddressSet storage set, address value) internal returns (bool) {
        return _add(set._inner, bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(AddressSet storage set, address value) internal returns (bool) {
        return _remove(set._inner, bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(AddressSet storage set, address value) internal view returns (bool) {
        return _contains(set._inner, bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(AddressSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(AddressSet storage set, uint256 index) internal view returns (address) {
        return address(uint160(uint256(_at(set._inner, index))));
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function values(AddressSet storage set) internal view returns (address[] memory) {
        bytes32[] memory store = _values(set._inner);
        address[] memory result;

        assembly {
            result := store
        }

        return result;
    }

    // UintSet

    struct UintSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(UintSet storage set, uint256 value) internal returns (bool) {
        return _add(set._inner, bytes32(value));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(UintSet storage set, uint256 value) internal returns (bool) {
        return _remove(set._inner, bytes32(value));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(UintSet storage set, uint256 value) internal view returns (bool) {
        return _contains(set._inner, bytes32(value));
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function length(UintSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(UintSet storage set, uint256 index) internal view returns (uint256) {
        return uint256(_at(set._inner, index));
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function values(UintSet storage set) internal view returns (uint256[] memory) {
        bytes32[] memory store = _values(set._inner);
        uint256[] memory result;

        assembly {
            result := store
        }

        return result;
    }
}",2867
RealWorld_BA_49_OverlayV1Market_RealWord_20240820233309.log,49,OverlayV1Market,34422,5470,39892,129.0,0.28151,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""../libraries/Position.sol"";
import ""../libraries/FixedPoint.sol"";
import ""../interfaces/IOverlayV1Mothership.sol"";
import ""./OverlayV1Governance.sol"";
import ""./OverlayV1OI.sol"";
import ""./OverlayV1PricePoint.sol"";
import ""../OverlayToken.sol"";
import ""./OverlayV1Comptroller.sol"";

abstract contract OverlayV1Market is OverlayV1Governance {

    using FixedPoint for uint256;

    uint256 constant public MIN_COLLAT = 1e14;

    uint256 private unlocked = 1;

    modifier lock() { require(unlocked == 1, ""OVLV1:!unlocked""); unlocked = 0; _; unlocked = 1; }

    constructor(address _mothership) OverlayV1Governance( _mothership) { }

    /// @notice Adds open interest to the market
    /// @dev This is invoked by Overlay collateral manager contracts, which
    /// can be for OVL, ERC20's, Overlay positions, NFTs, or what have you.
    /// The calculations for impact and fees are performed here.
    /// @param _isLong The side of the market to enter open interest on.
    /// @param _collateral The amount of collateral in OVL terms to take the
    /// position out with.
    /// @param _leverage The leverage with which to take out the position.
    /// @return oiAdjusted_ Amount of open interest after impact and fees.
    /// @return collateralAdjusted_ Amount of collateral after impact and fees.
    /// @return debtAdjusted_ Amount of debt after impact and fees.
    /// @return fee_ The protocol fee to be taken.
    /// @return impact_ The market impact for the build.
    /// @return pricePointNext_ The index of the price point for the position.
    function enterOI (
        bool _isLong,
        uint _collateral,
        uint _leverage
    ) external onlyCollateral returns (
        uint oiAdjusted_,
        uint collateralAdjusted_,
        uint debtAdjusted_,
        uint fee_,
        uint impact_,
        uint pricePointNext_
    ) {

        uint _cap = update();

        pricePointNext_ = _pricePoints.length - 1;

        uint _oi = _collateral * _leverage;

        uint _impact = intake(_isLong, _oi, _cap);

        fee_ = _oi.mulDown(mothership.fee());

        impact_ = _impact;

        require(_collateral >= MIN_COLLAT + impact_ + fee_ , ""OVLV1:collat<min"");

        collateralAdjusted_ = _collateral - _impact - fee_;

        oiAdjusted_ = collateralAdjusted_ * _leverage;

        debtAdjusted_ = oiAdjusted_ - collateralAdjusted_;

        addOi(_isLong, oiAdjusted_, _cap);

    }


    /// @notice First part of the flow to remove OI from the system
    /// @dev This is called by the collateral managers to retrieve
    /// the necessary information to calculate the specifics of each position,
    /// for instance the PnL or if it is liquidatable. 
    /// @param _isLong Whether the data is being retrieved for a long or short.
    /// @param _pricePoint Index of the initial price point
    /// @param oi_ Total outstanding open interest on that side of the market.
    /// @param oiShares_ Total outstanding open interest shares on that side.
    /// @param priceFrame_ The price multiple comprised of the entry and exit
    /// prices for the position, with the exit price being the current one.
    /// Longs receive the bid on exit and the ask on entry shorts the opposite.
    function exitData (
        bool _isLong,
        uint256 _pricePoint
    ) public onlyCollateral returns (
        uint oi_,
        uint oiShares_,
        uint priceFrame_
    ) {

        update();

        if (_isLong) ( oi_ = __oiLong__, oiShares_ = oiLongShares );
        else ( oi_ = __oiShort__, oiShares_ = oiShortShares );

        priceFrame_ = priceFrame(_isLong, _pricePoint);

    }

    /// @notice Removes open interest from the market
    /// @dev Called as the second part of exiting oi, this function
    /// reports the open interest in OVL terms to remove as well as 
    /// open interest shares to remove. It also registers printing
    /// or burning of OVL in the process.
    /// @param _isLong The side from which to remove open interest.
    /// @param _oi The open interest to remove in OVL terms.
    /// @param _oiShares The open interest shares to remove.
    /// @param _brrrr How much was printed on closing the position.
    /// @param _antiBrrrr How much was burnt on closing the position.
    function exitOI (
        bool _isLong,
        uint _oi,
        uint _oiShares,
        uint _brrrr,
        uint _antiBrrrr
    ) external onlyCollateral {

        brrrr( _brrrr, _antiBrrrr );

        if (_isLong) ( __oiLong__ -= _oi, oiLongShares -= _oiShares );
        else ( __oiShort__ -= _oi, oiShortShares -= _oiShares );

    }

    /// @notice Internal update function to price, cap, and pay funding.
    /// @dev This function updates the market with the latest price and
    /// conditionally reads the depth of the market feed. The market needs
    /// an update on the first call of any block.
    /// @return cap_ The open interest cap for the market.
    function update () public virtual returns (
        uint cap_
    ) {

        uint _now = block.timestamp;
        uint _updated = updated;

        if (_now != _updated) {

            PricePoint memory _pricePoint = fetchPricePoint();

            setPricePointNext(_pricePoint);

            updated = _now;

        } 

        (   uint _compoundings,
            uint _tCompounding  ) = epochs(_now, compounded);

        if (0 < _compoundings) {

            payFunding(k, _compoundings);
            compounded = _tCompounding;

        }

        cap_ = oiCap();

    }

    /// @notice The depth of the market feed in OVL terms at the current block.
    /// @dev Returns the time weighted liquidity of the market feed in
    /// OVL terms at the current block.
    /// @return depth_ The time weighted liquidity in OVL terms.
    function depth () public view override returns (
        uint depth_
    ) {

        ( ,,depth_ )= pricePointCurrent();

    }

    /// @notice Exposes important info for calculating position metrics.
    /// @dev These values are required to feed to the position calculations.
    /// @param _isLong Whether position is on short or long side of market.
    /// @param _priceEntry Index of entry price
    /// @return oi_ The current open interest on the chosen side.
    /// @return oiShares_ The current open interest shares on the chosen side.
    /// @return priceFrame_ Price frame resulting from e entry and exit prices.
    function positionInfo (
        bool _isLong,
        uint _priceEntry
    ) external view returns (
        uint256 oi_,
        uint256 oiShares_,
        uint256 priceFrame_
    ) {

        (   uint _compoundings, ) = epochs(block.timestamp, compounded);

        (   uint _oiLong,
            uint _oiShort,
            uint _oiLongShares,
            uint _oiShortShares ) = _oi(_compoundings);

        if (_isLong) ( oi_ = _oiLong, oiShares_ = _oiLongShares );
        else ( oi_ = _oiShort, oiShares_ = _oiShortShares );

        priceFrame_ = priceFrame(
            _isLong,
            _priceEntry
        );

    }


    /// @notice Computes the price frame for a given position
    /// @dev Computes the price frame conditionally giving shorts the bid
    /// on entry and ask on exit and longs the bid on exit and short on
    /// entry. Capped at the priceFrameCap for longs.
    /// @param _isLong If price frame is for a long or a short.
    /// @param _pricePoint The index of the entry price.
    /// @return priceFrame_ The exit price divided by the entry price.
    function priceFrame (
        bool _isLong,
        uint _pricePoint
    ) internal view returns (
        uint256 priceFrame_
    ) {

        ( uint _entryBid, uint _entryAsk, ) = readPricePoint(_pricePoint);

        ( uint _exitBid, uint _exitAsk, ) = pricePointCurrent();

        priceFrame_ = _isLong
            ? Math.min(_exitBid.divDown(_entryAsk), priceFrameCap)
            : _exitAsk.divUp(_entryBid);

    }

}",1921
RealWorld_BA_49_LowGasSafeMath_RealWord_20240820224935.log,49,LowGasSafeMath,10751,4952,15703,110.0,0.152795,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.7.0;

/// @title Optimized overflow and underflow safe math operations
/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost
library LowGasSafeMath {
    /// @notice Returns x + y, reverts if sum overflows uint256
    /// @param x The augend
    /// @param y The addend
    /// @return z The sum of x and y
    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require((z = x + y) >= x);
    }

    /// @notice Returns x - y, reverts if underflows
    /// @param x The minuend
    /// @param y The subtrahend
    /// @return z The difference of x and y
    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require((z = x - y) <= x);
    }

    /// @notice Returns x * y, reverts if overflows
    /// @param x The multiplicand
    /// @param y The multiplier
    /// @return z The product of x and y
    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require(x == 0 || (z = x * y) / x == y);
    }

    /// @notice Returns x + y, reverts if overflows or underflows
    /// @param x The augend
    /// @param y The addend
    /// @return z The sum of x and y
    function add(int256 x, int256 y) internal pure returns (int256 z) {
        require((z = x + y) >= x == (y >= 0));
    }

    /// @notice Returns x - y, reverts if overflows or underflows
    /// @param x The minuend
    /// @param y The subtrahend
    /// @return z The difference of x and y
    function sub(int256 x, int256 y) internal pure returns (int256 z) {
        require((z = x - y) <= x == (y >= 0));
    }
}",492
RealWorld_BA_49_UniswapV3OracleLibrary_RealWord_20240820224537.log,49,UniswapV3OracleLibrary,15661,6052,21713,109.0,0.199345,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0 <=0.8.7;

import '../../interfaces/IUniswapV3Pool.sol';
import './TickMath.sol';
import './FullMath.sol';
import './LowGasSafeMath.sol';
import './PoolAddress.sol';

/// @title Oracle library
/// @notice Provides functions to integrate with V3 pool oracle
library OracleLibrary {
    /// @notice Fetches time-weighted average tick using Uniswap V3 oracle
    /// @param pool Address of Uniswap V3 pool that we want to observe
    /// @param period Number of seconds in the past to start calculating time-weighted average
    /// @return timeWeightedAverageTick The time-weighted average tick from (block.timestamp - period) to block.timestamp
    function consult(address pool, uint32 period, uint32 end) internal view returns (int24 timeWeightedAverageTick) {
        require(period != 0, 'BP');

        uint32[] memory secondAgos = new uint32[](2);
        secondAgos[0] = period;
        secondAgos[1] = 0;

        (int56[] memory tickCumulatives, ) = IUniswapV3Pool(pool).observe(secondAgos);
        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];

        timeWeightedAverageTick = int24(tickCumulativesDelta / int56(int32(period)));

        // Always round to negative infinity
        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(int32(period)) != 0)) timeWeightedAverageTick--;

    }

    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange
    /// @param tick Tick value used to calculate the quote
    /// @param baseAmount Amount of token to be converted
    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination
    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination
    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken
    function getQuoteAtTick(
        int24 tick,
        uint128 baseAmount,
        address baseToken,
        address quoteToken
    ) internal pure returns (uint256 quoteAmount) {
        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);

        // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself
        if (sqrtRatioX96 <= type(uint128).max) {
            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;
            quoteAmount = baseToken < quoteToken
                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)
                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);
        } else {
            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);
            quoteAmount = baseToken < quoteToken
                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)
                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);
        }
    }
}",714
RealWorld_BA_49_IOverlayV1OVLCollateral_RealWord_20240820235408.log,49,IOverlayV1OVLCollateral,14161,5611,19772,108.0,0.183025,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""../libraries/Position.sol"";
import ""@openzeppelin/contracts/token/ERC1155/IERC1155.sol"";
import ""./IOverlayV1Market.sol"";
import ""./IOverlayV1Mothership.sol"";
import ""./IOverlayToken.sol"";

interface IOverlayV1OVLCollateral is IERC1155 {

    event log(string k, uint v);
    event log(string k, address v);

    event Build(
        address market,
        uint256 positionId,
        uint256 oi,
        uint256 debt
    );
    event Unwind(
        address market,
        uint256 positionId,
        uint256 oi,
        uint256 debt
    );
    event Liquidate(
        uint256 positionId,
        uint256 oi,
        uint256 reward,
        address rewarded
    );
    event Update(
        address rewarded,
        uint rewardAmount,
        uint feesCollected,
        uint feesBurned,
        uint liquidationsCollected,
        uint liquidationsBurned
    );

    struct MarketInfo {
        uint marginMaintenance;
        uint marginRewardRate;
    }

    function totalSupply(uint256 positionId) external view returns (uint256 totalSupply);
    function marginAdjustments (address market) external view returns (uint256 marginAdjustment);
    function supportedMarket (address market) external view returns (bool supported);

    function currentBlockPositionsLong (
        address market,
        uint leverage
    ) external view returns (
        uint positionId
    );

    function currentBlockPositionsShort (
        address market,
        uint leverage
    ) external view returns (
        uint positionId
    );

    function positions (uint positionId) external view returns (Position.Info memory);
    function ovl () external view returns (IOverlayToken);
    function mothership () external view returns (IOverlayV1Mothership);
    function marketInfo(address) external view returns (MarketInfo memory);
    function fees () external view returns (uint);
    function liquidations () external view returns (uint);

    function setMarketInfo(
        address _market,
        uint _marginMaintenance,
        uint _marginRewardRate,
        uint _maxLeverage
    ) external;

    function marginMaintenance(
        address _market
    ) external view returns (
        uint marginMaintenance_
    );

    function marginRewardRate(
        address _market
    ) external view returns (
        uint marginRewardRate_
    );

    function maxLeverage(
        address _market
    ) external view returns (
        uint maxLeverage_
    );

    function addMarket (
        address _market,
        uint _marginAdjustment
    ) external;

    function disburse() external;

    function build(
        address _market,
        uint256 _collateral,
        uint256 _leverage,
        bool _isLong,
        uint256 _oiAdjustedMinimum
    ) external returns (
        uint positionId_
    );

    function unwind(
        uint256 _positionId,
        uint256 _shares
    ) external;

    function liquidate(
        uint256 _positionId,
        address _rewardsTo
    ) external;

    function value (
        uint _positionId
    ) external view returns (uint);

}",681
RealWorld_BA_49_UniswapV3FactoryMock_RealWord_20240820222738.log,49,UniswapV3FactoryMock,7067,5013,12080,140.0,0.135595,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""./UniswapV3OracleMock.sol"";

contract UniswapV3FactoryMock {

    mapping(address => bool) public isPool;
    address[] public allPools;

    function createPool (
        address _token0, 
        address _token1
    ) external returns (
        UniswapV3OracleMock pool
    ) {

        pool = new UniswapV3OracleMock(_token0, _token1);
        isPool[address(pool)] = true;
        allPools.push(address(pool));

    }

    function loadObservations(
        address pool,
        OracleMock.Observation[] calldata _observations,
        UniswapV3OracleMock.Shim[] calldata _shims
    ) external {
        require(isPool[pool], ""!pool"");
        UniswapV3OracleMock(pool).loadObservations(_observations, _shims);
    }
}",205
RealWorld_BA_49_IMirinFactory_RealWord_20240820234317.log,49,IMirinFactory,3532,3613,7145,79.0,0.08992,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IMirinFactory {
    function isPool(address) external view returns (bool);
}",35
RealWorld_BA_49_IOverlayToken_RealWord_20240820234848.log,49,IOverlayToken,6392,4510,10902,101.0,0.12216,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IOverlayToken {

    function burn(address account, uint256 amount) external;

    function mint(address account, uint256 amount) external;

    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount) external returns (bool);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function decimals() external view returns (uint);

    function symbol () external view returns (string memory);
    
    function name () external view returns (string memory);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);
}",206
RealWorld_BA_49_OverlayV1UniswapV3Market_RealWord_20240820221521.log,49,OverlayV1UniswapV3Market,27046,5822,32868,125.0,0.25167,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""./libraries/FixedPoint.sol"";
import ""./libraries/UniswapV3OracleLibrary/UniswapV3OracleLibraryV2.sol"";
import ""./interfaces/IUniswapV3Pool.sol"";
import ""./market/OverlayV1Market.sol"";
import ""./libraries/UniswapV3OracleLibrary/TickMath.sol"";

contract OverlayV1UniswapV3Market is OverlayV1Market {

    using FixedPoint for uint256;

    uint256 internal X96 = 0x1000000000000000000000000;

    uint256 public immutable macroWindow; // window size for main TWAP
    uint256 public immutable microWindow; // window size for bid/ask TWAP

    address public immutable marketFeed;
    address public immutable ovlFeed;
    address public immutable base;
    address public immutable quote;
    uint128 internal immutable baseAmount;

    address internal immutable eth;
    bool internal immutable ethIs0;

    constructor(
        address _mothership,
        address _ovlFeed,
        address _marketFeed,
        address _quote,
        address _eth,
        uint128 _baseAmount,
        uint256 _macroWindow,
        uint256 _microWindow,
        uint256 _priceFrameCap
    ) OverlayV1Market (
        _mothership
    ) OverlayV1Comptroller (
        _microWindow
    ) OverlayV1OI (
        _microWindow
    ) OverlayV1PricePoint (
        _priceFrameCap
    ) {

        // immutables
        eth = _eth;
        ethIs0 = IUniswapV3Pool(_ovlFeed).token0() == _eth;
        ovlFeed = _ovlFeed;
        marketFeed = _marketFeed;
        baseAmount = _baseAmount;
        macroWindow = _macroWindow;
        microWindow = _microWindow;

        address _token0 = IUniswapV3Pool(_marketFeed).token0();
        address _token1 = IUniswapV3Pool(_marketFeed).token1();

        base = _token0 != _quote ? _token0 : _token1;
        quote = _token0 == _quote ? _token0 : _token1;

        int24 _tick = OracleLibraryV2.consult(
            _marketFeed,
            uint32(_macroWindow),
            uint32(0)
        );

        _pricePoints.push(PricePoint(
            _tick, 
            _tick, 
            0
        ));

        uint _price = OracleLibraryV2.getQuoteAtTick(
            _tick,
            uint128(_baseAmount),
            _token0 != _quote ? _token0 : _token1,
            _token0 == _quote ? _token0 : _token1
        );

        emit NewPricePoint(_price, _price, 0);

    }


    /// @notice Reads the current price and depth information
    /// @dev Reads price and depth of market feed
    /// @return price_ Price point
    function fetchPricePoint () public view override returns (
        PricePoint memory price_
    ) {

        int56[] memory _ticks;
        uint160[] memory _liqs;

        uint _ovlPrice;
        uint _marketLiquidity;

        int24 _microTick;
        int24 _macroTick;

        {

            uint32[] memory _secondsAgo = new uint32[](3);
            _secondsAgo[2] = uint32(macroWindow);
            _secondsAgo[1] = uint32(microWindow);

            ( _ticks, _liqs ) = IUniswapV3Pool(marketFeed).observe(_secondsAgo);

            _macroTick = int24(( _ticks[0] - _ticks[2]) / int56(int32(int(macroWindow))));

            _microTick = int24((_ticks[0] - _ticks[1]) / int56(int32(int(microWindow))));

            uint _sqrtPrice = TickMath.getSqrtRatioAtTick(_microTick);

            uint _liquidity = (uint160(microWindow) << 128) / ( _liqs[0] - _liqs[1] );

            _marketLiquidity = ethIs0
                ? ( uint256(_liquidity) << 96 ) / _sqrtPrice
                : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96);

        }


        {

            uint32[] memory _secondsAgo = new uint32[](2);

            _secondsAgo[1] = uint32(macroWindow);

            ( _ticks, ) = IUniswapV3Pool(ovlFeed).observe(_secondsAgo);

            _ovlPrice = OracleLibraryV2.getQuoteAtTick(
                int24((_ticks[0] - _ticks[1]) / int56(int32(int(macroWindow)))),
                1e18,
                ovl,
                eth
            );

        }

        price_ = PricePoint(
            _microTick, 
            _macroTick, 
            computeDepth(_marketLiquidity, _ovlPrice)
        );

    }


    /// @notice Arithmetic to get depth
    /// @dev Derived from cnstant product formula X*Y=K and tailored 
    /// to Uniswap V3 selective liquidity provision.
    /// @param _marketLiquidity Amount of liquidity in market in ETH terms.
    /// @param _ovlPrice Price of OVL against ETH.
    /// @return depth_ Depth criteria for market in OVL terms.
    function computeDepth (
        uint _marketLiquidity,
        uint _ovlPrice
    ) public override view returns (
        uint depth_
    ) {

        depth_ = ((_marketLiquidity * 1e18) / _ovlPrice)
            .mulUp(lmbda)    
            .divDown(2e18);

    }

    function _tickToPrice (
        int24 _tick
    ) public override view returns (
        uint quote_
    ) {

        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(_tick);

        // better precision if no overflow when squared
        if (sqrtRatioX96 <= type(uint128).max) {

            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;

            quote_ = base < quote
                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)
                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);

        } else {

            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);

            quote_ = base < quote
                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)
                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);

        }

    }

}",1484
RealWorld_BA_49_IOverlayV1Market_RealWord_20240820235202.log,49,IOverlayV1Market,19691,5578,25269,123.0,0.210015,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@openzeppelin/contracts/token/ERC1155/IERC1155.sol"";
import ""../libraries/Position.sol"";

interface IOverlayV1Market is IERC1155 {

    event log(string k, uint v);

    struct PricePoint {
        uint256 bid;
        uint256 ask;
        uint256 index;
    }

    event NewPrice(uint bid, uint ask, uint index);
    event FundingPaid(uint oiLong, uint oiShort, int fundingPaid);

    function ovl () external view returns (address);
    function factory () external view returns (address);

    function feed () external view returns (address);
    function impactWindow () external view returns (uint256);
    function updated () external view returns (uint256);
    function update () external;
    function compounded () external view returns (uint256);
    function compoundingPeriod () external view returns (uint256);

    function leverageMax () external view returns (uint8);

    function k() external view returns (uint256);

    function oi () external view returns (
        uint oiLong_,
        uint oiShort_,
        uint oiLongShares_,
        uint oiShortShares_
    );

    function oiLong() external view returns (uint256);
    function oiShort() external view returns (uint256);
    function oiLongShares() external view returns (uint256);
    function oiShortShares() external view returns (uint256);

    function oiCap () external view returns (uint256);

    function brrrrd () external view returns (int256);
    function pressure (
        bool _isLong,
        uint _oi,
        uint _cap
    ) external view returns (uint256);
    function impact (
        bool _isLong,
        uint _oi,
        uint _cap
    ) external view returns (uint256);

    function pbnj () external view returns (uint256);
    function priceFrameCap() external view returns (int256);

    function lmbda() external view returns (uint256);

    function brrrrdExpected() external view returns (uint256);
    function brrrrdWindowMacro() external view returns (uint256);
    function brrrrdWindowMicro() external view returns (uint256);

    function getBrrrrd() external view returns (uint256);

    function epochs() external view returns (
        uint compoundings_,
        uint tCompounding_
    );

    function epochs(
        uint _now,
        uint _compounded
    ) external view returns (
        uint compoundings_,
        uint tCompounding_
    );

    function pricePointNextIndex() external view returns (uint256);

    function pricePoints (
        uint256 index
    ) external view returns (
        uint bid_,
        uint ask_,
        uint depth_
    );

    function MAX_FUNDING_COMPOUND() external view returns (uint16);

    function addCollateral (
        address _collateral
    ) external;

    function adjustParams (
        uint256 _compoundingPeriod,
        uint144 _oiCap,
        uint112 _fundingKNumerator,
        uint112 _fundingKDenominator,
        uint8 _leverageMax
    ) external;

    function enterOI (
        bool _isLong,
        uint _collateral,
        uint _leverage
    ) external returns (
        uint oiAdjusted_,
        uint collateralAdjusted_,
        uint debtAdjusted_,
        uint fee_,
        uint impact_,
        uint pricePointNext_
    );

    function exitData (
        bool _isLong,
        uint256 _pricePoint
    ) external returns (
        uint oi_,
        uint oiShares_,
        uint priceFrame_
    );

    function exitOI (
        bool _isLong,
        uint _oi,
        uint _oiShares,
        uint _brrrr,
        uint _antibrrrr
    ) external;

    function positionInfo (
        bool _isLong,
        uint _entryIndex
    ) external view returns (
        uint256 oi_,
        uint256 oiShares_,
        uint256 priceFrame_
    );

    function setEverything (
        uint256 _k,
        uint256 _pbnj,
        uint256 _compoundPeriod,
        uint256 _lmbda,
        uint256 _staticCap,
        uint256 _brrrrExpected,
        uint256 _brrrrWindowMacro,
        uint256 _brrrrWindowMicro
    ) external;

    function setK (
        uint256 _k
    ) external;

    function setSpread(
        uint256 _pbnj
    ) external;

    function setPeriods(
        uint256 _compoundingPeriod
    ) external;

    function setComptrollerParams (
        uint256 _lmbda,
        uint256 _staticCap,
        uint256 _brrrrExpected,
        uint256 _brrrrWindowMacro,
        uint256 _brrrrWindowMicro
    ) external;



}",1033
RealWorld_BA_49_MirinOracleMock_RealWord_20240820223638.log,49,MirinOracleMock,8803,4815,13618,99.0,0.140315,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""../interfaces/IMirinOracle.sol"";

contract MirinOracleMock is IMirinOracle {

    struct PricePoint {
        uint256 timestamp;
        uint256 price0Cumulative;
        uint256 price1Cumulative;
    }

    PricePoint[] public override pricePoints;

    constructor(
        uint256[] memory _timestamps,
        uint256[] memory _price0Cumulatives,
        uint256[] memory _price1Cumulatives
    ) {
        addPricePoints(_timestamps, _price0Cumulatives, _price1Cumulatives);
    }

    function token0() external override pure returns (address) {
        return address(0);
    }

    function token1() external override pure returns (address) {
        return address(0);
    }

    function addPricePoints(
        uint256[] memory _timestamps,
        uint256[] memory _price0Cumulatives,
        uint256[] memory _price1Cumulatives
    ) public {
        require(_timestamps.length == _price0Cumulatives.length && _price0Cumulatives.length == _price1Cumulatives.length, ""price point arrays must have same length"");
        for (uint256 i = 0; i < _timestamps.length; i++) {
            pricePoints.push(PricePoint(
                _timestamps[i],
                _price0Cumulatives[i],
                _price1Cumulatives[i]
            ));
        }
    }

    function pricePointsLength() external override view returns (uint256) {
        return pricePoints.length;
    }
}",338
RealWorld_BA_49_OverlayToken_RealWord_20240820230841.log,49,OverlayToken,45071,5308,50379,131.0,0.331515,"// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.3.2 (token/ERC20/ERC20.sol)

pragma solidity ^0.8.0;

import ""../interfaces/IOverlayTokenNew.sol"";
import ""./utils/AccessControlEnumerable.sol"";
import ""./utils/Context.sol"";


contract OverlayTokenNew is Context, IOverlayTokenNew, AccessControlEnumerable {

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    bytes32 public constant ADMIN_ROLE = 0x00;
    bytes32 public constant MINTER_ROLE = keccak256(""MINTER"");
    bytes32 public constant BURNER_ROLE = keccak256(""BURNER"");

    string constant public override name = ""Overlay Token"";
    string constant public override symbol = ""OVL"";
    uint256 constant public override decimals = 18;

    uint256 private _totalSupply;

    constructor() {

        _setupRole(ADMIN_ROLE, msg.sender);
        _setupRole(MINTER_ROLE, msg.sender);
        _setupRole(BURNER_ROLE, msg.sender);
        _setRoleAdmin(MINTER_ROLE, ADMIN_ROLE);
        _setRoleAdmin(BURNER_ROLE, ADMIN_ROLE);

    }

    modifier onlyMinter() {
        require(hasRole(MINTER_ROLE, msg.sender), ""OVL:!minter"");
        _;
    }

    modifier onlyBurner() {
        require(hasRole(BURNER_ROLE, msg.sender), ""OVL:!burner"");
        _;
    }


    /// @dev Get the current total supply of OVL.
    /// @return totalSupply_ The outstanding supply of OVL tokens.
    function totalSupply() public view virtual override returns (
        uint256 totalSupply_
    ) {
        totalSupply_ = _totalSupply;
    }

    /// @dev Get OVL balance of a given account.
    /// @param account Account to find the OVL balance of.
    /// @return balance_ The account's balance of OVL.
    function balanceOf(
        address account
    ) public view virtual override returns (
        uint256 balance_
    ) {

        balance_ = _balances[account];

    }


    /// @dev Transfer amount of tokens from msg.sender to recipient
    /// @param recipient Can not be the zero address.
    /// @param amount Msg.sender must have at least this amount in tokens.
    /// @return success_ Returns success == true when call does not revert.
    function transfer(
        address recipient, 
        uint256 amount
    ) public virtual override returns (
        bool success_
    ) {

        _transfer(_msgSender(), recipient, amount);

        success_ = true;

    }


    /// @dev Returns allowance on one account for another account.
    /// @param owner Account to allow another to spend its tokens.
    /// @param spender Account allowed to spend the tokens of another.
    /// @return allowance_ Amount of tokens owner allows spender to control.
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }


    /// @dev Allows one account to approve another to spend from its balance. 
    /// @param spender Account to allow to spend from msg.sender's balance.
    /// @param amount Amount to allow spending of.
    /// @return success_ Returns success == true if call does not revert.
    function approve(
        address spender, 
        uint256 amount
    ) public virtual override returns (
        bool success_
    ) {

        _approve(_msgSender(), spender, amount);

        success_ = true;

    }

    /// @dev Transfers tokens from sender to recipient if sender has allowance.
    /// @param sender Address of account from which to send tokens.
    /// @param recipient Address of account to receive tokens.
    /// @param amount Amount of tokens to send.
    /// @param success_ Returns success == true if call does not revert.
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override returns (
        bool success_
    ) {

        _transfer(sender, recipient, amount);

        uint256 currentAllowance = _allowances[sender][_msgSender()];

        require(currentAllowance >= amount, ""ERC20: transfer amount exceeds allowance"");

        unchecked { _approve(sender, _msgSender(), currentAllowance - amount); }

        success_ = true;

    }


    /// @dev Allows msg.sender to simultaneously send and burn tokens.
    /// @param recipient Account to send tokens to.
    /// @param amount Amount of tokens to send.
    /// @param burnt Amount of tokens to burn from msg.sender.
    /// @return success_ Returns success == true if call does not revert.
    function transferBurn(
        address recipient,
        uint256 amount,
        uint256 burnt
    ) public override onlyBurner returns (
        bool
    ) {

        _transferBurn(msg.sender, recipient, amount, burnt);

        return true;

    }


    /// @dev Allows msg.sender to simultaneously send and burn tokens 
    /// from sender according to allowance granted.
    /// @param sender Address from which to transfer tokens.
    /// @param recipient Address to trasnfer tokens into.
    /// @param amount Amount of tokens to send.
    /// @param burnt Amount of tokens to burn.
    /// @return success Returns true if call does not revert.
    function transferFromBurn(
        address sender,
        address recipient,
        uint256 amount,
        uint256 burnt
    ) public override onlyBurner returns (
        bool success
    ) {

        _transferBurn(sender, recipient, amount, burnt);

        uint256 currentAllowance = _allowances[sender][msg.sender];

        require(currentAllowance >= amount + burnt, ""OVL:allowance<amount+burnt"");

        unchecked { _approve(sender, msg.sender, currentAllowance - amount - burnt); }

        success = true;

    }
    

    /// @dev Internal function to transfer and burn OVL simultaneously.
    /// @param sender Address to send and burn from.
    /// @param recipient Address to send to.
    /// @param amount Amount to send.
    /// @param burnt Amount to burn.
    function _transferBurn(
        address sender,
        address recipient,
        uint256 amount,
        uint256 burnt
    ) internal {

        uint256 senderBalance = _balances[sender];

        require(senderBalance >= amount + burnt, ""OVL:balance<amount+burnt"");

        unchecked { _balances[sender] = senderBalance - amount - burnt; }

        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);
        emit Transfer(sender, address(0), burnt);

    }

    /// @dev Allows msg.sender to simultaneously transfer tokens and mint 
    /// to the recipient.
    /// @param recipient Account to transfer and mint tokens to.
    /// @param amount Amount of tokens to transfer.
    /// @param minted Amount of tokens to mint.
    /// @return success Returns true if call does not revert.
    function transferMint(
        address recipient,
        uint256 amount,
        uint256 minted
    ) public override onlyMinter returns (
        bool success
    ) {

        _transferMint(msg.sender, recipient, amount, minted);

        success = true;

    }

    /// @dev Allows msg.sender to simultaneously transfer from sender 
    /// according to its granted allowance and mint to recipient.
    /// @param sender Account to transfer tokens from.
    /// @param recipient Account to transfer tokens and mint to.
    /// @param amount Amount of tokens to transfer.
    /// @param minted Amount of tokens to mint.
    /// @return success Returns true if call does not revert.
    function transferFromMint(
        address sender,
        address recipient,
        uint256 amount,
        uint256 minted
    ) public override onlyMinter returns (
        bool
    ) {

        _transferMint(sender, recipient, amount, minted);

        uint256 currentAllowance = _allowances[sender][msg.sender];

        require(currentAllowance >= amount, ""OVL:allowance<amount"");

        unchecked { _approve(sender, msg.sender, currentAllowance - amount); }

        return true;

    }

    /// @dev Internal function taking care of transfering from sender 
    /// to recipient and minting at recipient.
    /// @param sender Account to transfer tokens from.
    /// @param recipient Account to transfer tokens to and mint at.
    /// @param amount Amount of tokens to transfer.
    /// @param minted Amount of tokens to mint.
    function _transferMint(
        address sender,
        address recipient,
        uint256 amount,
        uint256 minted
    ) internal {

        uint256 senderBalance = _balances[sender];

        require(senderBalance >= amount, ""ERC20: transfer amount exceeds balance"");

        unchecked { _balances[sender] = senderBalance - amount; }

        _balances[recipient] += amount + minted;

        emit Transfer(sender, recipient, amount);
        emit Transfer(address(0), recipient, minted);

    }

    function increaseAllowance(
        address spender, 
        uint256 addedValue
    ) public virtual returns (
        bool success
    ) {

        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);

        success = true;

    }

    function decreaseAllowance(
        address spender, 
        uint256 subtractedValue
    ) public virtual returns (
        bool success
    ) {

        uint256 currentAllowance = _allowances[_msgSender()][spender];

        require(currentAllowance >= subtractedValue, ""ERC20: decreased allowance below zero"");

        unchecked { _approve(_msgSender(), spender, currentAllowance - subtractedValue); }

        success = true;
    }

    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _beforeTokenTransfer(sender, recipient, amount);

        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""ERC20: transfer amount exceeds balance"");
        unchecked {
            _balances[sender] = senderBalance - amount;
        }
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);

        _afterTokenTransfer(sender, recipient, amount);
    }


    function mint(
        address _recipient, 
        uint256 _amount
    ) external override onlyMinter {

        _mint(_recipient, _amount);

    }

    function _mint(
        address account, 
        uint256 amount
    ) internal virtual {

        require(account != address(0), ""ERC20: mint to the zero address"");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);

        _afterTokenTransfer(address(0), account, amount);

    }

    function burn(
        address _account, 
        uint256 _amount
    ) external override onlyBurner {

        _burn(_account, _amount);

    }


    function _burn(
        address account, 
        uint256 amount
    ) internal virtual {

        require(account != address(0), ""ERC20: burn from the zero address"");

        _beforeTokenTransfer(account, address(0), amount);

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, ""ERC20: burn amount exceeds balance"");
        unchecked {
            _balances[account] = accountBalance - amount;
        }
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);

        _afterTokenTransfer(account, address(0), amount);
    }

    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {

        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);

    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}

}",2629
RealWorld_BA_49_OverlayV1OI_RealWord_20240820233520.log,49,OverlayV1OI,34400,5492,39892,116.0,0.28184,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""../libraries/FixedPoint.sol"";

contract OverlayV1OI {

    event log(string k , uint v);

    using FixedPoint for uint256;

    uint256 private constant ONE = 1e18;

    uint256 public compoundingPeriod;
    uint256 public compounded;

    uint256 internal __oiLong__; // total long open interest
    uint256 internal __oiShort__; // total short open interest

    uint256 public oiLongShares; // total shares of long open interest outstanding
    uint256 public oiShortShares; // total shares of short open interest outstanding

    uint256 public k;

    event FundingPaid(uint oiLong, uint oiShort, int fundingPaid);

    constructor (
        uint256 _compoundingPeriod
    ) {

        compoundingPeriod = _compoundingPeriod;

        compounded = block.timestamp;

    }

    /// @notice The compounding information for computing funding.
    /// @dev This returns the number of compoundings that have passed since
    /// the last time funding was paid as well as the timestamp of the
    /// current compounding epoch, which come at regular intervals according
    /// to the compounding period.
    /// @param _now The timestamp of the current block.
    /// @param _compounded The last time compounding occurred.
    /// @return compoundings_ The number of compounding periods passed since
    /// the last time funding was compounded.
    /// @return tCompounding_ The current compounding epoch.
    function epochs (
        uint _now,
        uint _compounded
    ) public view returns (
        uint compoundings_,
        uint tCompounding_
    ) {

        uint _compoundPeriod = compoundingPeriod;

        compoundings_ = ( _now - _compounded ) / _compoundPeriod;

        tCompounding_ = _compounded + ( compoundings_ * _compoundPeriod );

    }


    /// @notice Internal utility to pay funding from heavier to ligher side.
    /// @dev Pure function accepting current open interest, compoundings
    /// to perform, and funding constant.
    /// @dev oiImbalance(period_m) = oiImbalance(period_now) * (1 - 2k) ** period_m
    /// @param _oiLong Current open interest on the long side.
    /// @param _oiShort Current open interest on the short side.
    /// @param _epochs The number of compounding periods to compute for.
    /// @param _k The funding constant.
    /// @return oiLong_ Open interest on the long side after funding is paid.
    /// @return oiShort_ Open interest on the short side after funding is paid.
    /// @return fundingPaid_ Signed integer of funding paid, negative if longs
    /// are paying shorts.
    function computeFunding (
        uint256 _oiLong,
        uint256 _oiShort,
        uint256 _epochs,
        uint256 _k
    ) internal pure returns (
        uint256 oiLong_,
        uint256 oiShort_,
        int256  fundingPaid_
    ) {

        if (_oiLong == 0 && 0 == _oiShort) return (0, 0, 0);

        if (0 == _epochs) return ( _oiLong, _oiShort, 0 );

        uint _fundingFactor = ONE.sub(_k.mulUp(ONE*2));

        _fundingFactor = _fundingFactor.powUp(ONE*_epochs);

        uint _funder = _oiLong;
        uint _funded = _oiShort;
        bool payingLongs = _funder <= _funded;
        if (payingLongs) (_funder, _funded) = (_funded, _funder);

        if (_funded == 0) {

            uint _oiNow = _fundingFactor.mulDown(_funder);
            fundingPaid_ = int(_funder - _oiNow);
            _funder = _oiNow;

        } else {

            // TODO: we can make an unsafe mul function here
            uint256 _oiImbNow = _fundingFactor.mulDown(_funder - _funded);
            uint256 _total = _funder + _funded;

            fundingPaid_ = int( ( _funder - _funded ) / 2 );
            _funder = ( _total + _oiImbNow ) / 2;
            _funded = ( _total - _oiImbNow ) / 2;

        }

        ( oiLong_, oiShort_, fundingPaid_) = payingLongs
            ? ( _funded, _funder, fundingPaid_ )
            : ( _funder, _funded, -fundingPaid_ );

    }


    /// @notice Pays funding.
    /// @dev Invokes internal computeFunding and sets oiLong and oiShort.
    /// @param _k The funding constant.
    /// @param _epochs The number of compounding periods to compute.
    /// @return fundingPaid_ Signed integer of how much funding was paid.
    function payFunding (
        uint256 _k,
        uint256 _epochs
    ) internal returns (
        int256 fundingPaid_
    ) {

        uint _oiLong;
        uint _oiShort;

        ( _oiLong, _oiShort, fundingPaid_ ) = computeFunding(
            __oiLong__,
            __oiShort__,
            _epochs,
            _k
        );

        __oiLong__ = _oiLong;
        __oiShort__ = _oiShort;

        emit FundingPaid(_oiLong, _oiShort, fundingPaid_);

    }

    /// @notice Adds open interest to one side
    /// @dev Adds open interest to one side, asserting the cap is not breached.
    /// @param _isLong If open interest is adding to the long or short side.
    /// @param _openInterest Open interest to add.
    /// @param _oiCap Open interest cap to require not to be breached.
    function addOi(
        bool _isLong,
        uint256 _openInterest,
        uint256 _oiCap
    ) internal {

        if (_isLong) {

            oiLongShares += _openInterest;

            uint _oiLong = __oiLong__ + _openInterest;

            require(_oiLong <= _oiCap, ""OVLV1:>cap"");

            __oiLong__ = _oiLong;

        } else {

            oiShortShares += _openInterest;

            uint _oiShort = __oiShort__ + _openInterest;

            require(_oiShort <= _oiCap, ""OVLV1:>cap"");

            __oiShort__ = _oiShort;

        }

    }

    /// @notice Internal function to retrieve up to date open interest.
    /// @dev Computes the current open interest values and returns them.
    /// @param _compoundings Number of compoundings yet to be paid in funding.
    /// @return oiLong_ Current open interest on the long side.
    /// @return oiShort_ Current open interest on the short side.
    /// @return oiLongShares_ Current open interest shares on the long side.
    /// @return oiShortShares_ Current open interest shares on the short side.
    function _oi (
        uint _compoundings
    ) internal view returns (
        uint oiLong_,
        uint oiShort_,
        uint oiLongShares_,
        uint oiShortShares_
    ) {

        oiLong_ = __oiLong__;
        oiShort_ = __oiShort__;
        oiLongShares_ = oiLongShares;
        oiShortShares_ = oiShortShares;

        if (0 < _compoundings) {

            ( oiLong_, oiShort_, ) = computeFunding(
                oiLong_,
                oiShort_,
                _compoundings,
                k
            );

        }

    }

    /// @notice The current open interest on both sides of the market.
    /// @dev Returns all up to date open interest data for the market.
    /// @return oiLong_ Current open interest on long side.
    /// @return oiShort_ Current open interest on short side.
    /// @return oiLongShares_ Current open interest shares on the long side.
    /// @return oiShortShares_ Current open interest shares on the short side.
    function oi () public view returns (
        uint oiLong_,
        uint oiShort_,
        uint oiLongShares_,
        uint oiShortShares_
    ) {

        ( uint _compoundings, ) = epochs(block.timestamp, compounded);

        (   oiLong_,
            oiShort_,
            oiLongShares_,
            oiShortShares_ ) = _oi(_compoundings);

    }


    /// @notice The current open interest on the long side.
    /// @return oiLong_ The current open interest on the long side.
    function oiLong () external view returns (uint oiLong_) {
        (   oiLong_,,, ) = oi();
    }


    /// @notice The current open interest on the short side.
    /// @return oiShort_ The current open interest on the short side.
    function oiShort () external view returns (uint oiShort_) {
        (  ,oiShort_,, ) = oi();
    }

}",1936
RealWorld_BA_49_OverlayV1PricePoint_RealWord_20240820232644.log,49,OverlayV1PricePoint,19232,5642,24874,136.0,0.209,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@openzeppelin/contracts/utils/math/Math.sol"";
import ""../libraries/FixedPoint.sol"";

abstract contract OverlayV1PricePoint {

    using FixedPoint for uint256;

    uint256 private constant E = 0x25B946EBC0B36351;
    uint256 private constant INVERSE_E = 0x51AF86713316A9A;

    struct PricePoint {
        int24 macroTick;
        int24 microTick;
        uint256 depth;
    }

    uint256 public pbnj;

    uint256 public updated;

    uint256 immutable public priceFrameCap;

    // mapping from price point index to realized historical prices
    PricePoint[] internal _pricePoints;

    event NewPricePoint(uint bid, uint ask, uint depth);

    constructor(
        uint256 _priceFrameCap
    ) {

        require(1e18 <= _priceFrameCap, ""OVLV1:!priceFrame"");

        priceFrameCap = _priceFrameCap;

        updated = block.timestamp;


    }

    function fetchPricePoint () public view virtual returns (PricePoint memory);

    function _tickToPrice (int24 _tick) public virtual view returns (uint quote_);


    /// @notice Get the index of the next price to be realized
    /// @dev Returns the index of the _next_ price
    /// @return nextIndex_ The length of the price point array
    function pricePointNextIndex() public view returns (
        uint nextIndex_
    ) {

        nextIndex_ = _pricePoints.length;

    }


    /// @notice All past price points.
    /// @dev Returns the price point if it exists.
    /// @param _pricePointIndex Index of the price point being queried.
    /// @return bid_ Bid.
    /// @return ask_ Ask.
    /// @return depth_ Market liquidity in OVL terms.
    function pricePoints(
        uint256 _pricePointIndex
    ) external view returns (
        uint256 bid_,
        uint256 ask_,
        uint256 depth_
    ) {

        uint _len = _pricePoints.length;

        require(_pricePointIndex <  _len ||
               (_pricePointIndex == _len && updated != block.timestamp),
               ""OVLV1:!price"");

        if (_pricePointIndex == _len) {

            ( bid_, ask_, depth_ ) = readPricePoint(fetchPricePoint());

        } else {

            ( bid_, ask_, depth_ ) = readPricePoint(_pricePointIndex);

        }

    }


    /// @notice Current price point.
    /// @dev Returns the price point if it exists.
    /// @return bid_ Bid.
    /// @return ask_ Ask.
    /// @return depth_ Market liquidity in OVL terms.
    function pricePointCurrent () public view returns (
        uint bid_,
        uint ask_,
        uint depth_
    ){

        uint _now = block.timestamp;
        uint _updated = updated;

        if (_now != _updated) {

            ( bid_, ask_, depth_ ) = readPricePoint(fetchPricePoint());

        } else {

            ( bid_, ask_, depth_ ) = readPricePoint(_pricePoints.length - 1);

        }

    }

    /// @notice Allows inheriting contracts to add the latest realized price
    function setPricePointNext(
        PricePoint memory _pricePoint
    ) internal {

        _pricePoints.push(_pricePoint);

        (   uint _bid, 
            uint _ask,  
            uint _depth ) = readPricePoint(_pricePoint);

        emit NewPricePoint(
            _bid, 
            _ask, 
            _depth
        );

    }

    function readPricePoint (
        uint _pricePoint
    ) public view returns (
        uint256 bid_,
        uint256 ask_,
        uint256 depth_
    ) {

        return readPricePoint(_pricePoints[_pricePoint]);

    }

    function readPricePoint(
        PricePoint memory _pricePoint
    ) public view returns (
        uint256 bid_,
        uint256 ask_,
        uint256 depth_
    ) {

        uint _microPrice = _tickToPrice(_pricePoint.microTick);

        uint _macroPrice = _tickToPrice(_pricePoint.macroTick);

        uint _spread = pbnj;

        ask_ = Math.max(_macroPrice, _microPrice).mulUp(E.powUp(_spread));

        bid_ = Math.min(_macroPrice, _microPrice).mulDown(INVERSE_E.powUp(_spread));

        depth_ = _pricePoint.depth;


    }


}",965
RealWorld_BA_49_Context_RealWord_20240820231822.log,49,Context,5972,3684,9656,87.0,0.10354,"// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.3.2 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}",181
RealWorld_BA_51_MockERC20_RealWord_20240821020443.log,51,MockERC20,7567,5289,12856,84.0,0.143615,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title Generic ERC20 token
 * @notice This contract simulates a generic ERC20 token that is mintable and burnable.
 */
contract MockERC20 is ERC20, Ownable {
    /**
     * @notice Deploy this contract with given name, symbol, and decimals
     * @dev the caller of this constructor will become the owner of this contract
     * @param name_ name of this token
     * @param symbol_ symbol of this token
     */
    constructor(
        string memory name_,
        string memory symbol_
    ) ERC20(name_, symbol_) {
    }

    /**
     * @notice Mints given amount of tokens to recipient
     * @dev only owner can call this mint function
     * @param recipient address of account to receive the tokens
     * @param amount amount of tokens to mint
     */
    function mint(address recipient, uint256 amount) external onlyOwner {
        require(amount != 0, ""amount == 0"");
        _mint(recipient, amount);
    }
}",260
RealWorld_BA_51_IERC20_RealWord_20240821020754.log,51,IERC20,14241,5046,19287,121.0,0.172125,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev mint  `tokens` for user.
     *
     * Requirements:
     *
     * - The `owner` is only caller.
     *
     * Emits an {} event.
     */
    function _mint(address account, uint256 amount) external;

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",675
RealWorld_BA_51_LPToken_RealWord_20240821014230.log,51,LPToken,17355,5552,22907,95.0,0.197815,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./interfaces/ISwap.sol"";

/**
 * @title Liquidity Provider Token
 * @notice This token is an ERC20 detailed token with added capability to be minted by the owner.
 * It is used to represent user's shares when providing liquidity to swap contracts.
 */
contract LPToken is ERC20Burnable, Ownable {
    using SafeMath for uint256;

    // Address of the swap contract that owns this LP token. When a user adds liquidity to the swap contract,
    // they receive a proportionate amount of this LPToken.
    ISwap public swap;

    // Maps user account to total number of LPToken minted by them. Used to limit minting during guarded release phase
    mapping(address => uint256) public mintedAmounts;

    /**
     * @notice Deploys LPToken contract with given name, symbol, and decimals
     * @dev the caller of this constructor will become the owner of this contract
     * @param name_ name of this token
     * @param symbol_ symbol of this token
     * @param decimals_ number of decimals this token will be based on
     */
    constructor(
        string memory name_,
        string memory symbol_,
        uint8 decimals_
    ) public ERC20(name_, symbol_) {
        _setupDecimals(decimals_);
        swap = ISwap(_msgSender());
    }

    /**
     * @notice Mints the given amount of LPToken to the recipient. During the guarded release phase, the total supply
     * and the maximum number of the tokens that a single account can mint are limited.
     * @dev only owner can call this mint function
     * @param recipient address of account to receive the tokens
     * @param amount amount of tokens to mint
     */
    function mint(
        address recipient,
        uint256 amount
    ) external onlyOwner {
        require(amount != 0, ""amount == 0"");

        // If the pool is in the guarded launch phase, the following checks are done to restrict deposits.
        //   1. Check if the given merkleProof corresponds to the recipient's address in the merkle tree stored in the
        //      allowlist contract. If the account has been already verified, merkleProof is ignored.
        //   2. Limit the total number of this LPToken minted to recipient as defined by the allowlist contract.
        //   3. Limit the total supply of this LPToken as defined by the allowlist contract.
        // if (swap.isGuarded()) {
        //     // IAllowlist allowlist = swap.getAllowlist();
        //     // require(
        //     //     allowlist.verifyAddress(recipient, merkleProof),
        //     //     ""Invalid merkle proof""
        //     // );
        //     uint256 totalMinted = mintedAmounts[recipient].add(amount);
        //     require(
        //         totalMinted <= allowlist.getPoolAccountLimit(address(swap)),
        //         ""account deposit limit""
        //     );
        //     require(
        //         totalSupply().add(amount) <=
        //             allowlist.getPoolCap(address(swap)),
        //         ""pool total supply limit""
        //     );
        //     mintedAmounts[recipient] = totalMinted;
        // }
        uint256 totalMinted = mintedAmounts[recipient].add(amount);
        mintedAmounts[recipient] = totalMinted;
        _mint(recipient, amount);
    }

    /**
     * @dev Overrides ERC20._beforeTokenTransfer() which get called on every transfers including
     * minting and burning. This ensures that swap.updateUserWithdrawFees are called everytime.
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override(ERC20) {
        super._beforeTokenTransfer(from, to, amount);
        swap.updateUserWithdrawFee(to, amount);
    }
}",900
RealWorld_BA_51_MockVesting_RealWord_20240821020609.log,51,MockVesting,5201,5257,10458,103.0,0.131145,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @title Generic ERC20 token
 * @notice This contract simulates a generic ERC20 token that is mintable and burnable.
 */
contract MockVesting {
    function vest(address _beneficiary, uint256 _amount, uint256 _isRevocable) external payable {
    }
}",78
RealWorld_BA_51_USDPoolDelegator_RealWord_20240821013625.log,51,USDPoolDelegator,19656,5673,25329,104.0,0.21174,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.8;
pragma experimental ABIEncoderV2;

/// @title USD Pool Delegator
/// @author John Deere
/// @notice USD Liquidity Pool that delegate calls Curve Pool.
/// @dev Storage is local, execution takes place as fallback via delegate call.

contract USDPoolDelegator {

    // _coins The addresses of coins in the pool
    // _balances The balances of above coins in the pool
    // fee Base swap fee of pool
    // admin_fee Percentage of base swap fee collected by DAO as admin fee
    // max_admin_fee Max admin fee permitted for this pool
    // owner The owner of the contract
    // token LP token for this pool
    // initial_A The initial A invariant
    // future_A The future A invariant
    // initial_A_time The number of rings from dendrochronological sample
    // future_A_time The number of rings from dendrochronological sample
    // admin_actions_deadline The deadline before pending changes have to be executed
    // transfer_ownership_deadline The deadline before pending ownership transfer has to be executed
    // future_fee The swap fee that would be set in the future
    // future_admin_fee The admin fee that would be set in the future
    // future_owner The owner in the future pending ownership transfer
    // kill_deadline The timestamp until which the pool can be killed
    // kill_deadline_dt Used to set kill_deadline
    // is_killed Is the contract killled? Only withdrawals permitted.

    address[] public _coins;
    address[] public _underlying_coins;
    uint256[] public _balances;
    uint256 public A;
    uint256 public fee;
    uint256 public admin_fee;
    uint256 constant max_admin_fee = 5 * 10 ** 9;
    address public owner;
    address token;
    uint256 public admin_actions_deadline;
    uint256 public transfer_ownership_deadline;
    uint256 public future_A;
    uint256 public future_fee;
    uint256 public future_admin_fee;
    address public future_owner;
    
    uint256 kill_deadline;
    uint256 constant kill_deadline_dt = 2 * 30 * 86400;
    bool is_killed;
    
    constructor(address[4] memory _coinsIn, address[4] memory _underlying_coinsIn, address _pool_token, uint256 _A, uint256 _fee) public {
        for (uint i = 0; i < 4; i++) {
            require(_coinsIn[i] != address(0));
            require(_underlying_coinsIn[i] != address(0));
            _balances.push(0);
            _coins.push(_coinsIn[i]);
            _underlying_coins.push(_underlying_coinsIn[i]);
        }
        A = _A;
        fee = _fee;
        admin_fee = 0;
        owner = msg.sender;
        kill_deadline = block.timestamp + kill_deadline_dt;
        is_killed = false;
        token = _pool_token;
    }
    
    //Returns balances of a certain coin selected by index
    function balances(int128 i) public view returns (uint256) {
        return _balances[uint256(i)];
    }
    
    //Returns address of the coin
    function coins(int128 i) public view returns (address) {
        return _coins[uint256(i)];
    }
    
    //Returns address of the underlying coin
    function underlying_coins(int128 i) public view returns (address) {
        return _underlying_coins[uint256(i)];
    }

    fallback() external payable {
        address _target = 0xA5407eAE9Ba41422680e2e00537571bcC53efBfD; //Curve Contract on ETH Mainnet to be Delegate Called

        assembly {
            let _calldataMemOffset := mload(0x40)
            let _callDataSZ := calldatasize()
            let _size := and(add(_callDataSZ, 0x1f), not(0x1f))
            mstore(0x40, add(_calldataMemOffset, _size))
            calldatacopy(_calldataMemOffset, 0x0, _callDataSZ)
            let _retval := delegatecall(gas(), _target, _calldataMemOffset, _callDataSZ, 0, 0)
            switch _retval
            case 0 {
                revert(0,0)
            } default {
                let _returndataMemoryOff := mload(0x40)
                mstore(0x40, add(_returndataMemoryOff, returndatasize()))
                returndatacopy(_returndataMemoryOff, 0x0, returndatasize())
                return(_returndataMemoryOff, returndatasize())
            }
        }
    }
}",1040
RealWorld_BA_51_GenericERC20_RealWord_20240821014821.log,51,GenericERC20,7506,4707,12213,91.0,0.13167,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/**
 * @title Generic ERC20 token
 * @notice This contract simulates a generic ERC20 token that is mintable and burnable.
 */
contract GenericERC20 is ERC20, Ownable {
    /**
     * @notice Deploy this contract with given name, symbol, and decimals
     * @dev the caller of this constructor will become the owner of this contract
     * @param name_ name of this token
     * @param symbol_ symbol of this token
     * @param decimals_ number of decimals this token will be based on
     */
    constructor(
        string memory name_,
        string memory symbol_,
        uint8 decimals_
    ) public ERC20(name_, symbol_) {
        _setupDecimals(decimals_);
    }

    /**
     * @notice Mints given amount of tokens to recipient
     * @dev only owner can call this mint function
     * @param recipient address of account to receive the tokens
     * @param amount amount of tokens to mint
     */
    function mint(address recipient, uint256 amount) external onlyOwner {
        require(amount != 0, ""amount == 0"");
        _mint(recipient, amount);
    }
}",290
RealWorld_BA_51_IERC721_RealWord_20240821020956.log,51,IERC721,20733,4847,25580,109.0,0.200605,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./utils/IERC165.sol"";

/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721 is IERC165 {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId) external view returns (address operator);

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool _approved) external;

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);

    /**
      * @dev Safely transfers `tokenId` token from `from` to `to`.
      *
      * Requirements:
      *
      * - `from` cannot be the zero address.
      * - `to` cannot be the zero address.
      * - `tokenId` token must exist and be owned by `from`.
      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
      *
      * Emits a {Transfer} event.
      */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
}",1088
RealWorld_BA_51_ISwap_RealWord_20240821015144.log,51,ISwap,12249,5741,17990,98.0,0.176065,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
// import ""./IAllowlist.sol"";

interface ISwap {
    // pool data view functions
    function getA() external view returns (uint256);

    function getA2() external view returns (uint256);

    // function getAllowlist() external view returns (IAllowlist);

    function getToken(uint8 index) external view returns (IERC20);

    function getTokenIndex(address tokenAddress) external view returns (uint8);

    function getTokenBalance(uint8 index) external view returns (uint256);

    function getVirtualPrice() external view returns (uint256);

    function isGuarded() external view returns (bool);

    // min return calculation functions
    function calculateSwap(
        uint8 tokenIndexFrom,
        uint8 tokenIndexTo,
        uint256 dx
    ) external view returns (uint256);

    function calculateTokenAmount(uint256[] calldata amounts, bool deposit)
        external
        view
        returns (uint256);

    function calculateRemoveLiquidity(uint256 amount)
        external
        view
        returns (uint256[] memory);

    function calculateRemoveLiquidityOneToken(
        uint256 tokenAmount,
        uint8 tokenIndex
    ) external view returns (uint256 availableTokenAmount);

    // state modifying functions
    function swap(
        uint8 tokenIndexFrom,
        uint8 tokenIndexTo,
        uint256 dx,
        uint256 minDy,
        uint256 deadline
    ) external returns (uint256);

    function addLiquidity(
        uint256[] calldata amounts,
        uint256 minToMint,
        uint256 deadline
        // bytes32[] calldata merkleProof
    ) external returns (uint256);

    function removeLiquidity(
        uint256 amount,
        uint256[] calldata minAmounts,
        uint256 deadline
    ) external returns (uint256[] memory);

    function removeLiquidityOneToken(
        uint256 tokenAmount,
        uint8 tokenIndex,
        uint256 minAmount,
        uint256 deadline
    ) external returns (uint256);

    function removeLiquidityImbalance(
        uint256[] calldata amounts,
        uint256 maxBurnAmount,
        uint256 deadline
    ) external returns (uint256);

    // withdraw fee update function
    function updateUserWithdrawFee(address recipient, uint256 transferAmount)
        external;
}",521
RealWorld_BA_51_Swap_RealWord_20240821014407.log,51,Swap,97760,6216,103976,131.0,0.61312,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"";
import ""./OwnerPausable.sol"";
import ""./SwapUtils.sol"";
import ""./MathUtils.sol"";
import ""./hardhat/console.sol"";

/**
 * @title Swap - A StableSwap implementation in solidity.
 * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)
 * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens
 * in desired ratios for an exchange of the pool token that represents their share of the pool.
 * Users can burn pool tokens and withdraw their share of token(s).
 *
 * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets
 * distributed to the LPs.
 *
 * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which
 * stops the ratio of the tokens in the pool from changing.
 * Users can always withdraw their tokens via multi-asset withdraws.
 *
 * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's
 * deployment size.
 */
contract Swap is OwnerPausable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;
    using MathUtils for uint256;
    using SwapUtils for SwapUtils.Swap;
    using SwapUtils for SwapUtils.TargetPrice;

    // Structs storing data responsible for automatic market maker functionalities. In order to
    // access this data, this contract uses SwapUtils library. For more details, see SwapUtils.sol
    SwapUtils.Swap public swapStorage;
    SwapUtils.TargetPrice public targetPriceStorage;

    // Address to allowlist contract that holds information about maximum totaly supply of lp tokens
    // and maximum mintable amount per user address. As this is immutable, this will become a constant
    // after initialization.
    // IAllowlist private immutable allowlist;

    // Boolean value that notates whether this pool is guarded or not. When isGuarded is true,
    // addLiquidity function will be restricted by limits defined in allowlist contract.
    // bool private guarded = true;

    // Maps token address to an index in the pool. Used to prevent duplicate tokens in the pool.
    // getTokenIndex function also relies on this mapping to retrieve token index.
    mapping(address => uint8) private tokenIndexes;

    // uint256[2] originalPrecisionMultipliers;
    // uint256[2] customPrecisionMultipliers;

    /*** EVENTS ***/

    // events replicated from SwapUtils to make the ABI easier for dumb
    // clients
    event TokenSwap(
        address indexed buyer,
        uint256 tokensSold,
        uint256 tokensBought,
        uint128 soldId,
        uint128 boughtId
    );
    event AddLiquidity(
        address indexed provider,
        uint256[] tokenAmounts,
        uint256[] fees,
        uint256 invariant,
        uint256 lpTokenSupply
    );
    event RemoveLiquidity(
        address indexed provider,
        uint256[] tokenAmounts,
        uint256 lpTokenSupply
    );
    event RemoveLiquidityOne(
        address indexed provider,
        uint256 lpTokenAmount,
        uint256 lpTokenSupply,
        uint256 boughtId,
        uint256 tokensBought
    );
    event RemoveLiquidityImbalance(
        address indexed provider,
        uint256[] tokenAmounts,
        uint256[] fees,
        uint256 invariant,
        uint256 lpTokenSupply
    );
    event NewAdminFee(uint256 newAdminFee);
    event NewSwapFee(uint256 newSwapFee);
    event NewWithdrawFee(uint256 newWithdrawFee);
    event RampA(
        uint256 oldA,
        uint256 newA,
        uint256 initialTime,
        uint256 futureTime
    );
    event RampA2(
        uint256 oldA2,
        uint256 newA2,
        uint256 initialA2Time,
        uint256 futureA2Time
    );
    event StopRampA(uint256 currentA, uint256 time);
    event StopRampA2(uint256 currentA2, uint256 time);

    /**
     * @notice Deploys this Swap contract with given parameters as default
     * values. This will also deploy a LPToken that represents users
     * LP position. The owner of LPToken will be this contract - which means
     * only this contract is allowed to mint new tokens.
     *
     * @param _pooledTokens an array of ERC20s this pool will accept
     * @param decimals the decimals to use for each pooled token,
     * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS
     * @param lpTokenName the long-form name of the token to be deployed
     * @param lpTokenSymbol the short symbol for the token to be deployed
     * @param _a the amplification coefficient * n * (n - 1). See the
     * StableSwap paper for details
     * @param _a2 the amplification coefficient * n * (n - 1). See the
     * StableSwap paper for details
     * @param _fee default swap fee to be initialized with
     * @param _adminFee default adminFee to be initialized with
     * @param _withdrawFee default withdrawFee to be initialized with
     * @param _targetPrice default targetPrice to be initialized with
     */

    //   * @param _allowlist address of allowlist contract for guarded launch
    constructor(
        IERC20[] memory _pooledTokens,
        uint8[] memory decimals,
        string memory lpTokenName,
        string memory lpTokenSymbol,
        uint256 _a,
        uint256 _a2,
        uint256 _fee,
        uint256 _adminFee,
        uint256 _withdrawFee,
        uint256 _targetPrice
        // IAllowlist _allowlist
    ) public OwnerPausable() ReentrancyGuard() {
        // Check _pooledTokens and precisions parameter
        require(_pooledTokens.length == 2, ""_pooledTokens.length must be 2 in length"");
        require(decimals.length == 2, ""decimals.length must be 2 in length"");
        require(
            _pooledTokens.length == decimals.length,
            ""_pooledTokens decimals mismatch""
        );

        // uint256[] memory originalPrecisionMultipliers = new uint256[](decimals.length);

        for (uint8 i = 0; i < _pooledTokens.length; i++) {
            if (i > 0) {
                // Check if index is already used. Check if 0th element is a duplicate.
                require(
                    tokenIndexes[address(_pooledTokens[i])] == 0 &&
                        _pooledTokens[0] != _pooledTokens[i],
                    ""Duplicate tokens""
                );
            }
            require(
                address(_pooledTokens[i]) != address(0),
                ""The 0 address isn't an ERC-20""
            );
            require(
                decimals[i] <= SwapUtils.POOL_PRECISION_DECIMALS,
                ""Token decimals exceeds max""
            );
            targetPriceStorage.originalPrecisionMultipliers[i] =
                10 **
                    uint256(SwapUtils.POOL_PRECISION_DECIMALS).sub(
                        uint256(decimals[i])
                    );

            tokenIndexes[address(_pooledTokens[i])] = i;
        }

        uint256[2] memory customPrecisionMultipliers;
        customPrecisionMultipliers[0] = targetPriceStorage.originalPrecisionMultipliers[0].mul(_targetPrice).div(10 ** 18);
        customPrecisionMultipliers[1] = targetPriceStorage.originalPrecisionMultipliers[1];
        // console.log(""customPrecisionMultipliers[0] %s"", customPrecisionMultipliers[0]);

        // Check _a, _a2 _fee, _adminFee, _withdrawFee, _allowlist parameters
        require(_a >= 0 && _a <= SwapUtils.MAX_A, ""_a not within the limits"");
        require(_a2 >= 0 && _a2 <= SwapUtils.MAX_A, ""_a2 not within the limits"");
        require(_fee < SwapUtils.MAX_SWAP_FEE, ""_fee exceeds maximum"");
        require(
            _adminFee < SwapUtils.MAX_ADMIN_FEE,
            ""_adminFee exceeds maximum""
        );
        require(
            _withdrawFee < SwapUtils.MAX_WITHDRAW_FEE,
            ""_withdrawFee exceeds maximum""
        );
        // require(
        //     _allowlist.getPoolCap(address(0x0)) == uint256(0x54dd1e),
        //     ""Allowlist check failed""
        // );

        // Initialize swapStorage struct
        swapStorage.lpToken = new LPToken(
            lpTokenName,
            lpTokenSymbol,
            SwapUtils.POOL_PRECISION_DECIMALS
        );
        swapStorage.pooledTokens = _pooledTokens;
        swapStorage.tokenPrecisionMultipliers = customPrecisionMultipliers;
        swapStorage.balances = new uint256[](_pooledTokens.length);
        
        targetPriceStorage.initialTargetPrice = _targetPrice/*.mul(SwapUtils.TARGET_PRICE_PRECISION)*/;
        targetPriceStorage.futureTargetPrice = _targetPrice/*.mul(SwapUtils.TARGET_PRICE_PRECISION)*/;
        targetPriceStorage.initialTargetPriceTime = 0;
        targetPriceStorage.futureTargetPriceTime = 0;

        swapStorage.initialA = _a.mul(SwapUtils.A_PRECISION);
        swapStorage.futureA = _a.mul(SwapUtils.A_PRECISION);
        swapStorage.initialATime = 0;
        swapStorage.futureATime = 0;
        
        swapStorage.initialA2 = _a2.mul(SwapUtils.A_PRECISION);
        swapStorage.futureA2 = _a2.mul(SwapUtils.A_PRECISION);
        swapStorage.initialA2Time = 0;
        swapStorage.futureA2Time = 0;
        
        swapStorage.swapFee = _fee;
        swapStorage.adminFee = _adminFee;
        swapStorage.defaultWithdrawFee = _withdrawFee;

        // Initialize variables related to guarding the initial deposits
        // allowlist = _allowlist;
        // guarded = true;
    }

    /*** MODIFIERS ***/

    /**
     * @notice Modifier to check deadline against current timestamp
     * @param deadline latest timestamp to accept this transaction
     */
    modifier deadlineCheck(uint256 deadline) {
        require(block.timestamp <= deadline, ""Deadline not met"");
        _;
    }

    /*** VIEW FUNCTIONS ***/

    /**
     * @notice Return A, the amplification coefficient * n * (n - 1)
     * @dev See the StableSwap paper for details
     * @return A parameter
     */
    function getA() external view returns (uint256) {
        return swapStorage.getA();
    }

    /**
     * @notice Return A2, the amplification coefficient * n * (n - 1)
     * @dev See the StableSwap paper for details
     * @return A2 parameter
     */
    function getA2() external view returns (uint256) {
        return swapStorage.getA2();
    }

    /**
     * @notice Return A in its raw precision form
     * @dev See the StableSwap paper for details
     * @return A parameter in its raw precision form
     */
    function getAPrecise() external view returns (uint256) {
        return swapStorage.getAPrecise();
    }

    /**
     * @notice Return A2 in its raw precision form
     * @dev See the StableSwap paper for details
     * @return A2 parameter in its raw precision form
     */
    function getA2Precise() external view returns (uint256) {
        return swapStorage.getA2Precise();
    }

    /**
     * @notice Return address of the pooled token at given index. Reverts if tokenIndex is out of range.
     * @param index the index of the token
     * @return address of the token at given index
     */
    function getToken(uint8 index) public view returns (IERC20) {
        require(index < swapStorage.pooledTokens.length, ""Out of range"");
        return swapStorage.pooledTokens[index];
    }

    /**
     * @notice Return the index of the given token address. Reverts if no matching
     * token is found.
     * @param tokenAddress address of the token
     * @return the index of the given token address
     */
    function getTokenIndex(address tokenAddress) external view returns (uint8) {
        uint8 index = tokenIndexes[tokenAddress];
        require(
            address(getToken(index)) == tokenAddress,
            ""Token does not exist""
        );
        return index;
    }

    // /**
    //  * @notice Reads and returns the address of the allowlist that is set during deployment of this contract
    //  * @return the address of the allowlist contract casted to the IAllowlist interface
    //  */
    // function getAllowlist() external view returns (IAllowlist) {
    //     return allowlist;
    // }

    /**
     * @notice Return timestamp of last deposit of given address
     * @return timestamp of the last deposit made by the given address
     */
    function getDepositTimestamp(address user) external view returns (uint256) {
        return swapStorage.getDepositTimestamp(user);
    }

    /**
     * @notice Return current balance of the pooled token at given index
     * @param index the index of the token
     * @return current balance of the pooled token at given index with token's native precision
     */
    function getTokenBalance(uint8 index) external view returns (uint256) {
        require(index < swapStorage.pooledTokens.length, ""Index out of range"");
        return swapStorage.balances[index];
    }

    /**
     * @notice Get the virtual price, to help calculate profit
     * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS
     */
    function getVirtualPrice() external view returns (uint256) {
        return swapStorage.getVirtualPrice();
    }

    /**
     * @notice Calculate amount of tokens you receive on swap
     * @param tokenIndexFrom the token the user wants to sell
     * @param tokenIndexTo the token the user wants to buy
     * @param dx the amount of tokens the user wants to sell. If the token charges
     * a fee on transfers, use the amount that gets transferred after the fee.
     * @return amount of tokens the user will receive
     */
    function calculateSwap(
        uint8 tokenIndexFrom,
        uint8 tokenIndexTo,
        uint256 dx
    ) external view returns (uint256) {
        return swapStorage.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);
    }

    /**
     * @notice A simple method to calculate prices from deposits or
     * withdrawals, excluding fees but including slippage. This is
     * helpful as an input into the various ""min"" parameters on calls
     * to fight front-running
     *
     * @dev This shouldn't be used outside frontends for user estimates.
     *
     * @param account address that is depositing or withdrawing tokens
     * @param amounts an array of token amounts to deposit or withdrawal,
     * corresponding to pooledTokens. The amount should be in each
     * pooled token's native precision. If a token charges a fee on transfers,
     * use the amount that gets transferred after the fee.
     * @param deposit whether this is a deposit or a withdrawal
     * @return token amount the user will receive
     */
    function calculateTokenAmount(
        address account,
        uint256[] calldata amounts,
        bool deposit
    ) external view returns (uint256) {
        return swapStorage.calculateTokenAmount(account, amounts, deposit);
    }

    /**
     * @notice A simple method to calculate amount of each underlying
     * tokens that is returned upon burning given amount of LP tokens
     * @param account the address that is withdrawing tokens
     * @param amount the amount of LP tokens that would be burned on withdrawal
     * @return array of token balances that the user will receive
     */
    function calculateRemoveLiquidity(address account, uint256 amount)
        external
        view
        returns (uint256[] memory)
    {
        return swapStorage.calculateRemoveLiquidity(account, amount);
    }

    /**
     * @notice Calculate the amount of underlying token available to withdraw
     * when withdrawing via only single token
     * @param account the address that is withdrawing tokens
     * @param tokenAmount the amount of LP token to burn
     * @param tokenIndex index of which token will be withdrawn
     * @return availableTokenAmount calculated amount of underlying token
     * available to withdraw
     */
    function calculateRemoveLiquidityOneToken(
        address account,
        uint256 tokenAmount,
        uint8 tokenIndex
    ) external view returns (uint256 availableTokenAmount) {
        (availableTokenAmount, ) = swapStorage.calculateWithdrawOneToken(
            account,
            tokenAmount,
            tokenIndex
        );
    }

    /**
     * @notice Calculate the fee that is applied when the given user withdraws. The withdraw fee
     * decays linearly over period of 4 weeks. For example, depositing and withdrawing right away
     * will charge you the full amount of withdraw fee. But withdrawing after 4 weeks will charge you
     * no additional fees.
     * @dev returned value should be divided by FEE_DENOMINATOR to convert to correct decimals
     * @param user address you want to calculate withdraw fee of
     * @return current withdraw fee of the user
     */
    function calculateCurrentWithdrawFee(address user)
        external
        view
        returns (uint256)
    {
        return swapStorage.calculateCurrentWithdrawFee(user);
    }

    /**
     * @notice This function reads the accumulated amount of admin fees of the token with given index
     * @param index Index of the pooled token
     * @return admin's token balance in the token's precision
     */
    function getAdminBalance(uint256 index) external view returns (uint256) {
        return swapStorage.getAdminBalance(index);
    }

    /*** STATE MODIFYING FUNCTIONS ***/

    /**
     * @notice Swap two tokens using this pool
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     * @param dx the amount of tokens the user wants to swap from
     * @param minDy the min amount the user would like to receive, or revert.
     * @param deadline latest timestamp to accept this transaction
     * @return amount of token user received on swap
     */
    function swap(
        uint8 tokenIndexFrom,
        uint8 tokenIndexTo,
        uint256 dx,
        uint256 minDy,
        uint256 deadline
    )
        external
        nonReentrant
        whenNotPaused
        deadlineCheck(deadline)
        returns (uint256)
    {
        return swapStorage.swap(tokenIndexFrom, tokenIndexTo, dx, minDy);
    }

    /**
     * @notice Add liquidity to the pool with given amounts during guarded launch phase. Only users
     * with valid address and proof can successfully call this function. When this function is called
     * after the guarded release phase is over, the merkleProof is ignored.
     * @param amounts the amounts of each token to add, in their native precision
     * @param minToMint the minimum LP tokens adding this amount of liquidity
     * should mint, otherwise revert. Handy for front-running mitigation
     * @param deadline latest timestamp to accept this transaction
     * get this data off chain. Even if the address is in the allowlist, users must include
     * a valid proof for this call to succeed. If the pool is no longer in the guarded release phase,
     * this parameter is ignored.
     * @return amount of LP token user minted and received
     */
    function addLiquidity(
        uint256[] calldata amounts,
        uint256 minToMint,
        uint256 deadline
    )
        external
        nonReentrant
        whenNotPaused
        deadlineCheck(deadline)
        returns (uint256)
    {
        return swapStorage.addLiquidity(amounts, minToMint);
    }

    /**
     * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly
     * over period of 4 weeks since last deposit will apply.
     * @dev Liquidity can always be removed, even when the pool is paused.
     * @param amount the amount of LP tokens to burn
     * @param minAmounts the minimum amounts of each token in the pool
     *        acceptable for this burn. Useful as a front-running mitigation
     * @param deadline latest timestamp to accept this transaction
     * @return amounts of tokens user received
     */
    function removeLiquidity(
        uint256 amount,
        uint256[] calldata minAmounts,
        uint256 deadline
    ) external nonReentrant deadlineCheck(deadline) returns (uint256[] memory) {
        return swapStorage.removeLiquidity(amount, minAmounts);
    }

    /**
     * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly
     * over period of 4 weeks since last deposit will apply.
     * @param tokenAmount the amount of the token you want to receive
     * @param tokenIndex the index of the token you want to receive
     * @param minAmount the minimum amount to withdraw, otherwise revert
     * @param deadline latest timestamp to accept this transaction
     * @return amount of chosen token user received
     */
    function removeLiquidityOneToken(
        uint256 tokenAmount,
        uint8 tokenIndex,
        uint256 minAmount,
        uint256 deadline
    )
        external
        nonReentrant
        whenNotPaused
        deadlineCheck(deadline)
        returns (uint256)
    {
        return
            swapStorage.removeLiquidityOneToken(
                tokenAmount,
                tokenIndex,
                minAmount
            );
    }

    /**
     * @notice Remove liquidity from the pool, weighted differently than the
     * pool's current balances. Withdraw fee that decays linearly
     * over period of 4 weeks since last deposit will apply.
     * @param amounts how much of each token to withdraw
     * @param maxBurnAmount the max LP token provider is willing to pay to
     * remove liquidity. Useful as a front-running mitigation.
     * @param deadline latest timestamp to accept this transaction
     * @return amount of LP tokens burned
     */
    function removeLiquidityImbalance(
        uint256[] calldata amounts,
        uint256 maxBurnAmount,
        uint256 deadline
    )
        external
        nonReentrant
        whenNotPaused
        deadlineCheck(deadline)
        returns (uint256)
    {
        return swapStorage.removeLiquidityImbalance(amounts, maxBurnAmount);
    }

    /*** ADMIN FUNCTIONS ***/

    /**
     * @notice Updates the user withdraw fee. This function can only be called by
     * the pool token. Should be used to update the withdraw fee on transfer of pool tokens.
     * Transferring your pool token will reset the 4 weeks period. If the recipient is already
     * holding some pool tokens, the withdraw fee will be discounted in respective amounts.
     * @param recipient address of the recipient of pool token
     * @param transferAmount amount of pool token to transfer
     */
    function updateUserWithdrawFee(address recipient, uint256 transferAmount)
        external
    {
        require(
            msg.sender == address(swapStorage.lpToken),
            ""Only callable by pool token""
        );
        swapStorage.updateUserWithdrawFee(recipient, transferAmount);
    }

    /**
     * @notice Withdraw all admin fees to the contract owner
     */
    function withdrawAdminFees() external onlyOwner {
        swapStorage.withdrawAdminFees(owner());
    }

    /**
     * @notice Update the admin fee. Admin fee takes portion of the swap fee.
     * @param newAdminFee new admin fee to be applied on future transactions
     */
    function setAdminFee(uint256 newAdminFee) external onlyOwner {
        swapStorage.setAdminFee(newAdminFee);
    }

    /**
     * @notice Update the swap fee to be applied on swaps
     * @param newSwapFee new swap fee to be applied on future transactions
     */
    function setSwapFee(uint256 newSwapFee) external onlyOwner {
        swapStorage.setSwapFee(newSwapFee);
    }

    /**
     * @notice Update the withdraw fee. This fee decays linearly over 4 weeks since
     * user's last deposit.
     * @param newWithdrawFee new withdraw fee to be applied on future deposits
     */
    function setDefaultWithdrawFee(uint256 newWithdrawFee) external onlyOwner {
        swapStorage.setDefaultWithdrawFee(newWithdrawFee);
    }

    /**
     * @notice Start ramping up or down Target price towards given futureTargetPrice and futureTime
     * Checks if the change is too rapid, and commits the new Target price value only when it falls under
     * the limit range.
     * @param futureTargetPrice the new target price to ramp towards
     * @param futureTime timestamp when the new target price should be reached
     */
    function rampTargetPrice(uint256 futureTargetPrice, uint256 futureTime) external onlyOwner {
        swapStorage.tokenPrecisionMultipliers[0] = targetPriceStorage.rampTargetPrice(futureTargetPrice, futureTime);
    }


    /**
     * @notice Start ramping up or down A parameter towards given futureA and futureTime
     * Checks if the change is too rapid, and commits the new A value only when it falls under
     * the limit range.
     * @param futureA the new A to ramp towards
     * @param futureTime timestamp when the new A should be reached
     */
    function rampA(uint256 futureA, uint256 futureTime) external onlyOwner {
        swapStorage.rampA(futureA, futureTime);
    }

    /**
     * @notice Start ramping up or down A2 parameter towards given futureA and futureTime
     * Checks if the change is too rapid, and commits the new A value only when it falls under
     * the limit range.
     * @param futureA the new A2 to ramp towards
     * @param futureTime timestamp when the new A2 should be reached
     */
    function rampA2(uint256 futureA, uint256 futureTime) external onlyOwner {
        swapStorage.rampA2(futureA, futureTime);
    }

    /**
     * @notice Stop ramping Target Price immediately. Reverts if ramp Target Price is already stopped.
     */
    function stopRampTargetPrice() external onlyOwner {
        swapStorage.tokenPrecisionMultipliers[0] = targetPriceStorage.stopRampTargetPrice();
    }


    /**
     * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.
     */
    function stopRampA() external onlyOwner {
        swapStorage.stopRampA();
    }

    /**
     * @notice Stop ramping A2 immediately. Reverts if ramp A2 is already stopped.
     */
    function stopRampA2() external onlyOwner {
        swapStorage.stopRampA2();
    }

    // /**
    //  * @notice Disables the guarded launch phase, removing any limits on deposit amounts and addresses
    //  */
    // function disableGuard() external onlyOwner {
    //     guarded = false;
    // }

    // /**
    //  * @notice Reads and returns current guarded status of the pool
    //  * @return guarded_ boolean value indicating whether the deposits should be guarded
    //  */
    // function isGuarded() external view returns (bool) {
    //     return guarded;
    // }
}",6011
RealWorld_BA_51_Token_RealWord_20240821015800.log,51,Token,4925,4332,9257,80.0,0.111265,"//SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

/// @notice Create a ERC20 token with additional functions in order 
///         to demo the working of vesting contract
contract Token is ERC20{
    address public admin;

    constructor() ERC20(""Boot Token"", ""BOOT"") {
        _mint(msg.sender, 10_000_000_000 * (10 ** uint256(decimals())));        // mint 10 B tokens
        admin = msg.sender;
    }

}",123
RealWorld_BA_51_IERC165_RealWord_20240821021147.log,51,IERC165,6261,4297,10558,91.0,0.117245,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}",193
RealWorld_BA_51_MathUtils_RealWord_20240821014111.log,51,MathUtils,8789,3816,12605,77.0,0.120265,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";

/**
 * @title MathUtils library
 * @notice A library to be used in conjunction with SafeMath. Contains functions for calculating
 * differences between two uint256.
 */
library MathUtils {
    /**
     * @notice Compares a and b and returns true if the difference between a and b
     *         is less than 1 or equal to each other.
     * @param a uint256 to compare with
     * @param b uint256 to compare with
     * @return True if the difference between a and b is less than 1 or equal,
     *         otherwise return false
     */
    function within1(uint256 a, uint256 b) external pure returns (bool) {
        return (_difference(a, b) <= 1);
    }

    /**
     * @notice Calculates absolute difference between a and b
     * @param a uint256 to compare with
     * @param b uint256 to compare with
     * @return Difference between a and b
     */
    function difference(uint256 a, uint256 b) external pure returns (uint256) {
        return _difference(a, b);
    }

    /**
     * @notice Calculates absolute difference between a and b
     * @param a uint256 to compare with
     * @param b uint256 to compare with
     * @return Difference between a and b
     */
    function _difference(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a > b) {
            return a - b;
        }
        return b - a;
    }
}",358
RealWorld_BA_51_InvestorDistribution_RealWord_20240821015433.log,51,InvestorDistribution,36905,5778,42683,101.0,0.300085,"//SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

/**
 * @summary: Distribution contract for Angel and Seed Contributors
 * @author: Boot Finance
 */

import '@openzeppelin/contracts/utils/math/SafeMath.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/security/Pausable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import ""./interfaces/IVesting.sol"";

/// @title InvestorDistribution
/// @dev The investor mappings will be initialized after deployment of contract

contract InvestorDistribution is Pausable, ReentrancyGuard {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    //Investor Shares (Angel + Seed Round)
    struct Investors {
        uint256 amount;
        uint256 claimed;
        uint256 total_tokens;
        uint256 fraction;     // with 10**18 precision
    }

    address public admin;
    mapping(address => Investors) public investors;

    uint256 private investors_supply = 11088000 * 10 ** 18;

    // General constants
    uint256 constant HOUR = 3600;
    uint256 constant DAY = 86400;
    uint256 constant WEEK = 86400 * 7;
    uint256 constant YEAR = WEEK * 52;

    //INITIAL_SUPPLY: constant(uint256) = 0
    // INFLATION_DELAY: constant(uint256) = 3 * HOUR # Three Hour delay before minting may begin
    // RATE_DENOMINATOR: constant(uint256) = 10 ** 18
    uint256 constant RATE_TIME = WEEK;                                         // How often the rate goes to the next epoch
    uint256 constant INITIAL_RATE = 135_994 * 10 ** 18 / WEEK;                // 2,474,410 for the first week
    uint256 constant EPOCH_INFLATION = 98_831;                                  // 98.831 % of last week
    uint256 constant INITIAL_RATE_EPOCH_CUTTOF = 260;                          // After 260 Weeks use the late rate

    // Supply variables
    uint256 public miningEpoch;
    uint256 public startEpochTime;
    uint256 public rate;
    uint256 public initTime;

    uint256 public startEpochSupply;
   
    event updateMiningParameters(uint256 time, uint256 rate, uint256 supply);
    event InvestorAdded(address indexed investor, uint256 amount, uint256 timeStamp);
    event InvestorModified(address indexed investor, address newinvestor, uint256 timeStamp);
    event Vested(address indexed investor, uint256 amount, uint256 timeStamp);
    event Rugged(uint256 amount, uint256 timeStamp);
    event AdminChanged(address newAdmin, uint256 timeStamp);

    IERC20 public mainToken;
    IVesting public vestLock;

    // define all the mining calculations here so that it doesn't have to
    // called from MainToken contract
    constructor(IERC20 _mainToken, IVesting _vestLock) {
        require(address(_mainToken) != address(0), ""Invalid address"");
        require(address(_vestLock) != address(0), ""Invalid address"");
        mainToken = _mainToken;
        vestLock = _vestLock;
        rate = INITIAL_RATE;
        initTime = block.timestamp;
        startEpochTime = block.timestamp;
        startEpochSupply = 0;
        admin = msg.sender;

        mainToken.approve(address(vestLock), 2**256-1);
    }


    //Address of contributor
    function addInvestor(address _investor, uint256 _amount) external whenNotPaused {
        require(_investor != address(0), ""Invalid address"");
        require(_amount > 0, ""Amount must be positive"");
        require(msg.sender == admin, ""Unauthorized"");

        Investors memory newInvestor = Investors(_amount, 0, _amount, 10**18 * _amount / investors_supply);
        investors[_investor] = newInvestor;

        emit InvestorAdded(_investor, _amount, block.timestamp);
    }

    //Fallback in case a contributor loses keys, or cannot access wallet for any other reason
    function modifyInvestor(address _investor, address _new) external whenNotPaused nonReentrant {
        require(_investor != address(0), ""Invalid old address"");
        require(_new != address(0), ""Invalid new address"");
        require(investors[_investor].amount != 0);
        require(msg.sender == admin, ""Unauthorized"");

        Investors memory newInvestor = Investors(investors[_investor].amount, investors[_investor].claimed, investors[_investor].total_tokens, investors[_investor].fraction);
        investors[_new] = newInvestor;

        Investors memory oldInvestor = Investors(0, 0, 0, 0);
        investors[_investor] = oldInvestor;

        emit InvestorModified(_investor, _new, block.timestamp);
    }

    //Claim function to calculate and withdraw claimable tokens, also lock 70% in vesting contract
    function claim() external nonReentrant {
        require(msg.sender != address(0));
        require(investors[msg.sender].amount != 0);
        
        uint256 avail = _available_supply();
        require(avail > 0, ""Nothing claimable (yet?)"");

        uint256 claimable = avail * investors[msg.sender].fraction / 10**18;
        assert(claimable > 0);
        if (investors[msg.sender].claimed != 0) {
            claimable -= investors[msg.sender].claimed;
        }

        require(investors[msg.sender].amount - claimable != 0);

        investors[msg.sender].amount -= claimable;
        investors[msg.sender].claimed += claimable;

        uint256 claimable_to_send = claimable * 3 / 10;         //30% released instantly
        mainToken.transfer(msg.sender, claimable_to_send);
        uint256 claimable_not_yet_vested = claimable - claimable_to_send;
        vestLock.vest(msg.sender, claimable_not_yet_vested, 0); //70% locked in vesting contract

        emit Vested(msg.sender, claimable, block.timestamp);
    }

    //Allow users to claim a specific amount instead of the entire amount
    function claimExact(uint256 _value) external nonReentrant {
        require(msg.sender != address(0));
        require(investors[msg.sender].amount != 0);
        
        uint256 avail = _available_supply();
        uint256 claimable = avail * investors[msg.sender].fraction / 10**18;
        if (investors[msg.sender].claimed != 0) {
            claimable -= investors[msg.sender].claimed;
        }

        require(investors[msg.sender].amount >= claimable);
        require(_value <= claimable);
        investors[msg.sender].amount -= _value;
        investors[msg.sender].claimed += _value;

        uint256 claimable_to_send = _value * 3 / 10;
        mainToken.transfer(msg.sender, claimable_to_send);
        uint256 claimable_not_yet_vested = _value - claimable_to_send;
        vestLock.vest(msg.sender, claimable_not_yet_vested, 0);

        emit Vested(msg.sender, _value, block.timestamp);
    }

    /// @notice release of BOOT public sale tokens from this contract 
    /// based on emission rules
    /// updates the rate the mining parameters for public sale tokens
    /// 

    function _updateEmission() private {
        if (block.timestamp >= startEpochTime + RATE_TIME) {
            miningEpoch += 1;
            startEpochTime = startEpochTime.add(RATE_TIME);
            startEpochSupply = startEpochSupply.add(rate.mul(RATE_TIME));

            if (miningEpoch < INITIAL_RATE_EPOCH_CUTTOF) {
                rate = rate.mul(EPOCH_INFLATION).div(100000);
            }
            else {
                rate = 0;
            }
            emit updateMiningParameters(block.timestamp, rate, startEpochSupply);
        }
    }

    //Update emission to be called at every step change to update emission inflation
    function updateEmission() public {
        require(block.timestamp >= startEpochTime + RATE_TIME, ""Too soon"");
        _updateEmission();
    }

    //Internal function to calculate current available supply
    function _available_supply() private view returns(uint256) {
        assert(block.timestamp - startEpochTime <= RATE_TIME);
        return startEpochSupply + (block.timestamp - startEpochTime) * rate;
    }

    //Public function to calculate current available supply
    function available_supply() public view returns(uint256) {
        assert(block.timestamp - startEpochTime <= RATE_TIME);
        return startEpochSupply + (block.timestamp - startEpochTime) * rate;
    }

    //Dev can access all tokens in the contract after 5 year period, to take care of fringe cases of lost or unclaimed tokens
    function dev_rugpull() public {
        assert(block.timestamp - initTime >= YEAR * 5); //dev can rug the unclaimed tokens 5 years later, assuming someone lost their key, or forgot about it or whatever and figure what to do with them.
        require(msg.sender == admin, ""Unauthorized"");   //admin-only
        uint256 bal = mainToken.balanceOf(address(this));
        mainToken.transfer(msg.sender, bal);
        emit Rugged(bal, block.timestamp);
    }

    //Change admin of the contract
    function setAdmin(address _newAdmin) public {
        require(msg.sender == admin, ""Unauthorized"");
        require(address(_newAdmin) != address(0), ""Invalid address"");
        admin = _newAdmin;
        emit AdminChanged(_newAdmin, block.timestamp);
    }

}",2057
RealWorld_BA_51_IVesting_RealWord_20240821015922.log,51,IVesting,3640,4665,8305,100.0,0.1115,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.4;

interface IVesting {
   function vest(address _beneficiary, uint256 _amount, uint256 _isRevocable) external payable;
}",45
RealWorld_BA_51_PublicSale_RealWord_20240821020104.log,51,PublicSale,56166,5823,61989,117.0,0.39729,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @summary: Forked & Modified Vether (vetherasset.io) contract for Public Sale
 * @author: Boot Finance
 */

import ""./interfaces/IERC20.sol"";
import ""./interfaces/IERC721.sol"";

interface IVesting {
   /**
    * @dev Interface to vesting contract. 30% tokens are released instantly, 70% are locked.
    * @param _beneficiary Beneficiary of the locked tokens.
    * @param _amount Amount to be locked in vesting contract.
    * @param _isRevocable Can the vesting be revoked? Only revocable for team, in case if someone leaves.
    */
   function vest(address _beneficiary, uint256 _amount, uint256 _isRevocable) external payable;
}

library SafeMath {
    /**
     * @dev SafeMath library
     * @param a First variable
     * @param b Second variable
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, ""SafeMath: subtraction overflow"");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;
        return c;
    }
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        return a / b;
    }
}

contract BasicSale {
    using SafeMath for uint;
    IERC20 public mainToken;    //Address of the BOOT token
    IERC721 public nft;         //Address of NFT contract, for first 4 weeks only NFT holders can access the sale
    IVesting public vestLock;   //Address of the Vesting contract

    // ERC-20 Mappings
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;

    // Public Parameters
    uint public constant decimals = 18;
    uint public constant coin = 10 ** decimals;
    uint public constant secondsPerDay = 84200;
    uint public constant firstEra = 1;

    // project-specific multisig address where raised funds will be sent
    
    address deployer;
    address payable burnAddress;

    uint public genesis;
    uint public daysPerEra;
    uint public firstPublicEra;
    uint public totalSupply;        // MainToken supply allocated to public sale
    uint public remainingSupply;
    uint public initialDayEmission;
    uint public currentEra;
    uint public currentDay;
    uint public nextEraTime;
    uint public nextDayTime;
    uint public totalBurnt;
    uint public totalEmitted;

    // uncapped theoretical, public should use getDayEmission() instead
    uint private emission;

    // Public Mappings
    mapping(uint => uint) public mapEra_Emission;                                             // Era->Emission
    mapping(uint => mapping(uint => uint)) public mapEraDay_MemberCount;                      // Era,Days->MemberCount
    mapping(uint => mapping(uint => address[])) public mapEraDay_Members;                     // Era,Days->Members
    mapping(uint => mapping(uint => uint)) public mapEraDay_Units;                            // Era,Days->Units
    mapping(uint => mapping(uint => uint)) public mapEraDay_UnitsRemaining;                   // Era,Days->TotalUnits
    mapping(uint => mapping(uint => uint)) public mapEraDay_EmissionRemaining;                // Era,Days->Emission
    mapping(uint => mapping(uint => mapping(address => uint))) public mapEraDay_MemberUnits;  // Era,Days,Member->Units
    mapping(address => mapping(uint => uint[])) public mapMemberEra_Days;                     // Member,Era->Days[]

    // Events
    event NewEra(uint era, uint emission, uint time, uint totalBurnt);
    event NewDay(uint era, uint day, uint time, uint previousDayTotal, uint previousDayMembers);
    event Burn(address indexed payer, address indexed member, uint era, uint day, uint units, uint dailyTotal);
    event Withdrawal(address indexed caller, address indexed member, uint era, uint day, uint value, uint vetherRemaining);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(
        IERC20 _mainToken,
        IERC721 _nft,
        IVesting _vestLock,
        uint _daysPerEra,
        uint _firstPublicEra,
        uint _totalSupply,
        uint _initialDayEmission,
        address payable _burnAddress)
    {
        require(address(_mainToken) != address(0), ""Invalid ERC20 address"");
        require(address(_nft) != address(0), ""Invalid ERC721 address"");
        require(address(_vestLock) != address(0), ""Invalid Vesting address"");

        mainToken = _mainToken;
        nft = _nft;
        vestLock = _vestLock;

        genesis = block.timestamp;
        currentEra = 1;
        currentDay = 1;
        totalBurnt = 0;
        totalEmitted = 0;

        daysPerEra = _daysPerEra;
        firstPublicEra = _firstPublicEra;
        totalSupply = _totalSupply;
        initialDayEmission = _initialDayEmission;

        emission = _initialDayEmission; // current day's theoretical emission regardless of actual supply
        remainingSupply = _totalSupply; // remaining actual supply including for the current day

        deployer = msg.sender;
        burnAddress = _burnAddress;

        nextEraTime = genesis + (secondsPerDay * daysPerEra);
        nextDayTime = block.timestamp + secondsPerDay;                                       
        mapEra_Emission[currentEra] = emission; 
        mapEraDay_EmissionRemaining[currentEra][currentDay] = emission; 
    }

    // Any ETH sent is assumed to be for the token sale.
    // Initially only accounts with the specific NFT may participate.
    //
    receive() external payable {
        _updateEmission();
        require(remainingSupply > 0, ""public sale has ended"");
        if (currentEra < firstPublicEra) {
            require(nft.balanceOf(msg.sender) > 0, ""You need NFT to participate in the sale."");
        }
        burnAddress.call{value: msg.value}("""");
        _recordBurn(msg.sender, msg.sender, currentEra, currentDay, msg.value);
    }

    function burnEtherForMember(address member) external payable {
        _updateEmission();
        require(remainingSupply > 0, ""public sale has ended"");
        if (currentEra < firstPublicEra) {
            require(nft.balanceOf(member) > 0, ""Member needs NFT to participate in the sale."");
        }
        burnAddress.call{value: msg.value}("""");
        _recordBurn(msg.sender, member, currentEra, currentDay, msg.value);
    }

    // Internal - Records burn
    function _recordBurn(address _payer, address _member, uint _era, uint _day, uint _eth) private {
        if (mapEraDay_MemberUnits[_era][_day][_member] == 0) {                              // If hasn't contributed to this Day yet
            mapMemberEra_Days[_member][_era].push(_day);                                    // Add it
            mapEraDay_MemberCount[_era][_day] += 1;                                         // Count member
            mapEraDay_Members[_era][_day].push(_member);                                    // Add member
        }
        mapEraDay_MemberUnits[_era][_day][_member] += _eth;                                 // Add member's share
        mapEraDay_UnitsRemaining[_era][_day] += _eth;                                       // Add to total historicals
        mapEraDay_Units[_era][_day] += _eth;                                                // Add to total outstanding
        totalBurnt += _eth;                                                                 // Add to total burnt
        emit Burn(_payer, _member, _era, _day, _eth, mapEraDay_Units[_era][_day]);          // Burn event
    }

    // efficiently tracks participation in each era
    function getDaysContributedForEra(address member, uint era) public view returns(uint) {
        return mapMemberEra_Days[member][era].length;
    }

    function withdrawShare(uint era, uint day) external returns (uint value) {
        require(era >= 1, ""era must be >= 1"");
        require(day >= 1, ""day must be >= 1"");
        require(day <= daysPerEra, ""day must be <= daysPerEra"");
        return _withdrawShare(era, day, msg.sender);                           
    }

    function withdrawShareForMember(uint era, uint day, address member) external returns (uint value) {
        require(era >= 1, ""era must be >= 1"");
        require(day >= 1, ""day must be >= 1"");
        require(day <= daysPerEra, ""day must be <= daysPerEra"");
        return _withdrawShare(era, day, member);
    }

    function _withdrawShare (uint _era, uint _day, address _member) private returns (uint value) {
        _updateEmission();
        if (_era < currentEra) {                                      // Allow if in previous Era
            value = _processWithdrawal(_era, _day, _member);          // Process Withdrawal
        }
        else if (_era == currentEra && _day < currentDay) {           // Allow if in current Era and previous Day
            value = _processWithdrawal(_era, _day, _member);          // Process Withdrawal    
        }  
        return value;
    }

    function _processWithdrawal (uint _era, uint _day, address _member) private returns (uint value) {
        uint memberUnits = mapEraDay_MemberUnits[_era][_day][_member]; // Get Member Units
        if (memberUnits == 0) { 
            value = 0;                                                 // Do nothing if 0 (prevents revert)
        }
        else {
            value = getEmissionShare(_era, _day, _member);             // Get the emission Share for Member
            mapEraDay_MemberUnits[_era][_day][_member] = 0;            // Set to 0 since it will be withdrawn
            mapEraDay_UnitsRemaining[_era][_day] = mapEraDay_UnitsRemaining[_era][_day].sub(memberUnits);  // Decrement Member Units
            mapEraDay_EmissionRemaining[_era][_day] = mapEraDay_EmissionRemaining[_era][_day].sub(value);  // Decrement emission
            totalEmitted += value;                                     // Add to Total Emitted
            uint256 v_value = value * 3 / 10;                          // Transfer 30%, lock the rest in vesting contract             
            mainToken.transfer(_member, v_value);                      // ERC20 transfer function
            vestLock.vest(_member, value - v_value, 0);
            emit Withdrawal(msg.sender, _member, _era, _day, value, mapEraDay_EmissionRemaining[_era][_day]);
        }
        return value;
    }

    function getEmissionShare(uint era, uint day, address member) public view returns (uint value) {
        uint memberUnits = mapEraDay_MemberUnits[era][day][member];                         // Get Member Units
        if (memberUnits == 0) {
            return 0;                                                                       // If 0, return 0
        }
        else {
            uint totalUnits = mapEraDay_UnitsRemaining[era][day];                           // Get Total Units
            uint emissionRemaining = mapEraDay_EmissionRemaining[era][day];                 // Get emission remaining for Day
            uint balance = mainToken.balanceOf(address(this));
            if (emissionRemaining > balance) {
                emissionRemaining = balance;                                                // In case less than required emission
            }
            return (emissionRemaining * memberUnits) / totalUnits;                          // Calculate share
        }
    }
    
    function _updateEmission() private {
        uint _now = block.timestamp;                                                        // Find now()
        if (_now >= nextDayTime) {                                                          // If time passed the next Day time
            if (remainingSupply > emission) {
                remainingSupply -= emission;
            }
            else {
                remainingSupply = 0;
            }
            if (currentDay >= daysPerEra) {                                                 // If time passed the next Era time
                currentEra += 1; currentDay = 0;                                            // Increment Era, reset Day
                nextEraTime = _now + (secondsPerDay * daysPerEra);                          // Set next Era time
                emission = getNextEraEmission();                                            // Get correct emission
                mapEra_Emission[currentEra] = emission;                                     // Map emission to Era
                emit NewEra(currentEra, emission, nextEraTime, totalBurnt);                 // Emit Event
            }
            currentDay += 1;                                                                // Increment Day
            nextDayTime = _now + secondsPerDay;                                             // Set next Day time
            emission = getDayEmission();                                                    // Check daily Dmission
            mapEraDay_EmissionRemaining[currentEra][currentDay] = emission;                 // Map emission to Day
            uint _era = currentEra;
            uint _day = currentDay - 1;
            if (currentDay == 1) {
                // new era
                _era = currentEra - 1;
                _day = daysPerEra;
            }
            emit NewDay(currentEra, currentDay, nextDayTime, mapEraDay_Units[_era][_day], mapEraDay_MemberCount[_era][_day]);
        }
    }

    function updateEmission() external {
        _updateEmission();
    }

    function getNextEraEmission() public view returns (uint) {
        if (emission > coin) {                                          // Normal Emission Schedule
            return emission.mul(988311938981777).div(1000000000000000); // Emissions: 2048 -> 1.0
        }
        else {                                                          // Enters Fee Era
            return coin;                                                // Return 1.0 from fees
        }
    }

    function getDayEmission() public view returns (uint) {
        if (remainingSupply > emission) {
            return emission;
        }
        else {
            return remainingSupply;
        }
    }
}

contract PublicSale is BasicSale {
    constructor(IERC20 _mainToken, IERC721 _nft, IVesting _vestLock) 

        BasicSale(_mainToken, _nft, _vestLock,

            7, // daysPerEra
            5, // firstPublicEra

            21_180_364_000000000000000000, // totalSupply
                37_111_000000000000000000, // initialDayEmission

            payable(address(0x03Df4ADDfB568b338f6a0266f30458045bbEFbF2)))
    {}
}",3385
RealWorld_BA_51_ETHPoolDelegator_RealWord_20240821013811.log,51,ETHPoolDelegator,17172,5592,22764,94.0,0.1977,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.8;
pragma experimental ABIEncoderV2;

/// @title ETH Pool Delegator
/// @author John Deere
/// @notice ETH Liquidity Pool that delegate calls Curve Pool.
/// @dev Storage is local, execution takes place as fallback via delegate call.

contract ETHPoolDelegator {

    // _coins The addresses of coins in the pool
    // _balances The balances of above coins in the pool
    // fee Base swap fee of pool
    // admin_fee Percentage of base swap fee collected by DAO as admin fee
    // max_admin_fee Max admin fee permitted for this pool
    // owner The owner of the contract
    // token LP token for this pool
    // initial_A The initial A invariant
    // future_A The future A invariant
    // initial_A_time The number of rings from dendrochronological sample
    // future_A_time The number of rings from dendrochronological sample
    // admin_actions_deadline The deadline before pending changes have to be executed
    // transfer_ownership_deadline The deadline before pending ownership transfer has to be executed
    // future_fee The swap fee that would be set in the future
    // future_admin_fee The admin fee that would be set in the future
    // future_owner The owner in the future pending ownership transfer
    // kill_deadline The timestamp until which the pool can be killed
    // kill_deadline_dt Used to set kill_deadline
    // is_killed Is the contract killled? Only withdrawals permitted.
    
    address[] public _coins;
    uint256[] public _balances;
    uint256 public fee;
    uint256 public admin_fee;
    uint256 constant max_admin_fee = 5 * 10 ** 9;
    address public owner;
    address token;

    uint256 public initial_A;
    uint256 public future_A;
    uint256 public initial_A_time;
    uint256 public future_A_time;
    
    uint256 public admin_actions_deadline;
    uint256 public transfer_ownership_deadline;
    
    uint256 public future_fee;
    uint256 public future_admin_fee;
    address public future_owner;
    
    bool is_killed;
    uint256 kill_deadline;
    uint256 constant kill_deadline_dt = 2 * 30 * 86400;

    
    constructor(
        address _owner,
        address[2] memory coins_,
        address _lp_token,
        uint256 _A,
        uint256 _fee,
        uint256 _adminFee
    ) public {
        for (uint i = 0; i < 2; i++) {
            require(coins_[i] != address(0));
            _balances.push(0);
            _coins.push(coins_[i]);
        }
        initial_A = _A;
        future_A = _A;
        fee = _fee;
        admin_fee = _adminFee;
        owner = _owner;
        kill_deadline = block.timestamp + kill_deadline_dt;
        is_killed = false;
        token = _lp_token;
    }
    
    //Returns balances of a certain coin selected by index
    function balances(int128 i) public view returns (uint256) {
        return _balances[uint256(i)];
    }
    
    //Returns address of the coin
    function coins(int128 i) public view returns (address) {
        return _coins[uint256(i)];
    }

    fallback() external payable {
        address _target = 0xc5424B857f758E906013F3555Dad202e4bdB4567; //Curve Contract on ETH Mainnet to be Delegate Called

        assembly {
            let ptr := mload(0x40)
            calldatacopy(ptr, 0x0, calldatasize())
            let _retval := delegatecall(
                gas(),
                _target,
                ptr,
                calldatasize(),
                0,
                0
            )
            returndatacopy(ptr, 0, returndatasize())

            switch _retval
                case 0 {
                    revert(ptr, returndatasize())
                }
                default {
                    return(ptr, returndatasize())
                }
        }
    }
}",887
RealWorld_BA_51_PublicSaleBatchWithdraw_RealWord_20240821020303.log,51,PublicSaleBatchWithdraw,9091,5210,14301,99.0,0.149655,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @notice Vether (vetherasset.io) contract for Public Sale Batch Withdrawals
 * @author Vether (vetherasset.io)
 */

interface BootTGE {

    function withdrawShareForMember(uint era, uint day, address member) external returns (uint value);

    function getDaysContributedForEra(address member, uint era) external view returns(uint);

    function mapMemberEra_Days(address member, uint era, uint day) external view returns(uint);
}

/**
 * @title BatchWithdraw
 */
contract BatchWithdraw {
    address tgeContract; //Contract address of PublicSale.sol
    constructor (address _tgeContract) {
        require(address(_tgeContract) != address(0), ""Invalid address"");
        tgeContract = _tgeContract;
    }

    function batchWithdraw(uint era, uint[] memory arrayDays, address member) public {
        for (uint i = 0; i < arrayDays.length; i++) {
            BootTGE(tgeContract).withdrawShareForMember(era, arrayDays[i], member);
        }
    }

    function withdrawAll(uint era, address member) public {
        uint length = BootTGE(tgeContract).getDaysContributedForEra(member, era);
        for (uint i = 0; i < length; i++) {
            uint day = BootTGE(tgeContract).mapMemberEra_Days(member, era, i);
            BootTGE(tgeContract).withdrawShareForMember(era, day, member);
        }
    }
}",337
RealWorld_BA_51_BTCPoolDelegator_RealWord_20240821013400.log,51,BTCPoolDelegator,17332,5690,23022,143.0,0.20046,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.8;
pragma experimental ABIEncoderV2;

/// @title BTC Pool Delegator
/// @author John Deere
/// @notice BTC Liquidity Pool that delegate calls Curve Pool.
/// @dev Storage is local, execution takes place as fallback via delegate call.

contract BTCPoolDelegator {

    // _coins The addresses of coins in the pool
    // _balances The balances of above coins in the pool
    // fee Base swap fee of pool
    // admin_fee Percentage of base swap fee collected by DAO as admin fee
    // max_admin_fee Max admin fee permitted for this pool
    // owner The owner of the contract
    // token LP token for this pool
    // initial_A The initial A invariant
    // future_A The future A invariant
    // initial_A_time The number of rings from dendrochronological sample
    // future_A_time The number of rings from dendrochronological sample
    // admin_actions_deadline The deadline before pending changes have to be executed
    // transfer_ownership_deadline The deadline before pending ownership transfer has to be executed
    // future_fee The swap fee that would be set in the future
    // future_admin_fee The admin fee that would be set in the future
    // future_owner The owner in the future pending ownership transfer
    // kill_deadline The timestamp until which the pool can be killed
    // kill_deadline_dt Used to set kill_deadline
    // is_killed Is the contract killled? Only withdrawals permitted.

    address[] public _coins;
    uint256[] public _balances;
    uint256 public fee;
    uint256 public admin_fee;
    uint256 constant max_admin_fee = 5 * 10 ** 9;
    address public owner;
    address token;

    uint256 public initial_A;
    uint256 public future_A;
    uint256 public initial_A_time;
    uint256 public future_A_time;

    uint256 public admin_actions_deadline;
    uint256 public transfer_ownership_deadline;

    uint256 public future_fee;
    uint256 public future_admin_fee;
    address public future_owner;

    uint256 kill_deadline;
    uint256 constant kill_deadline_dt = 2 * 30 * 86400;
    bool is_killed;

    constructor(
        address _owner,
        address[3] memory coins_,
        address _lp_token,
        uint256 _A,
        uint256 _init_fee,
        uint256 _admin_fee
    ) public {
        for (uint256 i = 0; i < 3; i++) {
            require(coins_[i] != address(0));
            _balances.push(0);
            _coins.push(coins_[i]);
        }

        initial_A = _A;
        future_A = _A;
        fee = _init_fee;
        admin_fee = _admin_fee;
        owner = _owner;
        kill_deadline = block.timestamp + kill_deadline_dt;
        is_killed = false;
        token = _lp_token;
    }

    // receive() external payable {}


    //Returns balances of a certain coin selected by index
    function balances(int128 i) public view returns (uint256) {
        return _balances[uint256(i)];
    }


    //Returns address of the coin
    function coins(int128 i) public view returns (address) {
        return _coins[uint256(i)];
    }

    fallback() external payable {
        address _target = 0x7fC77b5c7614E1533320Ea6DDc2Eb61fa00A9714; //Curve Contract on ETH Mainnet to be Delegate Called

        assembly {
            let ptr := mload(0x40)
            calldatacopy(ptr, 0x0, calldatasize())
            let _retval := delegatecall(
                gas(),
                _target,
                ptr,
                calldatasize(),
                0,
                0
            )
            returndatacopy(ptr, 0, returndatasize())

            switch _retval
                case 0 {
                    revert(ptr, returndatasize())
                }
                default {
                    return(ptr, returndatasize())
                }
        }
    }
}",896
RealWorld_BA_51_TestSwapReturnValues_RealWord_20240821014954.log,51,TestSwapReturnValues,20901,5729,26630,108.0,0.219085,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""../../interfaces/ISwap.sol"";
import ""../../hardhat/console.sol"";

contract TestSwapReturnValues {
    using SafeMath for uint256;

    ISwap public swap;
    IERC20 public lpToken;
    uint8 public n;

    uint256 public constant MAX_INT = 2**256 - 1;

    constructor(
        ISwap swapContract,
        IERC20 lpTokenContract,
        uint8 numOfTokens
    ) public {
        swap = swapContract;
        lpToken = lpTokenContract;
        n = numOfTokens;

        // Pre-approve tokens
        for (uint8 i; i < n; i++) {
            swap.getToken(i).approve(address(swap), MAX_INT);
        }
        lpToken.approve(address(swap), MAX_INT);
    }

    function test_swap(
        uint8 tokenIndexFrom,
        uint8 tokenIndexTo,
        uint256 dx,
        uint256 minDy
    ) public {
        uint256 balanceBefore =
            swap.getToken(tokenIndexTo).balanceOf(address(this));
        uint256 returnValue =
            swap.swap(tokenIndexFrom, tokenIndexTo, dx, minDy, block.timestamp);
        uint256 balanceAfter =
            swap.getToken(tokenIndexTo).balanceOf(address(this));

        console.log(
            ""swap: Expected %s, got %s"",
            balanceAfter.sub(balanceBefore),
            returnValue
        );

        require(
            returnValue == balanceAfter.sub(balanceBefore),
            ""swap()'s return value does not match received amount""
        );
    }

    function test_addLiquidity(
        uint256[] calldata amounts,
        uint256 minToMint
        // bytes32[] calldata merkleProof
    ) public {
        uint256 balanceBefore = lpToken.balanceOf(address(this));       // -> 0
/*        console.log(
            ""balance before: %s,"",
            balanceBefore
        );
*/      
        uint256 returnValue =
            swap.addLiquidity(amounts, minToMint, MAX_INT/*, merkleProof*/);
        uint256 balanceAfter = lpToken.balanceOf(address(this));        // -> 2997459774673651937
/*        console.log(
            ""balance after: %s,"",
            balanceAfter
        );
*/
        console.log(
            ""addLiquidity: Expected %s, got %s"",
            balanceAfter.sub(balanceBefore),
            returnValue
        );

        require(
            returnValue == balanceAfter.sub(balanceBefore),
            ""addLiquidity()'s return value does not match minted amount""
        );
    }

    function test_removeLiquidity(uint256 amount, uint256[] memory minAmounts)
        public
    {
        uint256[] memory balanceBefore = new uint256[](n);
        uint256[] memory balanceAfter = new uint256[](n);

        for (uint8 i = 0; i < n; i++) {
            balanceBefore[i] = swap.getToken(i).balanceOf(address(this));
        }

        uint256[] memory returnValue =
            swap.removeLiquidity(amount, minAmounts, MAX_INT);

        for (uint8 i = 0; i < n; i++) {
            balanceAfter[i] = swap.getToken(i).balanceOf(address(this));
            console.log(
                ""removeLiquidity: Expected %s, got %s"",
                balanceAfter[i].sub(balanceBefore[i]),
                returnValue[i]
            );
            require(
                balanceAfter[i].sub(balanceBefore[i]) == returnValue[i],
                ""removeLiquidity()'s return value does not match received amounts of tokens""
            );
        }
    }

    function test_removeLiquidityImbalance(
        uint256[] calldata amounts,
        uint256 maxBurnAmount
    ) public {
        uint256 balanceBefore = lpToken.balanceOf(address(this));
        uint256 returnValue =
            swap.removeLiquidityImbalance(amounts, maxBurnAmount, MAX_INT);
        uint256 balanceAfter = lpToken.balanceOf(address(this));

        console.log(
            ""removeLiquidityImbalance: Expected %s, got %s"",
            balanceBefore.sub(balanceAfter),
            returnValue
        );

        require(
            returnValue == balanceBefore.sub(balanceAfter),
            ""removeLiquidityImbalance()'s return value does not match burned lpToken amount""
        );
    }

    function test_removeLiquidityOneToken(
        uint256 tokenAmount,
        uint8 tokenIndex,
        uint256 minAmount
    ) public {
        uint256 balanceBefore =
            swap.getToken(tokenIndex).balanceOf(address(this));
        uint256 returnValue =
            swap.removeLiquidityOneToken(
                tokenAmount,
                tokenIndex,
                minAmount,
                MAX_INT
            );
        uint256 balanceAfter =
            swap.getToken(tokenIndex).balanceOf(address(this));

        console.log(
            ""removeLiquidityOneToken: Expected %s, got %s"",
            balanceAfter.sub(balanceBefore),
            returnValue
        );

        require(
            returnValue == balanceAfter.sub(balanceBefore),
            ""removeLiquidityOneToken()'s return value does not match received token amount""
        );
    }
}",1079
RealWorld_BA_51_Vesting_RealWord_20240821015616.log,51,Vesting,36754,6051,42805,102.0,0.30479,"//SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

/**
 * @summary: Vesting contract that serves as an escrow for tokens to be locked (70% of all allocations)
 * @author: Boot Finance
 */

import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/security/Pausable.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/utils/math/SafeMath.sol';

/// @title Vesting Contract
/// @dev Any address can vest tokens into this contract with amount, releaseTimestamp, revocable.
///      Anyone can claim tokens (if unlocked as per the schedule).

contract Vesting is Ownable, Pausable, ReentrancyGuard {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    // State variables===================================================================================
    IERC20 public vestingToken;
    address public multiSig;

    // uint256 public maxVestingAmount;
    uint256 public totalVestedAmount;
    uint256 public totalClaimedAmount;
    uint256 private unixYear = 52 * 7 * 24 * 60 * 60;

    struct Timelock {
        uint256 amount;
        uint256 releaseTimestamp;
    }

    mapping(address => Timelock[]) public timelocks;
    mapping(address => uint256) public benClaimed;      //total tokens claimed
    mapping(address => uint256[2]) public benVested;       //total tokens vested
    mapping(address => uint256) public benTotal;        //total locked in contract for user
    mapping(address => uint256) public benVestingIndex;     //index to start the for loop for the user ignoring completely vested timelock

    // map revocability at address level vs individual timelock
    mapping(address => bool[2]) public benRevocable;         // key: beneficiary address, value: revokeTimestamp

    // ===============EVENTS============================================================================================
    event TokenVested(address indexed sender, uint256 amount, uint256 releaseTimestamp, uint256 currentTimestamp);
    event TokenClaimed(address indexed beneficiary, uint256 amount, uint256 currentTimestamp);
    event TokenRevoked(address indexed beneficiary, uint256 amount, uint256 currentTimestamp);
    event Revoke(address indexed account, uint256 currentTimestamp);

    //================CONSTRUCTOR================================================================
    /// @notice Constructor
    /// @param _token ERC20 token
    constructor(
        IERC20 _token,
        address _multiSig
    ) {
        require(address(_token) != address(0) && address(_multiSig) != address(0), ""Invalid address"");
        vestingToken = _token;
        multiSig = _multiSig;

        totalVestedAmount = 0;
        totalClaimedAmount = 0;
    }
    

    //=================FUNCTIONS=================================================================
    /// @notice Vest function accessed by anyone
    /// @param _beneficiary beneficiary address
    /// @param _amount vesting amount
    /// @param _isRevocable revocable value either 0 or 1
    function vest(address _beneficiary, uint256 _amount, uint256 _isRevocable) external payable whenNotPaused {
        require(_beneficiary != address(0), ""Invalid address"");
        require( _amount > 0, ""amount must be positive"");
        // require(totalVestedAmount.add(_amount) <= maxVestingAmount, 'maxVestingAmount is already vested');
        require(_isRevocable == 0 || _isRevocable == 1, ""revocable must be 0 or 1"");
        uint256 _unlockTimestamp = block.timestamp.add(unixYear);

        Timelock memory newVesting = Timelock(_amount, _unlockTimestamp);
        timelocks[_beneficiary].push(newVesting);

        if(_isRevocable == 0){
            benRevocable[_beneficiary] = [false,false];
        }
        else if(_isRevocable == 1){
            benRevocable[_beneficiary] = [true,false];
        }

        totalVestedAmount = totalVestedAmount.add(_amount);
        benTotal[_beneficiary] = benTotal[_beneficiary].add(_amount);

        // transfer to SC using delegate transfer
        // NOTE: the tokens has to be approved first by the caller to the SC using `approve()` method.
        vestingToken.transferFrom(msg.sender, address(this), _amount);

        emit TokenVested(_beneficiary, _amount, _unlockTimestamp, block.timestamp);
    }

    // ------------------------------------------------------------------------------------------
    /// @notice Revoke vesting
    /// @param _addr beneficiary address

    function revoke(address _addr) public onlyOwner whenNotPaused {
        require(benRevocable[_addr][0] == true && benRevocable[_addr][1] == false, 'Account must be revokable and not already revoked.');

        uint256 amount = _claimableAmount(_addr).sub(benClaimed[_addr]);
        assert(amount <= benTotal[_addr]);
    
        benClaimed[_addr] = benClaimed[_addr].add(amount);
        totalClaimedAmount = totalClaimedAmount.add(amount);

        emit TokenClaimed(_addr, amount, block.timestamp);

        uint256 locked = 0;
        for (uint256 i = 0; i < timelocks[_addr].length; i++) {
            locked = locked.add(timelocks[_addr][i].amount);
        }
        delete timelocks[_addr];

        uint256 bal = locked.sub(benClaimed[_addr]);
        benRevocable[_addr][1] = true;
        emit Revoke(_addr, block.timestamp);
        
        //clean slate
        benClaimed[_addr] = 0;
        benVested[_addr] = [0, 0];
        benTotal[_addr] = 0;
        benVestingIndex[_addr] = 0;
        
        vestingToken.safeTransfer(_addr, amount); //send vested

        if (bal > 0) {
            vestingToken.safeTransfer(multiSig, bal); //send revoked to multisig
            emit TokenRevoked(_addr, bal, block.timestamp);
        }
    }

    // ------------------------------------------------------------------------------------------
    /// @notice Calculate claimable amount for a beneficiary
    /// @param _addr beneficiary address
    function calcClaimableAmount(address _addr) public view returns (uint256) {
        uint256 sum = 0;

        // iterate across all the vestings
        // & check if the releaseTimestamp is elapsed
        // then, add all the amounts as claimable amount
        for (uint256 i = 0; i < timelocks[_addr].length; i++) {
            if (block.timestamp >= timelocks[_addr][i].releaseTimestamp) {
                sum = sum.add(timelocks[_addr][i].amount);
            }
            else {
                uint256 iTimeStamp = timelocks[_addr][i].releaseTimestamp.sub(unixYear);
                uint256 claimable = block.timestamp.sub(iTimeStamp).mul(timelocks[_addr][i].amount).div(unixYear);
                sum = sum.add(claimable);
            }
        }
        return sum;
    }
    
    //Calculate amount claimable by a particular address
    function _claimableAmount(address _addr) private returns (uint256) {
        uint256 completely_vested = 0;
        uint256 partial_sum = 0;
        uint256 inc = 0;

        // iterate across all the vestings
        // & check if the releaseTimestamp is elapsed
        // then, add all the amounts as claimable amount
        for (uint256 i = benVestingIndex[_addr]; i < timelocks[_addr].length; i++) {
            if (block.timestamp >= timelocks[_addr][i].releaseTimestamp) {
                inc += 1;
                completely_vested = completely_vested.add(timelocks[_addr][i].amount);
            }
            else {
                uint256 iTimeStamp = timelocks[_addr][i].releaseTimestamp.sub(unixYear);
                uint256 claimable = block.timestamp.sub(iTimeStamp).mul(timelocks[_addr][i].amount).div(unixYear);
                partial_sum = partial_sum.add(claimable);
            }
        }

        benVestingIndex[_addr] +=inc;
        benVested[_addr][0] = benVested[_addr][0].add(completely_vested);
        benVested[_addr][1] = partial_sum;
        uint256 s = benVested[_addr][0].add(partial_sum);
        assert(s <= benTotal[_addr]);
        return s;
    }

    // ------------------------------------------------------------------------------------------
    /// @notice Claim vesting
    /// Beneficiary can claim claimableAmount which was vested
    function claim() external whenNotPaused nonReentrant {
        require(benRevocable[msg.sender][1] == false, 'Account must not already be revoked.');
        uint256 amount = _claimableAmount(msg.sender).sub(benClaimed[msg.sender]);
        require(amount > 0, ""Claimable amount must be positive"");
        require(amount <= benTotal[msg.sender], ""Cannot withdraw more than total vested amount"");

        // transfer from SC
        benClaimed[msg.sender] = benClaimed[msg.sender].add(amount);
        totalClaimedAmount = totalClaimedAmount.add(amount);
        vestingToken.safeTransfer(msg.sender, amount);

        emit TokenClaimed(msg.sender, amount, block.timestamp);
    }

    // ------------------------------------------------------------------------------------------
    /// @notice Pause contract 
    function pause() public onlyOwner whenNotPaused {
        _pause();
    }

    /// @notice Unpause contract
    function unpause() public onlyOwner whenPaused {
        _unpause();
    }
}",2102
RealWorld_BA_51_OwnerPausable_RealWord_20240821013947.log,51,OwnerPausable,5837,4958,10795,82.0,0.128345,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/Pausable.sol"";

/**
 * @title OwnerPausable
 * @notice An ownable contract allows the owner to pause and unpause the
 * contract without a delay.
 * @dev Only methods using the provided modifiers will be paused.
 */
contract OwnerPausable is Ownable, Pausable {
    /**
     * @notice Pause the contract. Revert if already paused.
     */
    function pause() external onlyOwner {
        Pausable._pause();
    }

    /**
     * @notice Unpause the contract. Revert if already unpaused.
     */
    function unpause() external onlyOwner {
        Pausable._unpause();
    }
}",176
RealWorld_BA_52_USDV_RealWord_20240821103518.log,52,USDV,7841,5406,13247,74.0,0.147325,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../shared/ProtocolConstants.sol"";

import ""../interfaces/tokens/IUSDV.sol"";
import ""../interfaces/reserve/IVaderReserve.sol"";

// TBD
contract USDV is IUSDV, ProtocolConstants, ERC20, Ownable {
    /* ========== STATE VARIABLES ========== */

    IERC20 public immutable vader;
    IVaderReserve public immutable reserve;

    /* ========== CONSTRUCTOR ========== */

    constructor(IERC20 _vader, IVaderReserve _reserve)
        ERC20(""Vader USD"", ""USDV"")
    {
        require(
            _reserve != IVaderReserve(_ZERO_ADDRESS),
            ""USDV::constructor: Incorrect Arguments""
        );
        vader = _vader;
        reserve = _reserve;
    }

    /* ========== VIEWS ========== */

    /* ========== MUTATIVE FUNCTIONS ========== */

    function distributeEmission() external override {
        // TODO: Adjust when incentives clearly defined
        uint256 balance = vader.balanceOf(address(this));
        vader.transfer(address(reserve), balance);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    /* ========== INTERNAL FUNCTIONS ========== */

    /* ========== PRIVATE FUNCTIONS ========== */

    /* ========== MODIFIERS ========== */
}",291
RealWorld_BA_52_VaderReserve_RealWord_20240821101234.log,52,VaderReserve,13359,5675,19034,91.0,0.180295,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""../shared/ProtocolConstants.sol"";

import ""../interfaces/reserve/IVaderReserve.sol"";

contract VaderReserve is IVaderReserve, ProtocolConstants, Ownable {
    /* ========== LIBRARIES ========== */

    // Used for safe VADER transfers
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    // The Vader token the reserve is handling
    IERC20 public immutable vader;

    // Router address for IL awards
    address public router;

    // Tracks last grant time for throttling
    uint256 public lastGrant;

    /* ========== CONSTRUCTOR ========== */

    constructor(
        IERC20 _vader
    ) {
        require(
            _vader != IERC20(_ZERO_ADDRESS),
            ""VaderReserve::constructor: Incorrect Arguments""
        );
        vader = _vader;
    }

    /* ========== VIEWS ========== */

    function reserve() public view override returns (uint256) {
        return vader.balanceOf(address(this));
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function grant(address recipient, uint256 amount)
        external
        override
        onlyOwner
        throttle
    {
        amount = _min(
            (reserve() * _MAX_GRANT_BASIS_POINTS) / _MAX_BASIS_POINTS,
            amount
        );
        vader.safeTransfer(recipient, amount);

        emit GrantDistributed(recipient, amount);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function initialize(address _router, address _dao) external onlyOwner {
         require(
            _router != _ZERO_ADDRESS &&
                _dao != _ZERO_ADDRESS,
            ""VaderReserve::initialize: Incorrect Arguments""
        );
        router = _router;
        transferOwnership(_dao);
    }

    function reimburseImpermanentLoss(address recipient, uint256 amount)
        external
        override
    {
        require(
            msg.sender == router,
            ""VaderReserve::reimburseImpermanentLoss: Insufficient Priviledges""
        );

        uint256 actualAmount = _min(reserve(), amount);

        vader.safeTransfer(recipient, actualAmount);

        emit LossCovered(recipient, amount, actualAmount);
    }

    /* ========== INTERNAL FUNCTIONS ========== */

    /* ========== PRIVATE FUNCTIONS ========== */

    /**
     * @dev Calculates the minimum of the two values
     */
    function _min(uint256 a, uint256 b) private pure returns (uint256) {
        return a < b ? a : b;
    }

    /* ========== MODIFIERS ========== */

    modifier throttle() {
        require(
            lastGrant + _GRANT_DELAY <= block.timestamp,
            ""VaderReserve::throttle: Grant Too Fast""
        );
        lastGrant = block.timestamp;
        _;
    }
}",627
RealWorld_BA_52_IVaderPoolV2_RealWord_20240821104801.log,52,IVaderPoolV2,9317,5606,14923,88.0,0.158705,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./IBasePoolV2.sol"";

interface IVaderPoolV2 is IBasePoolV2, IERC721 {
    /* ========== STRUCTS ========== */
    /* ========== FUNCTIONS ========== */

    function cumulativePrices(
        IERC20 foreignAsset
    ) external view returns (
        uint256 price0CumulativeLast,
        uint256 price1CumulativeLast,
        uint32 blockTimestampLast
    );

    function mintSynth(
        IERC20 foreignAsset,
        uint256 nativeDeposit,
        address from,
        address to
    ) external returns (uint256 amountSynth);

    function burnSynth(
        IERC20 foreignAsset,
        uint256 synthAmount,
        address to
    ) external returns (uint256 amountNative);

    function mintFungible(
        IERC20 foreignAsset,
        uint256 nativeDeposit,
        uint256 foreignDeposit,
        address from,
        address to
    ) external returns (uint256 liquidity);

    function burnFungible(
        IERC20 foreignAsset,
        uint256 liquidity,
        address to
    ) external returns (uint256 amountNative, uint256 amountForeign);

    function burn(uint256 id, address to)
        external
        returns (
            uint256 amountNative,
            uint256 amountForeign,
            uint256 coveredLoss
        );

    function toggleQueue() external;

    function setTokenSupport(IERC20 foreignAsset, bool support) external;

    function setFungibleTokenSupport(IERC20 foreignAsset) external;

    /* ========== EVENTS ========== */

    event QueueActive(bool activated);
}",376
RealWorld_BA_52_VaderBond_RealWord_20240821111033.log,52,VaderBond,58504,5256,63760,77.0,0.39764,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity 0.7.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"";
import ""./interfaces/IERC20Metadata.sol"";
import ""./interfaces/ITreasury.sol"";
// import ""./lib/FixedPoint.sol"";
import ""./Ownable.sol"";

contract VaderBond is Ownable, ReentrancyGuard {
    // using FixedPoint for FixedPoint.uq112x112;
    using SafeERC20 for IERC20;
    using SafeMath for uint;

    enum PARAMETER {
        VESTING,
        PAYOUT,
        DEBT
    }

    event SetBondTerms(PARAMETER indexed param, uint input);
    event SetAdjustment(bool add, uint rate, uint target, uint buffer);
    event BondCreated(uint deposit, uint payout, uint expires);
    event BondRedeemed(address indexed recipient, uint payout, uint remaining);
    event BondPriceChanged(uint internalPrice, uint debtRatio);
    event ControlVariableAdjustment(uint initialBCV, uint newBCV, uint adjustment, bool addition);
    event TreasuryChanged(address treasury);

    uint8 private immutable PRINCIPAL_TOKEN_DECIMALS;
    uint8 private constant PAYOUT_TOKEN_DECIMALS = 18; // Vader has 18 decimals
    uint private constant MIN_PAYOUT = 10**PAYOUT_TOKEN_DECIMALS / 100; // 0.01
    uint private constant MAX_PERCENT_VESTED = 1e4; // 1 = 0.01%, 10000 = 100%
    uint private constant MAX_PAYOUT_DENOM = 1e5; // 100 = 0.1%, 100000 = 100%

    IERC20 public immutable payoutToken; // token paid for principal
    IERC20 public immutable principalToken; // inflow token
    ITreasury public treasury; // pays for and receives principal

    Terms public terms; // stores terms for new bonds
    Adjust public adjustment; // stores adjustment to BCV data

    mapping(address => Bond) public bondInfo; // stores bond information for depositors

    uint public totalDebt; // total value of outstanding bonds; used for pricing
    uint public lastDecay; // reference block for debt decay

    // Info for creating new bonds
    struct Terms {
        uint controlVariable; // scaling variable for price
        uint vestingTerm; // in blocks
        uint minPrice; // vs principal value
        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%
        uint maxDebt; // max debt, same decimals with payout token
    }
    // Info for bond holder
    struct Bond {
        uint payout; // payout token remaining to be paid
        uint vesting; // Blocks left to vest
        uint lastBlock; // Last interaction
    }
    // Info for incremental adjustments to control variable
    struct Adjust {
        bool add; // addition or subtraction
        uint rate; // increment
        uint target; // BCV when adjustment finished
        uint buffer; // minimum length (in blocks) between adjustments
        uint lastBlock; // block when last adjustment made
    }

    constructor(
        address _treasury,
        address _payoutToken,
        address _principalToken
    ) {
        require(_treasury != address(0), ""treasury = zero"");
        treasury = ITreasury(_treasury);
        require(_payoutToken != address(0), ""payout token = zero"");
        payoutToken = IERC20(_payoutToken);
        require(_principalToken != address(0), ""principal token = zero"");
        principalToken = IERC20(_principalToken);

        PRINCIPAL_TOKEN_DECIMALS = IERC20Metadata(_principalToken).decimals();
    }

    /**
     *  @notice initializes bond parameters
     *  @param _controlVariable uint
     *  @param _vestingTerm uint
     *  @param _minPrice uint
     *  @param _maxPayout uint
     *  @param _maxDebt uint
     *  @param _initialDebt uint
     */
    function initializeBond(
        uint _controlVariable,
        uint _vestingTerm,
        uint _minPrice,
        uint _maxPayout,
        uint _maxDebt,
        uint _initialDebt
    ) external onlyOwner {
        require(terms.controlVariable == 0, ""initialized"");

        require(_controlVariable > 0, ""cv = 0"");
        // roughly 36 hours (262 blocks / hour)
        require(_vestingTerm >= 10000, ""vesting < 10000"");
        // max payout must be < 1% of total supply of payout token
        require(_maxPayout <= MAX_PAYOUT_DENOM / 100, ""max payout > 1%"");

        terms = Terms({
            controlVariable: _controlVariable,
            vestingTerm: _vestingTerm,
            minPrice: _minPrice,
            maxPayout: _maxPayout,
            maxDebt: _maxDebt
        });

        totalDebt = _initialDebt;
        lastDecay = block.number;
    }

    /**
     *  @notice set parameters for new bonds
     *  @param _param PARAMETER
     *  @param _input uint
     */
    function setBondTerms(PARAMETER _param, uint _input) external onlyOwner {
        if (_param == PARAMETER.VESTING) {
            // roughly 36 hours (262 blocks / hour)
            require(_input >= 10000, ""vesting < 10000"");
            terms.vestingTerm = _input;
        } else if (_param == PARAMETER.PAYOUT) {
            // max payout must be < 1% of total supply of payout token
            require(_input <= MAX_PAYOUT_DENOM / 100, ""max payout > 1%"");
            terms.maxPayout = _input;
        } else if (_param == PARAMETER.DEBT) {
            terms.maxDebt = _input;
        }
        emit SetBondTerms(_param, _input);
    }

    /**
     *  @notice set control variable adjustment
     *  @param _add bool
     *  @param _rate uint
     *  @param _target uint
     *  @param _buffer uint
     */
    function setAdjustment(
        bool _add,
        uint _rate,
        uint _target,
        uint _buffer
    ) external onlyOwner {
        require(_rate <= terms.controlVariable.mul(3) / 100, ""rate > 3%"");
        adjustment = Adjust({add: _add, rate: _rate, target: _target, buffer: _buffer, lastBlock: block.number});
        emit SetAdjustment(_add, _rate, _target, _buffer);
    }

    /**
     *  @notice deposit bond
     *  @param _amount uint
     *  @param _maxPrice uint
     *  @param _depositor address
     *  @return uint
     *  @dev Deposit resets vesting term for _depositor
     */
    function deposit(
        uint _amount,
        uint _maxPrice,
        address _depositor
    ) external nonReentrant returns (uint) {
        require(_depositor != address(0), ""depositor = zero"");

        decayDebt();
        require(totalDebt <= terms.maxDebt, ""max debt"");
        require(_maxPrice >= bondPrice(), ""bond price > max"");

        uint value = treasury.valueOfToken(address(principalToken), _amount);
        uint payout = payoutFor(value);

        require(payout >= MIN_PAYOUT, ""payout < min"");
        // size protection because there is no slippage
        require(payout <= maxPayout(), ""payout > max"");

        principalToken.safeTransferFrom(msg.sender, address(this), _amount);
        principalToken.approve(address(treasury), _amount);
        treasury.deposit(address(principalToken), _amount, payout);

        totalDebt = totalDebt.add(value);

        bondInfo[_depositor] = Bond({
            payout: bondInfo[_depositor].payout.add(payout),
            vesting: terms.vestingTerm,
            lastBlock: block.number
        });

        emit BondCreated(_amount, payout, block.number.add(terms.vestingTerm));

        uint price = bondPrice();
        // remove floor if price above min
        if (price > terms.minPrice && terms.minPrice > 0) {
            terms.minPrice = 0;
        }

        emit BondPriceChanged(price, debtRatio());

        adjust(); // control variable is adjusted
        return payout;
    }

    /**
     *  @notice redeem bond for user
     *  @return uint
     */
    function redeem(address _depositor) external nonReentrant returns (uint) {
        Bond memory info = bondInfo[_depositor];
        uint percentVested = percentVestedFor(_depositor); // (blocks since last interaction / vesting term remaining)

        if (percentVested >= MAX_PERCENT_VESTED) {
            // if fully vested
            delete bondInfo[_depositor]; // delete user info
            emit BondRedeemed(_depositor, info.payout, 0); // emit bond data
            payoutToken.transfer(_depositor, info.payout);
            return info.payout;
        } else {
            // if unfinished
            // calculate payout vested
            uint payout = info.payout.mul(percentVested) / MAX_PERCENT_VESTED;

            // store updated deposit info
            bondInfo[_depositor] = Bond({
                payout: info.payout.sub(payout),
                vesting: info.vesting.sub(block.number.sub(info.lastBlock)),
                lastBlock: block.number
            });

            emit BondRedeemed(_depositor, payout, bondInfo[_depositor].payout);
            payoutToken.transfer(_depositor, payout);
            return payout;
        }
    }

    /**
     *  @notice makes incremental adjustment to control variable
     */
    function adjust() private {
        uint blockCanAdjust = adjustment.lastBlock.add(adjustment.buffer);
        if (adjustment.rate != 0 && block.number >= blockCanAdjust) {
            uint initial = terms.controlVariable;
            if (adjustment.add) {
                terms.controlVariable = terms.controlVariable.add(adjustment.rate);
                if (terms.controlVariable >= adjustment.target) {
                    adjustment.rate = 0;
                }
            } else {
                terms.controlVariable = terms.controlVariable.sub(adjustment.rate);
                if (terms.controlVariable <= adjustment.target) {
                    adjustment.rate = 0;
                }
            }
            adjustment.lastBlock = block.number;
            emit ControlVariableAdjustment(initial, terms.controlVariable, adjustment.rate, adjustment.add);
        }
    }

    /**
     *  @notice amount to decay total debt by
     *  @return decay uint
     */
    function debtDecay() public view returns (uint decay) {
        uint blocksSinceLast = block.number.sub(lastDecay);
        decay = totalDebt.mul(blocksSinceLast).div(terms.vestingTerm);
        if (decay > totalDebt) {
            decay = totalDebt;
        }
    }

    /**
     *  @notice reduce total debt
     */
    function decayDebt() private {
        totalDebt = totalDebt.sub(debtDecay());
        lastDecay = block.number;
    }

    /**
     *  @notice calculate debt factoring in decay
     *  @return uint
     */
    function currentDebt() public view returns (uint) {
        return totalDebt.sub(debtDecay());
    }

    /**
     *  @notice calculate current ratio of debt to payout token supply
     *  @notice protocols using DAO should be careful when quickly adding large %s to total supply
     *  @return uint
     */
    function debtRatio() public view returns (uint) {
        // TODO: use fraction?
        // return
        //     FixedPoint
        //         .fraction(currentDebt().mul(10**PAYOUT_TOKEN_DECIMALS), payoutToken.totalSupply())
        //         .decode112with18() / 1e18;
        // NOTE: debt ratio is scaled up by 1e18
        // NOTE: fails if payoutToken.totalSupply() == 0
        return currentDebt().mul(1e18).div(payoutToken.totalSupply());
    }

    /**
     *  @notice calculate current bond premium
     *  @return price uint
     *  @dev price = 10 ** principal token decimals = 1 principal token buys 1 bond
     */
    function bondPrice() public view returns (uint price) {
        // NOTE: debt ratio scaled up with 1e18, so divide by 1e18
        price = terms.controlVariable.mul(debtRatio()) / 1e18;
        if (price < terms.minPrice) {
            price = terms.minPrice;
        }
    }

    /**
     *  @notice determine maximum bond size
     *  @return uint
     */
    function maxPayout() public view returns (uint) {
        return payoutToken.totalSupply().mul(terms.maxPayout) / MAX_PAYOUT_DENOM;
    }

    /**
     *  @notice calculate total interest due for new bond
     *  @param _value uint
     *  @return uint
     */
    function payoutFor(uint _value) public view returns (uint) {
        // TODO: use fraction?
        // NOTE: scaled up by 1e7
        // return FixedPoint.fraction(_value, bondPrice()).decode112with18() / 1e11;

        /*
        B = amount of bond to payout
        A = amount of principal token in
        P = amount of principal token to pay to get 1 bond

        B = A / P
        */
        // NOTE: decimals of value must match payout token decimals
        // NOTE: bond price must match principal token decimals
        return _value.mul(10**PRINCIPAL_TOKEN_DECIMALS).div(bondPrice());
    }

    /**
     *  @notice calculate how far into vesting a depositor is
     *  @param _depositor address
     *  @return percentVested uint
     */
    function percentVestedFor(address _depositor) public view returns (uint percentVested) {
        Bond memory bond = bondInfo[_depositor];
        uint blocksSinceLast = block.number.sub(bond.lastBlock);
        uint vesting = bond.vesting;
        if (vesting > 0) {
            percentVested = blocksSinceLast.mul(MAX_PERCENT_VESTED).div(vesting);
        }
        // default percentVested = 0
    }

    /**
     *  @notice calculate amount of payout token available for claim by depositor
     *  @param _depositor address
     *  @return uint
     */
    function pendingPayoutFor(address _depositor) external view returns (uint) {
        uint percentVested = percentVestedFor(_depositor);
        uint payout = bondInfo[_depositor].payout;
        if (percentVested >= MAX_PERCENT_VESTED) {
            return payout;
        } else {
            return payout.mul(percentVested) / MAX_PERCENT_VESTED;
        }
    }

    /**
     *  @notice owner can update treasury address
     *  @param _treasury address
     *  @dev allow new treasury to be zero address
     */
    function setTreasury(address _treasury) external onlyOwner {
        require(_treasury != address(treasury), ""no change"");
        treasury = ITreasury(_treasury);
        emit TreasuryChanged(_treasury);
    }

    /**
     *  @notice allows owner to send lost tokens to owner
     *  @param _token address
     */
    function recoverLostToken(address _token) external onlyOwner {
        require(_token != address(principalToken), ""protected"");
        require(_token != address(payoutToken), ""protected"");
        IERC20(_token).safeTransfer(owner, IERC20(_token).balanceOf(address(this)));
    }
}",3502
RealWorld_BA_52_VaderRouter_RealWord_20240821101103.log,52,VaderRouter,60464,5606,66070,89.0,0.41444,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""../../shared/ProtocolConstants.sol"";

import ""../math/VaderMath.sol"";

import ""../../interfaces/reserve/IVaderReserve.sol"";
import ""../../interfaces/dex/router/IVaderRouter.sol"";
import ""../../interfaces/dex/pool/IVaderPoolFactory.sol"";

/*
 @dev Implementation of {VaderRouter} contract.
 *
 * The contract VaderRouter inherits from {Ownable} and {ProtocolConstants} contracts.
 *
 * It allows adding of liquidity to Vader pools and facilitate creation of Vader pools if
 * it does not already exist when depositing liquidity.
 *
 * Allows removing of liquidity by the users and claiming the underlying assets from
 * the Vader pools.
 *
 * Allows swapping between native and foreign assets within a single Vader pool.
 *
 * Allows swapping of foreign assets across two different Vader pools.
 *
 * Contains helper functions to compute the destination asset amount given the exact source
 * asset amount and vice versa.
 **/
contract VaderRouter is IVaderRouter, ProtocolConstants, Ownable {
    /* ========== LIBRARIES ========== */

    // Used for safe token transfers
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    // The address of Vader pool factory contract.
    IVaderPoolFactory public immutable factory;

    // The address of Reserve contract.
    IVaderReserve public reserve;

    /* ========== CONSTRUCTOR ========== */

    /*
     * @dev Initializes contract's state by setting the vader pool factory address.
     *
     * Requirements:
     * - Vader pool factory address must not be zero.
     **/
    constructor(IVaderPoolFactory _factory) {
        require(
            _factory != IVaderPoolFactory(_ZERO_ADDRESS),
            ""VaderRouter::constructor: Incorrect Arguments""
        );

        factory = _factory;
    }

    /* ========== VIEWS ========== */

    /* ========== MUTATIVE FUNCTIONS ========== */

    /*
     * @dev Allows adding of liquidity to the Vader pools.
     *
     * Internally calls {addLiquidity} function.
     *
     * Returns the amounts of assetA and assetB used in liquidity and
     * the amount of liquidity units minted.
     **/
    // NOTE: For Uniswap V2 compliancy, necessary due to stack too deep
    function addLiquidity(
        IERC20 tokenA,
        IERC20 tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256, // amountAMin = unused
        uint256, // amountBMin = unused
        address to,
        uint256 deadline
    )
        external
        override
        returns (
            uint256 amountA,
            uint256 amountB,
            uint256 liquidity
        )
    {
        return
            addLiquidity(
                tokenA,
                tokenB,
                amountADesired,
                amountBDesired,
                to,
                deadline
            );
    }

    /*
     * @dev Allows adding of liquidity to the Vader pools.
     *
     * Internally calls {_addLiquidity} function.
     *
     * Transfers the amounts of tokenA and tokenB from {msg.sender} to the pool.
     *
     * Calls the {mint} function on the pool to deposit liquidity on the behalf of
     * {to} address.
     *
     * Returns the amounts of assetA and assetB used in liquidity and
     * the amount of liquidity units minted.
     *
     * Requirements:
     * - The current timestamp has not exceeded the param {deadline}.
     **/
    function addLiquidity(
        IERC20 tokenA,
        IERC20 tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        address to,
        uint256 deadline
    )
        public
        override
        ensure(deadline)
        returns (
            uint256 amountA,
            uint256 amountB,
            uint256 liquidity
        )
    {
        IVaderPool pool;
        (pool, amountA, amountB) = _addLiquidity(
            address(tokenA),
            address(tokenB),
            amountADesired,
            amountBDesired
        );
        tokenA.safeTransferFrom(msg.sender, address(pool), amountA);
        tokenB.safeTransferFrom(msg.sender, address(pool), amountB);
        liquidity = pool.mint(to);
    }

    /*
     * @dev Allows removing of liquidity by {msg.sender} and transfers the
     * underlying assets to {to} address.
     *
     * Transfers the NFT with Id {id} representing user's position, to the pool address,
     * so the pool is able to burn it in the `burn` function call.
     *
     * Calls the `burn` function on the pool contract.
     *
     * Calls the `reimburseImpermanentLoss` on reserve contract to cover impermanent loss
     * for the liquidity being removed.
     *
     * Requirements:
     * - The underlying assets amounts of {amountA} and {amountB} must
     *   be greater than or equal to {amountAMin} and {amountBMin}, respectively.
     * - The current timestamp has not exceeded the param {deadline}.
     **/
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 id,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    )
        public
        override
        ensure(deadline)
        returns (uint256 amountA, uint256 amountB)
    {
        IVaderPool pool = factory.getPool(tokenA, tokenB);

        pool.transferFrom(msg.sender, address(pool), id);

        (
            uint256 amountNative,
            uint256 amountForeign,
            uint256 coveredLoss
        ) = pool.burn(id, to);

        (amountA, amountB) = tokenA == factory.nativeAsset()
            ? (amountNative, amountForeign)
            : (amountForeign, amountNative);

        require(
            amountA >= amountAMin,
            ""UniswapV2Router: INSUFFICIENT_A_AMOUNT""
        );
        require(
            amountB >= amountBMin,
            ""UniswapV2Router: INSUFFICIENT_B_AMOUNT""
        );

        reserve.reimburseImpermanentLoss(msg.sender, coveredLoss);
    }

    /*
     * @dev Allows swapping of exact source token amount to destination
     * token amount.
     *
     * Internally calls {_swap} function.
     *
     * Requirements:
     * - The destination amount {amountOut} must greater than or equal to param {amountOutMin}.
     * - The current timestamp has not exceeded the param {deadline}.
     **/
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external virtual override ensure(deadline) returns (uint256 amountOut) {
        amountOut = _swap(amountIn, path, to);

        require(
            amountOut >= amountOutMin,
            ""VaderRouter::swapExactTokensForTokens: Insufficient Trade Output""
        );
    }

    /*
     * @dev Allows swapping of source token amount to exact destination token
     * amount.
     *
     * Internally calls {calculateInGivenOut} and {_swap} functions.
     *
     * Requirements:
     * - Param {amountInMax} must be greater than or equal to the source amount computed {amountIn}.
     * - The current timestamp has not exceeded the param {deadline}.
     **/
    function swapTokensForExactTokens(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external virtual ensure(deadline) returns (uint256 amountIn) {
        amountIn = calculateInGivenOut(amountOut, path);

        require(
            amountInMax >= amountIn,
            ""VaderRouter::swapTokensForExactTokens: Large Trade Input""
        );

        _swap(amountIn, path, to);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    /*
     * @dev Sets the reserve address and renounces contract's ownership.
     *
     * Requirements:
     * - Only existing owner can call this function.
     * - Param {_reserve} cannot be a zero address.
     **/
    function initialize(IVaderReserve _reserve) external onlyOwner {
        require(
            _reserve != IVaderReserve(_ZERO_ADDRESS),
            ""VaderRouter::initialize: Incorrect Reserve Specified""
        );

        reserve = _reserve;

        renounceOwnership();
    }

    /* ========== INTERNAL FUNCTIONS ========== */

    /* ========== PRIVATE FUNCTIONS ========== */

    /*
     * @dev Allows swapping of assets from within a single Vader pool or
     * across two different Vader pools.
     *
     * In case of a single Vader pool, the native asset can be swapped for foreign
     * asset and vice versa.
     *
     * In case of two Vader pools, the foreign asset is swapped for native asset from
     * the first Vader pool and the native asset retrieved from the first Vader pool is swapped
     * for foreign asset from the second Vader pool.
     *
     * Requirements:
     * - Param {path} length can be either 2 or 3.
     * - If the {path} length is 3 the index 0 and 1 must contain foreign assets' addresses
     *   and index 1 must contain native asset's address.
     * - If the {path} length is 2 then either of indexes must contain foreign asset's address
     *   and the other one must contain native asset's address.
     **/
    // TODO: Refactor with central pool, perhaps diminishes security? would need directSwap & bridgeSwap
    function _swap(
        uint256 amountIn,
        address[] calldata path,
        address to
    ) private returns (uint256 amountOut) {
        if (path.length == 3) {
            require(
                path[0] != path[1] &&
                    path[1] == factory.nativeAsset() &&
                    path[2] != path[1],
                ""VaderRouter::_swap: Incorrect Path""
            );

            IVaderPool pool0 = factory.getPool(path[0], path[1]);
            IVaderPool pool1 = factory.getPool(path[1], path[2]);

            IERC20(path[0]).safeTransferFrom(
                msg.sender,
                address(pool0),
                amountIn
            );

            return pool1.swap(0, pool0.swap(amountIn, 0, address(pool1)), to);
        } else {
            require(
                path.length == 2,
                ""VaderRouter::_swap: Incorrect Path Length""
            );
            address nativeAsset = factory.nativeAsset();
            require(path[0] != path[1], ""VaderRouter::_swap: Incorrect Path"");

            IVaderPool pool = factory.getPool(path[0], path[1]);
            IERC20(path[0]).safeTransferFrom(
                msg.sender,
                address(pool),
                amountIn
            );
            if (path[0] == nativeAsset) {
                return pool.swap(amountIn, 0, to);
            } else {
                require(
                    path[1] == nativeAsset,
                    ""VaderRouter::_swap: Incorrect Path""
                );
                return pool.swap(0, amountIn, to);
            }
        }
    }

    /*
     * @dev An internal function that returns Vader pool's address against
     * the provided assets of {tokenA} and {tokenB} if it exists, otherwise
     * a new Vader pool created against the provided assets.
     **/
    // NOTE: DEX allows asymmetric deposits
    function _addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired
    )
        private
        returns (
            IVaderPool pool,
            uint256 amountA,
            uint256 amountB
        )
    {
        // create the pair if it doesn't exist yet
        pool = factory.getPool(tokenA, tokenB);
        if (pool == IVaderPool(_ZERO_ADDRESS)) {
            pool = factory.createPool(tokenA, tokenB);
        }

        (amountA, amountB) = (amountADesired, amountBDesired);
    }

    /*
     * @dev Returns the amount of source asset given the amount of destination asset.
     *
     * Calls the {calculateSwapReverse} on VaderMath library to compute the source
     * token amount.
     *
     * Requirements:
     * - Param {path} length can be either 2 or 3.
     * - If the {path} length is 3 the index 0 and 1 must contain foreign assets' addresses
     *   and index 1 must contain native asset's address.
     * - If the {path} length is 2 then either of indexes must contain foreign asset's address
     *   and the other one must contain native asset's address.
     **/
    function calculateInGivenOut(uint256 amountOut, address[] calldata path)
        public
        view
        returns (uint256 amountIn)
    {
        if (path.length == 2) {
            address nativeAsset = factory.nativeAsset();
            IVaderPool pool = factory.getPool(path[0], path[1]);
            (uint256 nativeReserve, uint256 foreignReserve, ) = pool
                .getReserves();
            if (path[0] == nativeAsset) {
                return
                    VaderMath.calculateSwapReverse(
                        amountOut,
                        nativeReserve,
                        foreignReserve
                    );
            } else {
                return
                    VaderMath.calculateSwapReverse(
                        amountOut,
                        foreignReserve,
                        nativeReserve
                    );
            }
        } else {
            IVaderPool pool0 = factory.getPool(path[0], path[1]);
            IVaderPool pool1 = factory.getPool(path[1], path[2]);
            (uint256 nativeReserve0, uint256 foreignReserve0, ) = pool0
                .getReserves();
            (uint256 nativeReserve1, uint256 foreignReserve1, ) = pool1
                .getReserves();

            return
                VaderMath.calculateSwapReverse(
                    VaderMath.calculateSwapReverse(
                        amountOut,
                        nativeReserve1,
                        foreignReserve1
                    ),
                    foreignReserve0,
                    nativeReserve0
                );
        }
    }

    /*
     * @dev Returns the amount of destination asset given the amount of source asset.
     *
     * Calls the {calculateSwap} on VaderMath library to compute the destination
     * token amount.
     *
     * Requirements:
     * - Param {path} length can be either 2 or 3.
     * - If the {path} length is 3 the index 0 and 1 must contain foreign assets' addresses
     *   and index 1 must contain native asset's address.
     * - If the {path} length is 2 then either of indexes must contain foreign asset's address
     *   and the other one must contain native asset's address.
     **/
    function calculateOutGivenIn(uint256 amountIn, address[] calldata path)
        external
        view
        returns (uint256 amountOut)
    {
        if (path.length == 2) {
            address nativeAsset = factory.nativeAsset();
            IVaderPool pool = factory.getPool(path[0], path[1]);
            (uint256 nativeReserve, uint256 foreignReserve, ) = pool
                .getReserves();
            if (path[0] == nativeAsset) {
                return
                    VaderMath.calculateSwap(
                        amountIn,
                        nativeReserve,
                        foreignReserve
                    );
            } else {
                return
                    VaderMath.calculateSwap(
                        amountIn,
                        foreignReserve,
                        nativeReserve
                    );
            }
        } else {
            IVaderPool pool0 = factory.getPool(path[0], path[1]);
            IVaderPool pool1 = factory.getPool(path[1], path[2]);
            (uint256 nativeReserve0, uint256 foreignReserve0, ) = pool0
                .getReserves();
            (uint256 nativeReserve1, uint256 foreignReserve1, ) = pool1
                .getReserves();

            return
                VaderMath.calculateSwap(
                    VaderMath.calculateSwap(
                        amountIn,
                        nativeReserve1,
                        foreignReserve1
                    ),
                    foreignReserve0,
                    nativeReserve0
                );
        }
    }

    /* ========== MODIFIERS ========== */

    // Guard ensuring that the current timestamp has not exceeded the param {deadline}.
    modifier ensure(uint256 deadline) {
        require(deadline >= block.timestamp, ""VaderRouter::ensure: Expired"");
        _;
    }
}",3602
RealWorld_BA_52_VaderPoolV2_RealWord_20240821095220.log,52,VaderPoolV2,49820,5638,55458,88.0,0.36186,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/access/Ownable.sol"";

import ""./BasePoolV2.sol"";

import ""../../interfaces/shared/IERC20Extended.sol"";
import ""../../interfaces/dex-v2/pool/IVaderPoolV2.sol"";
import ""../../interfaces/dex-v2/wrapper/ILPWrapper.sol"";
import ""../../interfaces/dex-v2/synth/ISynthFactory.sol"";

/*
 * @dev Implementation of {VaderPoolV2} contract.
 *
 * The contract VaderPool inherits from {BasePoolV2} contract and implements
 * queue system.
 *
 * Extends on the liquidity redeeming function by introducing the `burn` function
 * that internally calls the namesake on `BasePoolV2` contract and computes the
 * loss covered by the position being redeemed and returns it along with amounts
 * of native and foreign assets sent.
 **/
contract VaderPoolV2 is IVaderPoolV2, BasePoolV2, Ownable {
    /* ========== LIBRARIES ========== */

    // Used for safe token transfers
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    // The LP wrapper contract
    ILPWrapper public wrapper;

    // The Synth Factory
    ISynthFactory public synthFactory;

    // Denotes whether the queue system is active
    bool public queueActive;

    /* ========== CONSTRUCTOR ========== */

    /*
     * @dev Initialised the contract state by passing the native asset's address
     * to the inherited {BasePoolV2} contract's constructor and setting queue status
     * to the {queueActive} state variable.
     **/
    constructor(bool _queueActive, IERC20 _nativeAsset)
        BasePoolV2(_nativeAsset)
    {
        queueActive = _queueActive;
    }

    /* ========== VIEWS ========== */

    /*
     * @dev Returns cumulative prices and the timestamp the were last updated
     * for both native and foreign assets against the pair specified by
     * parameter {foreignAsset}.
     **/
    function cumulativePrices(IERC20 foreignAsset)
        public
        view
        returns (
            uint256 price0CumulativeLast,
            uint256 price1CumulativeLast,
            uint32 blockTimestampLast
        )
    {
        PriceCumulative memory priceCumulative = pairInfo[foreignAsset]
            .priceCumulative;
        price0CumulativeLast = priceCumulative.nativeLast;
        price1CumulativeLast = priceCumulative.foreignLast;
        blockTimestampLast = pairInfo[foreignAsset].blockTimestampLast;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    /*
     * @dev Initializes contract's state with LP wrapper, synth factory
     * and router addresses.
     *
     * Requirements:
     * - None of the parameters are zero addresses.
     * - The parameters are not already set.
     * - Only callable by contract owner.
     **/
    function initialize(
        ILPWrapper _wrapper,
        ISynthFactory _synthFactory,
        address _router
    ) external onlyOwner {
        require(
            wrapper == ILPWrapper(_ZERO_ADDRESS),
            ""VaderPoolV2::initialize: Already initialized""
        );
        require(
            _wrapper != ILPWrapper(_ZERO_ADDRESS),
            ""VaderPoolV2::initialize: Incorrect Wrapper Specified""
        );
        require(
            _synthFactory != ISynthFactory(_ZERO_ADDRESS),
            ""VaderPoolV2::initialize: Incorrect SynthFactory Specified""
        );
        require(
            _router != _ZERO_ADDRESS,
            ""VaderPoolV2::initialize: Incorrect Router Specified""
        );
        wrapper = _wrapper;
        synthFactory = _synthFactory;
        router = _router;
    }

    /*
     * @dev Allows minting of synthetic assets corresponding to the {foreignAsset} based
     * on the native asset amount deposited and returns the minted synth asset amount.
     *
     * Creates the synthetic asset against {foreignAsset} if it does not already exist.
     *
     * Updates the cumulative prices for native and foreign assets.
     *
     * Requirements:
     * - {foreignAsset} must be a supported token.
     **/
    function mintSynth(
        IERC20 foreignAsset,
        uint256 nativeDeposit,
        address from,
        address to
    )
        external
        override
        nonReentrant
        supportedToken(foreignAsset)
        returns (uint256 amountSynth)
    {
        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);

        ISynth synth = synthFactory.synths(foreignAsset);

        if (synth == ISynth(_ZERO_ADDRESS))
            synth = synthFactory.createSynth(
                IERC20Extended(address(foreignAsset))
            );

        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(
            foreignAsset
        ); // gas savings

        amountSynth = VaderMath.calculateSwap(
            nativeDeposit,
            reserveNative,
            reserveForeign
        );

        // TODO: Clarify
        _update(
            foreignAsset,
            reserveNative + nativeDeposit,
            reserveForeign,
            reserveNative,
            reserveForeign
        );

        synth.mint(to, amountSynth);
    }

    /*
     * @dev Allows burning of synthetic assets corresponding to the {foreignAsset}
     * and returns the redeemed amount of native asset.
     *
     * Updates the cumulative prices for native and foreign assets.
     *
     * Requirements:
     * - {foreignAsset} must have a valid synthetic asset against it.
     * - {synthAmount} must be greater than zero.
     **/
    function burnSynth(
        IERC20 foreignAsset,
        uint256 synthAmount,
        address to
    ) external override nonReentrant returns (uint256 amountNative) {
        ISynth synth = synthFactory.synths(foreignAsset);

        require(
            synth != ISynth(_ZERO_ADDRESS),
            ""VaderPoolV2::burnSynth: Inexistent Synth""
        );

        require(
            synthAmount > 0,
            ""VaderPoolV2::burnSynth: Insufficient Synth Amount""
        );

        IERC20(synth).safeTransferFrom(msg.sender, address(this), synthAmount);
        synth.burn(synthAmount);

        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(
            foreignAsset
        ); // gas savings

        amountNative = VaderMath.calculateSwap(
            synthAmount,
            reserveForeign,
            reserveNative
        );

        // TODO: Clarify
        _update(
            foreignAsset,
            reserveNative - amountNative,
            reserveForeign,
            reserveNative,
            reserveForeign
        );

        nativeAsset.safeTransfer(to, amountNative);
    }

    /*
     * @dev Allows burning of NFT represented by param {id} for liquidity redeeming.
     *
     * Deletes the position in {positions} mapping against the burned NFT token.
     *
     * Internally calls `_burn` function on {BasePoolV2} contract.
     *
     * Calculates the impermanent loss incurred by the position.
     *
     * Returns the amounts for native and foreign assets sent to the {to} address
     * along with the covered loss.
     *
     * Requirements:
     * - Can only be called by the Router.
     **/
    // NOTE: IL is only covered via router!
    function burn(uint256 id, address to)
        external
        override
        onlyRouter
        returns (
            uint256 amountNative,
            uint256 amountForeign,
            uint256 coveredLoss
        )
    {
        (amountNative, amountForeign) = _burn(id, to);

        Position storage position = positions[id];

        uint256 creation = position.creation;
        uint256 originalNative = position.originalNative;
        uint256 originalForeign = position.originalForeign;

        delete positions[id];

        // NOTE: Validate it behaves as expected for non-18 decimal tokens
        uint256 loss = VaderMath.calculateLoss(
            originalNative,
            originalForeign,
            amountNative,
            amountForeign
        );

        // TODO: Original Implementation Applied 100 Days
        coveredLoss =
            (loss * _min(block.timestamp - creation, _ONE_YEAR)) /
            _ONE_YEAR;
    }

    /*
     * @dev Allows minting of liquidity in fungible tokens. The fungible token
     * is a wrapped LP token against a particular pair. The liquidity issued is also
     * tracked within this contract along with liquidity issued against non-fungible
     * token.
     *
     * Updates the cumulative prices for native and foreign assets.
     *
     * Calls 'mint' on the LP wrapper token contract.
     *
     * Requirements:
     * - LP wrapper token must exist against {foreignAsset}.
     **/
    function mintFungible(
        IERC20 foreignAsset,
        uint256 nativeDeposit,
        uint256 foreignDeposit,
        address from,
        address to
    ) external override nonReentrant returns (uint256 liquidity) {
        IERC20Extended lp = wrapper.tokens(foreignAsset);

        require(
            lp != IERC20Extended(_ZERO_ADDRESS),
            ""VaderPoolV2::mintFungible: Unsupported Token""
        );

        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(
            foreignAsset
        ); // gas savings

        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);
        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);

        PairInfo storage pair = pairInfo[foreignAsset];
        uint256 totalLiquidityUnits = pair.totalSupply;
        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;
        else
            liquidity = VaderMath.calculateLiquidityUnits(
                nativeDeposit,
                reserveNative,
                foreignDeposit,
                reserveForeign,
                totalLiquidityUnits
            );

        require(
            liquidity > 0,
            ""VaderPoolV2::mintFungible: Insufficient Liquidity Provided""
        );

        pair.totalSupply = totalLiquidityUnits + liquidity;

        _update(
            foreignAsset,
            reserveNative + nativeDeposit,
            reserveForeign + foreignDeposit,
            reserveNative,
            reserveForeign
        );

        lp.mint(to, liquidity);

        emit Mint(from, to, nativeDeposit, foreignDeposit);
    }

    /*
     * @dev Allows burning of liquidity issued in fungible tokens.
     *
     * Updates the cumulative prices for native and foreign assets.
     *
     * Calls 'burn' on the LP wrapper token contract.
     *
     * Requirements:
     * - LP wrapper token must exist against {foreignAsset}.
     * - {amountNative} and {amountForeign} redeemed, both must be greater than zero.,
     **/
    function burnFungible(
        IERC20 foreignAsset,
        uint256 liquidity,
        address to
    )
        external
        override
        nonReentrant
        returns (uint256 amountNative, uint256 amountForeign)
    {
        IERC20Extended lp = wrapper.tokens(foreignAsset);

        require(
            lp != IERC20Extended(_ZERO_ADDRESS),
            ""VaderPoolV2::burnFungible: Unsupported Token""
        );

        IERC20(lp).safeTransferFrom(msg.sender, address(this), liquidity);
        lp.burn(liquidity);

        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(
            foreignAsset
        ); // gas savings

        PairInfo storage pair = pairInfo[foreignAsset];
        uint256 _totalSupply = pair.totalSupply;
        amountNative = (liquidity * reserveNative) / _totalSupply;
        amountForeign = (liquidity * reserveForeign) / _totalSupply;

        require(
            amountNative > 0 && amountForeign > 0,
            ""VaderPoolV2::burnFungible: Insufficient Liquidity Burned""
        );

        pair.totalSupply = _totalSupply - liquidity;

        nativeAsset.safeTransfer(to, amountNative);
        foreignAsset.safeTransfer(to, amountForeign);

        _update(
            foreignAsset,
            reserveNative - amountNative,
            reserveForeign - amountForeign,
            reserveNative,
            reserveForeign
        );

        emit Burn(msg.sender, amountNative, amountForeign, to);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    // TODO: Investigate Necessity
    function toggleQueue() external override onlyOwner {
        bool _queueActive = !queueActive;
        queueActive = _queueActive;
        emit QueueActive(_queueActive);
    }

    /*
     * @dev Sets the supported state of the token represented by param {foreignAsset}.
     *
     * Requirements:
     * - The param {foreignAsset} is not already a supported token.
     **/
    function setTokenSupport(IERC20 foreignAsset, bool support)
        external
        override
        onlyOwner
    {
        require(
            supported[foreignAsset] != support,
            ""VaderPoolV2::supportToken: Already At Desired State""
        );
        supported[foreignAsset] = support;
    }

    /*
     * @dev Sets the supported state of the token represented by param {foreignAsset}.
     *
     * Requirements:
     * - The param {foreignAsset} is not already a supported token.
     **/
    function setFungibleTokenSupport(IERC20 foreignAsset)
        external
        override
        onlyOwner
    {
        wrapper.createWrapper(foreignAsset);
    }

    /* ========== INTERNAL FUNCTIONS ========== */

    /* ========== PRIVATE FUNCTIONS ========== */

    /**
     * @dev Calculates the minimum of the two values
     */
    function _min(uint256 a, uint256 b) private pure returns (uint256) {
        return a < b ? a : b;
    }
}",2900
RealWorld_BA_52_UniswapV2Pair_RealWord_20240821101558.log,52,UniswapV2Pair,44843,5399,50242,89.0,0.332195,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""./interfaces/IUniswapV2Pair.sol"";
import ""./UniswapV2ERC20.sol"";
import ""./libraries/Math.sol"";
import ""./libraries/UQ112x112.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IUniswapV2Factory.sol"";
import ""./interfaces/IUniswapV2Callee.sol"";

contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {
    using UQ112x112 for uint224;

    uint256 public constant MINIMUM_LIQUIDITY = 10**3;
    bytes4 private constant SELECTOR =
        bytes4(keccak256(bytes(""transfer(address,uint256)"")));

    address public factory;
    address public token0;
    address public token1;

    uint112 private reserve0; // uses single storage slot, accessible via getReserves
    uint112 private reserve1; // uses single storage slot, accessible via getReserves
    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves

    uint256 public price0CumulativeLast;
    uint256 public price1CumulativeLast;
    uint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event

    uint256 private unlocked = 1;
    modifier lock() {
        require(unlocked == 1, ""UniswapV2: LOCKED"");
        unlocked = 0;
        _;
        unlocked = 1;
    }

    function getReserves()
        public
        view
        returns (
            uint112 _reserve0,
            uint112 _reserve1,
            uint32 _blockTimestampLast
        )
    {
        _reserve0 = reserve0;
        _reserve1 = reserve1;
        _blockTimestampLast = blockTimestampLast;
    }

    function _safeTransfer(
        address token,
        address to,
        uint256 value
    ) private {
        (bool success, bytes memory data) = token.call(
            abi.encodeWithSelector(SELECTOR, to, value)
        );
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            ""UniswapV2: TRANSFER_FAILED""
        );
    }

    constructor() {
        factory = msg.sender;
    }

    // called once by the factory at time of deployment
    function initialize(address _token0, address _token1) external {
        require(msg.sender == factory, ""UniswapV2: FORBIDDEN""); // sufficient check
        token0 = _token0;
        token1 = _token1;
    }

    // update reserves and, on the first call per block, price accumulators
    function _update(
        uint256 balance0,
        uint256 balance1,
        uint112 _reserve0,
        uint112 _reserve1
    ) private {
        require(
            balance0 <= type(uint112).max && balance1 <= type(uint112).max,
            ""UniswapV2: OVERFLOW""
        );
        uint32 blockTimestamp = uint32(block.timestamp % 2**32);
        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
            // * never overflows, and + overflow is desired
            price0CumulativeLast +=
                uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) *
                timeElapsed;
            price1CumulativeLast +=
                uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) *
                timeElapsed;
        }
        reserve0 = uint112(balance0);
        reserve1 = uint112(balance1);
        blockTimestampLast = blockTimestamp;
        emit Sync(reserve0, reserve1);
    }

    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)
    function _mintFee(uint112 _reserve0, uint112 _reserve1)
        private
        returns (bool feeOn)
    {
        address feeTo = IUniswapV2Factory(factory).feeTo();
        feeOn = feeTo != address(0);
        uint256 _kLast = kLast; // gas savings
        if (feeOn) {
            if (_kLast != 0) {
                uint256 rootK = Math.sqrt(uint256(_reserve0) * _reserve1);
                uint256 rootKLast = Math.sqrt(_kLast);
                if (rootK > rootKLast) {
                    uint256 numerator = totalSupply * (rootK - rootKLast);
                    uint256 denominator = (rootK * 5) + rootKLast;
                    uint256 liquidity = numerator / denominator;
                    if (liquidity > 0) _mint(feeTo, liquidity);
                }
            }
        } else if (_kLast != 0) {
            kLast = 0;
        }
    }

    // this low-level function should be called from a contract which performs important safety checks
    function mint(address to) external lock returns (uint256 liquidity) {
        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
        uint256 balance0 = IERC20(token0).balanceOf(address(this));
        uint256 balance1 = IERC20(token1).balanceOf(address(this));
        uint256 amount0 = balance0 - _reserve0;
        uint256 amount1 = balance1 - _reserve1;

        bool feeOn = _mintFee(_reserve0, _reserve1);
        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
        if (_totalSupply == 0) {
            liquidity = Math.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;
            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens
        } else {
            liquidity = Math.min(
                (amount0 * (_totalSupply)) / _reserve0,
                (amount1 * (_totalSupply)) / _reserve1
            );
        }
        require(liquidity > 0, ""UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED"");
        _mint(to, liquidity);

        _update(balance0, balance1, _reserve0, _reserve1);
        if (feeOn) kLast = uint256(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date
        emit Mint(msg.sender, amount0, amount1);
    }

    // this low-level function should be called from a contract which performs important safety checks
    function burn(address to)
        external
        lock
        returns (uint256 amount0, uint256 amount1)
    {
        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
        address _token0 = token0; // gas savings
        address _token1 = token1; // gas savings
        uint256 balance0 = IERC20(_token0).balanceOf(address(this));
        uint256 balance1 = IERC20(_token1).balanceOf(address(this));
        uint256 liquidity = balanceOf[address(this)];

        bool feeOn = _mintFee(_reserve0, _reserve1);
        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
        amount0 = (liquidity * balance0) / _totalSupply; // using balances ensures pro-rata distribution
        amount1 = (liquidity * balance1) / _totalSupply; // using balances ensures pro-rata distribution
        require(
            amount0 > 0 && amount1 > 0,
            ""UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED""
        );
        _burn(address(this), liquidity);
        _safeTransfer(_token0, to, amount0);
        _safeTransfer(_token1, to, amount1);
        balance0 = IERC20(_token0).balanceOf(address(this));
        balance1 = IERC20(_token1).balanceOf(address(this));

        _update(balance0, balance1, _reserve0, _reserve1);
        if (feeOn) kLast = uint256(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date
        emit Burn(msg.sender, amount0, amount1, to);
    }

    // this low-level function should be called from a contract which performs important safety checks
    function swap(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        bytes calldata data
    ) external lock {
        require(
            amount0Out > 0 || amount1Out > 0,
            ""UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT""
        );
        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
        require(
            amount0Out < _reserve0 && amount1Out < _reserve1,
            ""UniswapV2: INSUFFICIENT_LIQUIDITY""
        );

        uint256 balance0;
        uint256 balance1;
        {
            // scope for _token{0,1}, avoids stack too deep errors
            address _token0 = token0;
            address _token1 = token1;
            require(to != _token0 && to != _token1, ""UniswapV2: INVALID_TO"");
            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
            if (data.length > 0)
                IUniswapV2Callee(to).uniswapV2Call(
                    msg.sender,
                    amount0Out,
                    amount1Out,
                    data
                );
            balance0 = IERC20(_token0).balanceOf(address(this));
            balance1 = IERC20(_token1).balanceOf(address(this));
        }
        uint256 amount0In = balance0 > _reserve0 - amount0Out
            ? balance0 - (_reserve0 - amount0Out)
            : 0;
        uint256 amount1In = balance1 > _reserve1 - amount1Out
            ? balance1 - (_reserve1 - amount1Out)
            : 0;
        require(
            amount0In > 0 || amount1In > 0,
            ""UniswapV2: INSUFFICIENT_INPUT_AMOUNT""
        );
        {
            // scope for reserve{0,1}Adjusted, avoids stack too deep errors
            uint256 balance0Adjusted = (balance0 * 1000) - (amount0In * 3);
            uint256 balance1Adjusted = (balance1 * 1000) - (amount1In * 3);
            require(
                balance0Adjusted * balance1Adjusted >=
                    uint256(_reserve0) * _reserve1 * 1000**2,
                ""UniswapV2: K""
            );
        }

        _update(balance0, balance1, _reserve0, _reserve1);
        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
    }

    // force balances to match reserves
    function skim(address to) external lock {
        address _token0 = token0; // gas savings
        address _token1 = token1; // gas savings
        _safeTransfer(
            _token0,
            to,
            IERC20(_token0).balanceOf(address(this)) - reserve0
        );
        _safeTransfer(
            _token1,
            to,
            IERC20(_token1).balanceOf(address(this)) - reserve1
        );
    }

    // force reserves to match balances
    function sync() external lock {
        _update(
            IERC20(token0).balanceOf(address(this)),
            IERC20(token1).balanceOf(address(this)),
            reserve0,
            reserve1
        );
    }
}",2625
RealWorld_BA_52_LPWrapper_RealWord_20240821094644.log,52,LPWrapper,6731,5410,12141,73.0,0.141855,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""./LPToken.sol"";

import ""../../interfaces/dex-v2/wrapper/ILPWrapper.sol"";

contract LPWrapper is ILPWrapper, ProtocolConstants, Ownable {
    mapping(IERC20 => IERC20Extended) public override tokens;

    constructor(address pool) {
        require(
            pool != _ZERO_ADDRESS,
            ""LPWrapper::constructor: Misconfiguration""
        );
        transferOwnership(pool);
    }

    function createWrapper(IERC20 foreignAsset) external override onlyOwner {
        require(
            tokens[foreignAsset] == IERC20Extended(_ZERO_ADDRESS),
            ""LPWrapper::createWrapper: Already Created""
        );

        // NOTE: Here, `owner` is the VaderPoolV2
        tokens[foreignAsset] = IERC20Extended(
            address(
                new LPToken(
                    IERC20Extended(address(foreignAsset)),
                    IVaderPoolV2(owner())
                )
            )
        );
    }
}",214
RealWorld_BA_52_IVaderPoolFactory_RealWord_20240821105551.log,52,IVaderPoolFactory,5282,4165,9447,60.0,0.10971,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""./IVaderPool.sol"";

interface IVaderPoolFactory {
    /* ========== STRUCTS ========== */

    /* ========== FUNCTIONS ========== */

    function createPool(address tokenA, address tokenB)
        external
        returns (IVaderPool);

    function getPool(address tokenA, address tokenB)
        external
        view
        returns (IVaderPool);

    function nativeAsset() external view returns (address);

    /* ========== EVENTS ========== */

    event PoolCreated(
        address token0,
        address token1,
        IVaderPool pool,
        uint256 index
    );
}",136
RealWorld_BA_52_IConverter_RealWord_20240821110639.log,52,IConverter,4602,4139,8741,70.0,0.10579,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

interface IConverter {
    /* ========== FUNCTIONS ========== */

    function convert(bytes32[] calldata proof, uint256 amount)
        external
        returns (uint256 vaderReceived);

    /* ========== EVENTS ========== */

    event Conversion(
        address indexed user,
        uint256 vetherAmount,
        uint256 vaderAmount
    );
}",85
RealWorld_BA_52_Vader_RealWord_20240821103357.log,52,Vader,44228,5438,49666,79.0,0.3299,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../shared/ProtocolConstants.sol"";

import ""../interfaces/tokens/IUSDV.sol"";
import ""../interfaces/tokens/IVader.sol"";
import ""../interfaces/tokens/vesting/ILinearVesting.sol"";
import ""../interfaces/tokens/converter/IConverter.sol"";

/**
 * @dev Implementation of the {IVader} interface.
 *
 * The Vader token that acts as the backbone of the Vader protocol,
 * burned and minted to mint and burn USDV tokens respectively.
 *
 * The token contains a dynamically adjusting fee that fluctuates
 * between 0% and 1% depending on the total supply of the token
 * in comparison to the maximum supply possible, which is initially
 * equal to 2.5 billion units.
 *
 * A daily emission schedule is built in the contract as well,
 * meant to supply the Vader USDV treasury at a diminishing
 * rate that inches closer to 0 as the total supply of the token
 * nears the maximum supply possible.
 */
contract Vader is IVader, ProtocolConstants, ERC20, Ownable {
    /* ========== STATE VARIABLES ========== */

    // The Vader <-> Vether converter contract
    IConverter public converter;

    // The Vader Team vesting contract
    ILinearVesting public vest;

    // The USDV contract, used to apply proper access control
    IUSDV public usdv;

    // The adjustable emission curve of the protocol, used as a divisor
    uint256 public emissionCurve = _INITIAL_EMISSION_CURVE;

    // The last emission's timestamp expressed in seconds
    uint256 public lastEmission = block.timestamp;

    // The initial maximum supply of the token, equivalent to 2.5 bn units
    uint256 public maxSupply = _INITIAL_VADER_SUPPLY;

    // A list of addresses that do not have a tax applied to them, used for system components
    mapping(address => bool) public untaxed;

    /* ========== CONSTRUCTOR ========== */

    /**
     * @dev Mints the ecosystem growth fund described in the whitepaper to the
     * token contract itself.
     *
     * As the token is meant to be minted and burned freely between USDV and itself,
     * there is no real initialization taking place apart from the initially minted
     * supply for the following components:
     *
     * - Ecosystem Growth: An allocation that is released to strategic partners for the
     * protocol's expansion
     *
     * - Team Allocation: An allocation that is gradually vested over a 2 year duration to
     * the Vader team to incentivize maintainance of the protocol
     *
     * - Vether Holder Allocation: An allocation that is immediately available to all existing
     * and future Vether holders that allows them to swap their Vether for Vader by burning the
     * former
     *
     * The latter two of the allocations are minted at a later date given that the addresses of
     * the converter and vesting contract are not known on deployment.
     */
    constructor() ERC20(""Vader"", ""VADER"") {
        _mint(address(this), _ECOSYSTEM_GROWTH);
    }

    /* ========== VIEWS ========== */

    /**
     * @dev Returns the current fee that the protocol applies to transactions. The fee
     * organically adjusts itself as the actual total supply of the token fluctuates and
     * will always hold a value between [0%, 1%] expressed in basis points.
     */
    function calculateFee() public view override returns (uint256 basisPoints) {
        basisPoints = (_MAX_FEE_BASIS_POINTS * totalSupply()) / maxSupply;
    }

    /**
     * @dev Returns the current era's emission based on the existing total supply of the
     * token. The era emissions diminish as the total supply of the token increases, inching
     * closer to 0 as the total supply reaches its cap.
     */
    function getCurrentEraEmission() external view override returns (uint256) {
        return getEraEmission(totalSupply());
    }

    /**
     * @dev Calculates and returns the constantly diminishing era emission based on the difference between
     * the current and maximum supply spread over a one year based in on the emission's era duration.
     */
    function getEraEmission(uint256 currentSupply)
        public
        view
        override
        returns (uint256)
    {
        return
            ((maxSupply - currentSupply) / emissionCurve) /
            (_ONE_YEAR / _EMISSION_ERA);
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    /**
     * @dev Creates a manual emission event
     *
     * Emits an {Emission} event indicating the amount emitted as well as what the current
     * era's timestamp is.
     */
    function createEmission(address user, uint256 amount)
        external
        override
        onlyOwner
    {
        _mint(user, amount);
        emit Emission(user, amount);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    /**
     * @dev Sets the initial {converter}, {vest}, and {usdv} contract addresses prior to transferring
     * ownership to the DAO. Additionally, mints the Vader amount available for conversion as well
     * as the team allocation that is meant to be vested to each respective contract.
     *
     * Emits a {ProtocolInitialized} event indicating all the supplied values of the function.
     *
     * Requirements:
     *
     * - the caller must be the deployer of the contract
     * - the contract must not have already been initialized
     */
    function setComponents(
        IConverter _converter,
        ILinearVesting _vest,
        IUSDV _usdv,
        address dao
    ) external onlyOwner {
        require(
            _converter != IConverter(_ZERO_ADDRESS) &&
                _vest != ILinearVesting(_ZERO_ADDRESS) &&
                _usdv != IUSDV(_ZERO_ADDRESS) &&
                dao != _ZERO_ADDRESS,
            ""Vader::setComponents: Incorrect Arguments""
        );
        require(
            converter == IConverter(_ZERO_ADDRESS),
            ""Vader::setComponents: Already Set""
        );

        converter = _converter;
        vest = _vest;
        usdv = _usdv;

        untaxed[address(_converter)] = true;
        untaxed[address(_vest)] = true;
        untaxed[address(_usdv)] = true;

        _mint(address(_converter), _VETH_ALLOCATION);
        _mint(address(_vest), _TEAM_ALLOCATION);

        _vest.begin();
        transferOwnership(dao);

        emit ProtocolInitialized(
            address(_converter),
            address(_vest),
            address(_usdv),
            dao
        );
    }

    /**
     * @dev Allows a strategic partnership grant to be claimed.
     *
     * Emits a {GrantClaimed} event indicating the beneficiary of the grant as
     * well as the grant amount.
     *
     * Requirements:
     *
     * - the caller must be the DAO
     * - the token must hold sufficient Vader allocation for the grant
     * - the grant must be of a non-zero amount
     */
    function claimGrant(address beneficiary, uint256 amount) external onlyDAO {
        require(amount != 0, ""Vader::claimGrant: Non-Zero Amount Required"");
        emit GrantClaimed(beneficiary, amount);
        ERC20._transfer(address(this), beneficiary, amount);
    }

    /**
     * @dev Allows the maximum supply of the token to be adjusted.
     *
     * Emits an {MaxSupplyChanged} event indicating the previous and next maximum
     * total supplies.
     *
     * Requirements:
     *
     * - the caller must be the DAO
     * - the new maximum supply must be greater than the current one
     */
    function adjustMaxSupply(uint256 _maxSupply) external onlyDAO {
        require(
            _maxSupply >= totalSupply(),
            ""Vader::adjustMaxSupply: Max supply cannot subcede current supply""
        );
        emit MaxSupplyChanged(maxSupply, _maxSupply);
        maxSupply = _maxSupply;
    }

    /* ========== INTERNAL FUNCTIONS ========== */

    /**
     * @dev Ensures that the daily emission of the token gets automatically executed
     * when the time is right and enforces the maximum supply limit on mint operations.
     */
    function _beforeTokenTransfer(
        address from,
        address,
        uint256 amount
    ) internal view override {
        if (from == address(0))
            require(
                totalSupply() + amount <= maxSupply,
                ""Vader::_beforeTokenTransfer: Mint exceeds cap""
            );

        // _syncEmissions();
    }

    /**
     * @dev Overrides the existing ERC-20 {_transfer} functionality to apply a fee on each
     * transfer.
     */
    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal override {
        if (untaxed[msg.sender])
            return ERC20._transfer(sender, recipient, amount);

        uint256 fee = calculateFee();

        uint256 tax = (amount * fee) / _MAX_BASIS_POINTS;

        amount -= tax;

        _burn(sender, tax);

        ERC20._transfer(sender, recipient, amount);
    }

    /* ========== PRIVATE FUNCTIONS ========== */

    /**
     * @dev Ensures only the DAO is able to invoke a particular function by validating that the
     * contract has been set up and that the owner is the msg.sender
     */
    function _onlyDAO() private view {
        require(
            converter != IConverter(_ZERO_ADDRESS),
            ""Vader::_onlyDAO: DAO not set yet""
        );
        require(
            owner() == _msgSender(),
            ""Vader::_onlyDAO: Insufficient Privileges""
        );
    }

    /* ========== MODIFIERS ========== */

    /**
     * @dev Throws if invoked by anyone else other than the DAO
     */
    modifier onlyDAO() {
        _onlyDAO();
        _;
    }

    /* ========== DEPRECATED FUNCTIONS ========== */

    /**
     * @dev Allows the daily emission curve of the token to be adjusted.
     *
     * Emits an {EmissionChanged} event indicating the previous and next emission
     * curves.
     *
     * Requirements:
     *
     * - the caller must be the DAO
     * - the new emission must be non-zero
     */
    // function adjustEmission(uint256 _emissionCurve) external onlyDAO {
    //     require(
    //         _emissionCurve != 0,
    //         ""Vader::adjustEmission: Incorrect Curve Emission""
    //     );
    //     emit EmissionChanged(emissionCurve, _emissionCurve);
    //     emissionCurve = _emissionCurve;
    // }

    /**
     * @dev Syncs the current emission schedule by advancing the necessary epochs to match the
     * current timestamp and mints the corresponding Vader to the USDV contract for distribution
     * via the {distributeEmission} function.
     */
    // function _syncEmissions() private {
    //     uint256 currentSupply = totalSupply();
    //     uint256 _lastEmission = lastEmission;
    //     if (
    //         block.timestamp >= _lastEmission + _EMISSION_ERA &&
    //         maxSupply != currentSupply
    //     ) {
    //         uint256 eras = (block.timestamp - _lastEmission) / _EMISSION_ERA;

    //         // NOTE: Current Supply + Emission guaranteed to not overflow as <= maxSupply
    //         uint256 emission;
    //         for (uint256 i = 0; i < eras; i++)
    //             emission += getEraEmission(currentSupply + emission);

    //         _mint(address(usdv), emission);

    //         usdv.distributeEmission();

    //         _lastEmission += (_EMISSION_ERA * eras);
    //         lastEmission = _lastEmission;

    //         emit Emission(emission, _lastEmission);
    //     }
    // }
}",2588
RealWorld_BA_52_IERC20Metadata_RealWord_20240821111748.log,52,IERC20Metadata,3672,4023,7695,59.0,0.09882,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity 0.7.6;

interface IERC20Metadata {
    function decimals() external view returns (uint8);
}",42
RealWorld_BA_52_MockGovernorAlpha_RealWord_20240821093623.log,52,MockGovernorAlpha,7217,5420,12637,79.0,0.144485,"// SPDX-License-Identifier: UNLICENSED

pragma solidity =0.8.9;

import ""../governance/GovernorAlpha.sol"";

contract MockGovernorAlpha is GovernorAlpha {
    constructor(
        address guardian_,
        address xVader_,
        address feeReceiver_,
        uint256 feeAmount_,
        address council_
    )
        GovernorAlpha(
            guardian_,
            xVader_,
            feeReceiver_,
            feeAmount_,
            council_
        )
    {}

    function votingPeriod() public pure override returns (uint256) {
        return 50;
    }

    /// @notice mock function to get chain id from CHAINID opcode.
    /// Using ganache in truffle sets chainid but the a separate ganache or ganache in solidity-coverage
    /// does not set the CHAINID opcode and it default to 1, which results in web3.eth.getChainId and CHAINID opcode
    /// both returning different values.
    /// https://github.com/ethereum/web3.py/issues/1677
    function CHAINID() public view returns (uint256 chainId) {
        assembly {
            chainId := chainid()
        }
    }
}",243
RealWorld_BA_52_IAggregator_RealWord_20240821110259.log,52,IAggregator,3512,4197,7709,61.0,0.1015,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

interface IAggregator {
    function latestAnswer() external view returns (int256);
}",35
RealWorld_BA_52_Treasury_RealWord_20240821111152.log,52,Treasury,14402,5069,19471,75.0,0.17339,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity 0.7.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./interfaces/IERC20Metadata.sol"";
import ""./interfaces/ITreasury.sol"";
import ""./Ownable.sol"";

contract Treasury is Ownable, ITreasury {
    using SafeERC20 for IERC20;
    using SafeMath for uint;

    event SetBondContract(address bond, bool approved);
    event Withdraw(address indexed token, address indexed destination, uint amount);

    uint8 private immutable PAYOUT_TOKEN_DECIMALS;
    uint private immutable PAYOUT_TOKEN_SCALE; // 10 ** decimals

    address public immutable payoutToken;
    mapping(address => bool) public isBondContract;

    constructor(address _payoutToken) {
        require(_payoutToken != address(0), ""payout token = zero"");
        payoutToken = _payoutToken;
        uint8 decimals = IERC20Metadata(_payoutToken).decimals();
        PAYOUT_TOKEN_DECIMALS = decimals;
        PAYOUT_TOKEN_SCALE = 10**decimals;
    }

    modifier onlyBondContract() {
        require(isBondContract[msg.sender], ""not bond"");
        _;
    }

    /**
     *  @notice deposit principal token and recieve back payout token
     *  @param _principalToken address
     *  @param _principalAmount uint
     *  @param _payoutAmount uint
     */
    function deposit(
        address _principalToken,
        uint _principalAmount,
        uint _payoutAmount
    ) external override onlyBondContract {
        IERC20(_principalToken).safeTransferFrom(msg.sender, address(this), _principalAmount);
        IERC20(payoutToken).safeTransfer(msg.sender, _payoutAmount);
    }

    /**
     *   @notice returns payout token valuation of priciple
     *   @param _principalToken address
     *   @param _amount uint
     *   @return value uint
     */
    function valueOfToken(address _principalToken, uint _amount) external view override returns (uint) {
        // convert amount to match payout token decimals
        return _amount.mul(PAYOUT_TOKEN_SCALE).div(10**IERC20Metadata(_principalToken).decimals());
    }

    /**
     *  @notice owner can withdraw ERC20 token to desired address
     *  @param _token uint
     *  @param _destination address
     *  @param _amount uint
     */
    function withdraw(
        address _token,
        address _destination,
        uint _amount
    ) external onlyOwner {
        IERC20(_token).safeTransfer(_destination, _amount);
        emit Withdraw(_token, _destination, _amount);
    }

    /**
     *  @notice set bond contract
     *  @param _bond address
     *  @param _approve bool
     */
    function setBondContract(address _bond, bool _approve) external onlyOwner {
        require(isBondContract[_bond] != _approve, ""no change"");
        isBondContract[_bond] = _approve;
        emit SetBondContract(_bond, _approve);
    }
}",709
RealWorld_BA_52_FullMath_RealWord_20240821102619.log,52,FullMath,10162,4422,14584,61.0,0.13925,"// SPDX-License-Identifier: CC-BY-4.0
pragma solidity =0.8.9;

// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1
// license is CC-BY-4.0
library FullMath {
    function fullMul(uint256 x, uint256 y)
        internal
        pure
        returns (uint256 l, uint256 h)
    {
        uint256 mm = mulmod(x, y, type(uint256).max);
        l = x * y;
        h = mm - l;
        if (mm < l) h -= 1;
    }

    function fullDiv(
        uint256 l,
        uint256 h,
        uint256 d
    ) private pure returns (uint256) {
        uint256 pow2 = d & uint256(-int256(d));
        d /= pow2;
        l /= pow2;
        l += h * (uint256(-int256(pow2)) / pow2 + 1);
        uint256 r = 1;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        return l * r;
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 d
    ) internal pure returns (uint256) {
        (uint256 l, uint256 h) = fullMul(x, y);

        uint256 mm = mulmod(x, y, d);
        if (mm > l) h -= 1;
        l -= mm;

        if (h == 0) return l / d;

        require(h < d, ""FullMath: FULLDIV_OVERFLOW"");
        return fullDiv(l, h, d);
    }
}",437
RealWorld_BA_52_BitMath_RealWord_20240821101840.log,52,BitMath,13850,4639,18489,66.0,0.16203,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity =0.8.9;

library BitMath {
    // returns the 0 indexed position of the most significant bit of the input x
    // s.t. x >= 2**msb and x < 2**(msb+1)
    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {
        require(x > 0, ""BitMath::mostSignificantBit: zero"");

        if (x >= 0x100000000000000000000000000000000) {
            x >>= 128;
            r += 128;
        }
        if (x >= 0x10000000000000000) {
            x >>= 64;
            r += 64;
        }
        if (x >= 0x100000000) {
            x >>= 32;
            r += 32;
        }
        if (x >= 0x10000) {
            x >>= 16;
            r += 16;
        }
        if (x >= 0x100) {
            x >>= 8;
            r += 8;
        }
        if (x >= 0x10) {
            x >>= 4;
            r += 4;
        }
        if (x >= 0x4) {
            x >>= 2;
            r += 2;
        }
        if (x >= 0x2) r += 1;
    }

    // returns the 0 indexed position of the least significant bit of the input x
    // s.t. (x & 2**lsb) != 0 and (x & (2**(lsb) - 1)) == 0)
    // i.e. the bit at the index is set and the mask of all lower bits is 0
    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {
        require(x > 0, ""BitMath::leastSignificantBit: zero"");

        r = 255;
        if (x & type(uint128).max > 0) {
            r -= 128;
        } else {
            x >>= 128;
        }
        if (x & type(uint64).max > 0) {
            r -= 64;
        } else {
            x >>= 64;
        }
        if (x & type(uint32).max > 0) {
            r -= 32;
        } else {
            x >>= 32;
        }
        if (x & type(uint16).max > 0) {
            r -= 16;
        } else {
            x >>= 16;
        }
        if (x & type(uint8).max > 0) {
            r -= 8;
        } else {
            x >>= 8;
        }
        if (x & 0xf > 0) {
            r -= 4;
        } else {
            x >>= 4;
        }
        if (x & 0x3 > 0) {
            r -= 2;
        } else {
            x >>= 2;
        }
        if (x & 0x1 > 0) r -= 1;
    }
}",683
RealWorld_BA_52_Babylonian_RealWord_20240821102335.log,52,Babylonian,11386,4431,15817,78.0,0.14555,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity =0.8.9;

// computes square roots using the babylonian method
// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method
library Babylonian {
    // credit for this implementation goes to
    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687
    function sqrt(uint256 x) internal pure returns (uint256) {
        if (x == 0) return 0;
        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);
        // however that code costs significantly more gas
        uint256 xx = x;
        uint256 r = 1;
        if (xx >= 0x100000000000000000000000000000000) {
            xx >>= 128;
            r <<= 64;
        }
        if (xx >= 0x10000000000000000) {
            xx >>= 64;
            r <<= 32;
        }
        if (xx >= 0x100000000) {
            xx >>= 32;
            r <<= 16;
        }
        if (xx >= 0x10000) {
            xx >>= 16;
            r <<= 8;
        }
        if (xx >= 0x100) {
            xx >>= 8;
            r <<= 4;
        }
        if (xx >= 0x10) {
            xx >>= 4;
            r <<= 2;
        }
        if (xx >= 0x8) {
            r <<= 1;
        }
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1; // Seven iterations should be enough
        uint256 r1 = x / r;
        return (r < r1 ? r : r1);
    }
}",502
RealWorld_BA_52_Math_RealWord_20240821102455.log,52,Math,6009,4973,10982,82.0,0.129505,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

// a library for performing various math operations

library Math {
    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = x < y ? x : y;
    }

    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)
    function sqrt(uint256 y) internal pure returns (uint256 z) {
        if (y > 3) {
            z = y;
            uint256 x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }
}",185
RealWorld_BA_52_VaderPool_RealWord_20240821100805.log,52,VaderPool,16481,5405,21886,77.0,0.190505,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""./BasePool.sol"";

import ""../../interfaces/dex/pool/IVaderPool.sol"";

/*
 * @dev Implementation of {VaderPool} contract.
 *
 * The contract VaderPool inherits from {BasePool} contract and implements
 * queue system.
 *
 * Extends on the liquidity redeeming function by introducing the `burn` function
 * that internally calls the namesake on `BasePool` contract and computes the
 * loss covered by the position being redeemed and returns it along with amounts
 * of native and foreign assets sent.
 **/
contract VaderPool is IVaderPool, BasePool {
    /* ========== STATE VARIABLES ========== */

    // Denotes whether the queue system is active
    bool public queueActive;

    /* ========== CONSTRUCTOR ========== */

    /*
     * @dev Initializes contract's state by passing addresses of
     * native and foreign assets to {BasePool} contract and setting
     * active status of queue.
     **/
    constructor(
        bool _queueActive,
        IERC20Extended _nativeAsset,
        IERC20Extended _foreignAsset
    ) BasePool(_nativeAsset, _foreignAsset) {
        queueActive = _queueActive;
    }

    /* ========== VIEWS ========== */

    /* ========== MUTATIVE FUNCTIONS ========== */

    /*
     * @dev Allows burning of NFT represented by param {id} for liquidity redeeming.
     *
     * Deletes the position in {positions} mapping against the burned NFT token.
     *
     * Internally calls `_burn` function on {BasePool} contract.
     *
     * Calculates the impermanent loss incurred by the position.
     *
     * Returns the amounts for native and foreign assets sent to the {to} address
     * along with the covered loss.
     **/
    // NOTE: IL is only covered via router!
    function burn(uint256 id, address to)
        external
        override
        returns (
            uint256 amountNative,
            uint256 amountForeign,
            uint256 coveredLoss
        )
    {
        (amountNative, amountForeign) = _burn(id, to);

        Position storage position = positions[id];

        uint256 creation = position.creation;
        uint256 originalNative = position.originalNative;
        uint256 originalForeign = position.originalForeign;

        delete positions[id];

        // NOTE: Validate it behaves as expected for non-18 decimal tokens
        uint256 loss = VaderMath.calculateLoss(
            originalNative,
            originalForeign,
            amountNative,
            amountForeign
        );

        // TODO: Original Implementation Applied 100 Days
        coveredLoss =
            (loss * _min(block.timestamp - creation, _ONE_YEAR)) /
            _ONE_YEAR;
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    // TODO: Investigate Necessity
    function toggleQueue() external override onlyOwner {
        bool _queueActive = !queueActive;
        queueActive = _queueActive;
        emit QueueActive(_queueActive);
    }

    /* ========== INTERNAL FUNCTIONS ========== */

    /* ========== PRIVATE FUNCTIONS ========== */

    /**
     * @dev Ensures only the DAO is able to invoke a particular function by validating that
     * the owner is the msg.sender, equivalent to the DAO address
     */
    function _onlyDAO() private view {
        require(
            owner() == _msgSender(),
            ""BasePool::_onlyDAO: Insufficient Privileges""
        );
    }

    /**
     * @dev Calculates the minimum of the two values
     */
    function _min(uint256 a, uint256 b) private pure returns (uint256) {
        return a < b ? a : b;
    }

    /* ========== MODIFIERS ========== */

    /**
     * @dev Throws if invoked by anyone else other than the DAO
     */
    modifier onlyDAO() {
        _onlyDAO();
        _;
    }
}",806
RealWorld_BA_52_ITimelock_RealWord_20240821105208.log,52,ITimelock,6232,5502,11734,80.0,0.1412,"// SPDX-License-Identifier: UNLICENSED

pragma solidity =0.8.9;

interface ITimelock {
    function delay() external view returns (uint256);

    function GRACE_PERIOD() external pure returns (uint256);

    function acceptAdmin() external;

    function queuedTransactions(bytes32 hash) external view returns (bool);

    function queueTransaction(
        address target,
        uint256 value,
        string calldata signature,
        bytes calldata data,
        uint256 eta
    ) external returns (bytes32);

    function cancelTransaction(
        address target,
        uint256 value,
        string calldata signature,
        bytes calldata data,
        uint256 eta
    ) external;

    function executeTransaction(
        address target,
        uint256 value,
        string calldata signature,
        bytes calldata data,
        uint256 eta
    ) external payable returns (bytes memory);
}",184
RealWorld_BA_52_BasePoolV2_RealWord_20240821095350.log,52,BasePoolV2,72383,5823,78206,91.0,0.478375,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

import ""../../shared/ProtocolConstants.sol"";

import ""../../dex/math/VaderMath.sol"";
import ""../../dex/utils/GasThrottle.sol"";

import ""../../external/libraries/UQ112x112.sol"";

import ""../../interfaces/dex-v2/pool/IBasePoolV2.sol"";

/*
 * @dev Implementation of {BasePoolV2} contract.
 *
 * The BasePoolV2 contract keeps track of all the Vader pools in the form of
 * pairs. Each pair tracked through {pairInfo} mapping and is mapped against the
 * foreign asset for which the pair is created.
 *
 * Has function to deposited liquidity to any of pair by specifying the mapped
 * foreign asset against the pair.
 *
 * The minted liquidity is associated with a position, that is tracked by a minted NFT.
 * The NFT has information about the pair for which it represents the liquidity.
 *
 * The contract allows redeeming of liquidity against a particular pool by burning the
 * associated position representing NFT.
 *
 * The contract allows swapping of native to foreign assets and vice versa within a pair and
 * allows foreign to foreign asset swap across two different pairs.
 *
 * Keeps track of the cumulative prices for both native and foreign assets for
 * pairs and updates them after minting and burning of liquidity, and swapping of assets.
 **/
contract BasePoolV2 is
    IBasePoolV2,
    ProtocolConstants,
    GasThrottle,
    ERC721,
    ReentrancyGuard
{
    /* ========== LIBRARIES ========== */

    // Used for safe token transfers
    using SafeERC20 for IERC20;

    // Used by Uniswap-like TWAP mechanism
    using UQ112x112 for uint224;

    /* ========== STATE VARIABLES ========== */

    // Address of native asset (Vader or USDV).
    IERC20 public immutable override nativeAsset;

    // Denotes what tokens are actively supported by the system
    mapping(IERC20 => bool) public override supported;

    /*
     * @dev A mapping of foreign asset to the pool's pair.
     * Each pair is represents a pool of native and foreign assets and
     * contains data such as the reserves of native and foreign assets and
     * the liquidity units issues against the deposits of these assets.
     **/
    mapping(IERC20 => PairInfo) public pairInfo;

    /*
     * @dev A mapping representing positions of liquidity providers. Each position
     * is an Non-fungible token that is mapped against amounts of native and foreign assets
     * deposited across different pools of pairs the timestamp at which the position
     * is created and the amount of liquidity of a particular pool assigned to the LP.
     *
     * Each position in the mapping is mapped against {positionId}.
     **/
    mapping(uint256 => Position) public positions;

    // A unique id the of the position created when liquidity is added to a pool.
    uint256 public positionId;

    // Address of the router contract (used for restriction)
    address public router;

    /* ========== CONSTRUCTOR ========== */

    /*
     * @dev Initializes the contract by setting address of native asset.
     **/
    constructor(IERC20 _nativeAsset) ERC721(""Vader LP"", ""VLP"") {
        require(
            _nativeAsset != IERC20(_ZERO_ADDRESS),
            ""BasePoolV2::constructor: Incorrect Arguments""
        );
        nativeAsset = IERC20(_nativeAsset);
    }

    /* ========== VIEWS ========== */

    /*
     * @dev Accepts address of foreign asset {foreignAsset} to determine the pair (pool)
     * and returns reserves amounts of native and foreign assets, and the last timestamp
     * when cumulative prices for these assets were updated.
     **/
    function getReserves(IERC20 foreignAsset)
        public
        view
        returns (
            uint112 reserveNative,
            uint112 reserveForeign,
            uint32 blockTimestampLast
        )
    {
        PairInfo storage pair = pairInfo[foreignAsset];
        (reserveNative, reserveForeign, blockTimestampLast) = (
            pair.reserveNative,
            pair.reserveForeign,
            pair.blockTimestampLast
        );
    }

    /*
     * @dev Accepts {id} of a liquidity position and returns foreign asset's
     * address for that particular liquidity position.
     **/
    function positionForeignAsset(uint256 id)
        external
        view
        override
        returns (IERC20)
    {
        return positions[id].foreignAsset;
    }

    function pairSupply(IERC20 foreignAsset)
        external
        view
        override
        returns (uint256)
    {
        return pairInfo[foreignAsset].totalSupply;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    /*
     * @dev Allows depositing of liquidity to a pool/pair by accepting native and foreign assets
     * and mints an NFT to the {to} address which records in {positions} mapping, the amounts
     * of the native and foreign assets deposited and the liquidity units minted against.
     *
     * The pool/pair to accept the native and foreign assets against is determined by {foreignAsset}.
     *
     * Updates the total supply of liquidity units by adding currently minted liquidity units
     * to {pair.totalSupply} of pair/pool.
     *
     * Updates the cumulative prices of native and foreign assets in pool/pair after minting the appropriate
     * liquidity units.
     *
     * Requirements:
     * - Amounts of native and foreign must be approved to the pool prior to calling the `mint` function.
     * - The amount of {liquidity} to be minted must be greater than 0.
     * - The param {foreignAsset} must be a supported token.
     * - Can only be called by Router.
     **/
    function mint(
        IERC20 foreignAsset,
        uint256 nativeDeposit,
        uint256 foreignDeposit,
        address from,
        address to
    )
        external
        override
        nonReentrant
        onlyRouter
        supportedToken(foreignAsset)
        returns (uint256 liquidity)
    {
        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(
            foreignAsset
        ); // gas savings

        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);
        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);

        PairInfo storage pair = pairInfo[foreignAsset];
        uint256 totalLiquidityUnits = pair.totalSupply;
        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;
        else
            liquidity = VaderMath.calculateLiquidityUnits(
                nativeDeposit,
                reserveNative,
                foreignDeposit,
                reserveForeign,
                totalLiquidityUnits
            );

        require(
            liquidity > 0,
            ""BasePoolV2::mint: Insufficient Liquidity Provided""
        );

        uint256 id = positionId++;

        pair.totalSupply = totalLiquidityUnits + liquidity;
        _mint(to, id);

        positions[id] = Position(
            foreignAsset,
            block.timestamp,
            liquidity,
            nativeDeposit,
            foreignDeposit
        );

        _update(
            foreignAsset,
            reserveNative + nativeDeposit,
            reserveForeign + foreignDeposit,
            reserveNative,
            reserveForeign
        );

        emit Mint(from, to, nativeDeposit, foreignDeposit);
        emit PositionOpened(from, to, id, liquidity);
    }

    /*
     * @dev Allows redeeming of liquidity units by burning the NFT with {id} associated with the liquidity
     * position.
     *
     * Computes the amounts of native and foreign assets from pool/pair against which the NFT with Id {id}
     * was minted. The computed assets' amounts depends upon current reserves of assets and
     * the liquidity associated with the position, and is transferred to the {to} address.
     *
     * Burns the redeemed NFT token and decreases {pair.totalSupply} by the {liquidity}
     * associated with that NFT token.
     *
     * Updates the cumulative prices for native and foreign assets in pool/pair after transferring the assets
     * to the {to} address.
     *
     * Requirements:
     * - The NFT token being redeemed must be transferred to the contract prior to calling `_burn`.
     * - The amount of native and foreign assets computed for transfer to {to} address must be greater
     *   than 0.
     **/
    function _burn(uint256 id, address to)
        internal
        nonReentrant
        returns (uint256 amountNative, uint256 amountForeign)
    {
        require(
            ownerOf(id) == address(this),
            ""BasePoolV2::burn: Incorrect Ownership""
        );

        IERC20 foreignAsset = positions[id].foreignAsset;

        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(
            foreignAsset
        ); // gas savings

        uint256 liquidity = positions[id].liquidity;

        PairInfo storage pair = pairInfo[foreignAsset];
        uint256 _totalSupply = pair.totalSupply;
        amountNative = (liquidity * reserveNative) / _totalSupply;
        amountForeign = (liquidity * reserveForeign) / _totalSupply;

        require(
            amountNative > 0 && amountForeign > 0,
            ""BasePoolV2::burn: Insufficient Liquidity Burned""
        );

        pair.totalSupply = _totalSupply - liquidity;
        _burn(id);

        nativeAsset.safeTransfer(to, amountNative);
        foreignAsset.safeTransfer(to, amountForeign);

        _update(
            foreignAsset,
            reserveNative - amountNative,
            reserveForeign - amountForeign,
            reserveNative,
            reserveForeign
        );

        emit Burn(msg.sender, amountNative, amountForeign, to);
    }

    /*
     * @dev Allows swapping between two foreign assets from two different pools/pairs.
     *
     * It receives amount {foreignAmountIn} in {foreignAssetA} and returns the swapped amount in {foreignAssetB}.
     *
     * The amount {foreignAmountIn} is swapped to the native asset from the pair against {foreignAssetA} and the
     * received native asset is swapped to foreign asset from the pair against {foreignAssetB}.
     *
     * Updates the cumulative prices for native and foreign assets across pools against assets {foreignAssetA} and
     * {foreignAssetB}.
     *
     * Requirements:
     * - The amount {foreignAmountIn} in {foreignAssetA} must be transferred to the contract prior to calling
     *   the function `doubleSwap`.
     * - The intermediary native asset retrieved from first swap must be greater than 0 and the reserve for native asset.
     * - The foreign amount received from second swap must be greater than 0 and the reserve for foreign asset in the pair/pool
     *   against that particular foreign asset.
     * - The params {foreignAssetA} and {foreignAssetB} must be the supported tokens.
     * - Can only be called by Router.
     **/
    function doubleSwap(
        IERC20 foreignAssetA,
        IERC20 foreignAssetB,
        uint256 foreignAmountIn,
        address to
    )
        external
        override
        onlyRouter
        supportedToken(foreignAssetA)
        supportedToken(foreignAssetB)
        nonReentrant
        validateGas
        returns (uint256 foreignAmountOut)
    {
        (uint112 nativeReserve, uint112 foreignReserve, ) = getReserves(
            foreignAssetA
        ); // gas savings

        require(
            foreignReserve + foreignAmountIn <=
                foreignAssetA.balanceOf(address(this)),
            ""BasePoolV2::doubleSwap: Insufficient Tokens Provided""
        );

        uint256 nativeAmountOut = VaderMath.calculateSwap(
            foreignAmountIn,
            foreignReserve,
            nativeReserve
        );

        require(
            nativeAmountOut > 0 && nativeAmountOut <= nativeReserve,
            ""BasePoolV2::doubleSwap: Swap Impossible""
        );

        _update(
            foreignAssetA,
            nativeReserve - nativeAmountOut,
            foreignReserve + foreignAmountIn,
            nativeReserve,
            foreignReserve
        );

        emit Swap(
            foreignAssetA,
            msg.sender,
            0,
            foreignAmountIn,
            nativeAmountOut,
            0,
            address(this)
        );

        (nativeReserve, foreignReserve, ) = getReserves(foreignAssetB); // gas savings

        foreignAmountOut = VaderMath.calculateSwap(
            nativeAmountOut,
            nativeReserve,
            foreignReserve
        );

        require(
            foreignAmountOut > 0 && foreignAmountOut <= foreignReserve,
            ""BasePoolV2::doubleSwap: Swap Impossible""
        );

        _update(
            foreignAssetB,
            nativeReserve + nativeAmountOut,
            foreignReserve - foreignAmountOut,
            nativeReserve,
            foreignReserve
        );

        emit Swap(
            foreignAssetB,
            msg.sender,
            nativeAmountOut,
            0,
            0,
            foreignAmountOut,
            to
        );

        foreignAssetB.safeTransfer(to, foreignAmountOut);
    }

    /*
     * @dev Allows swapping between native and foreign assets from within a single pair/pool determined
     * by {foreignAsset}.
     *
     * It receives the source asset and computes the destination asset and transfers it to the {to} address.
     *
     * Updates the cumulative prices for native and foreign assets for the pair involved after performing swap.
     *
     * Returns the amount of destination tokens resulting from the swap.
     *
     * Requirements:
     * - Param {nativeAmountIn} must be zero and {foreignAmountIn} must be non-zero
     *   if the destination asset in swap is native asset.
     * - Param {foreignAmountIn} must be zero and {nativeAmountIn} must be non zero
     *   if the destination asset in swap is foreign asset.
     * - Param {to} cannot be the addresses of native or foreign assets.
     * - The source asset amount in the swap must be transferred to the pool prior to calling `swap`.
     * - The source asset amount in the swap cannot exceed the source asset's reserve.
     * - The destination asset's amount in the swap must be greater than 0 and not exceed destination
     *   asset's reserve.
     * - The param {foreignAsset} must be a supported token.
     * - Can only be called by Router.
     **/
    function swap(
        IERC20 foreignAsset,
        uint256 nativeAmountIn,
        uint256 foreignAmountIn,
        address to
    )
        external
        override
        onlyRouter
        supportedToken(foreignAsset)
        nonReentrant
        validateGas
        returns (uint256)
    {
        require(
            (nativeAmountIn > 0 && foreignAmountIn == 0) ||
                (nativeAmountIn == 0 && foreignAmountIn > 0),
            ""BasePoolV2::swap: Only One-Sided Swaps Supported""
        );
        (uint112 nativeReserve, uint112 foreignReserve, ) = getReserves(
            foreignAsset
        ); // gas savings

        uint256 nativeAmountOut;
        uint256 foreignAmountOut;
        {
            // scope for _token{0,1}, avoids stack too deep errors
            IERC20 _nativeAsset = nativeAsset;
            require(
                to != address(_nativeAsset) && to != address(foreignAsset),
                ""BasePoolV2::swap: Invalid Receiver""
            );

            if (foreignAmountIn > 0) {
                nativeAmountOut = VaderMath.calculateSwap(
                    foreignAmountIn,
                    foreignReserve,
                    nativeReserve
                );
                require(
                    nativeAmountOut > 0 && nativeAmountOut <= nativeReserve,
                    ""BasePoolV2::swap: Swap Impossible""
                );
                _nativeAsset.safeTransfer(to, nativeAmountOut); // optimistically transfer tokens
            } else {
                foreignAmountOut = VaderMath.calculateSwap(
                    nativeAmountIn,
                    nativeReserve,
                    foreignReserve
                );
                require(
                    foreignAmountOut > 0 && foreignAmountOut <= foreignReserve,
                    ""BasePoolV2::swap: Swap Impossible""
                );
                foreignAsset.safeTransfer(to, foreignAmountOut); // optimistically transfer tokens
            }
        }

        _update(
            foreignAsset,
            nativeReserve - nativeAmountOut + nativeAmountIn,
            foreignReserve - foreignAmountOut + foreignAmountIn,
            nativeReserve,
            foreignReserve
        );

        emit Swap(
            foreignAsset,
            msg.sender,
            nativeAmountIn,
            foreignAmountIn,
            nativeAmountOut,
            foreignAmountOut,
            to
        );

        return nativeAmountOut > 0 ? nativeAmountOut : foreignAmountOut;
    }

    /*
     * @dev Allows withdrawing of unaccounted/unrealised foreign asset from the contract.
     *
     * Determines the realised amount of foreign asset from the pair against {foreignAsset}.
     **/
    function rescue(IERC20 foreignAsset) external {
        uint256 foreignBalance = foreignAsset.balanceOf(address(this));
        uint256 reserveForeign = pairInfo[foreignAsset].reserveForeign;

        uint256 unaccounted = foreignBalance - reserveForeign;

        foreignAsset.safeTransfer(msg.sender, unaccounted);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    /* ========== INTERNAL FUNCTIONS ========== */

    /*
     * @dev Internally called to update the cumulative prices for native and foreign assets for
     * the pair against {foreignAsset}. The updated prices depend upon the last reserves and
     * updates the reserves for both of the assets corresponding to their
     * current balances along with the timestamp.
     *
     * Requirements:
     * - Params {balanceNative} and {balanceForeign} must not overflow type `uint112`.
     *
     **/
    function _update(
        IERC20 foreignAsset,
        uint256 balanceNative,
        uint256 balanceForeign,
        uint112 reserveNative,
        uint112 reserveForeign
    ) internal {
        require(
            balanceNative <= type(uint112).max &&
                balanceForeign <= type(uint112).max,
            ""BasePoolV2::_update: Balance Overflow""
        );
        uint32 blockTimestamp = uint32(block.timestamp % 2**32);
        PairInfo storage pair = pairInfo[foreignAsset];
        unchecked {
            uint32 timeElapsed = blockTimestamp - pair.blockTimestampLast; // overflow is desired
            if (timeElapsed > 0 && reserveNative != 0 && reserveForeign != 0) {
                // * never overflows, and + overflow is desired
                pair.priceCumulative.nativeLast +=
                    uint256(
                        UQ112x112.encode(reserveForeign).uqdiv(reserveNative)
                    ) *
                    timeElapsed;
                pair.priceCumulative.foreignLast +=
                    uint256(
                        UQ112x112.encode(reserveNative).uqdiv(reserveForeign)
                    ) *
                    timeElapsed;
            }
        }
        pair.reserveNative = uint112(balanceNative);
        pair.reserveForeign = uint112(balanceForeign);
        pair.blockTimestampLast = blockTimestamp;
        emit Sync(foreignAsset, balanceNative, balanceForeign);
    }

    /* ========== PRIVATE FUNCTIONS ========== */

    /*
     * @dev Private function that returns if the param {token} is a supported token
     * or not.
     **/
    function _supportedToken(IERC20 token) private view {
        require(
            supported[token],
            ""BasePoolV2::_supportedToken: Unsupported Token""
        );
    }

    /*
     * @dev Private function that returns if {msg.sender} is a Router or not.
     **/
    function _onlyRouter() private view {
        require(
            msg.sender == router,
            ""BasePoolV2::_onlyRouter: Only Router is allowed to call""
        );
    }

    /* ========== MODIFIERS ========== */

    /*
     * @dev Modifier that only allows continuation of execution
     * if {msg.sender} is Router.
     **/
    modifier onlyRouter() {
        _onlyRouter();
        _;
    }

    /*
     * @dev Modifier that only allows continuation of exectuion if the param
     * {token} is a supported token.
     **/
    modifier supportedToken(IERC20 token) {
        _supportedToken(token);
        _;
    }
}",4367
RealWorld_BA_52_Owned_RealWord_20240821094000.log,52,Owned,6861,5075,11936,69.0,0.135805,"// SPDX-License-Identifier: Unlicense
pragma solidity 0.8.9;
  
contract Owned {
    address public owner;
    address public nominatedOwner;

    constructor(address _owner) {
        require(_owner != address(0), ""Owner address cannot be 0"");
        owner = _owner;
        emit OwnerChanged(address(0), _owner);
    }

    function nominateNewOwner(address _owner) external onlyOwner {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }

    function acceptOwnership() external {
        require(msg.sender == nominatedOwner, ""You must be nominated before you can accept ownership"");
        emit OwnerChanged(owner, nominatedOwner);
        owner = nominatedOwner;
        nominatedOwner = address(0);
    }

    modifier onlyOwner {
        _onlyOwner();
        _;
    }

    function _onlyOwner() private view {
        require(msg.sender == owner, ""Only the contract owner may perform this action"");
    }

    event OwnerNominated(address newOwner);
    event OwnerChanged(address oldOwner, address newOwner);
}",221
RealWorld_BA_52_ISwapQueue_RealWord_20240821105653.log,52,ISwapQueue,4395,4844,9239,64.0,0.118855,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

interface ISwapQueue {
    /* ========== STRUCTS ========== */

    struct Node {
        uint256 value;
        uint256 previous;
        uint256 next;
    }

    struct Queue {
        mapping(uint256 => Node) linkedList;
        uint256 start;
        uint256 end;
        uint256 size;
    }

    /* ========== FUNCTIONS ========== */
    /* ========== EVENTS ========== */
}",94
RealWorld_BA_52_RewardsDistributionRecipient_RealWord_20240821094526.log,52,RewardsDistributionRecipient,5318,5366,10684,76.0,0.13391,"// SPDX-License-Identifier: Unlicense
pragma solidity 0.8.9;

import ""./Owned.sol"";

abstract contract RewardsDistributionRecipient is Owned {
    address public rewardsDistribution;

    function notifyRewardAmount(uint reward) external virtual;

    modifier onlyRewardsDistribution() {
        require(msg.sender == rewardsDistribution, ""not reward distribution"");
        _;
    }

    function setRewardsDistribution(address _rewardsDistribution) external onlyOwner {
        rewardsDistribution = _rewardsDistribution;
    }
}",101
RealWorld_BA_52_IVaderRouter_RealWord_20240821110029.log,52,IVaderRouter,8366,4960,13326,79.0,0.14103,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IVaderRouter {
    /* ========== STRUCTS ========== */
    /* ========== FUNCTIONS ========== */

    function addLiquidity(
        IERC20 tokenA,
        IERC20 tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256, // amountAMin = unused
        uint256, // amountBMin = unused
        address to,
        uint256 deadline
    )
        external
        returns (
            uint256 amountA,
            uint256 amountB,
            uint256 liquidity
        );

    function addLiquidity(
        IERC20 tokenA,
        IERC20 tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        address to,
        uint256 deadline
    )
        external
        returns (
            uint256 amountA,
            uint256 amountB,
            uint256 liquidity
        );

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 id,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB);

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256 amountOut);

    /* ========== EVENTS ========== */
}",334
RealWorld_BA_52_Timelock_RealWord_20240821100118.log,52,Timelock,36302,5353,41655,77.0,0.28857,"// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.9;

import ""../interfaces/governance/ITimelock.sol"";

/**
 * @dev Implementation of {Timelock} contract.
 *
 * It allows queueing, execution and cancellation of transactions by the
 * {admin}. A queued transaction can be executed after the cool-time represented
 * by {delay} has elapsed and grace period has not passed since the queuing
 * of transaction.
 *
 * It allows changing of contract's admin through a queued transaction by the
 * prior admin. The new admin the calls {acceptAdmin} to accept its role.
 */
contract Timelock is ITimelock {
    // Current admin of the contract
    address public admin;

    // Pending admin of the contract
    address public pendingAdmin;

    // Cool-off before a queued transaction is executed
    uint256 public override delay;

    // Queued status of a transaction (txHash => tx status).
    mapping(bytes32 => bool) public override queuedTransactions;

    // Emitted when a new admin is set
    event NewAdmin(address indexed newAdmin);

    // Emitted when a new pending admin is set
    event NewPendingAdmin(address indexed newPendingAdmin);

    // Emitted when a new delay/cool-off time is set
    event NewDelay(uint256 indexed newDelay);

    // Emitted when a tx is cancelled
    event CancelTransaction(
        bytes32 indexed txHash,
        address indexed target,
        uint256 value,
        string signature,
        bytes data,
        uint256 eta
    );

    // Emitted when a tx is executed
    event ExecuteTransaction(
        bytes32 indexed txHash,
        address indexed target,
        uint256 value,
        string signature,
        bytes data,
        uint256 eta
    );

    // Emitted when a tx is queued
    event QueueTransaction(
        bytes32 indexed txHash,
        address indexed target,
        uint256 value,
        string signature,
        bytes data,
        uint256 eta
    );

    /**
     * @dev Allows of receiving of ether beforehand or in bulk, so the sending
     * ether is optional at the time of tx execution.
     */
    receive() external payable {}

    /* ========== CONSTRUCTOR ========== */

    /**
     * @dev Sets contract's state variable of {admin} and {delay}
     *
     * Requirements:
     * - `admin_` param must not be a zero address
     * - `delay_` param must be within range or min and max delay
     */
    constructor(address admin_, uint256 delay_) {
        require(
            delay_ >= MINIMUM_DELAY(),
            ""Timelock::constructor: Delay must exceed minimum delay.""
        );
        require(
            delay_ <= MAXIMUM_DELAY(),
            ""Timelock::constructor: Delay must not exceed maximum delay.""
        );

        require(
            admin_ != address(0),
            ""Timelock::constructor: Admin cannot be zero""
        );

        admin = admin_;
        delay = delay_;
    }

    /* ========== VIEWS ========== */
    /**
     * @dev Returns the time period a tx is valid for execution after eta has elapsed.
     */
    function GRACE_PERIOD() public pure virtual override returns (uint256) {
        return 14 days;
    }

    /**
     * @dev Returns the minimum delay required for execution after a tx is queued
     */
    function MINIMUM_DELAY() public pure virtual returns (uint256) {
        return 2 days;
    }

    /**
     * @dev Returns the maxium delay required for execution after a tx is queued
     */
    function MAXIMUM_DELAY() public pure virtual returns (uint256) {
        return 30 days;
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    /**
     * @dev Sets the the new value of {delay}.
     * It allows setting of new delay value through queued tx by the admin
     *
     * Requirements:
     * - only current contract can call it
     * - `delay_` param must be within the min and max delay range
     */
    function setDelay(uint256 delay_) public {
        require(
            msg.sender == address(this),
            ""Timelock::setDelay: Call must come from Timelock.""
        );
        require(
            delay_ >= MINIMUM_DELAY(),
            ""Timelock::setDelay: Delay must exceed minimum delay.""
        );
        require(
            delay_ <= MAXIMUM_DELAY(),
            ""Timelock::setDelay: Delay must not exceed maximum delay.""
        );
        delay = delay_;

        emit NewDelay(delay);
    }

    /**
     * @dev Sets {pendingAdmin} to admin of current contract.
     * A {GovernorAlpha} contract which is already set as {pendingAdmin}
     * of this contract calls this function to set itself as new admin.
     *
     * Requirements:
     * - only callable by {pendingAdmin}
     */
    function acceptAdmin() public override {
        require(
            msg.sender == pendingAdmin,
            ""Timelock::acceptAdmin: Call must come from pendingAdmin.""
        );
        admin = msg.sender;
        pendingAdmin = address(0);

        emit NewAdmin(admin);
    }

    /**
     * @dev Sets the the new value of {pendingAdmin_}.
     * It allows setting of new pendingAdmin value through queued tx by the admin
     *
     * Requirements:
     * - only current contract can call it
     */
    function setPendingAdmin(address pendingAdmin_) public {
        require(
            msg.sender == address(this),
            ""Timelock::setPendingAdmin: Call must come from Timelock.""
        );
        pendingAdmin = pendingAdmin_;

        emit NewPendingAdmin(pendingAdmin);
    }

    /**
     * @dev Queues a transaction by setting its status in {queuedTransactions} mapping.
     *
     * Requirements:
     * - only callable by {admin}
     * - `eta` must lie in future compared to delay referenced from current block
     */
    function queueTransaction(
        address target,
        uint256 value,
        string memory signature,
        bytes memory data,
        uint256 eta
    ) public override returns (bytes32 txHash) {
        require(
            msg.sender == admin,
            ""Timelock::queueTransaction: Call must come from admin.""
        );
        require(
            eta >= getBlockTimestamp() + delay,
            ""Timelock::queueTransaction: Estimated execution block must satisfy delay.""
        );

        txHash = keccak256(abi.encode(target, value, signature, data, eta));
        queuedTransactions[txHash] = true;

        emit QueueTransaction(txHash, target, value, signature, data, eta);
    }

    /**
     * @dev Cancels a transaction by setting its status in {queuedTransactions} mapping.
     *
     * Requirements:
     * - only callable by {admin}
     */
    function cancelTransaction(
        address target,
        uint256 value,
        string memory signature,
        bytes memory data,
        uint256 eta
    ) public override {
        require(
            msg.sender == admin,
            ""Timelock::cancelTransaction: Call must come from admin.""
        );

        bytes32 txHash = keccak256(
            abi.encode(target, value, signature, data, eta)
        );
        queuedTransactions[txHash] = false;

        emit CancelTransaction(txHash, target, value, signature, data, eta);
    }

    /**
     * @dev Executes a transaction by making a low level call to its `target`.
     * The call reverts if the low-level call made to `target` reverts.
     *
     * Requirements:
     * - only callable by {admin}
     * - tx must already be queued
     * - current timestamp is ahead of tx's eta
     * - grace period associated with the tx must not have passed
     * - the low-level call to tx's `target` must not revert
     */
    function executeTransaction(
        address target,
        uint256 value,
        string memory signature,
        bytes memory data,
        uint256 eta
    ) public payable override returns (bytes memory) {
        require(
            msg.sender == admin,
            ""Timelock::executeTransaction: Call must come from admin.""
        );

        bytes32 txHash = keccak256(
            abi.encode(target, value, signature, data, eta)
        );
        require(
            queuedTransactions[txHash],
            ""Timelock::executeTransaction: Transaction hasn't been queued.""
        );
        require(
            getBlockTimestamp() >= eta,
            ""Timelock::executeTransaction: Transaction hasn't surpassed time lock.""
        );
        require(
            getBlockTimestamp() <= eta + GRACE_PERIOD(),
            ""Timelock::executeTransaction: Transaction is stale.""
        );

        queuedTransactions[txHash] = false;

        bytes memory callData;

        if (bytes(signature).length == 0) {
            callData = data;
        } else {
            callData = abi.encodePacked(
                bytes4(keccak256(bytes(signature))),
                data
            );
        }

        // solium-disable-next-line security/no-call-value
        (bool success, bytes memory returnData) = target.call{value: value}(
            callData
        );

        require(
            success,
            ""Timelock::executeTransaction: Transaction execution reverted.""
        );

        emit ExecuteTransaction(txHash, target, value, signature, data, eta);

        return returnData;
    }

    /* ========== INTERNAL FUNCTIONS ========== */

    /**
     * @dev Gets timestamp from the current block.
     */
    function getBlockTimestamp() internal view returns (uint256) {
        // solium-disable-next-line security/no-block-members
        return block.timestamp;
    }
}",2040
RealWorld_BA_52_SynthFactory_RealWord_20240821094945.log,52,SynthFactory,6264,5013,11277,80.0,0.13158,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""./Synth.sol"";

import ""../../interfaces/dex-v2/synth/ISynthFactory.sol"";

contract SynthFactory is ISynthFactory, ProtocolConstants, Ownable {
    mapping(IERC20 => ISynth) public override synths;

    constructor(address _pool) {
        require(
            _pool != _ZERO_ADDRESS,
            ""SynthFactory::constructor: Misconfiguration""
        );
        transferOwnership(_pool);
    }

    function createSynth(IERC20Extended token)
        external
        override
        onlyOwner
        returns (ISynth)
    {
        require(
            synths[IERC20(token)] == ISynth(_ZERO_ADDRESS),
            ""SynthFactory::createSynth: Already Created""
        );

        Synth synth = new Synth(token);

        synth.transferOwnership(owner());

        synths[IERC20(token)] = synth;

        return synth;
    }
}",204
RealWorld_BA_52_VaderMath_RealWord_20240821100359.log,52,VaderMath,28049,5988,34037,92.0,0.260005,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

library VaderMath {
    /* ========== CONSTANTS ========== */

    uint256 public constant ONE = 1 ether;

    /* ========== LIBRARY FUNCTIONS ========== */

    /**
     * @dev Calculates the amount of liquidity units for the {vaderDeposited}
     * and {assetDeposited} amounts across {totalPoolUnits}.
     *
     * The {vaderBalance} and {assetBalance} are taken into account in order to
     * calculate any necessary slippage adjustment.
     */
    function calculateLiquidityUnits(
        uint256 vaderDeposited,
        uint256 vaderBalance,
        uint256 assetDeposited,
        uint256 assetBalance,
        uint256 totalPoolUnits
    ) public pure returns (uint256) {
        // slipAdjustment
        uint256 slip = calculateSlipAdjustment(
            vaderDeposited,
            vaderBalance,
            assetDeposited,
            assetBalance
        );

        // (Va + vA)
        uint256 poolUnitFactor = (vaderBalance * assetDeposited) +
            (vaderDeposited * assetBalance);

        // 2VA
        uint256 denominator = ONE * 2 * vaderBalance * assetBalance;

        // P * [(Va + vA) / (2 * V * A)] * slipAdjustment
        return ((totalPoolUnits * poolUnitFactor) / denominator) * slip;
    }

    /**
    * @dev Calculates the necessary slippage adjustment for the {vaderDeposited} and {assetDeposited}
    * amounts across the total {vaderBalance} and {assetBalance} amounts.
    */
    function calculateSlipAdjustment(
        uint256 vaderDeposited,
        uint256 vaderBalance,
        uint256 assetDeposited,
        uint256 assetBalance
    ) public pure returns (uint256) {
        // Va
        uint256 vaderAsset = vaderBalance * assetDeposited;

        // aV
        uint256 assetVader = assetBalance * vaderDeposited;

        // (v + V) * (a + A)
        uint256 denominator = (vaderDeposited + vaderBalance) *
            (assetDeposited + assetBalance);

        // 1 - [|Va - aV| / (v + V) * (a + A)]
        return ONE - (delta(vaderAsset, assetVader) / denominator);
    }

    /**
    * @dev Calculates the loss based on the supplied {releasedVader} and {releasedAsset}
    * compared to the supplied {originalVader} and {originalAsset}.
    */
    function calculateLoss(
        uint256 originalVader,
        uint256 originalAsset,
        uint256 releasedVader,
        uint256 releasedAsset
    ) public pure returns (uint256 loss) {
        //
        // TODO: Vader Formula Differs https://github.com/vetherasset/vaderprotocol-contracts/blob/main/contracts/Utils.sol#L347-L356
        //

        // [(A0 * P1) + V0]
        uint256 originalValue = ((originalAsset * releasedVader) /
            releasedAsset) + originalVader;

        // [(A1 * P1) + V1]
        uint256 releasedValue = ((releasedAsset * releasedVader) /
            releasedAsset) + releasedVader;

        // [(A0 * P1) + V0] - [(A1 * P1) + V1]
        if (originalValue > releasedValue) loss = originalValue - releasedValue;
    }

    /**
    * @dev Calculates the {amountOut} of the swap based on the supplied {amountIn}
    * across the supplied {reserveIn} and {reserveOut} amounts.
    */
    function calculateSwap(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) public pure returns (uint256 amountOut) {
        // x * Y * X
        uint256 numerator = amountIn * reserveIn * reserveOut;

        // (x + X) ^ 2
        uint256 denominator = pow(amountIn + reserveIn);

        amountOut = numerator / denominator;
    }

    /**
    * @dev Calculates the {amountIn} of the swap based on the supplied {amountOut}
    * across the supplied {reserveIn} and {reserveOut} amounts.
    */
    function calculateSwapReverse(
        uint256 amountOut,
        uint256 reserveIn,
        uint256 reserveOut
    ) public pure returns (uint256 amountIn) {
        // X * Y
        uint256 XY = reserveIn * reserveOut;

        // 2y
        uint256 y2 = amountOut * 2;

        // 4y
        uint256 y4 = y2 * 2;

        require(
            y4 < reserveOut,
            ""VaderMath::calculateSwapReverse: Desired Output Exceeds Maximum Output Possible (1/4 of Liquidity Pool)""
        );

        // root(-X^2 * Y * (4y - Y))    =>    root(X^2 * Y * (Y - 4y)) as Y - 4y >= 0    =>    Y >= 4y holds true
        uint256 numeratorA = root(XY) * root(reserveIn * (reserveOut - y4));

        // X * (2y - Y)    =>    2yX - XY
        uint256 numeratorB = y2 * reserveIn;
        uint256 numeratorC = XY;

        // -1 * (root(-X^2 * Y * (4y - Y)) + (X * (2y - Y)))    =>    -1 * (root(X^2 * Y * (Y - 4y)) + 2yX - XY)    =>    XY - root(X^2 * Y * (Y - 4y) - 2yX
        uint256 numerator = numeratorC - numeratorA - numeratorB;

        // 2y
        uint256 denominator = y2;

        amountIn = numerator / denominator;
    }

    /**
    * @dev Calculates the difference between the supplied {a} and {b} values as a positive number.
    */
    function delta(uint256 a, uint256 b) public pure returns (uint256) {
        return a > b ? a - b : b - a;
    }

    /**
    * @dev Calculates the power of 2 of the supplied {a} value.
    */
    function pow(uint256 a) public pure returns (uint256) {
        return a * a;
    }

    /**
    * @dev Calculates the square root {c} of the supplied {a} value utilizing the Babylonian method:
    * https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method
    */
    function root(uint256 a) public pure returns (uint256 c) {
        if (a > 3) {
            c = a;
            uint256 x = a / 2 + 1;
            while (x < c) {
                c = x;
                x = (a / x + x) / 2;
            }
        } else if (a != 0) {
            c = 1;
        }
    }
}",1565
RealWorld_BA_52_IERC20Extended_RealWord_20240821105047.log,52,IERC20Extended,4268,4813,9081,78.0,0.1176,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IERC20Extended is IERC20 {
    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function mint(address to, uint256 amount) external;

    function burn(uint256 amount) external;
}",88
RealWorld_BA_52_ISynthFactory_RealWord_20240821104304.log,52,ISynthFactory,4609,4963,9572,72.0,0.122305,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../../shared/IERC20Extended.sol"";
import ""./ISynth.sol"";

interface ISynthFactory {
    function synths(IERC20 token) external view returns (ISynth);

    function createSynth(IERC20Extended token) external returns (ISynth);
}",89
RealWorld_BA_52_StakingRewards_RealWord_20240821094350.log,52,StakingRewards,25713,6509,32222,94.0,0.258745,"// SPDX-License-Identifier: Unlicense
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

import ""./IStakingRewards.sol"";
import ""./RewardsDistributionRecipient.sol"";
import ""./Pausable.sol"";

contract StakingRewards is
    IStakingRewards,
    RewardsDistributionRecipient,
    ReentrancyGuard,
    Pausable
{
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    IERC20 public immutable rewardsToken;
    IERC20 public immutable stakingToken;
    uint public periodFinish;
    uint public rewardRate;
    uint public rewardsDuration = 7 days;
    uint public lastUpdateTime;
    uint public rewardPerTokenStored;

    mapping(address => uint) public userRewardPerTokenPaid;
    mapping(address => uint) public rewards;

    uint private _totalSupply;
    mapping(address => uint) private _balances;

    /* ========== CONSTRUCTOR ========== */

    constructor(
        address _owner,
        address _rewardsDistribution,
        address _rewardsToken,
        address _stakingToken
    ) Owned(_owner) {
        require(_rewardsDistribution != address(0), ""reward dist = zero address"");
        require(_rewardsToken != address(0), ""reward token = zero address"");
        require(_stakingToken != address(0), ""staking token = zero address"");

        rewardsToken = IERC20(_rewardsToken);
        stakingToken = IERC20(_stakingToken);
        rewardsDistribution = _rewardsDistribution;
    }

    /* ========== VIEWS ========== */

    function totalSupply() external view returns (uint) {
        return _totalSupply;
    }

    function balanceOf(address account) external view returns (uint) {
        return _balances[account];
    }

    function lastTimeRewardApplicable() public view returns (uint) {
        return block.timestamp < periodFinish ? block.timestamp : periodFinish;
    }

    function rewardPerToken() public view returns (uint) {
        if (_totalSupply == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored +
            ((lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * 1e18) /
            _totalSupply;
    }

    function earned(address account) public view returns (uint) {
        return
            _balances[account] *
            ((rewardPerToken() - userRewardPerTokenPaid[account]) / 1e18) +
            rewards[account];
    }

    function getRewardForDuration() external view returns (uint) {
        return rewardRate * rewardsDuration;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function stake(uint amount)
        external
        nonReentrant
        notPaused
        updateReward(msg.sender)
    {
        require(amount > 0, ""Cannot stake 0"");
        _totalSupply += amount;
        _balances[msg.sender] += amount;
        stakingToken.safeTransferFrom(msg.sender, address(this), amount);
        emit Staked(msg.sender, amount);
    }

    function withdraw(uint amount) public nonReentrant updateReward(msg.sender) {
        require(amount > 0, ""Cannot withdraw 0"");
        _totalSupply -= amount;
        _balances[msg.sender] -= amount;
        stakingToken.safeTransfer(msg.sender, amount);
        emit Withdrawn(msg.sender, amount);
    }

    function getReward() public nonReentrant updateReward(msg.sender) {
        uint reward = rewards[msg.sender];
        if (reward > 0) {
            rewards[msg.sender] = 0;
            rewardsToken.safeTransfer(msg.sender, reward);
            emit RewardPaid(msg.sender, reward);
        }
    }

    function exit() external {
        withdraw(_balances[msg.sender]);
        getReward();
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function notifyRewardAmount(uint reward)
        external
        override
        onlyRewardsDistribution
        updateReward(address(0))
    {
        if (block.timestamp >= periodFinish) {
            rewardRate = reward / rewardsDuration;
        } else {
            uint remaining = periodFinish - block.timestamp;
            uint leftover = remaining * rewardRate;
            rewardRate = (reward + leftover) / rewardsDuration;
        }
        // Ensure the provided reward amount is not more than the balance in the contract.
        // This keeps the reward rate in the right range, preventing overflows due to
        // very high values of rewardRate in the earned and rewardsPerToken functions;
        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.
        uint balance = rewardsToken.balanceOf(address(this));
        require(rewardRate <= balance / rewardsDuration, ""Provided reward too high"");

        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp + rewardsDuration;
        emit RewardAdded(reward);
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {
        require(
            tokenAddress != address(stakingToken),
            ""Cannot withdraw the staking token""
        );
        IERC20(tokenAddress).safeTransfer(msg.sender, tokenAmount);
        emit Recovered(tokenAddress, tokenAmount);
    }

    function setRewardsDuration(uint _rewardsDuration) external onlyOwner {
        require(
            block.timestamp > periodFinish,
            ""Previous rewards period must be complete before changing the duration for the new period""
        );
        rewardsDuration = _rewardsDuration;
        emit RewardsDurationUpdated(_rewardsDuration);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address account) {
        rewardPerTokenStored = rewardPerToken();
        lastUpdateTime = lastTimeRewardApplicable();
        if (account != address(0)) {
            rewards[account] = earned(account);
            userRewardPerTokenPaid[account] = rewardPerTokenStored;
        }
        _;
    }

    /* ========== EVENTS ========== */

    event RewardAdded(uint reward);
    event Staked(address indexed user, uint amount);
    event Withdrawn(address indexed user, uint amount);
    event RewardPaid(address indexed user, uint reward);
    event RewardsDurationUpdated(uint newDuration);
    event Recovered(address token, uint amount);
}",1349
RealWorld_BA_52_Synth_RealWord_20240821095107.log,52,Synth,8262,5177,13439,71.0,0.14485,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../../shared/ProtocolConstants.sol"";

import ""../../interfaces/shared/IERC20Extended.sol"";
import ""../../interfaces/dex-v2/synth/ISynth.sol"";

contract Synth is ISynth, ProtocolConstants, ERC20, Ownable {
    /* ========== CONSTRUCTOR ========== */

    constructor(IERC20Extended token)
        ERC20(_calculateName(token), _calculateSymbol(token))
    {}

    /* ========== VIEWS ========== */

    function _calculateName(IERC20Extended token)
        internal
        view
        returns (string memory)
    {
        return _combine(token.name(), "" - vSynth"");
    }

    function _calculateSymbol(IERC20Extended token)
        internal
        view
        returns (string memory)
    {
        return _combine(token.symbol(), "".v"");
    }

    function _combine(string memory a, string memory b)
        internal
        pure
        returns (string memory)
    {
        return string(abi.encodePacked(a, b));
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function mint(address to, uint256 amount) external override onlyOwner {
        _mint(to, amount);
    }

    function burn(uint256 amount) external override onlyOwner {
        _burn(msg.sender, amount);
    }
}",305
RealWorld_BA_52_FixedPoint_RealWord_20240821111409.log,52,FixedPoint,9763,4979,14742,72.0,0.148395,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity 0.7.6;

import ""./FullMath.sol"";

library FixedPoint {
    struct uq112x112 {
        uint224 _x;
    }

    struct uq144x112 {
        uint _x;
    }

    uint8 private constant RESOLUTION = 112;
    uint private constant Q112 = 0x10000000000000000000000000000;
    uint private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000;
    uint private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)

    function decode(uq112x112 memory self) internal pure returns (uint112) {
        return uint112(self._x >> RESOLUTION);
    }

    // decode a uq112x112 into a uint with 18 decimals of precision
    function decode112with18(uq112x112 memory self) internal pure returns (uint) {
        return uint(self._x) / 5192296858534827;
    }

    function fraction(uint numerator, uint denominator) internal pure returns (uq112x112 memory) {
        require(denominator > 0, ""FixedPoint::fraction: division by zero"");
        if (numerator == 0) return FixedPoint.uq112x112(0);

        if (numerator <= uint144(-1)) {
            uint result = (numerator << RESOLUTION) / denominator;
            require(result <= uint224(-1), ""FixedPoint::fraction: overflow"");
            return uq112x112(uint224(result));
        } else {
            uint result = FullMath.mulDiv(numerator, Q112, denominator);
            require(result <= uint224(-1), ""FixedPoint::fraction: overflow"");
            return uq112x112(uint224(result));
        }
    }
}",411
RealWorld_BA_52_GovernorAlpha_RealWord_20240821095929.log,52,GovernorAlpha,95544,6148,101692,107.0,0.60068,"// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.9;
pragma experimental ABIEncoderV2;

import ""../interfaces/governance/ITimelock.sol"";
import ""../interfaces/x-vader/IXVader.sol"";

/**
 * @dev Implementation of {GovernorAlpha} contract.
 *
 * The GovernorAlpha contract allows creation of proposals by anyone
 * by depositing xVader (1000 xVader initially).
 *
 * Anyone can vote on the created proposals utilizing their xVader weight in
 * xVader contract.
 *
 * Only 1 proposal can be active at a time by a particular proposer.
 *
 * A proposal is queued when it succeeds and can be executed after a cool-off
 * time period specified by {delay} in the Timelock contract.
 *
 * A proposal can be cancelled by a {guardian} if it has not been already
 * executed.
 *
 * A proposal can be vetoed by {council} while its state is active/pending
 * and a proposal vetoed with success is also queued at the same time.
 */
contract GovernorAlpha {
    // The name of this contract
    string public constant name = ""Vader Governor Alpha"";

    // The address of the Vader Protocol Timelock
    ITimelock public timelock;

    // The address of the Governor Guardian
    address public guardian;

    // The total number of proposals
    uint256 public proposalCount;

    // address of xVader token
    IXVader public immutable xVader;

    // address of fee receiver
    address public feeReceiver;

    // amount of fee deducted when proposing proposal
    uint256 public feeAmount;

    // address of council that is allowed to veto on proposals
    address public council;

    /**
     * @dev {Proposal} struct contains parameters for a single proposal.
     * id: Unique id for looking up a proposal.
     * canceled: Flag marking whether the proposal has been canceled.
     * executed: Flag marking whether the proposal has been executed.
     * proposer: Creator of the proposal
     * eta: The timestamp that the proposal will be available for execution, set once the vote succeeds
     * targets: the ordered list of target addresses for calls to be made
     * values: The ordered list of values (i.e. msg.value) to be passed to the calls to be made
     * signatures: The ordered list of function signatures to be called
     * calldatas: The ordered list of calldata to be passed to each call
     * startBlock: startBlock: The block at which voting begins: holders must delegate their votes prior to this block
     * endBlock: The block at which voting ends: votes must be cast prior to this block
     * forVotes: Current number of votes in favor of this proposal
     * againstVotes: Current number of votes in opposition to this proposal
     * receipts: Receipts of ballots for the entire set of voters
     * vetoStatus: Veto status if the proposal has been vetoed by council in favor or against
     */
    struct Proposal {
        uint256 id;
        bool canceled;
        bool executed;
        address proposer;
        uint256 eta;
        address[] targets;
        uint256[] values;
        string[] signatures;
        bytes[] calldatas;
        uint256 startBlock;
        uint256 endBlock;
        uint224 forVotes;
        uint224 againstVotes;
        VetoStatus vetoStatus;
        mapping(address => Receipt) receipts;
    }

    /**
     * @dev {Receipt} struct contains parameters for a voter against a particular proposal
     * and is a ballot receipt record for a voter.
     *
     * hasVoted: Whether or not a vote has been casted
     * support: Whether or not the voter supports the proposal
     * votes: The number of votes the voter had, which were cast
     */
    struct Receipt {
        bool hasVoted;
        bool support;
        uint224 votes;
    }

    /**
     * @dev {VetoStatus} contains parameters representing if a proposal has been vetoed by council
     *
     * hasBeenVetoed: Whether proposal has been vetoed or not
     * support: Whether veto is in favor or against of proposal
     */
    struct VetoStatus {
        bool hasBeenVetoed;
        bool support;
    }

    // Possible states that a proposal may be in
    enum ProposalState {
        Pending,
        Active,
        Canceled,
        Defeated,
        Succeeded,
        Queued,
        Expired,
        Executed
    }

    // The official record of all proposals ever proposed
    mapping(uint256 => Proposal) public proposals;

    // The latest proposal for each proposer
    mapping(address => uint256) public latestProposalIds;

    // The EIP-712 typehash for the contract's domain
    bytes32 public constant DOMAIN_TYPEHASH =
        keccak256(
            ""EIP712Domain(string name,uint256 chainId,address verifyingContract)""
        );

    // The EIP-712 typehash for the ballot struct used by the contract
    bytes32 public constant BALLOT_TYPEHASH =
        keccak256(""Ballot(uint256 proposalId,bool support)"");

    // An event emitted when a new proposal is created
    event ProposalCreated(
        uint256 id,
        address proposer,
        address[] targets,
        uint256[] values,
        string[] signatures,
        bytes[] calldatas,
        uint256 startBlock,
        uint256 endBlock,
        string description
    );

    // An event emitted when a vote has been cast on a proposal
    event VoteCast(
        address voter,
        uint256 proposalId,
        bool support,
        uint256 votes
    );

    // An event emitted when a proposal has been canceled
    event ProposalCanceled(uint256 id);

    // An event emitted when a proposal has been queued in the Timelock
    event ProposalQueued(uint256 id, uint256 eta);

    // An event emitted when a proposal has been executed in the Timelock
    event ProposalExecuted(uint256 id);

    // An event emitted when fee receiver is changed
    event FeeReceiverChanged(address oldFeeReceiver, address newFeeReceiver);

    // An event emitted when fee amount is changed
    event FeeAmountChanged(uint256 oldFeeAmount, uint256 newFeeAmount);

    // An event emitted when a proposal has been vetoed by the council
    event ProposalVetoed(uint256 proposalId, bool support);

    // An event emitted when council is changed
    event CouncilChanged(address oldCouncil, address newCouncil);

    /* ========== CONSTRUCTOR ========== */

    /**
     * @dev Initializes the contract's state setting xVader, fee receiver,
     * council and guardian addresses along with the fee amount.
     *
     * It performs sanity checks for the address type parameters against zero
     * address values.
     */
    constructor(
        address guardian_,
        address xVader_,
        address feeReceiver_,
        uint256 feeAmount_,
        address council_
    ) {
        require(
            xVader_ != address(0),
            ""GovernorAlpha::constructor: xVader address is zero""
        );

        require(
            guardian_ != address(0) &&
                feeReceiver_ != address(0) &&
                council_ != address(0),
            ""GovernorAlpha::constructor: guardian, feeReceiver or council cannot be zero""
        );

        guardian = guardian_;
        xVader = IXVader(xVader_);
        feeReceiver = feeReceiver_;
        feeAmount = feeAmount_;
        council = council_;

        emit FeeReceiverChanged(address(0), feeReceiver_);
        emit FeeAmountChanged(0, feeAmount_);
    }

    /* ========== VIEWS ========== */

    // The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed
    function quorumVotes(uint256 blockNumber) public view returns (uint256) {
        return (xVader.getPastTotalSupply(blockNumber) * 4) / 100; // 4% of xVader's supply at the time of proposal creation.
    }

    // The maximum number of actions that can be included in a proposal
    function proposalMaxOperations() public pure returns (uint256) {
        return 10; // 10 actions
    }

    // The delay before voting on a proposal may take place, once proposed
    function votingDelay() public pure returns (uint256) {
        return 1; // 1 block
    }

    // The duration of voting on a proposal, in blocks
    function votingPeriod() public pure virtual returns (uint256) {
        return 17280; // ~3 days in blocks (assuming 15s blocks)
    }

    /**
     * @dev Returns the actions contained in a proposal with id {proposalId}.
     */
    function getActions(uint256 proposalId)
        public
        view
        returns (
            address[] memory targets,
            uint256[] memory values,
            string[] memory signatures,
            bytes[] memory calldatas
        )
    {
        Proposal storage p = proposals[proposalId];
        return (p.targets, p.values, p.signatures, p.calldatas);
    }

    /**
     * @dev Returns receipt of the {voter} against the proposal with id {proposalId}.
     */
    function getReceipt(uint256 proposalId, address voter)
        public
        view
        returns (Receipt memory)
    {
        return proposals[proposalId].receipts[voter];
    }

    /**
     * @dev Returns the current state of the proposal with id {proposalId}.
     *
     * Requirements:
     * - The {proposalId} should be greater than 0
     * - The {proposalId} should be less than or equal to {proposalCount}
     */
    function state(uint256 proposalId) public view returns (ProposalState) {
        require(
            proposalCount >= proposalId && proposalId > 0,
            ""GovernorAlpha::state: invalid proposal id""
        );

        Proposal storage proposal = proposals[proposalId];
        if (proposal.canceled) return ProposalState.Canceled;

        if (proposal.vetoStatus.hasBeenVetoed) {
            // proposal has been vetoed
            uint256 _eta = proposal.eta;

            // proposal has been vetoed in favor, so considered succeeded
            if (proposal.vetoStatus.support && _eta == 0)
                return ProposalState.Succeeded;

            // proposal has been vetoed against, so considered defeated
            if (_eta == 0) return ProposalState.Defeated;
        } else {
            // proposal has not been vetoed, normal flow ensues
            if (block.number <= proposal.startBlock)
                return ProposalState.Pending;

            if (block.number <= proposal.endBlock) return ProposalState.Active;

            if (
                proposal.forVotes <= proposal.againstVotes ||
                proposal.forVotes < quorumVotes(proposal.startBlock)
            ) return ProposalState.Defeated;

            if (proposal.eta == 0) return ProposalState.Succeeded;
        }

        if (proposal.executed) return ProposalState.Executed;

        if (block.timestamp >= proposal.eta + timelock.GRACE_PERIOD())
            return ProposalState.Expired;

        return ProposalState.Queued;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    /**
     * @dev Sets timelock state variable. Contracts {GovernorAlpha} and
     * {Timelock} have circular dependencies upon each other and constructors
     * cannot be used to set them, hence this function is introduced to set
     * {Timelock} in {GovernorAlpha} after it has been deployed.
     *
     * Requirements:
     * - only guardian can call this function
     */
    function setTimelock(address _timelock) external onlyGuardian {
        require(
            _timelock != address(0),
            ""GovernorAlpha::initTimelock: _timelock cannot be zero address""
        );
        timelock = ITimelock(_timelock);
    }

    /**
     * @dev Allows any to make a proposal by depositing {feeAmount} xVader.
     * It accepts targets along with the values, signature and calldatas
     * for the actions to perform if the proposal succeeds.
     *
     * Requirements:
     * - targets, values, signatures and calldatas arrays' lengths must be greater
     *   than zero, less than {proposalMaxOperations} and are the same.
     * - the caller must approve {feeAmount} xVader to this contract prior to call.
     * - the caller must not have an active/pending proposal.
     */
    function propose(
        address[] memory targets,
        uint256[] memory values,
        string[] memory signatures,
        bytes[] memory calldatas,
        string memory description
    ) public returns (uint256 proposalId) {
        require(
            targets.length == values.length &&
                targets.length == signatures.length &&
                targets.length == calldatas.length,
            ""GovernorAlpha::propose: proposal function information arity mismatch""
        );
        require(
            targets.length != 0,
            ""GovernorAlpha::propose: must provide actions""
        );
        require(
            targets.length <= proposalMaxOperations(),
            ""GovernorAlpha::propose: too many actions""
        );

        xVader.transferFrom(msg.sender, feeReceiver, feeAmount);

        uint256 latestProposalId = latestProposalIds[msg.sender];
        if (latestProposalId != 0) {
            ProposalState proposersLatestProposalState = state(
                latestProposalId
            );
            require(
                proposersLatestProposalState != ProposalState.Active,
                ""GovernorAlpha::propose: one live proposal per proposer, found an already active proposal""
            );
            require(
                proposersLatestProposalState != ProposalState.Pending,
                ""GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal""
            );
        }

        uint256 startBlock = block.number + votingDelay();
        uint256 endBlock = startBlock + votingPeriod();

        proposalId = ++proposalCount;
        Proposal storage newProposal = proposals[proposalId];
        newProposal.id = proposalId;
        newProposal.proposer = msg.sender;
        newProposal.targets = targets;
        newProposal.values = values;
        newProposal.signatures = signatures;
        newProposal.calldatas = calldatas;
        newProposal.startBlock = startBlock;
        newProposal.endBlock = endBlock;

        latestProposalIds[msg.sender] = proposalId;

        emit ProposalCreated(
            proposalId,
            msg.sender,
            targets,
            values,
            signatures,
            calldatas,
            startBlock,
            endBlock,
            description
        );
    }

    /**
     * @dev Queues a proposal by setting the hashes of its actions in {Timelock} contract.
     * It also determines 'eta' for the proposal by adding timestamp to {delay} in {Timelock}
     * and sets it against the proposal in question.
     *
     * Requirements:
     * - the proposal in question must have succeeded either through majority for-votes
     *   or has been vetoed in its favour.
     */
    function queue(uint256 proposalId) public {
        require(
            state(proposalId) == ProposalState.Succeeded,
            ""GovernorAlpha::queue: proposal can only be queued if it is succeeded""
        );
        Proposal storage proposal = proposals[proposalId];
        uint256 eta = block.timestamp + timelock.delay();

        uint256 length = proposal.targets.length;
        for (uint256 i = 0; i < length; i++) {
            _queueOrRevert(
                proposal.targets[i],
                proposal.values[i],
                proposal.signatures[i],
                proposal.calldatas[i],
                eta
            );
        }
        proposal.eta = eta;
        emit ProposalQueued(proposalId, eta);
    }

    /**
     * @dev Executes a proposal after it has been queued and cool-off time has elapsed.
     * It sets the {executed} status of the proposal to 'true'.
     *
     * Requirements:
     * - the proposal in question must have been quened and cool-off time has elapsed
     * - none of the actions of the proposal revert upon execution
     */
    function execute(uint256 proposalId) public payable {
        require(
            state(proposalId) == ProposalState.Queued,
            ""GovernorAlpha::execute: proposal can only be executed if it is queued""
        );
        Proposal storage proposal = proposals[proposalId];
        proposal.executed = true;
        uint256 length = proposal.targets.length;
        for (uint256 i = 0; i < length; i++) {
            timelock.executeTransaction{value: proposal.values[i]}(
                proposal.targets[i],
                proposal.values[i],
                proposal.signatures[i],
                proposal.calldatas[i],
                proposal.eta
            );
        }
        emit ProposalExecuted(proposalId);
    }

    /**
     * @dev Casts vote by {msg.sender}.
     * It calls the internal function `_castVote` to perform vote casting.
     */
    function castVote(uint256 proposalId, bool support) public {
        return _castVote(msg.sender, proposalId, support);
    }

    /**
     * @dev Called by a relayer to cast vote by a message signer.
     *
     * Requirements:
     * - {signatory} retrieved must not be a zero address
     */
    function castVoteBySig(
        uint256 proposalId,
        bool support,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        bytes32 domainSeparator = keccak256(
            abi.encode(
                DOMAIN_TYPEHASH,
                keccak256(bytes(name)),
                getChainId(),
                address(this)
            )
        );

        bytes32 structHash = keccak256(
            abi.encode(BALLOT_TYPEHASH, proposalId, support)
        );

        bytes32 digest = keccak256(
            abi.encodePacked(""\x19\x01"", domainSeparator, structHash)
        );

        address signatory = ecrecover(digest, v, r, s);

        require(
            signatory != address(0),
            ""GovernorAlpha::castVoteBySig: invalid signature""
        );

        return _castVote(signatory, proposalId, support);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    /**
     * @dev Changes the {feeReceiver}.
     *
     * Requirements:
     * - only guardian can call
     */
    function changeFeeReceiver(address feeReceiver_) external onlyGuardian {
        emit FeeReceiverChanged(feeReceiver, feeReceiver_);
        feeReceiver = feeReceiver_;
    }

    /**
     * @dev Changes the {feeAmount}.
     *
     * Requirements:
     * - only guardian can call
     */
    function changeFeeAmount(uint256 feeAmount_) external onlyGuardian {
        emit FeeAmountChanged(feeAmount, feeAmount_);
        feeAmount = feeAmount_;
    }

    /**
     * @dev Allows vetoeing of a proposal in favor or against it.
     * It also queues a proposal if it has been vetoed in favor of it and.
     * sets the veto status of the proposal.
     *
     * Requirements:
     * - can only be called by {council}
     * - proposal being vetoed must be active or pending
     * - none of the actions in proposal being vetoed point to the contract
     *   itself. This to restrict council from vetoing a proposal intended
     *   to change council.
     */
    function veto(uint256 proposalId, bool support) external onlyCouncil {
        ProposalState _state = state(proposalId);
        require(
            _state == ProposalState.Active || _state == ProposalState.Pending,
            ""GovernorAlpha::veto: Proposal can only be vetoed when active""
        );

        Proposal storage proposal = proposals[proposalId];
        address[] memory _targets = proposal.targets;
        for (uint256 i = 0; i < _targets.length; i++) {
            if (_targets[i] == address(this)) {
                revert(
                    ""GovernorAlpha::veto: council cannot veto on proposal having action with address(this) as target""
                );
            }
        }

        VetoStatus storage _vetoStatus = proposal.vetoStatus;
        _vetoStatus.hasBeenVetoed = true;
        _vetoStatus.support = support;

        if (support) {
            queue(proposalId);
        }

        emit ProposalVetoed(proposalId, support);
    }

    /**
     * @dev Changes the {council}.
     *
     * Requirements:
     * - can only be called by {Timelock} contract through a non-vetoeable proposal
     */
    function changeCouncil(address council_) external onlyTimelock {
        emit CouncilChanged(council, council_);
        council = council_;
    }

    /**
     * @dev Cancels the proposal with id {proposalId}.
     * It also sets the {canceled} property of {Proposal} to `true` and
     * removes the proposal's corresponding actions from {Timelock} contract.
     *
     * Requirements:
     * - proposal must not be already executed
     */
    function cancel(uint256 proposalId) public onlyGuardian {
        ProposalState _state = state(proposalId);
        require(
            _state != ProposalState.Executed,
            ""GovernorAlpha::cancel: cannot cancel executed proposal""
        );

        Proposal storage proposal = proposals[proposalId];
        proposal.canceled = true;
        uint256 length = proposal.targets.length;
        for (uint256 i = 0; i < length; i++) {
            timelock.cancelTransaction(
                proposal.targets[i],
                proposal.values[i],
                proposal.signatures[i],
                proposal.calldatas[i],
                proposal.eta
            );
        }

        emit ProposalCanceled(proposalId);
    }

    /**
     * @dev Calls {acceptAdmin} on {Timelock} contract and makes the current contract
     * the admin of {Timelock} contract.
     *
     * Requirements:
     * - only guardian can call it
     * - current contract must be the `pendingAdmin` in {Timelock} contract
     */
    function __acceptAdmin() public onlyGuardian {
        timelock.acceptAdmin();
    }

    /**
     * @dev Gives up the guardian role associated with the contract.
     *
     * Requirements:
     * - only callable by guardian
     */
    function __abdicate() public onlyGuardian {
        guardian = address(0);
    }

    /**
     * @dev Queues the transaction to set `pendingAdmin` in {Timelock}.
     *
     * Requirements:
     * - only callable by guardian
     */
    function __queueSetTimelockPendingAdmin(
        address newPendingAdmin,
        uint256 eta
    ) public onlyGuardian {
        timelock.queueTransaction(
            address(timelock),
            0,
            ""setPendingAdmin(address)"",
            abi.encode(newPendingAdmin),
            eta
        );
    }

    /**
     * @dev Executes the transaction to set `pendingAdmin` in {Timelock}.
     *
     * Requirements:
     * - only callable by guardian
     */
    function __executeSetTimelockPendingAdmin(
        address newPendingAdmin,
        uint256 eta
    ) public onlyGuardian {
        timelock.executeTransaction(
            address(timelock),
            0,
            ""setPendingAdmin(address)"",
            abi.encode(newPendingAdmin),
            eta
        );
    }

    /* ========== INTERNAL FUNCTIONS ========== */

    /**
     * @dev Queues a transaction in {Timelock}.
     *
     * Requirements:
     * - only callable by guardian
     * - transaction is not already queued in {Timelock}
     */
    function _queueOrRevert(
        address target,
        uint256 value,
        string memory signature,
        bytes memory data,
        uint256 eta
    ) internal {
        require(
            !timelock.queuedTransactions(
                keccak256(abi.encode(target, value, signature, data, eta))
            ),
            ""GovernorAlpha::_queueOrRevert: proposal action already queued at eta""
        );
        timelock.queueTransaction(target, value, signature, data, eta);
    }

    /**
     * @dev Casts vote against proposal with id {proposalId}.
     * It gets the voting weight of voter from {xVader} token contract corresponding to
     * the blocknumber when proposal started and adds those votes to either
     * {forVotes} or {againstVotes} property of {Proposal} depending upon if
     * the voter is voting in favor of or against the proposal.
     *
     * Requirements:
     * - proposal being voted must be active
     * - voter has not already voted against the proposal
     */
    function _castVote(
        address voter,
        uint256 proposalId,
        bool support
    ) internal {
        require(
            state(proposalId) == ProposalState.Active,
            ""GovernorAlpha::_castVote: voting is closed""
        );

        Proposal storage proposal = proposals[proposalId];
        Receipt storage receipt = proposal.receipts[voter];

        require(
            !receipt.hasVoted,
            ""GovernorAlpha::_castVote: voter already voted""
        );

        // optimistically casting to uint224 as xVader contract performs the checks for
        // votes to not overflow uint224.
        uint224 votes = uint224(xVader.getPastVotes(voter, proposal.startBlock));

        if (support) {
            proposal.forVotes = proposal.forVotes + votes;
        } else {
            proposal.againstVotes = proposal.againstVotes + votes;
        }

        receipt.hasVoted = true;
        receipt.support = support;
        receipt.votes = votes;

        emit VoteCast(voter, proposalId, support, votes);
    }

    // gets the chainid from current network
    function getChainId() internal view returns (uint256 chainId) {
        assembly {
            chainId := chainid()
        }
    }

    /* ========== PRIVATE FUNCTIONS ========== */

    // ensures only {guardian} is able to a particular function.
    function _onlyGuardian() private view {
        require(
            msg.sender == guardian,
            ""GovernorAlpha::_onlyGuardian: only guardian can call""
        );
    }

    // ensures only {timelock} is able to a particular function.
    function _onlyTimelock() private view {
        require(
            msg.sender == address(timelock),
            ""GovernorAlpha::_onlyTimelock: only timelock can call""
        );
    }

    // ensures only {council} is able to a particular function.
    function _onlyCouncil() private view {
        require(
            msg.sender == council,
            ""GovernorAlpha::_onlyCouncil: only council can call""
        );
    }

    /* ========== MODIFIERS ========== */

    /**
     * @dev Throws if invoked by anyone else other than the {guardian}
     */
    modifier onlyGuardian() {
        _onlyGuardian();
        _;
    }

    /**
     * @dev Throws if invoked by anyone else other than the {timelock}
     */
    modifier onlyTimelock() {
        _onlyTimelock();
        _;
    }

    /**
     * @dev Throws if invoked by anyone else other than the {council}
     */
    modifier onlyCouncil() {
        _onlyCouncil();
        _;
    }
}",5835
RealWorld_BA_52_ISwapQueue_RealWord_20240821105331.log,52,ISwapQueue,4746,5020,9766,61.0,0.12413,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

interface ISwapQueue {
    /* ========== STRUCTS ========== */

    struct Node {
        uint256 value;
        uint256 previous;
        uint256 next;
    }

    struct Queue {
        mapping(uint256 => Node) linkedList;
        uint256 start;
        uint256 end;
        uint256 size;
    }

    /* ========== FUNCTIONS ========== */
    /* ========== EVENTS ========== */
}",94
RealWorld_BA_52_IUniswapV2Factory_RealWord_20240821103011.log,52,IUniswapV2Factory,5815,4516,10331,80.0,0.119395,"// SPDX-License-Identifier: Unlicense
pragma solidity >=0.8.9;

interface IUniswapV2Factory {
    event PairCreated(
        address indexed token0,
        address indexed token1,
        address pair,
        uint256
    );

    function feeTo() external view returns (address);

    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB)
        external
        view
        returns (address pair);

    function allPairs(uint256) external view returns (address pair);

    function allPairsLength() external view returns (uint256);

    function createPair(address tokenA, address tokenB)
        external
        returns (address pair);

    function setFeeTo(address) external;

    function setFeeToSetter(address) external;
}",168
RealWorld_BA_52_LinearVesting_RealWord_20240821103757.log,52,LinearVesting,36537,5421,41958,80.0,0.291105,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/access/Ownable.sol"";

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../../shared/ProtocolConstants.sol"";

import ""../../interfaces/tokens/vesting/ILinearVesting.sol"";

/**
 * @dev Implementation of the {ILinearVesting} interface.
 *
 * The straightforward vesting contract that gradually releases a
 * fixed supply of tokens to multiple vest parties over a 2 year
 * window.
 *
 * The token expects the {begin} hook to be invoked the moment
 * it is supplied with the necessary amount of tokens to vest,
 * which should be equivalent to the time the {setComponents}
 * function is invoked on the Vader token.
 */
contract LinearVesting is ILinearVesting, ProtocolConstants, Ownable {
    /* ========== LIBRARIES ========== */

    // Used for safe VADER transfers
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    // The Vader token
    IERC20 public immutable vader;

    // The start of the vesting period
    uint256 public start;

    // The end of the vesting period
    uint256 public end;

    // The status of each vesting member (Vester)
    mapping(address => Vester) public vest;

    /* ========== CONSTRUCTOR ========== */

    /**
     * @dev Initializes the contract's vesters and vesting amounts as well as sets
     * the Vader token address.
     *
     * It conducts a sanity check to ensure that the total vesting amounts specified match
     * the team allocation to ensure that the contract is deployed correctly.
     *
     * Additionally, it transfers ownership to the Vader contract that needs to consequently
     * initiate the vesting period via {begin} after it mints the necessary amount to the contract.
     */
    constructor(
        IERC20 _vader,
        address[] memory vesters,
        uint192[] memory amounts
    ) {
        require(
            _vader != IERC20(_ZERO_ADDRESS) && vesters.length == amounts.length,
            ""LinearVesting::constructor: Misconfiguration""
        );

        vader = _vader;

        uint256 total;
        for (uint256 i = 0; i < vesters.length; i++) {
            require(
                amounts[i] != 0,
                ""LinearVesting::constructor: Incorrect Amount Specified""
            );
            vest[vesters[i]].amount = amounts[i];
            total = total + amounts[i];
        }
        require(
            total == _TEAM_ALLOCATION,
            ""LinearVesting::constructor: Invalid Vest Amounts Specified""
        );

        transferOwnership(address(_vader));
    }

    /* ========== VIEWS ========== */

    /**
     * @dev Returns the amount a user can claim at a given point in time.
     *
     * Requirements:
     * - the vesting period has started
     */
    function getClaim()
        external
        view
        override
        hasStarted
        returns (uint256 vestedAmount)
    {
        Vester memory vester = vest[msg.sender];
        return _getClaim(vester.amount, vester.lastClaim);
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    /**
     * @dev Allows a user to claim their pending vesting amount.
     *
     * Emits a {Vested} event indicating the user who claimed their vested tokens
     * as well as the amount that was vested.
     *
     * Requirements:
     *
     * - the vesting period has started
     * - the caller must have a non-zero vested amount
     */
    function claim()
        external
        override
        hasStarted
        returns (uint256 vestedAmount)
    {
        Vester memory vester = vest[msg.sender];

        require(
            vester.start == 0,
            ""LinearVesting::claim: Incorrect Vesting Type""
        );

        vestedAmount = _getClaim(vester.amount, vester.lastClaim);

        require(vestedAmount != 0, ""LinearVesting::claim: Nothing to claim"");

        vester.amount -= uint192(vestedAmount);
        vester.lastClaim = uint64(block.timestamp);

        vest[msg.sender] = vester;

        emit Vested(msg.sender, vestedAmount);

        vader.safeTransfer(msg.sender, vestedAmount);
    }

    /**
     * @dev Allows a user to claim their pending vesting amount of the vested claim
     *
     * Emits a {Vested} event indicating the user who claimed their vested tokens
     * as well as the amount that was vested.
     *
     * Requirements:
     *
     * - the vesting period has started
     * - the caller must have a non-zero vested amount
     */
    function claimConverted() external override returns (uint256 vestedAmount) {
        Vester memory vester = vest[msg.sender];

        require(
            vester.start != 0,
            ""LinearVesting::claim: Incorrect Vesting Type""
        );

        require(
            vester.start < block.timestamp,
            ""LinearVesting::claim: Not Started Yet""
        );

        vestedAmount = _getClaim(
            vester.amount,
            vester.lastClaim,
            vester.start,
            vester.end
        );

        require(vestedAmount != 0, ""LinearVesting::claim: Nothing to claim"");

        vester.amount -= uint192(vestedAmount);
        vester.lastClaim = uint64(block.timestamp);

        vest[msg.sender] = vester;

        emit Vested(msg.sender, vestedAmount);

        vader.safeTransfer(msg.sender, vestedAmount);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    /**
     * @dev Allows the vesting period to be initiated.
     *
     * Emits a {VestingInitialized} event from which the start and
     * end can be calculated via it's attached timestamp.
     *
     * Requirements:
     *
     * - the caller must be the owner (vader token)
     */
    function begin() external override onlyOwner {
        start = block.timestamp;
        end = block.timestamp + _VESTING_DURATION;

        emit VestingInitialized(_VESTING_DURATION);

        renounceOwnership();
    }

    /**
     * @dev Adds a new vesting schedule to the contract
     */
    function vestFor(address user, uint256 amount) external override {
        require(
            vest[user].amount == 0,
            ""LinearVesting::selfVest: Already a vester""
        );
        vest[user] = Vester(
            uint192(amount),
            0,
            uint128(block.timestamp),
            uint128(block.timestamp + 365 days)
        );
        vader.safeTransferFrom(msg.sender, address(this), amount);
    }

    /* ========== PRIVATE FUNCTIONS ========== */

    /**
     * @dev Calculates the amount a user's vest is due. To calculate,
     * the following formula is utilized:
     *
     * - (remainingAmount * timeElapsed) / timeUntilEnd
     *
     * Each variable is described as follows:
     *
     * - remainingAmount (amount): Vesting amount remaining. Each claim subtracts from
     * this amount to ensure calculations are properly conducted.
     *
     * - timeElapsed (block.timestamp.sub(lastClaim)): Time that has elapsed since the
     * last claim.
     *
     * - timeUntilEnd (end.sub(lastClaim)): Time remaining for the particular vesting
     * member's total duration.
     *
     * Vesting calculations are relative and always update the last
     * claim timestamp as well as remaining amount whenever they
     * are claimed.
     */
    function _getClaim(uint256 amount, uint256 lastClaim)
        private
        view
        returns (uint256)
    {
        uint256 _end = end;

        if (block.timestamp >= _end) return amount;
        if (lastClaim == 0) lastClaim = start;

        return (amount * (block.timestamp - lastClaim)) / (_end - lastClaim);
    }

    /**
     * @dev Calculates the amount a user's vest is due. To calculate,
     * the following formula is utilized:
     *
     * - (remainingAmount * timeElapsed) / timeUntilEnd
     *
     * Each variable is described as follows:
     *
     * - remainingAmount (amount): Vesting amount remaining. Each claim subtracts from
     * this amount to ensure calculations are properly conducted.
     *
     * - timeElapsed (block.timestamp.sub(lastClaim)): Time that has elapsed since the
     * last claim.
     *
     * - timeUntilEnd (end.sub(lastClaim)): Time remaining for the particular vesting
     * member's total duration.
     *
     * Vesting calculations are relative and always update the last
     * claim timestamp as well as remaining amount whenever they
     * are claimed.
     */
    function _getClaim(
        uint256 amount,
        uint256 lastClaim,
        uint256 _start,
        uint256 _end
    ) private view returns (uint256) {
        if (block.timestamp >= _end) return amount;
        if (lastClaim == 0) lastClaim = _start;

        return (amount * (block.timestamp - lastClaim)) / (_end - lastClaim);
    }

    /**
     * @dev Validates that the vesting period has started
     */
    function _hasStarted() private view {
        require(
            start != 0,
            ""LinearVesting::_hasStarted: Vesting hasn't started yet""
        );
    }

    /* ========== MODIFIERS ========== */

    /**
     * @dev Throws if the vesting period hasn't started
     */
    modifier hasStarted() {
        _hasStarted();
        _;
    }
}",2067
RealWorld_BA_52_Converter_RealWord_20240821103635.log,52,Converter,17355,5444,22799,80.0,0.195655,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""@openzeppelin/contracts/utils/cryptography/MerkleProof.sol"";

import ""../../shared/ProtocolConstants.sol"";

import ""../../interfaces/tokens/converter/IConverter.sol"";
import ""../../interfaces/tokens/vesting/ILinearVesting.sol"";

/**
 * @dev Implementation of the {IConverter} interface.
 *
 * A simple converter contract that allows users to convert
 * their Vether tokens by ""burning"" them (See {convert}) to
 * acquire their equivalent Vader tokens based on the constant
 * {VADER_VETHER_CONVERSION_RATE}.
 *
 * The contract assumes that it has been sufficiently funded with
 * Vader tokens and will fail to execute trades if it has not been
 * done so yet.
 */
contract Converter is IConverter, ProtocolConstants {
    /* ========== LIBRARIES ========== */

    // Used for safe VADER & VETHER transfers
    using SafeERC20 for IERC20;

    // Using MerkleProof for validating claims
    using MerkleProof for bytes32[];

    /* ========== STATE VARIABLES ========== */

    // The VETHER token
    IERC20 public immutable vether;

    // The VADER token
    IERC20 public immutable vader;

    // The VADER vesting contract
    ILinearVesting public immutable vesting;

    // The merkle proof root for validating claims
    bytes32 public immutable root;

    // Signals whether a particular leaf has been claimed of the merkle proof
    mapping(bytes32 => bool) public claimed;

    /* ========== CONSTRUCTOR ========== */

    /**
     * @dev Initializes the contract's {vether} and {vader} addresses.
     *
     * Performs rudimentary checks to ensure that the variables haven't
     * been declared incorrectly.
     */
    constructor(
        IERC20 _vether,
        IERC20 _vader,
        ILinearVesting _vesting,
        bytes32 _root
    ) {
        require(
            _vether != IERC20(_ZERO_ADDRESS) &&
                _vader != IERC20(_ZERO_ADDRESS) &&
                _vesting != ILinearVesting(_ZERO_ADDRESS),
            ""Converter::constructor: Misconfiguration""
        );

        vether = _vether;
        vader = _vader;

        _vader.approve(address(_vesting), type(uint256).max);

        vesting = _vesting;
        root = _root;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    /**
     * @dev Allows a user to convert their Vether to Vader.
     *
     * Emits a {Conversion} event indicating the amount of Vether the user
     * ""burned"" and the amount of Vader that they acquired.
     *
     * Here, ""burned"" refers to the action of transferring them to an irrecoverable
     * address, the {BURN} address.
     *
     * Requirements:
     *
     * - the caller has approved the contract for the necessary amount via Vether
     * - the amount specified is non-zero
     * - the contract has been supplied with the necessary Vader amount to fulfill the trade
     */
    function convert(bytes32[] calldata proof, uint256 amount)
        external
        override
        returns (uint256 vaderReceived)
    {
        require(
            amount != 0,
            ""Converter::convert: Non-Zero Conversion Amount Required""
        );

        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, amount));
        require(
            !claimed[leaf] && proof.verify(root, leaf),
            ""Converter::convert: Incorrect Proof Provided""
        );
        claimed[leaf] = true;

        vaderReceived = amount * _VADER_VETHER_CONVERSION_RATE;

        emit Conversion(msg.sender, amount, vaderReceived);

        vether.safeTransferFrom(msg.sender, _BURN, amount);
        uint256 half = vaderReceived / 2;
        vader.safeTransfer(msg.sender, half);
        vesting.vestFor(msg.sender, half);
    }
}",887
RealWorld_BA_52_UniswapV2OracleLibrary_RealWord_20240821101729.log,52,UniswapV2OracleLibrary,9508,4951,14459,69.0,0.14656,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""../interfaces/IUniswapV2Pair.sol"";
import ""./FixedPoint.sol"";

// library with helper methods for oracles that are concerned with computing average prices
library UniswapV2OracleLibrary {
    using FixedPoint for *;

    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]
    function currentBlockTimestamp() internal view returns (uint32) {
        return uint32(block.timestamp % 2**32);
    }

    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.
    function currentCumulativePrices(address pair)
        internal
        view
        returns (
            uint256 price0Cumulative,
            uint256 price1Cumulative,
            uint32 blockTimestamp
        )
    {
        blockTimestamp = currentBlockTimestamp();
        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();
        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();

        // if time has elapsed since the last update on the pair, mock the accumulated price values
        (
            uint112 reserve0,
            uint112 reserve1,
            uint32 blockTimestampLast
        ) = IUniswapV2Pair(pair).getReserves();
        if (blockTimestampLast != blockTimestamp) {
            // subtraction overflow is desired
            uint32 timeElapsed = blockTimestamp - blockTimestampLast;
            // addition overflow is desired
            // counterfactual
            price0Cumulative +=
                uint256(FixedPoint.fraction(reserve1, reserve0)._x) *
                timeElapsed;
            // counterfactual
            price1Cumulative +=
                uint256(FixedPoint.fraction(reserve0, reserve1)._x) *
                timeElapsed;
        }
    }
}",409
RealWorld_BA_52_ILPWrapper_RealWord_20240821104028.log,52,ILPWrapper,4143,4831,8974,76.0,0.117335,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""../../shared/IERC20Extended.sol"";

interface ILPWrapper {
    function tokens(IERC20 foreignAsset) external view returns (IERC20Extended);

    function createWrapper(IERC20 foreignAsset) external;
}",63
RealWorld_BA_52_IVaderRouterV2_RealWord_20240821104931.log,52,IVaderRouterV2,8481,5432,13913,73.0,0.151045,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IVaderRouterV2 {
    /* ========== STRUCTS ========== */
    /* ========== FUNCTIONS ========== */

    function addLiquidity(
        IERC20 tokenA,
        IERC20 tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256, // amountAMin = unused
        uint256, // amountBMin = unused
        address to,
        uint256 deadline
    ) external returns (uint256 liquidity);

    function addLiquidity(
        IERC20 tokenA,
        IERC20 tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        address to,
        uint256 deadline
    ) external returns (uint256 liquidity);

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 id,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB);

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        IERC20[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256 amountOut);

    /* ========== EVENTS ========== */
}",302
RealWorld_BA_52_ITreasury_RealWord_20240821111633.log,52,ITreasury,4879,5515,10394,73.0,0.134695,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity 0.7.6;

interface ITreasury {
    function deposit(
        address _principalToken,
        uint _principalAmount,
        uint _payoutAmount
    ) external;

    function valueOfToken(address _principalToken, uint _amount) external view returns (uint value);
}",78
RealWorld_BA_52_SwapQueue_RealWord_20240821100533.log,52,SwapQueue,6804,4969,11773,67.0,0.1334,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/utils/Address.sol"";

import ""../../shared/ProtocolConstants.sol"";

import ""../../interfaces/dex/queue/ISwapQueue.sol"";

// TBD
contract SwapQueue is ISwapQueue, ProtocolConstants {
    using Address for address payable;

    mapping(uint256 => Queue) public queue;

    /* ========== STATE VARIABLES ========== */
    /* ========== CONSTRUCTOR ========== */
    /* ========== VIEWS ========== */
    /* ========== MUTATIVE FUNCTIONS ========== */

    function executeQueue() external {
        uint256 reimbursement = _executeQueue();
        payable(msg.sender).sendValue(reimbursement);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */
    /* ========== INTERNAL FUNCTIONS ========== */

    function _insertQueue(uint256 value) internal returns (bool) {}

    function _executeQueue() internal returns (uint256) {}
    /* ========== PRIVATE FUNCTIONS ========== */
    /* ========== MODIFIERS ========== */
}",199
RealWorld_BA_52_IGasQueue_RealWord_20240821105434.log,52,IGasQueue,3760,4140,7900,75.0,0.1016,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

interface IGasQueue {
    /* ========== STRUCTS ========== */
    /* ========== FUNCTIONS ========== */
    /* ========== EVENTS ========== */
}",42
RealWorld_BA_52_MockTarget_RealWord_20240821093743.log,52,MockTarget,5456,4182,9638,57.0,0.11092,"// SPDX-License-Identifier: Unlicensed

pragma solidity =0.8.9;

import ""../interfaces/governance/ITimelock.sol"";

contract MockTarget {
    bool public state;
    ITimelock public timelock;

    constructor(address _timelock) {
        timelock = ITimelock(_timelock);
    }

    function setStateToTrue() external onlyTimelock {
        state = true;
    }

    function changeState(bool _state) external onlyTimelock {
        state = _state;
    }

    modifier onlyTimelock() {
        require(msg.sender == address(timelock), ""only timelock can call"");
        _;
    }
}",148
RealWorld_BA_52_VaderPoolFactory_RealWord_20240821100642.log,52,VaderPoolFactory,19679,5531,25210,81.0,0.209015,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""./VaderPool.sol"";

import ""../../shared/ProtocolConstants.sol"";

import ""../../interfaces/shared/IERC20Extended.sol"";
import ""../../interfaces/dex/pool/IVaderPoolFactory.sol"";

/*
 * @dev Implementation of {VaderPoolFactory} contract.
 *
 * The VaderPoolFactory contract inherits from {Ownable} and {ProtocolConstants} contracts.
 *
 * Keeps track of all the created Vader pools through {getPool} mapping and
 * {allPools} array. Also stores the address of asset used as native asset
 * across all of the Vader pools created through the factory.
 *
 * Allows creation of new Vader pools.
 **/
contract VaderPoolFactory is IVaderPoolFactory, ProtocolConstants, Ownable {
    /* ========== STATE VARIABLES ========== */

    // Denotes whether the queue system is active on new pairs, disabled by default
    bool public queueActive;

    // Native Asset of the system
    address public override nativeAsset;

    // Token A -> Token B -> Pool mapping
    mapping(address => mapping(address => IVaderPool)) public override getPool;

    // A list of all pools
    IVaderPool[] public allPools;

    /* ========== VIEWS ========== */

    /* ========== MUTATIVE FUNCTIONS ========== */

    /*
     * @dev Allows creation of a Vader pool of native and foreign assets.
     *
     * Populates the {getPool} mapping with the newly created Vader pool and
     * pushes this pool to {allPools} array.
     *
     * Requirements:
     * - Native and foreign assets cannot be the same.
     * - Foreign asset cannot be the zero address.
     * - The pool against the specified foreign asset does not already exist.
     **/
    // NOTE: Between deployment & initialization may be corrupted but chance small
    function createPool(address tokenA, address tokenB)
        external
        override
        returns (IVaderPool pool)
    {
        (address token0, address token1) = tokenA == nativeAsset
            ? (tokenA, tokenB)
            : tokenB == nativeAsset
            ? (tokenB, tokenA)
            : (_ZERO_ADDRESS, _ZERO_ADDRESS);

        require(
            token0 != token1,
            ""VaderPoolFactory::createPool: Identical Tokens""
        );

        require(
            token1 != _ZERO_ADDRESS,
            ""VaderPoolFactory::createPool: Inexistent Token""
        );

        require(
            getPool[token0][token1] == IVaderPool(_ZERO_ADDRESS),
            ""VaderPoolFactory::createPool: Pair Exists""
        ); // single check is sufficient

        pool = new VaderPool(
            queueActive,
            IERC20Extended(token0),
            IERC20Extended(token1)
        );
        getPool[token0][token1] = pool;
        getPool[token1][token0] = pool; // populate mapping in the reverse direction
        allPools.push(pool);
        emit PoolCreated(token0, token1, pool, allPools.length);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    /*
     * @dev Allows initializing of the factory contract by owner by setting the
     * address of native asset for all the Vader pool and also transferring the
     * contract's ownership to {_dao}.
     *
     * Requirements:
     * - Only onwer can call this function.
     **/
    function initialize(address _nativeAsset, address _dao) external onlyOwner {
        require(
            _nativeAsset != _ZERO_ADDRESS && _dao != _ZERO_ADDRESS,
            ""VaderPoolFactory::initialize: Incorrect Arguments""
        );

        nativeAsset = _nativeAsset;
        transferOwnership(_dao);
    }

    /*
     * @dev Allows toggling of queue system of a pool.
     *
     * Requirements:
     * - This function can only be called when DAO is active.
     **/
    function toggleQueue(address token0, address token1) external onlyDAO {
        getPool[token0][token1].toggleQueue();
    }

    /* ========== INTERNAL FUNCTIONS ========== */

    /* ========== PRIVATE FUNCTIONS ========== */

    /**
     * @dev Ensures only the DAO is able to invoke a particular function by validating that
     * the owner is the msg.sender, equivalent to the DAO address, and that the native asset
     * has been set
     */
    function _onlyDAO() private view {
        require(
            nativeAsset != _ZERO_ADDRESS && owner() == _msgSender(),
            ""BasePool::_onlyDAO: Insufficient Privileges""
        );
    }

    /* ========== MODIFIERS ========== */

    /**
     * @dev Throws if invoked by anyone else other than the DAO
     */
    modifier onlyDAO() {
        _onlyDAO();
        _;
    }
}",1003
RealWorld_BA_52_MockTimelock_RealWord_20240821093520.log,52,MockTimelock,5043,4178,9221,61.0,0.108775,"// SPDX-License-Identifier: UNLICENSED

pragma solidity =0.8.9;

import ""../governance/Timelock.sol"";

contract MockTimelock is Timelock {
    constructor(address admin_, uint256 delay_) Timelock(admin_, delay_) {}

    function GRACE_PERIOD() public pure override returns (uint256) {
        return 1 days;
    }

    function MINIMUM_DELAY() public pure override returns (uint256) {
        return 5 minutes;
    }

    function MAXIMUM_DELAY() public pure override returns (uint256) {
        return 15 minutes;
    }
}",126
RealWorld_BA_52_IXVader_RealWord_20240821103919.log,52,IXVader,4586,4478,9064,67.0,0.11249,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IXVader is IERC20 {
    function getPastVotes(address account, uint256 blockNumber) external view returns (uint256);

    function getPastTotalSupply(uint256 blockNumber) external view returns (uint256);
}",81
RealWorld_BA_52_UQ112x112_RealWord_20240821102237.log,52,UQ112x112,5792,3920,9712,56.0,0.10736,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))

// range: [0, 2**112 - 1]
// resolution: 1 / 2**112

library UQ112x112 {
    uint224 constant Q112 = 2**112;

    // encode a uint112 as a UQ112x112
    function encode(uint112 y) internal pure returns (uint224 z) {
        z = uint224(y) * Q112; // never overflows
    }

    // divide a UQ112x112 by a uint112, returning a UQ112x112
    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {
        z = x / uint224(y);
    }
}",186
RealWorld_BA_52_IVaderPoolFactoryV2_RealWord_20240821104643.log,52,IVaderPoolFactoryV2,5651,4883,10534,75.0,0.125915,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""./IVaderPoolV2.sol"";

interface IVaderPoolFactoryV2 {
    /* ========== STRUCTS ========== */

    /* ========== FUNCTIONS ========== */

    function createPool(address tokenA, address tokenB)
        external
        returns (IVaderPoolV2);

    function getPool(address tokenA, address tokenB)
        external
        returns (IVaderPoolV2);

    function nativeAsset() external view returns (address);

    /* ========== EVENTS ========== */

    event PoolCreated(
        address token0,
        address token1,
        IVaderPoolV2 pool,
        uint256 totalPools
    );
}",145
RealWorld_BA_52_FixedPoint_RealWord_20240821102109.log,52,FixedPoint,33316,5481,38797,86.0,0.2762,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity =0.8.9;

import ""./FullMath.sol"";
import ""./Babylonian.sol"";
import ""./BitMath.sol"";

// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))
library FixedPoint {
    // range: [0, 2**112 - 1]
    // resolution: 1 / 2**112
    struct uq112x112 {
        uint224 _x;
    }

    // range: [0, 2**144 - 1]
    // resolution: 1 / 2**112
    struct uq144x112 {
        uint256 _x;
    }

    uint8 public constant RESOLUTION = 112;
    uint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112
    uint256 private constant Q224 =
        0x100000000000000000000000000000000000000000000000000000000; // 2**224
    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)

    // encode a uint112 as a UQ112x112
    function encode(uint112 x) internal pure returns (uq112x112 memory) {
        return uq112x112(uint224(x) << RESOLUTION);
    }

    // encodes a uint144 as a UQ144x112
    function encode144(uint144 x) internal pure returns (uq144x112 memory) {
        return uq144x112(uint256(x) << RESOLUTION);
    }

    // decode a UQ112x112 into a uint112 by truncating after the radix point
    function decode(uq112x112 memory self) internal pure returns (uint112) {
        return uint112(self._x >> RESOLUTION);
    }

    // decode a UQ144x112 into a uint144 by truncating after the radix point
    function decode144(uq144x112 memory self) internal pure returns (uint144) {
        return uint144(self._x >> RESOLUTION);
    }

    // multiply a UQ112x112 by a uint, returning a UQ144x112
    // reverts on overflow
    function mul(uq112x112 memory self, uint256 y)
        internal
        pure
        returns (uq144x112 memory)
    {
        uint256 z = 0;
        require(
            y == 0 || (z = self._x * y) / y == self._x,
            ""FixedPoint::mul: overflow""
        );
        return uq144x112(z);
    }

    // multiply a UQ112x112 by an int and decode, returning an int
    // reverts on overflow
    function muli(uq112x112 memory self, int256 y)
        internal
        pure
        returns (int256)
    {
        uint256 z = FullMath.mulDiv(self._x, uint256(y < 0 ? -y : y), Q112);
        require(z < 2**255, ""FixedPoint::muli: overflow"");
        return y < 0 ? -int256(z) : int256(z);
    }

    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112
    // lossy
    function muluq(uq112x112 memory self, uq112x112 memory other)
        internal
        pure
        returns (uq112x112 memory)
    {
        if (self._x == 0 || other._x == 0) {
            return uq112x112(0);
        }
        uint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0
        uint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112
        uint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0
        uint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112

        // partial products
        uint224 upper = uint224(upper_self) * upper_other; // * 2^0
        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224
        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112
        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112

        // so the bit shift does not overflow
        require(
            upper <= type(uint112).max,
            ""FixedPoint::muluq: upper overflow""
        );

        // this cannot exceed 256 bits, all values are 224 bits
        uint256 sum = uint256(upper << RESOLUTION) +
            uppers_lowero +
            uppero_lowers +
            (lower >> RESOLUTION);

        // so the cast does not overflow
        require(sum <= type(uint224).max, ""FixedPoint::muluq: sum overflow"");

        return uq112x112(uint224(sum));
    }

    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112
    function divuq(uq112x112 memory self, uq112x112 memory other)
        internal
        pure
        returns (uq112x112 memory)
    {
        require(other._x > 0, ""FixedPoint::divuq: division by zero"");
        if (self._x == other._x) {
            return uq112x112(uint224(Q112));
        }
        if (self._x <= type(uint144).max) {
            uint256 value = (uint256(self._x) << RESOLUTION) / other._x;
            require(value <= type(uint224).max, ""FixedPoint::divuq: overflow"");
            return uq112x112(uint224(value));
        }

        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);
        require(result <= type(uint224).max, ""FixedPoint::divuq: overflow"");
        return uq112x112(uint224(result));
    }

    // returns a UQ112x112 which represents the ratio of the numerator to the denominator
    // can be lossy
    function fraction(uint256 numerator, uint256 denominator)
        internal
        pure
        returns (uq112x112 memory)
    {
        require(denominator > 0, ""FixedPoint::fraction: division by zero"");
        if (numerator == 0) return FixedPoint.uq112x112(0);

        if (numerator <= type(uint144).max) {
            uint256 result = (numerator << RESOLUTION) / denominator;
            require(
                result <= type(uint224).max,
                ""FixedPoint::fraction: overflow""
            );
            return uq112x112(uint224(result));
        } else {
            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);
            require(
                result <= type(uint224).max,
                ""FixedPoint::fraction: overflow""
            );
            return uq112x112(uint224(result));
        }
    }

    // take the reciprocal of a UQ112x112
    // reverts on overflow
    // lossy
    function reciprocal(uq112x112 memory self)
        internal
        pure
        returns (uq112x112 memory)
    {
        require(self._x != 0, ""FixedPoint::reciprocal: reciprocal of zero"");
        require(self._x != 1, ""FixedPoint::reciprocal: overflow"");
        return uq112x112(uint224(Q224 / self._x));
    }

    // square root of a UQ112x112
    // lossy between 0/1 and 40 bits
    function sqrt(uq112x112 memory self)
        internal
        pure
        returns (uq112x112 memory)
    {
        if (self._x <= type(uint144).max) {
            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));
        }

        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);
        safeShiftBits -= safeShiftBits % 2;
        return
            uq112x112(
                uint224(
                    Babylonian.sqrt(uint256(self._x) << safeShiftBits) <<
                        ((112 - safeShiftBits) / 2)
                )
            );
    }
}",1855
RealWorld_BA_52_UniswapV2Library_RealWord_20240821101948.log,52,UniswapV2Library,24393,5195,29588,79.0,0.225865,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""../interfaces/IUniswapV2Pair.sol"";

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

library UniswapV2Library {
    using SafeMath for uint256;

    // returns sorted token addresses, used to handle return values from pairs sorted in this order
    function sortTokens(address tokenA, address tokenB)
        internal
        pure
        returns (address token0, address token1)
    {
        require(tokenA != tokenB, ""UniswapV2Library: IDENTICAL_ADDRESSES"");
        (token0, token1) = tokenA < tokenB
            ? (tokenA, tokenB)
            : (tokenB, tokenA);
        require(token0 != address(0), ""UniswapV2Library: ZERO_ADDRESS"");
    }

    // calculates the CREATE2 address for a pair without making any external calls
    function pairFor(
        address factory,
        address tokenA,
        address tokenB
    ) internal pure returns (address pair) {
        (address token0, address token1) = sortTokens(tokenA, tokenB);
        unchecked {
            pair = address(
                uint160(
                    uint256(
                        keccak256(
                            abi.encodePacked(
                                hex""ff"",
                                factory,
                                keccak256(abi.encodePacked(token0, token1)),
                                hex""96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f"" // init code hash
                            )
                        )
                    )
                )
            );
        }
    }

    // fetches and sorts the reserves for a pair
    function getReserves(
        address factory,
        address tokenA,
        address tokenB
    ) internal view returns (uint256 reserveA, uint256 reserveB) {
        (address token0, ) = sortTokens(tokenA, tokenB);
        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(
            pairFor(factory, tokenA, tokenB)
        ).getReserves();
        (reserveA, reserveB) = tokenA == token0
            ? (reserve0, reserve1)
            : (reserve1, reserve0);
    }

    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset
    function quote(
        uint256 amountA,
        uint256 reserveA,
        uint256 reserveB
    ) internal pure returns (uint256 amountB) {
        require(amountA > 0, ""UniswapV2Library: INSUFFICIENT_AMOUNT"");
        require(
            reserveA > 0 && reserveB > 0,
            ""UniswapV2Library: INSUFFICIENT_LIQUIDITY""
        );
        amountB = amountA.mul(reserveB) / reserveA;
    }

    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset
    function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) internal pure returns (uint256 amountOut) {
        require(amountIn > 0, ""UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT"");
        require(
            reserveIn > 0 && reserveOut > 0,
            ""UniswapV2Library: INSUFFICIENT_LIQUIDITY""
        );
        uint256 amountInWithFee = amountIn.mul(997);
        uint256 numerator = amountInWithFee.mul(reserveOut);
        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);
        amountOut = numerator / denominator;
    }

    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset
    function getAmountIn(
        uint256 amountOut,
        uint256 reserveIn,
        uint256 reserveOut
    ) internal pure returns (uint256 amountIn) {
        require(amountOut > 0, ""UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT"");
        require(
            reserveIn > 0 && reserveOut > 0,
            ""UniswapV2Library: INSUFFICIENT_LIQUIDITY""
        );
        uint256 numerator = reserveIn.mul(amountOut).mul(1000);
        uint256 denominator = reserveOut.sub(amountOut).mul(997);
        amountIn = (numerator / denominator).add(1);
    }

    // performs chained getAmountOut calculations on any number of pairs
    function getAmountsOut(
        address factory,
        uint256 amountIn,
        address[] memory path
    ) internal view returns (uint256[] memory amounts) {
        require(path.length >= 2, ""UniswapV2Library: INVALID_PATH"");
        amounts = new uint256[](path.length);
        amounts[0] = amountIn;
        for (uint256 i; i < path.length - 1; i++) {
            (uint256 reserveIn, uint256 reserveOut) = getReserves(
                factory,
                path[i],
                path[i + 1]
            );
            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);
        }
    }

    // performs chained getAmountIn calculations on any number of pairs
    function getAmountsIn(
        address factory,
        uint256 amountOut,
        address[] memory path
    ) internal view returns (uint256[] memory amounts) {
        require(path.length >= 2, ""UniswapV2Library: INVALID_PATH"");
        amounts = new uint256[](path.length);
        amounts[amounts.length - 1] = amountOut;
        for (uint256 i = path.length - 1; i > 0; i--) {
            (uint256 reserveIn, uint256 reserveOut) = getReserves(
                factory,
                path[i - 1],
                path[i]
            );
            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);
        }
    }
}",1300
RealWorld_BA_52_TestToken_RealWord_20240821111309.log,52,TestToken,5030,4091,9121,58.0,0.10697,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity 0.7.6;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract TestToken is ERC20 {
    constructor(
        string memory name,
        string memory symbol,
        uint8 decimals
    ) ERC20(name, symbol) {
        _setupDecimals(decimals);
    }

    function mint(address _to, uint _amount) external {
        _mint(_to, _amount);
    }

    function burn(address _from, uint _amount) external {
        _burn(_from, _amount);
    }
}",133
RealWorld_BA_52_IUniswapV2Callee_RealWord_20240821103252.log,52,IUniswapV2Callee,3875,4268,8143,63.0,0.104735,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

interface IUniswapV2Callee {
    function uniswapV2Call(
        address sender,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external;
}",63
RealWorld_BA_52_UniswapV2ERC20_RealWord_20240821101407.log,52,UniswapV2ERC20,16634,5547,22181,109.0,0.19411,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""./interfaces/IUniswapV2ERC20.sol"";

contract UniswapV2ERC20 is IUniswapV2ERC20 {
    string public constant name = ""Uniswap V2"";
    string public constant symbol = ""UNI-V2"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    bytes32 public DOMAIN_SEPARATOR;
    // keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    bytes32 public constant PERMIT_TYPEHASH =
        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
    mapping(address => uint256) public nonces;

    constructor() {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256(
                    ""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""
                ),
                keccak256(bytes(name)),
                keccak256(bytes(""1"")),
                chainId,
                address(this)
            )
        );
    }

    function _mint(address to, uint256 value) internal {
        totalSupply = totalSupply + value;
        balanceOf[to] = balanceOf[to] + value;
        emit Transfer(address(0), to, value);
    }

    function _burn(address from, uint256 value) internal {
        balanceOf[from] = balanceOf[from] - value;
        totalSupply = totalSupply - value;
        emit Transfer(from, address(0), value);
    }

    function _approve(
        address owner,
        address spender,
        uint256 value
    ) private {
        allowance[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    function _transfer(
        address from,
        address to,
        uint256 value
    ) private {
        balanceOf[from] = balanceOf[from] - value;
        balanceOf[to] = balanceOf[to] + value;
        emit Transfer(from, to, value);
    }

    function approve(address spender, uint256 value) external returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    function transfer(address to, uint256 value) external returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool) {
        if (allowance[from][msg.sender] != type(uint256).max) {
            allowance[from][msg.sender] = allowance[from][msg.sender] - value;
        }
        _transfer(from, to, value);
        return true;
    }

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        require(deadline >= block.timestamp, ""UniswapV2: EXPIRED"");
        bytes32 digest = keccak256(
            abi.encodePacked(
                ""\x19\x01"",
                DOMAIN_SEPARATOR,
                keccak256(
                    abi.encode(
                        PERMIT_TYPEHASH,
                        owner,
                        spender,
                        value,
                        nonces[owner]++,
                        deadline
                    )
                )
            )
        );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(
            recoveredAddress != address(0) && recoveredAddress == owner,
            ""UniswapV2: INVALID_SIGNATURE""
        );
        _approve(owner, spender, value);
    }
}",822
RealWorld_BA_52_MockToken_RealWord_20240821092906.log,52,MockToken,6011,5336,11347,79.0,0.136775,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MockToken is ERC20 {
    uint8 internal immutable _decimals;

    constructor(
        string memory _symbol,
        string memory _name,
        uint8 __decimals
    ) ERC20(_symbol, _name) {
        _decimals = __decimals;
    }

    function mint(address account, uint256 amount) public {
        _mint(account, amount);
    }

    function burn(address account, uint256 amount) public {
        _burn(account, amount);
    }

    function decimals() public view override returns (uint8) {
        return _decimals;
    }
}",157
RealWorld_BA_52_IUniswapV2Pair_RealWord_20240821103134.log,52,IUniswapV2Pair,8739,4789,13528,76.0,0.139475,"// SPDX-License-Identifier: Unlicense
pragma solidity =0.8.9;

import ""./IUniswapV2ERC20.sol"";

interface IUniswapV2Pair is IUniswapV2ERC20 {
    event Mint(address indexed sender, uint256 amount0, uint256 amount1);
    event Burn(
        address indexed sender,
        uint256 amount0,
        uint256 amount1,
        address indexed to
    );
    event Swap(
        address indexed sender,
        uint256 amount0In,
        uint256 amount1In,
        uint256 amount0Out,
        uint256 amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint256);

    function factory() external view returns (address);

    function token0() external view returns (address);

    function token1() external view returns (address);

    function getReserves()
        external
        view
        returns (
            uint112 reserve0,
            uint112 reserve1,
            uint32 blockTimestampLast
        );

    function price0CumulativeLast() external view returns (uint256);

    function price1CumulativeLast() external view returns (uint256);

    function kLast() external view returns (uint256);

    function mint(address to) external returns (uint256 liquidity);

    function burn(address to)
        external
        returns (uint256 amount0, uint256 amount1);

    function swap(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        bytes calldata data
    ) external;

    function skim(address to) external;

    function sync() external;

    function initialize(address, address) external;
}",367
RealWorld_BA_52_FullMath_RealWord_20240821111523.log,52,FullMath,8696,4646,13342,68.0,0.1364,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity 0.7.6;

library FullMath {
    function fullMul(uint x, uint y) private pure returns (uint l, uint h) {
        uint mm = mulmod(x, y, uint(-1));
        l = x * y;
        h = mm - l;
        if (mm < l) h -= 1;
    }

    function fullDiv(
        uint l,
        uint h,
        uint d
    ) private pure returns (uint) {
        uint pow2 = d & -d;
        d /= pow2;
        l /= pow2;
        l += h * ((-pow2) / pow2 + 1);
        uint r = 1;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        r *= 2 - d * r;
        return l * r;
    }

    function mulDiv(
        uint x,
        uint y,
        uint d
    ) internal pure returns (uint) {
        (uint l, uint h) = fullMul(x, y);
        uint mm = mulmod(x, y, d);
        if (mm > l) h -= 1;
        l -= mm;
        require(h < d, ""FullMath::mulDiv: overflow"");
        return fullDiv(l, h, d);
    }
}",349
RealWorld_BA_52_GasThrottle_RealWord_20240821100237.log,52,GasThrottle,5801,5572,11373,80.0,0.140445,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""../../shared/ProtocolConstants.sol"";

import ""../../interfaces/external/chainlink/IAggregator.sol"";

contract GasThrottle is ProtocolConstants {
    modifier validateGas() {
        // TODO: Uncomment prior to launch
        // require(
        //     block.basefee <= tx.gasprice &&
        //         tx.gasprice <=
        //         uint256(IAggregator(_FAST_GAS_ORACLE).latestAnswer()),
        //     ""GasThrottle::validateGas: Gas Exceeds Thresholds""
        // );
        _;
    }
}",133
RealWorld_BA_52_XVader_RealWord_20240821093842.log,52,XVader,11527,5837,17364,76.0,0.174375,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""../shared/ProtocolConstants.sol"";

contract XVader is ProtocolConstants, ERC20Votes, ReentrancyGuard {
    // Address of vader token
    IERC20 public immutable vader;

    /*
     * @dev Initializes contract's state by setting vader's tokens address and
     * setting current token's name and symbol.
     **/
    constructor(IERC20 _vader)
        ERC20Permit(""XVader"")
        ERC20(""XVader"", ""xVADER"")
    {
        require(
            _vader != IERC20(_ZERO_ADDRESS),
            ""XVader::constructor: _vader cannot be a zero address""
        );
        vader = _vader;
    }

    // Locks vader and mints xVader
    function enter(uint256 _amount) external nonReentrant {
        // Gets the amount of vader locked in the contract
        uint256 totalVader = vader.balanceOf(address(this));
        // Gets the amount of xVader in existence
        uint256 totalShares = totalSupply();

        uint256 xVADERToMint = totalShares == 0 || totalVader == 0
            // If no xVader exists, mint it 1:1 to the amount put in
            ? _amount
            // Calculate and mint the amount of xVader the vader is worth.
            // The ratio will change overtime, as xVader is burned/minted and
            // vader deposited + gained from fees / withdrawn.
            : (_amount * totalShares) / totalVader;

        _mint(msg.sender, xVADERToMint);

        // Lock the vader in the contract
        vader.transferFrom(msg.sender, address(this), _amount);
    }

    // Claim back your VADER
    // Unlocks the staked + gained vader and burns xVader
    function leave(uint256 _shares) external nonReentrant {
        // Calculates the amount of vader the xVader is worth
        uint vaderAmount = (_shares * vader.balanceOf(address(this))) / totalSupply();

        _burn(msg.sender, _shares);
        vader.transfer(msg.sender, vaderAmount);
    }
}",535
RealWorld_BA_52_IUSDV_RealWord_20240821110534.log,52,IUSDV,4086,4448,8534,63.0,0.10939,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

interface IUSDV {
    /* ========== STRUCTS ========== */

    /* ========== FUNCTIONS ========== */

    function distributeEmission() external;

    /* ========== EVENTS ========== */
}",50
RealWorld_BA_52_LPToken_RealWord_20240821094759.log,52,LPToken,11305,5876,17181,104.0,0.174045,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../../shared/ProtocolConstants.sol"";

import ""../../interfaces/dex-v2/pool/IVaderPoolV2.sol"";
import ""../../interfaces/dex-v2/wrapper/ILPToken.sol"";

contract LPToken is ILPToken, ProtocolConstants, ERC20, Ownable {
    IERC20Extended public immutable foreignAsset;
    IVaderPoolV2 public immutable pool;

    /* ========== CONSTRUCTOR ========== */

    constructor(IERC20Extended _foreignAsset, IVaderPoolV2 _pool)
        ERC20(_calculateName(_foreignAsset), _calculateSymbol(_foreignAsset))
    {
        foreignAsset = _foreignAsset;
        pool = _pool;
        transferOwnership(address(_pool));
    }

    /* ========== VIEWS ========== */

    function totalSupply() public view override returns (uint256) {
        return pool.pairSupply(foreignAsset);
    }

    function balanceOf(address user) public view override returns (uint256) {
        if (user == address(pool)) return totalSupply() - ERC20.totalSupply();
        else return ERC20.balanceOf(user);
    }

    function _calculateName(IERC20Extended token)
        internal
        view
        returns (string memory)
    {
        return _combine(token.name(), "" - USDV LP"");
    }

    function _calculateSymbol(IERC20Extended token)
        internal
        view
        returns (string memory)
    {
        return _combine(""V("", token.symbol(), ""|USDV)"");
    }

    function _combine(string memory a, string memory b)
        internal
        pure
        returns (string memory)
    {
        return _combine(a, b, """");
    }

    function _combine(
        string memory a,
        string memory b,
        string memory c
    ) internal pure returns (string memory) {
        return string(abi.encodePacked(a, b, c));
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function mint(address to, uint256 amount) external onlyOwner {
        _mint(to, amount);
    }

    function burn(uint256 amount) external onlyOwner {
        _burn(msg.sender, amount);
    }
}",487
RealWorld_BA_52_VaderRouterV2_RealWord_20240821095524.log,52,VaderRouterV2,42989,5817,48806,76.0,0.331285,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""../../shared/ProtocolConstants.sol"";

import ""../../dex/math/VaderMath.sol"";

import ""../../interfaces/reserve/IVaderReserve.sol"";
import ""../../interfaces/dex-v2/router/IVaderRouterV2.sol"";
import ""../../interfaces/dex-v2/pool/IVaderPoolV2.sol"";

/*
 @dev Implementation of {VaderRouterV2} contract.
 *
 * The contract VaderRouter inherits from {Ownable} and {ProtocolConstants} contracts.
 *
 * It allows adding of liquidity to Vader pairs.
 *
 * Allows removing of liquidity by the users and claiming the underlying assets from
 * the Vader pairs/pools.
 *
 * Allows swapping between native and foreign assets within a single Vader pair.
 *
 * Allows swapping of foreign assets across two different Vader pairs.
 **/
contract VaderRouterV2 is IVaderRouterV2, ProtocolConstants, Ownable {
    /* ========== LIBRARIES ========== */

    // Used for safe token transfers
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    // Address of the Vader pool contract.
    IVaderPoolV2 public immutable pool;

    // Address of native asset (USDV or Vader).
    IERC20 public immutable nativeAsset;

    // Address of reserve contract.
    IVaderReserve public reserve;

    /* ========== CONSTRUCTOR ========== */

    /*
     * @dev Initialises contract by setting pool and native asset addresses.
     *
     * Native assets address is taken from param {_pool} and native asset's address
     * is retrieved from {VaderPoolV2} contract.
     **/
    constructor(IVaderPoolV2 _pool) {
        require(
            _pool != IVaderPoolV2(_ZERO_ADDRESS),
            ""VaderRouterV2::constructor: Incorrect Arguments""
        );

        pool = _pool;
        nativeAsset = pool.nativeAsset();
    }

    /* ========== VIEWS ========== */

    /* ========== MUTATIVE FUNCTIONS ========== */

    /*
     * @dev Allows adding of liquidity to the Vader pool.
     *
     * Internally calls {addLiquidity} function.
     *
     * Returns the amount of liquidity minted.
     **/
    // NOTE: For Uniswap V2 compliancy, necessary due to stack too deep
    function addLiquidity(
        IERC20 tokenA,
        IERC20 tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256, // amountAMin = unused
        uint256, // amountBMin = unused
        address to,
        uint256 deadline
    ) external override returns (uint256 liquidity) {
        return
            addLiquidity(
                tokenA,
                tokenB,
                amountADesired,
                amountBDesired,
                to,
                deadline
            );
    }

    /*
     * @dev Allows adding of liquidity to the Vader pool.
     *
     * Calls `mint` function on the {BasePoolV2} contract.
     *
     * Pair is determined based {tokenA} and {tokenB} where one of them represents
     * native asset and the other one represents foreign asset.
     *
     * Returns the amount of liquidity units minted against a pair.
     *
     * Requirements:
     * - The current timestamp has not exceeded the param {deadline}.
     * - Amongst {tokenA} and {tokenB}, one should be the native asset and the other
     *   one must be the foreign asset.
     * - The foreign asset among {tokenA} and {tokenB} must be a supported token.
     **/
    function addLiquidity(
        IERC20 tokenA,
        IERC20 tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        address to,
        uint256 deadline
    ) public override ensure(deadline) returns (uint256 liquidity) {
        IERC20 foreignAsset;
        uint256 nativeDeposit;
        uint256 foreignDeposit;

        if (tokenA == nativeAsset) {
            require(
                pool.supported(tokenB),
                ""VaderRouterV2::addLiquidity: Unsupported Assets Specified""
            );
            foreignAsset = tokenB;
            foreignDeposit = amountBDesired;
            nativeDeposit = amountADesired;
        } else {
            require(
                tokenB == nativeAsset && pool.supported(tokenA),
                ""VaderRouterV2::addLiquidity: Unsupported Assets Specified""
            );
            foreignAsset = tokenA;
            foreignDeposit = amountADesired;
            nativeDeposit = amountBDesired;
        }

        liquidity = pool.mint(
            foreignAsset,
            nativeDeposit,
            foreignDeposit,
            msg.sender,
            to
        );
    }

    /*
     * @dev Allows removing of liquidity by {msg.sender} and transfers the
     * underlying assets to {to} address.
     *
     * The liquidity is removed from a pair represented by {tokenA} and {tokenB}.
     *
     * Transfers the NFT with Id {id} representing user's position, to the pool address,
     * so the pool is able to burn it in the `burn` function call.
     *
     * Calls the `burn` function on the pool contract.
     *
     * Calls the `reimburseImpermanentLoss` on reserve contract to cover impermanent loss
     * for the liquidity being removed.
     *
     * Requirements:
     * - The underlying assets amounts of {amountA} and {amountB} must
     *   be greater than or equal to {amountAMin} and {amountBMin}, respectively.
     * - The current timestamp has not exceeded the param {deadline}.
     * - Either of {tokenA} or {tokenB} should be a native asset and the other one
     *   must be the foreign asset associated with the NFT representing liquidity.
     **/
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 id,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    )
        public
        override
        ensure(deadline)
        returns (uint256 amountA, uint256 amountB)
    {
        IERC20 _foreignAsset = pool.positionForeignAsset(id);
        IERC20 _nativeAsset = nativeAsset;

        bool isNativeA = _nativeAsset == IERC20(tokenA);

        if (isNativeA) {
            require(
                IERC20(tokenB) == _foreignAsset,
                ""VaderRouterV2::removeLiquidity: Incorrect Addresses Specified""
            );
        } else {
            require(
                IERC20(tokenA) == _foreignAsset &&
                    IERC20(tokenB) == _nativeAsset,
                ""VaderRouterV2::removeLiquidity: Incorrect Addresses Specified""
            );
        }

        pool.transferFrom(msg.sender, address(pool), id);

        (
            uint256 amountNative,
            uint256 amountForeign,
            uint256 coveredLoss
        ) = pool.burn(id, to);

        (amountA, amountB) = isNativeA
            ? (amountNative, amountForeign)
            : (amountForeign, amountNative);

        require(
            amountA >= amountAMin,
            ""VaderRouterV2: INSUFFICIENT_A_AMOUNT""
        );
        require(
            amountB >= amountBMin,
            ""VaderRouterV2: INSUFFICIENT_B_AMOUNT""
        );

        reserve.reimburseImpermanentLoss(msg.sender, coveredLoss);
    }

    /*
     * @dev Allows swapping of exact source token amount to destination
     * token amount.
     *
     * Internally calls {_swap} function.
     *
     * Requirements:
     * - The destination amount {amountOut} must greater than or equal to param {amountOutMin}.
     * - The current timestamp has not exceeded the param {deadline}.
     **/
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        IERC20[] calldata path,
        address to,
        uint256 deadline
    ) external virtual override ensure(deadline) returns (uint256 amountOut) {
        amountOut = _swap(amountIn, path, to);

        require(
            amountOut >= amountOutMin,
            ""VaderRouterV2::swapExactTokensForTokens: Insufficient Trade Output""
        );
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    /*
    * @dev Sets the reserve address and renounces contract's ownership.
     *
     * Requirements:
     * - Only existing owner can call this function.
     * - Param {_reserve} cannot be a zero address.
     **/
    function initialize(IVaderReserve _reserve) external onlyOwner {
        require(
            _reserve != IVaderReserve(_ZERO_ADDRESS),
            ""VaderRouterV2::initialize: Incorrect Reserve Specified""
        );

        reserve = _reserve;

        renounceOwnership();
    }

    /* ========== INTERNAL FUNCTIONS ========== */

    /* ========== PRIVATE FUNCTIONS ========== */

    /*
     * @dev Allows swapping of assets from within a single Vader pool pair or
     * across two different Vader pairs.
     *
     * In case of a single Vader pair, the native asset can be swapped for foreign
     * asset and vice versa.
     *
     * In case of two Vader pairs, the foreign asset is swapped for native asset from
     * the first Vader pool and the native asset retrieved from the first Vader pair is swapped
     * for foreign asset from the second Vader pair.
     *
     * Requirements:
     * - Param {path} length can be either 2 or 3.
     * - If the {path} length is 3 the index 0 and 1 must contain foreign assets' addresses
     *   and index 1 must contain native asset's address.
     * - If the {path} length is 2 then either of indexes must contain foreign asset's address
     *   and the other one must contain native asset's address.
     **/
    function _swap(
        uint256 amountIn,
        IERC20[] calldata path,
        address to
    ) private returns (uint256 amountOut) {
        if (path.length == 3) {
            require(
                path[0] != path[1] &&
                    path[1] == pool.nativeAsset() &&
                    path[2] != path[1],
                ""VaderRouterV2::_swap: Incorrect Path""
            );

            path[0].safeTransferFrom(msg.sender, address(pool), amountIn);

            return pool.doubleSwap(path[0], path[2], amountIn, to);
        } else {
            require(
                path.length == 2,
                ""VaderRouterV2::_swap: Incorrect Path Length""
            );
            IERC20 _nativeAsset = nativeAsset;
            require(path[0] != path[1], ""VaderRouterV2::_swap: Incorrect Path"");

            path[0].safeTransferFrom(msg.sender, address(pool), amountIn);
            if (path[0] == _nativeAsset) {
                return pool.swap(path[1], amountIn, 0, to);
            } else {
                require(
                    path[1] == _nativeAsset,
                    ""VaderRouterV2::_swap: Incorrect Path""
                );
                return pool.swap(path[0], 0, amountIn, to);
            }
        }
    }

    /* ========== MODIFIERS ========== */

    // Guard ensuring that the current timestamp has not exceeded the param {deadline}.
    modifier ensure(uint256 deadline) {
        require(deadline >= block.timestamp, ""VaderRouterV2::ensure: Expired"");
        _;
    }
}",2501
RealWorld_BA_52_IUniswapV2ERC20_RealWord_20240821102723.log,52,IUniswapV2ERC20,7477,4984,12461,81.0,0.137065,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

interface IUniswapV2ERC20 {
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
    event Transfer(address indexed from, address indexed to, uint256 value);

    function name() external pure returns (string memory);

    function symbol() external pure returns (string memory);

    function decimals() external pure returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address owner) external view returns (uint256);

    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function transfer(address to, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PERMIT_TYPEHASH() external pure returns (bytes32);

    function nonces(address owner) external view returns (uint256);

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}",280
RealWorld_BA_52_IVaderPool_RealWord_20240821105913.log,52,IVaderPool,4950,4150,9100,74.0,0.10775,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

import ""./IBasePool.sol"";

interface IVaderPool is IBasePool, IERC721 {
    /* ========== STRUCTS ========== */
    /* ========== FUNCTIONS ========== */

    function burn(uint256 id, address to)
        external
        returns (
            uint256 amountNative,
            uint256 amountForeign,
            uint256 coveredLoss
        );

    function toggleQueue() external;

    /* ========== EVENTS ========== */

    event QueueActive(bool activated);
}",124
RealWorld_BA_52_MockAggregatorV3_RealWord_20240821093026.log,52,MockAggregatorV3,7886,4579,12465,68.0,0.13101,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MockAggregatorV3 {
    IERC20 public token;

    uint80 private _storedRoundId;

    constructor(IERC20 _token) {
        token = _token;
    }

    function decimals() external pure returns (uint8) {
        return 8;
    }

    function version() external pure returns (uint256) {
        return 3;
    }

    function getRoundData(uint80 _roundId)
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        // Mock Data
        roundId = _roundId;
        answer = 1e8;
        startedAt = block.timestamp;
        updatedAt = block.timestamp;
        answeredInRound = roundId;
    }

    function latestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        // Mock Data
        roundId = _storedRoundId + 1;
        answer = 1e8;
        startedAt = block.timestamp;
        updatedAt = block.timestamp;
        answeredInRound = roundId;
    }
}",305
RealWorld_BA_52_MockUniswapV2Factory_RealWord_20240821092749.log,52,MockUniswapV2Factory,11146,5563,16709,75.0,0.16699,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""../external/interfaces/IUniswapV2Factory.sol"";
import ""../external/UniswapV2Pair.sol"";

contract MockUniswapV2Factory is IUniswapV2Factory {
    address public feeTo;
    address public feeToSetter;

    mapping(address => mapping(address => address)) public getPair;
    address[] public allPairs;

    constructor(address _feeToSetter) {
        feeToSetter = _feeToSetter;
    }

    function allPairsLength() external view returns (uint256) {
        return allPairs.length;
    }

    function createPair(address tokenA, address tokenB)
        external
        returns (address pair)
    {
        require(tokenA != tokenB, ""UniswapV2: IDENTICAL_ADDRESSES"");
        (address token0, address token1) = tokenA < tokenB
            ? (tokenA, tokenB)
            : (tokenB, tokenA);
        require(token0 != address(0), ""UniswapV2: ZERO_ADDRESS"");
        require(
            getPair[token0][token1] == address(0),
            ""UniswapV2: PAIR_EXISTS""
        ); // single check is sufficient
        bytes memory bytecode = type(UniswapV2Pair).creationCode;
        bytes32 salt = keccak256(abi.encodePacked(token0, token1));
        assembly {
            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
        }
        IUniswapV2Pair(pair).initialize(token0, token1);
        getPair[token0][token1] = pair;
        getPair[token1][token0] = pair; // populate mapping in the reverse direction
        allPairs.push(pair);
        emit PairCreated(token0, token1, pair, allPairs.length);
    }

    function setFeeTo(address _feeTo) external {
        require(msg.sender == feeToSetter, ""UniswapV2: FORBIDDEN"");
        feeTo = _feeTo;
    }

    function setFeeToSetter(address _feeToSetter) external {
        require(msg.sender == feeToSetter, ""UniswapV2: FORBIDDEN"");
        feeToSetter = _feeToSetter;
    }
}",494
RealWorld_BA_52_Pausable_RealWord_20240821094111.log,52,Pausable,7406,5073,12479,76.0,0.13849,"// SPDX-License-Identifier: Unlicense
pragma solidity 0.8.9;

import ""./Owned.sol"";

abstract contract Pausable is Owned {
    uint public lastPauseTime;
    bool public paused;

    constructor() {
        // This contract is abstract, and thus cannot be instantiated directly
        require(owner != address(0), ""Owner must be set"");
        // Paused will be false, and lastPauseTime will be 0 upon initialisation
    }

    /**
     * @notice Change the paused state of the contract
     * @dev Only the contract owner may call this.
     */
    function setPaused(bool _paused) external onlyOwner {
        // Ensure we're actually changing the state before we do anything
        if (_paused == paused) {
            return;
        }

        // Set our paused state.
        paused = _paused;

        // If applicable, set the last pause time.
        if (_paused) {
            lastPauseTime = block.timestamp;
        }

        // Let everyone know that our pause state has changed.
        emit PauseChanged(_paused);
    }

    event PauseChanged(bool isPaused);

    modifier notPaused() {
        require(!paused, ""paused"");
        _;
    }
}",252
RealWorld_BA_52_MockUniswapV2Library_RealWord_20240821093252.log,52,MockUniswapV2Library,4374,4130,8504,66.0,0.10447,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""../external/libraries/UniswapV2Library.sol"";

contract MockUniswapV2Library {
    function pairFor(
        address _factory,
        address _token0,
        address _token1
    ) external pure returns (address) {
        return UniswapV2Library.pairFor(_factory, _token0, _token1);
    }
}",95
RealWorld_BA_52_MockConstants_RealWord_20240821093400.log,52,MockConstants,8453,4206,12659,78.0,0.126385,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""../shared/ProtocolConstants.sol"";

contract MockConstants is ProtocolConstants {
    // Max VADER supply
    uint256 public constant INITIAL_VADER_SUPPLY = _INITIAL_VADER_SUPPLY;

    // Allocation for VETH holders
    uint256 public constant VETH_ALLOCATION = _VETH_ALLOCATION;

    // Vader -> Vether Conversion Rate (1000:1)
    uint256 public constant VADER_VETHER_CONVERSION_RATE =
        _VADER_VETHER_CONVERSION_RATE;

    // Team allocation vested over {VESTING_DURATION} years
    uint256 public constant TEAM_ALLOCATION = _TEAM_ALLOCATION;

    // Ecosystem growth fund unlocked for partnerships & USDV provision
    uint256 public constant ECOSYSTEM_GROWTH = _ECOSYSTEM_GROWTH;

    // Emission Era
    uint256 public constant EMISSION_ERA = _EMISSION_ERA;

    // One year, utility
    uint256 public constant ONE_YEAR = _ONE_YEAR;

    // Initial Emission Curve, 5
    uint256 public constant INITIAL_EMISSION_CURVE = _INITIAL_EMISSION_CURVE;

    // Vesting Duration
    uint256 public constant VESTING_DURATION = _VESTING_DURATION;

    // Basis Points
    uint256 public constant MAX_BASIS_POINTS = _MAX_BASIS_POINTS;

    // Fee Basis Points
    uint256 public constant MAX_FEE_BASIS_POINTS = _MAX_FEE_BASIS_POINTS;

    // Burn Address
    address public constant BURN = _BURN;
}",338
RealWorld_BA_52_IBasePoolV2_RealWord_20240821104525.log,52,IBasePoolV2,12519,5199,17718,76.0,0.166575,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IBasePoolV2 {
    /* ========== STRUCTS ========== */

    struct Position {
        IERC20 foreignAsset;
        uint256 creation;
        uint256 liquidity;
        uint256 originalNative;
        uint256 originalForeign;
    }

    struct PairInfo {
        uint256 totalSupply;
        uint112 reserveNative;
        uint112 reserveForeign;
        uint32 blockTimestampLast;
        PriceCumulative priceCumulative;
    }

    struct PriceCumulative {
        uint256 nativeLast;
        uint256 foreignLast;
    }

    /* ========== FUNCTIONS ========== */

    function getReserves(
        IERC20 foreignAsset
    ) external view returns (
        uint112 reserve0,
        uint112 reserve1,
        uint32 blockTimestampLast
    );

    function nativeAsset() external view returns (IERC20);

    function supported(IERC20 token) external view returns (bool);

    function positionForeignAsset(uint256 id) external view returns (IERC20);

    function pairSupply(IERC20 foreignAsset) external view returns (uint256);

    function doubleSwap(
        IERC20 foreignAssetA,
        IERC20 foreignAssetB,
        uint256 foreignAmountIn,
        address to
    ) external returns (uint256);

    function swap(
        IERC20 foreignAsset,
        uint256 nativeAmountIn,
        uint256 foreignAmountIn,
        address to
    ) external returns (uint256);

    function mint(
        IERC20 foreignAsset,
        uint256 nativeDeposit,
        uint256 foreignDeposit,
        address from,
        address to
    ) external returns (uint256 liquidity);

    /* ========== EVENTS ========== */

    event Mint(
        address indexed sender,
        address indexed to,
        uint256 amount0,
        uint256 amount1
    ); // Adjustment -> new argument to which didnt exist
    event Burn(
        address indexed sender,
        uint256 amount0,
        uint256 amount1,
        address indexed to
    );
    event Swap(
        IERC20 foreignAsset,
        address indexed sender,
        uint256 amount0In,
        uint256 amount1In,
        uint256 amount0Out,
        uint256 amount1Out,
        address indexed to
    );
    event Sync(IERC20 foreignAsset, uint256 reserve0, uint256 reserve1); // Adjustment -> 112 to 256
    event PositionOpened(
        address indexed from,
        address indexed to,
        uint256 id,
        uint256 liquidity
    );
    event PositionClosed(
        address indexed sender,
        uint256 id,
        uint256 liquidity,
        uint256 loss
    );
}",573
RealWorld_BA_52_IVader_RealWord_20240821110403.log,52,IVader,6077,5319,11396,89.0,0.136765,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

interface IVader {
    /* ========== FUNCTIONS ========== */

    function createEmission(address user, uint256 amount) external;

    function calculateFee() external view returns (uint256 basisPoints);

    function getCurrentEraEmission() external view returns (uint256);

    function getEraEmission(uint256 currentSupply)
        external
        view
        returns (uint256);

    /* ========== EVENTS ========== */

    event Emission(address to, uint256 amount);

    event EmissionChanged(uint256 previous, uint256 next);

    event MaxSupplyChanged(uint256 previous, uint256 next);

    event GrantClaimed(address indexed beneficiary, uint256 amount);

    event ProtocolInitialized(
        address converter,
        address vest,
        address usdv,
        address dao
    );
}",175
RealWorld_BA_52_IStakingRewards_RealWord_20240821094229.log,52,IStakingRewards,5998,5503,11501,79.0,0.14005,"// SPDX-License-Identifier: Unlicense
pragma solidity 0.8.9;

interface IStakingRewards {
    // Views

    function balanceOf(address account) external view returns (uint);

    function earned(address account) external view returns (uint);

    function getRewardForDuration() external view returns (uint);

    function lastTimeRewardApplicable() external view returns (uint);

    function rewardPerToken() external view returns (uint);

    // function rewardsDistribution() external view returns (address);

    // function rewardsToken() external view returns (address);

    function totalSupply() external view returns (uint);

    // Mutative

    function exit() external;

    function getReward() external;

    function stake(uint amount) external;

    function withdraw(uint amount) external;
}",162
RealWorld_BA_52_AggregatorV3Interface_RealWord_20240821102847.log,52,AggregatorV3Interface,7035,4632,11667,82.0,0.127815,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface AggregatorV3Interface {

  function decimals()
    external
    view
    returns (
      uint8
    );

  function description()
    external
    view
    returns (
      string memory
    );

  function version()
    external
    view
    returns (
      uint256
    );

  // getRoundData and latestRoundData should both raise ""No data present""
  // if they do not have data to report, instead of returning unset values
  // which could be misinterpreted as actual reported values.
  function getRoundData(
    uint80 _roundId
  )
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );

  function latestRoundData()
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );

}",228
RealWorld_BA_52_MockXVader_RealWord_20240821093135.log,52,MockXVader,4679,4265,8944,75.0,0.108695,"// SPDX-License-Identifier: Unlicensed

pragma solidity =0.8.9;

import ""../x-vader/XVader.sol"";

contract MockXVader is XVader {

    constructor(IERC20 _vader) XVader(_vader) {}

    function mint(address to, uint256 amount) external {
        ERC20Votes._mint(to, amount);
    }

    function burn(address from, uint256 amount) external {
        ERC20Votes._burn(from, amount);
    }
}",101
RealWorld_BA_52_ISynth_RealWord_20240821104418.log,52,ISynth,3848,4303,8151,65.0,0.1053,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface ISynth is IERC20 {
    function mint(address to, uint256 amount) external;

    function burn(uint256 amount) external;
}",64
RealWorld_BA_52_Migrations_RealWord_20240821092638.log,52,Migrations,5121,4578,9699,69.0,0.117165,"// SPDX-License-Identifier: MIT
pragma solidity >=0.4.22 <0.9.0;

contract Migrations {
    address public owner = msg.sender;
    uint256 public last_completed_migration;

    modifier restricted() {
        require(
            msg.sender == owner,
            ""This function is restricted to the contract's owner""
        );
        _;
    }

    function setCompleted(uint256 completed) public restricted {
        last_completed_migration = completed;
    }
}",96
RealWorld_BA_52_IVaderReserve_RealWord_20240821110150.log,52,IVaderReserve,4972,4507,9479,67.0,0.115,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

interface IVaderReserve {
    /* ========== STRUCTS ========== */
    /* ========== FUNCTIONS ========== */

    function reimburseImpermanentLoss(address recipient, uint256 amount)
        external;

    function grant(address recipient, uint256 amount) external;

    function reserve() external view returns (uint256);

    /* ========== EVENTS ========== */

    event GrantDistributed(address recipient, uint256 amount);
    event LossCovered(address recipient, uint256 amount, uint256 actualAmount);
}",111
RealWorld_BA_52_ILPToken_RealWord_20240821104146.log,52,ILPToken,4081,5153,9234,76.0,0.123465,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""../../shared/IERC20Extended.sol"";

interface ILPToken {
    function mint(address to, uint256 amount) external;

    function burn(uint256 amount) external;
}",54
RealWorld_BA_52_BasePool_RealWord_20240821100924.log,52,BasePool,56006,6148,62154,97.0,0.40299,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

import ""../math/VaderMath.sol"";
// import ""../queue/SwapQueue.sol"";
import ""../utils/GasThrottle.sol"";

import ""../../external/libraries/UQ112x112.sol"";

import ""../../interfaces/dex/pool/IBasePool.sol"";
import ""../../interfaces/shared/IERC20Extended.sol"";

/*
 * @dev Implementation of {BasePool} contract.
 *
 * The BasePool contract represents pool of two assets termed as native and
 * foreign assets. The functionality in this contract allows depositing of both
 * of these assets to mint liquidity. Minted liquidity is associated with a
 * position which is represented by an NFT token.
 *
 * The contract allows burning of NFT and in turn redeems the associated liquidity,
 * transferring out underlying assets to the LP.
 *
 * The contract allows swapping of both native and foreign assets among themselves.
 *
 * Keeps track of the cumulative prices for both native and foreign assets and updates
 * them after minting and burning of liquidity, and swapping of assets.
 **/
contract BasePool is IBasePool, GasThrottle, ERC721, Ownable, ReentrancyGuard {
    /* ========== LIBRARIES ========== */

    // Used for safe token transfers
    using SafeERC20 for IERC20;

    // Used by Uniswap-like TWAP mechanism
    using UQ112x112 for uint224;

    /* ========== STATE VARIABLES ========== */

    // Address of native asset (Vader or USDV).
    IERC20 public immutable nativeAsset;

    // Address of foreign asset with which the native asset is paired in the pool.
    IERC20 public immutable foreignAsset;

    // Cumulative price of native asset.
    uint256 public priceNativeCumulativeLast;

    // Cumulative price of foreign asset.
    uint256 public priceForeignCumulativeLast;

    /*
     * @dev A mapping representing positions of liquidity providers. Each position
     * is an Non-fungible token that is mapped against amounts of native and foreign assets
     * deposited, the timestamp at which the position is created and the amount of
     * liquidity assigned to the LP.
     *
     * Each position in the mapping is mapped against {positionId}.
     **/
    mapping(uint256 => Position) public positions;

    // A unique id the of the position created when liquidity is added to the pool.
    uint256 public positionId;

    // Total amount of liquidity units minted.
    uint256 public totalSupply;

    // Name of the contract.
    string private _name;

    // Total amount of the native asset realised by the contract.
    uint112 private _reserveNative; // uses single storage slot, accessible via getReserves

    // Total amount of the foreign asset realised by the contract.
    uint112 private _reserveForeign; // uses single storage slot, accessible via getReserves

    // Last timestamp at which the cumulative prices for native and foreign assets were updated.
    uint32 private _blockTimestampLast; // uses single storage slot, accessible via getReserves

    /* ========== CONSTRUCTOR ========== */

    /*
     * @dev Initialized the contract state setting the addresses for native and foreign assets.
     *
     * Also computes the name of the contract and stores it in the contract's state.
     **/
    constructor(IERC20Extended _nativeAsset, IERC20Extended _foreignAsset)
        ERC721(""Vader LP"", ""VLP"")
    {
        nativeAsset = IERC20(_nativeAsset);
        foreignAsset = IERC20(_foreignAsset);

        string memory calculatedName = string(
            abi.encodePacked(""Vader USDV /"", _foreignAsset.symbol(), "" LP"")
        );
        _name = calculatedName;
    }

    /* ========== VIEWS ========== */

    /*
     * @dev Returns the realised amount of native and foreign assets, and the last timestamp
     * at which the cumulative prices for native and foreign assets were updated.
     **/
    function getReserves()
        public
        view
        returns (
            uint112 reserveNative,
            uint112 reserveForeign,
            uint32 blockTimestampLast
        )
    {
        reserveNative = _reserveNative;
        reserveForeign = _reserveForeign;
        blockTimestampLast = _blockTimestampLast;
    }

    // Returns the name of the contract.
    function name() public view override returns (string memory) {
        return _name;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    /*
     * @dev Allows depositing of liquidity to the pool by accepting native and foreign assets
     * and mints an NFT to the {to} address which records the amounts of the native and foreign
     * assets deposited and the liquidity units minted against it in {positions} mapping.
     *
     * Updates the total supply of liquidity units by adding currently minted liquidity units
     * to {totalSupply}.
     *
     * Updates the cumulative prices of native and foreign assets after minting the appropriate
     * liquidity units.
     *
     * Requirements:
     * - Amounts of native and foreign must be sent to the pool prior to calling `mint` such that
     *   balance of pool for both assets must be greater than their corresponding reserves.
     * - The amount of {liquidity} to be minted must be greater than 0.
     **/
    function mint(address to)
        external
        override
        nonReentrant
        returns (uint256 liquidity)
    {
        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(); // gas savings
        uint256 balanceNative = nativeAsset.balanceOf(address(this));
        uint256 balanceForeign = foreignAsset.balanceOf(address(this));
        uint256 nativeDeposit = balanceNative - reserveNative;
        uint256 foreignDeposit = balanceForeign - reserveForeign;

        uint256 totalLiquidityUnits = totalSupply;
        if (totalLiquidityUnits == 0)
            liquidity = nativeDeposit; // TODO: Contact ThorChain on proper approach
        else
            liquidity = VaderMath.calculateLiquidityUnits(
                nativeDeposit,
                reserveNative,
                foreignDeposit,
                reserveForeign,
                totalLiquidityUnits
            );

        require(
            liquidity > 0,
            ""BasePool::mint: Insufficient Liquidity Provided""
        );

        uint256 id = positionId++;

        totalSupply += liquidity;
        _mint(to, id);

        positions[id] = Position(
            block.timestamp,
            liquidity,
            nativeDeposit,
            foreignDeposit
        );

        _update(balanceNative, balanceForeign, reserveNative, reserveForeign);

        emit Mint(msg.sender, to, nativeDeposit, foreignDeposit);
        emit PositionOpened(msg.sender, id, liquidity);
    }

    /*
     * @dev Allows redeeming of liquidity units by burning the NFT associated with the liquidity
     * position.
     *
     * Computes the amounts of native and foreign assets depending upon current reserves of assets and
     * the liquidity associated with the position, and transfers them to the {to} address.
     *
     * Burns the redeemed NFT token and decreases {totalSupply} by the {liquidity}
     * associated with that NFT token.
     *
     * Updates the cumulative prices for native and foreign assets after transferring the assets
     * to the {to} address.
     *
     * Requirements:
     * - The NFT token being redeemed must be transferred to the pool prior to calling `_burn`.
     * - The amount of native and foreign assets computed for transfer to {to} address must be greater
     *   than 0.
     **/
    function _burn(uint256 id, address to)
        internal
        nonReentrant
        returns (uint256 amountNative, uint256 amountForeign)
    {
        require(
            ownerOf(id) == address(this),
            ""BasePool::burn: Incorrect Ownership""
        );

        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(); // gas savings
        IERC20 _nativeAsset = nativeAsset; // gas savings
        IERC20 _foreignAsset = foreignAsset; // gas savings
        uint256 nativeBalance = IERC20(_nativeAsset).balanceOf(address(this));
        uint256 foreignBalance = IERC20(_foreignAsset).balanceOf(address(this));

        uint256 liquidity = positions[id].liquidity;

        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
        amountNative = (liquidity * nativeBalance) / _totalSupply; // using balances ensures pro-rata distribution
        amountForeign = (liquidity * foreignBalance) / _totalSupply; // using balances ensures pro-rata distribution

        require(
            amountNative > 0 && amountForeign > 0,
            ""BasePool::burn: Insufficient Liquidity Burned""
        );

        totalSupply -= liquidity;
        _burn(id);

        _nativeAsset.safeTransfer(to, amountNative);
        _foreignAsset.safeTransfer(to, amountForeign);

        nativeBalance = _nativeAsset.balanceOf(address(this));
        foreignBalance = _foreignAsset.balanceOf(address(this));

        _update(nativeBalance, foreignBalance, reserveNative, reserveForeign);

        emit Burn(msg.sender, amountNative, amountForeign, to);
    }

    /*
     * @dev  Allows swapping between native and foreign assets. It receives the source asset
     * and computes the destination asset and transfers it to the {to} address.
     *
     * Internally calls {swap} function.
     **/
    function swap(
        uint256 nativeAmountIn,
        uint256 foreignAmountIn,
        address to,
        bytes calldata
    ) external override returns (uint256) {
        return swap(nativeAmountIn, foreignAmountIn, to);
    }

    /*
     * @dev Allows swapping between native and foreign assets. It receives the source asset
     * and computes the destination asset and transfers it to the {to} address.
     *
     * Updates the cumulative prices for native and foreign assets after performing swap.
     *
     * Returns the amount of destination tokens resulting from the swap.
     *
     * Requirements:
     * - Param {nativeAmountIn} must be zero and {foreignAmountIn} must be non-zero
     *   if the destination asset in swap is native asset.
     * - Param {foreignAmountIn} must be zero and {nativeAmountIn} must be non zero
     *   if the destination asset in swap is foreign asset.
     * - Param {to} cannot be the addresses of native or foreign assets.
     * - The source asset amount in the swap must be transferred to the pool prior to calling `swap`.
     * - The source asset amount in the swap cannot exceed the source asset's reserve.
     * - The destination asset's amount in the swap must be greater than 0 and not exceed destination
     *   asset's reserve.
     **/
    function swap(
        uint256 nativeAmountIn,
        uint256 foreignAmountIn,
        address to
    ) public override nonReentrant validateGas returns (uint256) {
        require(
            (nativeAmountIn > 0 && foreignAmountIn == 0) ||
                (nativeAmountIn == 0 && foreignAmountIn > 0),
            ""BasePool::swap: Only One-Sided Swaps Supported""
        );
        (uint112 nativeReserve, uint112 foreignReserve, ) = getReserves(); // gas savings

        uint256 nativeBalance;
        uint256 foreignBalance;
        uint256 nativeAmountOut;
        uint256 foreignAmountOut;
        {
            // scope for _token{0,1}, avoids stack too deep errors
            IERC20 _nativeAsset = nativeAsset;
            IERC20 _foreignAsset = foreignAsset;
            nativeBalance = _nativeAsset.balanceOf(address(this));
            foreignBalance = _foreignAsset.balanceOf(address(this));

            require(
                to != address(_nativeAsset) && to != address(_foreignAsset),
                ""BasePool::swap: Invalid Receiver""
            );

            if (foreignAmountIn > 0) {
                require(
                    foreignAmountIn <= foreignBalance - foreignReserve,
                    ""BasePool::swap: Insufficient Tokens Provided""
                );
                require(
                    foreignAmountIn <= foreignReserve,
                    ""BasePool::swap: Unfavourable Trade""
                );

                nativeAmountOut = VaderMath.calculateSwap(
                    foreignAmountIn,
                    foreignReserve,
                    nativeReserve
                );

                require(
                    nativeAmountOut > 0 && nativeAmountOut <= nativeReserve,
                    ""BasePool::swap: Swap Impossible""
                );

                _nativeAsset.safeTransfer(to, nativeAmountOut); // optimistically transfer tokens
            } else {
                require(
                    nativeAmountIn <= nativeBalance - nativeReserve,
                    ""BasePool::swap: Insufficient Tokens Provided""
                );
                require(
                    nativeAmountIn <= nativeReserve,
                    ""BasePool::swap: Unfavourable Trade""
                );

                foreignAmountOut = VaderMath.calculateSwap(
                    nativeAmountIn,
                    nativeReserve,
                    foreignReserve
                );

                require(
                    foreignAmountOut > 0 && foreignAmountOut <= foreignReserve,
                    ""BasePool::swap: Swap Impossible""
                );

                _foreignAsset.safeTransfer(to, foreignAmountOut); // optimistically transfer tokens
            }

            nativeBalance = _nativeAsset.balanceOf(address(this));
            foreignBalance = _foreignAsset.balanceOf(address(this));
        }

        _update(nativeBalance, foreignBalance, nativeReserve, foreignReserve);

        emit Swap(
            msg.sender,
            nativeAmountIn,
            foreignAmountIn,
            nativeAmountOut,
            foreignAmountOut,
            to
        );

        return nativeAmountOut > 0 ? nativeAmountOut : foreignAmountOut;
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    /* ========== INTERNAL FUNCTIONS ========== */

    /*
     * @dev Internally called to update the cumulative prices for native and foreign assets depending
     * upon the last reserves and updates the reserves for both of the assets corresponding to their
     * current balances along with the {_blockTimestampLast}.
     *
     * Requirements:
     * - Params {balanceNative} and {balanceForeign} must not overflow type `uint112`.
     *
     **/
    function _update(
        uint256 balanceNative,
        uint256 balanceForeign,
        uint112 reserveNative,
        uint112 reserveForeign
    ) internal {
        require(
            balanceNative <= type(uint112).max &&
                balanceForeign <= type(uint112).max,
            ""BasePool::_update: Balance Overflow""
        );
        uint32 blockTimestamp = uint32(block.timestamp % 2**32);
        unchecked {
            uint32 timeElapsed = blockTimestamp - _blockTimestampLast; // overflow is desired
            if (timeElapsed > 0 && reserveNative != 0 && reserveForeign != 0) {
                // * never overflows, and + overflow is desired
                priceNativeCumulativeLast +=
                    uint256(
                        UQ112x112.encode(reserveForeign).uqdiv(reserveNative)
                    ) *
                    timeElapsed;
                priceForeignCumulativeLast +=
                    uint256(
                        UQ112x112.encode(reserveNative).uqdiv(reserveForeign)
                    ) *
                    timeElapsed;
            }
        }
        _reserveNative = uint112(balanceNative);
        _reserveForeign = uint112(balanceForeign);
        _blockTimestampLast = blockTimestamp;
        emit Sync(balanceNative, balanceForeign);
    }

    /* ========== PRIVATE FUNCTIONS ========== */

    /* ========== MODIFIERS ========== */
}",3322
RealWorld_BA_52_TwapOracle_RealWord_20240821095759.log,52,TwapOracle,48757,5078,53835,88.0,0.345345,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";

import ""../external/interfaces/AggregatorV3Interface.sol"";
import ""../external/interfaces/IUniswapV2Factory.sol"";
import ""../external/interfaces/IUniswapV2Pair.sol"";

import ""../external/libraries/FixedPoint.sol"";
import ""../external/libraries/UniswapV2OracleLibrary.sol"";
import ""../external/libraries/UniswapV2Library.sol"";

import ""../interfaces/dex-v2/pool/IVaderPoolV2.sol"";

contract TwapOracle is Ownable {
    /* ========== LIBRARIES ========== */

    using FixedPoint for *;

    /* ========== STRUCTURES ========== */

    struct PairData {
        // The address of the pair interface (IUniswapV2Pair or IVaderPoolV2)
        address pair;
        // The first token of the pair.
        address token0;
        // The second token of the pair.
        address token1;
        // The last cumulative price of the first token.
        uint256 price0CumulativeLast;
        // The last cumulative price of the second token.
        uint256 price1CumulativeLast;
        // The block timestamp of the last update.
        uint32 blockTimestampLast;
        // The average price of the first token.
        FixedPoint.uq112x112 price0Average;
        // The average price of the second token.
        FixedPoint.uq112x112 price1Average;
    }

    /* ========== STATE VARIABLES ========== */

    // The address of the deployed VADER token.
    address public VADER;

    // The address of the deployed USDV token.
    address public USDV;

    // A predicated which determines if USDV is enabled.
    bool private _usdvEnabled;

    // The mapping of native assets to USD aggregators.
    mapping(address => address) private _aggregators;

    // The vader pool used across all native assets.
    IVaderPoolV2 private _vaderPool;

    // The frequency that the pair collection should be updated.
    uint256 private _updatePeriod;

    // The collection of pairs tracked by the TWAP oracle.
    PairData[] private _pairs;

    // A mapping of pair hashes to existence predicates.
    mapping(bytes32 => bool) private _pairExists;

    /* ========== CONSTRUCTOR ========== */

    /**
     * @dev Constructs a new TWAP oracle with a VADER pool and update period.
     * @param vaderPool The VADER pool address.
     * @param updatePeriod The required period of time between each oracle update.
     */
    constructor(address vaderPool, uint256 updatePeriod) Ownable() {
        _vaderPool = IVaderPoolV2(vaderPool);
        _updatePeriod = updatePeriod;
    }

    /* ========== MODIFIERS ========== */

    modifier initialized() {
        require(
            VADER != address(0) && USDV != address(0),
            ""TwapOracle::initialized: not initialized""
        );
        _;
    }

    /* ========== VIEWS ========== */

    /**
     * @dev Checks if a pair exists for the supplied {token0} and {token1} addresses.
     * @param token0 The primary token address, either VADER or USDV.
     * @param token1 The asset token address, paired to either VADER or USDV.
     */
    function pairExists(address token0, address token1)
        public
        view
        returns (bool)
    {
        bytes32 pairHash0 = keccak256(abi.encodePacked(token0, token1));
        bytes32 pairHash1 = keccak256(abi.encodePacked(token1, token0));
        return _pairExists[pairHash0] || _pairExists[pairHash1];
    }

    /**
     * @dev Performs a consultation to retrieve the equivalent to {amountIn} for the supplied {token} address.
     * The {token} address must have a registered pairing, otherwise the transaction will revert.
     * @param token The token address to consult the equivalent {amountIn} for.
     */
    function consult(address token) public view returns (uint256 result) {
        uint256 pairCount = _pairs.length;
        uint256 sumNative = 0;
        uint256 sumUSD = 0;

        for (uint256 i = 0; i < pairCount; i++) {
            PairData memory pairData = _pairs[i];

            if (token == pairData.token0) {
                //
                // TODO - Review:
                //   Verify price1Average is amount of USDV against 1 unit of token1
                //

                sumNative += pairData.price1Average.mul(1).decode144(); // native asset amount
                if (pairData.price1Average._x != 0) {
                    require(sumNative != 0);
                }

                (
                    uint80 roundID,
                    int256 price,
                    ,
                    ,
                    uint80 answeredInRound
                ) = AggregatorV3Interface(_aggregators[pairData.token1])
                        .latestRoundData();

                require(
                    answeredInRound >= roundID,
                    ""TwapOracle::consult: stale chainlink price""
                );
                require(
                    price != 0,
                    ""TwapOracle::consult: chainlink malfunction""
                );

                sumUSD += uint256(price) * (10**10);
            }
        }
        require(sumNative != 0, ""TwapOracle::consult: Sum of native is zero"");
        result = ((sumUSD * IERC20Metadata(token).decimals()) / sumNative);
    }

    /**
     * @dev Gets the exchange rate for the Vader to USDV.
     */
    function getRate() public view returns (uint256 result) {
        uint256 tUSDInUSDV = consult(USDV);
        uint256 tUSDInVader = consult(VADER);

        result = tUSDInUSDV / tUSDInVader;
    }

    /**
     * @dev Gets the VADER amount from the supplied USDV amount.
     * @param usdvAmount The amount in USDV.
     */
    function usdvtoVader(uint256 usdvAmount) external view returns (uint256) {
        return usdvAmount * getRate();
    }

    /**
     * @dev Gets the USDV amount from the supplied VADER amount.
     * @param vaderAmount The amount in VADER.
     */
    function vaderToUsdv(uint256 vaderAmount) external view returns (uint256) {
        if (!_usdvEnabled) {
            // consult call returns true USD amount against 1 Vader and is multiplied with {vaderAmount}.
            return consult(VADER) * vaderAmount;
        }

        // usdv price is disabled so true USD value of both Vader and USDV is taken into account.
        return vaderAmount / getRate();
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    /**
     * @dev Initializes the variables for VADER and USDV.
     * @param _usdv The USDV token address.
     * @param _vader The VADER token address.
     */
    function initialize(address _usdv, address _vader) external onlyOwner {
        require(
            VADER == address(0),
            ""TwapOracle::initialize: Vader already set""
        );
        require(USDV == address(0), ""TwapOracle::initialize: USDV already set"");
        require(
            _usdv != address(0),
            ""TwapOracle::initialize: can not set to a zero address""
        );
        require(
            _vader != address(0),
            ""TwapOracle::initialize: can not set to a zero address""
        );

        VADER = _vader;
        USDV = _usdv;
    }

    /**
     * @dev Enables utilization of USDV.
     */
    function enableUSDV() external onlyOwner {
        _usdvEnabled = true;
    }

    /**
     * @dev Registers a chainlink {aggregator} for the supplied {asset} address.
     * @param asset The address of the native asset.
     * @param aggregator The address of the chainlink aggregator.
     */
    function registerAggregator(address asset, address aggregator)
        external
        onlyOwner
        initialized
    {
        require(
            asset != address(0),
            ""TwapOracle::registerAggregator: asset zero address provided""
        );
        require(
            aggregator != address(0),
            ""TwapOracle::registerAggregator: aggregator zero address provided""
        );
        require(
            _aggregators[asset] == address(0),
            ""TwapOracle::registerAggregator: aggregator already exists""
        );

        _aggregators[asset] = aggregator;
    }

    /**
     * @dev Registers either a VADER or USDV pairing in the TWAP oracle.
     * @param factory The factory address, if any.
     * @param token0 The primary token address, either VADER or USDV.
     * @param token1 The asset token address, paired to VADER or USDV.
     */
    function registerPair(
        address factory,
        address token0,
        address token1
    ) external onlyOwner initialized {
        require(
            token0 == VADER || token0 == USDV,
            ""TwapOracle::registerPair: Invalid token0 address""
        );
        require(
            token0 != token1,
            ""TwapOracle::registerPair: Same token address""
        );
        require(
            !pairExists(token0, token1),
            ""TwapOracle::registerPair: Pair exists""
        );

        address pairAddr;
        uint256 price0CumulativeLast;
        uint256 price1CumulativeLast;
        uint112 reserve0;
        uint112 reserve1;
        uint32 blockTimestampLast;

        if (token0 == VADER) {
            IUniswapV2Pair pair = IUniswapV2Pair(
                IUniswapV2Factory(factory).getPair(token0, token1)
            );
            pairAddr = address(pair);
            price0CumulativeLast = pair.price0CumulativeLast();
            price1CumulativeLast = pair.price1CumulativeLast();
            (reserve0, reserve1, blockTimestampLast) = pair.getReserves();
        } else {
            pairAddr = address(_vaderPool);
            (price0CumulativeLast, price1CumulativeLast, ) = _vaderPool
                .cumulativePrices(IERC20(token1));
            (reserve0, reserve1, blockTimestampLast) = _vaderPool.getReserves(
                IERC20(token1)
            );
        }

        require(
            reserve0 != 0 && reserve1 != 0,
            ""TwapOracle::registerPair: No reserves""
        );

        _pairExists[keccak256(abi.encodePacked(token0, token1))] = true;

        _pairs.push(
            PairData({
                pair: pairAddr,
                token0: token0,
                token1: token1,
                price0CumulativeLast: price0CumulativeLast,
                price1CumulativeLast: price1CumulativeLast,
                blockTimestampLast: blockTimestampLast,
                price0Average: FixedPoint.uq112x112({_x: 0}),
                price1Average: FixedPoint.uq112x112({_x: 0})
            })
        );
    }

    /**
     * @dev Updates the average prices for all token pairs registered in the TWAP oracle.
     */
    function update() external onlyOwner initialized {
        uint256 pairCount = _pairs.length;

        // Update all of the registered pairs in the TWAP oracle.
        for (uint256 i = 0; i < pairCount; i++) {
            PairData storage pairData = _pairs[i];

            // Get the current cumulative prices and block timestamp of the current pairing.
            (
                uint256 price0Cumulative,
                uint256 price1Cumulative,
                uint32 blockTimestamp
            ) = (pairData.token0 == VADER)
                    ? UniswapV2OracleLibrary.currentCumulativePrices(
                        pairData.pair
                    )
                    : _vaderPool.cumulativePrices(IERC20(pairData.token1));

            unchecked {
                // Ensure that at least one full period has passed since the pairing was last update.
                uint32 timeElapsed = blockTimestamp -
                    pairData.blockTimestampLast;
                require(
                    timeElapsed >= _updatePeriod,
                    ""TwapOracle::update: Period not elapsed""
                );

                // Cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed.
                pairData.price0Average = FixedPoint.uq112x112(
                    uint224(
                        (price0Cumulative - pairData.price0CumulativeLast) /
                            timeElapsed
                    )
                );
                pairData.price1Average = FixedPoint.uq112x112(
                    uint224(
                        (price1Cumulative - pairData.price1CumulativeLast) /
                            timeElapsed
                    )
                );
            }

            // Update the stored pairing data
            pairData.price0CumulativeLast = price0Cumulative;
            pairData.price1CumulativeLast = price1Cumulative;
            pairData.blockTimestampLast = blockTimestamp;
        }
    }
}",2854
RealWorld_BA_52_ProtocolConstants_RealWord_20240821095642.log,52,ProtocolConstants,13647,4837,18484,75.0,0.164975,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

abstract contract ProtocolConstants {
    /* ========== GENERAL ========== */

    // The zero address, utility
    address internal constant _ZERO_ADDRESS = address(0);

    // One year, utility
    uint256 internal constant _ONE_YEAR = 365 days;

    // Basis Points
    uint256 internal constant _MAX_BASIS_POINTS = 100_00;

    /* ========== VADER TOKEN ========== */

    // Max VADER supply
    uint256 internal constant _INITIAL_VADER_SUPPLY = 2_500_000_000 * 1 ether;

    // Allocation for VETH holders
    uint256 internal constant _VETH_ALLOCATION = 1_000_000_000 * 1 ether;

    // Team allocation vested over {VESTING_DURATION} years
    uint256 internal constant _TEAM_ALLOCATION = 250_000_000 * 1 ether;

    // Ecosystem growth fund unlocked for partnerships & USDV provision
    uint256 internal constant _ECOSYSTEM_GROWTH = 250_000_000 * 1 ether;

    // Emission Era
    uint256 internal constant _EMISSION_ERA = 24 hours;

    // Initial Emission Curve, 5
    uint256 internal constant _INITIAL_EMISSION_CURVE = 5;

    // Fee Basis Points
    uint256 internal constant _MAX_FEE_BASIS_POINTS = 1_00;

    /* ========== VESTING ========== */

    // Vesting Duration
    uint256 internal constant _VESTING_DURATION = 2 * _ONE_YEAR;

    /* ========== CONVERTER ========== */

    // Vader -> Vether Conversion Rate (1000:1)
    uint256 internal constant _VADER_VETHER_CONVERSION_RATE = 1000;

    // Burn Address
    address internal constant _BURN =
        0xdeaDDeADDEaDdeaDdEAddEADDEAdDeadDEADDEaD;

    /* ========== SWAP QUEUE ========== */

    // A minimum of 10 swaps will be executed per block
    uint256 internal constant _MIN_SWAPS_EXECUTED = 10;

    // Expressed in basis points (50%)
    uint256 internal constant _DEFAULT_SWAPS_EXECUTED = 50_00;

    // The queue size of each block is 100 units
    uint256 internal constant _QUEUE_SIZE = 100;

    /* ========== GAS QUEUE ========== */

    // Address of Chainlink Fast Gas Price Oracle
    address internal constant _FAST_GAS_ORACLE =
        0x169E633A2D1E6c10dD91238Ba11c4A708dfEF37C;

    /* ========== VADER RESERVE ========== */

    // Minimum delay between grants
    uint256 internal constant _GRANT_DELAY = 30 days;

    // Maximum grant size divisor
    uint256 internal constant _MAX_GRANT_BASIS_POINTS = 10_00;
}",625
RealWorld_BA_52_IBasePool_RealWord_20240821105759.log,52,IBasePool,9081,5178,14259,72.0,0.148965,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

interface IBasePool {
    /* ========== STRUCTS ========== */

    struct Position {
        uint256 creation;
        uint256 liquidity;
        uint256 originalNative;
        uint256 originalForeign;
    }

    /* ========== FUNCTIONS ========== */

    function swap(
        uint256 nativeAmountIn,
        uint256 foreignAmountIn,
        address to
    ) external returns (uint256);

    function swap(
        uint256 nativeAmountIn,
        uint256 foreignAmountIn,
        address to,
        bytes calldata
    ) external returns (uint256);

    function mint(address to) external returns (uint256 liquidity);

    function getReserves() external view returns (
            uint112 reserveNative,
            uint112 reserveForeign,
            uint32 blockTimestampLast
        );

    /* ========== EVENTS ========== */

    event Mint(
        address indexed sender,
        address indexed to,
        uint256 amount0,
        uint256 amount1
    ); // Adjustment -> new argument to which didnt exist
    event Burn(
        address indexed sender,
        uint256 amount0,
        uint256 amount1,
        address indexed to
    );
    event Swap(
        address indexed sender,
        uint256 amount0In,
        uint256 amount1In,
        uint256 amount0Out,
        uint256 amount1Out,
        address indexed to
    );
    event Sync(uint256 reserve0, uint256 reserve1); // Adjustment -> 112 to 256
    event PositionOpened(address indexed sender, uint256 id, uint256 liquidity);
    event PositionClosed(
        address indexed sender,
        uint256 id,
        uint256 liquidity,
        uint256 loss
    );
}",354
RealWorld_BA_52_Ownable_RealWord_20240821110911.log,52,Ownable,5579,4583,10162,80.0,0.119555,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity 0.7.6;

contract Ownable {
    event OwnerNominated(address newOwner);
    event OwnerChanged(address newOwner);

    address public owner;
    address public nominatedOwner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""not owner"");
        _;
    }

    function nominateNewOwner(address _owner) external onlyOwner {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }

    function acceptOwnership() external {
        require(msg.sender == nominatedOwner, ""not nominated"");

        owner = nominatedOwner;
        nominatedOwner = address(0);

        emit OwnerChanged(owner);
    }
}",162
RealWorld_BA_52_ILinearVesting_RealWord_20240821110751.log,52,ILinearVesting,6024,5421,11445,78.0,0.13854,"// SPDX-License-Identifier: Unlicense

pragma solidity =0.8.9;

interface ILinearVesting {
    /* ========== STRUCTS ========== */

    // Struct of a vesting member, tight-packed to 256-bits
    struct Vester {
        uint192 amount;
        uint64 lastClaim;
        uint128 start;
        uint128 end;
    }

    /* ========== FUNCTIONS ========== */

    function getClaim() external view returns (uint256 vestedAmount);

    function claim() external returns (uint256 vestedAmount);

    function claimConverted() external returns (uint256 vestedAmount);

    function begin() external;

    function vestFor(address user, uint256 amount) external;

    /* ========== EVENTS ========== */

    event VestingInitialized(uint256 duration);

    event Vested(address indexed from, uint256 amount);
}",167
RealWorld_BA_53_ZeroExOperator_RealWord_20240821122523.log,53,ZeroExOperator,13403,5598,19001,86.0,0.178975,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/Create2.sol"";
import ""./IZeroExOperator.sol"";
import ""./ZeroExStorage.sol"";
import ""../../libraries/ExchangeHelpers.sol"";
import ""../../interfaces/IOperatorSelector.sol"";

/// @title The 0x protocol operator to execute swap with the aggregator
contract ZeroExOperator is IZeroExOperator, IOperatorSelector {
    /// @dev Deploy with the storage contract
    constructor(address swapTarget) {
        address zeroxExStorage = Create2.deploy(0, bytes32(""nested.zeroex.operator""), type(ZeroExStorage).creationCode);
        ZeroExStorage(zeroxExStorage).updatesSwapTarget(swapTarget);
        ZeroExStorage(zeroxExStorage).transferOwnership(msg.sender);
    }

    /// @inheritdoc IZeroExOperator
    function commitAndRevert(
        address self,
        IERC20 sellToken,
        IERC20 buyToken,
        bytes4 swapSelector,
        bytes calldata swapCallData
    ) external payable override returns (uint256[] memory amounts, address[] memory tokens) {
        amounts = new uint256[](2);
        tokens = new address[](2);
        uint256 buyBalanceBeforePurchase = buyToken.balanceOf(address(this));
        uint256 sellBalanceBeforePurchase = sellToken.balanceOf(address(this));

        bool success = ExchangeHelpers.fillQuote(
            sellToken,
            ZeroExStorage(storageAddress(self)).swapTarget(),
            bytes.concat(swapSelector, swapCallData[32:])
        );
        require(success, ""ZeroExOperator::commitAndRevert: 0x swap failed"");

        uint256 amountBought = buyToken.balanceOf(address(this)) - buyBalanceBeforePurchase;
        uint256 amountSold = sellBalanceBeforePurchase - sellToken.balanceOf(address(this));
        assert(amountBought > 0);
        assert(amountSold > 0);

        // Output amounts
        amounts[0] = amountBought;
        amounts[1] = amountSold;
        // Output token
        tokens[0] = address(buyToken);
        tokens[1] = address(sellToken);
    }

    /// @notice Return the operator storage address
    /// @param own the operator address to build the storage address in delegatecall
    function storageAddress(address own) public pure returns (address) {
        bytes32 _data = keccak256(
            abi.encodePacked(
                bytes1(0xff),
                own,
                bytes32(""nested.zeroex.operator""),
                keccak256(type(ZeroExStorage).creationCode)
            )
        );
        return address(uint160(uint256(_data)));
    }

    /// @inheritdoc IOperatorSelector
    function getCommitSelector() external pure override returns (bytes4) {
        return this.commitAndRevert.selector;
    }

    /// @inheritdoc IOperatorSelector
    function getRevertSelector() external pure override returns (bytes4) {
        return this.commitAndRevert.selector;
    }
}",649
RealWorld_BA_53_INestedFactory_RealWord_20240821123146.log,53,INestedFactory,25825,5406,31231,88.0,0.237245,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../NestedReserve.sol"";
import ""../FeeSplitter.sol"";

/// @title NestedFactory interface
interface INestedFactory {
    /// @dev Emitted when the feeSplitter is updated
    /// @param feeSplitter The new feeSplitter address
    event FeeSplitterUpdated(address feeSplitter);

    /// @dev Emitted when the reserve is updated
    /// @param reserve The new reserve address
    event ReserveUpdated(address reserve);

    /// @dev Emitted when a NFT (portfolio) is created
    /// @param nftId The NFT token Id
    /// @param originalNftId If replicated, the original NFT token Id
    event NftCreated(uint256 indexed nftId, uint256 originalNftId);

    /// @dev Emitted when a NFT (portfolio) is updated
    /// @param nftId The NFT token Id
    event NftUpdated(uint256 indexed nftId);

    /// @dev Emitted when a NFT (portfolio) is burned
    /// @param nftId The burned NFT token iI
    event NftBurned(uint256 indexed nftId);

    /// @dev Represent an order made to the factory when creating/editing an NFT
    /// @param operator The bytes32 name of the Operator
    /// @param token The expected token address in output/input
    /// @param callData The operator parameters (delegatecall)
    /// @param commit If the order is a commit (false if it's a revert)
    struct Order {
        bytes32 operator;
        address token;
        bytes callData;
        bool commit;
    }

    /// @notice Add an operator (name) for building cache
    /// @param operator The operator name to add
    function addOperator(bytes32 operator) external;

    /// @notice Remove an operator (name) for building cache
    /// @param operator The operator name to remove
    function removeOperator(bytes32 operator) external;

    /// @notice Sets the reserve where the funds are stored
    /// @param _reserve the address of the new reserve
    function setReserve(NestedReserve _reserve) external;

    /// @notice Sets the address receiving the fees
    /// @param _feeSplitter The address of the receiver
    function setFeeSplitter(FeeSplitter _feeSplitter) external;

    /// @notice Create a portfolio and store the underlying assets from the positions
    /// @param _originalTokenId The id of the NFT replicated, 0 if not replicating
    /// @param _sellToken Token used to make the orders
    /// @param _sellTokenAmount Amount of sell tokens to use
    /// @param _orders Orders calldata
    function create(
        uint256 _originalTokenId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external payable;

    /// @notice Add or increase one position (or more) and update the NFT
    /// @param _nftId The id of the NFT to update
    /// @param _sellToken Token used to make the orders
    /// @param _sellTokenAmount Amount of sell tokens to use
    /// @param _orders Orders calldata
    function addTokens(
        uint256 _nftId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external payable;

    /// @notice Use the output token of an existing position from
    /// the NFT for one or more positions.
    /// @param _nftId The id of the NFT to update
    /// @param _sellToken Token used to make the orders
    /// @param _sellTokenAmount Amount of sell tokens to use
    /// @param _orders Orders calldata
    function swapTokenForTokens(
        uint256 _nftId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external;

    /// @notice Use one or more existing tokens from the NFT for one position.
    /// @param _nftId The id of the NFT to update
    /// @param _buyToken The output token
    /// @param _sellTokensAmount The amount of sell tokens to use
    /// @param _orders Orders calldata
    function sellTokensToNft(
        uint256 _nftId,
        IERC20 _buyToken,
        uint256[] memory _sellTokensAmount,
        Order[] calldata _orders
    ) external;

    /// @notice Liquidate one or more holdings and transfer the sale amount to the user
    /// @param _nftId The id of the NFT to update
    /// @param _buyToken The output token
    /// @param _sellTokensAmount The amount of sell tokens to use
    /// @param _orders Orders calldata
    function sellTokensToWallet(
        uint256 _nftId,
        IERC20 _buyToken,
        uint256[] memory _sellTokensAmount,
        Order[] calldata _orders
    ) external;

    /// @notice Burn NFT and Sell all tokens for a specific ERC20 then send it back to the user
    /// @dev Will unwrap WETH output to ETH
    /// @param _nftId The id of the NFT to destroy
    /// @param _buyToken The output token
    /// @param _orders Orders calldata
    function destroy(
        uint256 _nftId,
        IERC20 _buyToken,
        Order[] calldata _orders
    ) external;

    /// @notice Withdraw a token from the reserve and transfer it to the owner without exchanging it
    /// @param _nftId NFT token ID
    /// @param _tokenIndex Index in array of tokens for this NFT and holding.
    function withdraw(uint256 _nftId, uint256 _tokenIndex) external;

    /// @notice Increase the lock timestamp of an NFT record.
    /// @param _nftId The NFT id to get the record
    /// @param _timestamp The new timestamp.
    function increaseLockTimestamp(uint256 _nftId, uint256 _timestamp) external;

    /// @notice The Factory is not storing funds, but some users can make
    /// bad manipulations and send tokens to the contract.
    /// In response to that, the owner can retrieve the factory balance of a given token
    /// to later return users funds.
    /// @param _token The token to retrieve.
    function unlockTokens(IERC20 _token) external;
}",1450
RealWorld_BA_53_IOperatorSelector_RealWord_20240821123438.log,53,IOperatorSelector,4385,3644,8029,58.0,0.094805,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

/// @title Interface for operator selectors
interface IOperatorSelector {
    /// @notice Return the operator commit function selector
    /// @return Function selector
    function getCommitSelector() external pure returns (bytes4);

    /// @notice Return the operator revert function selector
    /// @return Function selector
    function getRevertSelector() external pure returns (bytes4);
}",100
RealWorld_BA_53_OwnableOperator_RealWord_20240821122203.log,53,OwnableOperator,2443,2509,4952,49.0,0.062395,,0
RealWorld_BA_53_DummyRouter_RealWord_20240821122044.log,53,DummyRouter,12587,5673,18260,76.0,0.176395,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.3;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""../NestedFactory.sol"";
import ""../libraries/ExchangeHelpers.sol"";
import ""../interfaces/INestedFactory.sol"";

contract DummyRouter is IERC721Receiver {
    address payable public factory;
    INestedFactory.Order[] attackOrders;
    IWETH public weth;

    receive() external payable {}

    // send ETH, get the token
    function dummyswapETH(IERC20 token) public payable {
        // send 1ETH, you get 10 dummy tokens
        token.transfer(msg.sender, msg.value * 10);
    }

    // send a token, get the token
    function dummyswapToken(
        IERC20 _inputToken,
        IERC20 _outputToken,
        uint256 _amount
    ) external {
        IERC20(_inputToken).transferFrom(msg.sender, address(this), _amount);
        _outputToken.transfer(msg.sender, _amount);
    }

    function reentrancyAttackForDestroy(uint256 nftId) external {
        NestedFactory(factory).destroy(nftId, IERC20(address(weth)), attackOrders);
    }

    function prepareAttack(
        address payable _factory,
        IWETH _weth,
        INestedFactory.Order[] calldata _tokenOrders,
        INestedFactory.Order[] calldata _attackOrders
    ) external payable {
        factory = _factory;
        weth = _weth;
        uint256 amountIn = msg.value;
        weth.deposit{ value: amountIn }();
        weth.approve(_factory, amountIn);
        attackOrders.push(_attackOrders[0]);
        attackOrders.push(_attackOrders[1]);
        NestedFactory(_factory).create(0, IERC20(address(_weth)), amountIn - amountIn / 98, _tokenOrders);
    }

    function setMaxAllowance(IERC20 _token, address _spender) external {
        ExchangeHelpers.setMaxAllowance(_token, _spender);
    }

    function setAllowance(
        IERC20 _token,
        address _spender,
        uint256 _amount
    ) external {
        _token.approve(_spender, _amount);
    }

    function onERC721Received(
        address _operator,
        address _from,
        uint256 _tokenId,
        bytes calldata _data
    ) external pure override returns (bytes4) {
        _operator;
        _from;
        _tokenId;
        _data;
        return 0x150b7a02;
    }
}",568
RealWorld_BA_53_NestedRecords_RealWord_20240821120659.log,53,NestedRecords,37928,5034,42962,86.0,0.29032,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/access/Ownable.sol"";

/// @title Tracks data for underlying assets of NestedNFTs
contract NestedRecords is Ownable {
    /// @dev Emitted when a new factory is added to the supported list
    /// @param newFactory The new added factory
    event FactoryAdded(address newFactory);

    /// @dev Emitted when maxHoldingsCount is updated
    /// @param maxHoldingsCount The new value
    event MaxHoldingsChanges(uint256 maxHoldingsCount);

    /// @dev Emitted when the lock timestamp of an NFT is increased
    /// @param nftId The NFT ID
    /// @param timestamp The new lock timestamp of the portfolio
    event LockTimestampIncreased(uint256 nftId, uint256 timestamp);

    /// @dev Info about assets stored in reserves
    struct Holding {
        address token;
        uint256 amount;
        bool isActive;
    }

    /// @dev Store user asset informations
    struct NftRecord {
        mapping(address => Holding) holdings;
        address[] tokens;
        address reserve;
        uint256 lockTimestamp;
    }

    /// @dev List of supported factories.
    /// This information is used across the protocol
    mapping(address => bool) public supportedFactories;

    /// @dev stores for each NFT ID an asset record
    mapping(uint256 => NftRecord) public records;

    /// @dev The maximum number of holdings for an NFT record
    uint256 public maxHoldingsCount;

    /// @dev Reverts the transaction if the caller is not the factory
    modifier onlyFactory() {
        require(supportedFactories[_msgSender()], ""NestedRecords: FORBIDDEN"");
        _;
    }

    constructor(uint256 _maxHoldingsCount) {
        maxHoldingsCount = _maxHoldingsCount;
    }

    /// @notice Add a record for NFT data into our mappings
    /// @param _nftId The id of the NFT
    /// @param _token The address of the token
    /// @param _amount The amount of tokens bought
    /// @param _reserve The address of the reserve
    function createRecord(
        uint256 _nftId,
        address _token,
        uint256 _amount,
        address _reserve
    ) public onlyFactory {
        require(records[_nftId].tokens.length < maxHoldingsCount, ""NestedRecords: TOO_MANY_ORDERS"");
        require(
            _reserve != address(0) && (_reserve == records[_nftId].reserve || records[_nftId].reserve == address(0)),
            ""NestedRecords: INVALID_RESERVE""
        );

        Holding memory holding = records[_nftId].holdings[_token];
        require(!holding.isActive, ""NestedRecords: HOLDING_EXISTS"");

        records[_nftId].holdings[_token] = Holding({ token: _token, amount: _amount, isActive: true });
        records[_nftId].tokens.push(_token);
        records[_nftId].reserve = _reserve;
    }

    /// @notice Update the amount for a specific holding and delete
    /// the holding if the amount is zero.
    /// @param _nftId The id of the NFT
    /// @param _token The token/holding address
    /// @param _amount Updated amount for this asset
    function updateHoldingAmount(
        uint256 _nftId,
        address _token,
        uint256 _amount
    ) public onlyFactory {
        if (_amount == 0) {
            uint256 tokenIndex = 0;
            address[] memory tokens = getAssetTokens(_nftId);
            while (tokenIndex < tokens.length) {
                if (tokens[tokenIndex] == _token) {
                    deleteAsset(_nftId, tokenIndex);
                    break;
                }
                tokenIndex++;
            }
        } else {
            records[_nftId].holdings[_token].amount = _amount;
        }
    }

    /// @notice Get content of assetTokens mapping
    /// @param _nftId The id of the NFT>
    function getAssetTokens(uint256 _nftId) public view returns (address[] memory) {
        return records[_nftId].tokens;
    }

    /// @notice Delete a holding item in holding mapping. Does not remove token in NftRecord.tokens array
    /// @param _nftId NFT's identifier
    /// @param _token Token address for holding to remove
    function freeHolding(uint256 _nftId, address _token) public onlyFactory {
        delete records[_nftId].holdings[_token];
    }

    /// @notice Helper function that creates a record or add the holding if record already exists
    /// @param _nftId The NFT's identifier
    /// @param _token The token/holding address
    /// @param _amount Amount to add for this asset
    /// @param _reserve Reserve address
    function store(
        uint256 _nftId,
        address _token,
        uint256 _amount,
        address _reserve
    ) external onlyFactory {
        Holding memory holding = records[_nftId].holdings[_token];
        if (holding.isActive) {
            require(records[_nftId].reserve == _reserve, ""NestedRecords: RESERVE_MISMATCH"");
            updateHoldingAmount(_nftId, _token, holding.amount + _amount);
            return;
        }
        createRecord(_nftId, _token, _amount, _reserve);
    }

    /// @notice Get holding object for this NFT ID
    /// @param _nftId The id of the NFT
    /// @param _token The address of the token
    function getAssetHolding(uint256 _nftId, address _token) external view returns (Holding memory) {
        return records[_nftId].holdings[_token];
    }

    /// @notice Sets the factory for Nested records
    /// @param _factory The address of the new factory
    function setFactory(address _factory) external onlyOwner {
        require(_factory != address(0), ""NestedRecords: INVALID_ADDRESS"");
        supportedFactories[_factory] = true;
        emit FactoryAdded(_factory);
    }

    /// @notice The factory can update the lock timestamp of a NFT record
    /// The new timestamp must be greater than the records lockTimestamp
    //  if block.timestamp > actual lock timestamp
    /// @param _nftId The NFT id to get the record
    /// @param _timestamp The new timestamp
    function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external onlyFactory {
        require(
            _timestamp > records[_nftId].lockTimestamp,
            ""NestedRecords::increaseLockTimestamp: Can't decrease timestamp""
        );
        records[_nftId].lockTimestamp = _timestamp;
        emit LockTimestampIncreased(_nftId, _timestamp);
    }

    /// @notice Sets the maximum number of holdings for an NFT record
    /// @param _maxHoldingsCount The new maximum number of holdings
    function setMaxHoldingsCount(uint256 _maxHoldingsCount) external onlyOwner {
        require(_maxHoldingsCount > 0, ""NestedRecords: INVALID_MAX_HOLDINGS"");
        maxHoldingsCount = _maxHoldingsCount;
        emit MaxHoldingsChanges(maxHoldingsCount);
    }

    /// @notice Get reserve the assets are stored in
    /// @param _nftId The NFT ID
    /// @return The reserve address these assets are stored in
    function getAssetReserve(uint256 _nftId) external view returns (address) {
        return records[_nftId].reserve;
    }

    /// @notice Get how many tokens are in a portfolio/NFT
    /// @param _nftId NFT ID to examine
    /// @return The array length
    function getAssetTokensLength(uint256 _nftId) external view returns (uint256) {
        return records[_nftId].tokens.length;
    }

    /// @notice Get the lock timestamp of a portfolio/NFT
    /// @param _nftId The NFT ID
    /// @return The lock timestamp from the NftRecord
    function getLockTimestamp(uint256 _nftId) external view returns (uint256) {
        return records[_nftId].lockTimestamp;
    }

    /// @notice Set the reserve where assets are stored
    /// @param _nftId The NFT ID to update
    /// @param _nextReserve Address for the new reserve
    function setReserve(uint256 _nftId, address _nextReserve) external onlyFactory {
        records[_nftId].reserve = _nextReserve;
    }

    /// @notice Delete from mapping assetTokens
    /// @param _nftId The id of the NFT
    function removeNFT(uint256 _nftId) external onlyFactory {
        delete records[_nftId];
    }

    /// @notice Fully delete a holding record for an NFT
    /// @param _nftId The id of the NFT
    /// @param _tokenIndex The token index in holdings array
    function deleteAsset(uint256 _nftId, uint256 _tokenIndex) public onlyFactory {
        address[] storage tokens = records[_nftId].tokens;
        address token = tokens[_tokenIndex];
        Holding memory holding = records[_nftId].holdings[token];

        require(holding.isActive, ""NestedRecords: HOLDING_INACTIVE"");

        delete records[_nftId].holdings[token];
        freeToken(_nftId, _tokenIndex);
    }

    /// @dev Remove a token from the array of tokens in assetTokens. Does not remove holding record
    /// @param _nftId ID for the NFT
    /// @param _tokenIndex Token index to delete in the array of tokens
    function freeToken(uint256 _nftId, uint256 _tokenIndex) private {
        address[] storage tokens = records[_nftId].tokens;
        tokens[_tokenIndex] = tokens[tokens.length - 1];
        tokens.pop();
    }
}",2187
RealWorld_BA_53_IFlatOperator_RealWord_20240821122254.log,53,IFlatOperator,5948,3981,9929,74.0,0.10936,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/// @title FlatOperator Operator Interface
interface IFlatOperator {
    /// @notice Execute the flat operator... it does nothing !
    /// @param self The operator address (for delegatecall context resolution).
    /// This parameter is useless for this operator (no storage), but cant be removed.
    /// @param token The token address
    /// @param amount The amount
    /// @return amounts Array of output amounts
    /// @return tokens Array of output tokens
    function commitAndRevert(
        address self,
        address token,
        uint256 amount
    ) external payable returns (uint256[] memory amounts, address[] memory tokens);
}",174
RealWorld_BA_53_MockSmartChef_RealWord_20240821121833.log,53,MockSmartChef,2495,2449,4944,52.0,0.061455,,0
RealWorld_BA_53_NestedAsset_RealWord_20240821120524.log,53,NestedAsset,26754,5858,32612,93.0,0.25093,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import ""@openzeppelin/contracts/utils/Counters.sol"";

/// @title Collection of NestedNFTs used to represent ownership of real assets stored in NestedReserves
/// @dev Only NestedFactory contracts are allowed to call functions that write to storage
contract NestedAsset is ERC721Enumerable, Ownable {
    using Counters for Counters.Counter;

    event FactoryAdded(address newFactory);
    event FactoryRemoved(address oldFactory);

    Counters.Counter private _tokenIds;

    /// @dev Supported factories to interact with
    mapping(address => bool) public supportedFactories;

    /// @dev Stores the URI of each asset
    mapping(uint256 => string) private _tokenURIs;

    /// @dev Stores the original asset of each asset
    mapping(uint256 => uint256) public originalAsset;

    /// @dev Stores owners of burnt assets
    mapping(uint256 => address) public lastOwnerBeforeBurn;

    constructor() ERC721(""NestedNFT"", ""NESTED"") {}

    /// @dev Reverts the transaction if the caller is not the factory
    modifier onlyFactory() {
        require(supportedFactories[_msgSender()], ""NestedAsset: FORBIDDEN_NOT_FACTORY"");
        _;
    }

    /// @dev Reverts the transaction if the address is not the token owner
    modifier onlyTokenOwner(address _address, uint256 _tokenId) {
        require(_address == ownerOf(_tokenId), ""NestedAsset: FORBIDDEN_NOT_OWNER"");
        _;
    }

    /// @notice Get the Uniform Resource Identifier (URI) for `tokenId` token.
    /// @param _tokenId The id of the NestedAsset
    /// @return The token Uniform Resource Identifier (URI)
    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {
        require(_exists(_tokenId), ""URI query for nonexistent token"");
        return _tokenURIs[_tokenId];
    }

    /// @notice Returns the owner of the original token if the token was replicated
    /// If the original asset was burnt, the last owner before burn is returned
    /// @param _tokenId The asset for which we want to know the original owner
    /// @return The owner of the original asset
    function originalOwner(uint256 _tokenId) public view returns (address) {
        uint256 originalAssetId = originalAsset[_tokenId];

        if (originalAssetId != 0) {
            return _exists(originalAssetId) ? ownerOf(originalAssetId) : lastOwnerBeforeBurn[originalAssetId];
        }
        return address(0);
    }

    /// @notice Mints an ERC721 token for the user and stores the original asset used to create the new asset if any
    /// @param _owner The account address that signed the transaction
    /// @param _replicatedTokenId The token id of the replicated asset, 0 if no replication
    /// @return The minted token's id
    function mint(address _owner, uint256 _replicatedTokenId) public onlyFactory returns (uint256) {
        _tokenIds.increment();

        uint256 tokenId = _tokenIds.current();
        _safeMint(_owner, tokenId);

        // Stores the first asset of the replication chain as the original
        if (_replicatedTokenId == 0) {
            return tokenId;
        }

        require(
            _exists(_replicatedTokenId) && tokenId != _replicatedTokenId,
            ""NestedAsset::mint: Invalid replicated token ID""
        );

        uint256 originalTokenId = originalAsset[_replicatedTokenId];
        originalAsset[tokenId] = originalTokenId != 0 ? originalTokenId : _replicatedTokenId;

        return tokenId;
    }

    /// @notice Mints an ERC721 token and sets the tokenUri
    /// @param _owner The account address that signed the transaction
    /// @param _metadataURI he metadata URI string
    /// @param _replicatedTokenId The token id of the replicated asset, 0 if no replication
    /// @return The minted token's id
    function mintWithMetadata(
        address _owner,
        string memory _metadataURI,
        uint256 _replicatedTokenId
    ) external onlyFactory returns (uint256) {
        uint256 tokenId = mint(_owner, _replicatedTokenId);
        _setTokenURI(tokenId, _metadataURI);
        return tokenId;
    }

    /// @notice Backfills the token URI if it had never set
    /// @param _tokenId The id of the NestedAsset
    /// @param _owner The id of the NestedAsset
    /// @param _metadataURI The metadata URI string
    function backfillTokenURI(
        uint256 _tokenId,
        address _owner,
        string memory _metadataURI
    ) external onlyFactory onlyTokenOwner(_owner, _tokenId) {
        require(bytes(tokenURI(_tokenId)).length == 0, ""NestedAsset: TOKEN_URI_IMMUTABLE"");
        _setTokenURI(_tokenId, _metadataURI);
    }

    /// @notice Burns an ERC721 token
    /// @param _owner The account address that signed the transaction
    /// @param _tokenId The id of the NestedAsset
    function burn(address _owner, uint256 _tokenId) external onlyFactory onlyTokenOwner(_owner, _tokenId) {
        lastOwnerBeforeBurn[_tokenId] = _owner;
        _burn(_tokenId);

        if (bytes(_tokenURIs[_tokenId]).length != 0) {
            delete _tokenURIs[_tokenId];
        }
    }

    /// @notice Sets the factory for Nested assets
    /// @param _factory the address of the new factory
    function setFactory(address _factory) external onlyOwner {
        require(_factory != address(0), ""NestedAsset: INVALID_ADDRESS"");
        supportedFactories[_factory] = true;
        emit FactoryAdded(_factory);
    }

    /// @notice Remove a supported factory from NestedAssets
    /// @param _factory The address of the factory to remove
    function removeFactory(address _factory) external onlyOwner {
        require(supportedFactories[_factory] == true, ""NestedAsset: ALREADY_NOT_SUPPORTED"");
        supportedFactories[_factory] = false;
        emit FactoryRemoved(_factory);
    }

    /// @dev Sets the Uniform Resource Identifier (URI) for `tokenId` token.
    /// @param _tokenId The id of the NestedAsset
    /// @param _metadataURI The metadata URI string
    function _setTokenURI(uint256 _tokenId, string memory _metadataURI) internal {
        _tokenURIs[_tokenId] = _metadataURI;
    }
}",1438
RealWorld_BA_53_NestedFactory_RealWord_20240821120329.log,53,NestedFactory,88998,6007,95005,113.0,0.56513,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/Multicall.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""./libraries/ExchangeHelpers.sol"";
import ""./libraries/OperatorHelpers.sol"";
import ""./interfaces/external/IWETH.sol"";
import ""./interfaces/INestedFactory.sol"";
import ""./FeeSplitter.sol"";
import ""./MixinOperatorResolver.sol"";
import ""./NestedReserve.sol"";
import ""./NestedAsset.sol"";
import ""./NestedRecords.sol"";

/// @title Creates, updates and destroys NestedAssets.
/// @notice Responsible for the business logic of the protocol and interaction with operators
contract NestedFactory is INestedFactory, ReentrancyGuard, Ownable, MixinOperatorResolver, Multicall {
    using SafeERC20 for IERC20;
    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    /// @dev Supported operators by the factory contract
    bytes32[] private operators;

    /// @dev Current feeSplitter contract/address
    FeeSplitter public feeSplitter;

    /// @dev Current reserve contract/address
    NestedReserve public reserve;

    NestedAsset public immutable nestedAsset;
    IWETH public immutable weth;
    NestedRecords public immutable nestedRecords;

    constructor(
        NestedAsset _nestedAsset,
        NestedRecords _nestedRecords,
        FeeSplitter _feeSplitter,
        IWETH _weth,
        address _operatorResolver
    ) MixinOperatorResolver(_operatorResolver) {
        nestedAsset = _nestedAsset;
        nestedRecords = _nestedRecords;
        feeSplitter = _feeSplitter;
        weth = _weth;
    }

    /// @dev Reverts the transaction if the caller is not the token owner
    /// @param _nftId The NFT Id
    modifier onlyTokenOwner(uint256 _nftId) {
        require(nestedAsset.ownerOf(_nftId) == _msgSender(), ""NestedFactory: Not the token owner"");
        _;
    }

    /// @dev Reverts the transaction if the nft is locked (hold by design).
    /// The block.timestamp must be greater than NFT record lock timestamp
    /// @param _nftId The NFT Id
    modifier isUnlocked(uint256 _nftId) {
        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), ""NestedFactory: The NFT is currently locked"");
        _;
    }

    /// @dev Receive function
    receive() external payable {}

    /// @notice Get the required operator addresses
    function resolverAddressesRequired() public view override returns (bytes32[] memory addresses) {
        return operators;
    }

    /// @inheritdoc INestedFactory
    function addOperator(bytes32 operator) external override onlyOwner {
        operators.push(operator);
    }

    /// @inheritdoc INestedFactory
    function removeOperator(bytes32 operator) external override onlyOwner {
        uint256 i = 0;
        while (operators[i] != operator) {
            i++;
        }
        require(i > 0, ""NestedFactory::removeOperator: Cant remove non-existent operator"");
        delete operators[i];
    }

    /// @inheritdoc INestedFactory
    function setReserve(NestedReserve _reserve) external override onlyOwner {
        require(address(reserve) == address(0), ""NestedFactory::setReserve: Reserve is immutable"");
        reserve = _reserve;
        emit ReserveUpdated(address(_reserve));
    }

    /// @inheritdoc INestedFactory
    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {
        require(address(_feeSplitter) != address(0), ""NestedFactory::setFeeSplitter: Invalid feeSplitter address"");
        feeSplitter = _feeSplitter;
        emit FeeSplitterUpdated(address(_feeSplitter));
    }

    /// @inheritdoc INestedFactory
    function create(
        uint256 _originalTokenId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external payable override nonReentrant {
        require(_orders.length > 0, ""NestedFactory::create: Missing orders"");

        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);
        (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _sellToken, _sellTokenAmount, _orders, true, false);

        _transferFeeWithRoyalty(fees, tokenSold, nftId);
        emit NftCreated(nftId, _originalTokenId);
    }

    /// @inheritdoc INestedFactory
    function addTokens(
        uint256 _nftId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external payable override nonReentrant onlyTokenOwner(_nftId) {
        require(_orders.length > 0, ""NestedFactory::addTokens: Missing orders"");

        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, false);
        _transferFeeWithRoyalty(fees, tokenSold, _nftId);
        emit NftUpdated(_nftId);
    }

    /// @inheritdoc INestedFactory
    function swapTokenForTokens(
        uint256 _nftId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        require(_orders.length > 0, ""NestedFactory::swapTokenForTokens: Missing orders"");
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::swapTokenForTokens: Assets in different reserve""
        );

        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, true);
        _transferFeeWithRoyalty(fees, tokenSold, _nftId);

        emit NftUpdated(_nftId);
    }

    /// @inheritdoc INestedFactory
    function sellTokensToNft(
        uint256 _nftId,
        IERC20 _buyToken,
        uint256[] memory _sellTokensAmount,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        require(_orders.length > 0, ""NestedFactory::sellTokensToNft: Missing orders"");
        require(_sellTokensAmount.length == _orders.length, ""NestedFactory::sellTokensToNft: Input lengths must match"");
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::sellTokensToNft: Assets in different reserve""
        );

        (uint256 feesAmount, ) = _submitOutOrders(_nftId, _buyToken, _sellTokensAmount, _orders, true, true);
        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);

        emit NftUpdated(_nftId);
    }

    /// @inheritdoc INestedFactory
    function sellTokensToWallet(
        uint256 _nftId,
        IERC20 _buyToken,
        uint256[] memory _sellTokensAmount,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        require(_orders.length > 0, ""NestedFactory::sellTokensToWallet: Missing orders"");
        require(
            _sellTokensAmount.length == _orders.length,
            ""NestedFactory::sellTokensToWallet: Input lengths must match""
        );
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::sellTokensToWallet: Assets in different reserve""
        );

        (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(
            _nftId,
            _buyToken,
            _sellTokensAmount,
            _orders,
            false,
            true
        );
        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);
        _safeTransferAndUnwrap(_buyToken, amountBought - feesAmount, _msgSender());

        emit NftUpdated(_nftId);
    }

    /// @inheritdoc INestedFactory
    function destroy(
        uint256 _nftId,
        IERC20 _buyToken,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);
        require(_orders.length > 0, ""NestedFactory::destroy: Missing orders"");
        require(tokens.length == _orders.length, ""NestedFactory::destroy: Missing sell args"");
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::destroy: Assets in different reserve""
        );

        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));

        for (uint256 i = 0; i < tokens.length; i++) {
            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, tokens[i]);
            reserve.withdraw(IERC20(holding.token), holding.amount);

            _safeSubmitOrder(tokens[i], address(_buyToken), holding.amount, _nftId, _orders[i]);
            nestedRecords.freeHolding(_nftId, tokens[i]);
        }

        // Amount calculation to send fees and tokens
        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;
        uint256 amountFees = _calculateFees(_msgSender(), amountBought);
        amountBought = amountBought - amountFees;

        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);
        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());

        // Burn NFT
        nestedRecords.removeNFT(_nftId);
        nestedAsset.burn(_msgSender(), _nftId);
        emit NftBurned(_nftId);
    }

    /// @inheritdoc INestedFactory
    function withdraw(uint256 _nftId, uint256 _tokenIndex)
        external
        override
        nonReentrant
        onlyTokenOwner(_nftId)
        isUnlocked(_nftId)
    {
        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);
        require(assetTokensLength > _tokenIndex, ""NestedFactory::withdraw: Invalid token index"");
        // Use destroy instead if NFT has a single holding
        require(assetTokensLength > 1, ""NestedFactory::withdraw: Can't withdraw the last asset"");

        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(
            _nftId,
            nestedRecords.getAssetTokens(_nftId)[_tokenIndex]
        );
        reserve.withdraw(IERC20(holding.token), holding.amount);
        _safeTransferWithFees(IERC20(holding.token), holding.amount, _msgSender(), _nftId);

        nestedRecords.deleteAsset(_nftId, _tokenIndex);

        emit NftUpdated(_nftId);
    }

    /// @inheritdoc INestedFactory
    function increaseLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {
        nestedRecords.updateLockTimestamp(_nftId, _timestamp);
    }

    /// @inheritdoc INestedFactory
    function unlockTokens(IERC20 _token) external override onlyOwner {
        _token.transfer(owner(), _token.balanceOf(address(this)));
    }

    /// @dev For every orders, call the operator with the calldata
    /// to submit buy orders (where the input is one asset).
    /// @param _nftId The id of the NFT impacted by the orders
    /// @param _inputToken Token used to make the orders
    /// @param _inputTokenAmount Amount of input tokens to use
    /// @param _orders Orders calldata
    /// @param _reserved True if the output is store in the reserve/records, false if not.
    /// @param _fromReserve True if the input tokens are from the reserve
    /// @return feesAmount The total amount of fees
    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)
    function _submitInOrders(
        uint256 _nftId,
        IERC20 _inputToken,
        uint256 _inputTokenAmount,
        Order[] calldata _orders,
        bool _reserved,
        bool _fromReserve
    ) private returns (uint256 feesAmount, IERC20 tokenSold) {
        _inputToken = _transferInputTokens(_nftId, _inputToken, _inputTokenAmount, _fromReserve);
        uint256 amountSpent;
        for (uint256 i = 0; i < _orders.length; i++) {
            amountSpent += _submitOrder(address(_inputToken), _orders[i].token, _nftId, _orders[i], _reserved);
        }
        feesAmount = _calculateFees(_msgSender(), amountSpent);
        assert(amountSpent <= _inputTokenAmount - feesAmount); // overspent

        // If input is from the reserve, update the records
        if (_fromReserve) {
            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount);
        }

        _handleUnderSpending(_inputTokenAmount - feesAmount, amountSpent, _inputToken);

        tokenSold = _inputToken;
    }

    /// @dev For every orders, call the operator with the calldata
    /// to submit sell orders (where the output is one asset).
    /// @param _nftId The id of the NFT impacted by the orders
    /// @param _outputToken Token received for every orders
    /// @param _inputTokenAmounts Amounts of tokens to use (respectively with Orders)
    /// @param _orders Orders calldata
    /// @param _reserved True if the output is store in the reserve/records, false if not.
    /// @param _fromReserve True if the input tokens are from the reserve
    /// @return feesAmount The total amount of fees
    /// @return amountBought The total amount bought
    function _submitOutOrders(
        uint256 _nftId,
        IERC20 _outputToken,
        uint256[] memory _inputTokenAmounts,
        Order[] calldata _orders,
        bool _reserved,
        bool _fromReserve
    ) private returns (uint256 feesAmount, uint256 amountBought) {
        uint256 _outputTokenInitialBalance = _outputToken.balanceOf(address(this));

        for (uint256 i = 0; i < _orders.length; i++) {
            IERC20 _inputToken = _transferInputTokens(
                _nftId,
                IERC20(_orders[i].token),
                _inputTokenAmounts[i],
                _fromReserve
            );

            // Submit order and update holding of spent token
            uint256 amountSpent = _submitOrder(address(_inputToken), address(_outputToken), _nftId, _orders[i], false);
            assert(amountSpent <= _inputTokenAmounts[i]);

            if (_fromReserve) {
                _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmounts[i]);
            }

            // Under spent input amount send to fee splitter
            if (_inputTokenAmounts[i] - amountSpent > 0) {
                _transferFeeWithRoyalty(_inputTokenAmounts[i] - amountSpent, _inputToken, _nftId);
            }
        }

        amountBought = _outputToken.balanceOf(address(this)) - _outputTokenInitialBalance;
        feesAmount = _calculateFees(_msgSender(), amountBought);

        if (_reserved) {
            _transferToReserveAndStore(address(_outputToken), amountBought - feesAmount, _nftId);
        }
    }

    /// @dev Call the operator to submit the order (commit/revert) and add the output
    /// assets to the reserve (if needed).
    /// @param _inputToken Token used to make the orders
    /// @param _outputToken Expected output token
    /// @param _nftId The nftId
    /// @param _order The order calldata
    /// @param _reserved True if the output is store in the reserve/records, false if not.
    function _submitOrder(
        address _inputToken,
        address _outputToken,
        uint256 _nftId,
        Order calldata _order,
        bool _reserved
    ) private returns (uint256 amountSpent) {
        address operator = requireAndGetAddress(_order.operator);
        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);
        require(success, ""NestedFactory::_submitOrder: Operator call failed"");

        (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(
            data,
            _inputToken,
            _outputToken
        );

        if (_reserved) {
            _transferToReserveAndStore(_outputToken, amounts[0], _nftId);
        }
        amountSpent = amounts[1];
    }

    /// @dev Call the operator to submit the order (commit/revert) but dont stop if
    /// the call to the operator fail. It will send the input token back to the msg.sender.
    /// Note : The _reserved Boolean has been removed (compare to _submitOrder) since it was
    ///        useless for the only use case (destroy).
    /// @param _inputToken Token used to make the orders
    /// @param _outputToken Expected output token
    /// @param _amountToSpend The input amount available (to spend)
    /// @param _nftId The nftId
    /// @param _order The order calldata
    function _safeSubmitOrder(
        address _inputToken,
        address _outputToken,
        uint256 _amountToSpend,
        uint256 _nftId,
        Order calldata _order
    ) private {
        address operator = requireAndGetAddress(_order.operator);
        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);
        if (success) {
            (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(
                data,
                _inputToken,
                _outputToken
            );
            _handleUnderSpending(_amountToSpend, amounts[1], IERC20(_inputToken));
        } else {
            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);
        }
    }

    /// @dev Transfer tokens to the reserve, and compute the amount received to store
    /// in the records. We need to know the amount received in case of deflationary tokens.
    /// @param _token The token address
    /// @param _amount The amount to send to the reserve
    /// @param _nftId The Token ID to store the assets
    function _transferToReserveAndStore(
        address _token,
        uint256 _amount,
        uint256 _nftId
    ) private {
        uint256 balanceReserveBefore = IERC20(_token).balanceOf(address(reserve));

        // Send output to reserve
        IERC20(_token).safeTransfer(address(reserve), _amount);

        uint256 balanceReserveAfter = IERC20(_token).balanceOf(address(reserve));

        nestedRecords.store(_nftId, _token, balanceReserveAfter - balanceReserveBefore, address(reserve));
    }

    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve
    ///      or the user wallet, to the factory.
    /// @param _nftId The NFT id
    /// @param _inputToken The token to receive
    /// @param _inputTokenAmount Amount to transfer
    /// @param _fromReserve True to transfer from the reserve
    /// @return tokenUsed Token transfered (in case of ETH)
    function _transferInputTokens(
        uint256 _nftId,
        IERC20 _inputToken,
        uint256 _inputTokenAmount,
        bool _fromReserve
    ) private returns (IERC20 tokenUsed) {
        if (_fromReserve) {
            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, address(_inputToken));
            require(holding.amount >= _inputTokenAmount, ""NestedFactory:_transferInputTokens: Insufficient amount"");

            // Get input from reserve
            reserve.withdraw(IERC20(holding.token), _inputTokenAmount);
        } else if (address(_inputToken) == ETH) {
            require(msg.value == _inputTokenAmount, ""NestedFactory::_transferInputTokens: Insufficient amount in"");
            weth.deposit{ value: msg.value }();
            _inputToken = IERC20(address(weth));
        } else {
            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);
        }
        tokenUsed = _inputToken;
    }

    /// @dev Send the under spent amount to the FeeSplitter without the royalties.
    ///      The ""under spent"" amount is the positive difference between the amount supposed
    ///      to be spent and the amount really spent.
    /// @param _amountToSpent The amount supposed to be spent
    /// @param _amountSpent The amount really spent
    /// @param _token The amount-related token
    function _handleUnderSpending(
        uint256 _amountToSpent,
        uint256 _amountSpent,
        IERC20 _token
    ) private {
        if (_amountToSpent - _amountSpent > 0) {
            ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));
            feeSplitter.sendFees(_token, _amountToSpent - _amountSpent);
        }
    }

    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset
    /// @param _amount Amount to send
    /// @param _token Token to send
    /// @param _nftId User portfolio ID used to find a potential royalties recipient
    function _transferFeeWithRoyalty(
        uint256 _amount,
        IERC20 _token,
        uint256 _nftId
    ) private {
        address originalOwner = nestedAsset.originalOwner(_nftId);
        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));
        if (originalOwner != address(0)) {
            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);
        } else {
            feeSplitter.sendFees(_token, _amount);
        }
    }

    /// @dev Decrease the amount of a NFT holding
    /// @param _nftId The NFT id
    /// @param _inputToken The token holding
    /// @param _amount The amount to subtract from the actual holding amount
    function _decreaseHoldingAmount(
        uint256 _nftId,
        address _inputToken,
        uint256 _amount
    ) private {
        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, _inputToken);
        nestedRecords.updateHoldingAmount(_nftId, _inputToken, holding.amount - _amount);
    }

    /// @dev Transfer a token amount from the factory to the recipient.
    ///      The token is unwrapped if WETH.
    /// @param _token The token to transfer
    /// @param _amount The amount to transfer
    /// @param _dest The address receiving the funds
    function _safeTransferAndUnwrap(
        IERC20 _token,
        uint256 _amount,
        address _dest
    ) private {
        // if buy token is WETH, unwrap it instead of transferring it to the sender
        if (address(_token) == address(weth)) {
            IWETH(weth).withdraw(_amount);
            (bool success, ) = _dest.call{ value: _amount }("""");
            require(success, ""ETH_TRANSFER_ERROR"");
        } else {
            _token.safeTransfer(_dest, _amount);
        }
    }

    /// @dev Transfer from factory and collect fees
    /// @param _token The token to transfer
    /// @param _amount The amount (with fees) to transfer
    /// @param _dest The address receiving the funds
    function _safeTransferWithFees(
        IERC20 _token,
        uint256 _amount,
        address _dest,
        uint256 _nftId
    ) private {
        uint256 feeAmount = _calculateFees(_dest, _amount);
        _transferFeeWithRoyalty(feeAmount, _token, _nftId);
        _token.safeTransfer(_dest, _amount - feeAmount);
    }

    /// @dev Calculate the fees for a specific user and amount (1%)
    /// @param _user The user address
    /// @param _amount The amount
    /// @return The fees amount
    function _calculateFees(address _user, uint256 _amount) private view returns (uint256) {
        return _amount / 100;
    }
}",5567
RealWorld_BA_53_FlatOperator_RealWord_20240821122410.log,53,FlatOperator,8177,4958,13135,70.0,0.140045,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./IFlatOperator.sol"";
import ""../../interfaces/IOperatorSelector.sol"";

/// @title The flat operator doesn't execute any logic to an input.
/// @notice The input is the output, and the input amount is the output amount.
/// Usefull to deposit/withdraw a token without swapping in your Orders.
contract FlatOperator is IFlatOperator, IOperatorSelector {
    /// @inheritdoc IFlatOperator
    function commitAndRevert(
        address self,
        address token,
        uint256 amount
    ) external payable override returns (uint256[] memory amounts, address[] memory tokens) {
        require(amount > 0, ""FlatOperator::commitAndRevert: Amount must be greater than zero"");

        amounts = new uint256[](2);
        tokens = new address[](2);

        // Output amounts
        amounts[0] = amount;
        amounts[1] = amount;
        // Output token
        tokens[0] = token;
        tokens[1] = token;
    }

    /// @inheritdoc IOperatorSelector
    function getCommitSelector() external pure override returns (bytes4) {
        return this.commitAndRevert.selector;
    }

    /// @inheritdoc IOperatorSelector
    function getRevertSelector() external pure override returns (bytes4) {
        return this.commitAndRevert.selector;
    }
}",317
RealWorld_BA_53_MixinOperatorResolver_RealWord_20240821120827.log,53,MixinOperatorResolver,12077,4940,17017,89.0,0.159185,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./OperatorResolver.sol"";

/// @title Mixin operator resolver
/// @notice Store in cache operators name and address
abstract contract MixinOperatorResolver {
    /// @notice Emitted when cache is updated
    /// @param name The operator name
    /// @param destination The operator address
    event CacheUpdated(bytes32 name, address destination);

    /// @dev The OperatorResolver used to build the cache
    OperatorResolver public resolver;

    /// @dev Cache operators map of the name and address
    mapping(bytes32 => address) private addressCache;

    constructor(address _resolver) {
        resolver = OperatorResolver(_resolver);
    }

    /// @dev This function is public not external in order for it to be overridden and
    /// invoked via super in subclasses
    function resolverAddressesRequired() public view virtual returns (bytes32[] memory addresses) {}

    /// @notice Rebuild the addressCache
    function rebuildCache() public {
        bytes32[] memory requiredAddresses = resolverAddressesRequired();
        // The resolver must call this function whenever it updates its state
        for (uint256 i = 0; i < requiredAddresses.length; i++) {
            bytes32 name = requiredAddresses[i];
            // Note: can only be invoked once the resolver has all the targets needed added
            address destination = resolver.getAddress(name);
            if (destination != address(0)) {
                addressCache[name] = destination;
            } else {
                delete addressCache[name];
            }
            emit CacheUpdated(name, destination);
        }
    }

    /// @notice Check the state of addressCache
    function isResolverCached() external view returns (bool) {
        bytes32[] memory requiredAddresses = resolverAddressesRequired();
        for (uint256 i = 0; i < requiredAddresses.length; i++) {
            bytes32 name = requiredAddresses[i];
            // false if our cache is invalid or if the resolver doesn't have the required address
            if (resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)) {
                return false;
            }
        }
        return true;
    }

    /// @dev Get operator address in cache and require (if exists)
    /// @param name The operator name
    /// @return The operator address
    function requireAndGetAddress(bytes32 name) internal view returns (address) {
        address _foundAddress = addressCache[name];
        require(_foundAddress != address(0), string(abi.encodePacked(""Missing operator : "", name)));
        return _foundAddress;
    }
}",549
RealWorld_BA_53_ExchangeHelpers_RealWord_20240821123030.log,53,ExchangeHelpers,9440,4818,14258,74.0,0.14356,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

/**
 * Helpers for swapping tokens
 */
library ExchangeHelpers {
    using SafeERC20 for IERC20;

    /*
    Perform a swap between two tokens
    @param _sellToken [IERC20] token to exchange
    @param _swapTarget [address] the address of the contract that swaps tokens
    @param _swapCallData [bytes] call data provided by 0x to fill the quote
    */
    function fillQuote(
        IERC20 _sellToken,
        address _swapTarget,
        bytes memory _swapCallData
    ) internal returns (bool) {
        setMaxAllowance(_sellToken, _swapTarget);
        // solhint-disable-next-line avoid-low-level-calls
        (bool success, ) = _swapTarget.call(_swapCallData);
        return success;
    }

    /**
     * @dev sets the allowance for a token to the maximum if it is not already at max
     * @param _token [IERC20] the token to use for the allowance setting
     * @param _spender [address] spender to allow
     */
    function setMaxAllowance(IERC20 _token, address _spender) internal {
        uint256 _currentAllowance = _token.allowance(address(this), _spender);
        if (_currentAllowance == 0) {
            _token.safeApprove(_spender, type(uint256).max);
        } else if (_currentAllowance != type(uint256).max) {
            // Approve 0 first for tokens mitigating the race condition
            _token.safeApprove(_spender, 0);
            _token.safeApprove(_spender, type(uint256).max);
        }
    }
}",396
RealWorld_BA_53_IOperatorResolver_RealWord_20240821123317.log,53,IOperatorResolver,8930,5027,13957,79.0,0.14519,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

/// @title Operator address resolver interface
interface IOperatorResolver {
    /// @notice Emitted when an operator is imported
    /// @param name The operator name
    /// @param destination The operator address
    event OperatorImported(bytes32 name, address destination);

    /// @notice Get the address of an operator for a given name
    /// @param name The operator name
    /// @return The operator address
    function getAddress(bytes32 name) external view returns (address);

    /// @notice Get the address of an operator for a given but require
    /// the operator to exist.
    /// @param name The operator name
    /// @param reason Require message
    /// @return The operator address
    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);

    /// @notice Check if some addresses are imported with the right name (and vice versa)
    /// @dev The check is performed on the index, make sure that the two arrays match
    /// @param names The operator names
    /// @param destinations The operator addresses
    /// @return True if all the addresses/names are correctly imported, false otherwise
    function areAddressesImported(bytes32[] calldata names, address[] calldata destinations)
        external
        view
        returns (bool);

    /// @notice Import/replace operators
    /// @dev names and destinations arrays must coincide
    /// @param names Operators name
    /// @param destinations Operators address
    function importOperators(bytes32[] calldata names, address[] calldata destinations) external;
}",352
RealWorld_BA_53_NestedReserve_RealWord_20240821120959.log,53,NestedReserve,12125,5189,17314,79.0,0.164405,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/// @title Stores underlying assets of NestedNFTs.
/// @notice The factory itself can only trigger a transfer after verification that the user
///         holds funds present in this contract. Only the factory can withdraw assets.
contract NestedReserve is Ownable {
    using SafeERC20 for IERC20;

    /// @dev The current factory address
    address public factory;

    /// @dev Emitted when the factory address is updated by the owner
    event FactoryUpdated(address newFactory);

    constructor(address _factory) {
        factory = _factory;
    }

    /// @dev Reverts if the address does not exist
    /// @param _address The address to check
    modifier valid(address _address) {
        require(_address != address(0), ""NestedReserve: INVALID_ADDRESS"");
        _;
    }

    /// @dev Reverts if the caller is not the factory
    modifier onlyFactory() {
        require(_msgSender() == factory, ""NestedReserve: UNAUTHORIZED"");
        _;
    }

    /// @notice Release funds to a recipient
    /// @param _recipient The receiver
    /// @param _token The token to transfer
    /// @param _amount The amount to transfer
    function transfer(
        address _recipient,
        IERC20 _token,
        uint256 _amount
    ) external onlyFactory valid(_recipient) valid(address(_token)) {
        _token.safeTransfer(_recipient, _amount);
    }

    /// @notice Release funds to the factory
    /// @param _token The ERC20 to transfer
    /// @param _amount The amount to transfer
    function withdraw(IERC20 _token, uint256 _amount) external onlyFactory valid(address(_token)) {
        _token.safeTransfer(factory, _amount);
    }

    /// Transfer funds from the factory directly
    /// @param _token The ERC20 to transfer
    /// @param _amount The amount to transfer
    function transferFromFactory(IERC20 _token, uint256 _amount) external onlyFactory {
        _token.safeTransferFrom(factory, address(this), _amount);
    }

    /// @notice Update the factory address
    /// @param _newFactory The new factory address
    function updateFactory(address _newFactory) external onlyOwner {
        require(_newFactory != address(0), ""NestedReserve: INVALID_ADDRESS"");
        factory = _newFactory;
        emit FactoryUpdated(_newFactory);
    }
}",563
RealWorld_BA_53_NestedBuybacker_RealWord_20240821120202.log,53,NestedBuybacker,19812,5283,25095,85.0,0.20472,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

import ""./interfaces/external/INestedToken.sol"";
import ""./FeeSplitter.sol"";
import ""./libraries/ExchangeHelpers.sol"";

/// @title Token sent to this contract are used to purchase NST.
/// @dev Some of it is burned, the rest is sent to a pool that will redistribute
///      to the NST ecosystem and community.
contract NestedBuybacker is Ownable {
    using SafeERC20 for IERC20;
    using SafeERC20 for INestedToken;

    /// @dev Emitted when the reserve address is updated
    /// @param newReserve The new reserve address
    event ReserveUpdated(address newReserve);

    /// @dev Emitted when the fee splitter address is updated
    /// @param newFeeSplitter The new FeeSplitter address
    event FeeSplitterUpdated(FeeSplitter newFeeSplitter);

    /// @dev Emitted when the burn percentage is updated
    /// @param newBurnPart The new burn percentage amount
    event BurnPartUpdated(uint256 newBurnPart);

    /// @dev Emitted when the buy back is executed
    /// @param forToken sellToken used for the buy back
    event BuybackTriggered(IERC20 forToken);

    /// @dev The Nested project token
    INestedToken public immutable NST;

    /// @dev Current address where user assets are stored
    address public nstReserve;

    /// @dev Current fee splitter address
    FeeSplitter public feeSplitter;

    /// @dev Part of the bought tokens to be burned (100% = 1000)
    uint256 public burnPercentage;

    constructor(
        address _NST,
        address _nstReserve,
        address payable _feeSplitter,
        uint256 _burnPercentage
    ) {
        require(_burnPercentage <= 1000, ""NestedBuybacker::constructor: Burn part to high"");
        burnPercentage = _burnPercentage;
        NST = INestedToken(_NST);
        feeSplitter = FeeSplitter(_feeSplitter);
        nstReserve = _nstReserve;
    }

    /// @notice Claim awarded fees from the FeeSplitter contract
    /// @param _token Token address for the fees
    function claimFees(IERC20 _token) public {
        feeSplitter.releaseToken(_token);
    }

    /// @notice Update the nested reserve address
    /// @param _nstReserve New reserve contract address
    function setNestedReserve(address _nstReserve) external onlyOwner {
        nstReserve = _nstReserve;
        emit ReserveUpdated(nstReserve);
    }

    /// @notice Update the fee splitter address
    /// @param _feeSplitter The new fee splitter contract address
    function setFeeSplitter(FeeSplitter _feeSplitter) external onlyOwner {
        feeSplitter = _feeSplitter;
        emit FeeSplitterUpdated(feeSplitter);
    }

    /// @notice Update parts deciding what amount is sent to reserve or burned
    /// @param _burnPercentage The new burn percentage
    function setBurnPart(uint256 _burnPercentage) public onlyOwner {
        require(_burnPercentage <= 1000, ""NestedBuybacker::setBurnPart: Burn part to high"");
        burnPercentage = _burnPercentage;
        emit BurnPartUpdated(burnPercentage);
    }

    /// @notice Triggers the purchase of NST sent to reserve and burn
    /// @param _swapCallData Call data provided by 0x to fill quotes
    /// @param _swapTarget Target contract for the swap (could be Uniswap router for example)
    /// @param _sellToken Token to sell in order to buy NST
    function triggerForToken(
        bytes calldata _swapCallData,
        address payable _swapTarget,
        IERC20 _sellToken
    ) external onlyOwner {
        if (feeSplitter.getAmountDue(address(this), _sellToken) > 0) {
            claimFees(_sellToken);
        }

        uint256 balance = _sellToken.balanceOf(address(this));
        ExchangeHelpers.fillQuote(_sellToken, _swapTarget, _swapCallData);
        trigger();
        emit BuybackTriggered(_sellToken);
    }

    /// @dev burns part of the bought NST and send the rest to the reserve
    function trigger() internal {
        uint256 balance = NST.balanceOf(address(this));
        uint256 toBurn = (balance * burnPercentage) / 1000;
        uint256 toSendToReserve = balance - toBurn;
        _burnNST(toBurn);
        NST.safeTransfer(nstReserve, toSendToReserve);
    }

    /// @dev Burn NST token from the smart contract
    /// @param _amount The amount to burn
    function _burnNST(uint256 _amount) private {
        NST.burn(_amount);
    }
}",1072
RealWorld_BA_53_ZeroExStorage_RealWord_20240821122800.log,53,ZeroExStorage,5228,4916,10144,76.0,0.12446,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/access/Ownable.sol"";

/// @title ZeroExOperator storage contract
contract ZeroExStorage is Ownable {
    address private _swapTarget;

    /// @notice Returns the address of 0x swaptarget
    function swapTarget() external view returns (address) {
        return _swapTarget;
    }

    /// @notice Update the address of 0x swaptarget
    function updatesSwapTarget(address swapTargetValue) external onlyOwner {
        _swapTarget = swapTargetValue;
    }
}",136
RealWorld_BA_53_OperatorResolver_RealWord_20240821121303.log,53,OperatorResolver,10893,4976,15869,95.0,0.153985,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./interfaces/IOperatorResolver.sol"";
import ""./MixinOperatorResolver.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

/// @title Operator Resolver implementation
/// @notice Resolve the operators address
contract OperatorResolver is IOperatorResolver, Ownable {
    /// @dev Operators map of the name and address
    mapping(bytes32 => address) public operators;

    /// @inheritdoc IOperatorResolver
    function getAddress(bytes32 name) external view override returns (address) {
        return operators[name];
    }

    /// @inheritdoc IOperatorResolver
    function requireAndGetAddress(bytes32 name, string calldata reason) external view override returns (address) {
        address _foundAddress = operators[name];
        require(_foundAddress != address(0), reason);
        return _foundAddress;
    }

    /// @inheritdoc IOperatorResolver
    function areAddressesImported(bytes32[] calldata names, address[] calldata destinations)
        external
        view
        override
        returns (bool)
    {
        for (uint256 i = 0; i < names.length; i++) {
            if (operators[names[i]] != destinations[i]) {
                return false;
            }
        }
        return true;
    }

    /// @inheritdoc IOperatorResolver
    function importOperators(bytes32[] calldata names, address[] calldata destinations) external override onlyOwner {
        require(names.length == destinations.length, ""OperatorResolver::importOperators: Input lengths must match"");

        for (uint256 i = 0; i < names.length; i++) {
            bytes32 name = names[i];
            address destination = destinations[i];
            operators[name] = destination;
            emit OperatorImported(name, destination);
        }
    }

    /// @notice rebuild the caches of mixin smart contracts
    /// @param destinations The list of mixinOperatorResolver to rebuild
    function rebuildCaches(MixinOperatorResolver[] calldata destinations) external {
        for (uint256 i = 0; i < destinations.length; i++) {
            destinations[i].rebuildCache();
        }
    }
}",453
RealWorld_BA_53_WETHMock_RealWord_20240821121928.log,53,WETHMock,13614,4964,18578,74.0,0.16735,"/**
 *Submitted for verification at Etherscan.io on 2017-12-12
 */

// Copyright (C) 2015, 2016, 2017 Dapphub

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

contract WETH9 {
    string public name = ""Wrapped Ether"";
    string public symbol = ""WETH"";
    uint8 public decimals = 18;

    event Approval(address indexed src, address indexed guy, uint256 wad);
    event Transfer(address indexed src, address indexed dst, uint256 wad);
    event Deposit(address indexed dst, uint256 wad);
    event Withdrawal(address indexed src, uint256 wad);

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    receive() external payable {
        deposit();
    }

    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 wad) public {
        require(balanceOf[msg.sender] >= wad);
        balanceOf[msg.sender] -= wad;
        payable(msg.sender).transfer(wad);
        emit Withdrawal(msg.sender, wad);
    }

    function totalSupply() public view returns (uint256) {
        return address(this).balance;
    }

    function approve(address guy, uint256 wad) public returns (bool) {
        allowance[msg.sender][guy] = wad;
        emit Approval(msg.sender, guy, wad);
        return true;
    }

    function transfer(address dst, uint256 wad) public returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }

    function transferFrom(
        address src,
        address dst,
        uint256 wad
    ) public returns (bool) {
        require(balanceOf[src] >= wad, ""INSUFFICIENT_BALANCE"");

        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {
            require(allowance[src][msg.sender] >= wad);
            allowance[src][msg.sender] -= wad;
        }

        balanceOf[src] -= wad;
        balanceOf[dst] += wad;

        emit Transfer(src, dst, wad);

        return true;
    }
}

/*
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

 */",691
RealWorld_BA_53_IWETH_RealWord_20240821123539.log,53,IWETH,5364,4412,9776,78.0,0.11506,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.9;

interface IWETH {
    function deposit() external payable;

    function withdraw(uint256) external;

    function totalSupply() external view returns (uint256);

    function transfer(address recipient, uint256 amount) external returns (bool);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);
}",151
RealWorld_BA_53_IZeroExOperator_RealWord_20240821122652.log,53,IZeroExOperator,6202,4083,10285,66.0,0.11267,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/// @title ZeroEx Operator Interface
interface IZeroExOperator {
    /// @notice Execute a swap via 0x
    /// @param self The operator address (for delegatecall context resolution)
    /// @param sellToken The token sold
    /// @param buyToken The token bought
    /// @param swapSelector The selector of the ZeroEx function
    /// @param swapCallData 0x calldata from the API
    /// @return amounts Array of output amounts
    /// @return tokens Array of output tokens
    function commitAndRevert(
        address self,
        IERC20 sellToken,
        IERC20 buyToken,
        bytes4 swapSelector,
        bytes calldata swapCallData
    ) external payable returns (uint256[] memory amounts, address[] memory tokens);
}",208
RealWorld_BA_53_OperatorHelpers_RealWord_20240821122918.log,53,OperatorHelpers,12891,5210,18101,70.0,0.168655,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../interfaces/IOperatorSelector.sol"";

/// @title Library to help the interaction with operators
library OperatorHelpers {
    /// @dev Build the calldata (with safe datas) and call the Operator
    /// @param _operator The operator address
    /// @param _commit True to call the commit operator function, false to call the revert function.
    /// @param _calldata Parameters of the operator (expect the 'self' parameter)
    /// @return success If the operator call is successful
    /// @return data The data from the call
    function callOperator(
        address _operator,
        bool _commit,
        bytes calldata _calldata
    ) internal returns (bool success, bytes memory data) {
        // The operator address needs to be the first parameter of the operator delegatecall.
        // We assume that the calldata given by the user are only the params, without the signature.
        // Parameters are concatenated and padded to 32 bytes.
        // We are concatenating the selector + operator address + given params
        bytes4 selector;
        if (_commit) {
            selector = IOperatorSelector(_operator).getCommitSelector();
        } else {
            selector = IOperatorSelector(_operator).getRevertSelector();
        }

        bytes memory safeCalldata = bytes.concat(selector, abi.encode(_operator), _calldata);

        (success, data) = _operator.delegatecall(safeCalldata);
    }

    /// @dev Get amounts and tokens from operator call by decoding data
    /// @param _data The bytes from the operator call
    /// @param _inputToken Input token expected to be used by the operator
    /// @param _outputToken Output token expected to be used by the operator
    /// @return amounts The amounts from the execution (used and received)
    ///         - amounts[0] : The amount of output token
    ///         - amounts[1] : The amount of input token USED by the operator (can be different than expected)
    /// @return tokens The tokens used and received from the execution
    ///         - tokens[0] : The output token from the operator execution
    ///         - tokens[1] : The token used as an input
    function decodeDataAndRequire(
        bytes memory _data,
        address _inputToken,
        address _outputToken
    ) internal returns (uint256[] memory amounts, address[] memory tokens) {
        (amounts, tokens) = abi.decode(_data, (uint256[], address[]));
        require(tokens[0] == _outputToken, ""OperatorHelpers::getDecodeDataAndRequire: Wrong output token"");
        require(tokens[1] == _inputToken, ""OperatorHelpers::getDecodeDataAndRequire: Wrong input token"");
    }
}",600
RealWorld_BA_53_INestedToken_RealWord_20240821123741.log,53,INestedToken,3745,4339,8084,81.0,0.105505,"//SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

abstract contract INestedToken is IERC20 {
    function burn(uint256 amount) public virtual;
}",57
RealWorld_BA_53_MinimalSmartChef_RealWord_20240821123700.log,53,MinimalSmartChef,2487,1829,4316,39.0,0.049015,,0
RealWorld_BA_53_MockERC20_RealWord_20240821121551.log,53,MockERC20,5011,4442,9453,72.0,0.113895,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MockERC20 is ERC20 {
    constructor(
        string memory _name,
        string memory _symbol,
        uint256 _initialSupply
    ) ERC20(_name, _symbol) {
        _mint(msg.sender, _initialSupply);
    }

    function mint(address recipient, uint256 amount) external {
        _mint(recipient, amount);
    }

    function burn(uint256 amount) external {
        _burn(msg.sender, amount);
    }
}",129
RealWorld_BA_53_TestableOperatorCaller_RealWord_20240821121440.log,53,TestableOperatorCaller,5782,4268,10050,69.0,0.11427,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

/// @notice Testable contract calling
contract TestableOperatorCaller {
    address public operator;

    constructor(address _operator) {
        operator = _operator;
    }

    function zeroExCommitAndRevert(
        address own,
        address sellToken,
        address buyToken,
        bytes calldata swapCallData
    ) external returns (bool) {
        (bool success, bytes memory data) = operator.delegatecall(
            abi.encodeWithSignature(
                ""commitAndRevert(address,address,address,bytes)"",
                own,
                sellToken,
                buyToken,
                swapCallData
            )
        );
        require(success, ""TestableOperatorCaller::zeroExCommitAndRevert: Error"");
        return true;
    }
}",174
RealWorld_BA_53_TestableMixingOperatorResolver_RealWord_20240821121705.log,53,TestableMixingOperatorResolver,6377,4751,11128,86.0,0.126905,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../MixinOperatorResolver.sol"";

contract TestableMixinResolver is MixinOperatorResolver {
    bytes32 private constant CONTRACT_EXAMPLE_1 = ""Example_1"";
    bytes32 private constant CONTRACT_EXAMPLE_2 = ""Example_2"";
    bytes32 private constant CONTRACT_EXAMPLE_3 = ""Example_3"";

    bytes32[24] private addressesToCache = [CONTRACT_EXAMPLE_1, CONTRACT_EXAMPLE_2, CONTRACT_EXAMPLE_3];

    constructor(address _resolver) MixinOperatorResolver(_resolver) {}

    function resolverAddressesRequired() public view override returns (bytes32[] memory addresses) {
        addresses = new bytes32[](3);
        addresses[0] = CONTRACT_EXAMPLE_1;
        addresses[1] = CONTRACT_EXAMPLE_2;
        addresses[2] = CONTRACT_EXAMPLE_3;
    }
}",200
RealWorld_BA_53_FeeSplitter_RealWord_20240821121120.log,53,FeeSplitter,44649,5319,49968,101.0,0.329625,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""./interfaces/external/IWETH.sol"";

/// @title Manage the fees between shareholders
/// @notice Receives fees collected by the NestedFactory, and splits the income among
/// shareholders (the NFT owners, Nested treasury and a NST buybacker contract).
contract FeeSplitter is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    /// @dev Emitted when a payment is released
    /// @param to The address receiving the payment
    /// @param token The token transfered
    /// @param amount The amount paid
    event PaymentReleased(address to, address token, uint256 amount);

    /// @dev Emitted when a payment is released
    /// @param from The address sending the tokens
    /// @param token The token received
    /// @param amount The amount received
    event PaymentReceived(address from, address token, uint256 amount);

    /// @dev Represent a shareholder
    /// @param account Shareholders address that can receive income
    /// @param weight Determines share allocation
    struct Shareholder {
        address account;
        uint256 weight;
    }

    /// @dev Registers shares and amount release for a specific token or ETH
    struct TokenRecords {
        uint256 totalShares;
        uint256 totalReleased;
        mapping(address => uint256) shares;
        mapping(address => uint256) released;
    }

    /// @dev Map of tokens with the tokenRecords
    mapping(address => TokenRecords) private tokenRecords;

    /// @dev All the shareholders (array)
    Shareholder[] private shareholders;

    /// @dev Royalties part weights when applicable
    uint256 public royaltiesWeight;

    uint256 public totalWeights;

    address public immutable weth;

    constructor(
        address[] memory _accounts,
        uint256[] memory _weights,
        uint256 _royaltiesWeight,
        address _weth
    ) {
        // Initial shareholders addresses and weights
        setShareholders(_accounts, _weights);
        setRoyaltiesWeight(_royaltiesWeight);
        weth = _weth;
    }

    /// @dev Receive ether after a WETH withdraw call
    receive() external payable {
        require(_msgSender() == weth, ""FeeSplitter: ETH_SENDER_NOT_WETH"");
    }

    /// @notice Returns the amount due to an account. Call releaseToken to withdraw the amount.
    /// @param _account Account address to check the amount due for
    /// @param _token ERC20 payment token address (or ETH_ADDR)
    /// @return The total amount due for the requested currency
    function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {
        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];
        uint256 totalReceived = _tokenRecords.totalReleased;
        if (_tokenRecords.totalShares == 0) return 0;
        else totalReceived += _token.balanceOf(address(this));
        uint256 amountDue = (totalReceived * _tokenRecords.shares[_account]) /
            _tokenRecords.totalShares -
            _tokenRecords.released[_account];
        return amountDue;
    }

    /// @notice Sets the weight assigned to the royalties part for the fee
    /// @param _weight The new royalties weight
    function setRoyaltiesWeight(uint256 _weight) public onlyOwner {
        totalWeights -= royaltiesWeight;
        royaltiesWeight = _weight;
        totalWeights += _weight;
    }

    /// @notice Sets a new list of shareholders
    /// @param _accounts Shareholders accounts list
    /// @param _weights Weight for each shareholder. Determines part of the payment allocated to them
    function setShareholders(address[] memory _accounts, uint256[] memory _weights) public onlyOwner {
        delete shareholders;
        require(_accounts.length > 0 && _accounts.length == _weights.length, ""FeeSplitter: ARRAY_LENGTHS_ERR"");
        totalWeights = royaltiesWeight;

        for (uint256 i = 0; i < _accounts.length; i++) {
            _addShareholder(_accounts[i], _weights[i]);
        }
    }

    /// @notice Triggers a transfer to `msg.sender` of the amount of token they are owed, according to
    /// the amount of shares they own and their previous withdrawals.
    /// @param _token Payment token address
    function releaseToken(IERC20 _token) public nonReentrant {
        uint256 amount = _releaseToken(_msgSender(), _token);
        _token.safeTransfer(_msgSender(), amount);
        emit PaymentReleased(_msgSender(), address(_token), amount);
    }

    /// @notice Call releaseToken() for multiple tokens
    /// @param _tokens ERC20 tokens to release
    function releaseTokens(IERC20[] memory _tokens) external {
        for (uint256 i = 0; i < _tokens.length; i++) {
            releaseToken(_tokens[i]);
        }
    }

    /// @dev Triggers a transfer to `msg.sender` of the amount of Ether they are owed, according to
    /// the amount of shares they own and their previous withdrawals.
    function releaseETH() external nonReentrant {
        uint256 amount = _releaseToken(_msgSender(), IERC20(weth));
        IWETH(weth).withdraw(amount);
        (bool success, ) = _msgSender().call{ value: amount }("""");
        require(success, ""FeeSplitter: ETH_TRANFER_ERROR"");
        emit PaymentReleased(_msgSender(), ETH, amount);
    }

    /// @notice Sends a fee to this contract for splitting, as an ERC20 token. No royalties are expected.
    /// @param _token Currency for the fee as an ERC20 token
    /// @param _amount Amount of token as fee to be claimed by this contract
    function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {
        uint256 weights = totalWeights - royaltiesWeight;
        _sendFees(_token, _amount, weights);
    }

    /// @notice Sends a fee to this contract for splitting, as an ERC20 token
    /// @param _royaltiesTarget The account that can claim royalties
    /// @param _token Currency for the fee as an ERC20 token
    /// @param _amount Amount of token as fee to be claimed by this contract
    function sendFeesWithRoyalties(
        address _royaltiesTarget,
        IERC20 _token,
        uint256 _amount
    ) external nonReentrant {
        require(_royaltiesTarget != address(0), ""FeeSplitter: INVALID_ROYALTIES_TARGET_ADDRESS"");

        _sendFees(_token, _amount, totalWeights);
        _addShares(_royaltiesTarget, _computeShareCount(_amount, royaltiesWeight, totalWeights), address(_token));
    }

    /// @notice Updates weight for a shareholder
    /// @param _accountIndex Account to change the weight of
    /// @param _weight The new weight
    function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {
        require(_accountIndex + 1 <= shareholders.length, ""FeeSplitter: INVALID_ACCOUNT_INDEX"");
        uint256 _totalWeights = totalWeights;
        _totalWeights -= shareholders[_accountIndex].weight;
        shareholders[_accountIndex].weight = _weight;
        _totalWeights += _weight;
        require(_totalWeights > 0, ""FeeSplitter: TOTAL_WEIGHTS_ZERO"");
        totalWeights = _totalWeights;
    }

    /// @notice Getter for the total shares held by shareholders.
    /// @param _token Payment token address, use ETH_ADDR for ETH
    /// @return The total shares count
    function totalShares(address _token) external view returns (uint256) {
        return tokenRecords[_token].totalShares;
    }

    /// @notice Getter for the total amount of token already released.
    /// @param _token Payment token address, use ETH_ADDR for ETH
    /// @return The total amount release to shareholders
    function totalReleased(address _token) external view returns (uint256) {
        return tokenRecords[_token].totalReleased;
    }

    /// @notice Getter for the amount of shares held by an account.
    /// @param _account Account the shares belong to
    /// @param _token Payment token address, use ETH_ADDR for ETH
    /// @return The shares owned by the account
    function shares(address _account, address _token) external view returns (uint256) {
        return tokenRecords[_token].shares[_account];
    }

    /// @notice Getter for the amount of Ether already released to a shareholders.
    /// @param _account The target account for this request
    /// @param _token Payment token address, use ETH_ADDR for ETH
    /// @return The amount already released to this account
    function released(address _account, address _token) external view returns (uint256) {
        return tokenRecords[_token].released[_account];
    }

    /// @notice Finds a shareholder and return its index
    /// @param _account Account to find
    /// @return The shareholder index in the storage array
    function findShareholder(address _account) external view returns (uint256) {
        for (uint256 i = 0; i < shareholders.length; i++) {
            if (shareholders[i].account == _account) return i;
        }
        revert(""FeeSplitter: NOT_FOUND"");
    }

    /// @dev Transfers a fee to this contract
    /// @param _token Currency for the fee
    /// @param _amount Amount of token as fee
    /// @param _totalWeights Total weights to determine the share count to allocate
    function _sendFees(
        IERC20 _token,
        uint256 _amount,
        uint256 _totalWeights
    ) private {
        IERC20(_token).safeTransferFrom(_msgSender(), address(this), _amount);

        for (uint256 i = 0; i < shareholders.length; i++) {
            _addShares(
                shareholders[i].account,
                _computeShareCount(_amount, shareholders[i].weight, _totalWeights),
                address(_token)
            );
        }
        emit PaymentReceived(_msgSender(), address(_token), _amount);
    }

    /// @dev Increase the shares of a shareholder
    /// @param _account The shareholder address
    /// @param _shares The shares of the holder
    /// @param _token The updated token
    function _addShares(
        address _account,
        uint256 _shares,
        address _token
    ) private {
        TokenRecords storage _tokenRecords = tokenRecords[_token];
        _tokenRecords.shares[_account] += _shares;
        _tokenRecords.totalShares = _tokenRecords.totalShares + _shares;
    }

    function _releaseToken(address _account, IERC20 _token) private returns (uint256) {
        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];
        uint256 amountToRelease = getAmountDue(_account, _token);
        require(amountToRelease != 0, ""FeeSplitter: NO_PAYMENT_DUE"");

        _tokenRecords.released[_account] = _tokenRecords.released[_account] + amountToRelease;
        _tokenRecords.totalReleased = _tokenRecords.totalReleased + amountToRelease;

        return amountToRelease;
    }

    function _addShareholder(address _account, uint256 _weight) private {
        require(_weight > 0, ""FeeSplitter: ZERO_WEIGHT"");
        shareholders.push(Shareholder(_account, _weight));
        totalWeights += _weight;
    }

    function _computeShareCount(
        uint256 _amount,
        uint256 _weight,
        uint256 _totalWeights
    ) private pure returns (uint256) {
        return (_amount * _weight) / _totalWeights;
    }
}",2615
RealWorld_BA_54_ILockKeyPurchaseHook_RealWord_20240821133848.log,54,ILockKeyPurchaseHook,10405,5540,15945,107.0,0.162825,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.17 <0.9.0;


/**
 * @notice Functions to be implemented by a keyPurchaseHook.
 * @dev Lock hooks are configured by calling `setEventHooks` on the lock.
 */
interface ILockKeyPurchaseHook
{
  /**
   * @notice Used to determine the purchase price before issueing a transaction.
   * This allows the hook to offer a discount on purchases.
   * This may revert to prevent a purchase.
   * @param from the msg.sender making the purchase
   * @param recipient the account which will be granted a key
   * @param referrer the account which referred this key sale
   * @param data arbitrary data populated by the front-end which initiated the sale
   * @return minKeyPrice the minimum value/price required to purchase a key with these settings
   * @dev the lock's address is the `msg.sender` when this function is called via
   * the lock's `purchasePriceFor` function
   */
  function keyPurchasePrice(
    address from,
    address recipient,
    address referrer,
    bytes calldata data
  ) external view
    returns (uint minKeyPrice);

  /**
   * @notice If the lock owner has registered an implementer then this hook
   * is called with every key sold.
   * @param from the msg.sender making the purchase
   * @param recipient the account which will be granted a key
   * @param referrer the account which referred this key sale
   * @param data arbitrary data populated by the front-end which initiated the sale
   * @param minKeyPrice the price including any discount granted from calling this
   * hook's `keyPurchasePrice` function
   * @param pricePaid the value/pricePaid included with the purchase transaction
   * @dev the lock's address is the `msg.sender` when this function is called
   */
  function onKeyPurchase(
    address from,
    address recipient,
    address referrer,
    bytes calldata data,
    uint minKeyPrice,
    uint pricePaid
  ) external;
}",448
RealWorld_BA_54_MixinERC721Enumerable_RealWord_20240821132049.log,54,MixinERC721Enumerable,12299,5365,17664,78.0,0.168795,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import './MixinKeys.sol';
import './MixinLockCore.sol';
// import '@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/utils/introspection/ERC165StorageUpgradeable.sol';


/**
 * @title Implements the ERC-721 Enumerable extension.
 */
contract MixinERC721Enumerable is
  ERC165StorageUpgradeable,
  MixinLockCore, // Implements totalSupply
  MixinKeys
{
  function _initializeMixinERC721Enumerable() internal
  {
    /**
     * register the supported interface to conform to ERC721Enumerable via ERC165
     * 0x780e9d63 ===
     *     bytes4(keccak256('totalSupply()')) ^
     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^
     *     bytes4(keccak256('tokenByIndex(uint256)'))
     */
    _registerInterface(0x780e9d63);
  }

  /// @notice Enumerate valid NFTs
  /// @dev Throws if `_index` >= `totalSupply()`.
  /// @param _index A counter less than `totalSupply()`
  /// @return The token identifier for the `_index`th NFT,
  ///  (sort order not specified)
  function tokenByIndex(
    uint256 _index
  ) public view
    returns (uint256)
  {
    require(_index < _totalSupply, 'OUT_OF_RANGE');
    return _index;
  }

  /// @notice Enumerate NFTs assigned to an owner
  /// @dev Throws if `_index` >= `balanceOf(_keyOwner)` or if
  ///  `_keyOwner` is the zero address, representing invalid NFTs.
  /// @param _keyOwner An address where we are interested in NFTs owned by them
  /// @param _index A counter less than `balanceOf(_keyOwner)`
  /// @return The token identifier for the `_index`th NFT assigned to `_keyOwner`,
  ///   (sort order not specified)
  function tokenOfOwnerByIndex(
    address _keyOwner,
    uint256 _index
  ) public view
    returns (uint256)
  {
    require(_index == 0, 'ONLY_ONE_KEY_PER_OWNER');
    return getTokenIdFor(_keyOwner);
  }

  function supportsInterface(bytes4 interfaceId) 
    public 
    view 
    virtual 
    override(
      AccessControlUpgradeable,
      ERC165StorageUpgradeable
    ) 
    returns (bool) 
    {
    return super.supportsInterface(interfaceId);
  }
}",583
RealWorld_BA_54_MixinLockMetadata_RealWord_20240821130815.log,54,MixinLockMetadata,19878,5861,25739,90.0,0.21661,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import '@openzeppelin/contracts-upgradeable/utils/introspection/ERC165StorageUpgradeable.sol';
// import '@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol';
import '../UnlockUtils.sol';
import './MixinKeys.sol';
import './MixinLockCore.sol';
import './MixinRoles.sol';

/**
 * @title Mixin for metadata about the Lock.
 * @author HardlyDifficult
 * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply
 * separates logically groupings of code to ease readability.
 */
contract MixinLockMetadata is
  ERC165StorageUpgradeable,
  MixinRoles,
  MixinLockCore,
  MixinKeys
{
  using UnlockUtils for uint;
  using UnlockUtils for address;
  using UnlockUtils for string;

  /// A descriptive name for a collection of NFTs in this contract.Defaults to ""Unlock-Protocol"" but is settable by lock owner
  string public name;

  /// An abbreviated name for NFTs in this contract. Defaults to ""KEY"" but is settable by lock owner
  string private lockSymbol;

  // the base Token URI for this Lock. If not set by lock owner, the global URI stored in Unlock is used.
  string private baseTokenURI;

  event NewLockSymbol(
    string symbol
  );

  function _initializeMixinLockMetadata(
    string calldata _lockName
  ) internal
  {
    ERC165StorageUpgradeable.__ERC165Storage_init();
    name = _lockName;
    // registering the optional erc721 metadata interface with ERC165.sol using
    // the ID specified in the standard: https://eips.ethereum.org/EIPS/eip-721
    _registerInterface(0x5b5e139f);
  }

  /**
   * Allows the Lock owner to assign a descriptive name for this Lock.
   */
  function updateLockName(
    string calldata _lockName
  ) external
    onlyLockManager
  {
    name = _lockName;
  }

  /**
   * Allows the Lock owner to assign a Symbol for this Lock.
   */
  function updateLockSymbol(
    string calldata _lockSymbol
  ) external
    onlyLockManager
  {
    lockSymbol = _lockSymbol;
    emit NewLockSymbol(_lockSymbol);
  }

  /**
    * @dev Gets the token symbol
    * @return string representing the token name
    */
  function symbol()
    external view
    returns(string memory)
  {
    if(bytes(lockSymbol).length == 0) {
      return unlockProtocol.globalTokenSymbol();
    } else {
      return lockSymbol;
    }
  }

  /**
   * Allows the Lock owner to update the baseTokenURI for this Lock.
   */
  function setBaseTokenURI(
    string calldata _baseTokenURI
  ) external
    onlyLockManager
  {
    baseTokenURI = _baseTokenURI;
  }

  /**  @notice A distinct Uniform Resource Identifier (URI) for a given asset.
   * @param _tokenId The iD of the token  for which we want to retrieve the URI.
   * If 0 is passed here, we just return the appropriate baseTokenURI.
   * If a custom URI has been set we don't return the lock address.
   * It may be included in the custom baseTokenURI if needed.
   * @dev  URIs are defined in RFC 3986. The URI may point to a JSON file
   * that conforms to the ""ERC721 Metadata JSON Schema"".
   * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
   */
  function tokenURI(
    uint256 _tokenId
  ) external
    view
    returns(string memory)
  {
    string memory URI;
    string memory tokenId;
    string memory lockAddress = address(this).address2Str();
    string memory seperator;

    if(_tokenId != 0) {
      tokenId = _tokenId.uint2Str();
    } else {
      tokenId = '';
    }

    if(bytes(baseTokenURI).length == 0) {
      URI = unlockProtocol.globalBaseTokenURI();
      seperator = '/';
    } else {
      URI = baseTokenURI;
      seperator = '';
      lockAddress = '';
    }

    return URI.strConcat(
        lockAddress,
        seperator,
        tokenId
      );
  }

  function supportsInterface(bytes4 interfaceId) 
    public 
    view 
    virtual 
    override(
      AccessControlUpgradeable,
      ERC165StorageUpgradeable
    ) 
    returns (bool) 
    {
    return super.supportsInterface(interfaceId);
  }
}",1011
RealWorld_BA_54_MixinGrantKeys_RealWord_20240821130947.log,54,MixinGrantKeys,9918,5274,15192,82.0,0.15507,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import './MixinKeys.sol';
import './MixinRoles.sol';


/**
 * @title Mixin allowing the Lock owner to grant / gift keys to users.
 * @author HardlyDifficult
 * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply
 * separates logically groupings of code to ease readability.
 */
contract MixinGrantKeys is
  MixinRoles,
  MixinKeys
{
  /**
   * Allows the Lock owner to give a collection of users a key with no charge.
   * Each key may be assigned a different expiration date.
   */
  function grantKeys(
    address[] calldata _recipients,
    uint[] calldata _expirationTimestamps,
    address[] calldata _keyManagers
  ) external
    onlyKeyGranterOrManager
  {
    for(uint i = 0; i < _recipients.length; i++) {
      address recipient = _recipients[i];
      uint expirationTimestamp = _expirationTimestamps[i];
      address keyManager = _keyManagers[i];

      require(recipient != address(0), 'INVALID_ADDRESS');

      Key storage toKey = keyByOwner[recipient];
      require(expirationTimestamp > toKey.expirationTimestamp, 'ALREADY_OWNS_KEY');

      uint idTo = toKey.tokenId;

      if(idTo == 0) {
        _assignNewTokenId(toKey);
        idTo = toKey.tokenId;
        _recordOwner(recipient, idTo);
      }
      // Set the key Manager
      _setKeyManagerOf(idTo, keyManager);
      emit KeyManagerChanged(idTo, keyManager);

      toKey.expirationTimestamp = expirationTimestamp;
      // trigger event
      emit Transfer(
        address(0), // This is a creation.
        recipient,
        idTo
      );
    }
  }
}",405
RealWorld_BA_54_MixinLockCore_RealWord_20240821131749.log,54,MixinLockCore,30834,5675,36509,98.0,0.26767,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// import '@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';
import './MixinDisable.sol';
import './MixinRoles.sol';
import '../interfaces/IUnlock.sol';
import './MixinFunds.sol';
import '../interfaces/hooks/ILockKeyCancelHook.sol';
import '../interfaces/hooks/ILockKeyPurchaseHook.sol';


/**
 * @title Mixin for core lock data and functions.
 * @author HardlyDifficult
 * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply
 * separates logically groupings of code to ease readability.
 */
contract MixinLockCore is
  MixinRoles,
  MixinFunds,
  MixinDisable
{
  using AddressUpgradeable for address;

  event Withdrawal(
    address indexed sender,
    address indexed tokenAddress,
    address indexed beneficiary,
    uint amount
  );

  event PricingChanged(
    uint oldKeyPrice,
    uint keyPrice,
    address oldTokenAddress,
    address tokenAddress
  );

   /**
    * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
    */
  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

  /**
    * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
    */
  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

  /**
    * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
    */
  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

  // Unlock Protocol address
  // TODO: should we make that private/internal?
  IUnlock public unlockProtocol;

  // Duration in seconds for which the keys are valid, after creation
  // should we take a smaller type use less gas?
  // TODO: add support for a timestamp instead of duration
  uint public expirationDuration;

  // price in wei of the next key
  // TODO: allow support for a keyPriceCalculator which could set prices dynamically
  uint public keyPrice;

  // Max number of keys sold if the keyReleaseMechanism is public
  uint public maxNumberOfKeys;

  // A count of how many new key purchases there have been
  uint internal _totalSupply;

  // The account which will receive funds on withdrawal
  address payable public beneficiary;

  // The denominator component for values specified in basis points.
  uint internal constant BASIS_POINTS_DEN = 10000;

  ILockKeyPurchaseHook public onKeyPurchaseHook;
  ILockKeyCancelHook public onKeyCancelHook;

  // Ensure that the Lock has not sold all of its keys.
  modifier notSoldOut() {
    require(maxNumberOfKeys > _totalSupply, 'LOCK_SOLD_OUT');
    _;
  }

  modifier onlyLockManagerOrBeneficiary()
  {
    require(
      isLockManager(msg.sender) || msg.sender == beneficiary,
      'ONLY_LOCK_MANAGER_OR_BENEFICIARY'
    );
    _;
  }

  function _initializeMixinLockCore(
    address payable _beneficiary,
    uint _expirationDuration,
    uint _keyPrice,
    uint _maxNumberOfKeys
  ) internal
  {
    require(_expirationDuration <= 100 * 365 * 24 * 60 * 60, 'MAX_EXPIRATION_100_YEARS');
    unlockProtocol = IUnlock(msg.sender); // Make sure we link back to Unlock's smart contract.
    beneficiary = _beneficiary;
    expirationDuration = _expirationDuration;
    keyPrice = _keyPrice;
    maxNumberOfKeys = _maxNumberOfKeys;
  }

  // The version number of the current implementation on this network
  function publicLockVersion(
  ) public pure
    returns (uint16)
  {
    return 9;
  }

  /**
   * @dev Called by owner to withdraw all funds from the lock and send them to the `beneficiary`.
   * @param _tokenAddress specifies the token address to withdraw or 0 for ETH. This is usually
   * the same as `tokenAddress` in MixinFunds.
   * @param _amount specifies the max amount to withdraw, which may be reduced when
   * considering the available balance. Set to 0 or MAX_UINT to withdraw everything.
   *
   * TODO: consider allowing anybody to trigger this as long as it goes to owner anyway?
   *  -- however be wary of draining funds as it breaks the `cancelAndRefund` and `expireAndRefundFor`
   * use cases.
   */
  function withdraw(
    address _tokenAddress,
    uint _amount
  ) external
    onlyLockManagerOrBeneficiary
  {

    // get balance
    uint balance;
    if(_tokenAddress == address(0)) {
      balance = address(this).balance;
    } else {
      balance = IERC20Upgradeable(_tokenAddress).balanceOf(address(this));
    }

    uint amount;
    if(_amount == 0 || _amount > balance)
    {
      require(balance > 0, 'NOT_ENOUGH_FUNDS');
      amount = balance;
    }
    else
    {
      amount = _amount;
    }

    emit Withdrawal(msg.sender, _tokenAddress, beneficiary, amount);
    // Security: re-entrancy not a risk as this is the last line of an external function
    _transfer(_tokenAddress, beneficiary, amount);
  }

  /**
   * A function which lets the owner of the lock change the pricing for future purchases.
   * This consists of 2 parts: The token address and the price in the given token.
   * In order to set the token to ETH, use 0 for the token Address.
   */
  function updateKeyPricing(
    uint _keyPrice,
    address _tokenAddress
  )
    external
    onlyLockManager
    onlyIfAlive
  {
    uint oldKeyPrice = keyPrice;
    address oldTokenAddress = tokenAddress;
    require(
      _tokenAddress == address(0) || IERC20Upgradeable(_tokenAddress).totalSupply() > 0,
      'INVALID_TOKEN'
    );
    keyPrice = _keyPrice;
    tokenAddress = _tokenAddress;
    emit PricingChanged(oldKeyPrice, keyPrice, oldTokenAddress, tokenAddress);
  }

  /**
   * A function which lets the owner of the lock update the beneficiary account,
   * which receives funds on withdrawal.
   */
  function updateBeneficiary(
    address payable _beneficiary
  ) external
  {
    require(msg.sender == beneficiary || isLockManager(msg.sender), 'ONLY_BENEFICIARY_OR_LOCKMANAGER');
    require(_beneficiary != address(0), 'INVALID_ADDRESS');
    beneficiary = _beneficiary;
  }

  /**
   * @notice Allows a lock manager to add or remove an event hook
   */
  function setEventHooks(
    address _onKeyPurchaseHook,
    address _onKeyCancelHook
  ) external
    onlyLockManager()
  {
    require(_onKeyPurchaseHook == address(0) || _onKeyPurchaseHook.isContract(), 'INVALID_ON_KEY_SOLD_HOOK');
    require(_onKeyCancelHook == address(0) || _onKeyCancelHook.isContract(), 'INVALID_ON_KEY_CANCEL_HOOK');
    onKeyPurchaseHook = ILockKeyPurchaseHook(_onKeyPurchaseHook);
    onKeyCancelHook = ILockKeyCancelHook(_onKeyCancelHook);
  }

  function totalSupply()
    public
    view returns(uint256)
  {
    return _totalSupply;
  }

  /**
   * @notice An ERC-20 style approval, allowing the spender to transfer funds directly from this lock.
   */
  function approveBeneficiary(
    address _spender,
    uint _amount
  ) public
    onlyLockManagerOrBeneficiary
    returns (bool)
  {
    return IERC20Upgradeable(tokenAddress).approve(_spender, _amount);
  }
}",1719
RealWorld_BA_54_IUnlock_RealWord_20240821133657.log,54,IUnlock,29803,6418,36221,109.0,0.277375,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.17 <0.9.0;


/**
 * @title The Unlock Interface
 * @author Nick Furfaro (unlock-protocol.com)
**/

interface IUnlock
{
  // Use initialize instead of a constructor to support proxies(for upgradeability via zos).
  function initialize(address _unlockOwner) external;

  /**
  * @dev deploy a ProxyAdmin contract used to upgrade locks
  */
  function initializeProxyAdmin() external;

  // store contract proxy admin address
  function proxyAdminAddress() external view;

  /**
  * @dev Create lock
  * This deploys a lock for a creator. It also keeps track of the deployed lock.
  * @param _tokenAddress set to the ERC20 token address, or 0 for ETH.
  * @param _salt an identifier for the Lock, which is unique for the user.
  * This may be implemented as a sequence ID or with RNG. It's used with `create2`
  * to know the lock's address before the transaction is mined.
  */
  function createLock(
    uint _expirationDuration,
    address _tokenAddress,
    uint _keyPrice,
    uint _maxNumberOfKeys,
    string calldata _lockName,
    bytes12 _salt
  ) external returns(address);

  /**
  * @notice Upgrade a lock to a specific version
  * @dev only available for publicLockVersion > 10 (proxyAdmin /required)
  * @param lockAddress the existing lock address
  * @param version the version number you are targeting
  * Likely implemented with OpenZeppelin TransparentProxy contract
  */
  function upgradeLock(
    address payable lockAddress, 
    uint16 version
  ) external returns(address);

    /**
   * This function keeps track of the added GDP, as well as grants of discount tokens
   * to the referrer, if applicable.
   * The number of discount tokens granted is based on the value of the referal,
   * the current growth rate and the lock's discount token distribution rate
   * This function is invoked by a previously deployed lock only.
   */
  function recordKeyPurchase(
    uint _value,
    address _referrer // solhint-disable-line no-unused-vars
  )
    external;

    /**
   * This function will keep track of consumed discounts by a given user.
   * It will also grant discount tokens to the creator who is granting the discount based on the
   * amount of discount and compensation rate.
   * This function is invoked by a previously deployed lock only.
   */
  function recordConsumedDiscount(
    uint _discount,
    uint _tokens // solhint-disable-line no-unused-vars
  )
    external;

    /**
   * This function returns the discount available for a user, when purchasing a
   * a key from a lock.
   * This does not modify the state. It returns both the discount and the number of tokens
   * consumed to grant that discount.
   */
  function computeAvailableDiscountFor(
    address _purchaser, // solhint-disable-line no-unused-vars
    uint _keyPrice // solhint-disable-line no-unused-vars
  )
    external
    view
    returns(uint discount, uint tokens);

  // Function to read the globalTokenURI field.
  function globalBaseTokenURI()
    external
    view
    returns(string memory);

  /**
   * @dev Redundant with globalBaseTokenURI() for backwards compatibility with v3 & v4 locks.
   */
  function getGlobalBaseTokenURI()
    external
    view
    returns (string memory);

  // Function to read the globalTokenSymbol field.
  function globalTokenSymbol()
    external
    view
    returns(string memory);

  // Function to read the chainId field.
  function chainId()
    external
    view
    returns(uint);

  /**
   * @dev Redundant with globalTokenSymbol() for backwards compatibility with v3 & v4 locks.
   */
  function getGlobalTokenSymbol()
    external
    view
    returns (string memory);

  /**
   * @notice Allows the owner to update configuration variables
   */
  function configUnlock(
    address _udt,
    address _weth,
    uint _estimatedGasForPurchase,
    string calldata _symbol,
    string calldata _URI,
    uint _chainId
  )
    external;

  /**
   * @notice Add a PublicLock template to be used for future calls to `createLock`.
   * @dev This is used to upgrade conytract per version number
   */
  function addLockTemplate(address impl, uint16 version) external;

  // match lock templates addresses with version numbers
  function publicLockImpls(uint16 _version) external view;
  
  // match version numbers with lock templates addresses 
  function publicLockVersions(address _impl) external view;

  // the latest existing lock template version
  function publicLockLatestVersion() external view;

  /**
   * @notice Upgrade the PublicLock template used for future calls to `createLock`.
   * @dev This will initialize the template and revokeOwnership.
   */
  function setLockTemplate(
    address payable _publicLockAddress
  ) external;

  // Allows the owner to change the value tracking variables as needed.
  function resetTrackedValue(
    uint _grossNetworkProduct,
    uint _totalDiscountGranted
  ) external;

  function grossNetworkProduct() external view returns(uint);

  function totalDiscountGranted() external view returns(uint);

  function locks(address) external view returns(bool deployed, uint totalSales, uint yieldedDiscountTokens);

  // The address of the public lock template, used when `createLock` is called
  function publicLockAddress() external view returns(address);

  // Map token address to exchange contract address if the token is supported
  // Used for GDP calculations
  function uniswapOracles(address) external view returns(address);

  // The WETH token address, used for value calculations
  function weth() external view returns(address);

  // The UDT token address, used to mint tokens on referral
  function udt() external view returns(address);

  // The approx amount of gas required to purchase a key
  function estimatedGasForPurchase() external view returns(uint);

  // The version number of the current Unlock implementation on this network
  function unlockVersion() external pure returns(uint16);

  /**
   * @notice allows the owner to set the oracle address to use for value conversions
   * setting the _oracleAddress to address(0) removes support for the token
   * @dev This will also call update to ensure at least one datapoint has been recorded.
   */
  function setOracle(
    address _tokenAddress,
    address _oracleAddress
  ) external;

  // Initialize the Ownable contract, granting contract ownership to the specified sender
  function __initializeOwnable(address sender) external;

  /**
   * @dev Returns true if the caller is the current owner.
   */
  function isOwner() external view returns(bool);

  /**
   * @dev Returns the address of the current owner.
   */
  function owner() external view returns(address);

  /**
   * @dev Leaves the contract without owner. It will not be possible to call
   * `onlyOwner` functions anymore. Can only be called by the current owner.
   *
   * NOTE: Renouncing ownership will leave the contract without an owner,
   * thereby removing any functionality that is only available to the owner.
   */
  function renounceOwnership() external;

  /**
   * @dev Transfers ownership of the contract to a new account (`newOwner`).
   * Can only be called by the current owner.
   */
  function transferOwnership(address newOwner) external;
}",1623
RealWorld_BA_54_IPublicLock_RealWord_20240821133512.log,54,IPublicLock,63560,5854,69414,103.0,0.43488,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.17 <0.9.0;

/**
* @title The PublicLock Interface
* @author Nick Furfaro (unlock-protocol.com)
 */


interface IPublicLock
{

// See indentationissue description here:
// https://github.com/duaraghav8/Ethlint/issues/268
// solium-disable indentation

  /// Functions
  function initialize(
    address _lockCreator,
    uint _expirationDuration,
    address _tokenAddress,
    uint _keyPrice,
    uint _maxNumberOfKeys,
    string calldata _lockName
  ) external;

  /**
   * @notice Allow the contract to accept tips in ETH sent directly to the contract.
   * @dev This is okay to use even if the lock is priced in ERC-20 tokens
   */
  // receive() external payable;
  // fallback() external payable;

  // roles
  function DEFAULT_ADMIN_ROLE() external pure returns (bytes32);
  function KEY_GRANTER_ROLE() external pure returns (bytes32);
  function LOCK_MANAGER_ROLE() external pure returns (bytes32);

  /**
  * @notice The version number of the current implementation on this network.
  * @return The current version number.
  */
  function publicLockVersion() external pure returns (uint16);

  /**
  * @notice Used to disable lock before migrating keys and/or destroying contract.
  * @dev Throws if called by other than a lock manager.
  * @dev Throws if lock contract has already been disabled.
  */
  function disableLock() external;

  /**
   * @dev Called by a lock manager or beneficiary to withdraw all funds from the lock and send them to the `beneficiary`.
   * @dev Throws if called by other than a lock manager or beneficiary
   * @param _tokenAddress specifies the token address to withdraw or 0 for ETH. This is usually
   * the same as `tokenAddress` in MixinFunds.
   * @param _amount specifies the max amount to withdraw, which may be reduced when
   * considering the available balance. Set to 0 or MAX_UINT to withdraw everything.
   *  -- however be wary of draining funds as it breaks the `cancelAndRefund` and `expireAndRefundFor`
   * use cases.
   */
  function withdraw(
    address _tokenAddress,
    uint _amount
  ) external;

  /**
   * @notice An ERC-20 style approval, allowing the spender to transfer funds directly from this lock.
   */
  function approveBeneficiary(
    address _spender,
    uint _amount
  ) external
    returns (bool);

  /**
   * A function which lets a Lock manager of the lock to change the price for future purchases.
   * @dev Throws if called by other than a Lock manager
   * @dev Throws if lock has been disabled
   * @dev Throws if _tokenAddress is not a valid token
   * @param _keyPrice The new price to set for keys
   * @param _tokenAddress The address of the erc20 token to use for pricing the keys,
   * or 0 to use ETH
   */
  function updateKeyPricing( uint _keyPrice, address _tokenAddress ) external;

  /**
   * A function which lets a Lock manager update the beneficiary account,
   * which receives funds on withdrawal.
   * @dev Throws if called by other than a Lock manager or beneficiary
   * @dev Throws if _beneficiary is address(0)
   * @param _beneficiary The new address to set as the beneficiary
   */
  function updateBeneficiary( address _beneficiary ) external;

  /**
   * Checks if the user has a non-expired key.
   * @param _user The address of the key owner
   */
  function getHasValidKey(
    address _user
  ) external view returns (bool);

  /**
   * @notice Find the tokenId for a given user
   * @return The tokenId of the NFT, else returns 0
   * @param _account The address of the key owner
  */
  function getTokenIdFor(
    address _account
  ) external view returns (uint);

  /**
  * @dev Returns the key's ExpirationTimestamp field for a given owner.
  * @param _keyOwner address of the user for whom we search the key
  * @dev Returns 0 if the owner has never owned a key for this lock
  */
  function keyExpirationTimestampFor(
    address _keyOwner
  ) external view returns (uint timestamp);

  /**
   * Public function which returns the total number of unique owners (both expired
   * and valid).  This may be larger than totalSupply.
   */
  function numberOfOwners() external view returns (uint);

  /**
   * Allows a Lock manager to assign a descriptive name for this Lock.
   * @param _lockName The new name for the lock
   * @dev Throws if called by other than a Lock manager
   */
  function updateLockName(
    string calldata _lockName
  ) external;

  /**
   * Allows a Lock manager to assign a Symbol for this Lock.
   * @param _lockSymbol The new Symbol for the lock
   * @dev Throws if called by other than a Lock manager
   */
  function updateLockSymbol(
    string calldata _lockSymbol
  ) external;

  /**
    * @dev Gets the token symbol
    * @return string representing the token symbol
    */
  function symbol()
    external view
    returns(string memory);

    /**
   * Allows a Lock manager to update the baseTokenURI for this Lock.
   * @dev Throws if called by other than a Lock manager
   * @param _baseTokenURI String representing the base of the URI for this lock.
   */
  function setBaseTokenURI(
    string calldata _baseTokenURI
  ) external;

  /**  @notice A distinct Uniform Resource Identifier (URI) for a given asset.
   * @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC
   *  3986. The URI may point to a JSON file that conforms to the ""ERC721
   *  Metadata JSON Schema"".
   * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
   * @param _tokenId The tokenID we're inquiring about
   * @return String representing the URI for the requested token
   */
  function tokenURI(
    uint256 _tokenId
  ) external view returns(string memory);

  /**
   * @notice Allows a Lock manager to add or remove an event hook
   */
  function setEventHooks(
    address _onKeyPurchaseHook,
    address _onKeyCancelHook
  ) external;

  /**
   * Allows a Lock manager to give a collection of users a key with no charge.
   * Each key may be assigned a different expiration date.
   * @dev Throws if called by other than a Lock manager
   * @param _recipients An array of receiving addresses
   * @param _expirationTimestamps An array of expiration Timestamps for the keys being granted
   */
  function grantKeys(
    address[] calldata _recipients,
    uint[] calldata _expirationTimestamps,
    address[] calldata _keyManagers
  ) external;

  /**
  * @dev Purchase function
  * @param _value the number of tokens to pay for this purchase >= the current keyPrice - any applicable discount
  * (_value is ignored when using ETH)
  * @param _recipient address of the recipient of the purchased key
  * @param _referrer address of the user making the referral
  * @param _data arbitrary data populated by the front-end which initiated the sale
  * @dev Throws if lock is disabled. Throws if lock is sold-out. Throws if _recipient == address(0).
  * @dev Setting _value to keyPrice exactly doubles as a security feature. That way if a Lock manager increases the
  * price while my transaction is pending I can't be charged more than I expected (only applicable to ERC-20 when more
  * than keyPrice is approved for spending).
  */
  function purchase(
    uint256 _value,
    address _recipient,
    address _referrer,
    bytes calldata _data
  ) external payable;

  /**
   * @notice returns the minimum price paid for a purchase with these params.
   * @dev this considers any discount from Unlock or the OnKeyPurchase hook.
   */
  function purchasePriceFor(
    address _recipient,
    address _referrer,
    bytes calldata _data
  ) external view
    returns (uint);

  /**
   * Allow a Lock manager to change the transfer fee.
   * @dev Throws if called by other than a Lock manager
   * @param _transferFeeBasisPoints The new transfer fee in basis-points(bps).
   * Ex: 200 bps = 2%
   */
  function updateTransferFee(
    uint _transferFeeBasisPoints
  ) external;

  /**
   * Determines how much of a fee a key owner would need to pay in order to
   * transfer the key to another account.  This is pro-rated so the fee goes down
   * overtime.
   * @dev Throws if _keyOwner does not have a valid key
   * @param _keyOwner The owner of the key check the transfer fee for.
   * @param _time The amount of time to calculate the fee for.
   * @return The transfer fee in seconds.
   */
  function getTransferFee(
    address _keyOwner,
    uint _time
  ) external view returns (uint);

  /**
   * @dev Invoked by a Lock manager to expire the user's key and perform a refund and cancellation of the key
   * @param _keyOwner The key owner to whom we wish to send a refund to
   * @param amount The amount to refund the key-owner
   * @dev Throws if called by other than a Lock manager
   * @dev Throws if _keyOwner does not have a valid key
   */
  function expireAndRefundFor(
    address _keyOwner,
    uint amount
  ) external;

   /**
   * @dev allows the key manager to expire a given tokenId
   * and send a refund to the keyOwner based on the amount of time remaining.
   * @param _tokenId The id of the key to cancel.
   */
  function cancelAndRefund(uint _tokenId) external;

  /**
   * Allow a Lock manager to change the refund penalty.
   * @dev Throws if called by other than a Lock manager
   * @param _freeTrialLength The new duration of free trials for this lock
   * @param _refundPenaltyBasisPoints The new refund penaly in basis-points(bps)
   */
  function updateRefundPenalty(
    uint _freeTrialLength,
    uint _refundPenaltyBasisPoints
  ) external;

  /**
   * @dev Determines how much of a refund a key owner would receive if they issued
   * @param _keyOwner The key owner to get the refund value for.
   * a cancelAndRefund block.timestamp.
   * Note that due to the time required to mine a tx, the actual refund amount will be lower
   * than what the user reads from this call.
   */
  function getCancelAndRefundValueFor(
    address _keyOwner
  ) external view returns (uint refund);

  function addKeyGranter(address account) external;

  function addLockManager(address account) external;

  function isKeyGranter(address account) external view returns (bool);

  function isLockManager(address account) external view returns (bool);

  function onKeyPurchaseHook() external view returns(address);

  function onKeyCancelHook() external view returns(address);

  function revokeKeyGranter(address _granter) external;

  function renounceLockManager() external;

  ///===================================================================
  /// Auto-generated getter functions from public state variables

  function beneficiary() external view returns (address );

  function expirationDuration() external view returns (uint256 );

  function freeTrialLength() external view returns (uint256 );

  function isAlive() external view returns (bool );

  function keyPrice() external view returns (uint256 );

  function maxNumberOfKeys() external view returns (uint256 );

  function owners(uint256 ) external view returns (address );

  function refundPenaltyBasisPoints() external view returns (uint256 );

  function tokenAddress() external view returns (address );

  function transferFeeBasisPoints() external view returns (uint256 );

  function unlockProtocol() external view returns (address );

  function keyManagerOf(uint) external view returns (address );

  ///===================================================================

  /**
  * @notice Allows the key owner to safely share their key (parent key) by
  * transferring a portion of the remaining time to a new key (child key).
  * @dev Throws if key is not valid.
  * @dev Throws if `_to` is the zero address
  * @param _to The recipient of the shared key
  * @param _tokenId the key to share
  * @param _timeShared The amount of time shared
  * checks if `_to` is a smart contract (code size > 0). If so, it calls
  * `onERC721Received` on `_to` and throws if the return value is not
  * `bytes4(keccak256('onERC721Received(address,address,uint,bytes)'))`.
  * @dev Emit Transfer event
  */
  function shareKey(
    address _to,
    uint _tokenId,
    uint _timeShared
  ) external;

  /**
  * @notice Update transfer and cancel rights for a given key
  * @param _tokenId The id of the key to assign rights for
  * @param _keyManager The address to assign the rights to for the given key
  */
  function setKeyManagerOf(
    uint _tokenId,
    address _keyManager
  ) external;

  /// @notice A descriptive name for a collection of NFTs in this contract
  function name() external view returns (string memory _name);
  ///===================================================================

  /// From ERC165.sol
  function supportsInterface(bytes4 interfaceId) external view returns (bool);
  ///===================================================================

  /// From ERC-721
  /**
     * @dev Returns the number of NFTs in `owner`'s account.
     */
    function balanceOf(address _owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the NFT specified by `tokenId`.
     */
    function ownerOf(uint256 tokenId) external view returns (address _owner);

    /**
     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to
     * another (`to`).
     *
     * Requirements:
     * - `from`, `to` cannot be zero.
     * - `tokenId` must be owned by `from`.
     * - If the caller is not `from`, it must be have been allowed to move this
     * NFT by either {approve} or {setApprovalForAll}.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    
    /**
     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to
     * another (`to`).
     *
     * Requirements:
     * - If the caller is not `from`, it must be approved to move this NFT by
     * either {approve} or {setApprovalForAll}.
     */
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;

    /**
    * @notice Get the approved address for a single NFT
    * @dev Throws if `_tokenId` is not a valid NFT.
    * @param _tokenId The NFT to find the approved address for
    * @return operator The approved address for this NFT, or the zero address if there is none
    */
    function getApproved(uint256 _tokenId) external view returns (address operator);

    function setApprovalForAll(address operator, bool _approved) external;
    function isApprovedForAll(address _owner, address operator) external view returns (bool);

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;

    function totalSupply() external view returns (uint256);
    function tokenOfOwnerByIndex(address _owner, uint256 index) external view returns (uint256 tokenId);

    function tokenByIndex(uint256 index) external view returns (uint256);

    /**
    * Innherited from Open Zeppelin AccessControl.sol
     */
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function grantRole(bytes32 role, address account) external;
    function revokeRole(bytes32 role, address account) external;
    function renounceRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);

    /**
     * @notice An ERC-20 style transfer.
     * @param _value sends a token with _value * expirationDuration (the amount of time remaining on a standard purchase).
     * @dev The typical use case would be to call this with _value 1, which is on par with calling `transferFrom`. If the user
     * has more than `expirationDuration` time remaining this may use the `shareKey` function to send some but not all of the token.
     */
    function transfer(
      address _to,
      uint _value
    ) external
      returns (bool success);
}",3753
RealWorld_BA_54_UnlockProtocolTimelock_RealWord_20240821125443.log,54,UnlockProtocolTimelock,4492,4385,8877,73.0,0.11016,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import '@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol';

contract UnlockProtocolTimelock is TimelockControllerUpgradeable {
  function initialize (
    uint256 minDelay,
    address[] memory proposers,
    address[] memory executors
  ) public initializer {
    __TimelockController_init(minDelay, proposers, executors);
  }
}",100
RealWorld_BA_54_UnlockDiscountTokenV2_RealWord_20240821130128.log,54,UnlockDiscountTokenV2,10599,4824,15423,92.0,0.149475,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import './ERC20Patched.sol';

/**
* @title The Unlock Discount Token
* This smart contract implements the Unlock Discount Token
*/
contract UnlockDiscountTokenV2 is
ERC20MintableUpgradeable,
ERC20DetailedUpgradeable,
ERC20VotesCompUpgradeable
{
 /**
  * @notice A one-time call to configure the token.
  * @param _minter A wallet with permissions to mint tokens and/or add other minters.
  */
  function initialize(address _minter) public override initializer()
  {
    ERC20MintableUpgradeable.initialize(_minter);
    ERC20DetailedUpgradeable.initialize('Unlock Discount Token', 'UDT', 18);
    __ERC20Permit_init(name());
  }

  function initialize2() public {
      require(_EIP712NameHash() == bytes32(0), ""Already initialized: EIP712_init, ERC20Permit_init, ERC20Votes_init"");
      __EIP712_init_unsafe(name(), ""1"");
      __ERC20Permit_init_unsafe(name());
      __ERC20Votes_init_unsafe();
  }

  function name() public view override(IERC20MetadataUpgradeable, ERC20DetailedUpgradeable) returns (string memory) {
    return ERC20DetailedUpgradeable.name();
  }

  function symbol() public view override(IERC20MetadataUpgradeable, ERC20DetailedUpgradeable) returns (string memory) {
    return ERC20DetailedUpgradeable.symbol();
  }

  function decimals() public view override(ERC20Upgradeable, ERC20DetailedUpgradeable) returns (uint8) {
    return ERC20DetailedUpgradeable.decimals();
  }

  function _mint(address account, uint256 amount) internal virtual override(ERC20Upgradeable, ERC20VotesUpgradeable) {
    return ERC20VotesUpgradeable._mint(account, amount);
  }

  function _burn(address account, uint256 amount) internal virtual override(ERC20Upgradeable, ERC20VotesUpgradeable) {
    return ERC20VotesUpgradeable._burn(account, amount);
  }

  function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual override(ERC20Upgradeable, ERC20VotesUpgradeable) {
    return ERC20VotesUpgradeable._afterTokenTransfer(from, to, amount);
  }
}",492
RealWorld_BA_54_UnlockUtils_RealWord_20240821125958.log,54,UnlockUtils,11138,4951,16089,88.0,0.15471,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.17 <0.8.5;

// This contract provides some utility methods for use with the unlock protocol smart contracts.
// Borrowed from:
// https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol#L943

library UnlockUtils {

  function strConcat(
    string memory _a,
    string memory _b,
    string memory _c,
    string memory _d
  ) internal pure
    returns (string memory _concatenatedString)
  {
    return string(abi.encodePacked(_a, _b, _c, _d));
  }

  function uint2Str(
    uint _i
  ) internal pure
    returns (string memory _uintAsString)
  {
    // make a copy of the param to avoid security/no-assign-params error
    uint c = _i;
    if (_i == 0) {
      return '0';
    }
    uint j = _i;
    uint len;
    while (j != 0) {
      len++;
      j /= 10;
    }
    bytes memory bstr = new bytes(len);
    uint k = len;
    while (c != 0) {
        k = k-1;
        uint8 temp = (48 + uint8(c - c / 10 * 10));
        bytes1 b1 = bytes1(temp);
        bstr[k] = b1;
        c /= 10;
    }
    return string(bstr);
  }

  function address2Str(
    address _addr
  ) internal pure
    returns(string memory)
  {
    bytes32 value = bytes32(uint256(uint160(_addr)));
    bytes memory alphabet = '0123456789abcdef';
    bytes memory str = new bytes(42);
    str[0] = '0';
    str[1] = 'x';
    for (uint i = 0; i < 20; i++) {
      str[2+i*2] = alphabet[uint8(value[i + 12] >> 4)];
      str[3+i*2] = alphabet[uint8(value[i + 12] & 0x0f)];
    }
    return string(str);
  }
}",481
RealWorld_BA_54_IMintableERC20_RealWord_20240821133352.log,54,IMintableERC20,5102,5047,10149,78.0,0.12645,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.17 <0.9.0;

interface IMintableERC20
{
  function mint(address account, uint256 amount) external returns (bool);
  function transfer(address recipient, uint256 amount) external returns (bool);
  function totalSupply() external returns (uint);
  function balanceOf(address account) external returns (uint256);
}",84
RealWorld_BA_54_Unlock_RealWord_20240821130302.log,54,Unlock,63978,5649,69627,91.0,0.43287,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.2;

/**
 * @title The Unlock contract
 * @author Julien Genestoux (unlock-protocol.com)
 * This smart contract has 3 main roles:
 *  1. Distribute discounts to discount token holders
 *  2. Grant dicount tokens to users making referrals and/or publishers granting discounts.
 *  3. Create & deploy Public Lock contracts.
 * In order to achieve these 3 elements, it keeps track of several things such as
 *  a. Deployed locks addresses and balances of discount tokens granted by each lock.
 *  b. The total network product (sum of all key sales, net of discounts)
 *  c. Total of discounts granted
 *  d. Balances of discount tokens, including 'frozen' tokens (which have been used to claim
 * discounts and cannot be used/transferred for a given period)
 *  e. Growth rate of Network Product
 *  f. Growth rate of Discount tokens supply
 * The smart contract has an owner who only can perform the following
 *  - Upgrades
 *  - Change in golden rules (20% of GDP available in discounts, and supply growth rate is at most
 * 50% of GNP growth rate)
 * NOTE: This smart contract is partially implemented for now until enough Locks are deployed and
 * in the wild.
 * The partial implementation includes the following features:
 *  a. Keeping track of deployed locks
 *  b. Keeping track of GNP
 */

import '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';
import '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol';
import '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol';
import 'hardlydifficult-eth/contracts/protocols/Uniswap/IUniswapOracle.sol';
import './utils/UnlockOwnable.sol';
import './interfaces/IPublicLock.sol';
import './interfaces/IMintableERC20.sol';

/// @dev Must list the direct base contracts in the order from most base-like to most derived.
/// https://solidity.readthedocs.io/en/latest/contracts.html#multiple-inheritance-and-linearization
contract Unlock is
  Initializable,
  UnlockOwnable
{

  /**
   * The struct for a lock
   * We use deployed to keep track of deployments.
   * This is required because both totalSales and yieldedDiscountTokens are 0 when initialized,
   * which would be the same values when the lock is not set.
   */
  struct LockBalances
  {
    bool deployed;
    uint totalSales; // This is in wei
    uint yieldedDiscountTokens;
  }

  modifier onlyFromDeployedLock() {
    require(locks[msg.sender].deployed, 'ONLY_LOCKS');
    _;
  }

  uint public grossNetworkProduct;

  uint public totalDiscountGranted;

  // We keep track of deployed locks to ensure that callers are all deployed locks.
  mapping (address => LockBalances) public locks;

  // global base token URI
  // Used by locks where the owner has not set a custom base URI.
  string public globalBaseTokenURI;

  // global base token symbol
  // Used by locks where the owner has not set a custom symbol
  string public globalTokenSymbol;

  // The address of the latest public lock template, used by default when `createLock` is called
  address public publicLockAddress;

  // Map token address to oracle contract address if the token is supported
  // Used for GDP calculations
  mapping (address => IUniswapOracle) public uniswapOracles;

  // The WETH token address, used for value calculations
  address public weth;

  // The UDT token address, used to mint tokens on referral
  address public udt;

  // The approx amount of gas required to purchase a key
  uint public estimatedGasForPurchase;

  // Blockchain ID the network id on which this version of Unlock is operating
  uint public chainId;

  // store proxy admin
  address public proxyAdminAddress;
  ProxyAdmin private proxyAdmin;

  // publicLock templates
  mapping(address => uint16) private _publicLockVersions;
  mapping(uint16 => address) private _publicLockImpls;
  uint16 public publicLockLatestVersion;

  // Events
  event NewLock(
    address indexed lockOwner,
    address indexed newLockAddress
  );

  event LockUpgraded(
    address lockAddress,
    uint16 version
  );

  event ConfigUnlock(
    address udt,
    address weth,
    uint estimatedGasForPurchase,
    string globalTokenSymbol,
    string globalTokenURI,
    uint chainId
  );

  event SetLockTemplate(
    address publicLockAddress
  );

  event ResetTrackedValue(
    uint grossNetworkProduct,
    uint totalDiscountGranted
  );

  event UnlockTemplateAdded(
    address indexed impl,
    uint16 indexed version
  );

  // Use initialize instead of a constructor to support proxies (for upgradeability via OZ).
  function initialize(
    address _unlockOwner
  )
    public
    initializer()
  {
    // We must manually initialize Ownable
    UnlockOwnable.__initializeOwnable(_unlockOwner);
    // add a proxy admin on deployment
    _deployProxyAdmin();
  }

  function initializeProxyAdmin() public {
    require(proxyAdminAddress == address(0), ""ProxyAdmin already deployed"");
    _deployProxyAdmin();
  }

  /**
  * @dev Deploy the ProxyAdmin contract that will manage lock templates upgrades
  * This deploys an instance of ProxyAdmin used by PublicLock transparent proxies.
  */
  function _deployProxyAdmin() private returns(address) {
    proxyAdmin = new ProxyAdmin();
    proxyAdminAddress = address(proxyAdmin);
    return address(proxyAdmin);
  }

  /**
  * @dev Helper to get the version number of a template from his address
  */
  function publicLockVersions(address _impl) external view returns(uint16) {
    return _publicLockVersions[_impl];
  }

  /**
  * @dev Helper to get the address of a template based on its version number
  */
  function publicLockImpls(uint16 _version) external view returns(address) {
    return _publicLockImpls[_version];
  }

  /**
  * @dev Registers a new PublicLock template immplementation
  * The template is identified by a version number
  * Once registered, the template can be used to upgrade an existing Lock
  */
  function addLockTemplate(address impl, uint16 version) public onlyOwner {
    _publicLockVersions[impl] = version;
    _publicLockImpls[version] = impl;
    if (publicLockLatestVersion < version) publicLockLatestVersion = version;

    emit UnlockTemplateAdded(impl, version);
  }

  /**
  * @notice Create lock
  * This deploys a lock for a creator. It also keeps track of the deployed lock.
  * @param data bytes containing the call to initialize the lock template
  * @dev this call is passed as encoded function - for instance:
  *  bytes memory data = abi.encodeWithSignature(
  *    'initialize(address,uint256,address,uint256,uint256,string)',
  *    msg.sender,
  *    _expirationDuration,
  *    _tokenAddress,
  *    _keyPrice,
  *    _maxNumberOfKeys,
  *    _lockName
  *  );
  * @return address of the create lock
  */
  function createLock(
    bytes memory data
  ) public returns(address)
  {
    require(proxyAdminAddress != address(0), ""proxyAdmin is not set"");
    require(publicLockAddress != address(0), 'MISSING_LOCK_TEMPLATE');

    // deploy a proxy pointing to impl
    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(publicLockAddress, proxyAdminAddress, data);
    address payable newLock = payable(address(proxy));

    // assign the new Lock
    locks[newLock] = LockBalances({
      deployed: true, totalSales: 0, yieldedDiscountTokens: 0
    });

    // trigger event
    emit NewLock(msg.sender, newLock);
    return newLock;
  }

  /**
   * @dev Upgrade a Lock template implementation
   * @param lockAddress the address of the lock to be upgraded
   * @param version the version number of the template
   */
  function upgradeLock(address payable lockAddress, uint16 version) public returns(address) {
    require(proxyAdminAddress != address(0), ""proxyAdmin is not set"");

    // check perms
    require(_isLockManager(lockAddress, msg.sender) == true, ""caller is not a manager of this lock"");

    // check version
    IPublicLock lock = IPublicLock(lockAddress);
    uint16 currentVersion = lock.publicLockVersion();
    require( version == currentVersion + 1, 'version error: only +1 increments are allowed');

    // make our upgrade
    address impl = _publicLockImpls[version];
    TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(lockAddress);
    proxyAdmin.upgrade(proxy, impl);

    emit LockUpgraded(lockAddress, version);
    return lockAddress;
  }

  function _isLockManager(address lockAddress, address _sender) private view returns(bool isManager) {
    IPublicLock lock = IPublicLock(lockAddress);
    return lock.isLockManager(_sender);
  }

  /**
   * This function returns the discount available for a user, when purchasing a
   * a key from a lock.
   * This does not modify the state. It returns both the discount and the number of tokens
   * consumed to grant that discount.
   * TODO: actually implement this.
   */
  function computeAvailableDiscountFor(
    address /* _purchaser */,
    uint /* _keyPrice */
  )
    public
    pure
    returns (uint discount, uint tokens)
  {
    // TODO: implement me
    return (0, 0);
  }

  /**
   * This function keeps track of the added GDP, as well as grants of discount tokens
   * to the referrer, if applicable.
   * The number of discount tokens granted is based on the value of the referal,
   * the current growth rate and the lock's discount token distribution rate
   * This function is invoked by a previously deployed lock only.
   * TODO: actually implement
   */
  function recordKeyPurchase(
    uint _value,
    address _referrer
  )
    public
    onlyFromDeployedLock()
  {
    if(_value > 0) {
      uint valueInETH;
      address tokenAddress = IPublicLock(msg.sender).tokenAddress();
      if(tokenAddress != address(0) && tokenAddress != weth) {
        // If priced in an ERC-20 token, find the supported uniswap oracle
        IUniswapOracle oracle = uniswapOracles[tokenAddress];
        if(address(oracle) != address(0)) {
          valueInETH = oracle.updateAndConsult(tokenAddress, _value, weth);
        }
      }
      else {
        // If priced in ETH (or value is 0), no conversion is required
        valueInETH = _value;
      }

      grossNetworkProduct = grossNetworkProduct + valueInETH;
      // If GNP does not overflow, the lock totalSales should be safe
      locks[msg.sender].totalSales += valueInETH;

      // Mint UDT
      if(_referrer != address(0))
      {
        IUniswapOracle udtOracle = uniswapOracles[udt];
        if(address(udtOracle) != address(0))
        {
          // Get the value of 1 UDT (w/ 18 decimals) in ETH
          uint udtPrice = udtOracle.updateAndConsult(udt, 10 ** 18, weth);

          // tokensToDistribute is either == to the gas cost times 1.25 to cover the 20% dev cut
          uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice;

          // or tokensToDistribute is capped by network GDP growth
          uint maxTokens = 0;
          if (chainId > 1)
          {
            // non mainnet: we distribute tokens using asymptotic curve between 0 and 0.5
            // maxTokens = IMintableERC20(udt).balanceOf(address(this)).mul((valueInETH / grossNetworkProduct) / (2 + 2 * valueInETH / grossNetworkProduct));
            maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct;
          } else {
            // Mainnet: we mint new token using log curve
            maxTokens = IMintableERC20(udt).totalSupply() * valueInETH / 2 / grossNetworkProduct;
          }

          // cap to GDP growth!
          if(tokensToDistribute > maxTokens)
          {
            tokensToDistribute = maxTokens;
          }

          if(tokensToDistribute > 0)
          {
            // 80% goes to the referrer, 20% to the Unlock dev - round in favor of the referrer
            uint devReward = tokensToDistribute * 20 / 100;
            if (chainId > 1)
            {
              uint balance = IMintableERC20(udt).balanceOf(address(this));
              if (balance > tokensToDistribute) {
                // Only distribute if there are enough tokens
                IMintableERC20(udt).transfer(_referrer, tokensToDistribute - devReward);
                IMintableERC20(udt).transfer(owner(), devReward);
              }
            } else {
              // No distribnution
              IMintableERC20(udt).mint(_referrer, tokensToDistribute - devReward);
              IMintableERC20(udt).mint(owner(), devReward);
            }
          }
        }
      }
    }
  }

  /**
   * This function will keep track of consumed discounts by a given user.
   * It will also grant discount tokens to the creator who is granting the discount based on the
   * amount of discount and compensation rate.
   * This function is invoked by a previously deployed lock only.
   */
  function recordConsumedDiscount(
    uint _discount,
    uint /* _tokens */
  )
    public
    onlyFromDeployedLock()
  {
    // TODO: implement me
    totalDiscountGranted += _discount;
    return;
  }

  // The version number of the current Unlock implementation on this network
  function unlockVersion(
  ) external pure
    returns (uint16)
  {
    return 10;
  }

  /**
   * @notice Allows the owner to update configuration variables
   */
  function configUnlock(
    address _udt,
    address _weth,
    uint _estimatedGasForPurchase,
    string calldata _symbol,
    string calldata _URI,
    uint _chainId
  ) external
    onlyOwner
  {
    udt = _udt;
    weth = _weth;
    estimatedGasForPurchase = _estimatedGasForPurchase;

    globalTokenSymbol = _symbol;
    globalBaseTokenURI = _URI;

    chainId = _chainId;

    emit ConfigUnlock(_udt, _weth, _estimatedGasForPurchase, _symbol, _URI, _chainId);
  }

  /**
   * @notice Upgrade the PublicLock template used for future calls to `createLock`.
   * @dev This will initialize the template and revokeOwnership.
   */
  function setLockTemplate(
    address _publicLockAddress
  ) external
    onlyOwner
  {
    // First claim the template so that no-one else could
    // this will revert if the template was already initialized.
    IPublicLock(_publicLockAddress).initialize(
      address(this), 0, address(0), 0, 0, ''
    );
    IPublicLock(_publicLockAddress).renounceLockManager();

    publicLockAddress = _publicLockAddress;

    emit SetLockTemplate(_publicLockAddress);
  }

  /**
   * @notice allows the owner to set the oracle address to use for value conversions
   * setting the _oracleAddress to address(0) removes support for the token
   * @dev This will also call update to ensure at least one datapoint has been recorded.
   */
  function setOracle(
    address _tokenAddress,
    address _oracleAddress
  ) external
    onlyOwner
  {
    uniswapOracles[_tokenAddress] = IUniswapOracle(_oracleAddress);
    if(_oracleAddress != address(0)) {
      IUniswapOracle(_oracleAddress).update(_tokenAddress, weth);
    }
  }

  // Allows the owner to change the value tracking variables as needed.
  function resetTrackedValue(
    uint _grossNetworkProduct,
    uint _totalDiscountGranted
  ) external
    onlyOwner
  {
    grossNetworkProduct = _grossNetworkProduct;
    totalDiscountGranted = _totalDiscountGranted;

    emit ResetTrackedValue(_grossNetworkProduct, _totalDiscountGranted);
  }

  /**
   * @dev Redundant with globalBaseTokenURI() for backwards compatibility with v3 & v4 locks.
   */
  function getGlobalBaseTokenURI()
    external
    view
    returns (string memory)
  {
    return globalBaseTokenURI;
  }

  /**
   * @dev Redundant with globalTokenSymbol() for backwards compatibility with v3 & v4 locks.
   */
  function getGlobalTokenSymbol()
    external
    view
    returns (string memory)
  {
    return globalTokenSymbol;
  }
}",3808
RealWorld_BA_54_Migrations_RealWord_20240821125558.log,54,Migrations,4819,4215,9034,67.0,0.108395,"// SPDX-License-Identifier: MIT
pragma solidity 0.5.17;


contract Migrations {
  address public owner;
  uint public lastCompletedMigration;

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  constructor() public {
    owner = msg.sender;
  }

  function setCompleted(uint completed) public restricted {
    lastCompletedMigration = completed;
  }

  function upgrade(address newAddress) public restricted {
    Migrations upgraded = Migrations(newAddress);
    upgraded.setCompleted(lastCompletedMigration);
  }
}",112
RealWorld_BA_54_KeyManagerMock_RealWord_20240821130704.log,54,KeyManagerMock,4308,3915,8223,69.0,0.09984,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.17 <0.8.5;


import '../PublicLock.sol';

contract KeyManagerMock is
  PublicLock
{

  function isKeyManager(
    uint _tokenId,
    address _keyManager
  ) external view
    returns (bool)
  {
    return(_isKeyManager(_tokenId, _keyManager));
  }

}",84
RealWorld_BA_54_TestNoop_RealWord_20240821132621.log,54,TestNoop,4036,3305,7341,56.0,0.08628,"pragma solidity 0.5.17;


/**
 * This is an empty contract to be used in tests to see what happens
 * when an external contract does not have an API we expect.
 *
 * This contract should not be used in production.
 */
// solium-disable-next-line no-empty-blocks
contract TestNoop
{}",68
RealWorld_BA_54_MixinRoles_RealWord_20240821131111.log,54,MixinRoles,12332,5138,17470,77.0,0.16442,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// This contract mostly follows the pattern established by openzeppelin in
// openzeppelin/contracts-ethereum-package/contracts/access/roles

import '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';

contract MixinRoles is AccessControlUpgradeable {

  // roles
  bytes32 public constant LOCK_MANAGER_ROLE = keccak256(""LOCK_MANAGER"");
  bytes32 public constant KEY_GRANTER_ROLE = keccak256(""KEY_GRANTER"");

  // events
  event LockManagerAdded(address indexed account);
  event LockManagerRemoved(address indexed account);
  event KeyGranterAdded(address indexed account);
  event KeyGranterRemoved(address indexed account);

  // initializer
  function _initializeMixinRoles(address sender) internal {

    // for admin mamangers to add other lock admins
    _setRoleAdmin(LOCK_MANAGER_ROLE, LOCK_MANAGER_ROLE);

    // for lock managers to add/remove key granters
    _setRoleAdmin(KEY_GRANTER_ROLE, LOCK_MANAGER_ROLE);

    if (!isLockManager(sender)) {
      _setupRole(LOCK_MANAGER_ROLE, sender);  
    }
    if (!isKeyGranter(sender)) {
      _setupRole(KEY_GRANTER_ROLE, sender);
    }
  }

  // modifiers
  modifier onlyLockManager() {
    require( hasRole(LOCK_MANAGER_ROLE, msg.sender), 'MixinRoles: caller does not have the LockManager role');
    _;
  }

  modifier onlyKeyGranterOrManager() {
    require(isKeyGranter(msg.sender) || isLockManager(msg.sender), 'MixinRoles: caller does not have the KeyGranter or LockManager role');
    _;
  }


  // lock manager functions
  function isLockManager(address account) public view returns (bool) {
    return hasRole(LOCK_MANAGER_ROLE, account);
  }

  function addLockManager(address account) public onlyLockManager {
    grantRole(LOCK_MANAGER_ROLE, account);
    emit LockManagerAdded(account);
  }

  function renounceLockManager() public {
    renounceRole(LOCK_MANAGER_ROLE, msg.sender);
    emit LockManagerRemoved(msg.sender);
  }


  // key granter functions
  function isKeyGranter(address account) public view returns (bool) {
    return hasRole(KEY_GRANTER_ROLE, account);
  }

  function addKeyGranter(address account) public onlyLockManager {
    grantRole(KEY_GRANTER_ROLE, account);
    emit KeyGranterAdded(account);
  }

  function revokeKeyGranter(address _granter) public onlyLockManager {
    revokeRole(KEY_GRANTER_ROLE, _granter);
    emit KeyGranterRemoved(_granter);
  }
}",573
RealWorld_BA_54_PublicLock_RealWord_20240821125323.log,54,PublicLock,13972,5450,19422,78.0,0.17886,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import './interfaces/IPublicLock.sol';
import '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/utils/introspection/ERC165StorageUpgradeable.sol';
import './mixins/MixinDisable.sol';
import './mixins/MixinERC721Enumerable.sol';
import './mixins/MixinFunds.sol';
import './mixins/MixinGrantKeys.sol';
import './mixins/MixinKeys.sol';
import './mixins/MixinLockCore.sol';
import './mixins/MixinLockMetadata.sol';
import './mixins/MixinPurchase.sol';
import './mixins/MixinRefunds.sol';
import './mixins/MixinTransfer.sol';
import './mixins/MixinRoles.sol';


/**
 * @title The Lock contract
 * @author Julien Genestoux (unlock-protocol.com)
 * @dev ERC165 allows our contract to be queried to determine whether it implements a given interface.
 * Every ERC-721 compliant contract must implement the ERC165 interface.
 * https://eips.ethereum.org/EIPS/eip-721
 */
contract PublicLock is
  Initializable,
  ERC165StorageUpgradeable,
  MixinRoles,
  MixinFunds,
  MixinDisable,
  MixinLockCore,
  MixinKeys,
  MixinLockMetadata,
  MixinERC721Enumerable,
  MixinGrantKeys,
  MixinPurchase,
  MixinTransfer,
  MixinRefunds
{
  function initialize(
    address payable _lockCreator,
    uint _expirationDuration,
    address _tokenAddress,
    uint _keyPrice,
    uint _maxNumberOfKeys,
    string calldata _lockName
  ) public
    initializer()
  {
    MixinFunds._initializeMixinFunds(_tokenAddress);
    MixinDisable._initializeMixinDisable();
    MixinLockCore._initializeMixinLockCore(_lockCreator, _expirationDuration, _keyPrice, _maxNumberOfKeys);
    MixinLockMetadata._initializeMixinLockMetadata(_lockName);
    MixinERC721Enumerable._initializeMixinERC721Enumerable();
    MixinRefunds._initializeMixinRefunds();
    MixinRoles._initializeMixinRoles(_lockCreator);
    // registering the interface for erc721 with ERC165.sol using
    // the ID specified in the standard: https://eips.ethereum.org/EIPS/eip-721
    _registerInterface(0x80ac58cd);
  }

  /**
   * @notice Allow the contract to accept tips in ETH sent directly to the contract.
   * @dev This is okay to use even if the lock is priced in ERC-20 tokens
   */
  receive() external payable {}
  
  
  // TODO: what should be done here?
  fallback() external payable {}

  /**
   Overrides
  */
  function supportsInterface(bytes4 interfaceId) 
    public 
    view 
    virtual 
    override(
      MixinERC721Enumerable,
      MixinLockMetadata,
      AccessControlUpgradeable, 
      ERC165StorageUpgradeable
    ) 
    returns (bool) 
    {
    return super.supportsInterface(interfaceId);
  }

}",670
RealWorld_BA_54_ERC20Patched.template_RealWord_20240821134159.log,54,ERC20Patched.template,12029,5658,17687,76.0,0.173305,"pragma solidity ^0.8.0;

import '@openzeppelin/contracts-ethereum-package/contracts/access/Roles.sol';
// import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesCompUpgradeable.sol';

contract MinterRoleUpgradeable is Initializable, ContextUpgradeable {
    using Roles for Roles.Role;

    event MinterAdded(address indexed account);
    event MinterRemoved(address indexed account);

    Roles.Role private _minters;

    function initialize(address sender) public virtual initializer {
        if (!isMinter(sender)) {
            _addMinter(sender);
        }
    }

    modifier onlyMinter() {
        require(isMinter(_msgSender()), ""MinterRole: caller does not have the Minter role"");
        _;
    }

    function isMinter(address account) public view returns (bool) {
        return _minters.has(account);
    }

    function addMinter(address account) public onlyMinter {
        _addMinter(account);
    }

    function renounceMinter() public {
        _removeMinter(_msgSender());
    }

    function _addMinter(address account) internal {
        _minters.add(account);
        emit MinterAdded(account);
    }

    function _removeMinter(address account) internal {
        _minters.remove(account);
        emit MinterRemoved(account);
    }

    uint256[50] private ______gap;
}

abstract contract ERC20DetailedUpgradeable is Initializable, ERC20VotesUpgradeable {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    function initialize(string memory name, string memory symbol, uint8 decimals) public virtual initializer {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
    }

    function name() public view virtual returns (string memory) {
        return _name;
    }

    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

    function decimals() public view virtual returns (uint8) {
        return _decimals;
    }

    uint256[50] private ______gap;
}

abstract contract ERC20MintableUpgradeable is Initializable, ERC20VotesUpgradeable, MinterRoleUpgradeable {
    function initialize(address sender) public virtual override initializer {
        MinterRoleUpgradeable.initialize(sender);
    }

    function mint(address account, uint256 amount) public onlyMinter returns (bool) {
        _mint(account, amount);
        return true;
    }

    uint256[50] private ______gap;
}",555
RealWorld_BA_54_TestProxyAdmin_RealWord_20240821133001.log,54,TestProxyAdmin,3464,3993,7457,69.0,0.09718,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol"";

contract TestProxyAdmin is ProxyAdmin {}",40
RealWorld_BA_54_MixinKeys_RealWord_20240821132209.log,54,MixinKeys,49787,5361,55148,86.0,0.356155,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import './MixinLockCore.sol';


/**
 * @title Mixin for managing `Key` data, as well as the * Approval related functions needed to meet the ERC721
 * standard.
 * @author HardlyDifficult
 * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply
 * separates logically groupings of code to ease readability.
 */
contract MixinKeys is
  MixinLockCore
{
  // The struct for a key
  struct Key {
    uint tokenId;
    uint expirationTimestamp;
  }

  // Emitted when the Lock owner expires a user's Key
  event ExpireKey(uint indexed tokenId);

  // Emitted when the expiration of a key is modified
  event ExpirationChanged(
    uint indexed _tokenId,
    uint _amount,
    bool _timeAdded
  );

  event KeyManagerChanged(uint indexed _tokenId, address indexed _newManager);


  // Keys
  // Each owner can have at most exactly one key
  // TODO: could we use public here? (this could be confusing though because it getter will
  // return 0 values when missing a key)
  mapping (address => Key) internal keyByOwner;

  // Each tokenId can have at most exactly one owner at a time.
  // Returns 0 if the token does not exist
  // TODO: once we decouple tokenId from owner address (incl in js), then we can consider
  // merging this with totalSupply into an array instead.
  mapping (uint => address) internal _ownerOf;

  // Addresses of owners are also stored in an array.
  // Addresses are never removed by design to avoid abuses around referals
  address[] public owners;

  // A given key has both an owner and a manager.
  // If keyManager == address(0) then the key owner is also the manager
  // Each key can have at most 1 keyManager.
  mapping (uint => address) public keyManagerOf;

    // Keeping track of approved transfers
  // This is a mapping of addresses which have approved
  // the transfer of a key to another address where their key can be transferred
  // Note: the approver may actually NOT have a key... and there can only
  // be a single approved address
  mapping (uint => address) private approved;

    // Keeping track of approved operators for a given Key manager.
  // This approves a given operator for all keys managed by the calling ""keyManager""
  // The caller may not currently be the keyManager for ANY keys.
  // These approvals are never reset/revoked automatically, unlike ""approved"",
  // which is reset on transfer.
  mapping (address => mapping (address => bool)) private managerToOperatorApproved;

    // Ensure that the caller is the keyManager of the key
  // or that the caller has been approved
  // for ownership of that key
  modifier onlyKeyManagerOrApproved(
    uint _tokenId
  )
  {
    require(
      _isKeyManager(_tokenId, msg.sender) ||
      _isApproved(_tokenId, msg.sender) ||
      isApprovedForAll(_ownerOf[_tokenId], msg.sender),
      'ONLY_KEY_MANAGER_OR_APPROVED'
    );
    _;
  }

  // Ensures that an owner owns or has owned a key in the past
  modifier ownsOrHasOwnedKey(
    address _keyOwner
  ) {
    require(
      keyByOwner[_keyOwner].expirationTimestamp > 0, 'HAS_NEVER_OWNED_KEY'
    );
    _;
  }

  // Ensures that an owner has a valid key
  modifier hasValidKey(
    address _user
  ) {
    require(
      getHasValidKey(_user), 'KEY_NOT_VALID'
    );
    _;
  }

  // Ensures that a key has an owner
  modifier isKey(
    uint _tokenId
  ) {
    require(
      _ownerOf[_tokenId] != address(0), 'NO_SUCH_KEY'
    );
    _;
  }

  // Ensure that the caller owns the key
  modifier onlyKeyOwner(
    uint _tokenId
  ) {
    require(
      ownerOf(_tokenId) == msg.sender, 'ONLY_KEY_OWNER'
    );
    _;
  }

  /**
   * In the specific case of a Lock, each owner can own only at most 1 key.
   * @return The number of NFTs owned by `_keyOwner`, either 0 or 1.
  */
  function balanceOf(
    address _keyOwner
  )
    public
    view
    returns (uint)
  {
    require(_keyOwner != address(0), 'INVALID_ADDRESS');
    return getHasValidKey(_keyOwner) ? 1 : 0;
  }

  /**
   * Checks if the user has a non-expired key.
   */
  function getHasValidKey(
    address _keyOwner
  )
    public
    view
    returns (bool)
  {
    return keyByOwner[_keyOwner].expirationTimestamp > block.timestamp;
  }

  /**
   * @notice Find the tokenId for a given user
   * @return The tokenId of the NFT, else returns 0
  */
  function getTokenIdFor(
    address _account
  ) public view
    returns (uint)
  {
    return keyByOwner[_account].tokenId;
  }

  /**
  * @dev Returns the key's ExpirationTimestamp field for a given owner.
  * @param _keyOwner address of the user for whom we search the key
  * @dev Returns 0 if the owner has never owned a key for this lock
  */
  function keyExpirationTimestampFor(
    address _keyOwner
  ) public view
    returns (uint)
  {
    return keyByOwner[_keyOwner].expirationTimestamp;
  }

  /**
   * Public function which returns the total number of unique owners (both expired
   * and valid).  This may be larger than totalSupply.
   */
  function numberOfOwners()
    public
    view
    returns (uint)
  {
    return owners.length;
  }

  // Returns the owner of a given tokenId
  function ownerOf(
    uint _tokenId
  ) public view
    returns(address)
  {
    return _ownerOf[_tokenId];
  }

  /**
  * @notice Public function for updating transfer and cancel rights for a given key
  * @param _tokenId The id of the key to assign rights for
  * @param _keyManager The address with the manager's rights for the given key.
  * Setting _keyManager to address(0) means the keyOwner is also the keyManager
   */
  function setKeyManagerOf(
    uint _tokenId,
    address _keyManager
  ) public
    isKey(_tokenId)
  {
    require(
      _isKeyManager(_tokenId, msg.sender) ||
      isLockManager(msg.sender),
      'UNAUTHORIZED_KEY_MANAGER_UPDATE'
    );
    _setKeyManagerOf(_tokenId, _keyManager);
  }

  function _setKeyManagerOf(
    uint _tokenId,
    address _keyManager
  ) internal
  {
    if(keyManagerOf[_tokenId] != _keyManager) {
      keyManagerOf[_tokenId] = _keyManager;
      _clearApproval(_tokenId);
      emit KeyManagerChanged(_tokenId, address(0));
    }
  }

    /**
   * This approves _approved to get ownership of _tokenId.
   * Note: that since this is used for both purchase and transfer approvals
   * the approved token may not exist.
   */
  function approve(
    address _approved,
    uint _tokenId
  )
    public
    onlyIfAlive
    onlyKeyManagerOrApproved(_tokenId)
  {
    require(msg.sender != _approved, 'APPROVE_SELF');

    approved[_tokenId] = _approved;
    emit Approval(_ownerOf[_tokenId], _approved, _tokenId);
  }

    /**
   * @notice Get the approved address for a single NFT
   * @dev Throws if `_tokenId` is not a valid NFT.
   * @param _tokenId The NFT to find the approved address for
   * @return The approved address for this NFT, or the zero address if there is none
   */
  function getApproved(
    uint _tokenId
  ) public view
    isKey(_tokenId)
    returns (address)
  {
    address approvedRecipient = approved[_tokenId];
    return approvedRecipient;
  }

    /**
   * @dev Tells whether an operator is approved by a given keyManager
   * @param _owner owner address which you want to query the approval of
   * @param _operator operator address which you want to query the approval of
   * @return bool whether the given operator is approved by the given owner
   */
  function isApprovedForAll(
    address _owner,
    address _operator
  ) public view
    returns (bool)
  {
    uint tokenId = keyByOwner[_owner].tokenId;
    address keyManager = keyManagerOf[tokenId];
    if(keyManager == address(0)) {
      return managerToOperatorApproved[_owner][_operator];
    } else {
      return managerToOperatorApproved[keyManager][_operator];
    }
  }

  /**
  * Returns true if _keyManager is the manager of the key
  * identified by _tokenId
   */
  function _isKeyManager(
    uint _tokenId,
    address _keyManager
  ) internal view
    returns (bool)
  {
    if(keyManagerOf[_tokenId] == _keyManager ||
      (keyManagerOf[_tokenId] == address(0) && ownerOf(_tokenId) == _keyManager)) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * Assigns the key a new tokenId (from totalSupply) if it does not already have
   * one assigned.
   */
  function _assignNewTokenId(
    Key storage _key
  ) internal
  {
    if (_key.tokenId == 0) {
      // This is a brand new owner
      // We increment the tokenId counter
      _totalSupply++;
      // we assign the incremented `_totalSupply` as the tokenId for the new key
      _key.tokenId = _totalSupply;
    }
  }

  /**
   * Records the owner of a given tokenId
   */
  function _recordOwner(
    address _keyOwner,
    uint _tokenId
  ) internal
  {
    if (ownerOf(_tokenId) != _keyOwner) {
      // TODO: this may include duplicate entries
      owners.push(_keyOwner);
      // We register the owner of the tokenID
      _ownerOf[_tokenId] = _keyOwner;
    }
  }

  /**
  * @notice Modify the expirationTimestamp of a key
  * by a given amount.
  * @param _tokenId The ID of the key to modify.
  * @param _deltaT The amount of time in seconds by which
  * to modify the keys expirationTimestamp
  * @param _addTime Choose whether to increase or decrease
  * expirationTimestamp (false == decrease, true == increase)
  * @dev Throws if owner does not have a valid key.
  */
  function _timeMachine(
    uint _tokenId,
    uint256 _deltaT,
    bool _addTime
  ) internal
  {
    address tokenOwner = ownerOf(_tokenId);
    require(tokenOwner != address(0), 'NON_EXISTENT_KEY');
    Key storage key = keyByOwner[tokenOwner];
    uint formerTimestamp = key.expirationTimestamp;
    bool validKey = getHasValidKey(tokenOwner);
    if(_addTime) {
      if(validKey) {
        key.expirationTimestamp = formerTimestamp + _deltaT;
      } else {
        key.expirationTimestamp = block.timestamp + _deltaT;
      }
    } else {
      key.expirationTimestamp = formerTimestamp - _deltaT;
    }
    emit ExpirationChanged(_tokenId, _deltaT, _addTime);
  }

    /**
   * @dev Sets or unsets the approval of a given operator
   * An operator is allowed to transfer all tokens of the sender on their behalf
   * @param _to operator address to set the approval
   * @param _approved representing the status of the approval to be set
   */
  function setApprovalForAll(
    address _to,
    bool _approved
  ) public
    onlyIfAlive
  {
    require(_to != msg.sender, 'APPROVE_SELF');
    managerToOperatorApproved[msg.sender][_to] = _approved;
    emit ApprovalForAll(msg.sender, _to, _approved);
  }

    /**
   * @dev Checks if the given user is approved to transfer the tokenId.
   */
  function _isApproved(
    uint _tokenId,
    address _user
  ) internal view
    returns (bool)
  {
    return approved[_tokenId] == _user;
  }

    /**
   * @dev Function to clear current approval of a given token ID
   * @param _tokenId uint256 ID of the token to be transferred
   */
  function _clearApproval(
    uint256 _tokenId
  ) internal
  {
    if (approved[_tokenId] != address(0)) {
      approved[_tokenId] = address(0);
    }
  }
}",2842
RealWorld_BA_54_TestPublicLockUpgraded_RealWord_20240821132719.log,54,TestPublicLockUpgraded,4694,4164,8858,73.0,0.10675,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import 'hardhat/console.sol';
import ""../PublicLock.sol"";
import ""../interfaces/IPublicLock.sol"";

contract TestPublicLockUpgraded is PublicLock {

  // add a function to try
  function sayHello() external pure returns (string memory) {
    return 'hello world';
  }
}

interface ITestPublicLockUpgraded is IPublicLock {
  function sayHello() external pure returns (string memory);
}",102
RealWorld_BA_54_Clone2Factory_RealWord_20240821132337.log,54,Clone2Factory,15093,4834,19927,80.0,0.172145,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.2;


// From https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.sol
// Updated to support Solidity 5, switch to `create2` and revert on fail
library Clone2Factory
{
  /**
   * @notice Uses create2 to deploy a clone to a pre-determined address.
   * @param target the address of the template contract, containing the logic for this contract.
   * @param salt a salt used to determine the contract address before the transaction is mined,
   * may be random or sequential.
   * The salt to use with the create2 call can be `msg.sender+salt` in order to
   * prevent an attacker from front-running another user's deployment.
   * @return proxyAddress the address of the newly deployed contract.
   * @dev Using `bytes12` for the salt saves 6 gas over using `uint96` (requires another shift).
   * Will revert on fail.
   */
  function createClone2(
    address target,
    bytes32 salt
  ) internal
    returns (address proxyAddress)
  {
    // solium-disable-next-line
    assembly
    {
      let pointer := mload(0x40)

      // Create the bytecode for deployment based on the Minimal Proxy Standard (EIP-1167)
      // bytecode: 0x0
      mstore(pointer, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
      mstore(add(pointer, 0x14), shl(96, target))
      mstore(add(pointer, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)

      // `create2` consumes all available gas if called with a salt that's already been consumed
      // we check if the address is available first so that doesn't happen
      // Costs ~958 gas

      // Calculate the hash
      let contractCodeHash := keccak256(pointer, 0x37)

      // salt: 0x100
      mstore(add(pointer, 0x100), salt)

      // addressSeed: 0x40
      // 0xff
      mstore(add(pointer, 0x40), 0xff00000000000000000000000000000000000000000000000000000000000000)
      // this
      mstore(add(pointer, 0x41), shl(96, address()))
      // salt
      mstore(add(pointer, 0x55), mload(add(pointer, 0x100)))
      // hash
      mstore(add(pointer, 0x75), contractCodeHash)

      proxyAddress := keccak256(add(pointer, 0x40), 0x55)

      switch extcodesize(proxyAddress)
      case 0 {
        // Deploy the contract, returning the address or 0 on fail
        proxyAddress := create2(0, pointer, 0x37, mload(add(pointer, 0x100)))
      }
      default {
        proxyAddress := 0
      }
    }

    // Revert if the deployment fails (possible if salt was already used)
    require(proxyAddress != address(0), 'PROXY_DEPLOY_FAILED');
  }
}",730
RealWorld_BA_54_UnlockOwnable_RealWord_20240821132459.log,54,UnlockOwnable,13527,5167,18694,80.0,0.170975,"// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.3.2 (access/Ownable.sol)

pragma solidity ^0.8.0;

import '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be aplied to your functions to restrict their use to
 * the owner.
 * 
 * This contract was originally part of openzeppelin/contracts-ethereum-package
 * but had to be included (instead of using the one in openzeppelin/contracts-upgradeable ) 
 * because the ______gap array length was 49 instead of 50
 */
abstract contract UnlockOwnable is Initializable, ContextUpgradeable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    function __initializeOwnable(address sender) public initializer {
        _owner = sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(isOwner(), ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Returns true if the caller is the current owner.
     */
    function isOwner() public view returns (bool) {
        return _msgSender() == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * > Note: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
      require(newOwner != address(0), ""Ownable: new owner is the zero address"");
      _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }

    uint256[50] private ______gap;
}",649
RealWorld_BA_54_UnlockUtilsMock_RealWord_20240821130548.log,54,UnlockUtilsMock,6328,4603,10931,74.0,0.1237,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.17 <0.8.5;


import '../UnlockUtils.sol';

// For testing only.
contract UnlockUtilsMock
{
  using UnlockUtils for uint;
  using UnlockUtils for address;
  using UnlockUtils for string;

  function strConcat(
    string memory _a,
    string memory _b,
    string memory _c,
    string memory _d
  ) public pure
    returns (string memory _concatenatedString)
  {
    return _a.strConcat(_b, _c, _d);
  }

  function uint2Str(
    uint _i
  ) public pure
    returns (string memory _uintAsString)
  {
    return _i.uint2Str();
  }

  function address2Str(
    address _addr
  ) public pure
    returns(string memory)
  {
    return _addr.address2Str();
  }
}",195
RealWorld_BA_54_TestErc20Noop_RealWord_20240821133237.log,54,TestErc20Noop,7247,4580,11827,73.0,0.127835,"pragma solidity 0.5.17;


/**
 * This is an implementation of the ERC20 interface but without any data
 * backing the token to be used in tests.
 *
 * This contract should not be used in production.
 */
contract TestErc20Noop
{
  uint suppressCompileWarning;

  function transfer(
    address /* to */,
    uint /* value */
  ) external
    returns (bool)
  {
    suppressCompileWarning++;
    return true;
  }

  function approve(
    address /* spender */,
    uint /* value */
  ) external
    returns (bool)
  {
    suppressCompileWarning++;
    return true;
  }

  function mint(
    address /* to */,
    uint /* value */
  ) public
    returns (bool)
  {
    suppressCompileWarning++;
    return true;
  }

  function transferFrom(
    address /* from */,
    address /* to */,
    uint /* value */
  ) external
    returns (bool)
  {
    suppressCompileWarning++;
    return true;
  }

  function balanceOf(
    address /* who */
  ) external view
    returns (uint)
  {
    require(suppressCompileWarning >= 0, 'Suppressing the Solidity compile warning');
    return uint(-1);
  }
}",263
RealWorld_BA_54_UnlockProtocolGovernor_RealWord_20240821125834.log,54,UnlockProtocolGovernor,19703,5511,25214,82.0,0.208735,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.2;

import '@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/governance/extensions/GovernorCountingSimpleUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';

contract UnlockProtocolGovernor is Initializable,
  GovernorUpgradeable,
  GovernorCountingSimpleUpgradeable,
  GovernorVotesUpgradeable,
  GovernorTimelockControlUpgradeable
  {

  uint256 _votingDelay;
  uint256 _votingPeriod;
  uint256 _quorum;

  function initialize(ERC20VotesUpgradeable _token, TimelockControllerUpgradeable _timelock)
    public initializer
  {
    __Governor_init('Unlock Protocol Governor');
    __GovernorCountingSimple_init();
    __GovernorVotes_init(_token);
    __GovernorTimelockControl_init(_timelock);

    _votingDelay = 1; // 1 block
    _votingPeriod = 45818; // 1 week
    _quorum = 15000e18; // 15k UDT
  }

  /*
  * Events to track params changes
  */
  event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);
  event VotingDelayUpdated(uint256 oldVotingDelay, uint256 newVotingDelay);
  event VotingPeriodUpdated(uint256 oldVotingPeriod, uint256 newVotingPeriod);

  function votingDelay() public view override returns (uint256) {
    return _votingDelay;
  }

  function votingPeriod() public view override returns (uint256) {
    return _votingPeriod;
  }

  function quorum(uint256 blockNumber) public view override returns (uint256) {
    require(blockNumber < block.number, 'ERC20Votes: block not yet mined');
    return _quorum;
  }

  // governance setters
  function setVotingDelay(uint256 newVotingDelay) public onlyGovernance {
    uint256 oldVotingDelay = _votingDelay;
    _votingDelay = newVotingDelay;
    emit VotingDelayUpdated(oldVotingDelay, newVotingDelay);
  }

  function setVotingPeriod(uint256 newVotingPeriod) public onlyGovernance {
    uint256 oldVotingPeriod = _votingPeriod;
    _votingPeriod = newVotingPeriod;
    emit VotingPeriodUpdated(oldVotingPeriod, newVotingPeriod);
  }

  function setQuorum(uint256 newQuorum) public onlyGovernance {
    uint256 oldQuorum = _quorum;
    _quorum = newQuorum;
    emit QuorumUpdated(oldQuorum, newQuorum);
  }

  // The following functions are overrides required by Solidity.
  function getVotes(address account, uint256 blockNumber)
    public
    view
    override(IGovernorUpgradeable, GovernorVotesUpgradeable)
    returns (uint256)
  {
    return super.getVotes(account, blockNumber);
  }

  function state(uint256 proposalId)
    public
    view
    override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)
    returns (ProposalState)
  {
    return super.state(proposalId);
  }

  function propose(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description)
    public
    override(GovernorUpgradeable, IGovernorUpgradeable)
    returns (uint256)
  {
    return super.propose(targets, values, calldatas, description);
  }

  function _execute(uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)
    internal
    override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)
  {
    super._execute(proposalId, targets, values, calldatas, descriptionHash);
  }

  function _cancel(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)
    internal
    override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)
    returns (uint256)
  {
    return super._cancel(targets, values, calldatas, descriptionHash);
  }

  function _executor()
    internal
    view
    override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)
    returns (address)
  {
    return super._executor();
  }

  function supportsInterface(bytes4 interfaceId)
    public
    view
    override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)
    returns (bool)
  {
    return super.supportsInterface(interfaceId);
  }
}",1080
RealWorld_BA_54_UnlockDiscountToken_RealWord_20240821125209.log,54,UnlockDiscountToken,5632,4832,10464,72.0,0.1248,"// SPDX-License-Identifier: MIT
pragma solidity 0.5.17;

import '@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Mintable.sol';
import '@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Detailed.sol';


/**
* @title The Unlock Discount Token
* This smart contract implements the Unlock Discount Token
*/
contract UnlockDiscountToken is
ERC20Mintable,
ERC20Detailed
{
  /**
   * @notice A one-time call to configure the token.
   * @param _minter A wallet with permissions to mint tokens and/or add other minters.
   */
  function initialize(address _minter) public initializer()
  {
    ERC20Mintable.initialize(_minter);
    ERC20Detailed.initialize('Unlock Discount Token', 'UDT', 18);
  }
}",181
RealWorld_BA_54_MixinRefunds_RealWord_20240821131511.log,54,MixinRefunds,20286,5001,25287,74.0,0.20145,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import './MixinKeys.sol';
import './MixinLockCore.sol';
import './MixinRoles.sol';
import './MixinFunds.sol';


contract MixinRefunds is
  MixinRoles,
  MixinFunds,
  MixinLockCore,
  MixinKeys
{
  // CancelAndRefund will return funds based on time remaining minus this penalty.
  // This is calculated as `proRatedRefund * refundPenaltyBasisPoints / BASIS_POINTS_DEN`.
  uint public refundPenaltyBasisPoints;

  uint public freeTrialLength;

  event CancelKey(
    uint indexed tokenId,
    address indexed owner,
    address indexed sendTo,
    uint refund
  );

  event RefundPenaltyChanged(
    uint freeTrialLength,
    uint refundPenaltyBasisPoints
  );

  function _initializeMixinRefunds() internal
  {
    // default to 10%
    refundPenaltyBasisPoints = 1000;
  }

  /**
   * @dev Invoked by the lock owner to destroy the user's ket and perform a refund and cancellation
   * of the key
   */
  function expireAndRefundFor(
    address payable _keyOwner,
    uint amount
  ) external
    onlyLockManager
    hasValidKey(_keyOwner)
  {
    _cancelAndRefund(_keyOwner, amount);
  }

  /**
   * @dev Destroys the key and sends a refund based on the amount of time remaining.
   * @param _tokenId The id of the key to cancel.
   */
  function cancelAndRefund(uint _tokenId)
    external
    onlyKeyManagerOrApproved(_tokenId)
  {
    address payable keyOwner = payable(ownerOf(_tokenId));
    uint refund = _getCancelAndRefundValue(keyOwner);

    _cancelAndRefund(keyOwner, refund);
  }

  /**
   * Allow the owner to change the refund penalty.
   */
  function updateRefundPenalty(
    uint _freeTrialLength,
    uint _refundPenaltyBasisPoints
  ) external
    onlyLockManager
  {
    emit RefundPenaltyChanged(
      _freeTrialLength,
      _refundPenaltyBasisPoints
    );

    freeTrialLength = _freeTrialLength;
    refundPenaltyBasisPoints = _refundPenaltyBasisPoints;
  }

  /**
   * @dev Determines how much of a refund a key owner would receive if they issued
   * a cancelAndRefund block.timestamp.
   * Note that due to the time required to mine a tx, the actual refund amount will be lower
   * than what the user reads from this call.
   */
  function getCancelAndRefundValueFor(
    address _keyOwner
  )
    external view
    returns (uint refund)
  {
    return _getCancelAndRefundValue(_keyOwner);
  }

  /**
   * @dev cancels the key for the given keyOwner and sends the refund to the msg.sender.
   */
  function _cancelAndRefund(
    address payable _keyOwner,
    uint refund
  ) internal
  {
    Key storage key = keyByOwner[_keyOwner];

    emit CancelKey(key.tokenId, _keyOwner, msg.sender, refund);
    // expirationTimestamp is a proxy for hasKey, setting this to `block.timestamp` instead
    // of 0 so that we can still differentiate hasKey from hasValidKey.
    key.expirationTimestamp = block.timestamp;

    if (refund > 0) {
      // Security: doing this last to avoid re-entrancy concerns
      _transfer(tokenAddress, _keyOwner, refund);
    }

    // inform the hook if there is one registered
    if(address(onKeyCancelHook) != address(0))
    {
      onKeyCancelHook.onKeyCancel(msg.sender, _keyOwner, refund);
    }
  }

  /**
   * @dev Determines how much of a refund a key owner would receive if they issued
   * a cancelAndRefund now.
   * @param _keyOwner The owner of the key check the refund value for.
   */
  function _getCancelAndRefundValue(
    address _keyOwner
  )
    private view
    hasValidKey(_keyOwner)
    returns (uint refund)
  {
    Key storage key = keyByOwner[_keyOwner];
    // Math: safeSub is not required since `hasValidKey` confirms timeRemaining is positive
    uint timeRemaining = key.expirationTimestamp - block.timestamp;
    if(timeRemaining + freeTrialLength >= expirationDuration) {
      refund = keyPrice;
    } else {
      refund = keyPrice * timeRemaining / expirationDuration;
    }

    // Apply the penalty if this is not a free trial
    if(freeTrialLength == 0 || timeRemaining + freeTrialLength < expirationDuration)
    {
      uint penalty = keyPrice * refundPenaltyBasisPoints / BASIS_POINTS_DEN;
      if (refund > penalty) {
        refund -= penalty;
      } else {
        refund = 0;
      }
    }
  }
}",1081
RealWorld_BA_54_MixinTransfer_RealWord_20240821131230.log,54,MixinTransfer,43466,5784,49250,84.0,0.33301,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import './MixinRoles.sol';
import './MixinDisable.sol';
import './MixinKeys.sol';
import './MixinFunds.sol';
import './MixinLockCore.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';

/**
 * @title Mixin for the transfer-related functions needed to meet the ERC721
 * standard.
 * @author Nick Furfaro
 * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply
 * separates logically groupings of code to ease readability.
 */

contract MixinTransfer is
  MixinRoles,
  MixinFunds,
  MixinLockCore,
  MixinKeys
{
  using AddressUpgradeable for address;

  event TransferFeeChanged(
    uint transferFeeBasisPoints
  );

  // 0x150b7a02 == bytes4(keccak256('onERC721Received(address,address,uint256,bytes)'))
  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;

  // The fee relative to keyPrice to charge when transfering a Key to another account
  // (potentially on a 0x marketplace).
  // This is calculated as `keyPrice * transferFeeBasisPoints / BASIS_POINTS_DEN`.
  uint public transferFeeBasisPoints;

  /**
  * @notice Allows the key owner to safely share their key (parent key) by
  * transferring a portion of the remaining time to a new key (child key).
  * @param _to The recipient of the shared key
  * @param _tokenId the key to share
  * @param _timeShared The amount of time shared
  */
  function shareKey(
    address _to,
    uint _tokenId,
    uint _timeShared
  ) public
    onlyIfAlive
    onlyKeyManagerOrApproved(_tokenId)
  {
    require(transferFeeBasisPoints < BASIS_POINTS_DEN, 'KEY_TRANSFERS_DISABLED');
    require(_to != address(0), 'INVALID_ADDRESS');
    address keyOwner = _ownerOf[_tokenId];
    require(getHasValidKey(keyOwner), 'KEY_NOT_VALID');
    Key storage fromKey = keyByOwner[keyOwner];
    Key storage toKey = keyByOwner[_to];
    uint idTo = toKey.tokenId;
    uint time;
    // get the remaining time for the origin key
    uint timeRemaining = fromKey.expirationTimestamp - block.timestamp;
    // get the transfer fee based on amount of time wanted share
    uint fee = getTransferFee(keyOwner, _timeShared);
    uint timePlusFee = _timeShared + fee;

    // ensure that we don't try to share too much
    if(timePlusFee < timeRemaining) {
      // now we can safely set the time
      time = _timeShared;
      // deduct time from parent key, including transfer fee
      _timeMachine(_tokenId, timePlusFee, false);
    } else {
      // we have to recalculate the fee here
      fee = getTransferFee(keyOwner, timeRemaining);
      time = timeRemaining - fee;
      fromKey.expirationTimestamp = block.timestamp; // Effectively expiring the key
      emit ExpireKey(_tokenId);
    }

    if (idTo == 0) {
      _assignNewTokenId(toKey);
      idTo = toKey.tokenId;
      _recordOwner(_to, idTo);
      emit Transfer(
        address(0), // This is a creation or time-sharing
        _to,
        idTo
      );
    } else if (toKey.expirationTimestamp <= block.timestamp) {
      // reset the key Manager for expired keys
      _setKeyManagerOf(idTo, address(0));
    }

    // add time to new key
    _timeMachine(idTo, time, true);
    // trigger event
    emit Transfer(
      keyOwner,
      _to,
      idTo
    );

    require(_checkOnERC721Received(keyOwner, _to, _tokenId, ''), 'NON_COMPLIANT_ERC721_RECEIVER');
  }

  function transferFrom(
    address _from,
    address _recipient,
    uint _tokenId
  )
    public
    onlyIfAlive
    hasValidKey(_from)
    onlyKeyManagerOrApproved(_tokenId)
  {
    require(ownerOf(_tokenId) == _from, 'TRANSFER_FROM: NOT_KEY_OWNER');
    require(transferFeeBasisPoints < BASIS_POINTS_DEN, 'KEY_TRANSFERS_DISABLED');
    require(_recipient != address(0), 'INVALID_ADDRESS');
    uint fee = getTransferFee(_from, 0);

    Key storage fromKey = keyByOwner[_from];
    Key storage toKey = keyByOwner[_recipient];

    uint previousExpiration = toKey.expirationTimestamp;
    // subtract the fee from the senders key before the transfer
    _timeMachine(_tokenId, fee, false);

    if (toKey.tokenId == 0) {
      toKey.tokenId = _tokenId;
      _recordOwner(_recipient, _tokenId);
      // Clear any previous approvals
      _clearApproval(_tokenId);
    }

    if (previousExpiration <= block.timestamp) {
      // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration
      // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID
      toKey.expirationTimestamp = fromKey.expirationTimestamp;
      toKey.tokenId = _tokenId;

      // Reset the key Manager to the key owner
      _setKeyManagerOf(_tokenId, address(0));

      _recordOwner(_recipient, _tokenId);
    } else {
      // The recipient has a non expired key. We just add them the corresponding remaining time
      // SafeSub is not required since the if confirms `previousExpiration - block.timestamp` cannot underflow
      toKey.expirationTimestamp = fromKey.expirationTimestamp + previousExpiration - block.timestamp;
    }

    // Effectively expiring the key for the previous owner
    fromKey.expirationTimestamp = block.timestamp;

    // Set the tokenID to 0 for the previous owner to avoid duplicates
    fromKey.tokenId = 0;

    // trigger event
    emit Transfer(
      _from,
      _recipient,
      _tokenId
    );
  }

  /**
   * @notice An ERC-20 style transfer.
   * @param _value sends a token with _value * expirationDuration (the amount of time remaining on a standard purchase).
   * @dev The typical use case would be to call this with _value 1, which is on par with calling `transferFrom`. If the user
   * has more than `expirationDuration` time remaining this may use the `shareKey` function to send some but not all of the token.
   */
  function transfer(
    address _to,
    uint _value
  ) public
    returns (bool success)
  {
    uint maxTimeToSend = _value * expirationDuration;
    Key storage fromKey = keyByOwner[msg.sender];
    uint timeRemaining = fromKey.expirationTimestamp - block.timestamp;
    if(maxTimeToSend < timeRemaining)
    {
      shareKey(_to, fromKey.tokenId, maxTimeToSend);
    }
    else
    {
      transferFrom(msg.sender, _to, fromKey.tokenId);
    }

    // Errors will cause a revert
    return true;
  }

  /**
  * @notice Transfers the ownership of an NFT from one address to another address
  * @dev This works identically to the other function with an extra data parameter,
  *  except this function just sets data to ''
  * @param _from The current owner of the NFT
  * @param _to The new owner
  * @param _tokenId The NFT to transfer
  */
  function safeTransferFrom(
    address _from,
    address _to,
    uint _tokenId
  )
    public
  {
    safeTransferFrom(_from, _to, _tokenId, '');
  }

  /**
  * @notice Transfers the ownership of an NFT from one address to another address.
  * When transfer is complete, this functions
  *  checks if `_to` is a smart contract (code size > 0). If so, it calls
  *  `onERC721Received` on `_to` and throws if the return value is not
  *  `bytes4(keccak256('onERC721Received(address,address,uint,bytes)'))`.
  * @param _from The current owner of the NFT
  * @param _to The new owner
  * @param _tokenId The NFT to transfer
  * @param _data Additional data with no specified format, sent in call to `_to`
  */
  function safeTransferFrom(
    address _from,
    address _to,
    uint _tokenId,
    bytes memory _data
  )
    public
  {
    transferFrom(_from, _to, _tokenId);
    require(_checkOnERC721Received(_from, _to, _tokenId, _data), 'NON_COMPLIANT_ERC721_RECEIVER');

  }

  /**
   * Allow the Lock owner to change the transfer fee.
   */
  function updateTransferFee(
    uint _transferFeeBasisPoints
  )
    external
    onlyLockManager
  {
    emit TransferFeeChanged(
      _transferFeeBasisPoints
    );
    transferFeeBasisPoints = _transferFeeBasisPoints;
  }

  /**
   * Determines how much of a fee a key owner would need to pay in order to
   * transfer the key to another account.  This is pro-rated so the fee goes down
   * overtime.
   * @param _keyOwner The owner of the key check the transfer fee for.
   */
  function getTransferFee(
    address _keyOwner,
    uint _time
  )
    public view
    returns (uint)
  {
    if(! getHasValidKey(_keyOwner)) {
      return 0;
    } else {
      Key storage key = keyByOwner[_keyOwner];
      uint timeToTransfer;
      uint fee;
      // Math: safeSub is not required since `hasValidKey` confirms timeToTransfer is positive
      // this is for standard key transfers
      if(_time == 0) {
        timeToTransfer = key.expirationTimestamp - block.timestamp;
      } else {
        timeToTransfer = _time;
      }
      fee = timeToTransfer * transferFeeBasisPoints / BASIS_POINTS_DEN;
      return fee;
    }
  }

  /**
   * @dev Internal function to invoke `onERC721Received` on a target address
   * The call is not executed if the target address is not a contract
   * @param from address representing the previous owner of the given token ID
   * @param to target address that will receive the tokens
   * @param tokenId uint256 ID of the token to be transferred
   * @param _data bytes optional data to send along with the call
   * @return whether the call correctly returned the expected magic value
   */
  function _checkOnERC721Received(
    address from,
    address to,
    uint256 tokenId,
    bytes memory _data
  )
    internal
    returns (bool)
  {
    if (!to.isContract()) {
      return true;
    }
    bytes4 retval = IERC721ReceiverUpgradeable(to).onERC721Received(
      msg.sender, from, tokenId, _data);
    return (retval == _ERC721_RECEIVED);
  }

}",2495
RealWorld_BA_54_TestEventHooks_RealWord_20240821132835.log,54,TestEventHooks,10259,5356,15615,84.0,0.158415,"pragma solidity 0.5.17;

import '../interfaces/hooks/ILockKeyPurchaseHook.sol';
import '../interfaces/hooks/ILockKeyCancelHook.sol';
import '../interfaces/IPublicLock.sol';


/**
 * @title Test contract for lock event hooks.
 * @author Nick Mancuso (unlock-protocol.com)
 */
contract TestEventHooks is ILockKeyPurchaseHook, ILockKeyCancelHook
{
  event OnKeyPurchase(
    address lock,
    address from,
    address recipient,
    address referrer,
    uint minKeyPrice,
    uint pricePaid
  );
  event OnKeyCancel(
    address lock,
    address operator,
    address to,
    uint refund
  );

  uint public discount;
  bool public isPurchaseSupported;

  function configure(
    bool _isPurchaseSupported,
    uint _discount
  ) public
  {
    isPurchaseSupported = _isPurchaseSupported;
    discount = _discount;
  }

  function onKeyPurchase(
    address _from,
    address _recipient,
    address _referrer,
    bytes calldata /*_data*/,
    uint _minKeyPrice,
    uint _pricePaid
  ) external
  {
    emit OnKeyPurchase(msg.sender, _from, _recipient, _referrer, _minKeyPrice, _pricePaid);
  }

  function keyPurchasePrice(
    address /*from*/,
    address /*recipient*/,
    address /*referrer*/,
    bytes calldata /*data*/
  ) external view
    returns (uint minKeyPrice)
  {
    require(isPurchaseSupported, 'PURCHASE_BLOCKED_BY_HOOK');
    minKeyPrice = IPublicLock(msg.sender).keyPrice();
    if(discount < minKeyPrice)
    {
      minKeyPrice -= discount;
    }
    else
    {
      minKeyPrice = 0;
    }
  }

  function onKeyCancel(
    address _operator,
    address _to,
    uint _refund
  ) external
  {
    emit OnKeyCancel(msg.sender, _operator, _to, _refund);
  }
}",427
RealWorld_BA_54_TimeMachineMock_RealWord_20240821130435.log,54,TimeMachineMock,4283,3966,8249,71.0,0.100735,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.17 <0.8.5;

import '../PublicLock.sol';

contract TimeMachineMock is
  PublicLock
{
  function timeMachine(
    uint _tokenId,
    uint256 _deltaT,
    bool _addTime
  ) public
  {
    _timeMachine(_tokenId, _deltaT, _addTime);
  }
}",86
RealWorld_BA_54_MixinDisable_RealWord_20240821131929.log,54,MixinDisable,7197,4946,12143,78.0,0.134905,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import './MixinFunds.sol';
import './MixinRoles.sol';

/**
 * @title Mixin allowing the Lock owner to disable a Lock (preventing new purchases)
 * and then destroy it.
 * @author HardlyDifficult
 * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply
 * separates logically groupings of code to ease readability.
 */
contract MixinDisable is
  MixinRoles,
  MixinFunds
{
  // Used to disable payable functions when deprecating an old lock
  bool public isAlive;

  event Disable();

  function _initializeMixinDisable(
  ) internal
  {
    isAlive = true;
  }

  // Only allow usage when contract is Alive
  modifier onlyIfAlive() {
    require(isAlive, 'LOCK_DEPRECATED');
    _;
  }

  /**
  * @dev Used to disable lock before migrating keys and/or destroying contract
   */
  function disableLock()
    external
    onlyLockManager
    onlyIfAlive
  {
    emit Disable();
    isAlive = false;
  }
}",246
RealWorld_BA_54_TestErc20PausableToken_RealWord_20240821133113.log,54,TestErc20PausableToken,5022,4858,9880,81.0,0.12227,"pragma solidity 0.5.17;

import '@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Mintable.sol';
import '@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Pausable.sol';


/**
 * This is an implementation of a ERC20 token with mint and pause capabilities
 * to be used in tests.
 *
 * This contract should not be used in production.
 */
contract TestErc20PausableToken is
  ERC20Mintable,
  ERC20Pausable
{
  constructor() public
  {
    ERC20Pausable.initialize(msg.sender);
    ERC20Mintable.initialize(msg.sender);
  }
}",149
RealWorld_BA_54_MixinFunds_RealWord_20240821131356.log,54,MixinFunds,9339,5023,14362,73.0,0.147155,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';
import '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol';


/**
 * @title An implementation of the money related functions.
 * @author HardlyDifficult (unlock-protocol.com)
 */
contract MixinFunds
{
  using AddressUpgradeable for address payable;
  using SafeERC20Upgradeable for IERC20Upgradeable;

  /**
   * The token-type that this Lock is priced in.  If 0, then use ETH, else this is
   * a ERC20 token address.
   */
  address public tokenAddress;

  function _initializeMixinFunds(
    address _tokenAddress
  ) internal
  {
    tokenAddress = _tokenAddress;
    require(
      _tokenAddress == address(0) || IERC20Upgradeable(_tokenAddress).totalSupply() > 0,
      'INVALID_TOKEN'
    );
  }

  /**
   * Transfers funds from the contract to the account provided.
   *
   * Security: be wary of re-entrancy when calling this function.
   */
  function _transfer(
    address _tokenAddress,
    address payable _to,
    uint _amount
  ) internal
  {
    if(_amount > 0) {
      if(_tokenAddress == address(0)) {
        // https://diligence.consensys.net/blog/2019/09/stop-using-soliditys-transfer-now/
        _to.sendValue(_amount);
      } else {
        IERC20Upgradeable token = IERC20Upgradeable(_tokenAddress);
        token.safeTransfer(_to, _amount);
      }
    }
  }
}",398
RealWorld_BA_54_MixinPurchase_RealWord_20240821131628.log,54,MixinPurchase,22558,5708,28266,78.0,0.22695,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import './MixinDisable.sol';
import './MixinKeys.sol';
import './MixinLockCore.sol';
import './MixinFunds.sol';


/**
 * @title Mixin for the purchase-related functions.
 * @author HardlyDifficult
 * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply
 * separates logically groupings of code to ease readability.
 */
contract MixinPurchase is
  MixinFunds,
  MixinDisable,
  MixinLockCore,
  MixinKeys
{
  event RenewKeyPurchase(address indexed owner, uint newExpiration);

  /**
  * @dev Purchase function
  * @param _value the number of tokens to pay for this purchase >= the current keyPrice - any applicable discount
  * (_value is ignored when using ETH)
  * @param _recipient address of the recipient of the purchased key
  * @param _referrer address of the user making the referral
  * @param _data arbitrary data populated by the front-end which initiated the sale
  * @dev Setting _value to keyPrice exactly doubles as a security feature. That way if the lock owner increases the
  * price while my transaction is pending I can't be charged more than I expected (only applicable to ERC-20 when more
  * than keyPrice is approved for spending).
  */
  function purchase(
    uint256 _value,
    address _recipient,
    address _referrer,
    bytes calldata _data
  ) external payable
    onlyIfAlive
    notSoldOut
  {
    require(_recipient != address(0), 'INVALID_ADDRESS');

    // Assign the key
    Key storage toKey = keyByOwner[_recipient];
    uint idTo = toKey.tokenId;
    uint newTimeStamp;

    if (idTo == 0) {
      // Assign a new tokenId (if a new owner or previously transferred)
      _assignNewTokenId(toKey);
      // refresh the cached value
      idTo = toKey.tokenId;
      _recordOwner(_recipient, idTo);
      newTimeStamp = block.timestamp + expirationDuration;
      toKey.expirationTimestamp = newTimeStamp;

      // trigger event
      emit Transfer(
        address(0), // This is a creation.
        _recipient,
        idTo
      );
    } else if (toKey.expirationTimestamp > block.timestamp) {
      // This is an existing owner trying to extend their key
      newTimeStamp = toKey.expirationTimestamp + expirationDuration;
      toKey.expirationTimestamp = newTimeStamp;
      emit RenewKeyPurchase(_recipient, newTimeStamp);
    } else {
      // This is an existing owner trying to renew their expired key
      newTimeStamp = block.timestamp + expirationDuration;
      toKey.expirationTimestamp = newTimeStamp;

      // reset the key Manager to 0x00
      _setKeyManagerOf(idTo, address(0));

      emit RenewKeyPurchase(_recipient, newTimeStamp);
    }

    (uint inMemoryKeyPrice, uint discount, uint tokens) = _purchasePriceFor(_recipient, _referrer, _data);
    if (discount > 0)
    {
      unlockProtocol.recordConsumedDiscount(discount, tokens);
    }

    // Record price without any tips
    unlockProtocol.recordKeyPurchase(inMemoryKeyPrice, _referrer);

    // We explicitly allow for greater amounts of ETH or tokens to allow 'donations'
    uint pricePaid;
    if(tokenAddress != address(0))
    {
      pricePaid = _value;
      IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
      token.transferFrom(msg.sender, address(this), pricePaid);
    }
    else
    {
      pricePaid = msg.value;
    }
    require(pricePaid >= inMemoryKeyPrice, 'INSUFFICIENT_VALUE');

    if(address(onKeyPurchaseHook) != address(0))
    {
      onKeyPurchaseHook.onKeyPurchase(msg.sender, _recipient, _referrer, _data, inMemoryKeyPrice, pricePaid);
    }
  }

  /**
   * @notice returns the minimum price paid for a purchase with these params.
   * @dev minKeyPrice considers any discount from Unlock or the OnKeyPurchase hook
   */
  function purchasePriceFor(
    address _recipient,
    address _referrer,
    bytes calldata _data
  ) external view
    returns (uint minKeyPrice)
  {
    (minKeyPrice, , ) = _purchasePriceFor(_recipient, _referrer, _data);
  }

  /**
   * @notice returns the minimum price paid for a purchase with these params.
   * @dev minKeyPrice considers any discount from Unlock or the OnKeyPurchase hook
   * unlockDiscount and unlockTokens are the values returned from `computeAvailableDiscountFor`
   */
  function _purchasePriceFor(
    address _recipient,
    address _referrer,
    bytes memory _data
  ) internal view
    returns (uint minKeyPrice, uint unlockDiscount, uint unlockTokens)
  {
    if(address(onKeyPurchaseHook) != address(0))
    {
      minKeyPrice = onKeyPurchaseHook.keyPurchasePrice(msg.sender, _recipient, _referrer, _data);
    }
    else
    {
      minKeyPrice = keyPrice;
    }

    if(minKeyPrice > 0)
    {
      (unlockDiscount, unlockTokens) = unlockProtocol.computeAvailableDiscountFor(_recipient, minKeyPrice);
      require(unlockDiscount <= minKeyPrice, 'INVALID_DISCOUNT_FROM_UNLOCK');
      minKeyPrice -= unlockDiscount;
    }
  }
}",1179
RealWorld_BA_54_ILockKeyCancelHook_RealWord_20240821134037.log,54,ILockKeyCancelHook,5805,4734,10539,80.0,0.123705,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.17 <0.9.0;


/**
 * @notice Functions to be implemented by a keyCancelHook.
 * @dev Lock hooks are configured by calling `setEventHooks` on the lock.
 */
interface ILockKeyCancelHook
{
  /**
   * @notice If the lock owner has registered an implementer
   * then this hook is called with every key cancel.
   * @param operator the msg.sender issuing the cancel
   * @param to the account which had the key canceled
   * @param refund the amount sent to the `to` account (ETH or a ERC-20 token)
   */
  function onKeyCancel(
    address operator,
    address to,
    uint256 refund
  ) external;
}",165
RealWorld_BA_55_Governor_RealWord_20240821145136.log,55,Governor,4410,5552,9962,87.0,0.13309,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity 0.8.7;

import { Governor as ProxyGovernor } from ""../../../modules/maple-proxy-factory/contracts/test/accounts/Governor.sol"";

contract Governor is ProxyGovernor {}",56
RealWorld_BA_55_DebtLocker_RealWord_20240821144110.log,55,DebtLocker,48796,5241,54037,75.0,0.3488,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity ^0.8.7;

import { IMapleProxyFactory } from ""../modules/maple-proxy-factory/contracts/interfaces/IMapleProxyFactory.sol"";

import { ERC20Helper }  from ""../modules/erc20-helper/src/ERC20Helper.sol"";
import { Liquidator }   from ""../modules/liquidations/contracts/Liquidator.sol"";
import { MapleProxied } from ""../modules/maple-proxy-factory/contracts/MapleProxied.sol"";

import { IDebtLocker }                                                                from ""./interfaces/IDebtLocker.sol"";
import { IERC20Like, IMapleGlobalsLike, IMapleLoanLike, IPoolLike, IPoolFactoryLike } from ""./interfaces/Interfaces.sol"";

import { DebtLockerStorage } from ""./DebtLockerStorage.sol"";

/// @title DebtLocker interacts with Loans on behalf of PoolV1
contract DebtLocker is IDebtLocker, DebtLockerStorage, MapleProxied {

    /*****************/
    /*** Modifiers ***/
    /*****************/

    modifier whenProtocolNotPaused() {
        require(!IMapleGlobalsLike(_getGlobals()).protocolPaused(), ""DL:PROTOCOL_PAUSED"");
        _;
    }

    /********************************/
    /*** Administrative Functions ***/
    /********************************/

    function migrate(address migrator_, bytes calldata arguments_) external override {
        require(msg.sender == _factory(),        ""DL:M:NOT_FACTORY"");
        require(_migrate(migrator_, arguments_), ""DL:M:FAILED"");
    }

    function setImplementation(address newImplementation_) external override {
        require(msg.sender == _factory(),               ""DL:SI:NOT_FACTORY"");
        require(_setImplementation(newImplementation_), ""DL:SI:FAILED"");
    }

    function upgrade(uint256 toVersion_, bytes calldata arguments_) external override {
        require(msg.sender == _getPoolDelegate(), ""DL:U:NOT_POOL_DELEGATE"");

        emit Upgraded(toVersion_, arguments_);

        IMapleProxyFactory(_factory()).upgradeInstance(toVersion_, arguments_);
    }

    /*******************************/
    /*** Pool Delegate Functions ***/
    /*******************************/

    function acceptNewTerms(address refinancer_, bytes[] calldata calls_, uint256 amount_) external override whenProtocolNotPaused {
        require(msg.sender == _getPoolDelegate(), ""DL:ANT:NOT_PD"");

        IMapleLoanLike loan_ = IMapleLoanLike(_loan);

        require(
            (loan_.claimableFunds() + _fundsToCapture == 0) &&
            (loan_.principal() == _principalRemainingAtLastClaim),
            ""DL:ANT:NEED_TO_CLAIM""
        );

        require(amount_ == uint256(0) || ERC20Helper.transfer(loan_.fundsAsset(), address(_loan), amount_), ""DL:ANT:TRANSFER_FAILED"");

        loan_.acceptNewTerms(refinancer_, calls_, uint256(0));

        // NOTE: This must be set after accepting the new terms, which affects the loan principal.
        _principalRemainingAtLastClaim = loan_.principal();
    }

    function claim() external override whenProtocolNotPaused returns (uint256[7] memory details_) {
        require(msg.sender == _pool, ""DL:C:NOT_POOL"");

        return _repossessed ? _handleClaimOfRepossessed() : _handleClaim();
    }

    // TODO: Discuss pros/cons of pause on this function
    function pullFundsFromLiquidator(address token_, address destination_, uint256 amount_) external override {
        require(msg.sender == _getPoolDelegate(), ""DL:SA:NOT_PD"");
        
        Liquidator(_liquidator).pullFunds( token_,  destination_,  amount_);
    }

    function setAllowedSlippage(uint256 allowedSlippage_) external override whenProtocolNotPaused {
        require(msg.sender == _getPoolDelegate(), ""DL:SAS:NOT_PD"");

        emit AllowedSlippageSet(_allowedSlippage = allowedSlippage_);
    }

    function setAuctioneer(address auctioneer_) external override whenProtocolNotPaused {
        require(msg.sender == _getPoolDelegate(), ""DL:SA:NOT_PD"");

        emit AuctioneerSet(auctioneer_);

        Liquidator(_liquidator).setAuctioneer(auctioneer_);
    }

    function setFundsToCapture(uint256 amount_) override external whenProtocolNotPaused {
        require(msg.sender == _getPoolDelegate(), ""DL:SFTC:NOT_PD"");

        emit FundsToCaptureSet(_fundsToCapture = amount_);
    }

    function setMinRatio(uint256 minRatio_) external override whenProtocolNotPaused {
        require(msg.sender == _getPoolDelegate(), ""DL:SMR:NOT_PD"");

        emit MinRatioSet(_minRatio = minRatio_);
    }

    // Pool delegate can prematurely stop liquidation when there's still significant amount to be liquidated.
    function stopLiquidation() external override {
        require(msg.sender == _getPoolDelegate(), ""DL:SL:NOT_PD"");

        _liquidator = address(0);

        emit LiquidationStopped();
    }

    function triggerDefault() external override whenProtocolNotPaused {
        require(msg.sender == _pool, ""DL:TD:NOT_POOL"");

        require(
            (IMapleLoanLike(_loan).claimableFunds() == 0) &&
            (IMapleLoanLike(_loan).principal() == _principalRemainingAtLastClaim),
            ""DL:TD:NEED_TO_CLAIM""
        );

        _repossessed = true;

        // Ensure that principal is always up to date, claim function will clear out all payments, but on refinance we need to ensure that
        // accounting is updated properly when principal is updated and there are no claimable funds.

        // Repossess collateral and funds from Loan.
        ( uint256 collateralAssetAmount, ) = IMapleLoanLike(_loan).repossess(address(this));

        address collateralAsset = IMapleLoanLike(_loan).collateralAsset();
        address fundsAsset      = IMapleLoanLike(_loan).fundsAsset();

        if (collateralAsset == fundsAsset || collateralAssetAmount == 0) return;

        // Deploy Liquidator contract and transfer collateral.
        require(
            ERC20Helper.transfer(
                collateralAsset,
                _liquidator = address(new Liquidator(address(this), collateralAsset, fundsAsset, address(this), address(this))),
                collateralAssetAmount
            ),
            ""DL:TD:TRANSFER""
       );
    }

    /**************************/
    /*** Internal Functions ***/
    /**************************/

    function _handleClaim() internal returns (uint256[7] memory details_) {
        // Get loan state variables needed
        uint256 claimableFunds = IMapleLoanLike(_loan).claimableFunds();

        require(claimableFunds > uint256(0), ""DL:HC:NOTHING_TO_CLAIM"");

        // Send funds to pool
        IMapleLoanLike(_loan).claimFunds(claimableFunds, _pool);

        uint256 currentPrincipalRemaining = IMapleLoanLike(_loan).principal();

        // Determine how much of `claimableFunds` is principal
        uint256 principalPortion = _principalRemainingAtLastClaim - currentPrincipalRemaining;

        // Update state variables
        _principalRemainingAtLastClaim = currentPrincipalRemaining;

        // Set return values
        // Note: All fees get deducted and transferred during `loan.fundLoan()` that omits the need to
        // return the fees distribution to the pool.
        details_[0] = claimableFunds;
        details_[1] = claimableFunds - principalPortion;
        details_[2] = principalPortion;

        uint256 amountOfFundsToCapture = _fundsToCapture;

        if (amountOfFundsToCapture > uint256(0)) {
            details_[0] += amountOfFundsToCapture;
            details_[2] += amountOfFundsToCapture;

            _fundsToCapture = uint256(0);

            require(ERC20Helper.transfer(IMapleLoanLike(_loan).fundsAsset(), _pool, amountOfFundsToCapture), ""DL:HC:CAPTURE_FAILED"");
        }
    }

    function _handleClaimOfRepossessed() internal returns (uint256[7] memory details_) {
        require(!_isLiquidationActive(), ""DL:HCOR:LIQ_NOT_FINISHED"");

        address fundsAsset       = IMapleLoanLike(_loan).fundsAsset();
        uint256 principalToCover = _principalRemainingAtLastClaim;      // Principal remaining at time of liquidation
        uint256 fundsCaptured    = _fundsToCapture;

        // Funds recovered from liquidation and any unclaimed previous payment amounts
        uint256 recoveredFunds = IERC20Like(fundsAsset).balanceOf(address(this)) - fundsCaptured;

        // If `recoveredFunds` is greater than `principalToCover`, the remaining amount is treated as interest in the context of the pool.
        // If `recoveredFunds` is less than `principalToCover`, the difference is registered as a shortfall.
        details_[0] = recoveredFunds + fundsCaptured;
        details_[1] = recoveredFunds > principalToCover ? recoveredFunds - principalToCover : 0;
        details_[2] = fundsCaptured;
        details_[5] = recoveredFunds > principalToCover ? principalToCover : recoveredFunds;
        details_[6] = principalToCover > recoveredFunds ? principalToCover - recoveredFunds : 0;

        _fundsToCapture = uint256(0);
        _repossessed    = false;

        require(ERC20Helper.transfer(fundsAsset, _pool, recoveredFunds + fundsCaptured), ""DL:HCOR:TRANSFER"");
    }

    /**********************/
    /*** View Functions ***/
    /**********************/

    function allowedSlippage() external view override returns (uint256 allowedSlippage_) {
        return _allowedSlippage;
    }

    function amountRecovered() external view override returns (uint256 amountRecovered_) {
        return _amountRecovered;
    }

    function factory() external view override returns (address factory_) {
        return _factory();
    }

    function fundsToCapture() external view override returns (uint256 fundsToCapture_) {
        return _fundsToCapture;
    }

    function getExpectedAmount(uint256 swapAmount_) external view override whenProtocolNotPaused returns (uint256 returnAmount_) {
        address collateralAsset = IMapleLoanLike(_loan).collateralAsset();
        address fundsAsset      = IMapleLoanLike(_loan).fundsAsset();

        uint256 oracleAmount =
            swapAmount_
                * IMapleGlobalsLike(_getGlobals()).getLatestPrice(collateralAsset)  // Convert from `fromAsset` value.
                * 10 ** IERC20Like(fundsAsset).decimals()                           // Convert to `toAsset` decimal precision.
                * (10_000 - _allowedSlippage)                                       // Multiply by allowed slippage basis points
                / IMapleGlobalsLike(_getGlobals()).getLatestPrice(fundsAsset)       // Convert to `toAsset` value.
                / 10 ** IERC20Like(collateralAsset).decimals()                      // Convert from `fromAsset` decimal precision.
                / 10_000;                                                           // Divide basis points for slippage

        uint256 minRatioAmount = swapAmount_ * _minRatio / 10 ** IERC20Like(collateralAsset).decimals();

        return oracleAmount > minRatioAmount ? oracleAmount : minRatioAmount;
    }

    function implementation() external view override returns (address) {
        return _implementation();
    }

    function investorFee() external view override returns (uint256 investorFee_) {
        return IMapleGlobalsLike(_getGlobals()).investorFee();
    }

    function liquidator() external view override returns (address liquidator_) {
        return _liquidator;
    }

    function loan() external view override returns (address loan_) {
        return _loan;
    }

    function mapleTreasury() external view override returns (address mapleTreasury_) {
        return IMapleGlobalsLike(_getGlobals()).mapleTreasury();
    }

    function minRatio() external view override returns (uint256 minRatio_) {
        return _minRatio;
    }

    function pool() external view override returns (address pool_) {
        return _pool;
    }

    function poolDelegate() external override view returns(address) {
        return _getPoolDelegate();
    }

    function principalRemainingAtLastClaim() external view override returns (uint256 principalRemainingAtLastClaim_) {
        return _principalRemainingAtLastClaim;
    }

    function repossessed() external view override returns (bool repossessed_) {
        return _repossessed;
    }

    function treasuryFee() external view override returns (uint256 treasuryFee_) {
        return IMapleGlobalsLike(_getGlobals()).treasuryFee();
    }

    /*******************************/
    /*** Internal View Functions ***/
    /*******************************/

    function _getGlobals() internal view returns (address) {
        return IPoolFactoryLike(IPoolLike(_pool).superFactory()).globals();
    }

    function _getPoolDelegate() internal view returns(address) {
        return IPoolLike(_pool).poolDelegate();
    }

    function _isLiquidationActive() internal view returns (bool) {
        return (_liquidator != address(0)) && (IERC20Like(IMapleLoanLike(_loan).collateralAsset()).balanceOf(_liquidator) > 0);
    }

}",2880
RealWorld_BA_55_DebtLockerFactory_RealWord_20240821144227.log,55,DebtLockerFactory,8086,5693,13779,83.0,0.15429,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity ^0.8.7;

import { IMapleProxyFactory, MapleProxyFactory } from ""../modules/maple-proxy-factory/contracts/MapleProxyFactory.sol"";

import { IDebtLockerFactory } from ""./interfaces/IDebtLockerFactory.sol"";

/// @title Deploys DebtLocker proxy instances.
contract DebtLockerFactory is IDebtLockerFactory, MapleProxyFactory {

    uint8 public constant override factoryType = uint8(1);

    constructor(address mapleGlobals_) MapleProxyFactory(mapleGlobals_) {
        require(mapleGlobals_ != address(0));
    }

    function newLocker(address loan_) external override returns (address debtLocker_) {
        bytes memory arguments = abi.encode(loan_, msg.sender);

        bool success_;
        ( success_, debtLocker_ ) = _newInstance(defaultVersion, arguments);
        require(success_, ""DLF:NL:FAILED"");

        emit InstanceDeployed(defaultVersion, debtLocker_, arguments);
    }

    function createInstance(bytes calldata arguments_, bytes32 salt_)
        public override(IMapleProxyFactory, MapleProxyFactory) virtual returns (address instance_)
    {}

    function getInstanceAddress(bytes calldata arguments_, bytes32 salt_)
        public view override(IMapleProxyFactory, MapleProxyFactory) virtual returns (address instanceAddress_)
    {}

}",285
RealWorld_BA_55_IDebtLockerFactory_RealWord_20240821145554.log,55,IDebtLockerFactory,5531,4195,9726,68.0,0.111555,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity ^0.8.7;

import { IMapleProxyFactory } from ""../../modules/maple-proxy-factory/contracts/interfaces/IMapleProxyFactory.sol"";

/// @title Deploys DebtLocker proxy instances.
interface IDebtLockerFactory is IMapleProxyFactory {

    /**
     * @dev The Maple factory type (to be deprecated).
     */
    function factoryType() external view returns (uint8 factoryType_);

    /**
     * @dev Deploys a new DebtLocker proxy instance.
     * @param loan_ Loan contract that corresponds to DebtLocker.
     */
    function newLocker(address loan_) external returns (address debtLocker_);

}",151
RealWorld_BA_55_DebtLockerStorage_RealWord_20240821144511.log,55,DebtLockerStorage,5315,4799,10114,83.0,0.122555,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity ^0.8.7;

/// @title DebtLockerStorage maps the storage layout of a DebtLocker.
contract DebtLockerStorage {

    bool internal _repossessed;

    address internal _loan;
    address internal _liquidator;
    address internal _pool;

    uint256 internal _allowedSlippage;
    uint256 internal _amountRecovered;
    uint256 internal _fundsToCapture;
    uint256 internal _minRatio;
    uint256 internal _principalRemainingAtLastClaim;

}",119
RealWorld_BA_55_DebtLockerInitializer_RealWord_20240821144353.log,55,DebtLockerInitializer,8358,5507,13865,76.0,0.15193,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity ^0.8.7;

import { IMapleGlobalsLike, IMapleLoanLike, IPoolFactoryLike, IPoolLike }  from ""./interfaces/Interfaces.sol"";

import { DebtLockerStorage } from ""./DebtLockerStorage.sol"";

/// @title DebtLockerInitializer is intended to initialize the storage of a DebtLocker proxy.
contract DebtLockerInitializer is DebtLockerStorage {

    function encodeArguments(address loan_, address pool_) external pure returns (bytes memory encodedArguments_) {
        return abi.encode(loan_, pool_);
    }

    function decodeArguments(bytes calldata encodedArguments_) public pure returns (address loan_, address pool_) {
        ( loan_, pool_ ) = abi.decode(encodedArguments_, (address, address));
    }

    fallback() external {
        ( address loan_, address pool_ ) = decodeArguments(msg.data);

        IMapleGlobalsLike globals = IMapleGlobalsLike(IPoolFactoryLike(IPoolLike(pool_).superFactory()).globals());

        require(globals.isValidCollateralAsset(IMapleLoanLike(loan_).collateralAsset()), ""DL:I:INVALID_COLLATERAL_ASSET"");
        require(globals.isValidLiquidityAsset(IMapleLoanLike(loan_).fundsAsset()),       ""DL:I:INVALID_FUNDS_ASSET"");

        _loan = loan_;
        _pool = pool_;

        _principalRemainingAtLastClaim = IMapleLoanLike(loan_).principalRequested();
    }

}",316
RealWorld_BA_55_DebtLockerHarness_RealWord_20240821144904.log,55,DebtLockerHarness,5220,4858,10078,69.0,0.12326,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity ^0.8.7;

import { DebtLocker } from ""../../DebtLocker.sol"";

contract DebtLockerHarness is DebtLocker {

    /*************************/
    /*** Harness Functions ***/
    /*************************/

    function getGlobals() external view returns (address) {
        return _getGlobals();
    }

    function getPoolDelegate() external view returns(address) {
        return _getPoolDelegate();
    }

    function isLiquidationActive() external view returns (bool) {
        return _isLiquidationActive();
    }

}",124
RealWorld_BA_55_Interfaces_RealWord_20240821145704.log,55,Interfaces,10631,5680,16311,89.0,0.166755,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity ^0.8.7;

interface IERC20Like {

    function decimals() external view returns (uint256 decimals_);

    function balanceOf(address account_) external view returns (uint256 balanceOf_);

}

interface ILiquidatorLike {

    function auctioneer() external view returns (address auctioneer_);
}

interface IMapleGlobalsLike {

   function defaultUniswapPath(address fromAsset_, address toAsset_) external view returns (address intermediateAsset_);

   function getLatestPrice(address asset_) external view returns (uint256 price_);

   function investorFee() external view returns (uint256 investorFee_);

   function isValidCollateralAsset(address asset_) external view returns (bool isValid_);

   function isValidLiquidityAsset(address asset_) external view returns (bool isValid_);

   function mapleTreasury() external view returns (address mapleTreasury_);

   function protocolPaused() external view returns (bool protocolPaused_);

   function treasuryFee() external view returns (uint256 treasuryFee_);

}

interface IMapleLoanLike {

    function acceptNewTerms(address refinancer_, bytes[] calldata calls_, uint256 amount_) external;

    function claimableFunds() external view returns (uint256 claimableFunds_);

    function collateralAsset() external view returns (address collateralAsset_);

    function fundsAsset() external view returns (address fundsAsset_);

    function lender() external view returns (address lender_);

    function principal() external view returns (uint256 principal_);

    function principalRequested() external view returns (uint256 principalRequested_);

    function claimFunds(uint256 amount_, address destination_) external;

    function repossess(address destination_) external returns (uint256 collateralAssetAmount_, uint256 fundsAssetAmount_);

}

interface IPoolLike {

    function poolDelegate() external view returns (address poolDelegate_);

    function superFactory() external view returns (address superFactory_);

}

interface IPoolFactoryLike {

    function globals() external pure returns (address globals_);

}

interface IUniswapRouterLike {

    function swapExactTokensForTokens(
        uint amountIn_,
        uint amountOutMin_,
        address[] calldata path_,
        address to_,
        uint deadline_
    ) external returns (uint[] memory amounts_);

}",465
RealWorld_BA_55_IDebtLocker_RealWord_20240821145425.log,55,IDebtLocker,27030,5648,32678,86.0,0.24811,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity ^0.8.7;

import { IMapleProxied } from ""../../modules/maple-proxy-factory/contracts/interfaces/IMapleProxied.sol"";

/// @title DebtLocker holds custody of LoanFDT tokens.
interface IDebtLocker is IMapleProxied {

    /**************/
    /*** Events ***/
    /**************/

    /**
     * @dev   Emitted when `setAllowedSlippage` is called.
     * @param newSlippage_ New value for `allowedSlippage`.
     */
    event AllowedSlippageSet(uint256 newSlippage_);

    /**
     * @dev   Emitted when `setAuctioneer` is called.
     * @param newAuctioneer_ New value for `auctioneer` in Liquidator.
     */
    event AuctioneerSet(address newAuctioneer_);

    /**
     * @dev   Emitted when `fundsToCapture` is set.
     * @param amount_ The amount of funds that will be captured next claim.
     */
    event FundsToCaptureSet(uint256 amount_);

    /**
     * @dev   Emitted when `stopLiquidation` is called.
     */
    event LiquidationStopped();

    /**
     * @dev   Emitted when `setMinRatio` is called.
     * @param newMinRatio_ New value for `minRatio`.
     */
    event MinRatioSet(uint256 newMinRatio_);

    /*****************/
    /*** Functions ***/
    /*****************/

    /**
     * @dev Accept the new loan terms and trigger a refinance.
     */
    function acceptNewTerms(address refinancer_, bytes[] calldata calls_, uint256 amount_) external;

    /**
     *  @dev    Claims funds to send to Pool. Handles funds from payments and liquidations.
     *  @dev    Only the Pool can call this function.
     *  @return details_
     *              [0] => Total Claimed.
     *              [1] => Interest Claimed.
     *              [2] => Principal Claimed.
     *              [3] => Pool Delegate Fees Claimed.
     *              [4] => Excess Returned Claimed.
     *              [5] => Amount Recovered (from Liquidation).
     *              [6] => Default Suffered.
     */
    function claim() external returns (uint256[7] memory details_);

    /**
     * @dev Returns the annualized establishment fee that will go to the PoolDelegate.
     */
    function investorFee() external view returns (uint256 investorFee_);

    /**
     * @dev Returns the address of the Maple Treasury.
     */
    function mapleTreasury() external view returns (address mapleTreasury_);

    /**
     * @dev   Allows the poolDelegate to pull some funds from liquidator contract
     * @param token_       The token address of the funds.
     * @param destination_ The destination address of captured funds.
     * @param amount_      The amount to pull.
     */
    function pullFundsFromLiquidator(address token_, address destination_, uint256 amount_) external;

    /**
     * @dev Returns the annualized establishment fee that will go to the Maple Treasury.
     */
    function treasuryFee() external view returns (uint256 treasuryFee_);

    /**
     * @dev Returns the address of the Pool Delegate that has control of the DebtLocker.
     */
    function poolDelegate() external view returns (address poolDelegate_);

    /**
     * @dev Repossesses funds and collateral from a loan and transfers them to the Liquidator.
     */
    function triggerDefault() external;

    /**
     * @dev   Sets the allowed slippage for auctioneer (used to determine expected amount to be returned in flash loan).
     * @param allowedSlippage_ Basis points representation of allowed percent slippage from market price.
     */
    function setAllowedSlippage(uint256 allowedSlippage_) external;

    /**
     * @dev   Sets the auctioneer contract for the liquidator.
     * @param auctioneer_ Address of auctioneer contract.
     */
    function setAuctioneer(address auctioneer_) external;

    /**
     * @dev   Sets the minimum ""price"" for auctioneer (used to determine expected amount to be returned in flash loan).
     * @param minRatio_ Price in fundsAsset precision (e.g., 10 * 10 ** 6 for $10 price for USDC).
     */
    function setMinRatio(uint256 minRatio_) external;

    /**
     * @dev    Returns the expected amount to be returned to the liquidator during a flash borrower liquidation.
     * @param  swapAmount_   Amount of collateralAsset being swapped.
     * @return returnAmount_ Amount of fundsAsset that must be returned in the same transaction.
     */
    function getExpectedAmount(uint256 swapAmount_) external view returns (uint256 returnAmount_);

    /**
     * @dev   Returns the expected amount to be returned to the liquidator during a flash borrower liquidation.
     * @param amount_ The amount of funds that should be captured next claim.
     */
    function setFundsToCapture(uint256 amount_) external;

    /**
     * @dev Called by the PoolDelegate in case of a DoS, where a user transfers small amounts of collateralAsset into the Liquidator
     * @dev to make `_isLiquidationActive` remain true.
     */
    function stopLiquidation() external;

    /*************/
    /*** State ***/
    /*************/

    /**
     * @dev The Loan contract this locker is holding tokens for.
     */
    function loan() external view returns (address loan_);

    /**
     * @dev The address of the liquidator.
     */
    function liquidator() external view returns (address liquidator_);

    /**
     * @dev The owner of this Locker (the Pool).
     */
    function pool() external view returns (address pool_);

    /**
     * @dev The maximum slippage allowed during liquidations.
     */
    function allowedSlippage() external view returns (uint256 allowedSlippage_);

    /**
     * @dev The amount in funds asset recovered during liquidations.
     */
    function amountRecovered() external view returns (uint256 amountRecovered_);

    /**
     * @dev The minimum exchange ration between funds asset and collateral asset.
     */
    function minRatio() external view returns (uint256 minRatio_);

    /**
     * @dev Returns the principal that was present at the time of last claim.
     */
    function principalRemainingAtLastClaim() external view returns (uint256 principalRemainingAtLastClaim_);

    /**
     * @dev Returns if the funds have been repossessed.
     */
    function repossessed() external view returns (bool repossessed_);

    /**
     * @dev Returns the amount of funds that will be captured next claim.
     */
    function fundsToCapture() external view returns (uint256 fundsToCapture_);

}",1465
